// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Dependencies will be automatically added here, the following line must declare ionic as first dependency
// and should not be split into multiple lines, see gulpfile.js.
angular.module('mm', ['ionic', 'mm.core', 'mm.core.contentlinks', 'mm.core.course', 'mm.core.courses', 'mm.core.login', 'mm.core.settings', 'mm.core.sidemenu', 'mm.core.textviewer', 'mm.core.user', 'mm.addons.calendar', 'mm.addons.coursecompletion', 'mm.addons.files', 'mm.addons.frontpage', 'mm.addons.grades', 'mm.addons.messages', 'mm.addons.mod_assign', 'mm.addons.mod_book', 'mm.addons.mod_chat', 'mm.addons.mod_choice', 'mm.addons.mod_folder', 'mm.addons.mod_forum', 'mm.addons.mod_glossary', 'mm.addons.mod_imscp', 'mm.addons.mod_label', 'mm.addons.mod_lti', 'mm.addons.mod_page', 'mm.addons.mod_resource', 'mm.addons.mod_scorm', 'mm.addons.mod_survey', 'mm.addons.mod_url', 'mm.addons.notes', 'mm.addons.notifications', 'mm.addons.participants', 'mm.addons.pushnotifications', 'mm.addons.remotestyles', 'ngCordova', 'angular-md5', 'pascalprecht.translate', 'ngAria', 'ngIOS9UIWebViewPatch', 'nvd3'])

.run(["$ionicPlatform", function($ionicPlatform) {
  $ionicPlatform.ready(function() {
    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
    }
    if (window.StatusBar) {
      StatusBar.styleDefault();
    }
  });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core', ['pascalprecht.translate'])

.constant('mmCoreSessionExpired', 'mmCoreSessionExpired')
.constant('mmCoreUserDeleted', 'mmCoreUserDeleted')
.constant('mmCoreSecondsYear', 31536000)
.constant('mmCoreSecondsDay', 86400)
.constant('mmCoreSecondsHour', 3600)
.constant('mmCoreSecondsMinute', 60)

// States for downloading files/modules.
.constant('mmCoreDownloaded', 'downloaded')
.constant('mmCoreDownloading', 'downloading')
.constant('mmCoreNotDownloaded', 'notdownloaded')
.constant('mmCoreOutdated', 'outdated')
.constant('mmCoreNotDownloadable', 'notdownloadable')

.constant('mmCoreWifiDownloadThreshold', 104857600) // 100MB.
.constant('mmCoreDownloadThreshold', 10485760) // 10MB.

.config(["$stateProvider", "$provide", "$ionicConfigProvider", "$httpProvider", "$mmUtilProvider", "$mmLogProvider", "$compileProvider", "$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($stateProvider, $provide, $ionicConfigProvider, $httpProvider, $mmUtilProvider,
        $mmLogProvider, $compileProvider, $mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {

    // Set tabs to bottom on Android.
    $ionicConfigProvider.platform.android.tabs.position('bottom');

    // Decorate $ionicPlatform.
    $provide.decorator('$ionicPlatform', ['$delegate', '$window', function($delegate, $window) {
        $delegate.isTablet = function() {
            var mq = 'only screen and (min-width: 768px) and (-webkit-min-device-pixel-ratio: 1)';
            return $window.matchMedia(mq).matches;
        };
        return $delegate;
    }]);

    /**
     * Decorate $log. Usage:
     * $log = $log.getInstance('MyFactory')
     * $log.debug('My message') -> "dd/mm/aaaa hh:mm:ss MyFactory: My message"
     */
    $provide.decorator('$log', ['$delegate', $mmLogProvider.logDecorator]);

    $stateProvider
        .state('redirect', {
            url: '/redirect',
            params: {
                siteid: null,
                state: null,
                params: null
            },
            cache: false,
            controller: ["$scope", "$state", "$stateParams", "$mmSite", "$mmSitesManager", "$ionicHistory", function($scope, $state, $stateParams, $mmSite, $mmSitesManager, $ionicHistory) {

                $ionicHistory.nextViewOptions({disableBack: true});

                function loadSiteAndGo() {
                    $mmSitesManager.loadSite($stateParams.siteid).then(function() {
                        $state.go($stateParams.state, $stateParams.params);
                    }, function() {
                        // Site doesn't exist.
                        $state.go('mm_login.sites');
                    });
                }

                $scope.$on('$ionicView.enter', function() {
                    if ($mmSite.isLoggedIn()) {
                        if ($stateParams.siteid && $stateParams.siteid != $mmSite.getId()) {
                            // Notification belongs to a different site. Change site.
                            $mmSitesManager.logout().then(function() {
                                loadSiteAndGo();
                            });
                        } else {
                            $state.go($stateParams.state, $stateParams.params);
                        }
                    } else {
                        if ($stateParams.siteid) {
                            loadSiteAndGo();
                        } else {
                            $state.go('mm_login.sites');
                        }
                    }
                });
            }]
        });

    // This code is to be able to get data sent with $http.post using $_POST variable.
    // Otherwise all the data ends up in php://input and seems like local/mobile/check.php doesn't like it.
    $httpProvider.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8';
    $httpProvider.defaults.transformRequest = [function(data) {
        return angular.isObject(data) && String(data) !== '[object File]' ? $mmUtilProvider.param(data) : data;
    }];

    // Add some protocols to safe protocols.
    function addProtocolIfMissing(list, protocol) {
        if (list.indexOf(protocol) == -1) {
            list = list.replace('https?', 'https?|' + protocol);
        }
        return list;
    }

    var hreflist = $compileProvider.aHrefSanitizationWhitelist().source,
        imglist = $compileProvider.imgSrcSanitizationWhitelist().source;

    hreflist = addProtocolIfMissing(hreflist, 'file');
    hreflist = addProtocolIfMissing(hreflist, 'tel');
    hreflist = addProtocolIfMissing(hreflist, 'mailto');
    hreflist = addProtocolIfMissing(hreflist, 'geo');
    hreflist = addProtocolIfMissing(hreflist, 'filesystem'); // For HTML5 FileSystem.
    imglist = addProtocolIfMissing(imglist, 'filesystem'); // For HTML5 FileSystem.

    $compileProvider.aHrefSanitizationWhitelist(hreflist);
    $compileProvider.imgSrcSanitizationWhitelist(imglist);

    // Register the core init process, this should be the very first thing.
    $mmInitDelegateProvider.registerProcess('mmAppInit', '$mmApp.initProcess', mmInitDelegateMaxAddonPriority + 400, true);

    // Register upgrade check process, this should happen almost before everything else.
    $mmInitDelegateProvider.registerProcess('mmUpdateManager', '$mmUpdateManager.check', mmInitDelegateMaxAddonPriority + 300, true);
}])

.run(["$ionicPlatform", "$ionicBody", "$window", "$mmEvents", "$mmInitDelegate", "mmCoreEventKeyboardShow", "mmCoreEventKeyboardHide", function($ionicPlatform, $ionicBody, $window, $mmEvents, $mmInitDelegate, mmCoreEventKeyboardShow, mmCoreEventKeyboardHide) {
    // Execute all the init processes.
    $mmInitDelegate.executeInitProcesses();

    // When the platform is ready.
    $ionicPlatform.ready(function() {
        var checkTablet = function() {
            $ionicBody.enableClass($ionicPlatform.isTablet(), 'tablet');
        };
        ionic.on('resize', checkTablet, $window);
        checkTablet();

        // Listen for keyboard events. We don't use $cordovaKeyboard because it doesn't support keyboardHeight property.
        $window.addEventListener('native.keyboardshow', function(e) {
            $mmEvents.trigger(mmCoreEventKeyboardShow, e);
        });
        $window.addEventListener('native.keyboardhide', function(e) {
            $mmEvents.trigger(mmCoreEventKeyboardHide, e);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmAddonManager
 * @module mm.core
 * @description
 * This service provides functions related to addons, like checking if an addon is available.
 */
.factory('$mmAddonManager', ["$log", "$injector", function($log, $injector) {

    $log = $log.getInstance('$mmAddonManager');

    var self = {},
        instances = {};

    /**
     * Get a service instance if it's available.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmAddonManager#get
     * @param  {String} name Service name.
     * @return {Object}      Service instance.
     */
    self.get = function(name) {
        if (self.isAvailable(name)) {
            return instances[name];
        }
    };

    /**
     * Check if a service is available.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmAddonManager#isAvailable
     * @param  {String} name Service name.
     * @return {Boolean}     True if available, false otherwise.
     */
    self.isAvailable = function(name) {
        if (!name) {
            return false;
        }

        if (instances[name]) {
            return true;
        }

        try {
            instances[name] = $injector.get(name);
            return true;
        } catch(ex) {
            $log.warn('Service not available: '+name);
            return false;
        }
    };

    return self;
}]);

/**
 * ==================  angular-ios9-uiwebview.patch.js v1.1.0 ==================
 *
 * This patch works around iOS9 UIWebView regression that causes infinite digest
 * errors in Angular.
 *
 * The patch can be applied to Angular 1.2.0 – 1.4.5. Newer versions of Angular
 * have the workaround baked in.
 *
 * To apply this patch load/bundle this file with your application and add a
 * dependency on the "ngIOS9Patch" module to your main app module.
 *
 * For example:
 *
 * ```
 * angular.module('myApp', ['ngRoute'])`
 * ```
 *
 * becomes
 *
 * ```
 * angular.module('myApp', ['ngRoute', 'ngIOS9UIWebViewPatch'])
 * ```
 *
 *
 * More info:
 * - https://openradar.appspot.com/22186109
 * - https://github.com/angular/angular.js/issues/12241
 * - https://github.com/driftyco/ionic/issues/4082
 *
 *
 * @license AngularJS
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */

angular.module('ngIOS9UIWebViewPatch', ['ng']).config(["$provide", function($provide) {
  $provide.decorator('$browser', ['$delegate', '$window', function($delegate, $window) {

    if (isIOS9UIWebView($window.navigator.userAgent)) {
      return applyIOS9Shim($delegate);
    }

    return $delegate;

    function isIOS9UIWebView(userAgent) {
      return /(iPhone|iPad|iPod).* OS 9_\d/.test(userAgent) && !/Version\/9\./.test(userAgent);
    }

    function applyIOS9Shim(browser) {
      var pendingLocationUrl = null;
      var originalUrlFn= browser.url;

      browser.url = function() {
        if (arguments.length) {
          pendingLocationUrl = arguments[0];
          return originalUrlFn.apply(browser, arguments);
        }

        return pendingLocationUrl || originalUrlFn.apply(browser, arguments);
      };

      window.addEventListener('popstate', clearPendingLocationUrl, false);
      window.addEventListener('hashchange', clearPendingLocationUrl, false);

      function clearPendingLocationUrl() {
        pendingLocationUrl = null;
      }

      return browser;
    }
  }]);
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Factory to provide some global functionalities, like access to the global app database.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmApp
 * @description
 * This provider is the interface with the app database. The modules that need to store
 * information here need to register their stores.
 *
 * Example:
 *
 * .config(function($mmAppProvider) {
 *      $mmAppProvider.registerStore({
 *          name: 'settings',
 *          keyPath: 'name'
 *      });
 *  })
 */
.provider('$mmApp', ["$stateProvider", function($stateProvider) {

    /** Define the app storage schema. */
    var DBNAME = 'MoodleMobile',
        dbschema = {
            stores: []
        },
        dboptions = {
            autoSchema: true
        };

    /**
     * Register a store schema.
     *
     * @param  {Object} store The store object definition.
     * @return {Void}
     */
    this.registerStore = function(store) {
        if (typeof(store.name) === 'undefined') {
            console.log('$mmApp: Error: store name is undefined.');
            return;
        } else if (storeExists(store.name)) {
            console.log('$mmApp: Error: store ' + store.name + ' is already defined.');
            return;
        }
        dbschema.stores.push(store);
    };

    /**
     * Register multiple stores at once.
     *
     * @param  {Array} stores Array of store objects.
     * @return {Void}
     */
    this.registerStores = function(stores) {
        var self = this;
        angular.forEach(stores, function(store) {
            self.registerStore(store);
        });
    };

    /**
     * Check if a store is already defined.
     *
     * @param  {String} name The name of the store.
     * @return {Boolean} True when the store was already defined.
     */
    function storeExists(name) {
        var exists = false;
        angular.forEach(dbschema.stores, function(store) {
            if (store.name === name) {
                exists = true;
            }
        });
        return exists;
    }

    this.$get = ["$mmDB", "$cordovaNetwork", "$log", "$injector", "$ionicPlatform", function($mmDB, $cordovaNetwork, $log, $injector, $ionicPlatform) {

        $log = $log.getInstance('$mmApp');

        var db,
            self = {};

        /**
         * Create a new state in the UI-router.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#createState
         * @param {String} name   State name.
         * @param {Object} config State config.
         */
        self.createState = function(name, config) {
            $log.debug('Adding new state: '+name);
            $stateProvider.state(name, config);
        };

        /**
         * Closes the keyboard if plugin is available.
         *
         * @return {Boolean} True if plugin is available, false otherwise.
         */
        self.closeKeyboard = function() {
            if (typeof cordova != 'undefined' && cordova.plugins && cordova.plugins.Keyboard && cordova.plugins.Keyboard.close) {
                cordova.plugins.Keyboard.close();
                return true;
            }
            return false;
        };

        /**
         * Get the application global database.
         * @return {Object} App's DB.
         */
        self.getDB = function() {
            if (typeof db == 'undefined') {
                db = $mmDB.getDB(DBNAME, dbschema, dboptions);
            }

            return db;
        };

        /**
         * Get the database schema.
         *
         * Do not use this method to modify the schema. Use $mmAppProvider#registerStore instead.
         *
         * @return {Object} The schema.
         */
        self.getSchema = function() {
            return dbschema;
        };

        /**
         * Core init process for the app.
         *
         * @description
         * This should be the first init process of all, no other process should run until we
         * are certain that the cordova plugins are loaded, which is what $ionicPlatform tells us.
         * There should not be any logic acting on the database here as the upgrade is
         * another process and has not run yet at this point.
         *
         * Keep this fast.
         *
         * Reserved for core use, do not call directly.
         *
         * @module mm.core
         * @ngdoc service
         * @name $mmApp#initProcess
         * @protected
         * @return {Promise}
         */
        self.initProcess = function() {
            return $ionicPlatform.ready();
        };

        /**
         * Checks if the app is running in a real device with cordova-plugin-device installed.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#isDevice
         * @return {Bool} True if device is defined, false otherwise.
         */
        self.isDevice = function() {
            return !!window.device;
        };

        /**
         * Returns whether we are online.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#isOnline
         * @return {Bool} True when we are.
         * @description
         * This methods returns whether the app is online or not.
         * Note that a browser is always considered being online.
         */
        self.isOnline = function() {
            var online = typeof navigator.connection === 'undefined' || $cordovaNetwork.isOnline();
            // Double check we are not online because we cannot rely 100% in Cordova APIs.
            if (!online && navigator.onLine) {
                online = true;
            }
            return online;
        };

        /*
         * Check if device uses a limited connection.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#isNetworkAccessLimited
         * @return {Boolean} True if device used a limited connection, false otherwise.
         * @description
         * This method allows for us to first check if cordova is loaded,
         * otherwise exceptions can be thrown when trying on a browser.
         */
        self.isNetworkAccessLimited = function() {
            if (typeof navigator.connection === 'undefined') {
                // Plugin not defined, probably in browser.
                return false;
            }
            var type = $cordovaNetwork.getNetwork();
            var limited = [Connection.CELL_2G, Connection.CELL_3G, Connection.CELL_4G, Connection.CELL];
            return limited.indexOf(type) > -1;
        };

        /**
         * Instantly returns if the app is ready.
         *
         * To be notified when the app is ready, refer to {@link $mmApp#ready}.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#ready
         * @return {Boolean} True when it is, false when not.
         */
        self.isReady = function() {
            var promise = $injector.get('$mmInitDelegate').ready();
            return promise.$$state.status === 1;
        };

        /**
         * Open the keyboard if plugin is available.
         *
         * @return {Boolean} True if plugin is available, false otherwise.
         */
        self.openKeyboard = function() {
            if (typeof cordova != 'undefined' && cordova.plugins && cordova.plugins.Keyboard && cordova.plugins.Keyboard.show) {
                cordova.plugins.Keyboard.show();
                return true;
            }
            return false;
        };

        /**
         * Resolves when the app is ready.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#ready
         * @description
         * This returns a promise that is resolved when the app is initialised.
         *
         * Usage:
         *
         *    $mmApp.ready().then(function() {
         *        // What you want to do.
         *    });
         *
         * @return {Promise} Resolved when the app is initialised. Never rejected.
         */
        self.ready = function() {
            // Injects to prevent circular dependencies.
            return $injector.get('$mmInitDelegate').ready();
        };

        return self;
    }];
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreConfigStore', 'config')

.config(["$mmAppProvider", "mmCoreConfigStore", function($mmAppProvider, mmCoreConfigStore) {
    var stores = [
        {
            name: mmCoreConfigStore,
            keyPath: 'name'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

/**
 * Factory to provide access to dynamic and permanent config and settings.
 * It should not be abused into a temporary storage.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmConfig
 * @description
 * Provides access to the app settings.
 */
.factory('$mmConfig', ["$q", "$log", "$mmApp", "mmCoreConfigStore", function($q, $log, $mmApp, mmCoreConfigStore) {

    $log = $log.getInstance('$mmConfig');

    var self = {};

    /**
     * Get an app setting.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmConfig#get
     * @param {String} name           The config name.
     * @param {Mixed}  [defaultValue] Default value to use if the entry is not found.
     * @return {Promise}              Resolves upon success along with the config data. Reject on failure.
     * @description
     * Get an app setting.
     */
    self.get = function(name, defaultValue) {
        return $mmApp.getDB().get(mmCoreConfigStore, name).then(function(entry) {
            return entry.value;
        }).catch(function() {
            if (typeof defaultValue != 'undefined') {
                return defaultValue;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Set an app setting.
     *
     * @module mm.core
     * @ngdoc service
     * @name $mmConfig#set
     * @param {String} name The config name.
     * @param {Mixed} value The config value.
     * @return {Promise}    Promise which resolves on success, providing no data.
     * @description
     * Set an app setting.
     */
    self.set = function(name, value) {
        return $mmApp.getDB().insert(mmCoreConfigStore, {name: name, value: value});
    };

    /**
     * Deletes an app setting.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmConfig#delete
     * @param {String} name The config name.
     * @return {Promise}    Promise which resolves on success, providing no data.
     * @description
     * Delete an app setting.
     */
    self.delete = function(name) {
        return $mmApp.getDB().remove(mmCoreConfigStore, name);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmDB
 * @module mm.core
 * @description
 * This service allows to interact with the local database to store and retrieve data.
 */
.factory('$mmDB', ["$q", "$log", function($q, $log) {

    $log = $log.getInstance('$mmDB');

    var self = {},
        dbInstances = {};

    /**
     * Convenient helper to apply an order to a query.
     *
     * @param  {Object}  [query]   A query object.
     * @param  {String}  [order]   The field to order on.
     * @param  {Boolean} [reverse] Whether to reverse the results.
     * @return {Object}  The updated query object (or initial one).
     */
    function applyOrder(query, order, reverse) {
        if (order) {
            query = query.order(order);
            if (reverse) {
                query = query.reverse();
            }
        }
        return query;
    }

    /**
     * Convenient helper to apply a where condition to a query.
     *
     * @param  {Object} [query]   A query object.
     * @param  {Array}  [where]   Array of parameters, in order:
     *                            - The field to filter on
     *                            - The operator: <, <=, =, >, >=, ^ (starts with)
     *                            - The value
     *                            - An additional operator
     *                            - An additional value
     * @return {Object} The updated query object (or initial one).
     */
    function applyWhere(query, where) {
        if (where && where.length > 0) {
            query = query.where.apply(query, where);
        }
        return query;
    }

    /**
     * Call a DB simple function.
     * @param  {Object}  db      DB to use.
     * @param  {String}  func    Name of the function to call.
     * @return {Promise}         Promise to be resolved when the operation finishes.
     */
    function callDBFunction(db, func) {
        var deferred = $q.defer();

        try {
            if (typeof(db) != 'undefined') {
                db[func].apply(db, Array.prototype.slice.call(arguments, 2)).then(function(result) {
                    if (typeof(result) == 'undefined') {
                        deferred.reject();
                    } else {
                        deferred.resolve(result);
                    }
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error executing function '+func+' to DB '+db.getName());
            $log.error(ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Retrieve the count of entries matching certain conditions.
     * @param  {Object}  db         DB to use.
     * @param  {String}  store      Name of the store to get the entries from.
     * @param  {Array}   where      Array of where conditions, see applyWhere.
     * @return {Promise}
     */
    function callCount(db, store, where) {
        var deferred = $q.defer(),
            query;

        try {
            if (typeof(db) != 'undefined') {
                query = db.from(store);
                query = applyWhere(query, where);
                query.count().then(function(count) {
                    deferred.resolve(count);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying db '+db.getName()+'. '+ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Retrieve the list of entries matching certain conditions.
     * @param  {Object}  db         DB to use.
     * @param  {String}  store      Name of the store to get the entries from.
     * @param  {String}  field_name Name of the field that should match the conditions.
     * @param  {String}  op         First operator symbol. One of '<', '<=', '=', '>', '>=', '^'.
     * @param  {String}  value      Value for the first operator.
     * @param  {String}  op2        Second operator symbol.
     * @param  {String}  value2     Value for the second operator.
     * @return {Promise}            Promise to be resolved when the list is retrieved.
     */
    function callWhere(db, store, field_name, op, value, op2, value2) {
        var deferred = $q.defer();

        try {
            if (typeof(db) != 'undefined') {
                db.from(store).where(field_name, op, value, op2, value2).list().then(function(list) {
                    deferred.resolve(list);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying db '+db.getName()+'. '+ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Retrieve the list of entries where a certain field is equal to a certain value.
     * Important: the field must be an index.
     * @param  {Object}  db         DB to use.
     * @param  {String}  store      Name of the store to get the entries from.
     * @param  {String}  field_name Name of the field to check.
     * @param  {String}  value      Value the field should be equal to.
     * @return {Promise}            Promise to be resolved when the list is retrieved.
     */
    function callWhereEqual(db, store, field_name, value) {
        var deferred = $q.defer();

        try {
            if (typeof(db) != 'undefined') {
                db.from(store).where(field_name, '=', value).list().then(function(list) {
                    deferred.resolve(list);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error getting where equal from db '+db.getName()+'. '+ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Performs an operation with every entry in a certain store.
     * @param  {Object}   db       DB to use.
     * @param  {String}   store    Name of the store to get the entries from.
     * @param  {Function} callback Function to call with each entry.
     * @return {Promise}           Promise to be resolved when the the operation has been applied to all entries.
     */
    function callEach(db, store, callback) {
        var deferred = $q.defer();

        callDBFunction(db, 'values', store, undefined, 99999999).then(function(entries) {
            for (var i = 0; i < entries.length; i++) {
                callback(entries[i]);
            }
            deferred.resolve();
        }, function() {
            deferred.reject();
        });

        return deferred.promise;
    }

    /**
     * Retrieve the list of entries matching certain conditions.
     *
     * @param  {Object}  db      DB to use.
     * @param  {String}  store   Name of the store to get the entries from.
     * @param  {Array}   where   Array of where conditions, see applyWhere.
     * @param  {Array}   order   The key to order on.
     * @param  {Boolean} reverse Whether to reverse the order.
     * @param  {Number}  limit   The number of result to return.
     * @return {Promise}
     */
    function doQuery(db, store, where, order, reverse, limit) {
        var deferred = $q.defer(),
            query;

        try {
            if (typeof(db) != 'undefined') {
                query = db.from(store);
                query = applyWhere(query, where);
                query = applyOrder(query, order, reverse);
                query.list(limit).then(function(list) {
                    deferred.resolve(list);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying ' + store + ' on ' + db.getName() + '. ' + ex.name + ': ' + ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Update a list of entries matching conditions.
     *
     * @param  {Object}  db      DB to use.
     * @param  {String}  store   Name of the store to get the entries from.
     * @param  {Object}  values  The values to set.
     * @param  {Array}   where   An array of where() parameters.
     * @return {Promise}
     */
    function doUpdate(db, store, values, where) {
        var deferred = $q.defer(),
            query;

        try {
            if (typeof(db) != 'undefined') {
                query = db.from(store);
                query = applyWhere(query, where);
                query.patch(values).then(function(count) {
                    deferred.resolve(count);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying ' + store + ' on ' + db.getName() + '. ' + ex.name + ': ' + ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Create a new database object.
     *
     * The database objects are cached statically.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmDB#getDB
     * @param  {String} name    DB name.
     * @param  {Object} schema  DB schema.
     * @param  {Object} options DB options.
     * @return {Object}         DB.
     */
    self.getDB = function(name, schema, options) {
        if (typeof dbInstances[name] === 'undefined') {

            var isSafari = !ionic.Platform.isIOS() && !ionic.Platform.isAndroid() && navigator.userAgent.indexOf('Safari') != -1
                            && navigator.userAgent.indexOf('Chrome') == -1 && navigator.userAgent.indexOf('Firefox') == -1;
            if (typeof IDBObjectStore == 'undefined' || typeof IDBObjectStore.prototype.count == 'undefined' || isSafari) {
                // IndexedDB not implemented or not fully implemented (Galaxy S4 Mini). Use WebSQL.
                if (typeof options.mechanisms == 'undefined') {
                    options.mechanisms = ['websql', 'sqlite', 'localstorage', 'sessionstorage', 'userdata', 'memory'];
                } else {
                    var position = options.mechanisms.indexOf('indexeddb');
                    if (position != -1) {
                        options.mechanisms.splice(position, 1);
                    }
                }
            }

            var db = new ydn.db.Storage(name, schema, options);

            dbInstances[name] = {
                /**
                 * Get DB name.
                 *
                 * @return {String} DB name.
                 */
                getName: function() {
                    return db.getName();
                },
                /**
                 * Get an entry from a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Mixed}  id    Entry's identifier (primary key / keyPath).
                 * @return {Promise}     Promise resolved when the entry is retrieved. Resolve param: DB entry (object).
                 */
                get: function(store, id) {
                    return callDBFunction(db, 'get', store, id);
                },
                /**
                 * Get all the entries from a store.
                 *
                 * @param {String} store Name of the store.
                 * @return {Promise}     Promise resolved when the entries are retrieved. Resolve param: DB entries (array).
                 */
                getAll: function(store) {
                    return callDBFunction(db, 'values', store, undefined, 99999999);
                },
                /**
                 * Count the number of entries in a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Array} [where] Array of where conditions, see applyWhere.
                 * @return {Promise}     Promise resolved when the count is done. Resolve param: number of entries.
                 */
                count: function(store, where) {
                    return callCount(db, store, where);
                },
                /**
                 * Add an entry to a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Object} value Object to store. Primary key (keyPath) is required.
                 * @param {IDbKey} id The key when needed.
                 * @return {Promise}     Promise resolved when the entry is inserted. Resolve param: new entry's primary key.
                 */
                insert: function(store, value, id) {
                    return callDBFunction(db, 'put', store, value, id);
                },
                /**
                 * Add an entry to a store, returning a synchronous value.
                 * Please use this function only if synchronous is a must, you should always use $mmDB#insert.
                 * Take into account that the value will be returned BEFORE the value is actually stored. The value of the
                 * boolean returned only indicates if it has passed the first validation.
                 *
                 * @param {String} store Name of the store.
                 * @param {Object} value Object to store. Primary key (keyPath) is required.
                 * @return {Boolean}     True if data to insert is valid, false otherwise. Returning true doesn't mean that the
                 *                       data has been stored, this function can return true but the insertion can still fail.
                 */
                insertSync: function(store, value) {
                    if (db) {
                        try {
                            db.put(store, value);
                            return true;
                        } catch(ex) {
                            $log.error('Error executing function sync put to DB '+db.getName());
                            $log.error(ex.name+': '+ex.message);
                        }
                    }

                    return false;
                },
                /**
                 * Query the database.
                 *
                 * @param {String} store Name of the store.
                 * @param {Array} [where] Array of where conditions, see applyWhere.
                 * @param {String} [order] The key to sort the results with.
                 * @param {Boolean} [reverse=false] Whether to reverse the results.
                 * @param {Number} [limit] The number of results to return.
                 * @return {Promise} Promise resolved with an array of entries.
                 */
                query: function(store, where, order, reverse, limit) {
                    return doQuery(db, store, where, order, reverse, limit);
                },
                /**
                 * Removes an entry from a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Mixed}  id    Entry's identifier (primary key / keyPath).
                 * @return {Promise}     Promise resolved when the entry is deleted. Resolve param: number of entries deleted.
                 */
                remove: function(store, id) {
                    return callDBFunction(db, 'remove', store, id);
                },
                /**
                 * Removes all entries from a store.
                 *
                 * @param {String} store Name of the store.
                 * @return {Promise}     Promise resolved when the entries are deleted.
                 */
                removeAll: function(store) {
                    return callDBFunction(db, 'clear', store);
                },
                /**
                 * Update records matching.
                 *
                 * @param {String} store Name of the store.
                 * @param {Object} values The values to update.
                 * @param {Array} [where] Array of where conditions, see applyWhere.
                 * @return {Promise}
                 */
                update: function(store, values, where) {
                    return doUpdate(db, store, values, where);
                },
                /**
                 * Get the entries where a field match certain conditions.
                 *
                 * @param {String} store      Name of the store.
                 * @param {String} field_name Name of the field to match.
                 * @param {String} op         First operator to apply to the field. <, <=, =, >, >=, ^ (start with).
                 * @param {Mixed}  value      Value to compare using the first operator.
                 * @param {String} op2        Second operator to apply to the field. Optional.
                 * @param {Mixed}  value2     Value to compare using the second operator. Optional.
                 * @return {Promise}          Promise resolved when the entries are retrieved. Resolve param: entries (array).
                 */
                where: function(store, field_name, op, value, op2, value2) {
                    return callWhere(db, store, field_name, op, value, op2, value2);
                },
                /**
                 * Get the entries where a field is equal to a certain value.
                 *
                 * @param {String} store      Name of the store.
                 * @param {String} field_name Name of the field to match.
                 * @param {Mixed}  value      Value to compare to the field.
                 * @return {Promise}          Promise resolved when the entries are retrieved. Resolve param: entries (array).
                 */
                whereEqual: function(store, field_name, value) {
                    return callWhereEqual(db, store, field_name, value);
                },
                /**
                 * Call a function with each of the entries from a store.
                 *
                 * @param {String} store      Name of the store.
                 * @param {Function} callback Function to call with each entry.
                 * @return {Promise}          Promise resolved when the function is called for all entries. No resolve params.
                 */
                each: function(store, callback) {
                    return callEach(db, store, callback);
                },
                /**
                 * Close the database.
                 */
                close: function() {
                    db.close();
                    db = undefined;
                },
                /**
                 * Call a callback once DB is ready.
                 *
                 * @param {Function} cb Callback to call.
                 */
                onReady: function(cb) {
                    db.onReady(cb);
                },
                /**
                 * Get storage type.
                 *
                 * @return {String} Storage type.
                 */
                getType: function() {
                    return db.getType();
                }
            };
        }
        return dbInstances[name];
    };

    /**
     * Delete a DB.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmDB#deleteDB
     * @param  {String} name   DB name.
     * @return {Promise}       Promise to be resolved when the site DB is deleted.
     */
    self.deleteDB = function(name) {
        var deferred = $q.defer();

        function deleteDB() {
            delete dbInstances[name];
            $q.when(ydn.db.deleteDatabase(name)).then(deferred.resolve, deferred.reject);
        }

        if (typeof dbInstances[name] != 'undefined') {
            // We have a DB instance. Wait for it to be ready before deleting the DB.
            dbInstances[name].onReady(deleteDB);
        } else {
            deleteDB();
        }

        return deferred.promise;
    };

    return self;

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmEmulatorManager
 * @module mm.core
 * @description
 * This service handles the emulation of Cordova plugins in other environments like browser.
 */
.factory('$mmEmulatorManager', ["$log", "$q", "$http", "$mmFS", "$window", function($log, $q, $http, $mmFS, $window) {

    $log = $log.getInstance('$mmEmulatorManager');

    var self = {};

    /**
     * Loads HTML API to simulate Cordova APIs. Reserved for core use.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEmulatorManager#loadHTMLAPI
     * @return {Promise} Promise resolved when the API is loaded.
     * @protected
     */
    self.loadHTMLAPI = function() {

        if ($mmFS.isAvailable()) {
            $log.debug('Stop loading HTML API, it was already loaded or the environment doesn\'t need it.');
            return $q.when();
        }

        var deferred = $q.defer(),
            basePath;

        $log.debug('Loading HTML API.');

        // File API.
        $window.requestFileSystem  = $window.requestFileSystem || $window.webkitRequestFileSystem;
        $window.resolveLocalFileSystemURL = $window.resolveLocalFileSystemURL || $window.webkitResolveLocalFileSystemURL;

        $window.LocalFileSystem = {
            PERSISTENT: 1
        };

        // FileTransfer API.
        $window.FileTransfer = function() {};

        $window.FileTransfer.prototype.download = function(url, filePath, successCallback, errorCallback) {
            $http.get(url, {responseType: 'blob'}).then(function(data) {
                if (!data || !data.data) {
                    errorCallback();
                } else {
                    filePath = filePath.replace(basePath, ''); // Remove basePath from the filePath.
                    $mmFS.writeFile(filePath, data.data).then(function(e) {
                        successCallback(e);
                    }).catch(function(error) {
                        errorCallback(error);
                    });
                }
            }).catch(function(error) {
                errorCallback(error);
            });
        };

        // Cordova ZIP plugin.
        $window.zip = {
            unzip: function(source, destination, callback, progressCallback) {
                // Remove basePath from the source and destination.
                source = source.replace(basePath, '');
                destination = destination.replace(basePath, '');

                $mmFS.readFile(source, $mmFS.FORMATARRAYBUFFER).then(function(data) {
                    var zip = new JSZip(data),
                        promises = [];

                    angular.forEach(zip.files, function(file, name) {
                        var filepath = $mmFS.concatenatePaths(destination, name),
                            type;

                        if (!file.dir) {
                            // It's a file. Get the mimetype and write the file.
                            type = $mmFS.getMimeType($mmFS.getFileExtension(name));
                            promises.push($mmFS.writeFile(filepath, new Blob([file.asArrayBuffer()], {type: type})));
                        } else {
                            // It's a folder, create it if it doesn't exist.
                            promises.push($mmFS.createDir(filepath));
                        }
                    });

                    return $q.all(promises).then(function() {
                        // Success.
                        callback(0);
                    });
                }).catch(function() {
                    // Error.
                    callback(-1);
                });
            }
        };

        // @todo: Implement FileTransfer.upload.

        // Request 500MB.
        $window.webkitStorageInfo.requestQuota(PERSISTENT, 500 * 1024 * 1024, function(granted) {
            $window.requestFileSystem(PERSISTENT, granted, function(entry) {
                basePath = entry.root.toURL();
                $mmFS.setHTMLBasePath(basePath);
                deferred.resolve();
            }, deferred.reject);
        }, deferred.reject);

        return deferred.promise;
    };

    return self;
}])

.config(["$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {
    if (!ionic.Platform.isWebView()) {
        $mmInitDelegateProvider.registerProcess('mmEmulator', '$mmEmulatorManager.loadHTMLAPI',
                mmInitDelegateMaxAddonPriority + 500, true);
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreEventKeyboardShow', 'keyboard_show')
.constant('mmCoreEventKeyboardHide', 'keyboard_hide')
.constant('mmCoreEventSessionExpired', 'session_expired')
.constant('mmCoreEventLogin', 'login')
.constant('mmCoreEventLogout', 'logout')
.constant('mmCoreEventLanguageChanged', 'language_changed')
.constant('mmCoreEventSiteAdded', 'site_added')
.constant('mmCoreEventSiteUpdated', 'site_updated')
.constant('mmCoreEventSiteDeleted', 'site_deleted')
.constant('mmCoreEventQueueEmpty', 'filepool_queue_empty')
.constant('mmCoreEventCompletionModuleViewed', 'completion_module_viewed')
.constant('mmCoreEventUserDeleted', 'user_deleted')
.constant('mmCoreEventPackageStatusChanged', 'filepool_package_status_changed')
.constant('mmCoreEventSectionStatusChanged', 'section_status_changed')

/**
 * Service to send and listen to events.
 *
 * @ngdoc service
 * @name $mmEvents
 * @module mm.core
 * @description
 * This service allows sending and listening to events in the Moodle Mobile app.
 */
.factory('$mmEvents', ["$log", "md5", function($log, md5) {

    $log = $log.getInstance('$mmEvents');

    var self = {},
        observers = {},
        uniqueEvents = {},
        uniqueEventsData = {};

    /**
     * Adds an observer for a certain event.
     * To deregister the event:
     * var observer = $mmEvents.on('something', myCallBack);
     * observer.off();
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEvents#on
     * @param  {String}   eventName  Name of the event to listen to.
     * @param  {Function} callBack   Function to call when the event is triggered.
     * @return {Object}              Object to deregister the observer. Undefined if it's an already triggered unique event.
     */
    self.on = function(eventName, callBack) {

        // If it's a unique event and has been triggered already, call the callBack.
        // We don't need to store the observer because the event won't be triggered again.
        if (uniqueEvents[eventName]) {
            callBack(uniqueEventsData[eventName]);
            // Return a fake observer to prevent errors.
            return {
                id: -1,
                off: function() {}
            };
        }

        var observerID;

        if (typeof(observers[eventName]) === 'undefined') {
            observers[eventName] = {};
        }

        while (typeof(observerID) === 'undefined') {
            var candidateID = md5.createHash(Math.random().toString());
            if (typeof(observers[eventName][candidateID]) === 'undefined') {
                observerID = candidateID;
            }
        }
        $log.debug('Observer ' + observerID + ' listening to event '+eventName);

        observers[eventName][observerID] = callBack;

        // Create observer object to deregister the listener.
        var observer = {
            id: observerID,
            off: function() {
                $log.debug('Disable observer ' + observerID + ' for event '+eventName);
                delete observers[eventName][observerID];
            }
        };
        return observer;
    };

    /**
     * Triggers an event, notifying all the observers.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEvents#trigger
     * @param {String} event Name of the event to trigger.
     * @param {Mixed}  data  Data to pass to the observers.
     */
    self.trigger = function(eventName, data) {
        $log.debug('Event ' + eventName + ' triggered.');
        var affected = observers[eventName];
        for (var observerName in affected) {
            if (typeof(affected[observerName]) === 'function') {
                affected[observerName](data);
            }
        }
    };

    /**
     * Triggers a unique event, notifying all the observers. If the event has already been triggered, don't do anything.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEvents#trigger
     * @param {String} event Name of the event to trigger.
     * @param {Mixed}  data  Data to pass to the observers.
     */
    self.triggerUnique = function(eventName, data) {
        if (uniqueEvents[eventName]) {
            $log.debug('Unique event ' + eventName + ' ignored because it was already triggered.');
        } else {
            $log.debug('Unique event ' + eventName + ' triggered.');
            uniqueEvents[eventName] = true;
            uniqueEventsData[eventName] = data;
            var affected = observers[eventName];
            angular.forEach(affected, function(callBack) {
                if (typeof callBack === 'function') {
                    callBack(data);
                }
            });
        }
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmFilepoolQueueProcessInterval', 0)
.constant('mmFilepoolFolder', 'filepool')
.constant('mmFilepoolStore', 'filepool')
.constant('mmFilepoolQueueStore', 'files_queue')
.constant('mmFilepoolLinksStore', 'files_links')
.constant('mmFilepoolPackagesStore', 'filepool_packages')

.config(["$mmAppProvider", "$mmSitesFactoryProvider", "mmFilepoolStore", "mmFilepoolLinksStore", "mmFilepoolQueueStore", "mmFilepoolPackagesStore", function($mmAppProvider, $mmSitesFactoryProvider, mmFilepoolStore, mmFilepoolLinksStore, mmFilepoolQueueStore,
            mmFilepoolPackagesStore) {
    var siteStores = [
        {
            // File store.
            //
            // Each entry should contain:
            // - fileId: A hash of the file info.
            // - url: URL to download the file.
            // - modified: The time at which the file was last downloaded.
            // - stale: When true, it means that the file should be redownloaded.
            // - etag: Store the ETAG code of the file.
            name: mmFilepoolStore,
            keyPath: 'fileId',
            indexes: []
        },
        {
            // Associations between files and components.
            //
            // Each entry should contain:
            // - fileId: Hash used in the file store.
            // - component: The component name (e.g. mmaModPage).
            // - componentId: An ID that can be used by the component. -1 when not provided.
            name: mmFilepoolLinksStore,
            keyPath: ['fileId', 'component', 'componentId'],
            indexes: [
                {
                    name: 'fileId',
                },
                {
                    name: 'component',
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'componentAndId',
                    generator: function(obj) {
                        return [obj.component, obj.componentId];
                    }
                }
            ]
        },
        {
            // Packages store.
            //
            // Each entry should contain:
            // - id: The package ID. See {@link $mmFilepool#getPackageId}
            // - component: Package's component.
            // - componentId: Package's componentId.
            // - status: The package status: mmCoreDownloaded, mmCoreDownloading, etc.
            // - previous: (optional) The package previous status.
            // - revision: The package revision.
            // - timemodified: The package timemodified.
            // - updated: When was the entry updated for the last time.
            name: mmFilepoolPackagesStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'component',
                },
                {
                    name: 'componentId',
                },
                {
                    name: 'status',
                }
            ]
        }
    ];
    var appStores = [
        {
            // Files queue.
            //
            // Each entry should contain:
            // - siteId: The site ID.
            // - fileId: A hash of the file info.
            // - url: URL to download the file.
            // - added: Timestamp (in milliseconds) at which the file was added to the queue.
            // - priority: Indicates which files should be treated first. Maximum value is 999.
            // - links: Array of objects containing component and ID to create links once the file has been processed.
            name: mmFilepoolQueueStore,
            keyPath: ['siteId', 'fileId'],
            indexes: [
                {
                    name: 'siteId',
                },
                {
                    name: 'sortorder',
                    generator: function(obj) {
                        // Creates an index to sort the queue items by priority, sort is ascending.
                        // The oldest are considered to be the most important ones.
                        // The additional priority argument allows to bump any queue item on top of the queue.
                        // The index will look as follow:
                        //    [999 - priority] + "-" + timestamp
                        //    "999-1431491086913": item without priority.
                        //    "900-1431491086913": item with priority of 99.
                        //    "000-1431491086913": item with max priority.

                        var sortorder = parseInt(obj.added, 10),
                            priority = 999 - Math.max(0, Math.min(parseInt(obj.priority || 0, 10), 999)),
                            padding = "000";

                        // Convert to strings.
                        sortorder = "" + sortorder;
                        priority = "" + priority;

                        // Final format.
                        priority = padding.substring(0, padding.length - priority.length) + priority;
                        sortorder = priority + '-' + sortorder;

                        return sortorder;
                    }
                }
            ]
        }
    ];
    $mmAppProvider.registerStores(appStores);
    $mmSitesFactoryProvider.registerStores(siteStores);
}])

/**
 * Factory for handling the files in the pool.
 *
 * @module mm.core
 * @ngdoc factory
 * @name $mmFilepool
 * @todo Use transactions (e.g. when querying, then updating)
 * @todo Setting files as stale after a certain time
 * @todo Use ETAGs
 * @todo Do not download on limited network
 * @description
 *
 * This factory is responsible for handling external content.
 *
 * It will always try to get a file from the filepool and return it, when the file is not
 * found it will be added to a queue to be downloaded later. The two main goals of this
 * is to keep the content available offline, and improve the user experience by caching
 * the content locally.
 *
 * The filepool has a very limited understanding of pluginfiles, you should always call
 * {@link $mmUtil#fixPluginfileURL} prior to passing the URL. The reason for this is to
 * allow for any type of URL to be handled here. We can download and cache content
 * that is not served by Moodle. The only little handling of pluginfile is located in
 * {@link $mmFilepool#_getFileIdByUrl}.
 */
.factory('$mmFilepool', ["$q", "$log", "$timeout", "$mmApp", "$mmFS", "$mmWS", "$mmSitesManager", "$mmEvents", "md5", "mmFilepoolStore", "mmFilepoolLinksStore", "mmFilepoolQueueStore", "mmFilepoolFolder", "mmFilepoolQueueProcessInterval", "mmCoreEventQueueEmpty", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreNotDownloadable", "mmFilepoolPackagesStore", "mmCoreEventPackageStatusChanged", function($q, $log, $timeout, $mmApp, $mmFS, $mmWS, $mmSitesManager, $mmEvents, md5, mmFilepoolStore,
        mmFilepoolLinksStore, mmFilepoolQueueStore, mmFilepoolFolder, mmFilepoolQueueProcessInterval, mmCoreEventQueueEmpty,
        mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreNotDownloadable, mmFilepoolPackagesStore,
        mmCoreEventPackageStatusChanged) {

    $log = $log.getInstance('$mmFilepool');

    var self = {},
        extensionRegex = new RegExp('^[a-z0-9]+$'),
        tokenRegex = new RegExp('(\\?|&)token=([A-Za-z0-9]+)'),
        queueState,
        urlAttributes = [
            tokenRegex,
            new RegExp('(\\?|&)forcedownload=[0-1]')
        ],
        revisionRegex = new RegExp('/content/([0-9]+)/'),
        queueDeferreds = {}, // To handle file downloads using the queue.
        packagesPromises = {}, // To prevent downloading packages twice at the same time.
        filePromises = {}; // To prevent downloading files twice at the same time.

    // Queue status codes.
    var QUEUE_RUNNING = 'mmFilepool:QUEUE_RUNNING',
        QUEUE_PAUSED = 'mmFilepool:QUEUE_PAUSED';

    // Error codes.
    var ERR_QUEUE_IS_EMPTY = 'mmFilepoolError:ERR_QUEUE_IS_EMPTY',
        ERR_FS_OR_NETWORK_UNAVAILABLE = 'mmFilepoolError:ERR_FS_OR_NETWORK_UNAVAILABLE',
        ERR_QUEUE_ON_PAUSE = 'mmFilepoolError:ERR_QUEUE_ON_PAUSE';

    /**
     * Files states. Deprecated, please use core constants instead: mmCoreDownloaded, mmCoreDownloading, ...
     * @deprecated since version 2.6
     */
    self.FILEDOWNLOADED = 'downloaded';
    self.FILEDOWNLOADING = 'downloading';
    self.FILENOTDOWNLOADED = 'notdownloaded';
    self.FILEOUTDATED = 'outdated';

    /**
     * Convenient site DB getter.
     */
    function getSiteDb(siteId) {
        return $mmSitesManager.getSiteDb(siteId);
    }

    /**
     * Link a file with a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_addFileLink
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._addFileLink = function(siteId, fileId, component, componentId) {
        if (!component) {
            return $q.reject();
        }

        componentId = self._fixComponentId(componentId);
        return getSiteDb(siteId).then(function(db) {
            return db.insert(mmFilepoolLinksStore, {
                fileId: fileId,
                component: component,
                componentId: componentId
            });
        });
    };

    /**
     * Link a file with a component by URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#addFileLinkByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file Url.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @description
     * Use this method to create a link between a URL and a component. You usually do not need to call
     * this manually as adding a file to queue allows you to do so. Note that this method
     * does not check if the file exists in the pool, so you probably want to use is after
     * a successful {@link $mmFilepool#downloadUrl}.
     */
    self.addFileLinkByUrl = function(siteId, fileUrl, component, componentId) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._addFileLink(siteId, fileId, component, componentId);
        });
    };

    /**
     * Link a file with a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_addFileLinks
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @param {Object[]} links Array of objects containing the link component and optionally componentId.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._addFileLinks = function(siteId, fileId, links) {
        var promises = [];
        angular.forEach(links, function(link) {
            promises.push(self._addFileLink(siteId, fileId, link.component, link.componentId));
        });
        return $q.all(promises);
    };

    /**
     * Add a file to the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_addFileToPool
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @param {Object} data Additional information to store about the file (timemodified, url, ...). See mmFilepoolStore schema.
     * @return {Promise}
     * @protected
     * @description
     * Note that this method will override any existing entry with the same key.
     * That is the only way to update an entry.
     */
    self._addFileToPool = function(siteId, fileId, data) {
        var values = angular.copy(data) || {};
        values.fileId = fileId;
        return getSiteDb(siteId).then(function(db) {
            return db.insert(mmFilepoolStore, values);
        });
    };

    /**
     * Add an entry to queue using a URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#addToQueueByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} [component] The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component (optional).
     * @param {Number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {String} [filePath]       Filepath to download the file to.
     * @param {Number} [priority=0] The priority this file should get in the queue (range 0-999).
     * @return {Promise} Resolved on success. The returned value can be inconsistent, do not use.
     */
    self.addToQueueByUrl = function(siteId, fileUrl, component, componentId, timemodified, filePath, priority) {
        var db = $mmApp.getDB(),
            fileId,
            now = new Date(),
            link,
            revision,
            queueDeferred;

        if (!$mmFS.isAvailable()) {
            return $q.reject();
        }

        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {

            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            fileId = self._getFileIdByUrl(fileUrl);
            priority = priority || 0;

            // Set up the component.
            if (typeof component !== 'undefined') {
                link = {
                    component: component,
                    componentId: componentId
                };
            }

            // Retrieve the queue deferred now if it exists to prevent errors if file is removed from queue
            // while we're checking if the file is in queue.
            queueDeferred = self._getQueueDeferred(siteId, fileId, false);

            return db.get(mmFilepoolQueueStore, [siteId, fileId]).then(function(fileObject) {
                var foundLink = false,
                    update = false;

                if (fileObject) {
                    // We already have the file in queue, we update the priority and links.
                    if (fileObject.priority < priority) {
                        update = true;
                        fileObject.priority = priority;
                    }
                    if (revision && fileObject.revision !== revision) {
                        update = true;
                        fileObject.revision = revision;
                    }
                    if (timemodified && fileObject.timemodified !== timemodified) {
                        update = true;
                        fileObject.timemodified = timemodified;
                    }
                    if (filePath && fileObject.path !== filePath) {
                        update = true;
                        fileObject.path = filePath;
                    }

                    if (link) {
                        // We need to add the new link if it does not exist yet.
                        angular.forEach(fileObject.links, function(fileLink) {
                            if (fileLink.component == link.component && fileLink.componentId == link.componentId) {
                                foundLink = true;
                            }
                        });
                        if (!foundLink) {
                            update = true;
                            fileObject.links.push(link);
                        }
                    }

                    if (update) {
                        // Update only when required.
                        $log.debug('Updating file ' + fileId + ' which is already in queue');
                        return db.insert(mmFilepoolQueueStore, fileObject).then(function() {
                            return self._getQueuePromise(siteId, fileId);
                        });
                    }

                    $log.debug('File ' + fileId + ' already in queue and does not require update');
                    if (queueDeferred) {
                        // If we were able to retrieve the queue deferred before we use that one, since the file download
                        // might have finished now and the deferred wouldn't be in the array anymore.
                        return queueDeferred.promise;
                    } else {
                        return self._getQueuePromise(siteId, fileId);
                    }
                } else {
                    return addToQueue();
                }
            }, function() {
                // Unsure why we could not get the record, let's add to the queue anyway.
                return addToQueue();
            });

            function addToQueue() {
                $log.debug('Adding ' + fileId + ' to the queue');
                return db.insert(mmFilepoolQueueStore, {
                    siteId: siteId,
                    fileId: fileId,
                    added: now.getTime(),
                    priority: priority,
                    url: fileUrl,
                    revision: revision,
                    timemodified: timemodified,
                    path: filePath,
                    links: link ? [link] : []
                }).then(function() {
                    // Check if the queue is running.
                    self.checkQueueProcessing();
                    return self._getQueuePromise(siteId, fileId);
                });
            }
        });
    };

    /**
     * Check the queue processing.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#checkQueueProcessing
     * @return {Void}
     * @description
     * In mose cases, this will enable the queue processing if it was paused.
     * Though, this will disable the queue if we are missing network or if the file system
     * is not accessible. Also, this will have no effect if the queue is already running.
     *
     * Do not use directly, it is reserved for core use.
     */
    self.checkQueueProcessing = function() {

        if (!$mmFS.isAvailable() || !$mmApp.isOnline()) {
            queueState = QUEUE_PAUSED;
            return;

        } else if (queueState === QUEUE_RUNNING) {
            return;
        }

        queueState = QUEUE_RUNNING;
        self._processQueue();
    };

    /**
     * Clear all packages status in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#clearAllPackagesStatus
     * @param {String} siteId Site ID.
     * @return {Promise}      Promise resolved when all status are cleared.
     */
    self.clearAllPackagesStatus = function(siteId) {
        var promises = [];
        $log.debug('Clear all packages status for site ' + siteId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb();
            return db.getAll(mmFilepoolPackagesStore).then(function(entries) {
                angular.forEach(entries, function(entry) {
                    promises.push(db.remove(mmFilepoolPackagesStore, entry.id).then(function() {
                        // Trigger module status changed, setting it as not downloaded.
                        self._triggerPackageStatusChanged(siteId, entry.component, entry.componentId, mmCoreNotDownloaded);
                    }));
                });
                return $q.all(promises);
            });
        });
    };

    /**
     * Clears the filepool. Use it only when all the files from a site are deleted.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#clearFilepool
     * @param  {String} siteId ID of the site to clear.
     * @return {Promise}       Promise resolved when the filepool is cleared.
     */
    self.clearFilepool = function(siteId) {
        return getSiteDb(siteId).then(function(db) {
            return db.removeAll(mmFilepoolStore);
        });
    };

    /**
     * Returns whether a component has files in the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#componentHasFiles
     * @param {String} siteId The site ID.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved means yes, rejected means no.
     */
    self.componentHasFiles = function(siteId, component, componentId) {
        return getSiteDb(siteId).then(function(db) {
            var where;
            if (typeof componentId !== 'undefined') {
                where = ['componentAndId', '=', [component, self._fixComponentId(componentId)]];
            } else {
                where = ['component', '=', component];
            }
            return db.count(mmFilepoolLinksStore, where).then(function(count) {
                if (count > 0) {
                    return true;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Given the current status of a list of packages and the status of one of the packages,
     * determine the new status for the list of packages. The status of a list of packages is:
     *     - mmCoreNotDownloadable if there are no downloadable packages.
     *     - mmCoreNotDownloaded if at least 1 package has status mmCoreNotDownloaded.
     *     - mmCoreDownloaded if ALL the downloadable packages have status mmCoreDownloaded.
     *     - mmCoreDownloading if ALL the downloadable packages have status mmCoreDownloading or mmCoreDownloaded,
     *                                     with at least 1 package with mmCoreDownloading.
     *     - mmCoreOutdated if ALL the downloadable packages have status mmCoreOutdated or mmCoreDownloaded or
     *                                     mmCoreDownloading, with at least 1 package with mmCoreOutdated.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#determinePackagesStatus
     * @param {String} current       Current status of the list of packages.
     * @param {String} packagestatus Status of one of the packages.
     * @return {String}              New status for the list of packages;
     */
    self.determinePackagesStatus = function(current, packagestatus) {
        if (!current) {
            current = mmCoreNotDownloadable;
        }

        if (packagestatus === mmCoreNotDownloaded) {
            // If 1 package is not downloaded the status of the whole list will always be not downloaded.
            return mmCoreNotDownloaded;
        } else if (packagestatus === mmCoreDownloaded && current === mmCoreNotDownloadable) {
            // If all packages are downloaded or not downloadable with at least 1 downloaded, status will be downloaded.
            return mmCoreDownloaded;
        } else if (packagestatus === mmCoreDownloading && (current === mmCoreNotDownloadable || current === mmCoreDownloaded)) {
            // If all packages are downloading/downloaded/notdownloadable with at least 1 downloading, status will be downloading.
            return mmCoreDownloading;
        } else if (packagestatus === mmCoreOutdated && current !== mmCoreNotDownloaded) {
            // If there are no packages notdownloaded and there is at least 1 outdated, status will be outdated.
            return mmCoreOutdated;
        }

        // Status remains the same.
        return current;
    };

    /**
     * Downloads or prefetches a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_downloadOrPrefetchPackage
     * @param {String} siteId        The site ID.
     * @param  {Object[]} fileList   List of files to download.
     * @param  {Boolean} prefetch    True if should prefetch the contents (queue), false if they should be downloaded right now.
     * @param {String} component     The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [revision]    Package's revision. If not defined, it will be calculated using the list of files.
     * @param {Number} [timemod]     Package's timemodified. If not defined, it will be calculated using the list of files.
     * @param {String} [dirPath]     Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                               the files directly inside the filepool folder.
     * @return {Promise}             Promise resolved when all files are downloaded.
     * @protected
     */
    self._downloadOrPrefetchPackage = function(siteId, fileList, prefetch, component, componentId, revision, timemod, dirPath) {

        var packageId = self.getPackageId(component, componentId);

        if (packagesPromises[siteId] && packagesPromises[siteId][packageId]) {
            // There's already a download ongoing for this package, return the promise.
            return packagesPromises[siteId][packageId];
        } else if (!packagesPromises[siteId]) {
            packagesPromises[siteId] = {};
        }

        revision = revision || self.getRevisionFromFileList(fileList);
        timemod = timemod || self.getTimemodifiedFromFileList(fileList);

        var dwnPromise,
            deleted = false;

        // Set package as downloading.
        dwnPromise = self.storePackageStatus(siteId, component, componentId, mmCoreDownloading, revision, timemod).then(function() {
            var promises = [],
                deferred = $q.defer(),
                packageLoaded = 0; // Use a deferred to be able to use notify.

            angular.forEach(fileList, function(file) {
                var path,
                    promise,
                    fileLoaded = 0;

                if (dirPath) {
                    // Calculate the path to the file.
                    path = file.filename;
                    if (file.filepath !== '/') {
                        path = file.filepath.substr(1) + path;
                    }
                    path = $mmFS.concatenatePaths(dirPath, path);
                }

                if (prefetch) {
                    promise = self.addToQueueByUrl(siteId, file.fileurl, component, componentId, file.timemodified, path);
                } else {
                    promise = self.downloadUrl(siteId, file.fileurl, false, component, componentId, file.timemodified, path);
                }

                // Using undefined for success & fail will pass the success/failure to the parent promise.
                promises.push(promise.then(undefined, undefined, function(progress) {
                    if (progress && progress.loaded) {
                        // Add the new size loaded to the package loaded.
                        packageLoaded = packageLoaded + (progress.loaded - fileLoaded);
                        fileLoaded = progress.loaded;
                        deferred.notify({
                            packageDownload: true,
                            loaded: packageLoaded,
                            fileProgress: progress
                        });
                    }
                }));
            });

            $q.all(promises).then(function() {
                // Success prefetching, store package as downloaded.
                return self.storePackageStatus(siteId, component, componentId, mmCoreDownloaded, revision, timemod);
            }).catch(function() {
                // Error downloading, go back to previous status and reject the promise.
		$log.debug('Error downloading package.');
                return self.setPackagePreviousStatus(siteId, component, componentId).then(function() {
                    return $q.reject();
                });
            }).then(deferred.resolve, deferred.reject);

            return deferred.promise;
        }).finally(function() {
            // Download finished, delete the promise.
            delete packagesPromises[siteId][packageId];
            deleted = true;
        });

        if (!deleted) { // In case promise was finished immediately.
            packagesPromises[siteId][packageId] = dwnPromise;
        }
        return dwnPromise;
    };

    /**
     * Downloads a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#downloadPackage
     * @param {String} siteId         The site ID.
     * @param  {Object[]} fileList    List of files to download.
     * @param {String} component      The component to link the file to.
     * @param {Number} componentId    An ID to identify the download. Must be unique.
     * @param {Number} [revision]     Package's revision. If not defined, it will be calculated using the list of files.
     * @param {Number} [timemodified] Package's timemodified. If not defined, it will be calculated using the list of files.
     * @param {String} [dirPath]      Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                                the files directly inside the filepool folder.
     * @return {Promise}              Promise resolved when all files are downloaded.
     */
    self.downloadPackage = function(siteId, fileList, component, componentId, revision, timemodified, dirPath) {
        return self._downloadOrPrefetchPackage(siteId, fileList, false, component, componentId, revision, timemodified, dirPath);
    };

    /**
     * Downloads a file on the spot.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#downloadUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @param {Boolean} [ignoreStale] True if 'stale' should be ignored.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {String} [filePath]       Filepath to download the file to.
     * @return {Promise} Resolved with internal URL on success, rejected otherwise.
     * @description
     * Downloads a file on the spot.
     *
     * This will also take care of adding the file to the pool if it's missing.
     * However, please note that this will not force a file to be re-downloaded
     * if it is already part of the pool. You should mark a file as stale using
     * {@link $mmFilepool#invalidateFileByUrl} to trigger a download.
     *
     * See {@link $mmFilepool#_getInternalUrlById} for the type of local URL returned.
     */
    self.downloadUrl = function(siteId, fileUrl, ignoreStale, component, componentId, timemodified, filePath) {
        var fileId,
            revision,
            promise;

        if ($mmFS.isAvailable()) {
            return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
                timemodified = timemodified || 0;
                revision = self.getRevisionFromUrl(fileUrl);
                fileId = self._getFileIdByUrl(fileUrl);

                return self._hasFileInPool(siteId, fileId).then(function(fileObject) {

                    if (typeof fileObject === 'undefined') {
                        // We do not have the file, download and add to pool.
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath);

                    } else if (self._isFileOutdated(fileObject, revision, timemodified) && $mmApp.isOnline() && !ignoreStale) {
                        // The file is outdated, force the download and update it.
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject);
                    }

                    // Everything is fine, return the file on disk.
                    if (filePath) {
                        promise = self._getInternalUrlByPath(filePath);
                    } else {
                        promise = self._getInternalUrlById(siteId, fileId);
                    }
                    return promise.then(function(response) {
                        return response;
                    }, function() {
                        // The file was not found in the pool, weird.
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject);
                    });

                }, function() {
                    // The file is not in the pool just yet.
                    return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath);
                })
                .then(function(response) {
                    if (typeof component !== 'undefined') {
                        self._addFileLink(siteId, fileId, component, componentId);
                    }
                    self._notifyFileDownloaded(siteId, fileId);
                    return response;
                }, function(err) {
                    self._notifyFileDownloadError(siteId, fileId);
                    return $q.reject(err);
                });
            });
        } else {
            return $q.reject();
        }
    };

    /**
     * Downloads a URL and update or add it to the pool.
     *
     * This uses the file system, you should always make sure that it is
     * accessible before calling this method.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_downloadForPoolByUrl
     * @param {String} siteId           The site ID.
     * @param {String} fileUrl          The file URL.
     * @param {Number} [revision]       File revision number.
     * @param {Number} [timemodified]   The time this file was modified. Can be used to check file state.
     * @param {String} [filePath]       Filepath to download the file to.
     * @param {Object} [poolFileObject] When set, the object will be updated, a new entry will not be created.
     * @return {Promise} Resolved with internal URL on success, rejected otherwise.
     * @protected
     */
    self._downloadForPoolByUrl = function(siteId, fileUrl, revision, timemodified, filePath, poolFileObject) {
        var fileId = self._getFileIdByUrl(fileUrl);
        filePath = filePath || self._getFilePath(siteId, fileId);

        if (poolFileObject && poolFileObject.fileId !== fileId) {
            $log.error('Invalid object to update passed');
            return $q.reject();
        }

        var downloadId = self.getFileDownloadId(fileUrl, filePath),
            deleted = false,
            promise;

        if (filePromises[siteId] && filePromises[siteId][downloadId]) {
            // There's already a download ongoing for this file in this location, return the promise.
            return filePromises[siteId][downloadId];
        } else if (!filePromises[siteId]) {
            filePromises[siteId] = {};
        }

        promise = $mmSitesManager.getSite(siteId).then(function(site) {

            if (!site.canDownloadFiles()) {
                return $q.reject();
            }

            return $mmWS.downloadFile(fileUrl, filePath).then(function(fileEntry) {
                var now = new Date(),
                    data = poolFileObject || {};

                data.downloaded = now.getTime();
                data.stale = false;
                data.url = fileUrl;
                data.revision = revision;
                data.timemodified = timemodified;
                data.path = filePath;

                return self._addFileToPool(siteId, fileId, data).then(function() {
                    return fileEntry.toURL();
                });
            });
        }).finally(function() {
            // Download finished, delete the promise.
            delete filePromises[siteId][downloadId];
            deleted = true;
        });

        if (!deleted) { // In case promise was finished immediately.
            filePromises[siteId][downloadId] = promise;
        }
        return promise;
    };

    /**
     * Fix a component ID to always be a Number.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_fixComponentId
     * @param {String|Number|undefined} The component ID.
     * @return {Number} The normalised component ID. -1 when undefined was passed.
     * @protected
     */
    self._fixComponentId = function(componentId) {
        var id = parseInt(componentId, 10);
        if (isNaN(id)) {
            return -1;
        }
        return id;
    };

    /**
     * Add the wstoken url and points to the correct script.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_fixPluginfileURL
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise}       Resolved with fixed URL on success, rejected otherwise.
     * @protected
     */
    self._fixPluginfileURL = function(siteId, fileUrl) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.fixPluginfileURL(fileUrl);
        });
    };

    /**
     * Get the ID of a file download. Used to keep track of filePromises.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileDownloadId
     * @param {String} fileUrl  The file URL.
     * @param {String} filePath The file destination path.
     * @return {String}         File download ID.
     * @protected
     */
    self.getFileDownloadId = function(fileUrl, filePath) {
        return md5.createHash(fileUrl + '###' + filePath);
    };

    /**
     * Get the name of the event used to notify download events ($mmEvents).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileEventName
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {String}       Event name.
     * @protected
     */
    self._getFileEventName = function(siteId, fileId) {
        return 'mmFilepoolFile:'+siteId+':'+fileId;
    };

    /**
     * Get the name of the event used to notify download events ($mmEvents).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileEventNameByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @return {Promise}       Promise resolved with event name.
     */
    self.getFileEventNameByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._getFileEventName(siteId, fileId);
        });
    };

    /**
     * Get a download promise. If the promise is not set, return undefined.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackageDownloadPromise
     * @param {String} siteId        Site ID.
     * @param {String} component     The component of the package.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {String}             Download promise or undefined.
     */
    self.getPackageDownloadPromise = function(siteId, component, componentId) {
        var packageId = self.getPackageId(component, componentId);
        if (packagesPromises[siteId] && packagesPromises[siteId][packageId]) {
            return packagesPromises[siteId][packageId];
        }
    };

    /**
     * Get the ID of a package.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackageId
     * @param {String} component     Package's component.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {String}              Package ID.
     */
    self.getPackageId = function(component, componentId) {
        return md5.createHash(component + '#' + self._fixComponentId(componentId));
    };

    /**
     * Get a package previous status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackagePreviousStatus
     * @param {String} siteId           Site ID.
     * @param {String} component        Package's component.
     * @param {Number} [componentId]    An ID to use in conjunction with the component.
     * @return {Promise}                Promise resolved with the status.
     */
    self.getPackagePreviousStatus = function(siteId, component, componentId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                return entry.previous || mmCoreNotDownloaded;
            }, function() {
                return mmCoreNotDownloaded;
            });
        });
    };

    /**
     * Get a package status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackageStatus
     * @param {String} siteId              Site ID.
     * @param {String} component           Package's component.
     * @param {Number} [componentId]       An ID to use in conjunction with the component.
     * @param {Number|String} [revision=0] Package's revision.
     * @param {Number} [timemodified=0]    Package's timemodified.
     * @return {Promise}                   Promise resolved with the status.
     */
    self.getPackageStatus = function(siteId, component, componentId, revision, timemodified) {
        revision = revision || 0;
        timemodified = timemodified || 0;
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);

            // Get status.
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                if (entry.status === mmCoreDownloaded) {
                    if (revision != entry.revision || timemodified > entry.timemodified) {
                        // File is outdated. Let's change its status.
                        entry.status = mmCoreOutdated;
                        entry.updated = new Date().getTime();
                        db.insert(mmFilepoolPackagesStore, entry).then(function() {
                            // Success inserting, trigger event.
                            self._triggerPackageStatusChanged(siteId, component, componentId, mmCoreOutdated);
                        });
                    }
                } else if (entry.status === mmCoreOutdated) {
                    if (revision === entry.revision && timemodified === entry.timemodified) {
                        // File isn't outdated anymore. Let's change its status.
                        entry.status = mmCoreDownloaded;
                        entry.updated = new Date().getTime();
                        db.insert(mmFilepoolPackagesStore, entry).then(function() {
                            // Success inserting, trigger event.
                            self._triggerPackageStatusChanged(siteId, component, componentId, mmCoreDownloaded);
                        });
                    }
                }
                return entry.status;
            }, function() {
                return mmCoreNotDownloaded;
            });
        });
    };

    /**
     * Get the deferred object for a file in the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getQueueDeferred
     * @param {String} siteId         The site ID.
     * @param {String} fileId         The file ID.
     * @param {Boolean} [create=true] True if it should create a new deferred if it doesn't exist.
     * @return {Object}               Deferred.
     * @protected
     */
    self._getQueueDeferred = function(siteId, fileId, create) {
        if (typeof create == 'undefined') {
            create = true;
        }

        if (!queueDeferreds[siteId]) {
            if (!create) {
                return;
            }
            queueDeferreds[siteId] = {};
        }
        if (!queueDeferreds[siteId][fileId]) {
            if (!create) {
                return;
            }
            queueDeferreds[siteId][fileId] = $q.defer();
        }
        return queueDeferreds[siteId][fileId];
    };

    /**
     * Get the promise for a file in the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getQueuePromise
     * @param {String} siteId         The site ID.
     * @param {String} fileId         The file ID.
     * @param {Boolean} [create=true] True if it should create a new promise if it doesn't exist.
     * @return {Promise}              Promise.
     * @protected
     */
    self._getQueuePromise = function(siteId, fileId, create) {
        return self._getQueueDeferred(siteId, fileId, create).promise;
    };

    /**
     * Is the file already in the pool?
     *
     * This does not check if the file is on the disk.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_hasFileInPool
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Resolved with file object from DB on success, rejected otherwise.
     * @protected
     */
    self._hasFileInPool = function(siteId, fileId) {
        return getSiteDb(siteId).then(function(db) {
            return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                if (typeof fileObject === 'undefined') {
                    return $q.reject();
                }
                return fileObject;
            });
        });
    };

    /**
     * Is the file in queue?
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_hasFileInQueue
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Resolved with file object from DB on success, rejected otherwise.
     * @protected
     */
    self._hasFileInQueue = function(siteId, fileId) {
        return $mmApp.getDB().get(mmFilepoolQueueStore, [siteId, fileId]).then(function(fileObject) {
            if (typeof fileObject === 'undefined') {
                return $q.reject();
            }
            return fileObject;
        });
    };

    /**
     * Returns the local URL of a drectory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getInternalUrlByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise}       Resolved with the URL. Rejected otherwise.
     * @protected
     */
    self.getDirectoryUrlByUrl = function(siteId, fileUrl) {
        if ($mmFS.isAvailable()) {
            return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
                var fileId = self._getFileIdByUrl(fileUrl);
                return $mmFS.getDir(self._getFilePath(siteId, fileId)).then(function(dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return $q.reject();
    };

    /**
     * Creates a unique ID based on a URL.
     *
     * This has a minimal handling of pluginfiles in order to generate a clean
     * file ID which will not change if pointing to the same pluginfile URL even
     * if the token or extra attributes have changed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getFileIdByUrl
     * @param {String} fileUrl The absolute URL to the file.
     * @return {Promise} The file ID.
     * @protected
     */
    self._getFileIdByUrl = function(fileUrl) {
        var url = self._removeRevisionFromUrl(fileUrl),
            candidate,
            extension = '';

        if (url.indexOf('/webservice/pluginfile') !== -1) {
            // Remove attributes that do not matter.
            angular.forEach(urlAttributes, function(regex) {
                url = url.replace(regex, '');
            });

            // For now only guesses the extension of the plugin files. We need the extension
            // for the inAppBrowser to open the files properly, e.g. the extension needs to be
            // part of the file name. Also, we need the mimetype to open the file with
            // web intents. The easiest way to provide such information is to keep the extension
            // in the file ID. Developers should not care about it, but as we are using the
            // file ID in the file path, devs and system can guess it.
            candidate = self._guessExtensionFromUrl(url);
            if (candidate && candidate !== 'php') {
                extension = '.' + candidate;
            }
        }
        return md5.createHash('url:' + url) + extension;
    };

    /**
     * Returns an absolute URL to access the file URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getFileUrlByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified=0] The time this file was modified.
     * @return {Promise} Resolved with the URL to use. When rejected, nothing could be done.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     *
     * This handles the queue and validity of the file. When we have a local copy of the file
     * we will assess whether or not it is still valid. If it is not valid, or we did not find
     * the file, we will add it to the queue to be downloaded later and we will return the URL
     * we received. When the file is valid we return a local URL to it.
     *
     * When the file cannot be found, and we are offline, then we reject the promise because
     * there was nothing we could do.
     */
    self._getFileUrlByUrl = function(siteId, fileUrl, mode, component, componentId, timemodified) {
        var fileId,
            revision;

        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._hasFileInPool(siteId, fileId).then(function(fileObject) {
                var response,
                    addToQueue = false,
                    fn;

                if (typeof fileObject === 'undefined') {
                    // We do not have the file, add it to the queue, and return real URL.
                    self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                    response = fileUrl;

                } else if (self._isFileOutdated(fileObject, revision, timemodified) && $mmApp.isOnline()) {
                    // The file is outdated, we add to the queue and return real URL.
                    self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                    response = fileUrl;

                } else {
                    // We found the file entry, now look for the file on disk.

                    if (mode === 'src') {
                        fn = self._getInternalSrcById;
                    } else {
                        fn = self._getInternalUrlById;
                    }

                    response = fn(siteId, fileId).then(function(internalUrl) {
                        // Perfect, the file is on disk.
                        // For the time being we assume that the component link already exists.
                        return internalUrl;
                    }, function() {
                        // We have a problem here, we could not retrieve the file though we thought
                        // we had it, we will delete the entries associated with that ID.
                        $log.debug('File ' + fileId + ' not found on disk');
                        self._removeFileById(siteId, fileId);
                        self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);

                        if ($mmApp.isOnline()) {
                            // We still have a chance to serve the right content.
                            return fileUrl;
                        }

                        return $q.reject();
                    });
                }

                return response;
            }, function() {
                // We do not have the file in store yet.
                self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                return fileUrl;
            });
        });
    };

    /**
     * Get the path to a file.
     *
     * This does not check if the file exists or not.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getFilePath
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {String} The path to the file relative to storage root.
     * @protected
     */
    self._getFilePath = function(siteId, fileId) {
        return $mmFS.getSiteFolder(siteId) + '/' + mmFilepoolFolder + '/' + fileId;
    };

    /**
     * Get the path to a file from its URL.
     *
     * This does not check if the file exists or not.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFilePathByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Promise resolved with the path to the file relative to storage root.
     */
    self.getFilePathByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._getFilePath(siteId, fileId);
        });
    };

    /**
     * Returns the file state: mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded or mmCoreOutdated.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileStateByUrl
     * @param {String} siteId           The site ID.
     * @param {String} fileUrl          File URL.
     * @param {Number} [timemodified=0] The time this file was modified.
     * @return {Promise}                Promise resolved with the file state.
     */
    self.getFileStateByUrl = function(siteId, fileUrl, timemodified) {
        var fileId,
            revision;

        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            fileId = self._getFileIdByUrl(fileUrl);

            return self._hasFileInQueue(siteId, fileId).then(function() {
                return mmCoreDownloading;
            }, function() {
                return self._hasFileInPool(siteId, fileId).then(function(fileObject) {
                    if (self._isFileOutdated(fileObject, revision, timemodified)) {
                        return mmCoreOutdated;
                    } else {
                        return mmCoreDownloaded;
                    }
                }, function() {
                    return mmCoreNotDownloaded;
                });
            });
        });
    };

    /**
     * Returns the internal SRC of a file.
     *
     * The returned URL from this method is typically used with IMG tags.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getInternalSrcById
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved with the internal URL. Rejected otherwise.
     * @protected
     */
    self._getInternalSrcById = function(siteId, fileId) {
        if ($mmFS.isAvailable()) {
            return $mmFS.getFile(self._getFilePath(siteId, fileId)).then(function(fileEntry) {
                // We use toInternalURL so images are loaded in iOS8 using img HTML tags,
                // with toURL the OS is unable to find the image files.
                return $mmFS.getInternalURL(fileEntry);
            });
        }
        return $q.reject();
    };

    /**
     * Returns the local URL of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getInternalUrlById
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved with the URL. Rejected otherwise.
     * @protected
     */
    self._getInternalUrlById = function(siteId, fileId) {
        if ($mmFS.isAvailable()) {
            return $mmFS.getFile(self._getFilePath(siteId, fileId)).then(function(fileEntry) {
                return fileEntry.toURL();
            });
        }
        return $q.reject();
    };

    /**
     * Returns the local URL of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getInternalUrlByPath
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved with the URL. Rejected otherwise.
     * @protected
     */
    self._getInternalUrlByPath = function(filePath) {
        if ($mmFS.isAvailable()) {
            return $mmFS.getFile(filePath).then(function(fileEntry) {
                return fileEntry.toURL();
            });
        }
        return $q.reject();
    };

    /**
     * Get package revision number from a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getRevisionFromFileList
     * @param {Object[]} files Package files.
     * @return {Number}        Package revision.
     */
    self.getRevisionFromFileList = function(files) {
        var revision = 0;

        angular.forEach(files, function(file) {
            if (file.fileurl) {
                var r = self.getRevisionFromUrl(file.fileurl);
                if (r > revision) {
                    revision = r;
                }
            }
        });

        return revision;
    };

    /**
     * Get the revision number from a file URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getRevisionFromUrl
     * @param {String} url URL to get the revision number.
     * @return {String}    Revision number.
     * @protected
     */
    self.getRevisionFromUrl = function(url) {
        var matches = url.match(revisionRegex);
        if (matches && typeof matches[1] != 'undefined') {
            return parseInt(matches[1]);
        }
    };

    /**
     * Returns an absolute URL to use in IMG tags.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getSrcByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified] The time this file was modified.
     * @return {Promise} Resolved with the URL to use. When rejected, nothing could be done,
     *                   which means that you should not even use the fileUrl passed.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with IMG tags.
     * See {@link $mmFilepool#_getFileUrlByUrl} for more details.
     */
    self.getSrcByUrl = function(siteId, fileUrl, component, componentId, timemodified) {
        return self._getFileUrlByUrl(siteId, fileUrl, 'src', component, componentId, timemodified);
    };

    /**
     * Get package timemodified from a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getTimemodifiedFromFileList
     * @param {Object[]} files Package files.
     * @return {Number}        Package time modified.
     */
    self.getTimemodifiedFromFileList = function(files) {
        var timemod = 0;

        angular.forEach(files, function(file) {
            if (file.timemodified > timemod) {
                timemod = file.timemodified;
            }
        });

        return timemod;
    };

    /**
     * Returns an absolute URL to access the file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getUrlByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified] The time this file was modified.
     * @return {Promise} Resolved with the URL to use. When rejected, nothing could be done,
     *                   which means that you should not even use the fileUrl passed.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with a local browser.
     * See {@link $mmFilepool#_getFileUrlByUrl} for more details.
     */
    self.getUrlByUrl = function(siteId, fileUrl, component, componentId, timemodified) {
        return self._getFileUrlByUrl(siteId, fileUrl, 'url', component, componentId, timemodified);
    };

    /**
     * Guess the extension of a file from its URL.
     *
     * This is very weak and unreliable.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_guessExtensionFromUrl
     * @param {String} fileUrl The file URL.
     * @return {String} The lowercased extension without the dot, or undefined.
     * @protected
     */
    self._guessExtensionFromUrl = function(fileUrl) {
        var split = fileUrl.split('.'),
            candidate,
            extension;

        if (split.length > 1) {
            candidate = split.pop().toLowerCase();
            if (extensionRegex.test(candidate)) {
                extension = candidate;
            }
        }

        return extension;
    };

    /**
     * Invalidate all the files in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#invalidateAllFiles
     * @param {String} siteId The site ID.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to ignore a failure.
     * @description
     * Invalidates all files by marking it stale. See {@link $mmFilepool#invalidateFileByUrl} for more details.
     */
    self.invalidateAllFiles = function(siteId) {
        return getSiteDb(siteId).then(function(db) {
            return db.getAll(mmFilepoolStore).then(function(items) {
                var promises = [];
                angular.forEach(items, function(item) {
                    item.stale = true;
                    promises.push(db.insert(mmFilepoolStore, item));
                });
                return $q.all(promises);
            });
        });
    };

    /**
     * Invalidate a file by URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#invalidateFileByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to ignore a failure.
     * @description
     * Invalidates a file by marking it stale. It will not be added to the queue automatically,
     * but the next time this file will be requested it will be added to the queue. This is to allow
     * for cache invalidation without necessarily re-triggering downloads.
     * You can manully call {@link $mmFilepool#addToQueueByUrl} to counter this behaviour.
     * Please note that when a file is marked as stale, the user will be presented the stale file
     * only if they do not have network access.
     */
    self.invalidateFileByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return getSiteDb(siteId).then(function(db) {
                return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                    if (!fileObject) {
                        // Nothing to do, we do not have the file in store.
                        return;
                    }
                    fileObject.stale = true;
                    return db.insert(mmFilepoolStore, fileObject);
                });
            });
        });
    };

    /**
     * Invalidate all the matching files from a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#invalidateFilesByComponent
     * @param {String} siteId The site ID.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to ignore a failure.
     * @description
     * Invalidates a file by marking it stale. See {@link $mmFilepool#invalidateFileByUrl} for more details.
     */
    self.invalidateFilesByComponent = function(siteId, component, componentId) {
        var values = { stale: true },
            where;
        if (typeof componentId !== 'undefined') {
            where = ['componentAndId', '=', [component, self._fixComponentId(componentId)]];
        } else {
            where = ['component', '=', component];
        }

        return getSiteDb(siteId).then(function(db) {
            return db.query(mmFilepoolLinksStore, where).then(function(items) {
                var promise,
                    promises = [];

                angular.forEach(items, function(item) {
                    promise = db.get(mmFilepoolStore, item.fileId).then(function(fileEntry) {
                        if (!fileEntry) {
                            return;
                        }
                        fileEntry.stale = true;
                        return db.insert(mmFilepoolStore, fileEntry);
                    });
                    promises.push(promise);
                });

                return $q.all(promises);
            });
        });
    };

    /**
     * Check if a file is downloading.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#isFileDownloadingByUrl
     * @param {String} siteId           The site ID.
     * @param {String} fileUrl          File URL.
     * @param {Promise}                 Promise resolved if file is downloading, false otherwise.
     */
    self.isFileDownloadingByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            fileId = self._getFileIdByUrl(fileUrl);
            return self._hasFileInQueue(siteId, fileId);
        });
    };

    /**
     * Check if a file is outdated.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_isFileOutdated
     * @param {Object} fileObject     File object.
     * @param {Number} [revision]     File revision number.
     * @param {Number} [timemodified] The time this file was modified.
     * @param {Boolean}               True if file is outdated, false otherwise.
     */
    self._isFileOutdated = function(fileObject, revision, timemodified) {
        return fileObject.stale || revision > fileObject.revision || timemodified > fileObject.timemodified;
    };

    /**
     * Notify a file has been downloaded.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_notifyFileDownloaded
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     */
    self._notifyFileDownloaded = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {success: true});
    };

    /**
     * Notify error occurred while downloading a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_notifyFileDownloadError
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     */
    self._notifyFileDownloadError = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {success: false});
    };

    /**
     * Prefetches a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#prefetchPackage
     * @param {String} siteId         The site ID.
     * @param  {Object[]} fileList    List of files to download.
     * @param {String} component      The component to link the file to.
     * @param {Number} componentId    An ID to identify the download. Must be unique.
     * @param {Number} [revision]     Package's revision. If not defined, it will be calculated using the list of files.
     * @param {Number} [timemodified] Package's timemodified. If not defined, it will be calculated using the list of files.
     * @param {String} [dirPath]      Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                                the files directly inside the filepool folder.
     * @return {Promise}              Promise resolved when all files are downloaded.
     */
    self.prefetchPackage = function(siteId, fileList, component, componentId, revision, timemodified, dirPath) {
        return self._downloadOrPrefetchPackage(siteId, fileList, true, component, componentId, revision, timemodified, dirPath);
    };

    /**
     * Process the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_processQueue
     * @return {Void}
     * @description
     * Processes the queue.
     *
     * This loops over itself to keep on processing the queue in the background.
     * The queue process is site agnostic.
     */
    self._processQueue = function() {
        var deferred = $q.defer(),
            promise;

        if (queueState !== QUEUE_RUNNING) {
            // Silently ignore, the queue is on pause.
            deferred.reject(ERR_QUEUE_ON_PAUSE);
            promise = deferred.promise;

        } else if (!$mmFS.isAvailable() || !$mmApp.isOnline()) {
            deferred.reject(ERR_FS_OR_NETWORK_UNAVAILABLE);
            promise = deferred.promise;

        } else {
            promise = self._processImportantQueueItem();
        }

        promise.then(function() {
            // All good, we schedule next execution.
            $timeout(self._processQueue, mmFilepoolQueueProcessInterval);

        }, function(error) {

            // We had an error, in which case we pause the processing.
            if (error === ERR_FS_OR_NETWORK_UNAVAILABLE) {
                $log.debug('Filesysem or network unavailable, pausing queue processing.');

            } else if (error === ERR_QUEUE_IS_EMPTY) {
                $log.debug('Queue is empty, pausing queue processing.');
                $mmEvents.trigger(mmCoreEventQueueEmpty);
            }

            queueState = QUEUE_PAUSED;
        });
    };

    /**
     * Process the most important queue item.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_processImportantQueueItem
     * @return {Promise} Resolved on success. Rejected on failure.
     */
    self._processImportantQueueItem = function() {
        return $mmApp.getDB().query(mmFilepoolQueueStore, undefined, 'sortorder', undefined, 1)
        .then(function(items) {
            var item = items.pop();
            if (!item) {
                return $q.reject(ERR_QUEUE_IS_EMPTY);
            }
            return self._processQueueItem(item);
        }, function() {
            return $q.reject(ERR_QUEUE_IS_EMPTY);
        });
    };

    /**
     * Process a queue item.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_processQueueItem
     * @param {Object} item The object from the queue store.
     * @return {Promise} Resolved on success. Rejected on failure.
     * @protected
     */
    self._processQueueItem = function(item) {
        var siteId = item.siteId,
            fileId = item.fileId,
            fileUrl = item.url,
            revision = item.revision,
            timemodified = item.timemodified,
            filePath = item.path,
            links = item.links || [];

        $log.debug('Processing queue item: ' + siteId + ', ' + fileId);
        return getSiteDb(siteId).then(function(db) {
            return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                if (fileObject && !self._isFileOutdated(fileObject, revision, timemodified)) {
                    // We have the file, it is not stale, we can update links and remove from queue.
                    $log.debug('Queued file already in store, ignoring...');
                    self._addFileLinks(siteId, fileId, links);
                    self._removeFromQueue(siteId, fileId).finally(function() {
                        self._treatQueueDeferred(siteId, fileId, true);
                    });
                    self._notifyFileDownloaded(siteId, fileId);
                    return;
                }
                // The file does not exist, or is stale, ... download it.
                return download(siteId, fileUrl, fileObject, links);
            }, function() {
                // The file does not exist, download it.
                return download(siteId, fileUrl, undefined, links);
            });
        }, function() {
            // Couldn't get site DB, site was probably deleted.
            $log.debug('Item dropped from queue due to site DB not retrieved: ' + fileUrl);
            return self._removeFromQueue(siteId, fileId).catch(function() {}).finally(function() {
                self._treatQueueDeferred(siteId, fileId, false);
                self._notifyFileDownloadError(siteId, fileId);
            });
        });

        /**
         * Download helper to avoid code duplication.
         */
        function download(siteId, fileUrl, fileObject, links) {
            return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject).then(function() {
                var promise;

                // Success, we add links and remove from queue.
                self._addFileLinks(siteId, fileId, links);
                promise = self._removeFromQueue(siteId, fileId);

                self._treatQueueDeferred(siteId, fileId, true);
                self._notifyFileDownloaded(siteId, fileId);

                // Wait for the item to be removed from queue before resolving the promise.
                // If the item could not be removed from queue we still resolve the promise.
                return promise.catch(function() {});

            }, function(errorObject) {
                // Whoops, we have an error...
                var dropFromQueue = false;

                if (typeof errorObject !== 'undefined' && errorObject.source === fileUrl) {
                    // This is most likely a $cordovaFileTransfer error.

                    if (errorObject.code === 1) { // FILE_NOT_FOUND_ERR.
                        // The file was not found, most likely a 404, we remove from queue.
                        dropFromQueue = true;

                    } else if (errorObject.code === 2) { // INVALID_URL_ERR.
                        // The URL is invalid, we drop the file from the queue.
                        dropFromQueue = true;

                    } else if (errorObject.code === 3) { // CONNECTION_ERR.
                        // If there was an HTTP status, then let's remove from the queue.
                        dropFromQueue = true;
                    } else if (errorObject.code === 4) { // ABORTED_ERR.
                        // The transfer was aborted, we will keep the file in queue.
                    } else if (errorObject.code === 5) { // NOT_MODIFIED_ERR.
                        // We have the latest version of the file, HTTP 304 status.
                        dropFromQueue = true;
                    } else {
                        // Unknown error, let's remove the file from the queue to avoid
                        // locking down the queue because of one file.
                        dropFromQueue = true;
                    }
                } else {
                    dropFromQueue = true;
                }

                if (dropFromQueue) {
                    var promise;

                    $log.debug('Item dropped from queue due to error: ' + fileUrl);
                    promise = self._removeFromQueue(siteId, fileId);

                    // Consider this as a silent error, never reject the promise here.
                    return promise.catch(function() {}).finally(function() {
                        self._treatQueueDeferred(siteId, fileId, false);
                        self._notifyFileDownloadError(siteId, fileId);
                    });
                } else {
                    // We considered the file as legit but did not get it, failure.
                    self._treatQueueDeferred(siteId, fileId, false);
                    self._notifyFileDownloadError(siteId, fileId);
                    return $q.reject();
                }

            }, function(progress) {
                // Send the progress object to the queue deferred.
                if (queueDeferreds[siteId] && queueDeferreds[siteId][fileId]) {
                    queueDeferreds[siteId][fileId].notify(progress);
                }
            });
        }

    };

    /**
     * Remove a file from the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_removeFromQueue
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._removeFromQueue = function(siteId, fileId) {
        return $mmApp.getDB().remove(mmFilepoolQueueStore, [siteId, fileId]);
    };

    /**
     * Remove a file from the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_removeFileById
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._removeFileById = function(siteId, fileId) {
        return getSiteDb(siteId).then(function(db) {
            var p1, p2, p3;
            p1 = db.remove(mmFilepoolStore, fileId);
            p2 = db.where(mmFilepoolLinksStore, 'fileId', '=', fileId).then(function(entries) {
                return $q.all(entries.map(function(entry) {
                    return db.remove(mmFilepoolLinksStore, [entry.fileId, entry.component, entry.componentId]);
                }));
            });
            p3 = $mmFS.isAvailable() ? $mmFS.removeFile(self._getFilePath(siteId, fileId)) : $q.when();
            return $q.all([p1, p2, p3]);
        });
    };

    /**
     * Delete all the matching files from a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#removeFilesByComponent
     * @param {String} siteId        The site ID.
     * @param {String} component     The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise}             Resolved on success. Rejected on failure.
     */
    self.removeFilesByComponent = function(siteId, component, componentId) {
        var where;
        if (typeof componentId !== 'undefined') {
            where = ['componentAndId', '=', [component, self._fixComponentId(componentId)]];
        } else {
            where = ['component', '=', component];
        }

        return getSiteDb(siteId).then(function(db) {
            return db.query(mmFilepoolLinksStore, where);
        }).then(function(items) {
            return $q.all(items.map(function(item) {
                return self._removeFileById(siteId, item.fileId);
            }));
        });
    };

    /**
     * Remove a file from the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#removeFileByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise}       Resolved on success, rejected on failure. It is advised to silently ignore failures.
     */
    self.removeFileByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._removeFileById(siteId, fileId);
        });
    };

    /**
     * Removes the revision number from a file URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_removeRevisionFromUrl
     * @param {String} url URL to remove the revision number.
     * @return {String}    URL without revision number.
     * @protected
     * @description
     * The revision is used to know if a file has changed. We remove it from the URL to prevent storing a file per revision.
     */
    self._removeRevisionFromUrl = function(url) {
        return url.replace(revisionRegex, '/content/0/');
    };

    /**
     * Change the package status, setting it to the previous status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#setPackagePreviousStatus
     * @param {String} siteId        Site ID.
     * @param {String} component     Package's component.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise}             Promise resolved when the status is changed. Resolve param: new status.
     */
    self.setPackagePreviousStatus = function(siteId, component, componentId) {
        $log.debug('Set previous status for package ' + component + ' ' + componentId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);

            // Get current stored data, we'll only update 'status' and 'updated' fields.
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                entry.status = entry.previous || mmCoreNotDownloaded;
                entry.updated = new Date().getTime();
                $log.debug('Set status \'' + entry.status + '\' for package ' + component + ' ' + componentId);

                return db.insert(mmFilepoolPackagesStore, entry).then(function() {
                    // Success updating, trigger event.
                    self._triggerPackageStatusChanged(siteId, component, componentId, entry.status);
                    return entry.status;
                });
            });
        });
    };

    /**
     * Store package status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#storePackageStatus
     * @param {String} siteId           Site ID.
     * @param {String} component        Package's component.
     * @param {Number} [componentId]    An ID to use in conjunction with the component.
     * @param {String} status           New package status.
     * @param {Number} [revision=0]     Package's revision.
     * @param {Number} [timemodified=0] Package's timemodified.
     * @return {Promise}                Promise resolved when status is stored.
     */
    self.storePackageStatus = function(siteId, component, componentId, status, revision, timemodified) {
        $log.debug('Set status \'' + status + '\' for package ' + component + ' ' + componentId);
        revision = revision || 0;
        timemodified = timemodified || 0;

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);

            // Search current status to set it as previous status.
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                return entry.status;
            }, function() {
                return undefined; // No previous status.
            }).then(function(previousStatus) {
                var promise;
                if (previousStatus === status) {
                    // The package already has this status, no need to change it.
                    promise = $q.when();
                } else {
                    promise = db.insert(mmFilepoolPackagesStore, {
                        id: packageId,
                        component: component,
                        componentId: componentId,
                        status: status,
                        previous: previousStatus,
                        revision: revision,
                        timemodified: timemodified,
                        updated: new Date().getTime()
                    });
                }

                return promise.then(function() {
                    // Success inserting, trigger event.
                    self._triggerPackageStatusChanged(siteId, component, componentId, status);
                });
            });
        });
    };

    /**
     * Resolves or rejects a queue deferred and removes it from the list.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_treatQueueDeferred
     * @param {String} siteId   The site ID.
     * @param {String} fileId   The file ID.
     * @param {Boolean} resolve True if promise should be resolved, false if it should be rejected.
     * @return {Object}         Deferred.
     * @protected
     */
    self._treatQueueDeferred = function(siteId, fileId, resolve) {
        if (queueDeferreds[siteId] && queueDeferreds[siteId][fileId]) {
            if (resolve) {
                queueDeferreds[siteId][fileId].resolve();
            } else {
                queueDeferreds[siteId][fileId].reject();
            }
            delete queueDeferreds[siteId][fileId];
        }
    };

    /**
     * Trigger mmCoreEventPackageStatusChanged with the right data.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_triggerPackageStatusChanged
     * @param {String} siteId        Site ID.
     * @param {String} component     Package's component.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {String} status        New package status.
     * @return {Void}
     * @protected
     */
    self._triggerPackageStatusChanged = function(siteId, component, componentId, status) {
        var data = {
            siteid: siteId,
            component: component,
            componentId: componentId,
            status: status
        };
        $mmEvents.trigger(mmCoreEventPackageStatusChanged, data);
    };

    return self;
}])

.run(["$log", "$ionicPlatform", "$timeout", "$mmFilepool", function($log, $ionicPlatform, $timeout, $mmFilepool) {
    $log = $log.getInstance('$mmFilepool');

    $ionicPlatform.ready(function() {
        // Waiting for the platform to be ready, and a few more before we start processing the queue.
        $timeout($mmFilepool.checkQueueProcessing, 1000);
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmFsSitesFolder', 'sites')
.constant('mmFsTmpFolder', 'tmp')

/**
 * @ngdoc service
 * @name $mmFS
 * @module mm.core
 * @description
 * This service handles the interaction with the FileSystem.
 */
.factory('$mmFS', ["$ionicPlatform", "$cordovaFile", "$log", "$q", "$http", "$cordovaZip", "mmFsSitesFolder", "mmFsTmpFolder", function($ionicPlatform, $cordovaFile, $log, $q, $http, $cordovaZip, mmFsSitesFolder, mmFsTmpFolder) {

    $log = $log.getInstance('$mmFS');

    var self = {},
        initialized = false,
        basePath = '',
        isHTMLAPI = false,
        mimeTypes = {};

    // Loading all the mimetypes.
    $http.get('core/assets/mimetypes.json').then(function(response) {
        mimeTypes = response.data;
    }, function() {
        // It failed, never mind...
    });

    // Formats to read a file.
    self.FORMATTEXT         = 0;
    self.FORMATDATAURL      = 1;
    self.FORMATBINARYSTRING = 2;
    self.FORMATARRAYBUFFER  = 3;

    /**
     * Sets basePath to use with HTML API. Reserved for core use.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#setHTMLBasePath
     * @param {String} path Base path to use.
     */
    self.setHTMLBasePath = function(path) {
        isHTMLAPI = true;
        basePath = path;
    };

    /**
     * Checks if we're using HTML API.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#usesHTMLAPI
     * @return {Boolean} True if uses HTML API, false otherwise.
     */
    self.usesHTMLAPI = function() {
        return isHTMLAPI;
    };

    /**
     * Initialize basePath based on the OS if it's not initialized already.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#init
     * @return {Promise} Promise to be resolved when the initialization is finished.
     */
    self.init = function() {

        var deferred = $q.defer();

        if (initialized) {
            deferred.resolve();
            return deferred.promise;
        }

        $ionicPlatform.ready(function() {

            if (ionic.Platform.isAndroid()) {
                basePath = cordova.file.externalApplicationStorageDirectory;
            } else if (ionic.Platform.isIOS()) {
                basePath = cordova.file.documentsDirectory;
            } else if (!self.isAvailable() || basePath === '') {
                $log.error('Error getting device OS.');
                deferred.reject();
                return;
            }

            initialized = true;
            $log.debug('FS initialized: '+basePath);
            deferred.resolve();
        });

        return deferred.promise;
    };

    /**
     * Check if the plugin is available.
     *
     * @return {Boolean} True when cordova is initialised.
     */
    self.isAvailable = function() {
        return typeof window.resolveLocalFileSystemURL !== 'undefined' && typeof FileTransfer !== 'undefined';
    };

    /**
     * Get a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFile
     * @param  {String}  path Relative path to the file.
     * @return {Promise}      Promise to be resolved when the file is retrieved.
     */
    self.getFile = function(path) {
        return self.init().then(function() {
            $log.debug('Get file: '+path);
            return $cordovaFile.checkFile(basePath, path);
        });
    };

    /**
     * Get a directory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getDir
     * @param  {String}  path Relative path to the directory.
     * @return {Promise}      Promise to be resolved when the directory is retrieved.
     */
    self.getDir = function(path) {
        return self.init().then(function() {
            $log.debug('Get directory: '+path);
            return $cordovaFile.checkDir(basePath, path);
        });
    };

    /**
     * Get site folder path.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getSiteFolder
     * @param  {String} siteId Site ID.
     * @return {String}        Site folder path.
     */
    self.getSiteFolder = function(siteId) {
        return mmFsSitesFolder + '/' + siteId;
    };

    /**
     * Create a directory or a file.
     *
     * @param  {Boolean} isDirectory  True if a directory should be created, false if it should create a file.
     * @param  {String}  path         Relative path to the dir/file.
     * @param  {Boolean} failIfExists True if it should fail if the dir/file exists, false otherwise.
     * @param  {String}  base         Base path to create the dir/file in. If not set, use basePath.
     * @return {Promise}              Promise to be resolved when the dir/file is created.
     */
    function create(isDirectory, path, failIfExists, base) {
        return self.init().then(function() {
            base = base || basePath;

            if (path.indexOf('/') == -1) {
                if (isDirectory) {
                    $log.debug('Create dir ' + path + ' in ' + base);
                    return $cordovaFile.createDir(base, path, !failIfExists);
                } else {
                    $log.debug('Create file ' + path + ' in ' + base);
                    return $cordovaFile.createFile(base, path, !failIfExists);
                }
            } else {
                // $cordovaFile doesn't allow creating more than 1 level at a time (e.g. tmp/folder).
                // We need to create them 1 by 1.
                var firstDir = path.substr(0, path.indexOf('/'));
                var restOfPath = path.substr(path.indexOf('/') + 1);

                $log.debug('Create dir ' + firstDir + ' in ' + base);

                return $cordovaFile.createDir(base, firstDir, true).then(function(newDirEntry) {
                    return create(isDirectory, restOfPath, failIfExists, newDirEntry.toURL());
                }, function(error) {
                    $log.error('Error creating directory ' + firstDir + ' in ' + base);
                    return $q.reject(error);
                });
            }
        });
    }

    /**
     * Create a directory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#createDir
     * @param  {String}  path         Relative path to the directory.
     * @param  {Boolean} failIfExists True if it should fail if the directory exists, false otherwise.
     * @return {Promise}              Promise to be resolved when the directory is created.
     */
    self.createDir = function(path, failIfExists) {
        failIfExists = failIfExists || false; // Default value false.
        return create(true, path, failIfExists);
    };

    /**
     * Create a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#createFile
     * @param  {String}  path         Relative path to the file.
     * @param  {Boolean} failIfExists True if it should fail if the file exists, false otherwise..
     * @return {Promise}              Promise to be resolved when the file is created.
     */
    self.createFile = function(path, failIfExists) {
        failIfExists = failIfExists || false; // Default value false.
        return create(false, path, failIfExists);
    };

    /**
     * Removes a directory and all its contents.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeDir
     * @param  {String}  path    Relative path to the directory.
     * @return {Promise}         Promise to be resolved when the directory is deleted.
     */
    self.removeDir = function(path) {
        return self.init().then(function() {
            $log.debug('Remove directory: ' + path);
            return $cordovaFile.removeRecursively(basePath, path);
        });
    };

    /**
     * Removes a file and all its contents.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeFile
     * @param  {String}  path    Relative path to the file.
     * @return {Promise}         Promise to be resolved when the file is deleted.
     */
    self.removeFile = function(path) {
        return self.init().then(function() {
            $log.debug('Remove file: ' + path);
            return $cordovaFile.removeFile(basePath, path);
        });
    };

    /**
     * Retrieve the contents of a directory (not subdirectories).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getDirectoryContents
     * @param  {String} path Relative path to the directory.
     * @return {Promise}     Promise to be resolved when the contents are retrieved.
     */
    self.getDirectoryContents = function(path) {
        $log.debug('Get contents of dir: ' + path);
        return self.getDir(path).then(function(dirEntry) {

            var deferred = $q.defer();

            var directoryReader = dirEntry.createReader();
            directoryReader.readEntries(deferred.resolve, deferred.reject);

            return deferred.promise;
        });
    };

    /**
     * Calculate the size of a directory or a file.
     *
     * @param  {String} path Relative path to the directory or file.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    function getSize(entry) {

        var deferred = $q.defer();

        if (entry.isDirectory) {

            var directoryReader = entry.createReader();
            directoryReader.readEntries(function(entries) {

                var promises = [];
                for (var i = 0; i < entries.length; i++) {
                    promises.push(getSize(entries[i]));
                }

                $q.all(promises).then(function(sizes) {

                    var directorySize = 0;
                    for (var i = 0; i < sizes.length; i++) {
                        var fileSize = parseInt(sizes[i]);
                        if (isNaN(fileSize)) {
                            deferred.reject();
                            return;
                        }
                        directorySize += fileSize;
                    }
                    deferred.resolve(directorySize);

                }, deferred.reject);

            }, deferred.reject);

        } else if (entry.isFile) {
            entry.file(function(file) {
                deferred.resolve(file.size);
            }, deferred.reject);
        }

        return deferred.promise;
    }

    /**
     * Calculate the size of a directory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getDirectorySize
     * @param  {String} path Relative path to the directory.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    self.getDirectorySize = function(path) {
        $log.debug('Get size of dir: ' + path);
        return self.getDir(path).then(function(dirEntry) {
           return getSize(dirEntry);
        });
    };

    /**
     * Calculate the size of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFileSize
     * @param  {String} path Relative path to the file.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    self.getFileSize = function(path) {
        $log.debug('Get size of file: ' + path);
        return self.getFile(path).then(function(fileEntry) {
           return getSize(fileEntry);
        });
    };

    /**
     * Get file object from a FileEntry.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFileSizeFromFileEntry
     * @param  {String} path Relative path to the file.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    self.getFileObjectFromFileEntry = function(entry) {
        $log.debug('Get file object of: ' + entry.fullPath);
        var deferred = $q.defer();
        entry.file(function(file) {
            deferred.resolve(file);
        }, deferred.reject);
        return deferred.promise;
    };

    /**
     * Calculate the free space in the disk.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#calculateFreeSpace
     * @return {Promise} Promise resolved with the estimated free space in bytes.
     */
    self.calculateFreeSpace = function() {
        if (ionic.Platform.isIOS() || isHTMLAPI) {
            // getFreeDiskSpace doesn't work on iOS. See https://tracker.moodle.org/browse/MOBILE-956.
            // Ugly fix: request a file system instance with a minimum size until we get an error.

            if (window.requestFileSystem) {

                var iterations = 0,
                    maxIterations = 50,
                    deferred = $q.defer();

                function calculateByRequest(size, ratio) {
                    var deferred = $q.defer();

                    window.requestFileSystem(LocalFileSystem.PERSISTENT, size, function() {
                        iterations++;
                        if (iterations > maxIterations) {
                            deferred.resolve(size);
                            return;
                        }
                        calculateByRequest(size * ratio, ratio).then(deferred.resolve);
                    }, function() {
                        deferred.resolve(size / ratio);
                    });

                    return deferred.promise;
                };

                // General calculation, base 1MB and increasing factor 1.3.
                calculateByRequest(1048576, 1.3).then(function(size) {
                    iterations = 0;
                    maxIterations = 10;
                    // More accurate. Factor is 1.1.
                    calculateByRequest(size, 1.1).then(deferred.resolve);
                });

                return deferred.promise;
            } else {
                return $q.reject();
            }

        } else {
            return $cordovaFile.getFreeDiskSpace().then(function(size) {
                return size * 1024; // GetFreeDiskSpace returns KB.
            });
        }
    };

    /**
     * Normalize a filename that usually comes URL encoded.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#normalizeFileName
     * @param  {String} filename The file name.
     * @return {String}          The file name normalized.
     */
    self.normalizeFileName = function(filename) {
        filename = decodeURIComponent(filename);
        return filename;
    };

    /**
     * Read a file from local file system.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#readFile
     * @param  {String}  path   Relative path to the file.
     * @param  {Number}  format Format to read the file. By default, FORMATTEXT. Must be one of:
     *                                  $mmFS.FORMATTEXT
     *                                  $mmFS.FORMATDATAURL
     *                                  $mmFS.FORMATBINARYSTRING
     *                                  $mmFS.FORMATARRAYBUFFER
     * @return {Promise}        Promise to be resolved when the file is read.
     */
    self.readFile = function(path, format) {
        format = format || self.FORMATTEXT;
        $log.debug('Read file ' + path + ' with format '+format);
        switch (format) {
            case self.FORMATDATAURL:
                return $cordovaFile.readAsDataURL(basePath, path);
            case self.FORMATBINARYSTRING:
                return $cordovaFile.readAsBinaryString(basePath, path);
            case self.FORMATARRAYBUFFER:
                return $cordovaFile.readAsArrayBuffer(basePath, path);
            default:
                return $cordovaFile.readAsText(basePath, path);
        }
    };

    /**
     * Read file contents from a file data object.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#readFileData
     * @param  {Object}  fileData File's data.
     * @param  {Number}  format   Format to read the file. By default, FORMATTEXT. Must be one of:
     *                                  $mmFS.FORMATTEXT
     *                                  $mmFS.FORMATDATAURL
     *                                  $mmFS.FORMATBINARYSTRING
     *                                  $mmFS.FORMATARRAYBUFFER
     * @return {Promise}          Promise to be resolved when the file is read.
     */
    self.readFileData = function(fileData, format) {
        format = format || self.FORMATTEXT;
        $log.debug('Read file from file data with format '+format);

        var deferred = $q.defer();

        var reader = new FileReader();
        reader.onloadend = function(evt) {
            if (evt.target.result !== undefined || evt.target.result !== null) {
                deferred.resolve(evt.target.result);
            } else if (evt.target.error !== undefined || evt.target.error !== null) {
                deferred.reject(evt.target.error);
            } else {
                deferred.reject({code: null, message: 'READER_ONLOADEND_ERR'});
            }
        };

        switch (format) {
            case self.FORMATDATAURL:
                reader.readAsDataURL(fileData);
                break;
            case self.FORMATBINARYSTRING:
                reader.readAsBinaryString(fileData);
                break;
            case self.FORMATARRAYBUFFER:
                reader.readAsArrayBuffer(fileData);
                break;
            default:
                reader.readAsText(fileData);
        }

        return deferred.promise;
    };

    /**
     * Writes some data in a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#writeFile
     * @param  {String}  path Relative path to the file.
     * @param  {String}  data Data to write.
     * @return {Promise}      Promise to be resolved when the file is written.
     */
    self.writeFile = function(path, data) {
        $log.debug('Write file: ' + path);
        return self.init().then(function() {
            // Create file (and parent folders) to prevent errors.
            return self.createFile(path).then(function(fileEntry) {
                if (isHTMLAPI && typeof data == 'string') {
                    // We need to write Blobs.
                    var type = self.getMimeType(self.getFileExtension(path));
                    data = new Blob([data], {type: type || 'text/plain'});
                }
                return $cordovaFile.writeFile(basePath, path, data, true).then(function() {
                    return fileEntry;
                });
            });
        });
    };

    /**
     * Gets a file that might be outside the app's folder.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getExternalFile
     * @param  {String}  fullPath Absolute path to the file.
     * @return {Promise}          Promise to be resolved when the file is retrieved.
     */
    self.getExternalFile = function(fullPath) {
        return $cordovaFile.checkFile(fullPath, '');
    };

    /**
     * Removes a file that might be outside the app's folder.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeExternalFile
     * @param  {String}  fullPath Absolute path to the file.
     * @return {Promise}          Promise to be resolved when the file is removed.
     */
    self.removeExternalFile = function(fullPath) {
        // removeFile(fullPath, '') does not work, we need to pass two valid parameters.
        var directory = fullPath.substring(0, fullPath.lastIndexOf('/') );
        var filename = fullPath.substr(fullPath.lastIndexOf('/') + 1);
        return $cordovaFile.removeFile(directory, filename);
    };

    /**
     * Get the base path where the application files are stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getBasePath
     * @return {Promise} Promise to be resolved when the base path is retrieved.
     */
    self.getBasePath = function() {
        return self.init().then(function() {
            if (basePath.slice(-1) == '/') {
                return basePath;
            } else {
                return basePath + '/';
            }
        });
    };

    /**
     * Get the base path where the application files are stored in the format to be used for downloads.
     * iOS: Internal URL (cdvfile://).
     * Others: basePath (file://)
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getBasePathToDownload
     * @return {Promise} Promise to be resolved when the base path is retrieved.
     */
    self.getBasePathToDownload = function() {
        return self.init().then(function() {
            if (ionic.Platform.isIOS()) {
                // In iOS we want the internal URL (cdvfile://localhost/persistent/...).
                return $cordovaFile.checkDir(basePath, '').then(function(dirEntry) {
                    return dirEntry.toInternalURL();
                });
            } else {
                // In the other platforms we use the basePath as it is (file://...).
                return basePath;
            }
        });
    };

    /**
     * Get temporary directory path.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getTmpFolder
     * @return {String} Tmp directory path.
     */
    self.getTmpFolder = function() {
        return mmFsTmpFolder;
    };

    /**
     * Move a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#moveEntry
     * @param {String} originalPath Path to the file to move.
     * @param {String} newPath      New path of the file.
     * @return {Promise}            Promise resolved when the entry is moved.
     */
    self.moveFile = function(originalPath, newPath) {
        return self.init().then(function() {
            if (isHTMLAPI) {
                // In Cordova API we need to calculate the longest matching path to make it work.
                // $cordovaFile.moveFile('a/', 'b/c.ext', 'a/', 'b/d.ext') doesn't work.
                // cordovaFile.moveFile('a/b/', 'c.ext', 'a/b/', 'd.ext') works.
                var commonPath = basePath,
                    dirsA = originalPath.split('/'),
                    dirsB = newPath.split('/');

                for (var i = 0; i < dirsA.length; i++) {
                    var dir = dirsA[i];
                    if (dirsB[i] === dir) {
                        // Found a common folder, add it to common path and remove it from each specific path.
                        dir = dir + '/';
                        commonPath = self.concatenatePaths(commonPath, dir);
                        originalPath = originalPath.replace(dir, '');
                        newPath = newPath.replace(dir, '');
                    } else {
                        // Folder doesn't match, stop searching.
                        break;
                    }
                }

                return $cordovaFile.moveFile(commonPath, originalPath, commonPath, newPath);
            } else {
                return $cordovaFile.moveFile(basePath, originalPath, basePath, newPath);
            }
        });
    };

    /**
     * Copy a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#copyFile
     * @param {String} from   Path to the file to move.
     * @param {String} to     New path of the file.
     * @return {Promise}      Promise resolved when the entry is copied.
     */
    self.copyFile = function(from, to) {
        return self.init().then(function() {
            // Check if to contains a directory.
            var toFile = self.getFileAndDirectoryFromPath(to);
            if (toFile.directory == '') {
                return $cordovaFile.copyFile(basePath, from, basePath, to);
            } else {
                // Ensure directory is created.
                return self.createDir(toFile.directory).then(function() {
                    return $cordovaFile.copyFile(basePath, from, basePath, to);
                });
            }
        });
    };

    /**
     * Extract the file name and directory from a given path.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFileAndDirectoryFromPath
     * @param {String} path   Path to be extracted.
     * @return {Object}       Plain object containing the file name and directory.
     * @description
     * file.pdf         -> directory: '', name: 'file.pdf'
     * /file.pdf        -> directory: '', name: 'file.pdf'
     * path/file.pdf    -> directory: 'path', name: 'file.pdf'
     * path/            -> directory: 'path', name: ''
     * path             -> directory: '', name: 'path'
     */
    self.getFileAndDirectoryFromPath = function(path) {
        var file = {
            directory: '',
            name: ''
        };

        file.directory = path.substring(0, path.lastIndexOf('/') );
        file.name = path.substr(path.lastIndexOf('/') + 1);

        return file;
    };

    /**
     * Concatenate two paths, adding a slash between them if needed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#concatenatePaths
     * @param {String} leftPath  Left path.
     * @param {String} rightPath Right path.
     * @return {String}          Concatenated path.
     */
    self.concatenatePaths = function(leftPath, rightPath) {
        var lastCharLeft = leftPath.slice(-1),
            firstCharRight = rightPath.charAt(0);

        if (lastCharLeft === '/' && firstCharRight === '/') {
            return leftPath + rightPath.substr(1);
        } else if(lastCharLeft !== '/' && firstCharRight !== '/') {
            return leftPath + '/' + rightPath;
        } else {
            return leftPath + rightPath;
        }
    };

    /**
     * Get the internal URL of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getInternalURL
     * @param  {Object} fileEntry File Entry.
     * @return {String}           Internal URL.
     */
    self.getInternalURL = function(fileEntry) {
        if (isHTMLAPI) {
            // HTML API doesn't implement toInternalURL.
            return fileEntry.toURL();
        }
        return fileEntry.toInternalURL();
    };

    /**
     * Get a file icon URL based on its file name.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#getFileIcon
     * @param  {String} The name of the file.
     * @return {String} The path to a file icon.
     */
    self.getFileIcon = function(filename) {
        var ext = self.getFileExtension(filename),
            icon;

        if (ext && mimeTypes[ext] && mimeTypes[ext].icon) {
            icon = mimeTypes[ext].icon + '-64.png';
        } else {
            icon = 'unknown-64.png';
        }

        return 'img/files/' + icon;
    };

    /**
     * Get the folder icon URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#getFolderIcon
     * @return {String} The path to a folder icon.
     */
    self.getFolderIcon = function() {
        return 'img/files/folder-64.png';
    };

    /**
     * Returns the file extension of a file.
     *
     * When the file does not have an extension, it returns undefined.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#getFileExtension
     * @param  {string} filename The file name.
     * @return {string}          The lowercased extension, or undefined.
     */
    self.getFileExtension = function(filename) {
        var dot = filename.lastIndexOf("."),
            ext;

        if (dot > -1) {
            ext = filename.substr(dot + 1).toLowerCase();
        }

        return ext;
    };

    /**
     * Get the mimetype of an extension. Returns undefined if not found.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#allPromises
     * @param  {String} extension Extension.
     * @return {String}           Mimetype.
     */
    self.getMimeType = function(extension) {
        if (mimeTypes[extension] && mimeTypes[extension].type) {
            return mimeTypes[extension].type;
        }
    };

    /**
     * Remove the extension from a path (if any).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeExtension
     * @param  {String} path Path.
     * @return {String}      Path without extension.
     */
    self.removeExtension = function(path) {
        var index = path.lastIndexOf('.');
        if (index > -1) {
            return path.substr(0, index); // Remove extension.
        }
        return path;
    };

    /**
     * Adds the basePath to a path if it doesn't have it already.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#addBasePathIfNeeded
     * @param {String} path Path to treat.
     * @return {String}     Path with basePath added.
     */
    self.addBasePathIfNeeded = function(path) {
        if (path.indexOf(basePath) > -1) {
            return path;
        } else {
            return self.concatenatePaths(basePath, path);
        }
    };

    /**
     * Unzips a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#unzipFile
     * @param  {String} path         Path to the ZIP file.
     * @param  {String} [destFolder] Path to the destination folder. If not defined, a new folder will be created with the
     *                               same location and name as the ZIP file (without extension).
     * @return {Promise}             Promise resolved when the file is unzipped.
     */
    self.unzipFile = function(path, destFolder) {
        // We need to use ansolute paths (including basePath).
        path = self.addBasePathIfNeeded(path);
         // If destFolder is not set, use same location as ZIP file.
        destFolder = self.addBasePathIfNeeded(destFolder || self.removeExtension(path));
        return $cordovaZip.unzip(path, destFolder);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Service to handle groups.
 *
 * @module mm.core.groups
 * @ngdoc service
 * @name $mmGroups
 */
.factory('$mmGroups', ["$log", "$q", "$mmSite", "$mmSitesManager", function($log, $q, $mmSite, $mmSitesManager) {

    $log = $log.getInstance('$mmGroups');

    // Group mode constants.
    self.NOGROUPS       = 0;
    self.SEPARATEGROUPS = 1;
    self.VISIBLEGROUPS  = 2;

    /**
     * Get the groups allowed in an activity.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getActivityAllowedGroups
     * @param {Number} cmid     Course module ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise}        Promise resolved when the groups are retrieved.
     */
    self.getActivityAllowedGroups = function(cmid, userid) {
        userid = userid || $mmSite.getUserId();

        var params = {
                cmid: cmid,
                userid: userid
            },
            preSets = {
                cacheKey: getActivityAllowedGroupsCacheKey(cmid, userid)
            };

        return $mmSite.read('core_group_get_activity_allowed_groups', params, preSets).then(function(response) {
            if (!response || !response.groups) {
                return $q.reject();
            }
            return response.groups;
        });
    };

    /**
     * Get cache key for group mode WS calls.
     *
     * @param {Number} cmid Course module ID.
     * @return {String}     Cache key.
     */
    function getActivityAllowedGroupsCacheKey(cmid, userid) {
        return 'mmGroups:allowedgroups:' + cmid + ':' + userid;
    }

    /**
     * Get the group mode of an activity.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getActivityGroupMode
     * @param {Number} cmid Course module ID.
     * @return {Promise}    Promise resolved when the group mode is retrieved.
     */
    self.getActivityGroupMode = function(cmid) {
        var params = {
                cmid: cmid
            },
            preSets = {
                cacheKey: getActivityGroupModeCacheKey(cmid)
            };

        return $mmSite.read('core_group_get_activity_groupmode', params, preSets).then(function(response) {
            if (!response || typeof response.groupmode == 'undefined') {
                return $q.reject();
            }
            return response.groupmode;
        });
    };

    /**
     * Get cache key for group mode WS calls.
     *
     * @param {Number} cmid Course module ID.
     * @return {String}     Cache key.
     */
    function getActivityGroupModeCacheKey(cmid) {
        return 'mmGroups:groupmode:' + cmid;
    }

    /**
     * Get user groups in courses.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getUserGroups
     * @param {Object[]|Number[]} courses List of courses or course ids to get the groups from.
     * @param {Boolean} [refresh]         True when we should not get the value from the cache.
     * @param {String} [siteid]           Site to get the groups from. If not defined, use current site.
     * @param {Number} [userid]           ID of the user. If not defined, use the userid related to siteid.
     * @return {Promise}                  Promise to be resolved when the groups are retrieved.
     */
    self.getUserGroups = function(courses, refresh, siteid, userid) {
        var promises = [],
            groups = [],
            deferred = $q.defer();

        angular.forEach(courses, function(course) {
            var courseid;
            if (typeof course == 'object') { // Param is array of courses.
                courseid = course.id;
            } else { // Param is array of courseids.
                courseid = course;
            }
            var promise = self.getUserGroupsInCourse(courseid, refresh, siteid, userid).then(function(coursegroups) {
                groups = groups.concat(coursegroups);
            });
            promises.push(promise);
        });

        $q.all(promises).finally(function() {
            // Use finally because we don't want to block the load of events if a request fails.
            deferred.resolve(groups);
        });

        return deferred.promise;
    };

    /**
     * Get user groups in a course.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getUserGroupsInCourse
     * @param {Number} courseid   ID of the course.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @param {String} [siteid]   Site to get the groups from. If not defined, use current site.
     * @param {Number} [userid]   ID of the user. If not defined, use ID related to siteid.
     * @return {Promise}        Promise to be resolved when the groups are retrieved.
     */
    self.getUserGroupsInCourse = function(courseid, refresh, siteid, userid) {
        siteid = siteid || $mmSite.getId();

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var presets = {},
                data = {
                    userid: userid || site.getUserId(),
                    courseid: courseid
                };
            if (refresh) {
                presets.getFromCache = false;
            }
            return site.read('core_group_get_course_user_groups', data, presets).then(function(response) {
                if (response && response.groups) {
                    return response.groups;
                } else {
                    return $q.reject();
                }
            });
        });
    };

    /**
     * Invalidates activity allowed groups.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#invalidateActivityAllowedGroups
     * @param {Number} cmid     Course module ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateActivityAllowedGroups = function(cmid, userid) {
        userid = userid || $mmSite.getUserId();
        return $mmSite.invalidateWsCacheForKey(getActivityAllowedGroupsCacheKey(cmid, userid));
    };

    /**
     * Invalidates activity group mode.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#invalidateActivityGroupMode
     * @param {Number} cmid Course module ID.
     * @return {Promise}    Promise resolved when the data is invalidated.
     */
    self.invalidateActivityGroupMode = function(cmid) {
        return $mmSite.invalidateWsCacheForKey(getActivityGroupModeCacheKey(cmid));
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * The default priority for init processes.
 * @module mm.core
 * @ngdoc constant
 * @name mmInitDelegateDefaultPriority
 */
.constant('mmInitDelegateDefaultPriority', 100)

/**
 * The maximum priority that an addon can use for init process, anything over that is reserved for core use.
 * @module mm.core
 * @ngdoc constant
 * @name mmInitDelegateMaxAddonPriority
 */
.constant('mmInitDelegateMaxAddonPriority', 599)

/**
 * Provider for initialisation mechanisms.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmInitDelegate
 */
.provider('$mmInitDelegate', ["mmInitDelegateDefaultPriority", function(mmInitDelegateDefaultPriority) {
    var initProcesses = {},
        self = {};

    /**
     * Registers an initialisation process.
     *
     * @description
     * Init processes can be used to add initialisation logic to the app. Anything that should
     * block the user interface while some processes are done should be an init process. When defining
     * an init process make sure you do not set a priority higher than mmInitDelegateMaxAddonPriority
     * in your addons. This is to make sure that your process does not happen before some essential
     * other core processes such as the upgrade, and restoring the user session.
     *
     * An init process should never change state or prompt user interaction.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmInitDelegateProvider#registerProcess
     * @param {String} name The name of the process.
     * @param {String|Function} callable The callable of the process. See {@link $mmUtil.resolveObject}.
     *                                   The resolved function will get $injector as first argument.
     * @param {Number} [priority=100] The priority of the process, the highest priority is executed first.
     * @param {Boolean} [blocking=false] Set this to true when this process should be resolved before any following one.
     * @return {Void}
     */
    self.registerProcess = function(name, callable, priority, blocking) {
        priority = typeof priority === 'undefined' ? mmInitDelegateDefaultPriority : priority;

        if (typeof initProcesses[name] !== 'undefined') {
            console.log('$mmInitDelegateProvider: Process \'' + name + '\' already defined.');
            return;
        }

        console.log('$mmInitDelegateProvider: Registered process \'' + name + '\'.');
        initProcesses[name] = {
            blocking: blocking,
            callable: callable,
            name: name,
            priority: priority
        };
    };

    self.$get = ["$q", "$log", "$injector", "$mmUtil", function($q, $log, $injector, $mmUtil) {

        $log = $log.getInstance('$mmInitDelegate');

        var self = {},
            readiness;

        /**
         * Convenience function to return a function that executes the process.
         *
         * @param  {Object} data The data of the process.
         * @return {Function}
         */
        function prepareProcess(data) {
            return function() {
                var promise,
                    fn;

                $log.debug('Executing init process \'' + data.name + '\'');

                try {
                    fn = $mmUtil.resolveObject(data.callable);
                } catch (e) {
                    $log.error('Could not resolve object of init process \'' + data.name + '\'. ' + e);
                    return;
                }

                try {
                    promise = fn($injector);
                } catch (e) {
                    $log.error('Error while calling the init process \'' + data.name + '\'. ' + e);
                    return;
                }

                return promise;
            };
        }

        /**
         * Executes the registered init processes.
         *
         * Reserved for core use, do not call directly.
         *
         * @module mm.core
         * @ngdoc service
         * @name $mmInitDelegate#executeInitProcesses
         * @protected
         * @return {Void}
         */
        self.executeInitProcesses = function() {
            var ordered = [],
                promises = [],
                dependency = $q.when();

            if (typeof readiness === 'undefined') {
                readiness = $q.defer();
            }

            // Re-ordering by priority.
            angular.forEach(initProcesses, function(data) {
                ordered.push(data);
            });
            ordered.sort(function(a, b) {
                return b.priority - a.priority;
            });

            // Execute all the processes.
            angular.forEach(ordered, function(data) {
                var promise;

                // Add the process to the dependency stack.
                promise = dependency.finally(prepareProcess(data));
                promises.push(promise);

                // If the new process is blocking, we set it as the dependency.
                if (data.blocking) {
                    dependency = promise;
                }
            });

            $q.all(promises).finally(readiness.resolve);
        };

        /**
         * Notifies when the app is ready.
         *
         * This returns a promise that is resolved when the app is initialised.
         *
         * Reserved for core use, do not call directly, use {@link $mmApp.ready} instead.
         *
         * @module mm.core
         * @ngdoc service
         * @name $mmInitDelegate#ready
         * @protected
         * @return {Promise} Resolved when the app is initialised. Never rejected.
         */
        self.ready = function() {
            if (typeof readiness === 'undefined') {
                // Prevent race conditions if this is called before executeInitProcesses.
                readiness = $q.defer();
            }

            return readiness.promise;
        };

        return self;
    }];

    return self;
}]);

/**
 * ionRadioFix - fixes a bug in iOS 9 UIWebView that breaks the tilde selector in CSS. To
 * use this fix, include it after your Ionic bundle JS.
 *
 * Note: due to Angular directive override limitations, you'll need to change any reference
 * to <ion-radio> to <ion-radio-fix> to apply this patched radio button.
 *
 * Also, make sure to add the new CSS from the second part of this gist.
 */
angular.module('ionic').directive('ionRadioFix', function() {
  return {
    restrict: 'E',
    replace: true,
    require: '?ngModel',
    transclude: true,
    template:
      '<label class="item item-radio">' +
        '<input type="radio" name="radio-group">' +
        '<div class="radio-content">' +
          '<div class="item-content disable-pointer-events" ng-transclude></div>' +
          '<i class="radio-icon disable-pointer-events icon ion-checkmark"></i>' +
        '</div>' +
      '</label>',

    compile: function(element, attr) {
      if (attr.icon) {
        var iconElm = element.find('i');
        iconElm.removeClass('ion-checkmark').addClass(attr.icon);
      }

      var input = element.find('input');
      angular.forEach({
          'name': attr.name,
          'value': attr.value,
          'disabled': attr.disabled,
          'ng-value': attr.ngValue,
          'ng-model': attr.ngModel,
          'ng-disabled': attr.ngDisabled,
          'ng-change': attr.ngChange,
          'ng-required': attr.ngRequired,
          'required': attr.required
      }, function(value, name) {
        if (angular.isDefined(value)) {
            input.attr(name, value);
          }
      });

      return function(scope, element, attr) {
        scope.getValue = function() {
          return scope.ngValue || attr.value;
        };
      };
    }
  };
});
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmLang
 * @module mm.core
 * @description
 * This service allows to add new languages strings.
 */
.factory('$mmLang', ["$translate", "$translatePartialLoader", "$mmConfig", "$cordovaGlobalization", "$q", "mmCoreConfigConstants", function($translate, $translatePartialLoader, $mmConfig, $cordovaGlobalization, $q, mmCoreConfigConstants) {

    var self = {},
        currentLanguage; // Save current language in a variable to speed up the get function.

    /**
     * Register a folder to search language files into it.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#registerLanguageFolder
     * @param  {String} path Path of the folder to use.
     * @return {Promise}     Promise resolved when file is loaded.
     */
    self.registerLanguageFolder = function(path) {
        $translatePartialLoader.addPart(path);
        return $translate.refresh();
    };

    /**
     * Get current language.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#getCurrentLanguage
     * @return {[type]} [description]
     */
    self.getCurrentLanguage = function() {

        if (typeof currentLanguage != 'undefined') {
            return $q.when(currentLanguage);
        }

        // Get current language from config (user might have changed it).
        return $mmConfig.get('current_language').then(function(language) {
            return language;
        }, function() {
            try {
                // User hasn't defined a language. Get it from cordova globalization.
                return $cordovaGlobalization.getPreferredLanguage().then(function(result) {
                    var language = result.value.toLowerCase();
                    if (language.indexOf('-') > -1) {
                        // Language code defined by locale has a dash, like en-US or es-ES. Check if it's supported.
                        if (mmCoreConfigConstants.languages && typeof mmCoreConfigConstants.languages[language] == 'undefined') {
                            // Code is NOT supported. Fallback to language without dash. E.g. 'en-US' would fallback to 'en'.
                            language = language.substr(0, language.indexOf('-'));

                        }
                    }
                    return language;
                }, function() {
                    // Error getting locale. Use default language.
                    return mmCoreConfigConstants.default_lang || 'en';
                });
            } catch(err) {
                // Error getting locale. Use default language.
                return mmCoreConfigConstants.default_lang || 'en';
            }
        }).then(function(language) {
            currentLanguage = language; // Save it for later.
            return language;
        });
    };

    /**
     * Change current language.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#changeCurrentLanguage
     * @param {String} language New language to use.
     * @return {Promise}        Promise resolved when the change is finished.
     */
    self.changeCurrentLanguage = function(language) {
        var p1 = $translate.use(language),
            p2 = $mmConfig.set('current_language', language);
        moment.locale(language);
        currentLanguage = language;
        return $q.all([p1, p2]);
    };

    /**
     * Translates an error message and returns a rejected promise with the translated message.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#translateAndReject
     * @param  {String} errorkey Key of the message to show.
     * @return {Promise}         Rejected promise.
     */
    self.translateAndReject = function(errorkey) {
        return $translate(errorkey).then(function(errorMessage) {
            return $q.reject(errorMessage);
        }, function() {
            return $q.reject(errorkey);
        });
    };

    /**
     * Translates an error message and rejects a deferred with the translated message.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#translateAndRejectDeferred
     * @param  {Object} deferred Deferred object to reject.
     * @param  {String} errorkey Key of the message to show.
     */
    self.translateAndRejectDeferred = function(deferred, errorkey) {
        $translate(errorkey).then(function(errorMessage) {
            deferred.reject(errorMessage);
        }, function() {
            deferred.reject(errorkey);
        });
    };

    return self;
}])

.config(["$translateProvider", "$translatePartialLoaderProvider", function($translateProvider, $translatePartialLoaderProvider) {

    $translateProvider.useLoader('$translatePartialLoader', {
        urlTemplate: '{part}/{lang}.json'
    });

    // Load the built language files from build/lang.
    $translatePartialLoaderProvider.addPart('build/lang');

    // Set fallback language.
    $translateProvider.fallbackLanguage('en');
    $translateProvider.preferredLanguage('en'); // Set English until we know which language to use.
}])

.run(["$ionicPlatform", "$translate", "$mmLang", function($ionicPlatform, $translate, $mmLang) {
    $ionicPlatform.ready(function() {
        $mmLang.getCurrentLanguage().then(function(language) {
            $translate.use(language);
            moment.locale(language);
        });
    });
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

// Stores used to create unique IDs for notifications.
.constant('mmCoreNotificationsSitesStore', 'notification_sites')
.constant('mmCoreNotificationsComponentsStore', 'notification_components')
.constant('mmCoreNotificationsTriggeredStore', 'notifications_triggered')

.config(["$mmAppProvider", "mmCoreNotificationsSitesStore", "mmCoreNotificationsComponentsStore", "mmCoreNotificationsTriggeredStore", function($mmAppProvider, mmCoreNotificationsSitesStore, mmCoreNotificationsComponentsStore,
        mmCoreNotificationsTriggeredStore) {
    var stores = [
        {
            name: mmCoreNotificationsSitesStore, // Store to asigne unique codes to each site.
            keyPath: 'id',
            indexes: [
                {
                    name: 'code',
                }
            ]
        },
        {
            name: mmCoreNotificationsComponentsStore, // Store to asigne unique codes to each component.
            keyPath: 'id',
            indexes: [
                {
                    name: 'code',
                }
            ]
        },
        {
            name: mmCoreNotificationsTriggeredStore, // Store to prevent re-triggering notifications.
            keyPath: 'id',
            indexes: []
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

/**
 * Factory to handle local notifications.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmLocalNotifications
 * @description
 * Provides methods to trigger notifications, listen clicks on them, etc.
 */
.factory('$mmLocalNotifications', ["$log", "$cordovaLocalNotification", "$mmApp", "$q", "mmCoreNotificationsSitesStore", "mmCoreNotificationsComponentsStore", "mmCoreNotificationsTriggeredStore", function($log, $cordovaLocalNotification, $mmApp, $q,
        mmCoreNotificationsSitesStore, mmCoreNotificationsComponentsStore, mmCoreNotificationsTriggeredStore) {

    $log = $log.getInstance('$mmLocalNotifications');

    var self = {},
        observers = {},
        codes = {}; // Store codes in memory to make getCode function faster.

    // We need a queue to request unique codes, to handle simultaneous requests.
    var codeRequestsQueue = {};

    /**
     * Get a code to create unique notifications. If there's no code assigned, create a new one.
     *
     * @param  {String} store Store to search in local DB.
     * @param  {String} id    ID of the element to get its code.
     * @return {Promise}      Promise resolved when the code is retrieved.
     */
    function getCode(store, id) {
        var db = $mmApp.getDB(),
            key = store + '#' + id;

        if (typeof codes[key] != 'undefined') {
            return $q.when(codes[key]);
        }

        return db.get(store, id).then(function(entry) {
            var code = parseInt(entry.code);
            codes[key] = code;
            return code;
        }, function() {
            // Site is not in the DB. Create a new ID for it.
            return db.query(store, undefined, 'code', true).then(function(entries) {
                var newCode = 0;
                if (entries.length > 0) {
                    newCode = parseInt(entries[0].code) + 1;
                }
                return db.insert(store, {id: id, code: newCode}).then(function() {
                    codes[key] = newCode;
                    return newCode;
                });
            });
        });
    }

    /**
     * Get a site code to be used.
     * If it's the first time this site is used to send notifications, create a new code for it.
     *
     * @param  {String} siteid   Site ID.
     * @return {Promise}         Promise resolved when the site code is retrieved.
     */
    function getSiteCode(siteid) {
        return requestCode(mmCoreNotificationsSitesStore, siteid);
    }

    /**
     * Get a notification component code to be used.
     * If it's the first time this component is used to send notifications, create a new code for it.
     *
     * @param {String} component Component name.
     * @return {Promise}         Promise resolved when the component code is retrieved.
     */
    function getComponentCode(component) {
        return requestCode(mmCoreNotificationsComponentsStore, component);
    }

    /**
     * Create a unique notification ID, trying to prevent collisions. Generated ID must be a Number (Android).
     * The generated ID shouldn't be higher than 2147483647 or it's going to cause problems in Android.
     * This function will prevent collisions and keep the number under Android limit if:
     *     -User has used less than 21 sites.
     *     -There are less than 11 components.
     *     -The notificationid passed as parameter is lower than 10000000.
     *
     * @param  {Number} notificationid Notification ID.
     * @param {String} component       Component triggering the notification.
     * @param  {String} siteid         Site ID.
     * @return {Promise}               Promise resolved when the notification ID is generated.
     */
    function getUniqueNotificationId(notificationid, component, siteid) {
        if (!siteid || !component) {
            return $q.reject();
        }

        return getSiteCode(siteid).then(function(sitecode) {
            return getComponentCode(component).then(function(componentcode) {
                // We use the % operation to keep the number under Android's limit.
                return (sitecode * 100000000 + componentcode * 10000000 + parseInt(notificationid)) % 2147483647;
            });
        });
    }

    /**
     * Process the next request in queue.
     */
    function processNextRequest() {
        var nextKey = Object.keys(codeRequestsQueue)[0],
            request,
            promise;

        if (typeof nextKey == 'undefined') {
            // No more requests in queue, stop.
            return;
        }

        request = codeRequestsQueue[nextKey];
        // Check if request is valid.
        if (angular.isObject(request) && typeof request.store != 'undefined' && typeof request.id != 'undefined') {
            // Get the code and resolve/reject all the promises of this request.
            promise = getCode(request.store, request.id).then(function(code) {
                angular.forEach(request.promises, function(p) {
                    p.resolve(code);
                });
            }, function(error) {
                angular.forEach(request.promises, function(p) {
                    p.reject(error);
                });
            });
        } else {
            promise = $q.when();
        }

        // Once this item is treated, remove it and process next.
        promise.finally(function() {
            delete codeRequestsQueue[nextKey];
            processNextRequest();
        });
    }

    /**
     * Request a unique code. The request will be added to the queue and the queue is going to be started if it's paused.
     *
     * @param  {String} store Store to search in local DB.
     * @param  {String} id    ID of the element to get its code.
     * @return {Promise}      Promise resolved when the code is retrieved.
     */
    function requestCode(store, id) {
        var deferred = $q.defer(),
            key = store+'#'+id,
            isQueueEmpty = Object.keys(codeRequestsQueue).length == 0;

        if (typeof codeRequestsQueue[key] != 'undefined') {
            // There's already a pending request for this store and ID, add the promise to it.
            codeRequestsQueue[key].promises.push(deferred);
        } else {
            // Add a pending request to the queue.
            codeRequestsQueue[key] = {
                store: store,
                id: id,
                promises: [deferred]
            };
        }

        if (isQueueEmpty) {
            processNextRequest();
        }

        return deferred.promise;
    }

    /**
     * Cancel a local notification.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#cancel
     * @param {Number} id        Notification id.
     * @param {String} component Component of the notification.
     * @param {String} siteid    Site ID.
     * @return {Promise}         Promise resolved when the notification is cancelled.
     */
    self.cancel = function(id, component, siteid) {
        return getUniqueNotificationId(id, component, siteid).then(function(uniqueId) {
            return $cordovaLocalNotification.cancel(uniqueId);
        });
    };

    /**
     * Cancel all the scheduled notifications belonging to a certain site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#cancelSiteNotifications
     * @param {String} siteid Site ID.
     * @return {Promise} Promise resolved when the notifications are cancelled.
     */
    self.cancelSiteNotifications = function(siteid) {

        if (!self.isAvailable()) {
            return $q.when();
        } else if (!siteid) {
            return $q.reject();
        }

        return $cordovaLocalNotification.getAllScheduled().then(function(scheduled) {
            var ids = [];

            angular.forEach(scheduled, function(notif) {
                if (typeof notif.data == 'string') {
                    notif.data = JSON.parse(notif.data);
                }

                if (typeof notif.data == 'object' && notif.data.siteid === siteid) {
                    ids.push(notif.id);
                }
            });

            return $cordovaLocalNotification.cancel(ids);
        });
    };

    /**
     * Returns whether local notifications plugin is installed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#isAvailable
     * @return {Boolean} True when local notifications plugin is installed.
     */
    self.isAvailable = function() {
        return window.plugin && window.plugin.notification && window.plugin.notification.local ? true: false;
    };

    /**
     * Check if a notification has been triggered with the same trigger time.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#isTriggered
     * @param  {Object}  notification Notification to check. Needs to have 'id' and 'at' properties.
     * @return {Promise}              Promise resolved with a boolean indicating if promise is triggered (true) or not.
     */
    self.isTriggered = function(notification) {
        return $mmApp.getDB().get(mmCoreNotificationsTriggeredStore, notification.id).then(function(stored) {
            var notifTime = notification.at.getTime() / 1000;
            return stored.at === notifTime;
        }, function() {
            return false;
        });
    };

    /**
     * Notify notification click to observer. Only the observer with the same component as the notification will be notified.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#notifyClick
     * @param {Object} data Data received by the notification.
     */
    self.notifyClick = function(data) {
        var component = data.component;
        if (component) {
            var callback = observers[component];
            if (typeof callback == 'function') {
                callback(data);
            }
        }
    };

    /**
     * Register an observer to be notified when a notification belonging to a certain component is clicked.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#registerClick
     * @param {String} component  Component to listen notifications for.
     * @param {Function} callback Function to call with the data received by the notification.
     */
    self.registerClick = function(component, callback) {
        $log.debug("Register observer '"+component+"' for notification click.");
        observers[component] = callback;
    };

    /**
     * Remove a notification from triggered store.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#removeTriggered
     * @param {String} id Notification ID.
     * @return {Promise}  Promise resolved when it is removed.
     */
    self.removeTriggered = function(id) {
        return $mmApp.getDB().remove(mmCoreNotificationsTriggeredStore, id);
    };

    /**
     * Schedule a local notification.
     * @see https://github.com/katzer/cordova-plugin-local-notifications/wiki/04.-Scheduling
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#schedule
     * @param {Object} notification Notification to schedule. Its ID should be lower than 10000000 and it should be unique inside
     *                              its component and site. If the ID is higher than that number there might be collisions.
     * @param {String} component    Component triggering the notification. It is used to generate unique IDs.
     * @param {String} siteid       Site ID.
     * @return {Promise}            Promise resolved when the notification is scheduled.
     */
    self.schedule = function(notification, component, siteid) {
        return getUniqueNotificationId(notification.id, component, siteid).then(function(uniqueId) {
            notification.id = uniqueId;
            notification.data = notification.data || {};
            notification.data.component = component;
            notification.data.siteid = siteid;

            return self.isTriggered(notification).then(function(triggered) {
                if (!triggered) {
                    // Remove from triggered, since the notification could be in there with a different time.
                    self.removeTriggered(notification.id);
                    return $cordovaLocalNotification.schedule(notification);
                }
            });
        });
    };

    /**
     * Function to call when a notification is triggered. Stores the notification so it's not scheduled again unless the
     * time is changed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#trigger
     * @param {Object} notification Triggered notification.
     * @return {Promise}            Promise resolved when stored, rejected otherwise.
     */
    self.trigger = function(notification) {
        var id = parseInt(notification.id);
        if (!isNaN(id)) {
            return $mmApp.getDB().insert(mmCoreNotificationsTriggeredStore, {
                id: id,
                at: parseInt(notification.at)
            });
        } else {
            return $q.reject();
        }
    };

    return self;
}])

.run(["$rootScope", "$log", "$mmLocalNotifications", "$mmEvents", "mmCoreEventSiteDeleted", function($rootScope, $log, $mmLocalNotifications, $mmEvents, mmCoreEventSiteDeleted) {
    $log = $log.getInstance('$mmLocalNotifications');

    $rootScope.$on('$cordovaLocalNotification:trigger', function(e, notification, state) {
        $mmLocalNotifications.trigger(notification);
    });

    $rootScope.$on('$cordovaLocalNotification:click', function(e, notification, state) {
        if (notification && notification.data) {
            $log.debug('Notification clicked: '+notification.data);
            var data = JSON.parse(notification.data);
            $mmLocalNotifications.notifyClick(data);
        }
    });

    $mmEvents.on(mmCoreEventSiteDeleted, function(site) {
        if (site) {
            $mmLocalNotifications.cancelSiteNotifications(site.id);
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreLogEnabledDefault', true) // Default value for logEnabled.
.constant('mmCoreLogEnabledConfigName', 'debug_enabled')

/**
 * Provider to decorate angular's $log service.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmLog
 * @description
 * $mmLogProvider.logDecorator function is designed to decorate '$log'. It should be used like this:
 *     $provide.decorator('$log', ['$delegate', $mmLogProvider.logDecorator]);
 *
 * Decorated $log usage:
 *     $log = $log.getInstance('MyFactory')
 *     $log.debug('My message') -> "dd/mm/aaaa hh:mm:ss MyFactory: My message"
 *
 * To permanently enable/disable logging messages, use:
 *     $mmLog.enabled(true/false)
 */
.provider('$mmLog', ["mmCoreLogEnabledDefault", function(mmCoreLogEnabledDefault) {

    var isEnabled = mmCoreLogEnabledDefault,
        self = this;

    // Function to pre-capture a logger function.
    function prepareLogFn(logFn, className) {
        className = className || '';
        // Invoke the specified 'logFn' with our new code.
        var enhancedLogFn = function() {
            if (isEnabled) {
                var args = Array.prototype.slice.call(arguments),
                    now  = moment().format('l LTS');

                args[0] = now + ' ' + className + ': ' + args[0]; // Prepend timestamp and className to the original message.
                logFn.apply(null, args);
            }
        };

        // Special, only needed to support angular-mocks expectations.
        enhancedLogFn.logs = [];

        return enhancedLogFn;
    }

    /**
     * Enhances $log service, adding date and component to the logged message, and allowing disable log.
     *
     * @param  {Service} $log Angular's $log service to decorate.
     * @return {Service}      Decorated $log.
     */
    self.logDecorator = function($log) {
        // Copy the original methods.
        var _$log = (function($log) {
            return {
                log   : $log.log,
                info  : $log.info,
                warn  : $log.warn,
                debug : $log.debug,
                error : $log.error
            };
        })($log);

        // Create the getInstance method so services/controllers can configure the className to be shown.
        var getInstance = function(className) {
            return {
                log   : prepareLogFn(_$log.log, className),
                info  : prepareLogFn(_$log.info, className),
                warn  : prepareLogFn(_$log.warn, className),
                debug : prepareLogFn(_$log.debug, className),
                error : prepareLogFn(_$log.error, className)
            };
        };

        // Decorate original $log functions too. This way if a service/controller uses $log without $log.getInstance,
        // it's going to prepend the date and 'Core'.
        $log.log   = prepareLogFn($log.log);
        $log.info  = prepareLogFn($log.info);
        $log.warn  = prepareLogFn($log.warn);
        $log.debug = prepareLogFn($log.debug);
        $log.error = prepareLogFn($log.error);
        $log.getInstance = getInstance;

        return $log;
    };

    this.$get = ["$mmConfig", "mmCoreLogEnabledDefault", "mmCoreLogEnabledConfigName", function($mmConfig, mmCoreLogEnabledDefault, mmCoreLogEnabledConfigName) {
        var self = {};

        /**
         * Initialize logging, enabling/disabling it based on settings and mmCoreLogEnabledDefault.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmLog#init
         */
        self.init = function() {
            $mmConfig.get(mmCoreLogEnabledConfigName).then(function(enabled) {
                isEnabled = enabled;
            }, function() {
                // Not set, use default value.
                isEnabled = mmCoreLogEnabledDefault;
            });
        }

        /**
         * Enable/disable logging in the app.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmLog#enabled
         * @param {Boolean} flag True if log should be enabled, false otherwise.
         */
        self.enabled = function(flag) {
            $mmConfig.set(mmCoreLogEnabledConfigName, flag);
            isEnabled = flag;
        };

        /**
         * Check if app logging is enabled.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmLog#isEnabled
         * @return {Boolean} True if log is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return isEnabled;
        };

        return self;
    }];
}])

.run(["$mmLog", function($mmLog) {
    $mmLog.init();
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Service to provide functionalities related to current site.
 *
 * @module mm.core
 * @ngdoc factory
 * @name $mmSite
 * @description
 * This services provides a set of functionalities related to current site. The current site instance is stored in $mmSitesManager.
 * This service can be seen as an instance of Site defined in $mmSitesFactory, with one method added: $mmSite.isLoggedIn.
 */
.factory('$mmSite', ["$mmSitesManager", "$mmSitesFactory", function($mmSitesManager, $mmSitesFactory) {

    var self = {},
        siteMethods = $mmSitesFactory.getSiteMethods();

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getId
     * @return {String} Current site ID.
     * @description
     *
     * Get current site ID.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getURL
     * @return {String} Current site URL.
     * @description
     *
     * Get current site URL.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getToken
     * @return {String} Current site token.
     * @description
     *
     * Get current site token.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getInfo
     * @return {Object} Current site info.
     * @description
     *
     * Get current site info.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getDb
     * @return {Object} Current site DB.
     * @description
     *
     * Get current site DB.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getUserId
     * @return {Object} User's ID.
     * @description
     *
     * Get current site user's ID.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#setId
     * @param {String} New ID.
     * @description
     *
     * Set current site ID.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#setToken
     * @param {String} New token.
     * @description
     *
     * Set current site token.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canAccessMyFiles
     * @return {Boolean} False when they cannot.
     * #description
     *
     * Check if user can access private files in current site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canDownloadFiles
     * @return {Boolean} False when they cannot.
     * #description
     *
     * Check if user can download files in current site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canUseAdvancedFeature
     * @param {String} feature The name of the feature.
     * @param {Boolean} [whenUndefined=true] The value to return when the parameter is undefined
     * @return {Boolean} False when they cannot.
     * @description
     *
     * Can the user use an advanced feature?
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canUploadFiles
     * @return {Boolean} False when they cannot.
     * #description
     *
     * Check if user can upload files in current site.
     */

    /**
     * Fetch site info from the Moodle site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#fetchSiteInfo
     * @return {Promise} A promise to be resolved when the site info is retrieved.
     * #description
     *
     * Fetch site info from the current Moodle site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#read
     * @param  {String} read  WS method to use.
     * @param  {Object} data    Data to send to the WS.
     * @param  {Object} preSets Options. @see $mmSite#request.
     * @return {Promise}        Promise to be resolved when the request is finished.
     * #description
     *
     * Read some data from the current Moodle site using WS. Requests are cached by default.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#write
     * @param  {String} method  WS method to use.
     * @param  {Object} data    Data to send to the WS.
     * @param  {Object} preSets Options. @see $mmSite#request.
     * @return {Promise}        Promise to be resolved when the request is finished.
     * #description
     *
     * Sends some data to the current Moodle site using WS. Requests are NOT cached by default.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#request
     * @param {string} method The WebService method to be called.
     * @param {Object} data Arguments to pass to the method.
     * @param {Object} preSets Extra settings.
     *                    - getFromCache boolean (false) Use the cache when possible.
     *                    - saveToCache boolean (false) Save the call results to the cache.
     *                    - omitExpires boolean (false) Ignore cache expiry.
     *                    - sync boolean (false) Add call to queue if device is not connected.
     *                    - cacheKey (string) Extra key to add to the cache when storing this call. This key is to
     *                                        flag the cache entry, it doesn't affect the data retrieved in this call.
     *                    - getCacheUsingCacheKey (boolean) True if it should retrieve cached data by cacheKey,
     *                                        false if it should get the data based on the params passed (usual behavior).
     * @return {Promise}
     * @description
     *
     * Sends a webservice request to the site. This method will automatically add the
     * required parameters and pass it on to the low level API in $mmWS.call().
     *
     * Caching is also implemented, when enabled this method will returned a cached
     * version of itself rather than contacting the server.
     *
     * This method is smart which means that it will try to map the method to a
     * compatibility one if need be, usually that means that it will fallback on
     * the 'local_mobile_' prefixed function if it is available and the non-prefixed is not.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#wsAvailable
     * @param  {String}       method      WS name.
     * @param  {Boolean=true} checkPrefix When true also checks with the compatibility prefix.
     * @return {Boolean}                  True if the WS is available, false otherwise.
     * @description
     * Check if a WS is available in the current site.
     *
     * This method checks if a web service function is available. By default it will
     * also check if there is a compatibility function for it, e.g. a prefixed one.
     */

    /*
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#uploadFile
     * @param {Object} uri File URI.
     * @param {Object} options File settings: fileKey, fileName and mimeType.
     * @return {Promise}
     * @description
     *
     * Uploads a file to the current site using Cordova File API.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#invalidateWsCacheForKey
     * @param  {String} key Key to search.
     * @return {Promise}    Promise resolved when the cache entries are invalidated.
     * @description
     *
     * Invalidates all the cache entries with a certain key.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#invalidateWsCacheForKeyStartingWith
     * @param  {String} key Key to search.
     * @return {Promise}    Promise resolved when the cache entries are invalidated.
     * @description
     *
     * Invalidates all the cache entries whose key starts with a certain value.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#fixPluginfileURL
     * @param {String} url   The url to be fixed.
     * @return {String}      Fixed URL.
     * @description
     *
     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
     * Uses $mmUtil.fixPluginfileURL, passing current site's token.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#deleteDB
     * @return {Promise} Promise to be resolved when the DB is deleted.
     * @description
     *
     * Deletes current site's DB.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#deleteFolder
     * @return {Promise} Promise to be resolved when the folder is deleted.
     * @description
     *
     * Deletes current site's folder.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getSpaceUsage
     * @return {Promise} Promise resolved with the site space usage (size).
     * @description
     *
     * Get space usage of the site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getDocsUrl
     * @param {String} [page]    Docs page to go to.
     * @return {Promise}         Promise resolved with the Moodle docs URL.
     * @description
     *
     * Returns the URL to the documentation of the app, based on Moodle version and current language.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#checkLocalMobilePlugin
     * @return {Promise} Promise resolved when the check is done. Resolve params:
     *                           - {Number} code Code to identify the authentication method to use.
     *                           - {String} [service] If defined, name of the service to use.
     *                           - {String} [warning] If defined, code of the warning message.
     * @description
     *
     * Check if the local_mobile plugin is installed in the Moodle site.
     * This plugin provide extended services.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#checkLocalMobilePlugin
     * @return {Promise} Promise resolved it local_mobile was added, rejected otherwise.
     * @description
     *
     * Check if local_mobile has been installed in Moodle but the app is not using it.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#containsUrl
     * @param  {String}  url URL to check.
     * @return {Boolean}     True if URL belongs to this site, false otherwise.
     * @description
     *
     * Check if a URL belongs to this site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getCompatibleFunction
     * @param  {String} method WS function to check.
     * @return {String}        Method to use based in the available functions.
     * @description
     *
     * Return the function to be used, based on the available functions in the site. It'll try to use non-deprecated
     * functions first, and fallback to deprecated ones if needed.
     */

    // Replicate all Site methods refined in $mmSitesFactory to be used with current site.
    angular.forEach(siteMethods, function(method) {
        self[method] = function() {
            var currentSite = $mmSitesManager.getCurrentSite();
            if (typeof currentSite == 'undefined') {
                return undefined;
            } else {
                return currentSite[method].apply(currentSite, arguments);
            }
        };
    });

    /**
     * Check if the user is logged in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#isLoggedIn
     * @return {Boolean} True if the user is logged in a site, false otherwise.
     */
    self.isLoggedIn = function() {
        var currentSite = $mmSitesManager.getCurrentSite();
        return typeof currentSite != 'undefined' && typeof currentSite.token != 'undefined' && currentSite.token != '';
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.value('mmCoreWSPrefix', 'local_mobile_')

.constant('mmCoreWSCacheStore', 'wscache')

.config(["$mmSitesFactoryProvider", "mmCoreWSCacheStore", function($mmSitesFactoryProvider, mmCoreWSCacheStore) {
    var stores = [
        {
            name: mmCoreWSCacheStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'key'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Provider to create sites instances.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmSitesFactory
 * @description
 * This provider is the interface with the DB database. The modules that need to store
 * information here need to register their stores.
 *
 * Example:
 *
 * .config(function($mmSitesFactoryProvider) {
 *      $mmSitesFactoryProvider.registerStore({
 *          name: 'courses',
 *          keyPath: 'id'
 *      });
 *  })
 *
 * The service $mmSitesFactory is used to create site instances. It's not intended to be used directly, its usage is
 * restricted to core. Developers should only use $mmSitesFactoryProvider, $mmSitesManager and $mmSite.
 */
.provider('$mmSitesFactory', function() {

    /** Define the site storage schema. */
    var siteSchema = {
            stores: []
        },
        dboptions = {
            autoSchema: true
        };

    /**
     * Register a store schema.
     * IMPORTANT: Modifying the schema of an already existing store deletes all its data in WebSQL Storage.
     * If a store schema needs to be modified, the data should be manually migrated to the new store.
     *
     * @param  {Object} store The store object definition.
     * @return {Void}
     */
    this.registerStore = function(store) {
        if (typeof(store.name) === 'undefined') {
            console.log('$mmSite: Error: store name is undefined.');
            return;
        } else if (storeExists(store.name)) {
            console.log('$mmSite: Error: store ' + store.name + ' is already defined.');
            return;
        }
        siteSchema.stores.push(store);
    };

    /**
     * Register multiple stores at once.
     * IMPORTANT: Modifying the schema of an already existing store deletes all its data in WebSQL Storage.
     * If a store schema needs to be modified, the data should be manually migrated to the new store.
     *
     * @param  {Array} stores Array of store objects.
     * @return {Void}
     */
    this.registerStores = function(stores) {
        var self = this;
        angular.forEach(stores, function(store) {
            self.registerStore(store);
        });
    };

    /**
     * Check if a store is already defined.
     *
     * @param  {String} name The name of the store.
     * @return {Boolean} True when the store was already defined.
     */
    function storeExists(name) {
        var exists = false;
        angular.forEach(siteSchema.stores, function(store) {
            if (store.name === name) {
                exists = true;
            }
        });
        return exists;
    }

    this.$get = ["$http", "$q", "$mmWS", "$mmDB", "$log", "md5", "$mmApp", "$mmLang", "$mmUtil", "$mmFS", "mmCoreWSCacheStore", "mmCoreWSPrefix", "mmCoreSessionExpired", "$mmEvents", "mmCoreEventSessionExpired", "mmCoreUserDeleted", "mmCoreEventUserDeleted", "$mmText", "mmCoreConfigConstants", function($http, $q, $mmWS, $mmDB, $log, md5, $mmApp, $mmLang, $mmUtil, $mmFS, mmCoreWSCacheStore,
            mmCoreWSPrefix, mmCoreSessionExpired, $mmEvents, mmCoreEventSessionExpired, mmCoreUserDeleted, mmCoreEventUserDeleted,
            $mmText, mmCoreConfigConstants) {

        $log = $log.getInstance('$mmSite');

        /**
         * List of deprecated WS functions with their corresponding NOT deprecated name.
         *
         * When the function does not have an equivalent set its value to true.
         *
         * @type {Object}
         */
        var deprecatedFunctions = {
            "core_grade_get_definitions": "core_grading_get_definitions",
            "moodle_course_create_courses": "core_course_create_courses",
            "moodle_course_get_courses": "core_course_get_courses",
            "moodle_enrol_get_users_courses": "core_enrol_get_users_courses",
            "moodle_file_get_files": "core_files_get_files",
            "moodle_file_upload": "core_files_upload",
            "moodle_group_add_groupmembers": "core_group_add_group_members",
            "moodle_group_create_groups": "core_group_create_groups",
            "moodle_group_delete_groupmembers": "core_group_delete_group_members",
            "moodle_group_delete_groups": "core_group_delete_groups",
            "moodle_group_get_course_groups": "core_group_get_course_groups",
            "moodle_group_get_groupmembers": "core_group_get_group_members",
            "moodle_group_get_groups": "core_group_get_groups",
            "moodle_message_send_instantmessages": "core_message_send_instant_messages",
            "moodle_notes_create_notes": "core_notes_create_notes",
            "moodle_role_assign": "core_role_assign_role",
            "moodle_role_unassign": "core_role_unassign_role",
            "moodle_user_create_users": "core_user_create_users",
            "moodle_user_delete_users": "core_user_delete_users",
            "moodle_user_get_course_participants_by_id": "core_user_get_course_user_profiles",
            "moodle_user_get_users_by_courseid": "core_enrol_get_enrolled_users",
            // Both *_user_get_users_by_id are deprecated, but there is no equivalent available in the Mobile service.
            "moodle_user_get_users_by_id": "core_user_get_users_by_id",
            "moodle_user_update_users": "core_user_update_users",
            "moodle_webservice_get_siteinfo": "core_webservice_get_site_info",
        };

        var self = {};

        /**
         * Site object to store site data.
         *
         * @param {String} id      Site ID.
         * @param {String} siteurl Site URL.
         * @param {String} token   User's token in the site.
         * @param {Object} infos   Site's info.
         */
        function Site(id, siteurl, token, infos) {
            this.id = id;
            this.siteurl = siteurl;
            this.token = token;
            this.infos = infos;

            if (this.id) {
                this.db = $mmDB.getDB('Site-' + this.id, siteSchema, dboptions);
            }
        }

        /**
         * Get site ID.
         *
         * @return {String} Current site ID.
         */
        Site.prototype.getId = function() {
            return this.id;
        };

        /**
         * Get site URL.
         *
         * @return {String} Current site URL.
         */
        Site.prototype.getURL = function() {
            return this.siteurl;
        };

        /**
         * Get site token.
         *
         * @return {String} Current site token.
         */
        Site.prototype.getToken = function() {
            return this.token;
        };

        /**
         * Get site info.
         *
         * @return {Object} Current site info.
         */
        Site.prototype.getInfo = function() {
            return this.infos;
        };

        /**
         * Get site DB.
         *
         * @return {Object} Current site DB.
         */
        Site.prototype.getDb = function() {
            return this.db;
        };

        /**
         * Get site user's ID.
         *
         * @return {Object} User's ID.
         */
        Site.prototype.getUserId = function() {
            if (typeof this.infos != 'undefined' && typeof this.infos.userid != 'undefined') {
                return this.infos.userid;
            } else {
                return undefined;
            }
        };

        /**
         * Set site ID.
         *
         * @param {String} New ID.
         */
        Site.prototype.setId = function(id) {
            this.id = id;
            this.db = $mmDB.getDB('Site-' + this.id, siteSchema, dboptions);
        };

        /**
         * Set site token.
         *
         * @param {String} New token.
         */
        Site.prototype.setToken = function(token) {
            this.token = token;
        };

        /**
         * Set site info.
         *
         * @param {Object} New info.
         */
        Site.prototype.setInfo = function(infos) {
            this.infos = infos;
        };

        /**
         * Can the user access their private files?
         *
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canAccessMyFiles = function() {
            var infos = this.getInfo();
            return infos && (typeof infos.usercanmanageownfiles === 'undefined' || infos.usercanmanageownfiles);
        };

        /**
         * Can the user download files?
         *
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canDownloadFiles = function() {
            var infos = this.getInfo();
            return infos && infos.downloadfiles;
        };

        /**
         * Can the user use an advanced feature?
         *
         * @param {String} feature The name of the feature.
         * @param {Boolean} [whenUndefined=true] The value to return when the parameter is undefined
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canUseAdvancedFeature = function(feature, whenUndefined) {
            var infos = this.getInfo(),
                canUse = true;

            whenUndefined = (typeof whenUndefined === 'undefined') ? true : whenUndefined;

            if (typeof infos.advancedfeatures === 'undefined') {
                canUse = whenUndefined;
            } else {

                angular.forEach(infos.advancedfeatures, function(item) {
                    if (item.name === feature && parseInt(item.value, 10) === 0) {
                        canUse = false;
                    }
                });

            }

            return canUse;
        };

        /**
         * Can the user upload files?
         *
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canUploadFiles = function() {
            var infos = this.getInfo();
            return infos && infos.uploadfiles;
        };

        /**
         * Fetch site info from the Moodle site.
         *
         * @return {Promise} A promise to be resolved when the site info is retrieved.
         */
        Site.prototype.fetchSiteInfo = function() {
            var deferred = $q.defer(),
                site = this;

            // get_site_info won't be cached.
            var preSets = {
                getFromCache: 0,
                saveToCache: 0
            };

            site.read('core_webservice_get_site_info', {}, preSets).then(deferred.resolve, function(error) {
                site.read('moodle_webservice_get_siteinfo', {}, preSets).then(deferred.resolve, function(error) {
                    deferred.reject(error);
                });
            });

            return deferred.promise;
        };

        /**
         * Read some data from the Moodle site using WS. Requests are cached by default.
         *
         * @param  {String} read  WS method to use.
         * @param  {Object} data    Data to send to the WS.
         * @param  {Object} preSets Options: @see Site#request.
         * @return {Promise}        Promise to be resolved when the request is finished.
         */
        Site.prototype.read = function(method, data, preSets) {
            preSets = preSets || {};
            if (typeof(preSets.getFromCache) === 'undefined') {
                preSets.getFromCache = 1;
            }
            if (typeof(preSets.saveToCache) === 'undefined') {
                preSets.saveToCache = 1;
            }
            if (typeof(preSets.sync) === 'undefined') {
                preSets.sync = 0;
            }
            return this.request(method, data, preSets);
        };

        /**
         * Sends some data to the Moodle site using WS. Requests are NOT cached by default.
         *
         * @param  {String} method  WS method to use.
         * @param  {Object} data    Data to send to the WS.
         * @param  {Object} preSets Options: @see Site#request.
         * @return {Promise}        Promise to be resolved when the request is finished.
         */
        Site.prototype.write = function(method, data, preSets) {
            preSets = preSets || {};
            if (typeof(preSets.getFromCache) === 'undefined') {
                preSets.getFromCache = 0;
            }
            if (typeof(preSets.saveToCache) === 'undefined') {
                preSets.saveToCache = 0;
            }
            if (typeof(preSets.sync) === 'undefined') {
                preSets.sync = 0;
            }
            return this.request(method, data, preSets);
        };

        /**
         * WS request to the site.
         *
         * @param {string} method The WebService method to be called.
         * @param {Object} data Arguments to pass to the method.
         * @param {Object} preSets Extra settings.
         *                    - getFromCache boolean (false) Use the cache when possible.
         *                    - saveToCache boolean (false) Save the call results to the cache.
         *                    - omitExpires boolean (false) Ignore cache expiry.
         *                    - emergencyCache boolean (true) If possible, use the cache when the request fails.
         *                    - sync boolean (false) Add call to queue if device is not connected.
         *                    - cacheKey (string) Extra key to add to the cache when storing this call. This key is to
         *                                        flag the cache entry, it doesn't affect the data retrieved in this call.
         *                    - getCacheUsingCacheKey (boolean) True if it should retrieve cached data by cacheKey,
         *                                        false if it should get the data based on the params passed (usual behavior).
         * @return {Promise}
         * @description
         *
         * Sends a webservice request to the site. This method will automatically add the
         * required parameters and pass it on to the low level API in $mmWS.call().
         *
         * Caching is also implemented, when enabled this method will returned a cached
         * version of itself rather than contacting the server.
         *
         * This method is smart which means that it will try to map the method to a
         * compatibility one if need be, usually that means that it will fallback on
         * the 'local_mobile_' prefixed function if it is available and the non-prefixed is not.
         */
        Site.prototype.request = function(method, data, preSets) {
            var deferred = $q.defer(),
                site = this;
            data = data || {};

            // Get the method to use based on the available ones.
            method = site.getCompatibleFunction(method);

            // Check if the method is available, use a prefixed version if possible.
            // We ignore this check when we do not have the site info, as the list of functions is not loaded yet.
            if (site.getInfo() && !site.wsAvailable(method, false)) {
                if (site.wsAvailable(mmCoreWSPrefix + method, false)) {
                    $log.info("Using compatibility WS method '" + mmCoreWSPrefix + method + "'");
                    method = mmCoreWSPrefix + method;
                } else {
                    $log.error("WS function '" + method + "' is not available, even in compatibility mode.");
                    $mmLang.translateAndRejectDeferred(deferred, 'mm.core.wsfunctionnotavailable');
                    return deferred.promise;
                }
            }

            preSets = angular.copy(preSets) || {};
            preSets.wstoken = site.token;
            preSets.siteurl = site.siteurl;

            // Enable text filtering.
            data.moodlewssettingfilter = true;

            getFromCache(site, method, data, preSets).then(function(data) {
                deferred.resolve(data);
            }, function() {
                // Do not pass those options to the core WS factory.
                var wsPreSets = angular.copy(preSets);
                delete wsPreSets.getFromCache;
                delete wsPreSets.saveToCache;
                delete wsPreSets.omitExpires;
                delete wsPreSets.cacheKey;
                delete wsPreSets.emergencyCache;
                delete wsPreSets.getCacheUsingCacheKey;

                // TODO: Sync

                $mmWS.call(method, data, wsPreSets).then(function(response) {

                    if (preSets.saveToCache) {
                        saveToCache(site, method, data, response, preSets.cacheKey);
                    }

                    // We pass back a clone of the original object, this may
                    // prevent errors if in the callback the object is modified.
                    deferred.resolve(angular.copy(response));
                }, function(error) {
                    if (error === mmCoreSessionExpired) {
                        // Session expired, trigger event.
                        $mmLang.translateAndRejectDeferred(deferred, 'mm.core.lostconnection');
                        $mmEvents.trigger(mmCoreEventSessionExpired, site.id);
                    } else if (error === mmCoreUserDeleted) {
                        // User deleted, trigger event.
                        $mmLang.translateAndRejectDeferred(deferred, 'mm.core.userdeleted');
                        $mmEvents.trigger(mmCoreEventUserDeleted, {siteid: site.id, params: data});
                    } else if (typeof preSets.emergencyCache !== 'undefined' && !preSets.emergencyCache) {
                        $log.debug('WS call ' + method + ' failed. Emergency cache is forbidden, rejecting.');
                        deferred.reject(error);
                    } else {
                        $log.debug('WS call ' + method + ' failed. Trying to use the emergency cache.');
                        preSets.omitExpires = true;
                        preSets.getFromCache = true;
                        getFromCache(site, method, data, preSets).then(function(data) {
                            deferred.resolve(data);
                        }, function() {
                            deferred.reject(error);
                        });
                    }
                });
            });

            return deferred.promise;
        };

        /**
         * Check if a WS is available in this site.
         *
         * @param  {String} method WS name.
         * @param  {Boolean=true} checkPrefix When true also checks with the compatibility prefix.
         * @return {Boolean}       True if the WS is available, false otherwise.
         * @description
         *
         * This method checks if a web service function is available. By default it will
         * also check if there is a compatibility function for it, e.g. a prefixed one.
         */
        Site.prototype.wsAvailable = function(method, checkPrefix) {
            checkPrefix = (typeof checkPrefix === 'undefined') ? true : checkPrefix;

            if (typeof this.infos == 'undefined') {
                return false;
            }

            for (var i = 0; i < this.infos.functions.length; i++) {
                var f = this.infos.functions[i];
                if (f.name == method) {
                    return true;
                }
            }

            // Let's try again with the compatibility prefix.
            if (checkPrefix) {
                return this.wsAvailable(mmCoreWSPrefix + method, false);
            }

            return false;
        };

        /*
         * Uploads a file using Cordova File API.
         *
         * @param {Object} uri File URI.
         * @param {Object} options File settings: fileKey, fileName and mimeType.
         * @return {Promise}
         */
        Site.prototype.uploadFile = function(uri, options) {
            return $mmWS.uploadFile(uri, options, {
                siteurl: this.siteurl,
                token: this.token
            });
        };

        /**
         * Invalidates all the cache entries.
         *
         * @return {Promise} Promise resolved when the cache entries are invalidated.
         */
        Site.prototype.invalidateWsCache = function() {
            var db = this.db;
            if (!db) {
                return $q.reject();
            }

            $log.debug('Invalidate all the cache for site: '+ this.id);
            return db.getAll(mmCoreWSCacheStore).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };

        /**
         * Invalidates all the cache entries with a certain key.
         *
         * @param  {String} key Key to search.
         * @return {Promise}    Promise resolved when the cache entries are invalidated.
         */
        Site.prototype.invalidateWsCacheForKey = function(key) {
            var db = this.db;
            if (!db || !key) {
                return $q.reject();
            }

            $log.debug('Invalidate cache for key: '+key);
            return db.whereEqual(mmCoreWSCacheStore, 'key', key).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };

        /**
         * Invalidates all the cache entries whose key starts with a certain value.
         *
         * @param  {String} key Key to search.
         * @return {Promise}    Promise resolved when the cache entries are invalidated.
         */
        Site.prototype.invalidateWsCacheForKeyStartingWith = function(key) {
            var db = this.db;
            if (!db || !key) {
                return $q.reject();
            }

            $log.debug('Invalidate cache for key starting with: '+key);
            return db.where(mmCoreWSCacheStore, 'key', '^', key).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };

        /**
         * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
         * Uses $mmUtil.fixPluginfileURL, passing site's token.
         *
         * @param {String} url   The url to be fixed.
         * @return {String}      Fixed URL.
         */
        Site.prototype.fixPluginfileURL = function(url) {
            return $mmUtil.fixPluginfileURL(url, this.token);

        };

        /**
         * Deletes site's DB.
         *
         * @return {Promise} Promise to be resolved when the DB is deleted.
         */
        Site.prototype.deleteDB = function() {
            return $mmDB.deleteDB('Site-' + this.id);
        };

        /**
         * Deletes site's folder.
         *
         * @return {Promise} Promise to be resolved when the DB is deleted.
         */
        Site.prototype.deleteFolder = function() {
            if ($mmFS.isAvailable()) {
                var siteFolder = $mmFS.getSiteFolder(this.id);
                return $mmFS.removeDir(siteFolder).catch(function() {
                    // Ignore any errors, $mmFS.removeDir fails if folder doesn't exists.
                });
            } else {
                return $q.when();
            }
        };

        /**
         * Get space usage of the site.
         *
         * @return {Promise} Promise resolved with the site space usage (size).
         */
        Site.prototype.getSpaceUsage = function() {
            if ($mmFS.isAvailable()) {
                var siteFolderPath = $mmFS.getSiteFolder(this.id);
                return $mmFS.getDirectorySize(siteFolderPath).catch(function() {
                    return 0;
                });
            } else {
                return $q.when(0);
            }
        };

        /**
         * Returns the URL to the documentation of the app, based on Moodle version and current language.
         *
         * @param {String} [page]    Docs page to go to.
         * @return {Promise}         Promise resolved with the Moodle docs URL.
         */
        Site.prototype.getDocsUrl = function(page) {
            var release = this.infos.release ? this.infos.release : undefined;
            return $mmUtil.getDocsUrl(release, page);
        };

        /**
         * Check if the local_mobile plugin is installed in the Moodle site.
         * This plugin provide extended services.
         *
         * @param {Boolean} retrying True if we're retrying the check.
         * @return {Promise}         Promise resolved when the check is done. Resolve params:
         *                                   - {Number} code Code to identify the authentication method to use.
         *                                   - {String} [service] If defined, name of the service to use.
         *                                   - {String} [warning] If defined, code of the warning message.
         */
        Site.prototype.checkLocalMobilePlugin = function(retrying) {
            var siteurl = this.siteurl,
                self = this,
                service = mmCoreConfigConstants.wsextservice;

            if (!service) {
                // External service not defined.
                return $q.when({code: 0});
            }

            return $http.post(siteurl + '/local/mobile/check.php', {service: service}).then(function(response) {
                var data = response.data;

                if (typeof data != 'undefined' && data.errorcode === 'requirecorrectaccess') {
                    if (!retrying) {
                        self.siteurl = $mmText.addOrRemoveWWW(siteurl);
                        return self.checkLocalMobilePlugin(true);
                    } else {
                        return $q.reject(data.error);
                    }
                } else if (typeof data == 'undefined' || typeof data.code == 'undefined') {
                    // local_mobile returned something we didn't expect. Let's assume it's not installed.
                    return {code: 0, warning: 'mm.login.localmobileunexpectedresponse'};
                }

                var code = parseInt(data.code, 10);
                if (data.error) {
                    switch (code) {
                        case 1:
                            // Site in maintenance mode.
                            return $mmLang.translateAndReject('mm.login.siteinmaintenance');
                        case 2:
                            // Web services not enabled.
                            return $mmLang.translateAndReject('mm.login.webservicesnotenabled');
                        case 3:
                            // Extended service not enabled, but the official is enabled.
                            return {code: 0};
                        case 4:
                            // Neither extended or official services enabled.
                            return $mmLang.translateAndReject('mm.login.mobileservicesnotenabled');
                        default:
                            return $mmLang.translateAndReject('mm.core.unexpectederror');
                    }
                } else {
                    return {code: code, service: service};
                }
            }, function() {
                return {code: 0};
            });
        };

        /**
         * Check if local_mobile has been installed in Moodle but the app is not using it.
         *
         * @return {Promise} Promise resolved it local_mobile was added, rejected otherwise.
         */
        Site.prototype.checkIfLocalMobileInstalledAndNotUsed = function() {
            var appUsesLocalMobile = false;
            angular.forEach(this.infos.functions, function(func) {
                if (func.name.indexOf(mmCoreWSPrefix) != -1) {
                    appUsesLocalMobile = true;
                }
            });

            if (appUsesLocalMobile) {
                // App already uses local_mobile, it wasn't added.
                return $q.reject();
            }

            return this.checkLocalMobilePlugin().then(function(data) {
                if (typeof data.service == 'undefined') {
                    // local_mobile NOT installed. Reject.
                    return $q.reject();
                }
                return data;
            });
        };

        /**
         * Check if a URL belongs to this site.
         *
         * @param  {String}  url URL to check.
         * @return {Boolean}     True if URL belongs to this site, false otherwise.
         */
        Site.prototype.containsUrl = function(url) {
            if (!url) {
                return false;
            }
            var siteurl = $mmText.removeProtocolAndWWW(this.siteurl);
            url = $mmText.removeProtocolAndWWW(url);
            return url.indexOf(siteurl) == 0;
        };

        /**
         * Invalidate entries from the cache.
         *
         * @param  {Object} db      DB the entries belong to.
         * @param  {Array}  entries Entries to invalidate.
         * @return {Promise}        Promise resolved when the cache entries are invalidated.
         */
        function invalidateWsCacheEntries(db, entries) {
            var promises = [];
            angular.forEach(entries, function(entry) {
                entry.expirationtime = 0;
                var promise = db.insert(mmCoreWSCacheStore, entry);
                promises.push(promise);
            });
            return $q.all(promises);
        }

        /**
         * Return the function to be used, based on the available functions in the site. It'll try to use non-deprecated
         * functions first, and fallback to deprecated ones if needed.
         *
         * @param  {String} method WS function to check.
         * @return {String}        Method to use based in the available functions.
         */
        Site.prototype.getCompatibleFunction = function(method) {
            if (typeof deprecatedFunctions[method] !== "undefined") {
                // Deprecated function is being used. Warn the developer.
                if (this.wsAvailable(deprecatedFunctions[method])) {
                    $log.warn("You are using deprecated Web Services: " + method +
                        " you must replace it with the newer function: " + deprecatedFunctions[method]);
                    return deprecatedFunctions[method];
                } else {
                    $log.warn("You are using deprecated Web Services. " +
                        "Your remote site seems to be outdated, consider upgrade it to the latest Moodle version.");
                }
            } else if (!this.wsAvailable(method)) {
                // Method not available. Check if there is a deprecated method to use.
                for (var oldFunc in deprecatedFunctions) {
                    if (deprecatedFunctions[oldFunc] === method && this.wsAvailable(oldFunc)) {
                        $log.warn("Your remote site doesn't support the function " + method +
                            ", it seems to be outdated, consider upgrade it to the latest Moodle version.");
                        return oldFunc; // Use deprecated function.
                    }
                }
            }
            return method;
        };

        /**
         * Get a WS response from cache.
         *
         * @param {Object} site    Site.
         * @param {String} method  The WebService method.
         * @param {Object} data    Arguments to pass to the method.
         * @param {Object} preSets Extra settings.
         * @return {Promise}       Promise to be resolved with the WS response.
         */
        function getFromCache(site, method, data, preSets) {
            var result,
                db = site.db,
                deferred = $q.defer(),
                id,
                promise;

            if (!db) {
                deferred.reject();
                return deferred.promise;
            } else if (!preSets.getFromCache) {
                deferred.reject();
                return deferred.promise;
            }

            id = md5.createHash(method + ':' + JSON.stringify(data));

            if (preSets.getCacheUsingCacheKey) {
                promise = db.whereEqual(mmCoreWSCacheStore, 'key', preSets.cacheKey).then(function(entries) {
                    if (entries.length == 0) {
                        // Cache key not found, get by params sent.
                        return db.get(mmCoreWSCacheStore, id);
                    }
                    return entries[0];
                });
            } else {
                promise = db.get(mmCoreWSCacheStore, id);
            }

            promise.then(function(entry) {
                var now = new Date().getTime();

                preSets.omitExpires = preSets.omitExpires || !$mmApp.isOnline();

                if (!preSets.omitExpires) {
                    if (now > entry.expirationtime) {
                        $log.debug('Cached element found, but it is expired');
                        deferred.reject();
                        return;
                    }
                }

                if (typeof entry != 'undefined' && typeof entry.data != 'undefined') {
                    var expires = (entry.expirationtime - now) / 1000;
                    $log.info('Cached element found, id: ' + id + ' expires in ' + expires + ' seconds');
                    deferred.resolve(entry.data);
                    return;
                }

                deferred.reject();
            }, function() {
                deferred.reject();
            });

            return deferred.promise;
        }

        /**
         * Save a WS response to cache.
         *
         * @param {Object} site    Site.
         * @param {String} method   The WebService method.
         * @param {Object} data     Arguments to pass to the method.
         * @param {Object} preSets  Extra settings.
         * @param {String} cacheKey (Optional) Extra key to add to the cache object to identify similar calls.
         * @return {Promise}        Promise to be resolved when the response is saved.
         */
        function saveToCache(site, method, data, response, cacheKey) {
            var db = site.db,
                id = md5.createHash(method + ':' + JSON.stringify(data)),
                cacheExpirationTime = mmCoreConfigConstants.cache_expiration_time,
                entry = {
                        id: id,
                        data: response
                    };

            if (!db) {
                return $q.reject();
            } else {
                cacheExpirationTime = isNaN(cacheExpirationTime) ? 300000 : cacheExpirationTime;
                entry.expirationtime = new Date().getTime() + cacheExpirationTime;
                if (cacheKey) {
                    entry.key = cacheKey;
                }
                return db.insert(mmCoreWSCacheStore, entry);
            }
        }

        /**
         * Make a site object.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmSitesFactory#makeSite
         * @param {String} id      Site ID.
         * @param {String} siteurl Site URL.
         * @param {String} token   User's token in the site.
         * @param {Object} infos   Site's info.
         * @return {Object} The current site object.
         * @description
         * This returns a site object.
         */
        self.makeSite = function(id, siteurl, token, infos) {
            return new Site(id, siteurl, token, infos);
        };

        /**
         * Gets the list of Site methods.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmSitesFactory#getSiteMethods
         * @return {Array} List of methods.
         */
        self.getSiteMethods = function() {
            var methods = [];
            for (var name in Site.prototype) {
                methods.push(name);
            }
            return methods;
        };

        return self;
    }];
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreSitesStore', 'sites')
.constant('mmCoreCurrentSiteStore', 'current_site')

.config(["$mmAppProvider", "mmCoreSitesStore", "mmCoreCurrentSiteStore", function($mmAppProvider, mmCoreSitesStore, mmCoreCurrentSiteStore) {
    var stores = [
        {
            name: mmCoreSitesStore,
            keyPath: 'id'
        },
        {
            name: mmCoreCurrentSiteStore,
            keyPath: 'id'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

/**
 * Sites manager service.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmSitesManager
 */
.factory('$mmSitesManager', ["$http", "$q", "$mmSitesFactory", "md5", "$mmLang", "$mmApp", "$mmUtil", "$mmEvents", "$state", "$translate", "mmCoreSitesStore", "mmCoreCurrentSiteStore", "mmCoreEventLogin", "mmCoreEventLogout", "$log", "mmCoreWSPrefix", "mmCoreEventSiteUpdated", "mmCoreEventSiteAdded", "mmCoreEventSessionExpired", "mmCoreEventSiteDeleted", "$mmText", "mmCoreConfigConstants", function($http, $q, $mmSitesFactory, md5, $mmLang, $mmApp, $mmUtil, $mmEvents, $state,
            $translate, mmCoreSitesStore, mmCoreCurrentSiteStore, mmCoreEventLogin, mmCoreEventLogout, $log, mmCoreWSPrefix,
            mmCoreEventSiteUpdated, mmCoreEventSiteAdded, mmCoreEventSessionExpired, mmCoreEventSiteDeleted, $mmText,
            mmCoreConfigConstants) {

    $log = $log.getInstance('$mmSitesManager');

    var self = {},
        services = {},
        sessionRestored = false,
        currentSite,
        sites = {};

    /**
     * Get the demo data of the siteurl if it is a demo site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getDemoSiteData
     * @param  {String} siteurl URL of the site to check.
     * @return {Object}         Site data if it's a demo site, undefined otherwise.
     */
    self.getDemoSiteData = function(siteurl) {
        var demoSites = mmCoreConfigConstants.demo_sites;
        if (typeof demoSites != 'undefined' && typeof demoSites[siteurl] != 'undefined') {
            return demoSites[siteurl];
        }
    };

    /**
     * Check if a site is valid and if it has specifics settings for authentication
     * (like force to log in using the browser).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#checkSite
     * @param {String} siteurl  URL of the site to check.
     * @param {String} protocol Protocol to use. If not defined, use https.
     * @return {Promise}        A promise to be resolved when the site is checked. Resolve params:
     *                            {Number} code      Code to identify the authentication method to use.
     *                            {String} siteurl   Site url to use (might have changed during the process).
     *                            {String} [warning] Code of the warning message to show to the user.
     */
    self.checkSite = function(siteurl, protocol) {

        // formatURL adds the protocol if is missing.
        siteurl = $mmUtil.formatURL(siteurl);

        if (siteurl.indexOf('://localhost') == -1 && !$mmUtil.isValidURL(siteurl)) {
            return $mmLang.translateAndReject('mm.login.invalidsite');
        } else if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        } else {

            protocol = protocol || "https://";

            // Now, replace the siteurl with the protocol.
            siteurl = siteurl.replace(/^http(s)?\:\/\//i, protocol);

            return self.siteExists(siteurl).then(function() {
                // Create a temporary site to check if local_mobile is installed.
                var temporarySite = $mmSitesFactory.makeSite(undefined, siteurl);
                return temporarySite.checkLocalMobilePlugin().then(function(data) {
                    siteurl = temporarySite.getURL();
                    services[siteurl] = data.service; // No need to store it in DB.
                    return {siteurl: siteurl, code: data.code, warning: data.warning};
                });
            }, function() {
                // Site doesn't exist.

                if (siteurl.indexOf("https://") === 0) {
                    // Retry without HTTPS.
                    return self.checkSite(siteurl, "http://");
                } else{
                    return $mmLang.translateAndReject('mm.core.cannotconnect');
                }
            });
        }
    };

    /**
     * Check if a site exists.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#siteExists
     * @param  {String} siteurl URL of the site to check.
     * @return {Promise}        A promise to be resolved if the site exists.
     */
    self.siteExists = function(siteurl) {
        var url = siteurl + '/login/token.php';
        if (!ionic.Platform.isWebView()) {
            // We pass fake parameters to make CORS work (without params, the script stops before allowing CORS).
            url = url + '?username=a&password=b&service=c';
        }
        return $http.get(url, {timeout: 30000});
    };

    /**
     * Gets a user token from the server.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getUserToken
     * @param {String} siteurl   The site url.
     * @param {String} username  User name.
     * @param {String} password  Password.
     * @param {String} [service] Service to use. If not defined, it will be searched in memory.
     * @param {Boolean} retry    We are retrying with a prefixed URL.
     * @return {Promise}         A promise to be resolved when the token is retrieved. If success, returns an object
     *                           with the token and the siteurl to use.
     */
    self.getUserToken = function(siteurl, username, password, service, retry) {
        retry = retry || false;

        if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        }

        if (!service) {
            service = determineService(siteurl);
        }

        var loginurl = siteurl + '/login/token.php';
        var data = {
            username: username,
            password: password,
            service: service
        };

        return $http.post(loginurl, data).then(function(response) {
            var data = response.data;

            if (typeof data == 'undefined') {
                return $mmLang.translateAndReject('mm.core.cannotconnect');
            } else {
                if (typeof data.token != 'undefined') {
                    return {token: data.token, siteurl: siteurl};
                } else {
                    if (typeof data.error != 'undefined') {
                        // We only allow one retry (to avoid loops).
                        if (!retry && data.errorcode == "requirecorrectaccess") {
                            siteurl = $mmText.addOrRemoveWWW(siteurl);
                            return self.getUserToken(siteurl, username, password, service, true);
                        } else {
                            return $q.reject(data.error);
                        }
                    } else {
                        return $mmLang.translateAndReject('mm.login.invalidaccount');
                    }
                }
            }
        }, function() {
            return $mmLang.translateAndReject('mm.core.cannotconnect');
        });
    };

    /**
     * Add a new site to the site list and authenticate the user in this site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#newSite
     * @param {String} siteurl  The site url.
     * @param {String} token    User's token.
     * @return {Promise}        A promise to be resolved when the site is added and the user is authenticated.
     */
    self.newSite = function(siteurl, token) {

        var candidateSite = $mmSitesFactory.makeSite(undefined, siteurl, token);

        return candidateSite.fetchSiteInfo().then(function(infos) {
            if (isValidMoodleVersion(infos)) {
                var validation = validateSiteInfo(infos);
                if (validation === true) {
                    var siteid = self.createSiteID(infos.siteurl, infos.username);
                    // Add site to sites list.
                    self.addSite(siteid, siteurl, token, infos);
                    // Turn candidate site into current site.
                    candidateSite.setId(siteid);
                    candidateSite.setInfo(infos);
                    currentSite = candidateSite;
                    // Store session.
                    self.login(siteid);
                    $mmEvents.trigger(mmCoreEventSiteAdded);
                } else {
                    return $translate(validation.error, validation.params).then(function(error) {
                        return $q.reject(error);
                    });
                }
            } else {
                return $mmLang.translateAndReject('mm.login.invalidmoodleversion');
            }
        });
    };

    /**
     * Create a site ID based on site URL and username.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#createSiteID
     * @param {String} siteurl  The site url.
     * @param {String} username Username.
     * @return {String}         Site ID.
     */
    self.createSiteID = function(siteurl, username) {
        return md5.createHash(siteurl + username);
    };

    /**
     * Function for determine which service we should use (default or extended plugin).
     *
     * @param  {String} siteurl The site URL.
     * @return {String}         The service shortname.
     */
    function determineService(siteurl) {
        // We need to try siteurl in both https or http (due to loginhttps setting).

        // First http://
        siteurl = siteurl.replace("https://", "http://");
        if (services[siteurl]) {
            return services[siteurl];
        }

        // Now https://
        siteurl = siteurl.replace("http://", "https://");
        if (services[siteurl]) {
            return services[siteurl];
        }

        // Return default service.
        return mmCoreConfigConstants.wsservice;
    }

    /**
     * Check for the minimum required version (Moodle 2.4).
     *
     * @param {Array} sitefunctions List of functions of the Moodle site.
     * @return {Boolean}            True if the moodle version is valid, false otherwise.
     */
    function isValidMoodleVersion(infos) {
        if (!infos) {
            return false;
        }

        var minVersion = 2012120300, // Moodle 2.4 version.
            minRelease = "2.4";

        // Try to validate by version.
        if (infos.version) {
            var version = parseInt(infos.version);
            if (!isNaN(version)) {
                return version >= minVersion;
            }
        }

        // We couldn't validate by version number. Let's try to validate by release number.
        if (infos.release) {
            var matches = infos.release.match(/^([\d|\.]*)/);
            if (matches && matches.length > 1) {
                return matches[1] >= minRelease;
            }
        }

        // Couldn't validate by release either. Check if it uses local_mobile plugin.
        var appUsesLocalMobile = false;
        angular.forEach(infos.functions, function(func) {
            if (func.name.indexOf(mmCoreWSPrefix) != -1) {
                appUsesLocalMobile = true;
            }
        });

        return appUsesLocalMobile;
    }

    /**
     * Check if site info is valid. If it's not, return error message.
     *
     * @param {Object} infos    Site info.
     * @return {Object|Boolean} Object with error message to show and its params if info is not valid, true if info is valid.
     */
    function validateSiteInfo(infos) {
        if (!infos.firstname || !infos.lastname) {
            var moodleLink = '<a mm-browser href="' + infos.siteurl + '">' + infos.siteurl + '</a>';
            return {error: 'mm.core.requireduserdatamissing', params: {'$a': moodleLink}};
        }
        return true;
    }

    /**
     * Saves a site in local DB.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#addSite
     * @param {String} id      Site ID.
     * @param {String} siteurl Site URL.
     * @param {String} token   User's token in the site.
     * @param {Object} infos   Site's info.
     */
    self.addSite = function(id, siteurl, token, infos) {
        return $mmApp.getDB().insert(mmCoreSitesStore, {
            id: id,
            siteurl: siteurl,
            token: token,
            infos: infos
        });
    };

    /**
     * Login a user to a site from the list of sites.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#loadSite
     * @param {String} siteid ID of the site to load.
     * @return {Promise}      Promise to be resolved when the site is loaded.
     */
    self.loadSite = function(siteid) {
        $log.debug('Load site '+siteid);

        return self.getSite(siteid).then(function(site) {
            currentSite = site;
            self.login(siteid);

            // Check if local_mobile was installed to Moodle.
            return site.checkIfLocalMobileInstalledAndNotUsed().then(function() {
                // Local mobile was added. Throw invalid session to force reconnect and create a new token.
                $mmEvents.trigger(mmCoreEventSessionExpired, siteid);
            }, function() {
                // Update site info. We don't block the UI.
                self.updateSiteInfo(siteid).finally(function() {
                    var infos = site.getInfo(),
                        validation = validateSiteInfo(infos);
                    if (validation !== true) {
                        // Site info is not valid. Logout the user and show an error message.
                        self.logout();
                        $state.go('mm_login.sites');
                        $translate(validation.error, validation.params).then(function(error) {
                            $mmUtil.showErrorModal(error);
                        });
                    }
                });
            });
        });
    };

    /**
     * Get current site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getCurrentSite
     * @return {Object} Current site.
     */
    self.getCurrentSite = function() {
        return currentSite;
    };

    /**
     * Delete a site from the sites list.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#deleteSite
     * @param {String} siteid ID of the site to delete.
     * @return {Promise}      Promise to be resolved when the site is deleted.
     */
    self.deleteSite = function(siteid) {
        $log.debug('Delete site '+siteid);

        if (typeof currentSite != 'undefined' && currentSite.id == siteid) {
            self.logout();
        }

        return self.getSite(siteid).then(function(site) {
            return site.deleteDB().then(function() {
                delete sites[siteid];
                return $mmApp.getDB().remove(mmCoreSitesStore, siteid).then(function() {
                    return site.deleteFolder();
                }, function() {
                    // DB remove shouldn't fail, but we'll go ahead even if it does.
                    return site.deleteFolder();
                }).then(function() {
                    $mmEvents.trigger(mmCoreEventSiteDeleted, site);
                });
            });
        });
    };

    /**
     * Check if there are no sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#hasNoSites
     * @return {Promise} Promise to be resolved if there are no sites, and rejected if there is at least one.
     */
    self.hasNoSites = function() {
        return $mmApp.getDB().count(mmCoreSitesStore).then(function(count) {
            if (count > 0) {
                return $q.reject();
            }
        });
    };

    /**
     * Check if there are sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#hasSites
     * @return {Promise} Promise to be resolved if there is at least one site, and rejected if there aren't.
     */
    self.hasSites = function() {
        return $mmApp.getDB().count(mmCoreSitesStore).then(function(count) {
            if (count == 0) {
                return $q.reject();
            }
        });
    };

    /**
     * Returns a site object.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSite
     * @param  {Number} siteId The site ID.
     * @return {Promise}
     */
    self.getSite = function(siteId) {
        if (!siteId) {
            // Site ID not valid, reject.
            return $q.reject();
        } else if (currentSite && currentSite.getId() === siteId) {
            return $q.when(currentSite);
        } else if (typeof sites[siteId] != 'undefined') {
            return $q.when(sites[siteId]);
        } else {
            return $mmApp.getDB().get(mmCoreSitesStore, siteId).then(function(data) {
                var site = $mmSitesFactory.makeSite(siteId, data.siteurl, data.token, data.infos);
                sites[siteId] = site;
                return site;
            });
        }
    };

    /**
     * Returns the database object of a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSiteDb
     * @param  {Number} siteId The site ID.
     * @return {Promise}
     */
    self.getSiteDb = function(siteId) {
        return self.getSite(siteId).then(function(site) {
            return site.getDb();
        });
    };

    /**
     * Get the list of sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSites
     * @param {String[]} [ids] IDs of the sites to get. If not defined, return all sites.
     * @return {Promise}       Promise to be resolved when the sites are retrieved.
     */
    self.getSites = function(ids) {
        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var formattedSites = [];
            angular.forEach(sites, function(site) {
                if (!ids || ids.indexOf(site.id) > -1) {
                    formattedSites.push({
                        id: site.id,
                        siteurl: site.siteurl,
                        fullname: site.infos.fullname,
                        sitename: site.infos.sitename,
                        avatar: site.infos.userpictureurl
                    });
                }
            });
            return formattedSites;
        });
    };

    /**
     * Get the list of IDs of sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSitesIds
     * @return {Promise} Promise to be resolved when the sites IDs are retrieved.
     */
    self.getSitesIds = function() {
        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var ids = [];
            angular.forEach(sites, function(site) {
                ids.push(site.id);
            });
            return ids;
        });
    };

    /**
     * Login the user in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#login
     * @param  {String} siteid ID of the site the user is accessing.
     * @return {Promise}       Promise resolved when current site is stored.
     */
    self.login = function(siteid) {
        return $mmApp.getDB().insert(mmCoreCurrentSiteStore, {
            id: 1,
            siteid: siteid
        }).then(function() {
            $mmEvents.trigger(mmCoreEventLogin);
        });
    };

    /**
     * Logout the user.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#logout
     * @return {Promise} Promise to be resolved when the user is logged out.
     */
    self.logout = function() {
        currentSite = undefined;
        $mmEvents.trigger(mmCoreEventLogout);
        return $mmApp.getDB().remove(mmCoreCurrentSiteStore, 1);
    }

    /**
     * Restores the session to the previous one so the user doesn't has to login everytime the app is started.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#restoreSession
     * @return {Promise} Promise to be resolved if a session is restored.
     */
    self.restoreSession = function() {
        if (sessionRestored) {
            return $q.reject();
        }
        sessionRestored = true;

        return $mmApp.getDB().get(mmCoreCurrentSiteStore, 1).then(function(current_site) {
            var siteid = current_site.siteid;
            $log.debug('Restore session in site '+siteid);
            return self.loadSite(siteid);
        }, function() {
            return $q.reject(); // Reject without params.
        });
    };

    /**
     * Updates a site's token.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#updateSiteToken
     * @param {String} siteurl  Site's URL.
     * @param {String} username Username.
     * @param {String} token    User's new token.
     * @return {Promise}        A promise to be resolved when the site is updated.
     */
    self.updateSiteToken = function(siteurl, username, token) {
        var siteid = self.createSiteID(siteurl, username);
        return self.getSite(siteid).then(function(site) {
            site.token = token;

            return $mmApp.getDB().insert(mmCoreSitesStore, {
                id: siteid,
                siteurl: site.getURL(),
                token: token,
                infos: site.getInfo()
            });
        });
    };

    /**
     * Updates a site's info.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#updateSiteInfo
     * @param {String} siteid Site's ID.
     * @return {Promise}      A promise to be resolved when the site is updated.
     */
    self.updateSiteInfo = function(siteid) {
        return self.getSite(siteid).then(function(site) {
            return site.fetchSiteInfo().then(function(infos) {
                site.setInfo(infos);
                return $mmApp.getDB().insert(mmCoreSitesStore, {
                    id: siteid,
                    siteurl: site.getURL(),
                    token: site.getToken(),
                    infos: infos
                }).finally(function() {
                    $mmEvents.trigger(mmCoreEventSiteUpdated, siteid);
                });
            });
        });
    };

    /**
     * Updates a site's info.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#updateSiteInfoByUrl
     * @param {String} siteurl  Site's URL.
     * @param {String} username Username.
     * @return {Promise}        A promise to be resolved when the site is updated.
     */
    self.updateSiteInfoByUrl = function(siteurl, username) {
        var siteid = self.createSiteID(siteurl, username);
        return self.updateSiteInfo(siteid);
    };

    /**
     * Get the site IDs a URL belongs to.
     * Someone can have more than one account in the same site, that's why this function returns an array of IDs.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSitesUrls
     * @param {String} url         URL to check.
     * @param {Boolean} prioritize True if it should prioritize current site. If the URL belongs to current site then it won't
     *                             check any other site, it will only return current site.
     * @return {Promise}           Promise resolved with the site IDs (array).
     */
    self.getSiteIdsFromUrl = function(url, prioritize) {
        // Check current site first, it has priority over the rest of sites.
        if (prioritize && currentSite && currentSite.containsUrl(url)) {
            return $q.when([currentSite.getId()]);
        }

        // Check if URL has http(s) protocol.
        if (!url.match(/^https?:\/\//i)) {
            // URL doesn't have http(s) protocol. Check if it has any protocol.
            if (url.match(/^[^:]{2,10}:\/\//i)) {
                // It has some protocol. Return empty array.
                return $q.when([]);
            } else {
                // No protocol, probably a relative URL. Return current site.
                if (currentSite) {
                    return $q.when([currentSite.getId()]);
                } else {
                    return $q.when([]);
                }
            }
        }

        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var ids = [];
            angular.forEach(sites, function(site) {
                if (!sites[site.id]) {
                    sites[site.id] = $mmSitesFactory.makeSite(site.id, site.siteurl, site.token, site.infos);
                }
                if (sites[site.id].containsUrl(url)) {
                    ids.push(site.id);
                }
            });
            return ids;
        }).catch(function() {
            // Shouldn't happen.
            return [];
        });
    };

    return self;

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmText
 * @module mm.core
 * @description
 * This service provides functions related to text, like formatting texts from Moodle.
 */
.factory('$mmText', ["$q", "$mmLang", "$translate", function($q, $mmLang, $translate) {

    var self = {};

    /**
     * Convert size in bytes into human readable format
     * http://codeaid.net/javascript/convert-size-in-bytes-to-human-readable-format-(javascript)
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#bytesToSize
     * @param {Number} bytes         Number of bytes to convert.
     * @param {Number} [precision=2] Number of digits after the decimal separator.
     * @return {String}              Size in human readable format.
     */
    self.bytesToSize = function(bytes, precision) {

        if (typeof bytes == 'undefined' || bytes < 0) {
            return $translate.instant('mm.core.notapplicable');
        }

        if (typeof precision == 'undefined' || precision < 0) {
            precision = 2;
        }

        var keys = ['mm.core.sizeb', 'mm.core.sizekb', 'mm.core.sizemb', 'mm.core.sizegb', 'mm.core.sizetb'];
        var units = $translate.instant(keys);
        var posttxt = 0;
        if (bytes >= 1024) {
            while (bytes >= 1024) {
                posttxt++;
                bytes = bytes / 1024;
            }
            bytes = Number(Math.round(bytes+'e+'+precision) + 'e-'+precision); // Round to "precision" decimals if needed.
        }
        return $translate.instant('mm.core.humanreadablesize', {size: Number(bytes), unit: units[keys[posttxt]]});
    };

    /**
     * Function to clean HTML tags.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#cleanTags
     * @param  {String}  text         The text to be cleaned.
     * @param  {Boolean} [singleLine] True if new lines should be removed (all the text in a single line).
     * @return {String}               Text cleaned.
     */
    self.cleanTags = function(text, singleLine) {
        // First, we use a regexpr.
        text = text.replace(/(<([^>]+)>)/ig,"");
        // Then, we rely on the browser. We need to wrap the text to be sure is HTML.
        text = angular.element('<p>').html(text).text(); // Get directive's content.
        // Recover or remove new lines.
        text = self.replaceNewLines(text, singleLine ? ' ' : '<br />');
        return text;
    };

    /**
     * Replace all the new lines on a certain text.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#replaceNewLines
     * @param  {String}  text     The text to be treated.
     * @param  {Boolean} newValue Text to place on each new line.
     * @return {String}           Treated text.
     */
    self.replaceNewLines = function(text, newValue) {
        return text.replace(/(?:\r\n|\r|\n)/g, newValue);
    };

    /**
     * Formats a text, treating multilang tags and cleaning HTML if needed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#formatText
     * @param  {String} text             Text to format.
     * @param  {Boolean} clean           True if HTML tags should be removed, false otherwise.
     * @param  {Boolean} [singleLine]    True if new lines should be removed. Only valid if clean is true.
     * @param  {Number}  [shortenLength] Number of characters to shorten the text.
     * @return {Promise}                 Promise resolved with the formatted text.
     */
    self.formatText = function(text, clean, singleLine, shortenLength) {
        return self.treatMultilangTags(text).then(function(formatted) {
            if (clean) {
                formatted = self.cleanTags(formatted, singleLine);
            }
            if (shortenLength && parseInt(shortenLength) > 0) {
                formatted = self.shortenText(formatted, parseInt(shortenLength));
            }
            return formatted;
        });
    };

    /**
     * Shortens a text to length and adds an ellipsis.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#shortenText
     * @param  {String} text The text to be shortened.
     * @param  {Number} length The desired length.
     * @return {String} Shortened text.
     */
    self.shortenText = function(text, length) {
        if (text.length > length) {
            text = text.substr(0, length);

            // Now, truncate at the last word boundary (if exists).
            var lastWordPos = text.lastIndexOf(' ');
            if (lastWordPos > 0) {
                text = text.substr(0, lastWordPos);
            }
            text += '&hellip;';
        }
        return text;
    };

    /**
     * Treat the multilang tags from a HTML code, leaving only the current language.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#treatMultilangTags
     * @param {String} text   The text to be formatted.
     * @param {String} siteId ID of the site to use. If not set, use current site.
     * @return {Promise}      Promise resolved with the formatted text.
     */
    self.treatMultilangTags = function(text) {
        if (!text) {
            return $q.when('');
        }

        return $mmLang.getCurrentLanguage().then(function(language) {
            // Match the current language
            var currentLangRe = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g'),
                anyLangRE = /<(?:lang|span)[^>]+lang="[a-zA-Z0-9_-]+"[^>]*>(.*?)<\/(?:lang|span)>/g;

            if (!text.match(currentLangRe)) {
                // Current lang not found. Try to find the first language.
                var matches = text.match(anyLangRE);
                if (matches && matches[0]) {
                    language = matches[0].match(/lang="([a-zA-Z0-9_-]+)"/)[1];
                    currentLangRe = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g');
                } else {
                    // No multi-lang tag found, stop.
                    return text;
                }
            }
            // Extract contents of current language.
            text = text.replace(currentLangRe, '$1');
            // Delete the rest of languages
            text = text.replace(anyLangRE, '');
            return text;
        });
    };

    /**
     * Escape an HTML text. This implementation is based on PHP's htmlspecialchars.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#escapeHTML
     * @param  {String} text Text to escape.
     * @return {String}      Escaped text.
     */
    self.escapeHTML = function(text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        } else if (typeof text != 'string') {
            return '' + text;
        }

        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    };

    /**
     * Add or remove 'www' from a URL. The url needs to have http or https protocol.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#addOrRemoveWWW
     * @param {String} url URL to modify.
     * @return             Modified URL.
     */
    self.addOrRemoveWWW = function(url) {
        if (typeof url == 'string') {
            if (url.match(/http(s)?:\/\/www\./)) {
                // Already has www. Remove it.
                url = url.replace('www.', '');
            } else {
                url = url.replace('https://', 'https://www.');
                url = url.replace('http://', 'http://www.');
            }
        }
        return url;
    };

    /**
     * Remove protocol and www from a URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#removeProtocolAndWWW
     * @param  {String} url URL to treat.
     * @return {String}     Treated URL.
     */
    self.removeProtocolAndWWW = function(url) {
        // Remove protocol.
        url = url.replace(/.*?:\/\//g, '');
        // Remove www.
        url = url.replace(/^www./, '');
        return url;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreVersionApplied', 'version_applied')

/**
 * Factory to handle app updates. This factory shouldn't be used outside of core.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmUpdateManager
 * @description
 * This service handles processes that need to be run when updating the app, like migrate MM1 sites to MM2.
 */
.factory('$mmUpdateManager', ["$log", "$q", "$mmConfig", "$mmSitesManager", "$mmFS", "$cordovaLocalNotification", "$mmLocalNotifications", "$mmApp", "$mmEvents", "mmCoreSitesStore", "mmCoreVersionApplied", "mmCoreEventSiteAdded", "mmCoreEventSiteUpdated", "mmCoreEventSiteDeleted", "$injector", "$mmFilepool", "mmCoreCourseModulesStore", "mmFilepoolLinksStore", "mmFilepoolPackagesStore", "mmCoreConfigConstants", function($log, $q, $mmConfig, $mmSitesManager, $mmFS, $cordovaLocalNotification, $mmLocalNotifications,
            $mmApp, $mmEvents, mmCoreSitesStore, mmCoreVersionApplied, mmCoreEventSiteAdded, mmCoreEventSiteUpdated,
            mmCoreEventSiteDeleted, $injector, $mmFilepool, mmCoreCourseModulesStore, mmFilepoolLinksStore,
            mmFilepoolPackagesStore, mmCoreConfigConstants) {

    $log = $log.getInstance('$mmUpdateManager');

    var self = {},
        sitesFilePath = 'migration/sites.json';

    /**
     * Check if the app has been updated and performs the needed processes.
     * This function shouldn't be used outside of core.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUpdateManager#check
     * @return {Promise} Promise resolved when the update process finishes.
     */
    self.check = function() {
        var promises = [],
            versionCode = mmCoreConfigConstants.versioncode;

        return $mmConfig.get(mmCoreVersionApplied, 0).then(function(versionApplied) {

            if (versionCode >= 391 && versionApplied < 391) {
                // Migrating from MM1 to MM2.
                promises.push(migrateMM1Sites());
                // Ignore errors in clearAppFolder. We don't want to clear the folder
                // everytime the app is opened if something goes wrong.
                promises.push(clearAppFolder().catch(function() {}));
            }

            if (versionCode >= 2003 && versionApplied < 2003) {
                promises.push(cancelAndroidNotifications());
            }

            if (versionCode >= 2003) {
                setStoreSitesInFile();
            }

            if (versionCode >= 2007 && versionApplied < 2007) {
                promises.push(migrateModulesStatus());
            }

            return $q.all(promises).then(function() {
                return $mmConfig.set(mmCoreVersionApplied, versionCode);
            }).catch(function() {
                $log.error('Error applying update from ' + versionApplied + ' to ' + versionCode);
            });
        });
    };

    /**
     * Clear the app folder.
     *
     * @return {Promise} Promise resolved when the folder is cleared.
     */
    function clearAppFolder() {
        if ($mmFS.isAvailable()) {
            return $mmFS.getDirectoryContents('').then(function(entries) {
                var promises = [];
                angular.forEach(entries, function(entry) {
                    // In Android, don't delete 'cache' and 'files' folders, created by the OS.
                    var canDeleteAndroid = ionic.Platform.isAndroid() && entry.name !== 'cache' && entry.name !== 'files';
                    var canDeleteIOS = ionic.Platform.isIOS() && entry.name !== 'NoCloud';
                    if (canDeleteIOS || canDeleteAndroid) {
                        promises.push($mmFS.removeDir(entry.name));
                    }
                });
                return $q.all(promises);
            });
        } else {
            return $q.when();
        }
    }

    /**
     * Migrate MoodleMobile 1 sites to MoodleMobile 2.
     *
     * @return {Promise} Promise resolved when the sites are migrated.
     */
    function migrateMM1Sites() {
        var sites = localStorage.getItem('sites'),
            promises = [];

        if (sites) {
            sites = sites.split(',');

            angular.forEach(sites, function(siteid) {
                if (!siteid) {
                    return;
                }

                $log.debug('Migrating site from MoodleMobile 1: ' + siteid);
                var site = localStorage.getItem('sites-'+siteid),
                    infos;

                if (site) {
                    try {
                        site = JSON.parse(site);
                    } catch(ex) {
                        // Invalid site. Shouldn't happen.
                        $log.warn('Site ' + siteid + ' data is invalid. Ignoring.');
                        return;
                    }

                    // In MM1 site info is mixed with site basic data (id, token, siteurl).
                    infos = angular.copy(site);
                    delete infos.id;
                    delete infos.token;
                    promises.push($mmSitesManager.addSite(site.id, site.siteurl, site.token, infos));
                } else {
                    $log.warn('Site ' + siteid + ' not found in local storage. Ignoring.');
                }
            });
        }

        return $q.all(promises).then(function() {
            if (sites) {
                localStorage.clear();
            }
        });
    }

    /**
     * Cancel all Android notifications. MM 2.0 was released with a bug in notifications ID (Android). These IDs were stored in
     * SharedPreferences, cancel them all will clear the stored values. @see MOBILE-1148.
     *
     * @return {Promise} Promise resolved when the notifications are cancelled.
     */
    function cancelAndroidNotifications() {
        if ($mmLocalNotifications.isAvailable() && ionic.Platform.isAndroid()) {
            return $cordovaLocalNotification.cancelAll().catch(function() {
                $log.error('Error cancelling Android notifications.');
            });
        }
        return $q.when();
    }

    /**
     * Sets the events to store the sites in a file.
     */
    function setStoreSitesInFile() {
        $mmEvents.on(mmCoreEventSiteAdded, storeSitesInFile);
        $mmEvents.on(mmCoreEventSiteUpdated, storeSitesInFile);
        $mmEvents.on(mmCoreEventSiteDeleted, storeSitesInFile);
        storeSitesInFile();
    }

    /**
     * Get sites stored in a file. It'll be used to migrate to Crosswalk if users skipped SQLite migration version.
     *
     * @return {Promise} Promise resolved with sites are retrieved. Resolve param is the sites list.
     */
    function getSitesStoredInFile() {
        if ($mmFS.isAvailable()) {
            return $mmFS.readFile(sitesFilePath).then(function(sites) {
                try {
                    sites = JSON.parse(sites);
                } catch (ex) {
                    sites = [];
                }
                return sites;
            }).catch(function() {
                // Error reading, probably file doesn't exist. Return empty list.
                return [];
            });
        } else {
            return $q.when([]);
        }
    }

    /**
     * Store sites in a file. It'll be used to migrate to Crosswalk if users skipped SQLite migration version.
     *
     * @return {Promise} Promise resolved when file is written.
     */
    function storeSitesInFile() {
        if ($mmFS.isAvailable()) {
            return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
                angular.forEach(sites, function(site) {
                    site.token = 'private'; // Remove the token, we don't want it written in a file.
                });
                return $mmFS.writeFile(sitesFilePath, JSON.stringify(sites));
            });
        } else {
            return $q.when();
        }
    }

    /**
     * Delete file with sites stored.
     *
     * @return {Promise} Promise resolved when file is deleted.
     */
    function deleteSitesFile() {
        if ($mmFS.isAvailable()) {
            return $mmFS.removeFile(sitesFilePath);
        } else {
            return $q.when();
        }
    }

    /**
     * Migrate mmCoreCourseModulesStore to mmFilepoolPackagesStore.
     *
     * @return {Promise} Promise resolved when the migration is finished.
     */
    function migrateModulesStatus() {
        var components = [];
        components.push($injector.get('mmaModBookComponent'));
        components.push($injector.get('mmaModImscpComponent'));
        components.push($injector.get('mmaModPageComponent'));
        components.push($injector.get('mmaModResourceComponent'));

        return $mmSitesManager.getSitesIds().then(function(sites) {
            var promises = [];
            angular.forEach(sites, function(siteId) {
                promises.push(migrateSiteModulesStatus(siteId, components));
            });
            return $q.all(promises);
        });
    }

    /**
     * Migrates the modules status from a certain site.
     *
     * @param {String} siteId       Site ID.
     * @param {String[]} components Components to check.
     * @return {Promise}            Promise resolved when the site migration is finished.
     */
    function migrateSiteModulesStatus(siteId, components) {
        $log.debug('Migrate site modules status from site ' + siteId);

        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            return db.getAll(mmCoreCourseModulesStore).then(function(entries) {
                var promises = [];

                angular.forEach(entries, function(entry) {
                    if (!parseInt(entry.id)) {
                        return; // The id is not a number, ignore it.
                    }

                    promises.push(determineComponent(db, entry.id, components).then(function(component) {
                        if (component) {
                            // Add a new entry in filepool store.
                            // We don't use $mmFilepool#storePackageStatus because we want to keep previousStatus.
                            entry.component = component;
                            entry.componentId = entry.id;
                            entry.id = $mmFilepool.getPackageId(component, entry.id);
                            promises.push(db.insert(mmFilepoolPackagesStore, entry));
                        }
                    }));
                });

                return $q.all(promises).then(function() {
                    // Success creating all the new entries. Let's remove the old ones.
                    return db.removeAll(mmCoreCourseModulesStore).catch(function() {
                        // Ignore errors.
                    });
                });
            });
        });
    }

    /**
     * Determines the component of a module status entry.
     *
     * @param  {Object} db           Site database.
     * @param  {Number} componentId  Component ID.
     * @param  {String[]} components List of components to check.
     * @return {Promise}             Promise resolved with the component or undefined if no component found.
     */
    function determineComponent(db, componentId, components) {
        var promises = [],
            component;

        angular.forEach(components, function(c) {
            if (c) {
                promises.push(db.query(mmFilepoolLinksStore, ['componentAndId', '=', [c, componentId]]).then(function(items) {
                    if (items.length) {
                        component = c;
                    }
                }).catch(function() {
                    // Never reject.
                }));
            }
        });

        return $q.all(promises).then(function() {
            return component;
        });
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Service to handle custom URLs schemes. Notifies all the observers when the app is invoked with a custom URL.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmURLDelegate
 */
.factory('$mmURLDelegate', ["$log", function($log) {

    $log = $log.getInstance('$mmURLDelegate');

    var observers = {},
        self = {};

    /**
     * Register an observer to be notified when the app is launched via custom URL scheme.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmURLDelegate#register
     * @param {String} name       Observer's name. Must be unique.
     * @param {Function} callback Function to call with the URLs received by the app. This function should check if the URL
     *                            is the one expected by the observer and return true if it is, return false otherwise.
     */
    self.register = function(name, callback) {
        $log.debug("Register observer '"+name+"' for custom URL.");
        observers[name] = callback;
    };

    /**
     * Notify all observers.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmURLDelegate#notify
     * @param {String} url URL to notify to the observers.
     */
    self.notify = function(url) {
        var treated = false; // Once an observer accepts a URL (return true) we stop notifying.
        angular.forEach(observers, function(callback, name) {
            if (!treated && typeof(callback) === 'function') {
                treated = callback(url);
            }
        });
    };

    return self;
}])

.run(["$mmURLDelegate", "$log", function($mmURLDelegate, $log) {
    window.handleOpenURL = function(url) {
        $log.debug('App launched by URL.');
        $mmURLDelegate.notify(url);
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Provider with some 'util' functionalities.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmUtil
 */
.provider('$mmUtil', ["mmCoreSecondsYear", "mmCoreSecondsDay", "mmCoreSecondsHour", "mmCoreSecondsMinute", function(mmCoreSecondsYear, mmCoreSecondsDay, mmCoreSecondsHour, mmCoreSecondsMinute) {

    var self = this, // Use 'self' to be coherent with the rest of services.
        provider = this; // To access provider methods from the service.

    /**
     * Serialize an object to be used in a request.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtilProvider#param
     * @param  {Object} obj Object to serialize.
     * @return {String}     Serialization of the object.
     */
    self.param = function(obj) {
        var query = '', name, value, fullSubName, subName, subValue, innerObj, i;

        for (name in obj) {
            value = obj[name];

            if (value instanceof Array) {
                for (i = 0; i < value.length; ++i) {
                    subValue = value[i];
                    fullSubName = name + '[' + i + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += self.param(innerObj) + '&';
                }
            }
            else if (value instanceof Object) {
                for (subName in value) {
                    subValue = value[subName];
                    fullSubName = name + '[' + subName + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += self.param(innerObj) + '&';
                }
            }
            else if (value !== undefined && value !== null) query += encodeURIComponent(name) + '=' + encodeURIComponent(value) + '&';
        }

        return query.length ? query.substr(0, query.length - 1) : query;
    };

    this.$get = ["$ionicLoading", "$ionicPopup", "$injector", "$translate", "$http", "$log", "$q", "$mmLang", "$mmFS", "$timeout", "$mmApp", "$mmText", "mmCoreWifiDownloadThreshold", "mmCoreDownloadThreshold", function($ionicLoading, $ionicPopup, $injector, $translate, $http, $log, $q, $mmLang, $mmFS, $timeout, $mmApp,
                $mmText, mmCoreWifiDownloadThreshold, mmCoreDownloadThreshold) {

        $log = $log.getInstance('$mmUtil');

        var self = {}; // Use 'self' to be coherent with the rest of services.

        /**
         * Formats a URL, trim, lowercase, etc...
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#formatURL
         * @param  {String} url The url to be formatted.
         * @return {String}     Fromatted url.
         */
        self.formatURL = function(url) {

            url = url.trim();

            // Check if the URL starts by http or https.
            if (! /^http(s)?\:\/\/.*/i.test(url)) {
                // Test first allways https.
                url = "https://" + url;
            }

            // http allways in lowercase.
            url = url.replace(/^http/i, 'http');
            url = url.replace(/^https/i, 'https');

            // Replace last slash.
            url = url.replace(/\/$/, "");

            return url;
        };

        /**
         * Resolves an object.
         *
         * @description
         * This is used to resolve what a callback should be when attached to a delegate.
         * For instance, if the object attached is a function, it is returned as is, but
         * we also support complex definition of objects. If we receive a string we will parse
         * it and to inject its service using $injector from Angular.
         *
         * Examples:
         * - (Function): returns the same function.
         * - (Object): returns the same object.
         * - '$mmSomething': Injects and returns $mmSomething.
         * - '$mmSomething.method': Injectes and returns a reference to the function 'method'.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#resolveObject
         * @param  {Mixed} object String, object or function.
         * @param  {Boolean} [instantiate=false] When true, if the object resolved is a function, instantiates it.
         * @return {Object} The reference to the object resolved.
         */
        self.resolveObject = function(object, instantiate) {
            var toInject,
                resolved;

            instantiate = angular.isUndefined(instantiate) ? false : instantiate;

            if (angular.isFunction(object) || angular.isObject(object)) {
                resolved = object;

            } else if (angular.isString(object)) {
                toInject = object.split('.');
                resolved = $injector.get(toInject[0]);

                if (toInject.length > 1) {
                    resolved = resolved[toInject[1]];
                }
            }

            if (angular.isFunction(resolved) && instantiate) {
                resolved = resolved();
            }

            if (typeof resolved === 'undefined') {
                throw new Error('Unexpected argument passed passed');
            }
            return resolved;
        };

        /**
         * Returns if a URL is downloadable: plugin file OR theme/image.php OR gravatar.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isDownloadableUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is downloadable.
         */
        self.isDownloadableUrl = function(url) {
            return self.isPluginFileUrl(url) || self.isThemeImageUrl(url) || self.isGravatarUrl(url);
        };

        /**
         * Returns if a URL is a gravatar URL.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isGravatarUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is a gravatar URL.
         */
        self.isGravatarUrl = function(url) {
            return url && url.indexOf('gravatar.com/avatar') !== -1;
        };

        /**
         * Returns if a URL is a pluginfile URL.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isPluginFileUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is a pluginfile URL.
         */
        self.isPluginFileUrl = function(url) {
            return url && url.indexOf('/pluginfile.php') !== -1;
        };

        /**
         * Returns if a URL is a theme image URL.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isThemeImageUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is a theme image URL.
         */
        self.isThemeImageUrl = function(url) {
            return url && url.indexOf('/theme/image.php') !== -1;
        };

        /**
         * Validates a URL for a specific pattern.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isValidURL
         * @param {String} url The url to test against the pattern
         * @return {Boolean}   TRUE if the url matches the expected pattern.
         *                     FALSE otherwise.
         */
        self.isValidURL = function(url) {
            return /^http(s)?\:\/\/([\da-zA-Z\.-]+)\.([\da-zA-Z\.]{2,6})([\/\w \.-]*)*\/?/i.test(url);
        };

        /**
         * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
         * For download remote files from Moodle we need to use the special /webservice/pluginfile passing
         * the ws token as a get parameter.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#fixPluginfileURL
         * @param {String} url   The url to be fixed.
         * @param {String} token Token to use.
         * @return {String}      Fixed URL.
         */
        self.fixPluginfileURL = function(url, token) {

            // This function is used in regexp callbacks, better not to risk!!
            if (!url) {
                return '';
            }

            // First check if we need to fix this url or is already fixed.
            if (url.indexOf('token=') != -1) {
                return url;
            }

            // Check if is a valid URL (contains the pluginfile endpoint).
            if (url.indexOf('pluginfile') == -1) {
                return url;
            }

            if (!token) {
                return '';
            }

            // In which way the server is serving the files? Are we using slash parameters?
            if (url.indexOf('?file=') != -1 || url.indexOf('?forcedownload=') != -1 || url.indexOf('?rev=') != -1) {
                url += '&';
            } else {
                url += '?';
            }
            url += 'token=' + token;

            // Some webservices returns directly the correct download url, others not.
            if (url.indexOf('/webservice/pluginfile') == -1) {
                url = url.replace('/pluginfile', '/webservice/pluginfile');
            }
            return url;
        };

        /**
         * Open a file using platform specific method.
         *
         * node-webkit: Using the default application configured.
         * Android: Using the WebIntent plugin.
         * iOs: Using the window.open method.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#openFile
         * @param  {String} path The local path of the file to be open.
         * @return {Void}
         */
        self.openFile = function(path) {
            var deferred = $q.defer();

            if (false) {
                // TODO Restore node-webkit support.

                // Link is the file path in the file system.
                // We use the node-webkit shell for open the file (pdf, doc) using the default application configured in the os.
                // var gui = require('nw.gui');
                // gui.Shell.openItem(path);
                deferred.resolve();

            } else if (window.plugins) {
                var extension = $mmFS.getFileExtension(path),
                    mimetype = $mmFS.getMimeType(extension);

                if (ionic.Platform.isAndroid() && window.plugins.webintent) {
                    var iParams = {
                        action: "android.intent.action.VIEW",
                        url: path,
                        type: mimetype
                    };

                    window.plugins.webintent.startActivity(
                        iParams,
                        function() {
                            $log.debug('Intent launched');
                            deferred.resolve();
                        },
                        function() {
                            $log.debug('Intent launching failed.');
                            $log.debug('action: ' + iParams.action);
                            $log.debug('url: ' + iParams.url);
                            $log.debug('type: ' + iParams.type);

                            if (!extension || extension.indexOf('/') > -1 || extension.indexOf('\\') > -1) {
                                // Extension not found.
                                $mmLang.translateAndRejectDeferred(deferred, 'mm.core.erroropenfilenoextension');
                            } else {
                                $mmLang.translateAndRejectDeferred(deferred, 'mm.core.erroropenfilenoapp');
                            }
                        }
                    );

                } else if (ionic.Platform.isIOS() && typeof handleDocumentWithURL == 'function') {

                    $mmFS.getBasePath().then(function(fsRoot) {
                        // Encode/decode the specific file path, note that a path may contain directories
                        // with white spaces, special characters...
                        if (path.indexOf(fsRoot > -1)) {
                            path = path.replace(fsRoot, "");
                            path = encodeURIComponent(decodeURIComponent(path));
                            path = fsRoot + path;
                        }

                        handleDocumentWithURL(
                            function() {
                                $log.debug('File opened with handleDocumentWithURL' + path);
                                deferred.resolve();
                            },
                            function(error) {
                                $log.debug('Error opening with handleDocumentWithURL' + path);
                                if(error == 53) {
                                    $log.error('No app that handles this file type.');
                                }
                                self.openInBrowser(path);
                                deferred.resolve();
                            },
                            path
                        );
                    }, deferred.reject);
                } else {
                    // Last try, launch the file with the browser.
                    self.openInBrowser(path);
                    deferred.resolve();
                }
            } else {
                // Changing _blank for _system may work in cordova 2.4 and onwards.
                $log.debug('Opening external file using window.open()');
                window.open(path, '_blank');
                deferred.resolve();
            }

            return deferred.promise;
        };

        /**
         * Open a URL using a browser.
         *
         * Do not use for files, refer to {@link $mmUtil#openFile}.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#openInBrowser
         * @param  {String} url The URL to open.
         * @return {Void}
         */
        self.openInBrowser = function(url) {
            window.open(url, '_system');
        };

        /**
         * Open a URL using InAppBrowser.
         *
         * Do not use for files, refer to {@link $mmUtil#openFile}.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#openInApp
         * @param  {String} url The URL to open.
         * @return {Void}
         */
        self.openInApp = function(url) {
            window.open(url, '_blank');
        };

        /**
         * Displays a loading modal window.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showModalLoading
         * @param {String}  text           The text of the modal window.
         * @param {Boolean} needsTranslate True if the 'text' is a $translate key, false otherwise.
         * @return {Object}                Object with a 'dismiss' function to close the modal.
         * @description
         * Usage:
         *     var modal = $mmUtil.showModalLoading(myText);
         *     ...
         *     modal.dismiss();
         */
        self.showModalLoading = function(text, needsTranslate) {
            var modalClosed = false,
                modalShown = false;

            if (!text) {
                text = 'mm.core.loading';
                needsTranslate = true;
            }

            function showModal(text) {
                if (!modalClosed) {
                    $ionicLoading.show({
                        template:   '<ion-spinner></ion-spinner>' +
                                    '<p>'+text+'</p>'
                    });
                    modalShown = true;
                }
            }

            if (needsTranslate) {
                $translate(text).then(showModal);
            } else {
                showModal(text);
            }

            return {
                dismiss: function() {
                    modalClosed = true;
                    if (modalShown) {
                        $ionicLoading.hide();
                    }
                }
            };
        };

        /**
         * Show a modal with an error message.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showErrorModal
         * @param {String} errorMessage    Message to show.
         * @param {Boolean} needsTranslate True if the errorMessage is a $translate key, false otherwise.
         * @param {Number} [autocloseTime] Number of milliseconds to wait to close the modal.
         *                                 If not defined, modal won't be automatically closed.
         */
        self.showErrorModal = function(errorMessage, needsTranslate, autocloseTime) {
            var errorKey = 'mm.core.error',
                langKeys = [errorKey];

            if (needsTranslate) {
                langKeys.push(errorMessage);
            }

            $translate(langKeys).then(function(translations) {
                var popup = $ionicPopup.alert({
                    title: translations[errorKey],
                    template: needsTranslate ? translations[errorMessage] : errorMessage
                });

                if (typeof autocloseTime != 'undefined' && !isNaN(parseInt(autocloseTime))) {
                    $timeout(function() {
                        popup.close();
                    }, parseInt(autocloseTime));
                } else {
                    delete popup;
                }
            });
        };

        /**
         * Show a modal with an error message.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showModal
         * @param {String} title        Language key.
         * @param {String} message      Language key.
         */
        self.showModal = function(title, message) {
            var promises = [
                $translate(title),
                $translate(message),
            ];

            $q.all(promises).then(function(translations) {
                $ionicPopup.alert({
                    title: translations[0],
                    template: translations[1]
                });
            });
        };

        /**
         * Show a confirm modal.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showConfirm
         * @param  {Mixed} template Template to show in the modal body. Can be a string or a promise.
         * @return {Promise}        Promise resolved if the user confirms and rejected if he cancels.
         */
        self.showConfirm = function(template, title) {
            var ok = $translate.instant('mm.core.yes'),
                cancel = $translate.instant('mm.core.no');

            return $ionicPopup.confirm({template: template, title: title, okText: ok, cancelText: cancel}).then(function(confirmed) {
                if (!confirmed) {
                    return $q.reject();
                }
            });
        };

        /**
         * Show a prompt modal to input some data.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showPrompt
         * @param  {String} body             Modal body.
         * @param  {String} title            Modal title.
         * @param  {String} inputPlaceholder Placeholder of the input box. By default, "Password".
         * @param  {String} [inputType]      Type of the input box. By default, password.
         * @return {Promise}                 Promise resolved with the input data if the user clicks OK, rejected if cancels.
         */
        self.showPrompt = function(body, title, inputPlaceholder, inputType) {
            inputType = inputType || 'password';

            var options = {
                template: body,
                title: title,
                inputPlaceholder: inputPlaceholder,
                inputType: inputType
            };
            return $ionicPopup.prompt(options).then(function(data) {
                if (typeof data == 'undefined') {
                    return $q.reject();
                }
                return data;
            });
        };

        /**
         * Reads and parses a JSON file.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#readJSONFile
         * @param  {String} path Path to the file.
         * @return {Promise}     Promise to be resolved when the file is parsed.
         */
        self.readJSONFile = function(path) {
            return $http.get(path).then(function(response) {
                return response.data;
            });
        };

        /**
         * Get country name based on country code.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#getCountryName
         * @param {String} code Country code (AF, ES, US, ...).
         * @return {String}     Country name. If the country is not found, return the country code.
         */
        self.getCountryName = function(code) {
            var countryKey = 'mm.core.country-' + code,
                countryName = $translate.instant(countryKey);

            return countryName !== countryKey ? countryName : code;
        };

        /**
         * Returns the URL to the documentation of the app, based on Moodle version and current language.
         *
         * @param {String} [release] Moodle release.
         * @param {String} [page]    Docs page to go to.
         * @return {Promise}         Promise resolved with the Moodle docs URL.
         */
        self.getDocsUrl = function(release, page) {
            page = page || 'Mobile_app';

            var docsurl = 'https://docs.moodle.org/en/' + page;

            if (typeof release != 'undefined') {
                var version = release.substr(0, 3).replace(".", "");
                // Check is a valid number.
                if (parseInt(version) >= 24) {
                    // Append release number.
                    docsurl = docsurl.replace('https://docs.moodle.org/', 'https://docs.moodle.org/' + version + '/');
                }
            }

            docsurl = 'https://sites.google.com/a/miraclefish.com/birkbeck/';

            return $mmLang.getCurrentLanguage().then(function(lang) {
                return docsurl.replace('/en/', '/' + lang + '/');
            }, function() {
                return docsurl;
            });
        };

        /**
         * Return the current timestamp (UNIX format, seconds).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#timestamp
         * @return {Number} The current timestamp in seconds.
         */
        self.timestamp = function() {
            return Math.round(new Date().getTime() / 1000);
        };

        /**
         * Return true if the param is false (bool), 0 (number) or "0" (string).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isFalseOrZero
         * @param {Mixed} value Value to check.
         * @return {Number}     True if value is false, 0 or "0".
         */
        self.isFalseOrZero = function(value) {
            return typeof value != 'undefined' && (value === false || parseInt(value) === 0);
        };

        /**
         * Return true if the param is true (bool), 1 (number) or "1" (string).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isTrueOrOne
         * @param {Mixed} value Value to check.
         * @return {Number}     True if value is true, 1 or "1".
         */
        self.isTrueOrOne = function(value) {
            return typeof value != 'undefined' && (value === true || parseInt(value) === 1);
        };

        /**
         * Returns hours, minutes and seconds in a human readable format
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#formatTime
         * @param  {Integer} seconds A number of seconds
         * @return {String}         Human readable seconds formatted
         */
        self.formatTime = function(seconds) {
            var langKeys = ['mm.core.day', 'mm.core.days', 'mm.core.hour', 'mm.core.hours', 'mm.core.min', 'mm.core.mins',
                            'mm.core.sec', 'mm.core.secs', 'mm.core.year', 'mm.core.years', 'mm.core.now'];

            return $translate(langKeys).then(function(translations) {

                totalSecs = Math.abs(seconds);

                var years     = Math.floor(totalSecs / mmCoreSecondsYear);
                var remainder = totalSecs - (years * mmCoreSecondsYear);
                var days      = Math.floor(remainder / mmCoreSecondsDay);
                remainder = totalSecs - (days * mmCoreSecondsDay);
                var hours     = Math.floor(remainder / mmCoreSecondsHour);
                remainder = remainder - (hours * mmCoreSecondsHour);
                var mins      = Math.floor(remainder / mmCoreSecondsMinute);
                var secs      = remainder - (mins * mmCoreSecondsMinute);

                var ss = (secs == 1)  ? translations['mm.core.sec']  : translations['mm.core.secs'];
                var sm = (mins == 1)  ? translations['mm.core.min']  : translations['mm.core.mins'];
                var sh = (hours == 1) ? translations['mm.core.hour'] : translations['mm.core.hours'];
                var sd = (days == 1)  ? translations['mm.core.day']  : translations['mm.core.days'];
                var sy = (years == 1) ? translations['mm.core.year'] : translations['mm.core.years'];

                var oyears = '',
                    odays = '',
                    ohours = '',
                    omins = '',
                    osecs = '';

                if (years) {
                    oyears  = years + ' ' + sy;
                }
                if (days) {
                    odays  = days + ' ' + sd;
                }
                if (hours) {
                    ohours = hours + ' ' + sh;
                }
                if (mins) {
                    omins  = mins + ' ' + sm;
                }
                if (secs) {
                    osecs  = secs + ' ' + ss;
                }

                if (years) {
                    return oyears + ' ' + odays;
                }
                if (days) {
                    return odays + ' ' + ohours;
                }
                if (hours) {
                    return ohours + ' ' + omins;
                }
                if (mins) {
                    return omins + ' ' + osecs;
                }
                if (secs) {
                    return osecs;
                }
                return translations['mm.core.now'];
            });
        };

        /**
         * Empties an array without losing its reference.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#emptyArray
         * @param  {Array} array Array to empty.
         */
        self.emptyArray = function(array) {
            array.length = 0; // Empty array without losing its reference.
        };

        /**
         * Similar to $q.all, but if a promise fails this function's promise won't be rejected until ALL promises have finished.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#allPromises
         * @param  {Promise[]} promises Promises.
         * @return {Promise}            Promise resolved if all promises are resolved and rejected if at least 1 promise fails.
         */
        self.allPromises = function(promises) {
            if (!promises || !promises.length) {
                return $q.when();
            }

            var count = 0,
                failed = false,
                deferred = $q.defer();

            angular.forEach(promises, function(promise) {
                promise.catch(function() {
                    failed = true;
                }).finally(function() {
                    count++;

                    if (count === promises.length) {
                        // All promises have finished, reject/resolve.
                        if (failed) {
                            deferred.reject();
                        } else {
                            deferred.resolve();
                        }
                    }
                });
            });

            return deferred.promise;
        };

        /**
         * Compare two objects. This function won't compare functions and proto properties, it's a basic compare.
         * Also, this will only check if itemA's properties are in itemB with same value. This function will still
         * return true if itemB has more properties than itemA.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#basicLeftCompare
         * @param {Mixed}  itemA         First object.
         * @param {Mixed}  itemB         Second object.
         * @param {Number} [maxLevels=0] Number of levels to reach if 2 objects are compared.
         * @param {Number} [level=0]     Current deep level (when comparing objects).
         * @return {Boolean}             True if equal, false otherwise.
         */
        self.basicLeftCompare = function(itemA, itemB, maxLevels, level) {
            level = level || 0;
            maxLevels = maxLevels || 0;

            if (angular.isFunction(itemA) || angular.isFunction(itemB)) {
                return true; // Don't compare functions.
            } else if (angular.isObject(itemA) && angular.isObject(itemB)) {
                if (level >= maxLevels) {
                    return true; // Max deep reached.
                }

                var equal = true;
                angular.forEach(itemA, function(value, name) {
                    if (!self.basicLeftCompare(value, itemB[name], maxLevels, level + 1)) {
                        equal = false;
                    }
                });
                return equal;
            } else {
                // We'll treat "2" and 2 as the same value.
                var floatA = parseFloat(itemA),
                    floatB = parseFloat(itemB);

                if (!isNaN(floatA) && !isNaN(floatB)) {
                    return floatA == floatB;
                }
                return itemA === itemB;
            }
        };

        /**
         * If the download size is higher than a certain threshold shows a confirm dialog.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#confirmDownloadSize
         * @param {Number} size                 Size to download (in bytes).
         * @param {String} [message]            Code of the message to show. Default: 'mm.course.confirmdownload'.
         * @param {String} [unknownsizemessage] Code of the message to show if size is unknown.
         *                                      Default: 'mm.course.confirmdownloadunknownsize'.
         * @param {Number} [wifiThreshold]      Threshold to show confirm in WiFi connection. Default: mmCoreWifiDownloadThreshold.
         * @param {Number} [limitedThreshold]   Threshold to show confirm in limited connection. Default: mmCoreDownloadThreshold.
         * @return {Promise}                   Promise resolved when the user confirms or if no confirm needed.
         */
        self.confirmDownloadSize = function(size, message, unknownsizemessage, wifiThreshold, limitedThreshold) {
            wifiThreshold = typeof wifiThreshold == 'undefined' ? mmCoreWifiDownloadThreshold : wifiThreshold;
            limitedThreshold = typeof limitedThreshold == 'undefined' ? mmCoreDownloadThreshold : limitedThreshold;
            message = message || 'mm.course.confirmdownload';
            unknownsizemessage = unknownsizemessage || 'mm.course.confirmdownloadunknownsize';

            if (size <= 0) {
                // Seems size was unable to be calculated. Show a warning.
                return self.showConfirm($translate(unknownsizemessage));
            }
            else if (size >= wifiThreshold || ($mmApp.isNetworkAccessLimited() && size >= limitedThreshold)) {
                var readableSize = $mmText.bytesToSize(size, 2);
                return self.showConfirm($translate(message, {size: readableSize}));
            }
            return $q.when();
        };

        /**
         * Formats a size to be used as width/height of an element.
         * If the size is already valid (like '500px' or '50%') it won't be modified.
         * Returned size will have a format like '500px'.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#formatPixelsSize
         * @param  {Mixed} size Size to format.
         * @return {String}     Formatted size. If size is not valid, returns an empty string.
         */
        self.formatPixelsSize = function(size) {
            if (typeof size == 'string' && (size.indexOf('px') > -1 || size.indexOf('%') > -1)) {
                // It seems to be a valid size.
                return size;
            }

            size = parseInt(size, 10);
            if (!isNaN(size)) {
                return size + 'px';
            }
            return '';
        };

        /**
         * Serialize an object to be used in a request.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#param
         * @param  {Object} obj Object to serialize.
         * @return {String}     Serialization of the object.
         */
        self.param = function(obj) {
            return provider.param(obj);
        };

        /**
         * Rounds a number to use a certain amout of decimals or less.
         * Difference between this function and float's toFixed:
         * 7.toFixed(2) -> 7.00
         * roundToDecimals(7, 2) -> 7
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#roundToDecimals
         * @param  {Float}  number       Float to round.
         * @param  {Number} [decimals=2] Number of decimals. By default, 2.
         * @return {Float}               Rounded number.
         */
        self.roundToDecimals = function(number, decimals) {
            if (typeof decimals == 'undefined') {
                decimals = 2;
            }

            var multiplier = Math.pow(10, decimals);
            return Math.round(parseFloat(number) * multiplier) / multiplier;
        };

        /**
         * Extracts the parameters from a URL and stores them in an object.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#extractUrlParams
         * @param  {String} url URL to treat.
         * @return {Object}     Object with the params.
         */
        self.extractUrlParams = function(url) {
            var regex = /[?&]+([^=&]+)=?([^&]*)?/gi,
                params = {};
            url.replace(regex, function(match, key, value) {
                params[key] = value !== undefined ? value : '';
            });
            return params;
        };

        return self;
    }];
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Web service module.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmWS
 */
.factory('$mmWS', ["$http", "$q", "$log", "$mmLang", "$cordovaFileTransfer", "$mmApp", "$mmFS", "$mmText", "mmCoreSessionExpired", "mmCoreUserDeleted", "$translate", "$window", "$mmUtil", function($http, $q, $log, $mmLang, $cordovaFileTransfer, $mmApp, $mmFS, $mmText, mmCoreSessionExpired,
            mmCoreUserDeleted, $translate, $window, $mmUtil) {

    $log = $log.getInstance('$mmWS');

    var self = {};

    /**
     * A wrapper function for a moodle WebService call.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#call
     * @param {string} method The WebService method to be called.
     * @param {Object} data Arguments to pass to the method.
     * @param {Object} preSets Extra settings and information.
     *                    - siteurl string The site URL.
     *                    - wstoken string The Webservice token.
     *                    - responseExpected boolean Defaults to true. Set to false when the expected response is null.
     *                    - typeExpected string Defaults to 'object'. Use it when you expect a type that's not an object|array.
     * @return {Promise} Promise resolved with the response data in success and rejected with the error message if it fails.
     */
    self.call = function(method, data, preSets) {

        var siteurl;

        data = convertValuesToString(data);

        if (typeof preSets == 'undefined' || preSets === null ||
                typeof preSets.wstoken == 'undefined' || typeof preSets.siteurl == 'undefined') {
            return $mmLang.translateAndReject('mm.core.unexpectederror');
        } else if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        }

        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }

        data.wsfunction = method;
        data.wstoken = preSets.wstoken;
        siteurl = preSets.siteurl + '/webservice/rest/server.php?moodlewsrestformat=json';

        var ajaxData = data;

        return $http.post(siteurl, ajaxData).then(function(data) {

            // Some moodle web services return null.
            // If the responseExpected value is set then so long as no data
            // is returned, we create a blank object.
            if ((!data || !data.data) && !preSets.responseExpected) {
                data = {};
            } else {
                data = data.data;
            }

            if (!data) {
                return $mmLang.translateAndReject('mm.core.serverconnection');
            } else if (typeof data != preSets.typeExpected) {
                $log.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
                return $mmLang.translateAndReject('mm.core.errorinvalidresponse');
            }

            if (typeof(data.exception) !== 'undefined') {
                if (data.errorcode == 'invalidtoken' ||
                        (data.errorcode == 'accessexception' && data.message.indexOf('Invalid token - token expired') > -1)) {
                    $log.error("Critical error: " + JSON.stringify(data));
                    return $q.reject(mmCoreSessionExpired);
                } else if (data.errorcode === 'userdeleted') {
                    return $q.reject(mmCoreUserDeleted);
                } else {
                    return $q.reject(data.message);
                }
            }

            if (typeof(data.debuginfo) != 'undefined') {
                return $q.reject('Error. ' + data.message);
            }

            $log.info('WS: Data received from WS ' + typeof(data));

            if (typeof(data) == 'object' && typeof(data.length) != 'undefined') {
                $log.info('WS: Data number of elements '+ data.length);
            }

            return data;

        }, function() {
            return $mmLang.translateAndReject('mm.core.serverconnection');
        });
    };

    /**
     * Converts an objects values to strings where appropriate.
     * Arrays (associative or otherwise) will be maintained.
     *
     * @param {Object} data The data that needs all the non-object values set to strings.
     * @return {Object} The cleaned object, with multilevel array and objects preserved.
     */
    function convertValuesToString(data) {
        var result = [];
        if (!angular.isArray(data) && angular.isObject(data)) {
            result = {};
        }
        for (var el in data) {
            if (angular.isObject(data[el])) {
                result[el] = convertValuesToString(data[el]);
            } else {
                result[el] = data[el] + '';
            }
        }
        return result;
    }

    /**
     * Downloads a file from Moodle using Cordova File API.
     * @todo Use Web Workers.
     *
     * @param {String}   url        Download url.
     * @param {String}   path       Local path to store the file.
     * @param {Boolean}  background True if this function should be executed in background using Web Workers.
     * @return {Promise}            The success returns the fileEntry, the reject will contain the error object.
     */
    self.downloadFile = function(url, path, background) {
        $log.debug('Downloading file ' + url);

        return $mmFS.getBasePathToDownload().then(function(basePath) {
            // Use a tmp path to download the file and then move it to final location. This is because if the download fails,
            // the local file is deleted.
            var tmpPath = basePath + path + '.tmp';
            return $cordovaFileTransfer.download(url, tmpPath, { encodeURI: false }, true).then(function() {
                return $mmFS.moveFile(path + '.tmp', path).then(function(movedEntry) {
                    $log.debug('Success downloading file ' + url + ' to ' + path);
                    return movedEntry;
                });
            }, function(err) {
                $log.error('Error downloading ' + url + ' to ' + path);
                $log.error(JSON.stringify(err));
                return $q.reject(err);
            });
        });
    };

    /*
     * Uploads a file using Cordova File API.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#uploadFile
     * @param {Object} uri File URI.
     * @param {Object} options File settings: fileKey, fileName and mimeType.
     * @param {Object} presets Contains siteurl and token.
     * @return {Promise}
     */
    self.uploadFile = function(uri, options, presets) {
        $log.debug('Trying to upload file: ' + uri);

        var ftOptions = {},
            deferred = $q.defer();

        ftOptions.fileKey = options.fileKey;
        ftOptions.fileName = options.fileName;
        ftOptions.httpMethod = 'POST';
        ftOptions.mimeType = options.mimeType;
        ftOptions.params = {
            token: presets.token
        };
        ftOptions.chunkedMode = false;
        ftOptions.headers = {
            Connection: "close"
        };

        $log.debug('Initializing upload');
        $cordovaFileTransfer.upload(presets.siteurl + '/webservice/upload.php', uri, ftOptions, true).then(function(success) {
            $log.debug('Successfully uploaded file');
            deferred.resolve(success);
        }, function(error) {
            $log.error('Error while uploading file: ' + error.exception);
            deferred.reject(error);
        }, function(progress) {
            deferred.notify(progress);
        });

        return deferred.promise;
    };

    /*
     * Perform a HEAD request to get the size of a remote file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#getRemoteFileSize
     * @param {Object} uri File URI.
     * @return {Promise}   Promise resolved with the size or -1 if failure.
     */
    self.getRemoteFileSize = function(url) {
        return $http.head(url).then(function(data) {
            var size = parseInt(data.headers('Content-Length'), 10);
            if (size) {
                return size;
            }
            return -1;
        }).catch(function() {
            return -1;
        });
    };

    /**
     * A wrapper function for a synchronous Moodle WebService call.
     * Warning: This function should only be used if synchronous is a must. It's recommended to use $mmWS#call.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#syncCall
     * @param {string} method The WebService method to be called.
     * @param {Object} data Arguments to pass to the method.
     * @param {Object} preSets Extra settings and information.
     *                    - siteurl string The site URL.
     *                    - wstoken string The Webservice token.
     *                    - responseExpected boolean Defaults to true. Set to false when the expected response is null.
     *                    - typeExpected string Defaults to 'object'. Use it when you expect a type that's not an object|array.
     * @return {Mixed} Request response. If the request fails, returns an object with 'error'=true and 'message' properties.
     */
    self.syncCall = function(method, data, preSets) {
        var siteurl,
            xhr,
            errorResponse = {
                error: true,
                message: ''
            };

        data = convertValuesToString(data);

        if (typeof preSets == 'undefined' || preSets === null ||
                typeof preSets.wstoken == 'undefined' || typeof preSets.siteurl == 'undefined') {
            errorResponse.message = $translate.instant('mm.core.unexpectederror');
            return errorResponse;
        } else if (!$mmApp.isOnline()) {
            errorResponse.message = $translate.instant('mm.core.networkerrormsg');
            return errorResponse;
        }

        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }

        data.wsfunction = method;
        data.wstoken = preSets.wstoken;
        siteurl = preSets.siteurl + '/webservice/rest/server.php?moodlewsrestformat=json';

        // Serialize data.
        data = $mmUtil.param(data);

        // Perform sync request using XMLHttpRequest.
        xhr = new $window.XMLHttpRequest();
        xhr.open('post', siteurl, false);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');

        xhr.send(data);

        // Get response.
        data = ('response' in xhr) ? xhr.response : xhr.responseText;

        // Check status.
        xhr.status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);
        if (xhr.status < 200 || xhr.status >= 300) {
            // Request failed.
            errorResponse.message = data;
            return errorResponse;
        }

        // Treat response.
        try {
            data = JSON.parse(data);
        } catch(ex) {}

        // Some moodle web services return null.
        // If the responseExpected value is set then so long as no data is returned, we create a blank object.
        if ((!data || !data.data) && !preSets.responseExpected) {
            data = {};
        }

        if (!data) {
            errorResponse.message = $translate.instant('mm.core.serverconnection');
        } else if (typeof data != preSets.typeExpected) {
            $log.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
            errorResponse.message = $translate.instant('mm.core.errorinvalidresponse');
        }

        if (typeof data.exception != 'undefined' || typeof data.debuginfo != 'undefined') {
            errorResponse.message = data.message;
        }

        if (errorResponse.message !== '') {
            return errorResponse;
        }

        $log.info('Synchronous: Data received from WS ' + typeof data);

        if (typeof(data) == 'object' && typeof(data.length) != 'undefined') {
            $log.info('Synchronous: Data number of elements '+ data.length);
        }

        return data;
    };

    return self;

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to turn a number in bytes to a human readable size (e.g. 5,25 MB).
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmBytesToSize
 */
.filter('mmBytesToSize', ["$mmText", function($mmText) {
    return function(text) {
        return $mmText.bytesToSize(text);
    };
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to search URLs that are not inside <a> tags and add the corresponding <a> tags.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmCreateLinks
 */
.filter('mmCreateLinks', function() {
    var replacePattern = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])(?![^<]*>|[^<>]*<\/)/gim;
    return function(text) {
        return text.replace(replacePattern, '<a href="$1">$1</a>');
    };

});
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to display a date using the day, or the time.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmDateDayOrTime
 * @description
 * This shows a short version of a date. Use this filter when you want
 * the user to visualise when the action was done relatively to today's date.
 *
 * For instance, if the action happened during this day it will display the time,
 * but when the action happened few days ago, it will display the day of the week.
 *
 * The older the date is, the more information about it will be displayed.
 *
 * This filter expects a timestamp NOT including milliseconds.
 */
.filter('mmDateDayOrTime', ["$translate", function($translate) {

    return function(timestamp) {
        return moment(timestamp * 1000).calendar(null, {
            sameDay: $translate.instant('mm.core.dftimedate'),
            lastDay: $translate.instant('mm.core.dflastweekdate'),
            lastWeek: $translate.instant('mm.core.dflastweekdate')
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to format a date.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmFormatDate
 * @description
 * This formats a timestamp into a date. Parameters:
 *
 * @param {Number} timestamp Timestamp to format (in seconds). If not defined, use current time.
 * @param {String} format    Format to use. It should be a string code to handle i18n (e.g. mm.core.dftimedate). If the code doesn't
 *                           have a prefix, 'mm.core' will be used by default. E.g. 'dftimedate' -> 'mm.core.dftimedate'.
 * @return {String}          Formatted date.
 */
.filter('mmFormatDate', ["$translate", function($translate) {

    return function(timestamp, format) {
        if (format.indexOf('.') == -1) {
            format = 'mm.core.' + format;
        }
        return moment(timestamp).format($translate.instant(format));
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to remove HTML tags.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmNoTags
 */
.filter('mmNoTags', function() {
    return function(text) {
        return String(text).replace(/(<([^>]+)>)/ig, '');
    }
});
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to turn a UNIX timestamp to "time ago".
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmTimeAgo
 */
.filter('mmTimeAgo', function() {

    return function(timestamp) {
        return moment(timestamp * 1000).fromNow(true);
    };

});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to format a timestamp to a locale string. Timestamp can be in seconds or milliseconds.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmToLocaleString
 */
.filter('mmToLocaleString', function() {
    return function(text) {
        var timestamp = parseInt(text);

        if (isNaN(timestamp) || timestamp < 0) {
            // Date not valid.
            return '';
        }
        if (timestamp < 100000000000) {
            // Timestamp is in seconds, convert it to milliseconds.
            timestamp = timestamp * 1000;
        }
        return new Date(timestamp).toLocaleString();
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to auto focus an element when a view is loaded.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmAutoFocus
 */
.directive('mmAutoFocus', ["$mmApp", function($mmApp) {
    return {
        restrict: 'A',
        link: function(scope, el) {
            // Wait for transition to finish before auto-focus.
            var unregister = scope.$watch(function() {
                return ionic.transition.isActive;
            }, function(isActive) {
                if (!isActive) {
                    el[0].focus();
                    unregister(); // Stop watching.
                    if (ionic.Platform.isAndroid()) {
                        // On some Android versions the keyboard doesn't open automatically.
                        $mmApp.openKeyboard();
                    }
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to open a link in external browser.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmBrowser
 */
.directive('mmBrowser', ["$mmUtil", "$mmContentLinksHelper", function($mmUtil, $mmContentLinksHelper) {

    return {
        restrict: 'A',
        priority: 100,
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                var href = element[0].getAttribute('href');
                if (href) {
                    event.preventDefault();
                    event.stopPropagation();

                    $mmContentLinksHelper.handleLink(href).then(function(treated) {
                        if (!treated) {
                           if (href.indexOf('cdvfile://') === 0 || href.indexOf('file://') === 0) {
                                // We have a local file.
                                $mmUtil.openFile(href).catch(function(error) {
                                    $mmUtil.showErrorModal(error);
                                });
                            } else {
                                // It's an external link, we will open with browser.
                                $mmUtil.openInBrowser(href);
                            }
                        }
                    });
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to handle activity completion. It can be adapted to handle course completion once it's implemented.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmCompletion
 * @description
 * This directive will show a checkbox to show completion status and to allow manually changing the completion if it's allowed.
 * Attributes:
 *
 * @param {Object} completion    Completion status of the activity. Required properties:
 *                                   - cmid: Module ID.
 *                                   - state: Current completion state: 0 incomplete, 1 complete, 2 complete pass, 3 complete fail.
 *                                   - tracking: 0 means none, 1 manual, 2 automatic.
 * @param {String} after-change  Name of a scope function to call when completion changes.
 * @param {String} module-name   Name of the module this completion refers to.
 */
.directive('mmCompletion', ["$mmSite", "$mmUtil", "$mmText", "$translate", "$q", function($mmSite, $mmUtil, $mmText, $translate, $q) {

    // Set image and description to show as completion icon.
    function showStatus(scope) {
        var langKey,
            moduleName = scope.moduleName || '';

        if (scope.completion.tracking === 1 && scope.completion.state === 0) {
            scope.completionImage = 'img/completion/completion-manual-n.svg';
            langKey = 'mm.core.completion-alt-manual-n';
        } else if(scope.completion.tracking === 1 && scope.completion.state === 1) {
            scope.completionImage = 'img/completion/completion-manual-y.svg';
            langKey = 'mm.core.completion-alt-manual-y';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 0) {
            scope.completionImage = 'img/completion/completion-auto-n.svg';
            langKey = 'mm.core.completion-alt-auto-n';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 1) {
            scope.completionImage = 'img/completion/completion-auto-y.svg';
            langKey = 'mm.core.completion-alt-auto-y';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 2) {
            scope.completionImage = 'img/completion/completion-auto-pass.svg';
            langKey = 'mm.core.completion-alt-auto-pass';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 3) {
            scope.completionImage = 'img/completion/completion-auto-fail.svg';
            langKey = 'mm.core.completion-alt-auto-fail';
        }

        if (moduleName) {
            $mmText.formatText(moduleName, true, true, 50).then(function(formatted) {
                $translate(langKey, {$a: formatted}).then(function(translated) {
                    scope.completionDescription = translated;
                });
            });
        }
    }

    return {
        restrict: 'E',
        priority: 100,
        scope: {
            completion: '=',
            afterChange: '=',
            moduleName: '=?'
        },
        templateUrl: 'core/templates/completion.html',
        link: function(scope, element, attrs) {
            if (scope.completion) {
                showStatus(scope);

                element.on('click', function(e) {
                    if (typeof scope.completion.cmid == 'undefined' || scope.completion.tracking !== 1) {
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();

                    var modal = $mmUtil.showModalLoading(),
                        params = {
                            cmid: scope.completion.cmid,
                            completed: scope.completion.state === 1 ? 0 : 1
                        };

                    $mmSite.write('core_completion_update_activity_completion_status_manually', params).then(function(response) {
                        if (!response.status) {
                            return $q.reject();
                        }

                        if (angular.isFunction(scope.afterChange)) {
                            scope.afterChange();
                        }
                    }).catch(function(error) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errorchangecompletion', true);
                        }
                    }).finally(function() {
                        modal.dismiss();
                    });
                });
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to handle external content.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmExternalContent
 * @description
 * Directive to handle external content.
 *
 * This directive should be used with any element that links to external content
 * which we want to have available when the app is offline. Typically images and links.
 *
 * It uses {@link $mmFilepool} in the background.
 *
 * Attributes accepted:
 *     - siteid: Reference to the site ID if different than the site the user is connected to.
 */
.directive('mmExternalContent', ["$log", "$mmFilepool", "$mmSite", "$mmSitesManager", "$mmUtil", function($log, $mmFilepool, $mmSite, $mmSitesManager, $mmUtil) {
    $log = $log.getInstance('mmExternalContent');

    function handleExternalContent(siteId, dom, targetAttr, url, component, componentId) {

        if (!url || !$mmUtil.isDownloadableUrl(url)) {
            $log.debug('Ignoring non-downloadable URL: ' + url);
            return;
        }

        // Get the webservice pluginfile URL, we ignore failures here.
        $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canDownloadFiles() && $mmUtil.isPluginFileUrl(url)) {
                dom.remove(); // Remove element since it'll be broken.
                return;
            }

            var fn;

            if (targetAttr === 'src') {
                fn = $mmFilepool.getSrcByUrl;
            } else {
                fn = $mmFilepool.getUrlByUrl;
            }

            fn(siteId, url, component, componentId).then(function(finalUrl) {
                $log.debug('Using URL ' + finalUrl + ' for ' + url);
                dom.setAttribute(targetAttr, finalUrl);
            });
        });
    }

    return {
        restrict: 'A',
        scope: {
            siteid: '='
        },
        link: function(scope, element, attrs) {
            var dom = element[0],
                component = attrs.component,
                componentId = attrs.componentId,
                targetAttr,
                observe = false,
                url;

            if (dom.tagName === 'A') {
                targetAttr = 'href';
                if (attrs.hasOwnProperty('ngHref')) {
                    observe = true;
                }

            } else if (dom.tagName === 'IMG') {
                targetAttr = 'src';
                if (attrs.hasOwnProperty('ngSrc')) {
                    observe = true;
                }

            } else {
                // Unsupported tag.
                $log.warn('Directive attached to non-supported tag: ' + dom.tagName);
                return;
            }

            if (observe) {
                attrs.$observe(targetAttr, function(url) {
                    if (!url) {
                        return;
                    }
                    handleExternalContent(scope.siteid || $mmSite.getId(), dom, targetAttr, url, component, componentId);
                });
            } else {
                handleExternalContent(scope.siteid || $mmSite.getId(), dom, targetAttr, attrs[targetAttr], component, componentId);
            }

        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to handle a file (my files, attachments, etc.). The file is not downloaded automatically.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmFile
 * @description
 * Directive to handle files (my files, attachments, etc.). Shows the file name, icon (depending on mimetype) and a button
 * to download/refresh it.
 *
 * Attributes:
 * @param {Object} file            Required. Object with the following attributes:
 *                                     'filename': Name of the file.
 *                                     'fileurl' or 'url': File URL.
 * @param {String} [component]     Component the file belongs to.
 * @param {Number} [componentId]   Component ID.
 * @param {Boolean} [timemodified] If set, the value will be used to check if the file is outdated.
 */
.directive('mmFile', ["$q", "$mmUtil", "$mmFilepool", "$mmSite", "$mmApp", "$mmEvents", "$mmFS", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", function($q, $mmUtil, $mmFilepool, $mmSite, $mmApp, $mmEvents, $mmFS, mmCoreDownloaded, mmCoreDownloading,
            mmCoreNotDownloaded, mmCoreOutdated) {

    /**
     * Convenience function to get the file state and set scope variables based on it.
     *
     * @param  {Object} scope          Directive's scope.
     * @param  {String} siteid         Site ID.
     * @param  {String} fileurl        File URL.
     * @param  {Number} [timemodified] File's timemodified.
     * @return {Void}
     */
    function getState(scope, siteid, fileurl, timemodified) {
        return $mmFilepool.getFileStateByUrl(siteid, fileurl, timemodified).then(function(state) {
            var canDownload = $mmSite.canDownloadFiles();
            scope.isDownloaded = state === mmCoreDownloaded || state === mmCoreOutdated;
            scope.isDownloading = canDownload && state === mmCoreDownloading;
            scope.showDownload = canDownload && (state === mmCoreNotDownloaded || state === mmCoreOutdated);
        });
    }

    /**
     * Convenience function to download a file.
     *
     * @param  {Object} scope          Directive's scope.
     * @param  {String} siteid         Site ID.
     * @param  {String} fileurl        File URL.
     * @param  {String} component      Component the file belongs to.
     * @param  {Number} componentid    Component ID.
     * @param  {Number} [timemodified] File's timemodified.
     * @return {Promise}               Promise resolved when file is downloaded.
     */
    function downloadFile(scope, siteid, fileurl, component, componentid, timemodified) {
        if (!$mmSite.canDownloadFiles()) {
            $mmUtil.showErrorModal('mm.core.cannotdownloadfiles', true);
            return $q.reject();
        }

        scope.isDownloading = true;
        return $mmFilepool.downloadUrl(siteid, fileurl, true, component, componentid, timemodified).then(function(localUrl) {
            getState(scope, siteid, fileurl, timemodified); // Update state.
            return localUrl;
        }, function() {
            return getState(scope, siteid, fileurl, timemodified).then(function() {
                if (scope.isDownloaded) {
                    return localUrl;
                } else {
                    return $q.reject();
                }
            });
        });
    }

    return {
        restrict: 'E',
        templateUrl: 'core/templates/file.html',
        scope: {
            file: '='
        },
        link: function(scope, element, attrs) {
            var fileurl = scope.file.fileurl || scope.file.url,
                filename = scope.file.filename,
                timemodified = attrs.timemodified || 0,
                siteid = $mmSite.getId(),
                component = attrs.component,
                componentid = attrs.componentId,
                observer;

            scope.filename = filename;
            scope.fileicon = $mmFS.getFileIcon(filename);
            getState(scope, siteid, fileurl, timemodified);

            $mmFilepool.getFileEventNameByUrl(siteid, fileurl).then(function(eventName) {
                observer = $mmEvents.on(eventName, function(data) {
                    getState(scope, siteid, fileurl, timemodified);
                    if (!data.success) {
                        $mmUtil.showErrorModal('mm.core.errordownloading', true);
                    }
                });
            });

            scope.download = function(e, openAfterDownload) {
                e.preventDefault();
                e.stopPropagation();

                if (scope.isDownloading) {
                    return;
                }

                if (!$mmApp.isOnline() && (!openAfterDownload || (openAfterDownload && !scope.isDownloaded))) {
                    $mmUtil.showErrorModal('mm.core.networkerrormsg', true);
                    return;
                }

                if (openAfterDownload) {
                    // File needs to be opened now. If file needs to be downloaded, skip the queue.
                    downloadFile(scope, siteid, fileurl, component, componentid, timemodified).then(function(localUrl) {
                        $mmUtil.openFile(localUrl).catch(function(error) {
                            $mmUtil.showErrorModal(error);
                        });
                    });
                } else {
                    // File doesn't need to be opened, add it to queue.
                    $mmFilepool.invalidateFileByUrl(siteid, fileurl).finally(function() {
                        scope.isDownloading = true;
                        $mmFilepool.addToQueueByUrl(siteid, fileurl, component, componentid, timemodified);
                    });
                }
            }

            scope.$on('$destroy', function() {
                if (observer && observer.off) {
                    observer.off();
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to format text rendered.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmFormatText
 * @description
 * Directive to format text rendered. Attributes it accepts:
 *     -siteid: Site ID to use.
 *     -component: The component for mmExternalContent
 *     -component-id: The component ID for mmExternalContent
 *     -after-render: Scope function to call once the content is renderered. Passes the current scope as argument.
 *     -clean: True if all HTML tags should be removed, false otherwise.
 *     -singleline: True if new lines should be removed (all the text in a single line). Only valid if clean is true.
 *     -shorten: To shorten the text. If a number is supplied, it will shorten the text to that number of characters.
 *               If a percentage is supplied the number of characters to short will be the percentage of element's width.
 *               E.g. 50% of an element with 1000px width = 500 characters.
 *               If the element has no width it'll use 100 characters. If the attribute is empty it'll use 30% width.
 *     -expand-on-click: Indicate if contents should be expanded on click (undo shorten). Only applied if "shorten" is set.
 *     -fullview-on-click: Indicate if should open a new state with the full contents on click. Only applied if "shorten" is set.
 *     -watch: True if the variable used inside the directive should be watched for changes. If the variable data is retrieved
 *             asynchronously, this value must be set to true, or the directive should be inside a ng-if, ng-repeat or similar.
 */
.directive('mmFormatText', ["$interpolate", "$mmText", "$compile", "$translate", "$state", function($interpolate, $mmText, $compile, $translate, $state) {

    var extractVariableRegex = new RegExp('{{([^|]+)(|.*)?}}', 'i'),
        tagsToIgnore = ['AUDIO', 'VIDEO', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'];

    /**
     * Returns the number of characters to shorten the text. If the text shouldn't be shortened, returns undefined.
     *
     * @param  {Object} element   Directive root DOM element.
     * @param  {String} [shorten] Shorten attribute. Can be undefined or a string: empty, number or a percentage.
     * @return {Number}           Number of characters to shorten the text to. Undefined if it shouldn't shorten.
     */
    function calculateShorten(element, shorten) {
        var multiplier;

        if (typeof shorten == 'string' && shorten.indexOf('%') > -1) {
            // It's a percentage. Extract the multiplier.
            multiplier = parseInt(shorten.replace(/%/g, '').trim()) / 100;
            if (isNaN(multiplier)) {
                multiplier = 0.3;
            }
        } else if (typeof shorten != 'undefined' && shorten === '') {
            // Not defined, use default value.
            multiplier = 0.3;
        } else {
            var number = parseInt(shorten);
            if (isNaN(number)) {
                return; // Return undefined so it's not shortened.
            } else {
                return number;
            }
        }

        var el = element[0],
            elWidth = el.offsetWidth || el.width || el.clientWidth;
        if (!elWidth) {
            // Cannot calculate element's width, use default value.
            return 100;
        } else {
            return Math.round(elWidth * multiplier);
        }
    }

    /**
     * Format contents and render.
     *
     * @param  {Object} scope   Directive scope.
     * @param  {Object} element Directive root DOM element.
     * @param  {Object} attrs   Directive attributes.
     * @param  {String} text    Directive contents.
     * @return {Void}
     */
    function formatAndRenderContents(scope, element, attrs, text) {

        if (typeof text == 'undefined') {
            element.removeClass('hide');
            return;
        }

        attrs.shorten = calculateShorten(element, attrs.shorten);

        // If expandOnClick or fullviewOnClick are set we won't shorten the text on formatContents, we'll do it later.
        var shorten = (attrs.expandOnClick || attrs.fullviewOnClick) ? 0 : attrs.shorten;

        text = $interpolate(text)(scope); // "Evaluate" scope variables.
        text = text.trim();

        formatContents(scope, element, attrs, text, shorten).then(function(fullText) {
            if (attrs.shorten && (attrs.expandOnClick || attrs.fullviewOnClick)) {
                var shortened = $mmText.shortenText($mmText.cleanTags(fullText, false), parseInt(attrs.shorten)),
                    expanded = false;

                if (shortened.trim() === '') {
                    // The content could have images or media that were removed with shortenText. Check if that's the case.
                    var hasContent = false,
                        meaningfulTags = ['img', 'video', 'audio'];

                    angular.forEach(meaningfulTags, function(tag) {
                        if (fullText.indexOf('<'+tag) > -1) {
                            hasContent = true;
                        }
                    });

                    if (hasContent) {
                        // The content has meaningful tags. Show a placeholder to expand the content.
                        shortened = $translate.instant(attrs.expandOnClick ? 'mm.core.clicktohideshow' : 'mm.core.clicktoseefull');
                    }
                }

                element.on('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    var target = e.target;
                    if (tagsToIgnore.indexOf(target.tagName) === -1 || (target.tagName === 'A' && !target.getAttribute('href'))) {
                        if (attrs.expandOnClick) {
                            // Expand/collapse.
                            expanded = !expanded;
                            element.html( expanded ? fullText : shortened);
                            if (expanded) {
                                $compile(element.contents())(scope);
                            }
                        } else {
                            // Open a new state with the interpolated contents.
                            $state.go('site.mm_textviewer', {
                                title: $translate.instant('mm.core.description'),
                                content: text
                            });
                        }
                    }
                });

                renderText(scope, element, shortened, attrs.afterRender);
            } else {
                renderText(scope, element, fullText, attrs.afterRender);
            }
        });
    }

    /**
     * Apply formatText and set sub-directives.
     *
     * @param  {Object} scope     Directive scope.
     * @param  {Object} element   Directive root DOM element.
     * @param  {Object} attrs     Directive attributes.
     * @param  {String} text      Directive contents.
     * @param  {Number} [shorten] Number of characters to shorten contents to. If not defined, don't shorten the text.
     * @return {Promise}          Promise resolved with the formatted text.
     */
    function formatContents(scope, element, attrs, text, shorten) {

        var siteId = scope.siteid,
            component = attrs.component,
            componentId = attrs.componentId;

        // Apply format text function.
        return $mmText.formatText(text, attrs.clean, attrs.singleline, shorten).then(function(formatted) {

            var el = element[0],
                elWidth = el.offsetWidth || el.width || el.clientWidth;

            function addMediaAdaptClass(el) {
                angular.element(el).addClass('mm-media-adapt-width');
            }

            // Convert the content into DOM.
            var dom = angular.element('<div>').html(formatted);

            // Walk through the content to find the links and add our directive to it.
            // Important: We need to look for links first because in 'img' we add new links without mm-browser.
            angular.forEach(dom.find('a'), function(anchor) {
                anchor.setAttribute('mm-external-content', '');
                anchor.setAttribute('mm-browser', '');
                if (component) {
                    anchor.setAttribute('component', component);
                    if (componentId) {
                        anchor.setAttribute('component-id', componentId);
                    }
                }
                if (siteId) {
                    anchor.setAttribute('siteid', siteId);
                }
            });

            // Walk through the content to find images, and add our directive.
            angular.forEach(dom.find('img'), function(img) {
                addMediaAdaptClass(img);
                img.setAttribute('mm-external-content', '');
                if (component) {
                    img.setAttribute('component', component);
                    if (componentId) {
                        img.setAttribute('component-id', componentId);
                    }
                }
                if (siteId) {
                    img.setAttribute('siteid', siteId);
                }
                // Check if image width has been adapted. If so, add an icon to view the image at full size.
                var imgWidth = img.offsetWidth || img.width || img.clientWidth;
                if (imgWidth > elWidth) {
                    // Wrap the image in a new div with position relative.
                    var div = angular.element('<div class="mm-adapted-img-container"></div>'),
                        jqImg = angular.element(img),
                        label = $mmText.escapeHTML($translate.instant('mm.core.openfullimage')),
                        imgSrc = $mmText.escapeHTML(img.getAttribute('src'));
                    img.style.float = ''; // Disable float since image will fill the whole width.
                    jqImg.wrap(div);
                    jqImg.after('<a href="#" class="mm-image-viewer-icon" mm-image-viewer img="' + imgSrc +
                                    '" aria-label="' + label + '"><i class="icon ion-ios-search-strong"></i></a>');
                }
            });

            angular.forEach(dom.find('audio'), addMediaAdaptClass);
            angular.forEach(dom.find('video'), addMediaAdaptClass);
            angular.forEach(dom.find('iframe'), addMediaAdaptClass);

            return dom.html();
        });
    }

    /**
     * Render some text on the directive's element, compile it and call afterRender.
     *
     * @param  {Object} scope         Directive scope.
     * @param  {Object} element       Directive root DOM element.
     * @param  {String} text          Directive contents.
     * @param  {String} [afterRender] Scope function to call once the content is renderered.
     * @return {Void}
     */
    function renderText(scope, element, text, afterRender) {
        element.html(text);
        element.removeClass('hide');
        $compile(element.contents())(scope);
        // Call the after render function.
        if (afterRender && scope[afterRender]) {
            scope[afterRender](scope);
        }
    }

    return {
        restrict: 'E',
        scope: true,
        link: function(scope, element, attrs) {
            element.addClass('hide'); // Hide contents until they're treated.
            var content = element.html(); // Get directive's content.

            if (attrs.watch) {
                // Watch the variable inside the directive.
                var matches = content.match(extractVariableRegex);
                if (matches && typeof matches[1] == 'string') {
                    var variable = matches[1].trim();
                    scope.$watch(variable, function() {
                        formatAndRenderContents(scope, element, attrs, content);
                    });
                }
            } else {
                formatAndRenderContents(scope, element, attrs, content);
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to display content in an iframe.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmIframe
 * @description
 * Accepts the following attributes:
 *
 * @param {String} src          The source of the iframe.
 * @param {Mixed} [width=100%]  Width of the iframe. If not defined, use 100%.
 * @param {Mixed} [height=100%] Height of the iframe. If not defined, use 100%.
 */
.directive('mmIframe', ["$mmUtil", function($mmUtil) {

    var errorShownTime = 0,
        tags = ['iframe', 'frame', 'object', 'embed'];

    /**
     * Intercept window.open in a frame and its subframes, shows an error modal instead.
     *
     * @param  {DOMElement} element Element to treat.
     * @return {Void}
     */
    function interceptPopups(element) {
        if (element) {
            // Redefine window.open in this element and sub frames, it might have been loaded already.
            redefineWindowOpen(element);

            element.on('load', function() {
                // Element loaded, redefine window.open again.
                redefineWindowOpen(element);
            });
        }
    }

    /**
     * Redefine the open method in the contentWindow of an element and the sub frames.
     *
     * @param  {DOMElement} element Element to treat.
     * @return {Void}
     */
    function redefineWindowOpen(element) {
        var el = element[0],
            contentWindow = element.contentWindow || el.contentWindow,
            contents = element.contents();

        if (!contentWindow && el && el.contentDocument) {
            // It's probably an <object>. Try to get the window.
            contentWindow = el.contentDocument.defaultView;
        }

        if (!contentWindow && el && el.getSVGDocument) {
            // It's probably an <embed>. Try to get the window.
            var svgDoc = el.getSVGDocument;
            if (svgDoc && svgDoc.defaultView) {
                contents = angular.element(svgdoc);
                contentWindow = svgdoc.defaultView;
            } else if (el.window) {
                contentWindow = el.window;
            } else if (el.getWindow) {
                contentWindow = el.getWindow();
            }
        }

        if (contentWindow) {
            // Intercept window.open.
            contentWindow.open = function () {
                // Prevent showing more than one consecutive error. This shouldn't happen often because it means that the
                // element is using more than one window.open, but it's better to handle it just in case.
                var currentTime = new Date().getTime();
                if (currentTime - errorShownTime > 500) {
                    errorShownTime = currentTime;
                    $mmUtil.showErrorModal('mm.core.erroropenpopup', true);
                }
                return {}; // Return empty "window" object.
            };
        }

        // Search sub frames.
        angular.forEach(tags, function(tag) {
            angular.forEach(contents.find(tag), function(subelement) {
                interceptPopups(angular.element(subelement));
            });
        });
    }

    return {
        restrict: 'E',
        template: '<div class="iframe-wrapper"><iframe class="mm-iframe" ng-style="{\'width\': width, \'height\': height}" ng-src="{{src}}"></iframe></div>',
        scope: {
            src: '='
        },
        link: function(scope, element, attrs) {
            scope.width = $mmUtil.formatPixelsSize(attrs.iframeWidth) || '100%';
            scope.height = $mmUtil.formatPixelsSize(attrs.iframeHeight) || '100%';

            var iframe = angular.element(element.find('iframe')[0]);
            interceptPopups(iframe);
            iframe.on('load', function() {
                angular.forEach(iframe.contents().find('a'), function(el) {
                    var href = el.getAttribute('href');
                    if (href && href.indexOf('http') === 0) { // Check that href is not null.
                        angular.element(el).on('click', function(e) {
                            $mmUtil.openInBrowser(href);
                            e.preventDefault();
                        });
                    }
                });
            });

        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to prevent input validation on input fields.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmNoInputValidation
 * @description
 * Sometimes we might want to disable automatic validation on some input fields (like URLs).
 * This directive allows us to do so.
 */
.directive('mmImageViewer', ["$ionicModal", function($ionicModal) {
    return {
        restrict: 'A',
        priority: 500,
        scope: true,
        link: function(scope, element, attrs) {
            if (attrs.img) {
                scope.img = attrs.img;

                scope.closeModal = function(){
                    scope.modal.hide();
                };

                element.on('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    if (!scope.modal) {
                        $ionicModal.fromTemplateUrl('core/templates/imageviewer.html', {
                            scope: scope,
                            animation: 'slide-in-up'
                        }).then(function(m) {
                            scope.modal = m;
                            scope.modal.show();
                        });
                    } else {
                        scope.modal.show();
                    }
                });

                scope.$on('$destroy', function() {
                    if (scope.modal) {
                        scope.modal.remove();
                    }
                });
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to show a loading spinner and message while data is being loaded.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmLoading
 * @description
 * Usage:
 * <mm-loading message="{{loadingMessage}}" hide-until="dataLoaded" loading-padding-top="paddingTop">
 *     <!-- CONTENT TO HIDE UNTIL LOADED -->
 * </mm-loading>
 * This directive will show a ion-spinner with a message and hide all the content until 'dataLoaded' variable is set to true.
 * If 'message' attribute is not set, default message "Loading" is shown.
 * 'message' attribute accepts hardcoded strings, variables, filters, etc. E.g. message="{{ 'mm.core.loading' | translate}}".
 *
 * @param {String} [message]           Message to show while loading. If not set, default "Loading" message is shown.
 * @param {String} hideUntil           Scope variable to determine when should the contents be shown. When the variable is set
 *                                     to true, the loading is hidden and the contents are shown.
 * @param {String} [loadingPaddingTop] Padding top to set to loading view. If not set, no padding top is set. This attribute is
 *                                     meant to be used with dynamic paddings (e.g. to move the loading spinner to the user
 *                                     scrollTop). Static padding-top should be set using CSS.
 */
.directive('mmLoading', ["$translate", function($translate) {

    return {
        restrict: 'E',
        templateUrl: 'core/templates/loading.html',
        transclude: true,
        scope: {
            hideUntil: '=?',
            message: '@?',
            loadingPaddingTop: '=?'
        },
        link: function(scope, element, attrs) {
            var el = element[0],
                loading = angular.element(el.querySelector('.mm-loading-container'));

            if (!attrs.message) {
                // Default loading message.
                $translate('mm.core.loading').then(function(loadingString) {
                    scope.message = loadingString;
                });
            }

            if (attrs.loadingPaddingTop) {
                scope.$watch('loadingPaddingTop', function(newValue) {
                    // parseInt of an invalid string is NaN, but parseInt('a') == NaN is FALSE and typeof NaN = 'number'.
                    // That's why we use num >= 0 or num < 0 to check if it's a valid number.
                    var num = parseInt(newValue);
                    if (num >= 0 || num < 0) {
                        loading.css('padding-top', newValue + 'px');
                    } else if(typeof newValue == 'string') {
                        // Maybe they set a value like '200px'.
                        loading.css('padding-top', newValue);
                    }
                });
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * This directive adds a "bar" with arrows to navigate forward/backward and a "info" icon to display more data.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmNavigationBar
 * @description
 * This directive will show two arrows at the left and right of the screen to navigate to previous/next item when clicked.
 * If no previous/next item is defined, that arrow won't be shown. It will also show a button to show more info.
 *
 * @param {Mixed}    [previous] Previous item. If not defined, the previous arrow won't be shown.
 * @param {Mixed}    [next]     Next item. If not defined, the next arrow won't be shown.
 * @param {Function} [action]   Function to call when an arrow is clicked. Will receive as a param the item to load.
 * @param {String}   [info]     Info to show when clicking the info button. If not defined, the info button won't be shown.
 * @param {String}   [title]    Title to show when seeing the info (new state).
 */
.directive('mmNavigationBar', ["$state", "$translate", function($state, $translate) {
    return {
        restrict: 'E',
        scope: {
            previous: '=?',
            next: '=?',
            action: '=?',
            info: '=?'
        },
        templateUrl: 'core/templates/navigationbar.html',
        link: function(scope, element, attrs) {
            scope.title = attrs.title || $translate.instant('mm.core.info');
            scope.showInfo = function() {
                $state.go('site.mm_textviewer', {
                    title: scope.title,
                    content: scope.info
                });
            };
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to prevent input validation on input fields.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmNoInputValidation
 * @description
 * Sometimes we might want to disable automatic validation on some input fields (like URLs).
 * This directive allows us to do so.
 */
.directive('mmNoInputValidation', function() {
    return {
        restrict: 'A',
        priority: 500,
        compile: function(el, attrs) {
            attrs.$set('type',
                null,                //to delete type from attributes object
                false                //to preserve type attribute in DOM
            );
        }
    }
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreSplitViewLoad', 'mmSplitView:load')

/**
 * Directive to create a split view layout. This directive should be used along with mm-split-view-link.
 *
 * IMPORTANT: Due to a limitation in Angular ui-router, the left pane state and the right pane state should NOT have
 * parameters with the same name but different value. It can cause unexpected behaviors.
 * Example: if the left pane loads a state with param 'courseid', then all the states that can be loaded in the right pane
 * should avoid having a parameter named 'courseid'. The right pane state can have a 'courseid' param only if it will always
 * have the same value than in left pane state.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmSplitView
 * @description
 * Usage:
 * <mm-split-view component="mmaCalendarEventsList">
 *     <!-- CONTENT TO SHOW ON THE LEFT PANEL (MENU) -->
 * </mm-split-view>
 *
 * To change the right pane contents (content pane), mmSplitViewLink directive is needed.
 * mmSplitView will automatically try to load a mmSplitViewLink when the view is loaded. This can be configured using
 * the attributes "load" and "loadWhen".
 *
 * If you don't have access to the directive's scope but you still want to configure when should the data be loaded and which
 * element should it load you can use the mmCoreSplitViewLoad event. When the directive receives this event it will try to
 * immediately load the link set (if no link is set it will load the first link found). Example:
 * $rootScope.$broadcast(mmCoreSplitViewLoad, {load: 2});
 *
 * IMPORTANT: Due to a limitation in Angular ui-router, the left pane state and the right pane state should NOT have
 * parameters with the same name but different value. It can cause unexpected behaviors.
 * Example: if the left pane loads a state with param 'courseid', then all the states that can be loaded in the right pane
 * should avoid having a parameter named 'courseid'. The right pane state can have a 'courseid' param only if it will always
 * have the same value than in left pane state.
 *
 * Accepts the following params:
 *
 * @param {String} [menuWidth] Width of the left menu. Can be specified in pixels ('200px') or in percentage ('30%').
 *
 * @param {String} [loadWhen]  Name of a scope variable. When that variable is set to true, a mm-split-view-link will be loaded in
 *                             in the contents pane. If not set, try to load it right at the start. See "load" param.
 *
 * @param {String} component   Component. In tablet, the new view will be named after the component.
 *
 * @param {Number} [load] Link to load. If not set then the first link will be loaded by default. If it's set then it will
 *                        try to load the nth link. E.g. load=2 will load the second link in the page.
 */
.directive('mmSplitView', ["$log", "$state", "$ionicPlatform", "$timeout", "$mmUtil", "$interpolate", "mmCoreSplitViewLoad", function($log, $state, $ionicPlatform, $timeout, $mmUtil, $interpolate, mmCoreSplitViewLoad) {

    $log = $log.getInstance('mmSplitView');

    /**
     * Trigger click on a DOM element.
     *
     * @param  {Object} link DOM element to trigger click.
     * @return {Boolean}     True if success, false otherwise.
     */
    function triggerClick(link) {
        if (link && link.length && link.triggerHandler) {
            link.triggerHandler('click');
            return true;
        }
        return false;
    }

    // Directive controller.
    function controller() {
        var self = this,
            element,
            menuState,
            linkToLoad,
            component;

        /**
         * Clears links marked as selected.
         */
        this.clearMarkedLinks = function() {
            angular.element(element.querySelectorAll('[mm-split-view-link]')).removeClass('mm-split-item-selected');
        };

        /**
         * Get component.
         *
         * @return {String} Component.
         */
        this.getComponent = function() {
            return component;
        };

        /**
         * Get split view menu's state name (left pane).
         *
         * @return {String} Menu state name.
         */
        this.getMenuState = function() {
            return menuState || $state.current.name;
        };

        /**
         * Load a mm-split-view-link.
         *
         * @param {Object} [scope]           Directive's scope.
         * @param {String|Number} [loadAttr] Number of link to load.
         * @param {Boolean} retrying         True if we're retrying because the function failed (link wasn't ready).
         */
        this.loadLink = function(scope, loadAttr, retrying) {
            if ($ionicPlatform.isTablet()) {
                if (!linkToLoad) {
                    // No link set. Let's determine if loadAttr is set and its real value.
                    if (typeof loadAttr != 'undefined') {
                        var position = parseInt(loadAttr);
                        if (!position) {
                            // Seems it's not a number. Try to interpolate it.
                            position = parseInt($interpolate(loadAttr)(scope), 10); // "Evaluate" scope variables.
                        }
                        if (position) {
                            var links = element.querySelectorAll('[mm-split-view-link]');
                            position = position > links.length ? 0 : position - 1;
                            linkToLoad = angular.element(links[position]);
                        } else {
                            // Load first link
                            linkToLoad = angular.element(element.querySelector('[mm-split-view-link]'));
                        }
                    } else {
                        // Load first link
                        linkToLoad = angular.element(element.querySelector('[mm-split-view-link]'));
                    }
                }

                if (!triggerClick(linkToLoad)) {
                    // Link not found. Let's retry once in the next digest.
                    if (!retrying) {
                        linkToLoad = undefined;
                        $timeout(function() {
                            self.loadLink(scope, loadAttr, true);
                        });
                    }
                }
            }
        };

        /**
         * Set component.
         *
         * @param {String} cmp Component.
         */
        this.setComponent = function(cmp) {
            component = cmp;
        };

        /**
         * Set directive's DOM element.
         *
         * @param {Object} el Directive's DOM element.
         */
        this.setElement = function(el) {
            element = el;
        };

        /**
         * Set mm-split-view-link to load. Used to re-load last state if needed.
         *
         * @param {Object} link Link to set (DOM element).
         */
        this.setLink = function(link) {
            linkToLoad = link;
        };

        /**
         * Set split view menu's state name (left pane).
         *
         * @param {String} state State name to set.
         */
        this.setMenuState = function(state) {
            menuState = state;
        };
    }

    return {
        restrict: 'E',
        templateUrl: 'core/templates/splitview.html',
        transclude: true,
        controller: controller,
        link: function(scope, element, attrs, controller) {
            var el = element[0],
                menu = angular.element(el.querySelector('.mm-split-pane-menu')),
                menuState = $state.$current.name,
                menuParams = $state.params,
                menuWidth = attrs.menuWidth,
                component = attrs.component || 'tablet';

            scope.component = component;

            controller.setComponent(component);
            controller.setElement(el);
            controller.setMenuState(menuState);

            if (menuWidth && $ionicPlatform.isTablet()) {
                menu.css('width', menuWidth);
                menu.css('-webkit-flex-basis', menuWidth);
                menu.css('-moz-flex-basis', menuWidth);
                menu.css('-ms-flex-basis', menuWidth);
                menu.css('flex-basis', menuWidth);
            }

            // We'll set all the listeners even if it's not a tablet, to support change between tablet-smartphone mode.

            if (attrs.loadWhen) {
                // Load link when variable is set to true.
                scope.$watch(attrs.loadWhen, function(newValue) {
                    if (newValue) {
                        controller.loadLink(scope, attrs.load);
                    }
                });
            } else {
                controller.loadLink(scope, attrs.load);
            }

            // Load last opened link when we re-enter the same state. We use $stateChangeSuccess instead of $ionicView.enter
            // because $ionicView.enter is not triggered when going to the same state.
            scope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
                // Compare that name and params are similar. We'll only compare 1st level of params, it's not a deep compare.
                if (toState.name === menuState && $mmUtil.basicLeftCompare(toParams, menuParams, 1)) {
                    controller.loadLink(); // No need to pass scope and load, link should be set.
                }
            });

            // Listen for event to load link.
            scope.$on(mmCoreSplitViewLoad, function(e, data) {
                if (data && data.load) {
                    controller.loadLink(scope, data.load);
                } else {
                    controller.loadLink(scope, attrs.load);
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to load a state in a split-view-content pane in tablet or in a new page in phone.
 * Requires being a child of mmSplitView.
 *
 * IMPORTANT: Due to a limitation in Angular ui-router, the left pane state and the right pane state should NOT have
 * parameters with the same name but different value. It can cause unexpected behaviors.
 * Example: if the left pane loads a state with param 'courseid', then all the states that can be loaded in the right pane
 * should avoid having a parameter named 'courseid'. The right pane state can have a 'courseid' param only if it will always
 * have the same value than in left pane state.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmSplitViewLink
 * @description
 * Usage:
 * <... mm-split-view-link="site.mm_user-profile({courseid: courseid, userid: participant.id})" >
 *
 * This directive accepts a sref string that indicates the state to go to and the params. Scope variable need to be
 * inside curly brackets: {{variable_name}}.
 * In tablet, the new state contents will be loaded in split-pane contents pane.
 * In phone, the new state contents will be loaded in a new page.
 */
.directive('mmSplitViewLink', ["$log", "$ionicPlatform", "$state", "$mmApp", function($log, $ionicPlatform, $state, $mmApp) {
    $log = $log.getInstance('mmSplitViewLink');

    var srefRegex = new RegExp(/([^\(]*)(\((.*)\))?$/);

    /**
     * Create a new state for tablet view (split-view). The state created will be exactly the same as the target state
     * (stateName), but changing the name and the view name.
     *
     * @param  {String} stateName       Name of the state to copy.
     * @param  {String} tabletStateName Name of the new state.
     * @param  {String} newViewName     Name of the new view.
     * @return {Boolean}                True if success, false otherwise.
     */
    function createTabletState(stateName, tabletStateName, newViewName) {
        var targetState = $state.get(stateName),
            newConfig,
            viewName;

        if (targetState) {
            newConfig = angular.copy(targetState);

            // Change first view name to 'tablet' so it's loaded in the split-view content pane.
            viewName = Object.keys(newConfig.views)[0];
            newConfig.views[newViewName] = newConfig.views[viewName];
            delete newConfig.views[viewName];
            delete newConfig['name'];

            $mmApp.createState(tabletStateName, newConfig);
            return true;
        } else {
            $log.error('State doesn\'t exist: '+stateName);
            return false;
        }
    }

    /**
     * Evaluate a string using scope.
     *
     * @param  {Object} scope Scope.
     * @param  {String} value String to eval.
     * @return {Mixed}        Evaluated value or undefined if not valid.
     */
    function scopeEval(scope, value) {
        if (typeof value == 'string') {
            try {
                return scope.$eval(value);
            } catch(ex) {
                $log.error('Error evaluating string: ' + param);
            }
        }
    }

    return {
        restrict: 'A',
        require: '^mmSplitView',
        link: function(scope, element, attrs, splitViewController) {
            var sref = attrs.mmSplitViewLink,
                menuState = splitViewController.getMenuState(),
                matches,
                stateName,
                stateParams,
                stateParamsString,
                tabletStateName;

            if (sref) {
                matches = sref.match(srefRegex);
                if (matches && matches.length) {
                    stateName = matches[1]; // E.g. site.mm_user-profile
                    tabletStateName = menuState + '.' + stateName.substr(stateName.lastIndexOf('.') + 1);

                    stateParamsString = matches[3]; // E.g. {courseid: courseid, userid: userid}
                    stateParams = scopeEval(scope, stateParamsString);

                    // Watch for changes on stateParams.
                    scope.$watch(stateParamsString, function(newVal) {
                        stateParams = newVal;
                    });

                    element.on('click', function(event) {
                        event.stopPropagation();
                        event.preventDefault();

                        if ($ionicPlatform.isTablet()) {
                            if (!$state.get(tabletStateName)) {
                                // State doesn't exists. Let's create it.
                                if (!createTabletState(stateName, tabletStateName, splitViewController.getComponent())) {
                                    return;
                                }
                            }
                            splitViewController.setLink(element); // Set last link loaded.
                            splitViewController.clearMarkedLinks();
                            element.addClass('mm-split-item-selected');
                            $state.go(tabletStateName, stateParams, {location:'replace'});
                        } else {
                            $state.go(stateName, stateParams);
                        }
                    });
                } else {
                    $log.error('Invalid sref.');
                }
            } else {
                $log.error('Invalid sref.');
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('mm_contentlinks', {
        url: '/mm_contentlinks',
        abstract: true,
        templateUrl: 'core/components/contentlinks/templates/base.html',
        cache: false,   // Disable caching to force controller reload.
    })

    .state('mm_contentlinks.choosesite', {
        url: '/choosesite',
        templateUrl: 'core/components/contentlinks/templates/choosesite.html',
        controller: 'mmContentLinksChooseSiteCtrl',
        params: {
            url: null
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course', ['mm.core.courses'])

.constant('mmCoreCoursePriority', 800)
.constant('mmCoreCourseAllSectionsId', -1)

.config(["$stateProvider", "$mmCoursesDelegateProvider", "mmCoreCoursePriority", function($stateProvider, $mmCoursesDelegateProvider, mmCoreCoursePriority) {

    $stateProvider

    .state('site.mm_course', {
        url: '/mm_course',
        params: {
            courseid: null,
            sid: null, // Section to load. Not naming it sectionid because it collides with 'mm_course-section' param in split-view.
            moduleid: null // Module to load.
        },
        views: {
            'site': {
                templateUrl: 'core/components/course/templates/sections.html',
                controller: 'mmCourseSectionsCtrl'
            }
        }
    })

    .state('site.mm_course-section', {
        url: '/mm_course-section',
        params: {
            sectionid: null,
            cid: null, // Not naming it courseid because it collides with 'site.mm_course' param in split-view.
            mid: null // Not naming it moduleid because it collides with 'site.mm_course' param in split-view.
        },
        views: {
            'site': {
                templateUrl: 'core/components/course/templates/section.html',
                controller: 'mmCourseSectionCtrl'
            }
        }
    })

    .state('site.mm_course-modcontent', {
        url: '/mm_course-modcontent',
        params: {
            module: null
        },
        views: {
            site: {
                templateUrl: 'core/components/course/templates/modcontent.html',
                controller: 'mmCourseModContentCtrl'
            }
        }
    });

    $mmCoursesDelegateProvider.registerNavHandler('mmCourse', '$mmCourseCoursesNavHandler', mmCoreCoursePriority);
}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmCourseDelegate", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmCourseDelegate) {
    $mmEvents.on(mmCoreEventLogin, $mmCourseDelegate.updateContentHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCourseDelegate.updateContentHandlers);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses', [])

.constant('mmCoursesSearchComponent', 'mmCoursesSearch')
.constant('mmCoursesSearchPerPage', 20) // Max of courses per page when searching courses.
.constant('mmCoursesEnrolInvalidKey', 'mmCoursesEnrolInvalidKey')
.constant('mmCoursesEventMyCoursesUpdated', 'my_courses_updated')
.constant('mmCoursesAccessMethods', {
     guest: 'guest',
     default: 'default'
})

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mm_courses', {
        url: '/mm_courses',
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/list.html',
                controller: 'mmCoursesListCtrl'
            }
        }
    })

    .state('site.mm_searchcourses', {
        url: '/mm_searchcourses',
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/search.html',
                controller: 'mmCoursesSearchCtrl'
            }
        }
    })

    .state('site.mm_viewresult', {
        url: '/mm_viewresult',
        params: {
            course: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/viewresult.html',
                controller: 'mmCoursesViewResultCtrl'
            }
        }
    });

}])

.config(["$mmContentLinksDelegateProvider", function($mmContentLinksDelegateProvider) {
    $mmContentLinksDelegateProvider.registerLinkHandler('mmCourses', '$mmCoursesHandlers.linksHandler');
}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmCoursesDelegate", "$mmCourses", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmCoursesDelegate, $mmCourses) {
    $mmEvents.on(mmCoreEventLogin, $mmCoursesDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCoursesDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventLogout, function() {
        $mmCoursesDelegate.clearCoursesHandlers();
        $mmCourses.clearCurrentCourses();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login', [])

.config(["$stateProvider", "$urlRouterProvider", "$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($stateProvider, $urlRouterProvider, $mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {

    $stateProvider

    .state('mm_login', {
        url: '/mm_login',
        abstract: true,
        templateUrl: 'core/components/login/templates/base.html',
        cache: false,   // Disable caching to force controller reload.
        onEnter: ["$ionicHistory", function($ionicHistory) {
            // Ensure that there is no history stack when getting here.
            $ionicHistory.clearHistory();
        }]
    })

    .state('mm_login.init', {
        url: '/init',
        templateUrl: 'core/components/login/templates/init.html',
        controller: 'mmLoginInitCtrl',
        cache: false // Disable caching to force controller reload.
    })

    .state('mm_login.sites', {
        url: '/sites',
        templateUrl: 'core/components/login/templates/sites.html',
        controller: 'mmLoginSitesCtrl',
        onEnter: ["$mmLoginHelper", "$mmSitesManager", function($mmLoginHelper, $mmSitesManager) {
            // Skip this page if there are no sites yet.
            $mmSitesManager.hasNoSites().then(function() {
                $mmLoginHelper.goToAddSite();
            });
        }]
    })

    .state('mm_login.site', {
        url: '/site',
        templateUrl: 'core/components/login/templates/site.html',
        controller: 'mmLoginSiteCtrl'
    })

    .state('mm_login.credentials', {
        url: '/cred',
        templateUrl: 'core/components/login/templates/credentials.html',
        controller: 'mmLoginCredentialsCtrl',
        params: {
            siteurl: ''
        },
        onEnter: ["$state", "$stateParams", function($state, $stateParams) {
            // Do not allow access to this page when the URL was not passed.
            if (!$stateParams.siteurl) {
              $state.go('mm_login.init');
            }
        }]
    })

    .state('mm_login.reconnect', {
        url: '/reconnect',
        templateUrl: 'core/components/login/templates/reconnect.html',
        controller: 'mmLoginReconnectCtrl',
        cache: false,
        params: {
            siteurl: '',
            username: '',
            infositeurl: ''
        }
    });

    // Default redirect to the login page.
    $urlRouterProvider.otherwise(function($injector) {
        var $state = $injector.get('$state');
        return $state.href('mm_login.init').replace('#', '');
    });

    // Restore the session.
    $mmInitDelegateProvider.registerProcess('mmLogin', '$mmSitesManager.restoreSession', mmInitDelegateMaxAddonPriority + 200);
}])

.run(["$log", "$state", "$mmUtil", "$translate", "$mmSitesManager", "$rootScope", "$mmSite", "$mmURLDelegate", "$ionicHistory", "$mmEvents", "$mmLoginHelper", "mmCoreEventSessionExpired", "$mmApp", function($log, $state, $mmUtil, $translate, $mmSitesManager, $rootScope, $mmSite, $mmURLDelegate, $ionicHistory,
                $mmEvents, $mmLoginHelper, mmCoreEventSessionExpired, $mmApp) {

    $log = $log.getInstance('mmLogin');

    // Listen for sessionExpired event to reconnect the user.
    $mmEvents.on(mmCoreEventSessionExpired, sessionExpired);

    // Register observer to check if the app was launched via URL scheme.
    $mmURLDelegate.register('mmLoginSSO', appLaunchedByURL);

    // Redirect depending on user session.
    $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {

        // Prevent state changes while the app is not ready.
        if (!$mmApp.isReady() && toState.name !== 'mm_login.init') {
            event.preventDefault();
            $state.transitionTo('mm_login.init');
            $log.warn('Forbidding state change to \'' + toState.name + '\'. App is not ready yet.');
            return;
        }

        if (toState.name.substr(0, 8) === 'redirect' || toState.name.substr(0, 15) === 'mm_contentlinks') {
            return;
        } else if ((toState.name.substr(0, 8) !== 'mm_login' || toState.name === 'mm_login.reconnect') && !$mmSite.isLoggedIn()) {
            // We are not logged in.
            event.preventDefault();
            $log.debug('Redirect to login page, request was: ' + toState.name);
            // Disable animation and back button for the next transition.
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.transitionTo('mm_login.init');
        } else if (toState.name.substr(0, 8) === 'mm_login' && toState.name !== 'mm_login.reconnect' && $mmSite.isLoggedIn()) {
            // We are logged in and requested the login page.
            event.preventDefault();
            $log.debug('Redirect to course page, request was: ' + toState.name);
            // Disable animation and back button for the next transition.
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.transitionTo('site.mm_courses');
        }

    });

    // Function to handle session expired events.
    function sessionExpired(siteid) {

        var siteurl = $mmSite.getURL();

        if (typeof(siteurl) !== 'undefined') {

            if (siteid && siteid !== $mmSite.getId()) {
                return; // Site that triggered the event is not current site.
            }

            // Check authentication method.
            $mmSitesManager.checkSite(siteurl).then(function(result) {

                if (result.warning) {
                    $mmUtil.showErrorModal(result.warning, true, 4000);
                }

                if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                    // SSO. User needs to authenticate in a browser.
                    $mmUtil.showConfirm($translate('mm.login.reconnectssodescription')).then(function() {
                        $mmLoginHelper.openBrowserForSSOLogin(result.siteurl);
                    });
                } else {
                    var info = $mmSite.getInfo();
                    if (typeof(info) !== 'undefined' && typeof(info.username) !== 'undefined') {
                        $ionicHistory.nextViewOptions({disableBack: true});
                        $state.go('mm_login.reconnect',
                                        {siteurl: result.siteurl, username: info.username, infositeurl: info.siteurl});
                    }
                }
            });
        }
    }

    // Function to handle URL received by Custom URL Scheme. If it's a SSO login, perform authentication.
    function appLaunchedByURL(url) {
        var ssoScheme = 'moodlemobile://token=';
        if (url.indexOf(ssoScheme) == -1) {
            return false;
        }

        // App opened using custom URL scheme. Probably an SSO authentication.
        $log.debug('App launched by URL');

        var modal = $mmUtil.showModalLoading('mm.login.authenticating', true);

        // Delete the sso scheme from the URL.
        url = url.replace(ssoScheme, '');
        // Decode from base64.
        try {
            url = atob(url);
        } catch(err) {
            // Error decoding the parameter.
            $log.error('Error decoding parameter received for login SSO');
            return false;
        }

        $mmLoginHelper.validateBrowserSSOLogin(url).then(function(sitedata) {

            $mmLoginHelper.handleSSOLoginAuthentication(sitedata.siteurl, sitedata.token).then(function() {
                $state.go('site.mm_courses');
            }, function(error) {
                $mmUtil.showErrorModal(error);
            }).finally(function() {
                modal.dismiss();
            });

        }, function(errorMessage) {
            modal.dismiss();
            if (typeof(errorMessage) === 'string' && errorMessage != '') {
                $mmUtil.showErrorModal(errorMessage);
            }
        });

        return true;
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings', [])

.constant('mmCoreSettingsDownloadSection', 'mmCoreSettingsDownloadSection')
.constant('mmCoreSettingsReportInBackground', 'mmCoreReportInBackground')
.constant('mmCoreSettingsSyncOnlyOnWifi', 'mmCoreSyncOnlyOnWifi')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mm_settings', {
        url: '/mm_settings',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/list.html'
            }
        }
    })

    .state('site.mm_settings-about', {
        url: '/mm_settings-about',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/about.html',
                controller: 'mmSettingsAboutCtrl'
            }
        }
    })

    .state('site.mm_settings-general', {
        url: '/mm_settings-general',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/general.html',
                controller: 'mmSettingsGeneralCtrl'
            }
        }
    })

    .state('site.mm_settings-spaceusage', {
        url: '/mm_settings-spaceusage',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/space-usage.html',
                controller: 'mmSettingsSpaceUsageCtrl'
            }
        }
    })

    .state('site.mm_settings-synchronization', {
        url: '/mm_settings-synchronization',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/synchronization.html',
                controller: 'mmSettingsSynchronizationCtrl'
            }
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.sidemenu', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site', {
        url: '/site',
        templateUrl: 'core/components/sidemenu/templates/menu.html',
        controller: 'mmSideMenuCtrl',
        abstract: true,
        cache: false,
        onEnter: ["$ionicHistory", "$state", "$mmSite", "$timeout", function($ionicHistory, $state, $mmSite, $timeout) {
            // Remove the login page from the history stack.
            $ionicHistory.clearHistory();

            // Go to login if user is not logged in.
            if (!$mmSite.isLoggedIn()) {
                $state.go('mm_login.init');
            }
        }]
    });

}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmSideMenuDelegate", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmSideMenuDelegate) {
    $mmEvents.on(mmCoreEventLogin, $mmSideMenuDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmSideMenuDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventLogout, $mmSideMenuDelegate.clearSiteHandlers);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.textviewer', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mm_textviewer', {
        url: '/mm_textviewer',
        params: {
            title: null,
            content: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/textviewer/templates/textviewer.html',
                controller: 'mmTextViewerIndexCtrl'
            }
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user', [])

.value('mmUserProfileState', 'site.mm_user-profile')

.config(["$stateProvider", "$mmContentLinksDelegateProvider", function($stateProvider, $mmContentLinksDelegateProvider) {

    $stateProvider

        .state('site.mm_user-profile', {
            url: '/mm_user-profile',
            views: {
                'site': {
                    controller: 'mmUserProfileCtrl',
                    templateUrl: 'core/components/user/templates/profile.html'
                }
            },
            params: {
                courseid: 0,
                userid: 0
            }
        });

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmUser', '$mmUserHandlers.linksHandler');

}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmUserDelegate", "$mmSite", "mmCoreEventUserDeleted", "$mmUser", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmUserDelegate, $mmSite, mmCoreEventUserDeleted, $mmUser) {
    $mmEvents.on(mmCoreEventLogin, $mmUserDelegate.updateProfileHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmUserDelegate.updateProfileHandlers);

    $mmEvents.on(mmCoreEventUserDeleted, function(data) {
        if (data.siteid && data.siteid === $mmSite.getId() && data.params) {
            // Search for userid in params.
            var params = data.params,
                userid = 0;
            if (params.userid) {
                userid = params.userid;
            } else if (params.userids) {
                userid = params.userids[0];
            } else if (params.field === 'id' && params.values && params.values.length) {
                userid = params.values[0];
            } else if (params.userlist && params.userlist.length) {
                userid = params.userlist[0].userid;
            }

            userid = parseInt(userid);
            if (userid > 0) {
                $mmUser.deleteStoredUser(userid);
            }
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks')

/**
 * Controller to choose an account to handle content links.
 *
 * @module mm.core.contentlinks
 * @ngdoc controller
 * @name mmContentLinksChooseSiteCtrl
 */
.controller('mmContentLinksChooseSiteCtrl', ["$scope", "$stateParams", "$mmSitesManager", "$mmUtil", "$ionicHistory", "$state", "$q", "$mmContentLinksDelegate", "$mmContentLinksHelper", function($scope, $stateParams, $mmSitesManager, $mmUtil, $ionicHistory, $state, $q,
            $mmContentLinksDelegate, $mmContentLinksHelper) {

    $scope.url = $stateParams.url || '';

    var action;

    function leaveView() {
        $mmSitesManager.logout().finally(function() {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.go('mm_login.sites');
        });
    }

    if (!$scope.url) {
        leaveView();
        return;
    }

    $mmContentLinksDelegate.getActionsFor($scope.url).then(function(actions) {
        action = $mmContentLinksHelper.getFirstValidAction(actions);
        if (!action) {
            return $q.reject();
        }

        $mmSitesManager.getSites(action.sites).then(function(sites) {
            $scope.sites = sites;
        });
    }).catch(function() {
        $mmUtil.showErrorModal('mm.contentlinks.errornosites', true);
        leaveView();
    });

    $scope.siteClicked = function(siteId) {
        action.action(siteId);
    };

    $scope.cancel = function() {
        leaveView();
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks')

/**
 * Service to handle links found in contents. Allows to capture links in content and redirect to certain parts
 * of the app instead of opening them in browser.
 *
 * @module mm.core.contentlinks
 * @ngdoc provider
 * @name $mmContentLinksDelegate
 */
.provider('$mmContentLinksDelegate', function() {
    var linkHandlers = {},
        self = {};

    /**
     * Register a link handler.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksDelegateProvider#registerLinkHandler
     * @param {String} name                    Handler's name.
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                         returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - getActions(siteIds, url, courseId) (Promise) Returns list of actions. Each action must have:
     *                                                           - message: Message related to the action to do. E.g. 'View'.
     *                                                           - icon: Icon related to the action to do.
     *                                                           - sites: Sites IDs that support the action. Subset of 'siteIds'.
     *                                                           - action(siteId): A function to be called when the link is clicked.
     * @param {Number} [priority]              Handler's priority.
     */
    self.registerLinkHandler = function(name, handler, priority) {
        if (typeof linkHandlers[name] !== 'undefined') {
            console.log("$mmContentLinksDelegateProvider: Addon '" + linkHandlers[name].name +
                        "' already registered as link handler");
            return false;
        }
        console.log("$mmContentLinksDelegateProvider: Registered handler '" + name + "' as link handler.");
        linkHandlers[name] = {
            name: name,
            handler: handler,
            instance: undefined,
            priority: typeof priority === 'undefined' ? 100 : priority
        };
        return true;
    };

    self.$get = ["$mmUtil", "$log", "$q", "$mmSitesManager", function($mmUtil, $log, $q, $mmSitesManager) {
        var self = {};

        $log = $log.getInstance('$mmContentLinksDelegate');

        /**
         * Get the list of possible actions to do for a URL.
         *
         * @module mm.core.contentlinks
         * @ngdoc method
         * @name $mmContentLinksDelegate#getLinkHandlersFor
         * @param {String} url        URL to handle.
         * @param {Number} [courseId] Course ID related to the URL. Optional but recommended since some handlers might require
         *                            to know the courseid if Moodle version is previous to 3.0.
         * @return {Promise}          Promise resolved with the actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActionsFor = function(url, courseId) {
            if (!url) {
                return $q.when([]);
            }

            // Get the list of sites the URL belongs to.
            return $mmSitesManager.getSiteIdsFromUrl(url, true).then(function(siteIds) {
                var linkActions = [],
                    promises = [];

                angular.forEach(linkHandlers, function(handler) {
                    if (typeof handler.instance === 'undefined') {
                        handler.instance = $mmUtil.resolveObject(handler.handler, true);
                    }

                    if (handler.instance) {
                        promises.push($q.when(handler.instance.getActions(siteIds, url, courseId)).then(function(actions) {
                            if (actions && actions.length) {
                                linkActions.push({
                                    priority: handler.priority,
                                    actions: actions
                                });
                            }
                        }));
                    }
                });

                return $mmUtil.allPromises(promises).catch(function() {}).then(function() {
                    // Sort link actions by priority.
                    return sortActionsByPriority(linkActions);
                });
            });
        };

        /**
         * Sort actions by priority. Each object in the actions param must have a priority and a list of actions.
         * The returned array only contains the actions ordered by priority.
         *
         * @param  {Object[]} actions Actions to sort.
         * @return {Object[]}         Sorted actions.
         */
        function sortActionsByPriority(actions) {
            var sorted = [];

            // Sort by priority.
            actions = actions.sort(function(a, b) {
                return a.priority > b.priority;
            });

            // Fill result array.
            actions.forEach(function(entry) {
                sorted = sorted.concat(entry.actions);
            });
            return sorted;
        }

        return self;
    }];

    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks')

/**
 * Service to provide some helper functionalities for the contentlinks component.
 *
 * @module mm.core.contentlinks
 * @ngdoc service
 * @name $mmContentLinksHelper
 */
.factory('$mmContentLinksHelper', ["$log", "$ionicHistory", "$state", "$mmSite", "$mmContentLinksDelegate", "$mmUtil", "$translate", "$mmCourseHelper", function($log, $ionicHistory, $state, $mmSite, $mmContentLinksDelegate, $mmUtil, $translate,
            $mmCourseHelper) {

    $log = $log.getInstance('$mmContentLinksHelper');

    var self = {};

    /**
     * Filter the list of supported sites based on a isEnabled function.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#filterSupportedSites
     * @param  {String[]} siteIds     Site IDs to filter.
     * @param  {Function} isEnabledFn Function to call for each site. Must return a promise resolved with true if enabled. It
     *                                receives a siteId param and all the params sent to this function after 'checkAll'.
     * @param  {Boolean} checkAll     True if it should check all the sites, false if it should check only 1 and treat them all
     *                                depending on this result.
     * @param  {Mixed}                All the params sent after checkAll will be passed to isEnabledFn.
     * @return {Promise}              Promise resolved with the list of supported sites.
     */
    self.filterSupportedSites = function(siteIds, isEnabledFn, checkAll) {
        var promises = [],
            supported = [],
            extraParams = Array.prototype.slice.call(arguments, 3); // Params received after 'checkAll'.

        angular.forEach(siteIds, function(siteId) {
            if (checkAll || !promises.length) {
                promises.push(isEnabledFn.apply(isEnabledFn, [siteId].concat(extraParams)).then(function(enabled) {
                    if (enabled) {
                        supported.push(siteId);
                    }
                }));
            }
        });

        return $mmUtil.allPromises(promises).catch(function() {}).then(function() {
            if (!checkAll) {
                if (supported.length) {
                    return siteIds; // Checking 1 was enough and it succeeded, all sites supported.
                } else {
                    return []; // Checking 1 was enough and it failed, no sites supported.
                }
            } else {
                return supported;
            }
        });
    };

    /**
     * Get the first valid action in a list of actions.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#getFirstValidAction
     * @param  {Object[]} actions List of actions.
     * @return {Object}           First valid action. Returns undefined if no valid action found.
     */
    self.getFirstValidAction = function(actions) {
        if (actions) {
            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];
                if (action && action.sites && action.sites.length && angular.isFunction(action.action)) {
                    return action;
                }
            }
        }
    };

    /**
     * Goes to a certain state in a certain site. If the site is current site it will perform a regular navigation,
     * otherwise it uses the 'redirect' state to change the site.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#goInSite
     * @param  {String} stateName   Name of the state to go.
     * @param  {Object} stateParams Params to send to the state.
     * @param  {String} [siteId]    Site ID. If not defined, current site.
     * @return {Promise}            Promise resolved when the state is changed.
     */
    self.goInSite = function(stateName, stateParams, siteId) {
        siteId = siteId || $mmSite.getId();
        if (siteId == $mmSite.getId()) {
            return $state.go(stateName, stateParams);
        } else {
            return $state.go('redirect', {
                siteid: siteId,
                state: stateName,
                params: stateParams
            });
        }
    };

    /**
     * Go to the view to choose a site.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#goToChooseSite
     * @param {String} url URL to treat.
     * @return {Promise}   Promise resolved when the state changes.
     */
    self.goToChooseSite = function(url) {
        $ionicHistory.nextViewOptions({
            disableBack: true
        });
        return $state.go('mm_contentlinks.choosesite', {url: url});
    };

    /**
     * Handle a link.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#handleLink
     * @param  {String} url URL to handle.
     * @return {Promise}    Promise resolved with a boolean: true if URL was treated, false otherwise.
     */
    self.handleLink = function(url) {
        // Check if the link should be treated by some component/addon.
        return $mmContentLinksDelegate.getActionsFor(url).then(function(actions) {
            var action = self.getFirstValidAction(actions);
            if (action) {
                if (action.sites.length == 1 && action.sites[0] == $mmSite.getId()) {
                    // Current site.
                    action.action(action.sites[0]);
                } else {
                    // Not current site or more than one site. Ask for confirmation.
                    $mmUtil.showConfirm($translate('mm.contentlinks.confirmurlothersite')).then(function() {
                        if (action.sites.length == 1) {
                            action.action(action.sites[0]);
                        } else {
                            self.goToChooseSite(url);
                        }
                    });
                }
                return true;
            }
        }).catch(function() {
            return false;
        });
    };

    /**
     * Treats a URL that belongs to a module's index page.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#treatModuleIndexUrl
     * @param {String[]} siteIds   Site IDs the URL belongs to.
     * @param {String} url         URL to treat.
     * @param {Function} isEnabled Function to check if the module is enabled. @see $mmContentLinksHelper#filterSupportedSites .
     * @param {Number} [courseId]  Course ID related to the URL.
     * @return {Promise}           Promise resolved with the list of actions.
     */
    self.treatModuleIndexUrl = function(siteIds, url, isEnabled, courseId) {
        var params = $mmUtil.extractUrlParams(url);
        if (typeof params.id != 'undefined') {
            // Pass false because all sites should have the same siteurl.
            return self.filterSupportedSites(siteIds, isEnabled, false, courseId).then(function(ids) {
                if (!ids.length) {
                    return [];
                } else {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: ids,
                        action: function(siteId) {
                            $mmCourseHelper.navigateToModule(parseInt(params.id, 10), siteId, courseId);
                        }
                    }];
                }
            });
        }
        return $q.when([]);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Mod content controller.
 *
 * @todo MDL-50114 The description might be missing because this data is based on the course
 *       contents which does not always include it.
 * @module mm.core.course
 * @ngdoc controller
 * @name mmCourseModContentCtrl
 */
.controller('mmCourseModContentCtrl', ["$log", "$stateParams", "$scope", function($log, $stateParams, $scope) {
    $log = $log.getInstance('mmCourseModContentCtrl');
    var module = $stateParams.module || {};
    $scope.description = module.description;
    $scope.title = module.name;
    $scope.url = module.url;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Section view controller.
 *
 * @module mm.core.course
 * @ngdoc controller
 * @name mmCourseSectionCtrl
 */
.controller('mmCourseSectionCtrl', ["$mmCourseDelegate", "$mmCourse", "$mmUtil", "$scope", "$stateParams", "$translate", "$mmSite", "$mmEvents", "$ionicScrollDelegate", "$mmCourses", "$q", "mmCoreEventCompletionModuleViewed", "$controller", function($mmCourseDelegate, $mmCourse, $mmUtil, $scope, $stateParams, $translate, $mmSite,
            $mmEvents, $ionicScrollDelegate, $mmCourses, $q, mmCoreEventCompletionModuleViewed, $controller) {

    // Default values are course 1 (front page) and all sections.
    var courseId = $stateParams.cid || 1,
        sectionId = $stateParams.sectionid || -1,
        moduleId = $stateParams.mid;

    $scope.sitehome = (courseId === 1); // Are we visiting the site home?
    $scope.sections = []; // Reset scope.sections, otherwise an error is shown in console with tablet view.

    if (sectionId < 0) {
        // Special scenario, we want all sections.
        if ($scope.sitehome) {
            $scope.title = $translate.instant('mma.frontpage.sitehome');
        } else {
            $scope.title = $translate.instant('mm.course.allsections');
        }
        $scope.summary = null;
    }

    // Convenience function to fetch section(s).
    function loadContent(sectionId) {
        return $mmCourses.getUserCourse(courseId, true).catch(function() {
            // User not enrolled in the course or an error occurred, ignore the error.
        }).then(function(course) {
            var promise;
            if (course && course.enablecompletion === false) {
                promise = $q.when([]); // Completion not enabled, return empty array.
            } else {
                promise = $mmCourse.getActivitiesCompletionStatus(courseId).catch(function() {
                    return []; // If fail, return empty array (as if there was no completion).
                });
            }

            return promise.then(function(statuses) {
                var promise,
                    sectionnumber;

                if (sectionId < 0) {
                    sectionnumber = 0;
                    promise = $mmCourse.getSections(courseId);
                } else {
                    sectionnumber = sectionId;
                    promise = $mmCourse.getSection(courseId, sectionId).then(function(section) {
                        $scope.title = section.name;
                        $scope.summary = section.summary;
                        return [section];
                    });
                }

                return promise.then(function(sections) {
                    // For the site home, we need to reverse the order to display first the site home section topic.
                    if ($scope.sitehome) {
                        sections.reverse();
                    }

                    var hasContent = false;

                    angular.forEach(sections, function(section) {
                        if (section.summary != '' || section.modules.length) {
                            hasContent = true;
                        }

                        angular.forEach(section.modules, function(module) {
                            module._controller =
                                    $mmCourseDelegate.getContentHandlerControllerFor(module.modname, module, courseId, section.id);
                            // Check if activity has completions and if it's marked.
                            var status = statuses[module.id];
                            if (typeof status != 'undefined') {
                                module.completionstatus = status;
                            }

                            if (module.id == moduleId) {
                                // This is the module we're looking for. Open it.
                                var scope = $scope.$new();
                                $controller(module._controller, {$scope: scope});
                                if (scope.action) {
                                    scope.action();
                                }
                            }
                        });
                    });

                    $scope.sections = sections;
                    $scope.hasContent = hasContent;

                    // Add log in Moodle.
                    $mmSite.write('core_course_view_course', {
                        courseid: courseId,
                        sectionnumber: sectionnumber
                    });
                }, function(error) {
                    if (error) {
                        $mmUtil.showErrorModal(error);
                    } else {
                        $mmUtil.showErrorModal('mm.course.couldnotloadsectioncontent', true);
                    }
                });
            });
        });
    }

    loadContent(sectionId).finally(function() {
        $scope.sectionLoaded = true;
    });

    $scope.doRefresh = function() {
        $mmCourse.invalidateSections(courseId).finally(function() {
            loadContent(sectionId).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    // Refresh list after a completion change since there could be new activities or so.
    function refreshAfterCompletionChange() {
        var scrollView = $ionicScrollDelegate.$getByHandle('mmSectionScroll');
        if (scrollView && scrollView.getScrollPosition()) {
            $scope.loadingPaddingTop = scrollView.getScrollPosition().top;
        }
        $scope.sectionLoaded = false;
        $scope.sections = [];
        loadContent(sectionId).finally(function() {
            $scope.sectionLoaded = true;
            $scope.loadingPaddingTop = 0;
        });
    }

    // Completion changed for at least one module. Invalidate data and re-load it.
    $scope.completionChanged = function() {
        $mmCourse.invalidateSections(courseId).finally(function() {
            refreshAfterCompletionChange();
        });
    };

    // Listen for viewed modules. If an automatic completion module is viewed, refresh the whole list.
    var observer = $mmEvents.on(mmCoreEventCompletionModuleViewed, function(cid) {
        if (cid === courseId) {
            refreshAfterCompletionChange();
        }
    });
    $scope.$on('$destroy', function() {
        if (observer && observer.off) {
            observer.off();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Sections view controller.
 *
 * @module mm.core.course
 * @ngdoc controller
 * @name mmCourseSectionsCtrl
 */
.controller('mmCourseSectionsCtrl', ["$mmCourse", "$mmUtil", "$scope", "$stateParams", "$translate", "$mmCourseHelper", "$mmEvents", "$mmSite", "$mmCoursePrefetchDelegate", "$mmCourses", "$q", "$ionicHistory", "$ionicPlatform", "mmCoreCourseAllSectionsId", "mmCoreEventSectionStatusChanged", "$mmConfig", "mmCoreSettingsDownloadSection", "$state", "$timeout", function($mmCourse, $mmUtil, $scope, $stateParams, $translate, $mmCourseHelper, $mmEvents,
            $mmSite, $mmCoursePrefetchDelegate, $mmCourses, $q, $ionicHistory, $ionicPlatform, mmCoreCourseAllSectionsId,
            mmCoreEventSectionStatusChanged, $mmConfig, mmCoreSettingsDownloadSection, $state, $timeout) {
    var courseId = $stateParams.courseid,
        sectionId = $stateParams.sid,
        moduleId = $stateParams.moduleid,
        downloadSectionsEnabled;

    $scope.courseId = courseId;
    $scope.sectionToLoad = 2; // Load "General" section by default.

    function checkDownloadSectionsEnabled() {
        return $mmConfig.get(mmCoreSettingsDownloadSection, true).then(function(enabled) {
            downloadSectionsEnabled = enabled;
        }).catch(function() {
            // Shouldn't happen.
            downloadSectionsEnabled = false;
        });
    }

    function loadSections(refresh) {
        // Get full course data. If not refreshing we'll try to get it from cache to speed up the response.
        return $mmCourses.getUserCourse(courseId).then(function(course) {
            $scope.fullname = course.fullname;
            // Get the sections.
            return $mmCourse.getSections(courseId).then(function(sections) {
                // Add a fake first section (all sections).
                return $translate('mm.course.allsections').then(function(str) {
                    // Adding fake first section.
                    var result = [{
                        name: str,
                        id: mmCoreCourseAllSectionsId
                    }].concat(sections);

                    $scope.sections = result;

                    if (downloadSectionsEnabled) {
                        // Calculate status of the sections.
                        return $mmCourseHelper.calculateSectionsStatus(result, courseId, true, refresh).catch(function() {
                            // Ignore errors (shouldn't happen).
                        }).then(function(downloadpromises) {
                            // If we restored any download we'll recalculate the status once all of them have finished.
                            if (downloadpromises && downloadpromises.length) {
                                $mmUtil.allPromises(downloadpromises).catch(function() {
                                    if (!$scope.$$destroyed) {
                                        $mmUtil.showErrorModal('mm.course.errordownloadingsection', true);
                                    }
                                }).finally(function() {
                                    if (!$scope.$$destroyed) {
                                        // Recalculate the status.
                                        $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false);
                                    }
                                });
                            }
                        });
                    }
                });
            });
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.couldnotloadsections', true);
            }
        });
    }

    // Prefetch a section. The second parameter indicates if the prefetch was started manually (true)
    // or it was automatically started because all modules are being downloaded (false).
    function prefetch(section, manual) {
        $mmCourseHelper.prefetch(section, courseId, $scope.sections).catch(function() {
            // Don't show error message if scope is destroyed or it's an automatic download but we aren't in this state.
            if ($scope.$$destroyed) {
                return;
            }

            var current = $ionicHistory.currentStateName(),
                isCurrent = ($ionicPlatform.isTablet() && current == 'site.mm_course.mm_course-section') ||
                            (!$ionicPlatform.isTablet() && current == 'site.mm_course');
            if (!manual && !isCurrent) {
                return;
            }

            $mmUtil.showErrorModal('mm.course.errordownloadingsection', true);
        }).finally(function() {
            if (!$scope.$$destroyed) {
                // Recalculate the status.
                $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false);
            }
        });
    }

    // Convenience function to autoload a section if sectionId param is set.
    function autoloadSection() {
        if (sectionId) {
            if ($ionicPlatform.isTablet()) {
                // Search the position of the section to load.
                angular.forEach($scope.sections, function(section, index) {
                    if (section.id == sectionId) {
                        $scope.sectionToLoad = index + 1;
                    }
                });
                // Set moduleId to pass it to the new state when the section is autoloaded. We unset it after this
                // to prevent autoloading the module when the user manually loads a section.
                $scope.moduleId = moduleId;
                $timeout(function() {
                    $scope.moduleId = null; // Unset moduleId when
                }, 500);
            } else {
                $state.go('site.mm_course-section', {
                    sectionid: sectionId,
                    cid: courseId,
                    mid: moduleId
                });
            }
        }
    }

    $scope.doRefresh = function() {
        var promises = [];
        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourse.invalidateSections(courseId));

        $q.all(promises).finally(function() {
            loadSections(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    $scope.prefetch = function(e, section) {
        e.preventDefault();
        e.stopPropagation();

        $mmCourseHelper.confirmDownloadSize(courseId, section, $scope.sections).then(function() {
            prefetch(section, true);
        });
    };

    checkDownloadSectionsEnabled().then(function() {
        loadSections().finally(function() {
            autoloadSection();
            $scope.sectionsLoaded = true;
        });
    });

    // Listen for section status changes.
    var statusObserver = $mmEvents.on(mmCoreEventSectionStatusChanged, function(data) {
        if (downloadSectionsEnabled && $scope.sections && $scope.sections.length && data.siteid === $mmSite.getId() &&
                    !$scope.$$destroyed&& data.sectionid) {
            // Check if the affected section is being downloaded. If so, we don't update section status
            // because it'll already be updated when the download finishes.
            if ($mmCoursePrefetchDelegate.isBeingDownloaded($mmCourseHelper.getSectionDownloadId({id: data.sectionid}))) {
                return;
            }

            // Recalculate the status.
            $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false).then(function() {
                var section;
                angular.forEach($scope.sections, function(s) {
                    if (s.id === data.sectionid) {
                        section = s;
                    }
                });
                if (section) {
                    var downloadid = $mmCourseHelper.getSectionDownloadId(section);
                    if (section.isDownloading && !$mmCoursePrefetchDelegate.isBeingDownloaded(downloadid)) {
                        // All the modules are now downloading, set a download all promise.
                        prefetch(section, false);
                    }
                }
            });
        }
    });

    $scope.$on('$destroy', function() {
        statusObserver && statusObserver.off && statusObserver.off();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Course Mod Description directive.
 *
 * To use to display the description of a module.
 *
 * @module mm.core.course
 * @ngdoc directive
 * @name mmCourseModDescription
 * @description
 *
 * This directive is meant to display a module description in a similar way throughout
 * all the modules. It has its own scope and so will use the attribute 'description' to
 * know what scope variable to look for in the parent scope.
 *
 * If the description is asynchronous you should set the attribute 'watch' to true.
 * This attribute is directly shared with mmFormatText which needs it.
 *
 * You can add a note at the right side of the description by using the 'note' attribute.
 *
 * Module descriptions are shortened by default, allowing the user to see the full description by clicking in it.
 * If you want the whole description to be shown you can use the 'showfull' attribute.
 *
 * @example
 *
 * <mm-course-mod-description description="myDescription"></mm-course-mod-description>
 *
 * <mm-course-mod-description description="myAsyncDesc" watch="true"></mm-course-mod-description>
 */
.directive('mmCourseModDescription', function() {
    return {
        compile: function(element, attrs) {
            if (attrs.watch) {
                element.find('mm-format-text').attr('watch', attrs.watch);
            }

            return function(scope) { // Link function.
                scope.showfull = !!attrs.showfull;
            };
        },
        restrict: 'E',
        scope: {
            description: '=',
            note: '='
        },
        templateUrl: 'core/components/course/templates/mod_description.html'
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Default course content handler.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseContentHandler
 */
.factory('$mmCourseContentHandler', ["$mmCourse", "$mmUtil", function($mmCourse, $mmUtil) {
    return {
        getController: function(module) {
            return function($scope, $state) {
                $scope.icon = $mmCourse.getModuleIconSrc(module.modname);
                $scope.title = module.name;

                $scope.action = function(e) {
                    $state.go('site.mm_course-modcontent', {module: module});
                    e.preventDefault();
                    e.stopPropagation();
                };

                if (module.url) {
                    $scope.buttons = [{
                        icon: 'ion-ios-browsers-outline',
                        label: 'mm.core.openinbrowser',
                        action: function(e) {
                            $mmUtil.openInBrowser(module.url);
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }];
                }
            };
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

.constant('mmCoreCourseModulesStore', 'course_modules') // @deprecated since version 2.6. Please do not use.

.config(["$mmSitesFactoryProvider", "mmCoreCourseModulesStore", function($mmSitesFactoryProvider, mmCoreCourseModulesStore) {
    var stores = [
        {
            name: mmCoreCourseModulesStore,
            keyPath: 'id'
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Factory containing course related methods.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourse
 */
.factory('$mmCourse', ["$mmSite", "$translate", "$q", "$log", "$mmEvents", "$mmSitesManager", "mmCoreEventCompletionModuleViewed", function($mmSite, $translate, $q, $log, $mmEvents, $mmSitesManager, mmCoreEventCompletionModuleViewed) {

    $log = $log.getInstance('$mmCourse');

    var self = {},
        mods = ["assign", "assignment", "book", "chat", "choice", "data", "database", "date", "external-tool",
            "feedback", "file", "folder", "forum", "glossary", "ims", "imscp", "label", "lesson", "lti", "page", "quiz",
            "resource", "scorm", "survey", "url", "wiki", "workshop"
        ],
        modsWithContent = ['book', 'folder', 'imscp', 'page', 'resource', 'url'];

    /**
     * Add a 'contents' property if the module needs it and it doesn't have it already. In some weird cases the site
     * doesn't return this property and it's needed. See MOBILE-1381.
     *
     * @param {Object} module Module to check.
     * @return {Object}       Module with contents.
     */
    function addContentsIfNeeded(module) {
        if (modsWithContent.indexOf(module.modname) > -1) {
            module.contents = module.contents || [];
        }
        return module;
    }

    /**
     * Check if the site is prepared to return a module without having its course ID.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#canGetModuleWithoutCourseId
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if can return it, rejected or resolved with false otherwise.
     */
    self.canGetModuleWithoutCourseId = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('core_course_get_course_module');
        });
    };

    /**
     * Check if the site is prepared to return a module by instance ID.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#canGetModuleByInstance
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if can return it, rejected or resolved with false otherwise.
     */
    self.canGetModuleByInstance = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('core_course_get_course_module_by_instance');
        });
    };

    /**
     * Check if module completion could have changed. If it could have, trigger event. This function must be used,
     * for example, after calling a "module_view" WS since it can change the module completion.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#checkModuleCompletion
     * @param {Number} courseId   Course ID.
     * @param {Object} completion Completion status of the module.
     */
    self.checkModuleCompletion = function(courseId, completion) {
        if (completion && completion.tracking === 2 && completion.state === 0) {
            self.invalidateSections(courseId).finally(function() {
                $mmEvents.trigger(mmCoreEventCompletionModuleViewed, courseId);
            });
        }
    };

    /**
     * Get completion status of all the activities in a course for a certain user.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getActivitiesCompletionStatus
     * @param  {Number} courseid Course ID.
     * @param  {Number} [userid] User ID. If not defined, current user.
     * @return {Promise}         Promise resolved with the completion statuses: object where the key is module ID.
     */
    self.getActivitiesCompletionStatus = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();

        $log.debug('Getting completion status for user ' + userid + ' in course ' + courseid);

        var params = {
                courseid: courseid,
                userid: userid
            },
            preSets = {
                cacheKey: getActivitiesCompletionCacheKey(courseid, userid)
            };

        return $mmSite.read('core_completion_get_activities_completion_status', params, preSets).then(function(data) {
            if (data && data.statuses) {
                var formattedStatuses = {};
                angular.forEach(data.statuses, function(status) {
                    formattedStatuses[status.cmid] = status;
                });
                return formattedStatuses;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for activities completion WS calls.
     *
     * @param  {Number} courseid Course ID.
     * @param  {Number} userid   User ID.
     * @return {String}          Cache key.
     */
    function getActivitiesCompletionCacheKey(courseid, userid) {
        return 'mmCourse:activitiescompletion:' + courseid + ':' + userid;
    }

    /**
     * Gets a module basic info by module ID.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleBasicInfo
     * @param  {Number} moduleId Module ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the module's info.
     */
    self.getModuleBasicInfo = function(moduleId, siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    cmid: moduleId
                },
                preSets = {
                    cacheKey: getModuleCacheKey(moduleId)
                };

            return site.read('core_course_get_course_module', params, preSets).then(function(response) {
                if (response.cm && (!response.warnings || !response.warnings.length)) {
                    return response.cm;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Gets a module basic info by instance.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleBasicInfoByInstance
     * @param {Number} id        Instance ID.
     * @param {String} module    Name of the module. E.g. 'glossary'.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the module's info.
     */
    self.getModuleBasicInfoByInstance = function(id, module, siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    instance: id,
                    module: module
                },
                preSets = {
                    cacheKey: getModuleByInstanceCacheKey(id, module)
                };

            return site.read('core_course_get_course_module_by_instance', params, preSets).then(function(response) {
                if (response.cm && (!response.warnings || !response.warnings.length)) {
                    return response.cm;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Get a module from Moodle.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModule
     * @param {Number} moduleId    The module ID.
     * @param {Number} [courseId]  The course ID. Recommended to speed up the process and minimize data usage.
     * @param {Number} [sectionId] The section ID.
     * @return {Promise}
     */
    self.getModule = function(moduleId, courseId, sectionId) {

        if (!moduleId) {
            return $q.reject();
        }

        var promise;

        if (!courseId) {
            // No courseId passed, try to retrieve it.
            promise = self.getModuleBasicInfo(moduleId).then(function(module) {
                return module.course;
            });
        } else {
            promise = $q.when(courseId);
        }

        return promise.then(function(courseId) {
            // We have courseId, we can use core_course_get_contents for compatibility.
            $log.debug('Getting module ' + moduleId + ' in course ' + courseId);

            params = {
                courseid: courseId,
                options: [
                    {
                        name: 'cmid',
                        value: moduleId
                    }
                ]
            };
            preSets = {
                cacheKey: getModuleCacheKey(moduleId)
            };

            if (sectionId) {
                params.options.push({
                    name: 'sectionid',
                    value: sectionId
                });
            }

            return $mmSite.read('core_course_get_contents', params, preSets).catch(function() {
                // Error getting the module. Try to get all contents (without filtering).
                params.options = [];
                preSets.cacheKey = getSectionsCacheKey(courseId);
                return $mmSite.read('core_course_get_contents', params, preSets);
            }).then(function(sections) {
                var section,
                    module;

                for (var i = 0; i < sections.length; i++) {
                    section = sections[i];
                    for (var j = 0; j < section.modules.length; j++) {
                        module = section.modules[j];
                        if (module.id == moduleId) {
                            module.course = courseId;
                            return addContentsIfNeeded(module);
                        }
                    }
                }
                return $q.reject();
            });
        });
    };

    /**
     * Get cache key for module WS calls.
     *
     * @param {Number} id     Instance ID.
     * @param {String} module Name of the module. E.g. 'glossary'.
     * @return {String}       Cache key.
     */
    function getModuleByInstanceCacheKey(id, module) {
        return 'mmCourse:moduleByInstance:' + module + ':' + id;
    }

    /**
     * Get cache key for module WS calls.
     *
     * @param {Number} moduleid Module ID.
     * @return {String}         Cache key.
     */
    function getModuleCacheKey(moduleid) {
        return 'mmCourse:module:' + moduleid;
    }

    /**
     * Returns the source to a module icon.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleIconSrc
     * @param {String} moduleName The module name.
     * @return {String} The IMG src.
     */
    self.getModuleIconSrc = function(moduleName) {
        if (mods.indexOf(moduleName) < 0) {
            moduleName = "external-tool";
        }

        return "img/mod/" + moduleName + ".svg";
    };

    /**
     * Get the section ID a module belongs to.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleSectionId
     * @param {Number} moduleId   The module ID.
     * @param {Number} [courseId] The course ID. Required if Moodle site is prior to 3.0.
     * @param {String} [siteId]   Site ID. If not defined, current site.
     * @return {Promise}
     */
    self.getModuleSectionId = function(moduleId, courseId, siteId) {

        if (!moduleId) {
            return $q.reject();
        }

        // Try to get the section using getModuleBasicInfo.
        return self.getModuleBasicInfo(moduleId, siteId).then(function(module) {
            return module.section;
        }).catch(function() {
            if (!courseId) {
                // It failed and we don't have courseId, reject.
                return $q.reject();
            }

            // Get all the sections in the course and iterate over them to find it.
            return self.getSections(courseId, {}, siteId).then(function(sections) {
                sections.forEach(function(section) {
                    section.modules.forEach(function(module) {
                        if (module.id == moduleId) {
                            return section.id;
                        }
                    });
                });
                // Not found.
                return $q.reject();
            });
        });
    };

    /**
     * Return a specific section.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getSection
     * @param {Number} courseid The course ID.
     * @param {Number} sectionid The section ID.
     * @return {Promise} The reject contains the error message, else contains the section.
     */
    self.getSection = function(courseid, sectionid) {
        var deferred = $q.defer();

        if (sectionid < 0) {
            deferred.reject('Invalid section ID');
            return deferred.promise;
        }

        self.getSections(courseid).then(function(sections) {
            for (var i = 0; i < sections.length; i++) {
                if (sections[i].id == sectionid) {
                    deferred.resolve(sections[i]);
                    return;
                }
            }
            deferred.reject('Unkown section');
        }, function(error) {
            deferred.reject(error);
        });

        return deferred.promise;
    };

    /**
     * Get the course sections.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getSections
     * @param {Number} courseid  The course ID.
     * @param {Object} [preSets] Optional. Presets to use.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise} The reject contains the error message, else contains the sections.
     */
    self.getSections = function(courseid, preSets, siteId) {
        preSets = preSets || {};
        siteId = siteId || $mmSite.getId();
        preSets.cacheKey = getSectionsCacheKey(courseid);

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.read('core_course_get_contents', {
                courseid: courseid,
                options: []
            }, preSets).then(function(sections) {
                angular.forEach(sections, function(section) {
                    angular.forEach(section.modules, function(module) {
                        addContentsIfNeeded(module);
                    });
                });
                return sections;
            });
        });
    };

    /**
     * Get cache key for section WS call.
     *
     * @param  {Number} courseid Course ID.
     * @return {String}          Cache key.
     */
    function getSectionsCacheKey(courseid) {
        return 'mmCourse:sections:' + courseid;
    }

    /**
     * Invalidates module WS call.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#invalidateModule
     * @param {Number} moduleid Module ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateModule = function(moduleid) {
        return $mmSite.invalidateWsCacheForKey(getModuleCacheKey(moduleid));
    };

    /**
     * Invalidates module WS call.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#invalidateModuleByInstance
     * @param {Number} id     Instance ID.
     * @param {String} module Name of the module. E.g. 'glossary'.
     * @return {Promise}      Promise resolved when the data is invalidated.
     */
    self.invalidateModuleByInstance = function(id, module) {
        return $mmSite.invalidateWsCacheForKey(getModuleByInstanceCacheKey(id, module));
    };

    /**
     * Invalidates sections WS call.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#invalidateSections
     * @param {Number} courseid  Course ID.
     * @param  {Number} [userid] User ID. If not defined, current user.
     * @return {Promise}         Promise resolved when the data is invalidated.
     */
    self.invalidateSections = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();

        var p1 = $mmSite.invalidateWsCacheForKey(getSectionsCacheKey(courseid)),
            p2 = $mmSite.invalidateWsCacheForKey(getActivitiesCompletionCacheKey(courseid, userid));
        return $q.all([p1, p2]);
    };

    /**
     * Translate a module name to current language.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#translateModuleName
     * @param {String} moduleName The module name.
     * @return {Promise}          Promise resolved with the translated name.
     */
    self.translateModuleName = function(moduleName) {
        if (mods.indexOf(moduleName) < 0) {
            moduleName = "external-tool";
        }

        var langkey = 'mm.core.mod_'+moduleName;
        return $translate(langkey).then(function(translated) {
            return translated !== langkey ? translated : moduleName;
        });
    };


    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Courses nav handler.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseCoursesNavHandler
 */
.factory('$mmCourseCoursesNavHandler', function() {
    return {

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        isEnabled: function() {
            return true;
        },

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean}          True if handler is enabled, false otherwise.
         */
        isEnabledForCourse: function() {
            return true;
        },

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        getController: function(courseId) {
            return function($scope, $state) {
                $scope.icon = 'ion-briefcase';
                $scope.title = 'mm.course.contents';

                $scope.action = function(e, course) {
                    $state.go('site.mm_course', {courseid: course.id});
                    e.preventDefault();
                    e.stopPropagation();
                };
            };
        }
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Delegate to register content handlers.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseDelegate
 * @description
 *
 * To register a content handler:
 *
 * .config($mmCourseDelegate, function() {
 *     $mmCourseDelegate.registerContentHandler('mmaYourAddon', 'moduleName', 'handlerName');
 *     $mmCourseDelegate.registerContentHandler('mmaModPage', 'page', '$mmaModPageCourseContentHandler');
 * })
 *
 * The content handler must provide two methods.
 *
 * 1/ isEnabled() which will be called once in a while to check if the plugin works on the current site.
 * 2/ getController(module, courseid) which should return a controller object
 *
 * The controller has its own scope inheriting the parent one. Though you should not use the
 * parent scope. To find out more what scope variables are expected look at the template
 * core/components/course/templates/section.html and at existing content handlers.
 */
.provider('$mmCourseDelegate', function() {
    var contentHandlers = {},
        self = {};

    /**
     * Register a content handler. If module is not supported in current site, handler should return undefined.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseDelegate#registerContentHandler
     * @param {String} addon The addon's name (mmaLabel, mmaForum, ...)
     * @param {String} handles The module this handler handles, e.g. forum, label. This value will be compared with
     *                         the value contained in module.modname from the Webservice core_course_get_contents.
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean) Whether or not the handler is enabled on a site level.
     *                             - getController(module, courseid) (Function) Returns the function that will act as controller.
     *                                                                See core/components/course/templates/section.html
     *                                                                for the list of scope variables expected.
     */
    self.registerContentHandler = function(addon, handles, handler) {
        if (typeof contentHandlers[handles] !== 'undefined') {
            console.log("$mmCourseDelegateProvider: Addon '" + contentHandlers[handles].addon + "' already registered as handler for '" + handles + "'");
            return false;
        }
        console.log("$mmCourseDelegateProvider: Registered addon '" + addon + "' as course content handler.");
        contentHandlers[handles] = {
            addon: addon,
            handler: handler,
            instance: undefined
        };
        return true;
    };

    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", "$mmCourseContentHandler", function($q, $log, $mmSite, $mmUtil, $mmCourseContentHandler) {
        var enabledHandlers = {},
            self = {};

        $log = $log.getInstance('$mmCourseDelegate');

        /**
         * Get the controller a content handler provides.
         *
         * This will first get the default data, then call the handler if any and override
         * the default data with the new data from the handler. That means that a handler
         * should always override any existing attribute if they want to change the defaults.
         *
         * @module mm.core.course
         * @ngdoc method
         * @name $mmCourseDelegate#getContentHandlerControllerFor
         * @param {String} handles   The module to work on
         * @param {Object} module    The module data
         * @param {Number} courseid  The course ID.
         * @param {Number} sectionid The section ID.
         * @return {Object}
         */
        self.getContentHandlerControllerFor = function(handles, module, courseid, sectionid) {
            if (typeof enabledHandlers[handles] !== 'undefined') {
                return enabledHandlers[handles].getController(module, courseid, sectionid);
            }
            return $mmCourseContentHandler.getController(module, courseid, sectionid);
        };

        /**
         * Update the enabled handlers for the current site.
         *
         * @module mm.core.course
         * @ngdoc method
         * @name $mmCourseDelegate#updateContentHandler
         * @param {String} handles The module this handler handles, e.g. forum, label. This value will be compared with
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateContentHandler = function(handles, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledHandlers[handles] = handlerInfo.instance;
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledHandlers[handles];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core.course
         * @ngdoc method
         * @name $mmCourseDelegate#updateContentHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateContentHandlers = function() {
            var promises = [],
                enabledHandlers = {};

            $log.debug('Updating content handlers for current site.');

            // Loop over all the content handlers.
            angular.forEach(contentHandlers, function(handlerInfo, handles) {
                promises.push(self.updateContentHandler(handles, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            });
        };

        return self;
    }];


    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Helper to gather some common course functions.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseHelper
 */
.factory('$mmCourseHelper', ["$q", "$mmCoursePrefetchDelegate", "$mmFilepool", "$mmUtil", "$mmCourse", "$mmSite", "$state", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreDownloading", "mmCoreCourseAllSectionsId", function($q, $mmCoursePrefetchDelegate, $mmFilepool, $mmUtil, $mmCourse, $mmSite, $state,
            mmCoreNotDownloaded, mmCoreOutdated, mmCoreDownloading, mmCoreCourseAllSectionsId) {

    var self = {};

    /**
     * Calculate the status of a section.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#calculateSectionStatus
     * @param {Object[]} section          Section to calculate its status. Can't be "All sections".
     * @param  {Number} courseid          Course ID the section belongs to.
     * @param {Boolean} restoreDownloads  True if it should restore downloads. It will try to restore this section downloads.
     * @param {Boolean} refresh           True if it shouldn't use module status cache (slower).
     * @param {Promise[]} [dwnpromises]   If section download is restored, a promise will be added to this array. Required
     *                                    if restoreDownloads=true.
     * @return {Promise}         Promise resolved when the state is calculated.
     */
    self.calculateSectionStatus = function(section, courseid, restoreDownloads, refresh, dwnpromises) {

        if (section.id !== mmCoreCourseAllSectionsId) {
            // Get the status of this section.
            return $mmCoursePrefetchDelegate.getModulesStatus(section.id, section.modules, courseid, refresh, restoreDownloads)
                    .then(function(result) {

                // Check if it's being downloaded. We can't trust status 100% because downloaded books are always outdated.
                var downloadid = self.getSectionDownloadId(section);
                if ($mmCoursePrefetchDelegate.isBeingDownloaded(downloadid)) {
                    result.status = mmCoreDownloading;
                }

                // Set this section data.
                section.showDownload = result.status === mmCoreNotDownloaded;
                section.showRefresh = result.status === mmCoreOutdated;

                if (result.status !== mmCoreDownloading) {
                    section.isDownloading = false;
                    section.total = 0;
                } else if (!restoreDownloads) {
                    // Set download data.
                    section.count = 0;
                    section.total = result[mmCoreOutdated].length + result[mmCoreNotDownloaded].length +
                                    result[mmCoreDownloading].length;
                    section.isDownloading = true;
                } else {
                    // Restore or re-start the prefetch.
                    var promise = self.startOrRestorePrefetch(section, result, courseid).then(function() {
                        // Re-calculate the status of this section once finished.
                        return self.calculateSectionStatus(section, courseid);
                    });
                    if (dwnpromises) {
                        dwnpromises.push(promise);
                    }
                }

                return result;
            });
        }
        return $q.reject();
    };

    /**
     * Calculate the status of a list of sections, setting attributes to determine the icons/data to be shown.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#calculateSectionsStatus
     * @param {Object[]} sections         Sections to calculate their status.
     * @param  {Number} courseid          Course ID the sections belong to.
     * @param {Boolean} restoreDownloads  True if it should restore downloads. It will try to restore section downloads
     * @param {Boolean} refresh           True if it shouldn't use module status cache (slower).
     * @return {Promise}                  Promise resolved when the states are calculated. Returns an array of download promises
     *                                    with the restored downloads (only if restoreDownloads=true).
     */
    self.calculateSectionsStatus = function(sections, courseid, restoreDownloads, refresh) {

        var allsectionssection,
            allsectionsstatus,
            downloadpromises = [],
            statuspromises = [];

        angular.forEach(sections, function(section) {
            if (section.id === mmCoreCourseAllSectionsId) {
                // "All sections" section status is calculated using the status of the rest of sections.
                allsectionssection = section;
            } else {
                statuspromises.push(self.calculateSectionStatus(section, courseid, restoreDownloads, refresh, downloadpromises)
                        .then(function(result) {

                    // Calculate "All sections" status.
                    allsectionsstatus = $mmFilepool.determinePackagesStatus(allsectionsstatus, result.status);
                }));
            }
        });

        return $q.all(statuspromises).then(function() {
            if (allsectionssection) {
                // Set "All sections" data.
                allsectionssection.showDownload = allsectionsstatus === mmCoreNotDownloaded;
                allsectionssection.showRefresh = allsectionsstatus === mmCoreOutdated;
                allsectionssection.isDownloading = allsectionsstatus === mmCoreDownloading;
            }
            return downloadpromises;
        });
    };

    /**
     * Calculate the size of the download and show a confirm modal if needed.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#confirmDownloadSize
     * @param {Number} courseid   Course ID the section belongs to.
     * @param {Object} section    Section.
     * @param {Object[]} sections List of sections. Used when downloading all the sections.
     * @return {Promise}          Promise resolved if the user confirms or there's no need to confirm.
     */
    self.confirmDownloadSize = function(courseid, section, sections) {
        var sizePromise;

        // Calculate the size of the download.
        if (section.id != mmCoreCourseAllSectionsId) {
            sizePromise = $mmCoursePrefetchDelegate.getDownloadSize(section.modules, courseid);
        } else {
            var promises = [],
                size = 0;
            angular.forEach(sections, function(s) {
                if (s.id != mmCoreCourseAllSectionsId) {
                    promises.push($mmCoursePrefetchDelegate.getDownloadSize(s.modules, courseid).then(function(sectionsize) {
                        size = size + sectionsize;
                    }));
                }
            });
            sizePromise = $q.all(promises).then(function() {
                return size;
            });
        }

        return sizePromise.then(function(size) {
            // Show confirm modal if needed.
            return $mmUtil.confirmDownloadSize(size);
        });
    };

    /**
     * Get the course ID from a module, showing an error message if it can't be retrieved.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#getModuleCourseId
     * @param {Number} id        Instance ID.
     * @param {String} module    Name of the module. E.g. 'glossary'.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the module's course ID.
     */
    self.getModuleCourseIdByInstance = function(id, module, siteId) {
        return $mmCourse.getModuleBasicInfoByInstance(id, module, siteId).then(function(cm) {
            return cm.course;
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.errorgetmodule', true);
            }
            return $q.reject();
        });
    };

    /**
     * Get the download ID of a section. It's used to interact with $mmCoursePrefetchDelegate.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#getSectionDownloadId
     * @param {Object} section Section.
     * @return {String}        Section download ID.
     */
    self.getSectionDownloadId = function(section) {
        return 'Section-'+section.id;
    };

    /**
     * Retrieves the courseId of the module and navigates to it.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#navigateToModule
     * @param  {Number} moduleId    Module's ID.
     * @param  {String} [siteId]    Site ID. If not defined, current site.
     * @param  {Number} [courseId]  Course ID. If not defined we'll try to retrieve it from the site.
     * @param  {Number} [sectionId] Section the module belongs to. If not defined we'll try to retrieve it from the site.
     * @return {Promise}            Promise resolved when the state changes.
     */
    self.navigateToModule = function(moduleId, siteId, courseId, sectionId) {
        siteId = siteId || $mmSite.getId();
        var modal = $mmUtil.showModalLoading(),
            promise;

        return $mmCourse.canGetModuleWithoutCourseId(siteId).then(function(enabled) {
            if (courseId && sectionId) {
                // No need to retrieve more data.
                promise = $q.when();
            } else if (!courseId && !enabled) {
                // We don't have enough data and we can't retrieve it.
                promise = $q.reject();
            } else if (!courseId) {
                // We don't have courseId but WS is enabled.
                promise = $mmCourse.getModuleBasicInfo(moduleId, siteId).then(function(module) {
                    courseId = module.course;
                    sectionId = module.section;
                });
            } else {
                // We don't have sectionId but we have courseId.
                promise = $mmCourse.getModuleSectionId(moduleId, courseId, siteId).then(function(id) {
                    sectionId = id;
                });
            }

            return promise.then(function() {
                return $state.go('redirect', {
                    siteid: siteId,
                    state: 'site.mm_course',
                    params: {
                        courseid: courseId,
                        moduleid: moduleId,
                        sid: sectionId
                    }
                });
            });
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.errorgetmodule', true);
            }
            return $q.reject();
        }).finally(function() {
            modal.dismiss();
        });
    };

    /**
     * Prefetch or restore the prefetch of one section or all the sections.
     * If the section is "All sections" it will prefetch all the sections.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#prefetch
     * @param  {Object} section    Section.
     * @param  {Number} courseid   Course ID the section belongs to.
     * @param  {Object[]} sections List of sections. Used when downloading all the sections.
     * @return {promise}           Promise resolved when the prefetch is finished.
     */
    self.prefetch = function(section, courseid, sections) {

        if (section.id != mmCoreCourseAllSectionsId) {
            // Download only this section.
            return self.prefetchSection(section, courseid, true, sections);
        } else {
            // Download all the sections except "All sections".
            // In case of a failure, we want that ALL promises have finished before rejecting the promise.
            var promises = [];

            section.isDownloading = true;
            angular.forEach(sections, function(s) {
                if (s.id != mmCoreCourseAllSectionsId) {
                    promises.push(self.prefetchSection(s, courseid, false, sections).then(function() {
                        // Calculate only the section that finished.
                        return self.calculateSectionStatus(s, courseid);
                    }));
                }
            });

            return $mmUtil.allPromises(promises);
        }
    };

    /**
     * Prefetch or restore the prefetch of a certain section if it needs to be prefetched.
     * If the section is "All sections" it will be ignored.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#prefetchSection
     * @param  {Object} section         Section to prefetch.
     * @param  {Number} courseid        Course ID the section belongs to.
     * @param  {Boolean} singleDownload True if user is only downloading this section, false if user is downloading all sections.
     * @param {Object[]} [sections]     List of sections. Used only if singleDownload is true.
     * @return {Promise}                Promise resolved when the section is prefetched.
     */
    self.prefetchSection = function(section, courseid, singleDownload, sections) {

        if (section.id == mmCoreCourseAllSectionsId) {
            return $q.when();
        }

        section.isDownloading = true;

        // Validate the section needs to be downloaded and calculate amount of modules that need to be downloaded.
        return $mmCoursePrefetchDelegate.getModulesStatus(section.id, section.modules, courseid).then(function(result) {
            if (result.status === mmCoreNotDownloaded || result.status === mmCoreOutdated || result.status === mmCoreDownloading) {
                var promise = self.startOrRestorePrefetch(section, result, courseid);
                if (singleDownload) {
                    // Re-calculate status to determine the right status for the "All sections" section.
                    self.calculateSectionsStatus(sections, courseid, false);
                }
                return promise;
            }
        }, function() {
            // This shouldn't happen.
            section.isDownloading = false;
            return $q.reject();
        });
    };

    /**
     * Start or restore the prefetch of a section.
     * If the section is "All sections" it will be ignored.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#startOrRestorePrefetch
     * @param {Object} section Section to download.
     * @param {Object} status  Result of $mmCoursePrefetchDelegate#getModulesStatus for this section.
     * @return {Promise}       Promise resolved when the section has been prefetched.
     */
    self.startOrRestorePrefetch = function(section, status, courseid) {

        if (section.id == mmCoreCourseAllSectionsId) {
            return $q.when();
        }

        // We only download modules with status notdownloaded, downloading or outdated.
        var modules = status[mmCoreOutdated].concat(status[mmCoreNotDownloaded]).concat(status[mmCoreDownloading]),
            downloadid = self.getSectionDownloadId(section),
            moduleids;

        moduleids = modules.map(function(m) {
            return m.id;
        });

        // Set download data.
        section.count = 0;
        section.total = modules.length;
        section.isDownloading = true;

        // We prefetch all the modules to prevent incoeherences in the download count
        // and also to download stale data that might not be marked as outdated.
        return $mmCoursePrefetchDelegate.prefetchAll(downloadid, modules, courseid).then(function() {}, function() {
            // Return a rejected promise so errors are handled outside of this function.
            return $q.reject();
        }, function(id) {
            // Progress. Check that the module downloaded is one of the expected ones.
            var index = moduleids.indexOf(id);
            if (index > -1) {
                // It's one of the modules we were expecting to download.
                moduleids.splice(index, 1);
                section.count++;
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Delegate to register prefetch handlers.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmCoursePrefetchDelegate
 * @description
 *
 * To register a prefetch handler:
 *
 * .config(function($mmCoursePrefetchDelegateProvider) {
 *     $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaYourAddon', 'moduleName', 'handlerName');
 * })
 *
 * To see the methods that must provide the prefetch handler see {@link $mmCoursePrefetchDelegateProvider#registerPrefetchHandler}.
 */
.provider('$mmCoursePrefetchDelegate', function() {
    var prefetchHandlers = {},
        self = {};

    /**
     * Register a prefetch handler.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmCoursePrefetchDelegateProvider#registerPrefetchHandler
     * @param {String} addon The addon's name (mmaLabel, mmaForum, ...)
     * @param {String} handles The module this handler handles, e.g. forum, label.
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these properties. See {@link $mmUtil#resolveObject}.
     *                             - component (String) Handler's component.
     *                             - getDownloadSize(module, courseid) (Number|Promise) Get the download size of a module.
     *                             - isEnabled() (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                             - prefetch(module, courseid) (Promise) Prefetches a module.
     *                             - (Optional) getFiles(module, courseid) (Object[]|Promise) Get list of files. If not defined,
     *                                                                      we'll assume they're in module.contents.
     *                             - (Optional) determineStatus(status) (String) Returns status to show based on current. E.g. for
     *                                                                 books we'll show "outdated" even if state is "downloaded".
     *                             - (Optional) getRevision(module, courseid) (String|Number|Promise) Returns the module revision.
     *                                                                 If not defined we'll calculate it using module files.
     *                             - (Optional) getTimemodified(module, courseid) (Number|Promise) Returns the module timemodified.
     *                                                                 If not defined we'll calculate it using module files.
     */
    self.registerPrefetchHandler = function(addon, handles, handler) {
        if (typeof prefetchHandlers[handles] !== 'undefined') {
            console.log("$mmCoursePrefetchDelegateProvider: Addon '" + prefetchHandlers[handles].addon +
                            "' already registered as handler for '" + handles + "'");
            return false;
        }
        console.log("$mmCoursePrefetchDelegateProvider: Registered addon '" + addon + "' as prefetch handler.");
        prefetchHandlers[handles] = {
            addon: addon,
            handler: handler,
            instance: undefined
        };
        return true;
    };

    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", "$mmFilepool", "$mmEvents", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreNotDownloadable", "mmCoreEventSectionStatusChanged", function($q, $log, $mmSite, $mmUtil, $mmFilepool, $mmEvents, mmCoreDownloaded, mmCoreDownloading,
                mmCoreNotDownloaded, mmCoreOutdated, mmCoreNotDownloadable, mmCoreEventSectionStatusChanged) {
        var enabledHandlers = {},
            self = {},
            deferreds = {},
            statusCache = {}; // To speed up the getModulesStatus function.

        $log = $log.getInstance('$mmCoursePrefetchDelegate');

        /**
         * Clear the status cache (memory object).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#clearStatusCache
         * @return {Void}
         */
        self.clearStatusCache = function() {
            statusCache = {};
        };

        /**
         * Determines a module status based on current status, restoring downloads if needed.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#determineModuleStatus
         * @param  {Object} module           Module.
         * @param  {String} status           Current status.
         * @param {Boolean} restoreDownloads True if it should restore downloads if needed.
         * @return {String}                  Module status.
         */
        self.determineModuleStatus = function(module, status, restoreDownloads) {
            var handler = enabledHandlers[module.modname];

            if (handler) {
                if (status == mmCoreDownloading && restoreDownloads) {
                    // Check if the download is being handled.
                    if (!$mmFilepool.getPackageDownloadPromise($mmSite.getId(), handler.component, module.id)) {
                        // Not handled, the app was probably restarted or something weird happened.
                        // Re-start download (files already on queue or already downloaded will be skipped).
                        handler.prefetch(module);
                    }
                } else if (handler.determineStatus) {
                    // The handler implements a determineStatus function. Apply it.
                    return handler.determineStatus(status);
                }
            }
            return status;
        };

        /**
         * Get modules download size. Only treat the modules with status not downloaded or outdated.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getDownloadSize
         * @param  {Object[]} modules List of modules.
         * @param  {Number} courseid  Course ID the modules belong to.
         * @return {Promise}          Promise resolved with the download size.
         */
        self.getDownloadSize = function(modules, courseid) {
            var size = 0,
                promises = [];

            angular.forEach(modules, function(module) {
                // Prevent null contents.
                module.contents = module.contents || [];

                // Check if the module has a prefetch handler.
                var handler = enabledHandlers[module.modname];
                if (handler) {
                    // Check if the file will be downloaded.
                    promises.push(self.getModuleStatus(module, courseid).then(function(modstatus) {
                        if (modstatus === mmCoreNotDownloaded || modstatus === mmCoreOutdated) {
                            return $q.when(handler.getDownloadSize(module, courseid)).then(function(modulesize) {
                                // Add the size of the downloadable files.
                                size = size + modulesize;
                            }).catch(function() {
                                // Ignore errors.
                            });
                        }
                    }));
                }
            });

            return $q.all(promises).then(function() {
                return size;
            });
        };

        /**
         * Get the module status.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getModuleStatus
         * @param {Object} module         Module.
         * @param {Number} courseid       Course ID the module belongs to.
         * @param {Number} [revision]     Module's revision. If not defined, it will be calculated using module data.
         * @param {Number} [timemodified] Module's timemodified. If not defined, it will be calculated using module data.
         * @return {Promise}              Promise resolved with the status.
         */
        self.getModuleStatus = function(module, courseid, revision, timemodified) {
            var handler = enabledHandlers[module.modname],
                siteid = $mmSite.getId();
            module.contents = module.contents || [];

            if (handler) {
                // If the handler doesn't define a function to get the files, use module.contents.
                var promise = handler.getFiles ? $q.when(handler.getFiles(module, courseid)) : $q.when(module.contents);

                return promise.then(function(files) {

                    if (files.length === 0) { // No files, treat is as downloaded.
                        return $q.when(mmCoreDownloaded);
                    }

                    // Get revision and timemodified if they aren't defined.
                    // If handler doesn't define a function to get them, get them from file list.
                    var promises = [];

                    if (typeof revision == 'undefined') {
                        if (handler.getRevision) {
                            promises.push($q.when(handler.getRevision(module, courseid)).then(function(rev) {
                                revision = rev;
                            }));
                        } else {
                            revision = $mmFilepool.getRevisionFromFileList(files);
                        }
                    }

                    if (typeof timemodified == 'undefined') {
                        if (handler.getTimemodified) {
                            promises.push($q.when(handler.getTimemodified(module, courseid)).then(function(timemod) {
                                timemodified = timemod;
                            }));
                        } else {
                            timemodified = $mmFilepool.getTimemodifiedFromFileList(files);
                        }
                    }

                    return $q.all(promises).then(function() {
                        // Now get the status.
                        return $mmFilepool.getPackageStatus(siteid, handler.component, module.id, revision, timemodified)
                                .then(function(status) {
                            return self.determineModuleStatus(module, status, true);
                        });
                    });
                });
            }

            return $q.reject();
        };

        /**
         * Get the status of a list of modules, along with the lists of modules for each status.
         * @see {@link $mmFilepool#determinePackagesStatus}
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getModulesStatus
         * @param  {String} sectionid         ID of the section the modules belong to.
         * @param  {Object[]} modules         List of modules to prefetch.
         * @param  {Number} courseid          Course ID the modules belong to.
         * @param  {Boolean} refresh          True if it should always check the DB (slower).
         * @param {Boolean} restoreDownloads  True if it should restore downloads. It's only used if refresh=false,
         *                                    if refresh=true then it always tries to restore downloads.
         * @return {Promise}                  Promise resolved with an object with the following properties:
         *                                            - status (String) Status of the module.
         *                                            - total (Number) Number of modules.
         *                                            - mmCoreNotDownloaded (Object[]) Modules with state mmCoreNotDownloaded.
         *                                            - mmCoreDownloaded (Object[]) Modules with state mmCoreDownloaded.
         *                                            - mmCoreDownloading (Object[]) Modules with state mmCoreDownloading.
         *                                            - mmCoreOutdated (Object[]) Modules with state mmCoreOutdated.
         */
        self.getModulesStatus = function(sectionid, modules, courseid, refresh, restoreDownloads) {

            var promises = [],
                status = mmCoreNotDownloadable,
                result = {};

            // Init result.
            result[mmCoreNotDownloaded] = [];
            result[mmCoreDownloaded] = [];
            result[mmCoreDownloading] = [];
            result[mmCoreOutdated] = [];
            result.total = 0;

            angular.forEach(modules, function(module) {
                // Check if the module has a prefetch handler.
                var handler = enabledHandlers[module.modname],
                    promise;
                // Prevent null contents.
                module.contents = module.contents || [];

                if (handler) {
                    var packageId = $mmFilepool.getPackageId(handler.component, module.id);
                    if (!refresh && statusCache[packageId] && statusCache[packageId].status) {
                        promise = $q.when(self.determineModuleStatus(module, statusCache[packageId].status, restoreDownloads));
                    } else {
                        promise = self.getModuleStatus(module, courseid);
                    }

                    promises.push(promise.then(function(modstatus) {
                        // Update status cache.
                        statusCache[packageId] = {
                            status: modstatus,
                            sectionid: sectionid
                        };
                        status = $mmFilepool.determinePackagesStatus(status, modstatus);
                        result[modstatus].push(module);
                        result.total++;
                    }));
                }
            });

            return $q.all(promises).then(function() {
                result.status = status;
                return result;
            });
        };

        /**
         * Get a prefetch handler.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getPrefetchHandlerFor
         * @param {String} handles The module to work on.
         * @return {Object}        Prefetch handler.
         */
        self.getPrefetchHandlerFor = function(handles) {
            return enabledHandlers[handles];
        };

        /**
         * Check if a list of modules is being downloaded.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#isBeingDownloaded
         * @param  {String} id An ID to identify the download.
         * @return {Boolean}   True if it's being downloaded, false otherwise.
         */
        self.isBeingDownloaded = function(id) {
            return deferreds[$mmSite.getId()] && deferreds[$mmSite.getId()][id];
        };

        /**
         * Prefetches a list of modules using their prefetch handlers.
         * If a prefetch already exists for this site and id, returns the current promise.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getPrefetchHandlerFor
         * @param  {String} siteid    Site ID.
         * @param  {String} id        An ID to identify the download. It can be used to retrieve the download promise.
         * @param  {Object[]} modules List of modules to prefetch.
         * @param  {Number} courseid  Course ID the modules belong to.
         * @return {Promise}          Promise resolved when all modules have been prefetched. Notify is called everytime
         *                            a module is prefetched, passing the module id as param.
         */
        self.prefetchAll = function(id, modules, courseid) {

            var siteid = $mmSite.getId();

            if (deferreds[siteid] && deferreds[siteid][id]) {
                // There's a prefetch ongoing, return the current promise.
                return deferreds[siteid][id].promise;
            }

            var deferred = $q.defer(),
                promises = [];

            // Store the deferred.
            if (!deferreds[siteid]) {
                deferreds[siteid] = {};
            }
            deferreds[siteid][id] = deferred;

            angular.forEach(modules, function(module) {
                // Prevent null contents.
                module.contents = module.contents || [];

                // Check if the module has a prefetch handler.
                var handler = enabledHandlers[module.modname];
                if (handler) {
                    promises.push(handler.prefetch(module, courseid).then(function() {
                        deferred.notify(module.id);
                    }));
                }
            });

            $q.all(promises).then(function() {
                delete deferreds[siteid][id]; // Remove from array before resolving.
                deferred.resolve();
            }, function() {
                delete deferreds[siteid][id]; // Remove from array before rejecting.
                deferred.reject();
            });

            return deferred.promise;
        };

        /**
         * Update the enabled handlers for the current site.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#updatePrefetchHandler
         * @param {String} handles The module this handler handles, e.g. forum, label.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updatePrefetchHandler = function(handles, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the prefetch is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledHandlers[handles] = handlerInfo.instance;
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledHandlers[handles];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#updatePrefetchHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updatePrefetchHandlers = function() {
            var promises = [];

            $log.debug('Updating prefetch handlers for current site.');

            // Loop over all the prefetch handlers.
            angular.forEach(prefetchHandlers, function(handlerInfo, handles) {
                promises.push(self.updatePrefetchHandler(handles, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            });
        };

        /**
         * Update the status of a module in the "cache".
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#updateStatusCache
         * @return {Void}
         */
        self.updateStatusCache = function(component, componentId, status) {
            var notify = false,
                packageid = $mmFilepool.getPackageId(component, componentId);

            if (statusCache[packageid]) {
                // If the status has changed, notify that the section has changed.
                notify = statusCache[packageid].status !== status;
            } else {
                statusCache[packageid] = {};
            }
            statusCache[packageid].status = status;

            if (notify) {
                $mmEvents.trigger(mmCoreEventSectionStatusChanged, {
                    sectionid: statusCache[packageid].sectionid,
                    siteid: $mmSite.getId()
                });
            }
        };

        return self;
    }];


    return self;
})

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmCoursePrefetchDelegate", "$mmSite", "mmCoreEventPackageStatusChanged", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmCoursePrefetchDelegate, $mmSite,
            mmCoreEventPackageStatusChanged) {
    $mmEvents.on(mmCoreEventLogin, $mmCoursePrefetchDelegate.updatePrefetchHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCoursePrefetchDelegate.updatePrefetchHandlers);
    $mmEvents.on(mmCoreEventLogout, $mmCoursePrefetchDelegate.clearStatusCache);
    $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
        if (data.siteid === $mmSite.getId()) {
            $mmCoursePrefetchDelegate.updateStatusCache(data.component, data.componentId, data.status);
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Controller to handle the courses list.
 *
 * @module mm.core.courses
 * @ngdoc controller
 * @name mmCoursesListCtrl
 */
.controller('mmCoursesListCtrl', ["$scope", "$mmCourses", "$mmCoursesDelegate", "$mmUtil", "$mmEvents", "$mmSite", "mmCoursesEventMyCoursesUpdated", function($scope, $mmCourses, $mmCoursesDelegate, $mmUtil, $mmEvents, $mmSite,
            mmCoursesEventMyCoursesUpdated) {

    $scope.searchEnabled = $mmCourses.isSearchCoursesAvailable();
    $scope.areNavHandlersLoadedFor = $mmCoursesDelegate.areNavHandlersLoadedFor;

    // Convenience function to fetch courses.
    function fetchCourses(refresh) {
        return $mmCourses.getUserCourses().then(function(courses) {
            $scope.courses = courses;
            angular.forEach(courses, function(course) {
                course._handlers = $mmCoursesDelegate.getNavHandlersFor(course.id, refresh);
            });
            $scope.filterText = ''; // Filter value MUST be set after courses are shown.
        }, function(error) {
            if (typeof error != 'undefined' && error !== '') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.courses.errorloadcourses', true);
            }
        });
    }
    fetchCourses().finally(function() {
        $scope.coursesLoaded = true;
    });

    $scope.refreshCourses = function() {
        $mmCourses.invalidateUserCourses().finally(function() {
            fetchCourses(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    $mmEvents.on(mmCoursesEventMyCoursesUpdated, function(siteid) {
        if (siteid == $mmSite.getId()) {
            fetchCourses();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Controller to handle search courses.
 *
 * @module mm.core.courses
 * @ngdoc controller
 * @name mmCoursesSearchCtrl
 */
.controller('mmCoursesSearchCtrl', ["$scope", "$mmCourses", "$q", "$mmUtil", function($scope, $mmCourses, $q, $mmUtil) {

    var page = 0,
    	currentSearch = '';

    $scope.searchText = '';

    // Convenience function to search courses.
    function searchCourses(refresh) {
        if (refresh) {
            page = 0;
        }

        return $mmCourses.search(currentSearch, page).then(function(response) {
            if (page === 0) {
                $scope.courses = response.courses;
            } else {
                $scope.courses = $scope.courses.concat(response.courses);
            }
            $scope.total = response.total;

            page++;
            $scope.canLoadMore = $scope.courses.length < $scope.total;

        }).catch(function(message) {
            $scope.canLoadMore = false;
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.searchcourses.errorsearching', true);
            }
            return $q.reject();
        });
    }

    $scope.search = function(text) {
        currentSearch = text;
        $scope.courses = undefined;

    	var modal = $mmUtil.showModalLoading('mm.core.searching', true);
    	searchCourses(true).finally(function() {
            modal.dismiss();
    	});
    };

    $scope.loadMoreResults = function() {
    	searchCourses();
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Controller to handle view a course that was searched.
 *
 * @module mm.core.courses
 * @ngdoc controller
 * @name mmCoursesViewResultCtrl
 */
.controller('mmCoursesViewResultCtrl', ["$scope", "$stateParams", "$mmCourses", "$mmCoursesDelegate", "$mmUtil", "$translate", "$q", "$ionicModal", "$mmEvents", "$mmSite", "mmCoursesSearchComponent", "mmCoursesEnrolInvalidKey", "mmCoursesEventMyCoursesUpdated", function($scope, $stateParams, $mmCourses, $mmCoursesDelegate, $mmUtil, $translate, $q,
            $ionicModal, $mmEvents, $mmSite, mmCoursesSearchComponent, mmCoursesEnrolInvalidKey, mmCoursesEventMyCoursesUpdated) {

    var course = $stateParams.course || {},
        selfEnrolWSAvailable = $mmCourses.isSelfEnrolmentEnabled(),
        guestWSAvailable = $mmCourses.isGuestWSAvailable(),
        isGuestEnabled = false,
        guestInstanceId,
        handlersShouldBeShown = true,
        enrollmentMethods;

    $scope.course = course;
    $scope.title = course.fullname;
    $scope.component = mmCoursesSearchComponent;
    $scope.selfEnrolInstances = [];
    $scope.enroldata = {
        password: ''
    };

    // Function to determine if handlers are being loaded.
    $scope.loadingHandlers = function() {
        return handlersShouldBeShown && !$mmCoursesDelegate.areNavHandlersLoadedFor(course.id);
    };

    // Convenience function to get course. We use this to determine if a user can see the course or not.
    function getCourse(refresh) {
        var promise;
        if (selfEnrolWSAvailable || guestWSAvailable) {
            // Get course enrolment methods.
            $scope.selfEnrolInstances = [];
            promise = $mmCourses.getCourseEnrolmentMethods(course.id).then(function(methods) {
                enrollmentMethods = methods;

                angular.forEach(enrollmentMethods, function(method) {
                    if (selfEnrolWSAvailable && method.type === 'self') {
                        $scope.selfEnrolInstances.push(method);
                    } else if (guestWSAvailable && method.type === 'guest') {
                        isGuestEnabled = true;
                    }
                });
            }).catch(function(error) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                }
            });
        } else {
            promise = $q.when(); // No need to get enrolment methods.
        }

        return promise.then(function() {
            // Check if user is enrolled in the course.
            return $mmCourses.getUserCourse(course.id).then(function(c) {
                $scope.isEnrolled = true;
                return c;
            }).catch(function() {
                // The user is not enrolled in the course. Use getCourses to see if it's an admin/manager and can see the course.
                $scope.isEnrolled = false;
                return $mmCourses.getCourse(course.id);
            }).then(function(c) {
                // Success retrieving the course, we can assume the user has permissions to view it.
                course.fullname = c.fullname || course.fullname;
                course.summary = c.summary || course.summary;
                course._handlers = $mmCoursesDelegate.getNavHandlersFor(course.id, refresh);
            }).catch(function() {
                // The user is not an admin/manager. Check if we can provide guest access to the course.
                return canAccessAsGuest().then(function(passwordRequired) {
                    if (!passwordRequired) {
                        course._handlers = $mmCoursesDelegate.getNavHandlersForGuest(course.id, refresh);
                    } else {
                        course._handlers = [];
                        handlersShouldBeShown = false;
                    }
                }).catch(function() {
                    course._handlers = [];
                    handlersShouldBeShown = false;
                });
            });
        });
    }

    // Convenience function to check if the user can access as guest.
    function canAccessAsGuest() {
        if (!isGuestEnabled) {
            return $q.reject();
        }

            // Search instance ID of guest enrolment method.
        angular.forEach(enrollmentMethods, function(method) {
            if (method.type == 'guest') {
                guestInstanceId = method.id;
            }
        });

        if (guestInstanceId) {
            return $mmCourses.getCourseGuestEnrolmentInfo(guestInstanceId).then(function(info) {
                if (!info.status) {
                    // Not active, reject.
                    return $q.reject();
                }
                return info.passwordrequired;
            });
        }
        return $q.reject();
    }

    function refreshData() {
        var promises = [];

        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourses.invalidateCourse(course.id));
        promises.push($mmCourses.invalidateCourseEnrolmentMethods(course.id));
        if (guestInstanceId) {
            promises.push($mmCourses.invalidateCourseGuestEnrolmentInfo(guestInstanceId));
        }

        return $q.all(promises).finally(function() {
            return getCourse(true);
        });
    }

    getCourse().finally(function() {
        $scope.courseLoaded = true;
    });

    $scope.doRefresh = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    if (selfEnrolWSAvailable && course.enrollmentmethods.indexOf('self') > -1) {
        // Setup password modal for self-enrolment.
        $ionicModal.fromTemplateUrl('core/components/courses/templates/password-modal.html', {
            scope: $scope,
            animation: 'slide-in-up'
        }).then(function(modal) {
            $scope.modal = modal;

            $scope.closeModal = function() {
                $scope.enroldata.password = '';
                delete $scope.currentEnrolInstance;
                modal.hide();
            };
            $scope.$on('$destroy', function() {
                modal.remove();
            });
        });

        // Convenience function to self-enrol a user in a course.
        $scope.enrol = function(instanceId, password) {
            var promise;

            if ($scope.modal.isShown()) {
                // Don't show confirm if password is shown, we already showed it before.
                promise = $q.when();
            } else {
                promise = $mmUtil.showConfirm($translate('mm.courses.confirmselfenrol'));
            }

            promise.then(function() {
                var modal = $mmUtil.showModalLoading('mm.core.loading', true);

                $mmCourses.selfEnrol(course.id, password, instanceId).then(function() {
                    // Close modal and refresh data.
                    $scope.closeModal();
                    $scope.isEnrolled = true;
                    refreshData().finally(function() {
                        // My courses have been updated, trigger event.
                        $mmEvents.trigger(mmCoursesEventMyCoursesUpdated, $mmSite.getId());
                    });
                }).catch(function(error) {
                    if (error) {
                        if (error.code === mmCoursesEnrolInvalidKey) {
                            // Invalid password. If password was already shown, show error message.
                            if ($scope.modal.isShown()) {
                                $mmUtil.showErrorModal(error.message);
                            } else {
                                $scope.currentEnrolInstance = instanceId;
                                $scope.modal.show();
                            }
                        } else if (typeof error == 'string') {
                            $mmUtil.showErrorModal(error);
                        }
                    } else {
                        $mmUtil.showErrorModal('mm.courses.errorselfenrol', true);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            });
        };
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Service to handle site courses.
 *
 * @module mm.core.courses
 * @ngdoc service
 * @name $mmCourses
 */
.factory('$mmCourses', ["$q", "$mmSite", "$log", "$mmSitesManager", "mmCoursesSearchPerPage", "mmCoursesEnrolInvalidKey", function($q, $mmSite, $log, $mmSitesManager, mmCoursesSearchPerPage, mmCoursesEnrolInvalidKey) {

    $log = $log.getInstance('$mmCourses');

    var self = {},
        currentCourses = {};

    /**
     * DEPRECATED: this function will be removed in a future version.
     * Clear current courses array. Reserved for core use.
     *
     * @deprecated since version 2.5
     * @protected
     */
    self.clearCurrentCourses = function() {
        currentCourses = {};
    };

    /**
     * Get course.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourse
     * @param {Number} id       ID of the course to get.
     * @param {String} [siteid] Site to get the courses from. If not defined, use current site.
     * @return {Promise}        Promise to be resolved when the courses are retrieved.
     */
    self.getCourse = function(id, siteid) {
        return self.getCourses([id], siteid).then(function(courses) {
            if (courses && courses.length > 0) {
                return courses[0];
            }
            return $q.reject();
        });
    };

    /**
     * Get the enrolment methods from a course.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourseEnrolmentMethods
     * @param {Number} id ID of the course.
     * @return {Promise}  Promise to be resolved when the methods are retrieved.
     */
    self.getCourseEnrolmentMethods = function(id) {
        var params = {
                courseid: id
            },
            preSets = {
                cacheKey: getCourseEnrolmentMethodsCacheKey(id)
            };

        return $mmSite.read('core_enrol_get_course_enrolment_methods', params, preSets);
    };

    /**
     * Get cache key for get course enrolment methods WS call.
     *
     * @param  {Number} id Course ID.
     * @return {String}    Cache key.
     */
    function getCourseEnrolmentMethodsCacheKey(id) {
        return 'mmCourses:enrolmentmethods:' + id;
    }

    /**
     * Get info from a course guest enrolment method.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourseGuestEnrolmentInfo
     * @param {Number} instanceId Guest instance ID.
     * @return {Promise}          Promise to be resolved when the info is retrieved.
     */
    self.getCourseGuestEnrolmentInfo = function(instanceId) {
        var params = {
                instanceid: instanceId
            },
            preSets = {
                cacheKey: getCourseGuestEnrolmentInfoCacheKey(instanceId)
            };

        return $mmSite.read('enrol_guest_get_instance_info', params, preSets).then(function(response) {
            return response.instanceinfo;
        });
    };

    /**
     * Get cache key for get course enrolment methods WS call.
     *
     * @param {Number} instanceId Guest instance ID.
     * @return {String}           Cache key.
     */
    function getCourseGuestEnrolmentInfoCacheKey(instanceId) {
        return 'mmCourses:guestinfo:' + instanceId;
    }

    /**
     * Get courses.
     * Warning: if the user doesn't have permissions to view some of the courses passed the WS call will fail.
     * The user must be able to view ALL the courses passed.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourses
     * @param {Number[]} ids    List of IDs of the courses to get.
     * @param {String} [siteid] Site to get the courses from. If not defined, use current site.
     * @return {Promise}        Promise to be resolved when the courses are retrieved.
     */
    self.getCourses = function(ids, siteid) {
        siteid = siteid || $mmSite.getId();

        if (!angular.isArray(ids)) {
            return $q.reject();
        } else if (ids.length === 0) {
            return $q.when([]);
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {

            var data = {
                    options: {
                        ids: ids
                    }
                },
                preSets = {
                    cacheKey: getCoursesCacheKey(ids)
                };

            return site.read('core_course_get_courses', data, preSets).then(function(courses) {
                if (typeof courses != 'object' && !angular.isArray(courses)) {
                    return $q.reject();
                }
                return courses;
            });
        });
    };

    /**
     * Get cache key for get courses WS call.
     *
     * @param  {Number[]} ids Courses IDs.
     * @return {String}       Cache key.
     */
    function getCoursesCacheKey(ids) {
        return 'mmCourses:course:' + JSON.stringify(ids);
    }

    /**
     * DEPRECATED: this function will be removed in a future version. Please use $mmCourses#getUserCourse.
     * Get a course stored in memory.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getStoredCourse
     * @param  {Number} id ID of the course to get.
     * @return {Object}    Course.
     * @deprecated since version 2.5
     */
    self.getStoredCourse = function(id) {
        $log.warn('The function \'getStoredCourse\' is deprecated. Please use \'getUserCourse\' instead');
        return currentCourses[id];
    };

    /**
     * Get a course the user is enrolled in. This function relies on $mmCourses#getUserCourses.
     * preferCache=true will try to speed up the response, but the data returned might not be updated.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getUserCourse
     * @param {Number} id                   ID of the course to get.
     * @param {Boolean} [preferCache=false] True if shouldn't call WS if data is cached, false otherwise.
     * @param {String} [siteid]             Site to get the courses from. If not defined, use current site.
     * @return {Promise}                    Promise resolved with the course.
     * @since 2.5
     */
    self.getUserCourse = function(id, preferCache, siteid) {
        siteid = siteid || $mmSite.getId();

        if (!id) {
            return $q.reject();
        }

        if (typeof preferCache == 'undefined') {
            preferCache = false;
        }

        return self.getUserCourses(preferCache, siteid).then(function(courses) {
            var course;
            angular.forEach(courses, function(c) {
                if (c.id == id) {
                    course = c;
                }
            });
            return course ? course : $q.reject();
        });
    };

    /**
     * Get user courses.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getUserCourses
     * @param {Boolean} [preferCache=false] True if shouldn't call WS if data is cached, false otherwise.
     * @param {String} [siteid]            Site to get the courses from. If not defined, use current site.
     * @return {Promise}                   Promise to be resolved when the courses are retrieved.
     */
    self.getUserCourses = function(preferCache, siteid) {
        siteid = siteid || $mmSite.getId();
        if (typeof preferCache == 'undefined') {
            preferCache = false;
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {

            var userid = site.getUserId(),
                presets = {
                    cacheKey: getUserCoursesCacheKey(),
                    omitExpires: preferCache
                },
                data = {userid: userid};

            if (typeof userid === 'undefined') {
                return $q.reject();
            }

            return site.read('core_enrol_get_users_courses', data, presets).then(function(courses) {
                if (siteid === $mmSite.getId()) {
                    // Only store courses if we're getting current site courses. This function is deprecated and will be removed.
                    storeCoursesInMemory(courses);
                }
                return courses;
            });
        });
    };

    /**
     * Get cache key for get user courses WS call.
     *
     * @return {String}       Cache key.
     */
    function getUserCoursesCacheKey() {
        return 'mmCourses:usercourses';
    }

    /**
     * Invalidates get course WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateCourse
     * @param  {Number} id Course ID.
     * @return {Promise}   Promise resolved when the data is invalidated.
     */
    self.invalidateCourse = function(id, siteid) {
        return self.invalidateCourses([id], siteid);
    };

    /**
     * Invalidates get course enrolment methods WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateUserCourses
     * @param {Number} id Course ID.
     * @return {Promise}  Promise resolved when the data is invalidated.
     */
    self.invalidateCourseEnrolmentMethods = function(id) {
        return $mmSite.invalidateWsCacheForKey(getCourseEnrolmentMethodsCacheKey(id));
    };

    /**
     * Invalidates get course guest enrolment info WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateUserCourses
     * @param {Number} instanceId Guest instance ID.
     * @return {Promise}          Promise resolved when the data is invalidated.
     */
    self.invalidateCourseGuestEnrolmentInfo = function(instanceId) {
        return $mmSite.invalidateWsCacheForKey(getCourseGuestEnrolmentInfoCacheKey(instanceId));
    };

    /**
     * Invalidates get courses WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateCourses
     * @param  {Number[]} ids   Courses IDs.
     * @param {String} [siteid] Site ID to invalidate. If not defined, use current site.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateCourses = function(ids, siteid) {
        siteid = siteid || $mmSite.getId();
        return $mmSitesManager.getSite(siteid).then(function(site) {
            return site.invalidateWsCacheForKey(getCoursesCacheKey(ids));
        });
    };

    /**
     * Invalidates get user courses WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateUserCourses
     * @param {String} [siteid] Site ID to invalidate. If not defined, use current site.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateUserCourses = function(siteid) {
        siteid = siteid || $mmSite.getId();
        return $mmSitesManager.getSite(siteid).then(function(site) {
            return site.invalidateWsCacheForKey(getUserCoursesCacheKey());
        });
    };

    /**
     * Check if WS to retrieve guest enrolment data is available.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#isGuestWSAvailable
     * @return {Boolean} True if guest WS is available, false otherwise.
     */
    self.isGuestWSAvailable = function() {
        return $mmSite.wsAvailable('enrol_guest_get_instance_info');
    };

    /**
     * Check if search courses feature is available in the current site.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#isSearchCoursesAvailable
     * @return {Boolean} True if is available, false otherwise.
     */
    self.isSearchCoursesAvailable = function() {
        return $mmSite.wsAvailable('core_course_search_courses');
    };

    /**
     * Check if self enrolment is available.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#isSelfEnrolmentEnabled
     * @return {Boolean} True if self enrolment is available, false otherwise.
     */
    self.isSelfEnrolmentEnabled = function() {
        return $mmSite.wsAvailable('enrol_self_enrol_user');
    };

    /**
     * Search courses.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#search
     * @param {String} text      Text to search.
     * @param {Number} [page]    Page to get. Defaults to 0.
     * @param {Number} [perpage] Number of courses per page. Defaults to mmCoursesSearchPerPage.
     * @return {Promise}         Promise resolved with the courses and the total of matches.
     */
    self.search = function(text, page, perpage) {
        page = page || 0;
        perpage = perpage || mmCoursesSearchPerPage;

        var params = {
                criterianame: 'search',
                criteriavalue: text,
                page: page,
                perpage: perpage
            }, preSets = {
                getFromCache: false
            };

        return $mmSite.read('core_course_search_courses', params, preSets).then(function(response) {
            if (typeof response == 'object') {
                return {total: response.total, courses: response.courses};
            }
            return $q.reject();
        });
    };

    /**
     * Self enrol current user in a certain course.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#selfEnrol
     * @param {String} courseid     Course ID.
     * @param {String} [password]   Password to use.
     * @param {Number} [instanceId] Enrol instance ID.
     * @return {Promise}            Promise resolved if the user is enrolled. If the password is invalid,
     *                              the promise is rejected with an object with code = mmCoursesEnrolInvalidKey.
     */
    self.selfEnrol = function(courseid, password, instanceId) {
        if (typeof password == 'undefined') {
            password = '';
        }

        var params = {
            courseid: courseid,
            password: password
        };
        if (instanceId) {
            params.instanceid = instanceId;
        }

        return $mmSite.write('enrol_self_enrol_user', params).then(function(response) {
            if (response) {
                if (response.status) {
                    return true;
                } else if (response.warnings && response.warnings.length) {
                    var message;
                    angular.forEach(response.warnings, function(warning) {
                        if (warning.warningcode == '2' || warning.warningcode == '4') { // Invalid password warnings.
                            message = warning.message;
                        }
                    });

                    if (message) {
                        return $q.reject({code: mmCoursesEnrolInvalidKey, message: message});
                    }
                }
            }
            return $q.reject();
        });
    };

    /**
     * DEPRECATED: this function will be removed in a future version.
     * Stores a list of courses in memory so they can be retrieved later.
     *
     * @param  {Object[]} courses Courses to store
     * @return {Void}
     * @deprecated since version 2.5
     */
    function storeCoursesInMemory(courses) {
        angular.forEach(courses, function(course) {
            currentCourses[course.id] = angular.copy(course); // Store a copy to prevent unwanted modifications.
        });
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Service to interact with courses.
 *
 * @module mm.core.courses
 * @ngdoc service
 * @name $mmCoursesDelegate
 */
.provider('$mmCoursesDelegate', function() {
    var navHandlers = {},
        self = {};

    /**
     * Register a navigation handler.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCoursesDelegate#registerNavHandler
     * @param {String} addon The addon's name (mmaLabel, mmaForum, ...)
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                                                           When using a promise, it should return a boolean.
     *                             - isEnabledForCourse(courseid, accessData) (Boolean|Promise) Whether or not the handler is
     *                                               enabled on a course level. When using a promise, it should return a boolean.
     *                             - getController(courseid) (Object) Returns the object that will act as controller.
     *                                                                See core/components/courses/templates/list.html
     *                                                                for the list of scope variables expected.
     */
    self.registerNavHandler = function(addon, handler, priority) {
        if (typeof navHandlers[addon] !== 'undefined') {
            console.log("$mmCoursesDelegateProvider: Addon '" + navHandlers[addon].addon + "' already registered as navigation handler");
            return false;
        }
        console.log("$mmCoursesDelegateProvider: Registered addon '" + addon + "' as navigation handler.");
        navHandlers[addon] = {
            addon: addon,
            handler: handler,
            instance: undefined,
            priority: priority
        };
        return true;
    };

    self.$get = ["$mmUtil", "$q", "$log", "$mmSite", "mmCoursesAccessMethods", function($mmUtil, $q, $log, $mmSite, mmCoursesAccessMethods) {
        var enabledNavHandlers = {},
            coursesHandlers = {},
            self = {},
            loaded = {};

        $log = $log.getInstance('$mmCoursesDelegate');

        /**
         * Check if addons are loaded for a certain course.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#areNavHandlersLoadedFor
         * @param {Number} courseId The course ID.
         * @return {Boolean} True if addons are loaded, false otherwise.
         */
        self.areNavHandlersLoadedFor = function(courseId) {
            return loaded[courseId];
        };

        /**
         * Clear all courses handlers.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#clearCoursesHandlers
         * @protected
         */
        self.clearCoursesHandlers = function() {
            coursesHandlers = {};
            loaded = {};
        };

        /**
         * Get the handler for a course using a certain access type.
         *
         * @param {Number} courseId    The course ID.
         * @param {Boolean} refresh    True if it should refresh the list.
         * @param  {Object} accessData Access type and data. Default, guest, ...
         * @return {Array}             Array of objects containing 'priority' and 'controller'.
         */
        function getNavHandlersForAccess(courseId, refresh, accessData) {
            if (refresh || !coursesHandlers[courseId] || coursesHandlers[courseId].access.type != accessData.type) {
                coursesHandlers[courseId] = {
                    access: accessData,
                    handlers: []
                };
                self.updateNavHandlersForCourse(courseId, accessData);
            }
            return coursesHandlers[courseId].handlers;
        }

        /**
         * Get the handlers for a course where the user is enrolled in.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#getNavHandlersFor
         * @param {Number} courseId The course ID.
         * @param {Boolean} refresh True if it should refresh the list.
         * @return {Array}          Array of objects containing 'priority' and 'controller'.
         */
        self.getNavHandlersFor = function(courseId, refresh) {
            // Default access.
            var accessData = {
                type: mmCoursesAccessMethods.default
            };
            return getNavHandlersForAccess(courseId, refresh, accessData);
        };

        /**
         * Get the handlers for a course as guest.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#getNavHandlersForGuest
         * @param {Number} courseId The course ID.
         * @param {Boolean} refresh True if it should refresh the list.
         * @return {Array}          Array of objects containing 'priority' and 'controller'.
         */
        self.getNavHandlersForGuest = function(courseId, refresh) {
            // Guest access.
            var accessData = {
                type: mmCoursesAccessMethods.guest
            };
            return getNavHandlersForAccess(courseId, refresh, accessData);
        };

        /**
         * Update the handler for the current site.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#updateNavHandler
         * @param {String} addon The addon.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateNavHandler = function(addon, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledNavHandlers[addon] = {
                        instance: handlerInfo.instance,
                        priority: handlerInfo.priority
                    };
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledNavHandlers[addon];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#updateNavHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateNavHandlers = function() {
            var promises = [];

            $log.debug('Updating navigation handlers for current site.');

            // Loop over all the content handlers.
            angular.forEach(navHandlers, function(handlerInfo, addon) {
                promises.push(self.updateNavHandler(addon, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            }).finally(function() {
                // Update handlers for all courses.
                angular.forEach(coursesHandlers, function(handler, courseId) {
                    self.updateNavHandlersForCourse(parseInt(courseId), handler.access);
                });
            });
        };

        /**
         * Update the handlers for a certain course.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#updateNavHandlersForCourse
         * @param {Number} courseId    The course ID.
         * @param  {Object} accessData Access type and data. Default, guest, ...
         * @return {Promise}           Resolved when updated.
         * @protected
         */
        self.updateNavHandlersForCourse = function(courseId, accessData) {
            var promises = [],
                enabledForCourse = [];

            angular.forEach(enabledNavHandlers, function(handler) {
                // Checks if the handler is enabled for the user.
                var promise = $q.when(handler.instance.isEnabledForCourse(courseId, accessData)).then(function(enabled) {
                    if (enabled) {
                        enabledForCourse.push(handler);
                    } else {
                        return $q.reject();
                    }
                }).catch(function() {
                    // Nothing to do here, it is not enabled for this user.
                });
                promises.push(promise);
            });

            return $q.all(promises).then(function() {
                return true;
            }).catch(function() {
                // Never fails.
                return true;
            }).finally(function() {
                // Update the coursesHandlers array with the new enabled addons.
                $mmUtil.emptyArray(coursesHandlers[courseId].handlers);
                angular.forEach(enabledForCourse, function(handler) {
                    coursesHandlers[courseId].handlers.push({
                        controller: handler.instance.getController(courseId),
                        priority: handler.priority
                    });
                });
                loaded[courseId] = true;
            });
        };

        return self;
    }];


    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Courses handlers factory.
 *
 * @module mm.core.courses
 * @ngdoc service
 * @name $mmCoursesHandlers
 */
.factory('$mmCoursesHandlers', ["$mmSite", "$state", "$mmCourses", "$q", "$mmUtil", "$translate", "$timeout", "$mmContentLinksHelper", "mmCoursesEnrolInvalidKey", function($mmSite, $state, $mmCourses, $q, $mmUtil, $translate, $timeout, $mmContentLinksHelper,
            mmCoursesEnrolInvalidKey) {

    var self = {};

    /**
     * Content links handler.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCoursesHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Action to perform when an enrol link is clicked.
         *
         * @param  {Number} courseId Course ID.
         * @param  {String} url      Treated URL.
         * @return {Void}
         */
        function actionEnrol(courseId, url) {
            var modal = $mmUtil.showModalLoading();

            // Check if user is enrolled in the course.
            $mmCourses.getUserCourse(courseId).catch(function() {
                // User is not enrolled in the course. Check if can self enrol.
                return canSelfEnrol(courseId).then(function() {
                    modal.dismiss();
                    return selfEnrol(courseId).catch(function() {
                        if (typeof error == 'string') {
                            $mmUtil.showErrorModal(error);
                        }
                        return $q.reject();
                    });
                }, function(error) {
                    // Error. Show error message and allow the user to open the link in browser.
                    modal.dismiss();
                    if (typeof error != 'string') {
                        error = $translate.instant('mm.courses.notenroled');
                    }

                    var body = $translate('mm.core.twoparagraphs',
                                    {p1: error, p2: $translate.instant('mm.core.confirmopeninbrowser')});
                    $mmUtil.showConfirm(body).then(function() {
                        $mmUtil.openInBrowser(url);
                    });
                    return $q.reject();
                });
            }).then(function() {
                modal.dismiss();
                $state.go('site.mm_course', {courseid: parseInt(courseId)});
            });
        }

        /**
         * Check if a user can be "automatically" self enrolled in a course.
         *
         * @param  {Number} courseId Course ID.
         * @return {Promise}         Promise resolved if user is can be enrolled in a course, rejected otherwise.
         */
        function canSelfEnrol(courseId) {
            // Check if self enrolment is enabled.
            if (!$mmCourses.isSelfEnrolmentEnabled()) {
                return $q.reject();
            }

            // Check that the course has self enrolment enabled.
            return $mmCourses.getCourseEnrolmentMethods(courseId).then(function(methods) {
                var isSelfEnrolEnabled = false,
                    instances = 0;
                angular.forEach(methods, function(method) {
                    if (method.type == 'self' && method.status) {
                        isSelfEnrolEnabled = true;
                        instances++;
                    }
                });

                if (!isSelfEnrolEnabled || instances != 1) {
                    // Self enrol not enabled or more than one instance.
                    return $q.reject();
                }
            });
        }

        /**
         * Try to self enrol a user in a course.
         *
         * @param  {Number} courseId Course ID.
         * @param  {String} password Password.
         * @return {Promise}         Promiser esolved when the user is enrolled, rejected otherwise.
         */
        function selfEnrol(courseId, password) {
            var modal = $mmUtil.showModalLoading();
            return $mmCourses.selfEnrol(courseId, password).then(function() {
                // Success self enrolling the user, invalidate the courses list.
                return $mmCourses.invalidateUserCourses().catch(function() {
                    // Ignore errors.
                }).then(function() {
                    // For some reason, if we get the course list right after self enrolling
                    // we won't retrieve the new course. Let's delay it a bit.
                    return $timeout(function() {}, 4000).finally(function() {
                        modal.dismiss();
                    });
                });

            }).catch(function(error) {
                modal.dismiss();
                if (error && error.code === mmCoursesEnrolInvalidKey) {
                    // Invalid password. Allow the user to input password.
                    var title = $translate.instant('mm.courses.selfenrolment'),
                        body = ' ', // Empty message.
                        placeholder = $translate.instant('mm.courses.password');

                    if (typeof password != 'undefined') {
                        // The user attempted a password. Show an error message.
                        $mmUtil.showErrorModal(error.message);
                    }

                    return $mmUtil.showPrompt(body, title, placeholder).then(function(password) {
                        return selfEnrol(courseId, password);
                    });
                } else {
                    return $q.reject(error);
                }
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        List of actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check if it's a course URL.
            if (url.indexOf('enrol/index.php') > -1 || url.indexOf('course/enrol.php') > -1 ||
                        url.indexOf('course/view.php') > -1) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: siteIds,
                        action: function(siteId) {
                            siteId = siteId || $mmSite.getId();
                            if (siteId == $mmSite.getId()) {
                                actionEnrol(parseInt(params.id, 10), url);
                            } else {
                                $mmContentLinksHelper.goInSite('site.mm_course', {courseid: parseInt(params.id, 10)}, siteId);
                            }
                        }
                    }];
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle input of user credentials.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginCredentialsCtrl
 */
.controller('mmLoginCredentialsCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmUtil", "$ionicHistory", "$mmApp", "$q", "$mmLoginHelper", "$translate", function($scope, $state, $stateParams, $mmSitesManager, $mmUtil, $ionicHistory, $mmApp,
            $q, $mmLoginHelper, $translate) {

    $scope.siteurl = $stateParams.siteurl;
    $scope.credentials = {};

    var siteChecked = false;

    // Function to check if a site uses local_mobile, requires SSO login, etc.
    // This should be used only if a fixed URL is set, otherwise this check is already performed in mmLoginSiteCtrl.
    function checkSite(siteurl) {
        var checkmodal = $mmUtil.showModalLoading();
        return $mmSitesManager.checkSite(siteurl).then(function(result) {

            siteChecked = true;
            $scope.siteurl = result.siteurl;

            if (result && result.warning) {
                $mmUtil.showErrorModal(result.warning, true, 4000);
            }

            if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                // SSO. User needs to authenticate in a browser.
                $scope.isBrowserSSO = true;
                $mmUtil.showConfirm($translate('mm.login.logininsiterequired')).then(function() {
                    $mmLoginHelper.openBrowserForSSOLogin(result.siteurl);
                });
            } else {
                $scope.isBrowserSSO = false;
            }

        }).catch(function(error) {
            $mmUtil.showErrorModal(error);
            return $q.reject();
        }).finally(function() {
            checkmodal.dismiss();
        });
    }

    if ($mmLoginHelper.isFixedUrlSet()) {
        // Fixed URL, we need to check if it uses browser SSO login.
        checkSite($scope.siteurl);
    } else {
        siteChecked = true;
    }

    $scope.login = function() {

        $mmApp.closeKeyboard();

        // Get input data.
        var siteurl = $scope.siteurl,
            username = $scope.credentials.username,
            password = $scope.credentials.password;

        if (!siteChecked) {
            // Site wasn't checked (it failed), let's check again.
            return checkSite(siteurl).then(function() {
                if (!$scope.isBrowserSSO) {
                    // Site doesn't use browser SSO, throw app's login again.
                    return $scope.login();
                }
            });
        } else if ($scope.isBrowserSSO) {
            // A previous check determined that browser SSO is needed. Let's check again, maybe site was updated.
            return checkSite(siteurl);
        }

        if (!username) {
            $mmUtil.showErrorModal('mm.login.usernamerequired', true);
            return;
        }
        if (!password) {
            $mmUtil.showErrorModal('mm.login.passwordrequired', true);
            return;
        }

        var modal = $mmUtil.showModalLoading();

        // Start the authentication process.
        return $mmSitesManager.getUserToken(siteurl, username, password).then(function(data) {
            return $mmSitesManager.newSite(data.siteurl, data.token).then(function() {
                delete $scope.credentials; // Delete username and password from the scope.
                $ionicHistory.nextViewOptions({disableBack: true});
                $state.go('site.mm_courses');
            });
        }).catch(function(error) {
            $mmUtil.showErrorModal(error);
        }).finally(function() {
            modal.dismiss();
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle splash screen and initialize the app (restore session, determine first state, etc.).
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginInitCtrl
 */
.controller('mmLoginInitCtrl', ["$log", "$ionicHistory", "$state", "$mmSitesManager", "$mmSite", "$mmApp", "$mmLoginHelper", function($log, $ionicHistory, $state, $mmSitesManager, $mmSite, $mmApp, $mmLoginHelper) {

    $log = $log.getInstance('mmLoginInitCtrl');

    $mmApp.ready().then(function() {

        // Disable animation and back button for the next transition.
        $ionicHistory.nextViewOptions({
            disableAnimate: true,
            disableBack: true
        });

        if ($mmSite.isLoggedIn()) {
            $state.go('site.mm_courses');
        } else {
            $mmSitesManager.hasSites().then(function() {
                return $state.go('mm_login.sites');
            }, function() {
                return $mmLoginHelper.goToAddSite();
            });
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle input of user credentials.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginReconnectCtrl
 */
.controller('mmLoginReconnectCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmApp", "$mmUtil", "$ionicHistory", function($scope, $state, $stateParams, $mmSitesManager, $mmApp, $mmUtil, $ionicHistory) {

    var infositeurl = $stateParams.infositeurl; // Siteurl in site info. It might be different than siteurl (http/https).
    $scope.siteurl = $stateParams.siteurl;
    $scope.credentials = {
        username: $stateParams.username,
        password: ''
    };

    $scope.cancel = function() {
        $mmSitesManager.logout().finally(function() {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.go('mm_login.sites');
        });
    };

    $scope.login = function() {

        $mmApp.closeKeyboard();

        // Get input data.
        var siteurl = $scope.siteurl,
            username = $scope.credentials.username,
            password = $scope.credentials.password;

        if (!password) {
            $mmUtil.showErrorModal('mm.login.passwordrequired', true);
            return;
        }

        var modal = $mmUtil.showModalLoading();

        // Start the authentication process.
        $mmSitesManager.getUserToken(siteurl, username, password).then(function(data) {
            $mmSitesManager.updateSiteToken(infositeurl, username, data.token).then(function() {
                // Update site info too because functions might have changed (e.g. unisntall local_mobile).
                $mmSitesManager.updateSiteInfoByUrl(infositeurl, username).finally(function() {
                    delete $scope.credentials; // Delete password from the scope.
                    $ionicHistory.nextViewOptions({disableBack: true});
                    $state.go('site.mm_courses');
                });
            }, function(error) {
                // Site deleted? Go back to login page.
                $mmUtil.showErrorModal('mm.login.errorupdatesite', true);
                $scope.cancel();
            }).finally(function() {
                modal.dismiss();
            });
        }, function(error) {
            modal.dismiss();
            $mmUtil.showErrorModal(error);
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle the input of a site URL and its validation.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginSiteCtrl
 */
.controller('mmLoginSiteCtrl', ["$scope", "$state", "$mmSitesManager", "$mmUtil", "$translate", "$ionicHistory", "$mmApp", "$ionicModal", "$mmLoginHelper", function($scope, $state, $mmSitesManager, $mmUtil, $translate, $ionicHistory, $mmApp,
        $ionicModal, $mmLoginHelper) {

    $scope.siteurl = '';
    $scope.isInvalidUrl = true;

    $scope.validate = function(url) {
        if (!url) {
            $scope.isInvalidUrl = true;
            return;
        }

        if ($mmSitesManager.getDemoSiteData(url)) {
            // Is demo site.
            $scope.isInvalidUrl = false;
        } else {
            // formatURL adds the protocol if is missing.
            var formattedurl = $mmUtil.formatURL(url);
            $scope.isInvalidUrl = formattedurl.indexOf('://localhost') == -1 && !$mmUtil.isValidURL(formattedurl);
        }
    };

    $scope.connect = function(url) {

        $mmApp.closeKeyboard();

        if (!url) {
            $mmUtil.showErrorModal('mm.login.siteurlrequired', true);
            return;
        }

        var modal = $mmUtil.showModalLoading(),
            sitedata = $mmSitesManager.getDemoSiteData(url);

        if (sitedata) {
            // It's a demo site.
            $mmSitesManager.getUserToken(sitedata.url, sitedata.username, sitedata.password).then(function(data) {
                $mmSitesManager.newSite(data.siteurl, data.token).then(function() {
                    $ionicHistory.nextViewOptions({disableBack: true});
                    $state.go('site.mm_courses');
                }, function(error) {
                    $mmUtil.showErrorModal(error);
                }).finally(function() {
                    modal.dismiss();
                });
            }, function(error) {
                modal.dismiss();
                $mmUtil.showErrorModal(error);
            });

        } else {
            // Not a demo site.
            $mmSitesManager.checkSite(url).then(function(result) {

                if (result.warning) {
                    $mmUtil.showErrorModal(result.warning, true, 4000);
                }

                if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                    // SSO. User needs to authenticate in a browser.
                    $mmUtil.showConfirm($translate('mm.login.logininsiterequired')).then(function() {
                        $mmLoginHelper.openBrowserForSSOLogin(result.siteurl);
                    });
                } else {
                    $state.go('mm_login.credentials', {siteurl: result.siteurl});
                }

            }, function(error) {
                $mmUtil.showErrorModal(error);
            }).finally(function() {
                modal.dismiss();
            });
        }
    };

    // Get docs URL for help modal.
    $mmUtil.getDocsUrl().then(function(docsurl) {
        $scope.docsurl = docsurl;
    });

    // Setup help modal.
    $ionicModal.fromTemplateUrl('core/components/login/templates/help-modal.html', {
        scope: $scope,
        animation: 'slide-in-up'
    }).then(function(helpModal) {
        $scope.showHelp = function() {
            helpModal.show();
        };
        $scope.closeHelp = function() {
            helpModal.hide();
        };
        $scope.$on('$destroy', function() {
            helpModal.remove();
        });
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle the list of sites.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginSitesCtrl
 */
.controller('mmLoginSitesCtrl', ["$scope", "$state", "$mmSitesManager", "$log", "$translate", "$mmUtil", "$ionicHistory", "$mmText", "$mmLoginHelper", function($scope, $state, $mmSitesManager, $log, $translate, $mmUtil, $ionicHistory, $mmText,
            $mmLoginHelper) {

    $log = $log.getInstance('mmLoginSitesCtrl');

    $mmSitesManager.getSites().then(function(sites) {
        $scope.sites = sites;
        $scope.data = {
            hasSites: sites.length > 0,
            showDelete: false
        };
    });

    $scope.toggleDelete = function() {
        $scope.data.showDelete = !$scope.data.showDelete;
    };

    $scope.onItemDelete = function(e, index) {
        // Prevent login() from being triggered. No idea why I cannot replicate this
        // problem on http://codepen.io/ionic/pen/JsHjf.
        e.stopPropagation();

        var site = $scope.sites[index],
            sitename = site.sitename;

        $mmText.formatText(sitename).then(function(sitename) {
            $mmUtil.showConfirm($translate('mm.login.confirmdeletesite', {sitename: sitename})).then(function() {
                $mmSitesManager.deleteSite(site.id).then(function() {
                    $scope.sites.splice(index, 1);
                    $mmSitesManager.hasNoSites().then(function() {
                        // No sites left, go to add a new site state.
                        $ionicHistory.nextViewOptions({disableBack: true});
                        $mmLoginHelper.goToAddSite();
                    });
                }, function() {
                    $log.error('Delete site failed');
                    $mmUtil.showErrorModal('mm.login.errordeletesite', true);
                });
            });
        });
    };

    $scope.login = function(siteid) {
        var modal = $mmUtil.showModalLoading();

        $mmSitesManager.loadSite(siteid).then(function() {
            $ionicHistory.nextViewOptions({disableBack: true});
            $state.go('site.mm_courses');
        }, function(error) {
            $log.error('Error loading site '+siteid);
            error = error || 'Error loading site.';
            $mmUtil.showErrorModal(error);
        }).finally(function() {
            modal.dismiss();
        });
    };

    $scope.add = function() {
        $mmLoginHelper.goToAddSite();
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

.constant('mmLoginSSOCode', 2) // This code is returned by local_mobile Moodle plugin if SSO in browser is required.
.constant('mmLoginLaunchSiteURL', 'mmLoginLaunchSiteURL')
.constant('mmLoginLaunchPassport', 'mmLoginLaunchPassport')

/**
 * Service to provide some helper functionalities for the login component.
 *
 * @module mm.core.login
 * @ngdoc service
 * @name $mmLoginHelper
 */
.factory('$mmLoginHelper', ["$q", "$log", "$mmConfig", "mmLoginSSOCode", "mmLoginLaunchSiteURL", "mmLoginLaunchPassport", "md5", "$mmSite", "$mmSitesManager", "$mmLang", "$mmUtil", "$state", "mmCoreConfigConstants", function($q, $log, $mmConfig, mmLoginSSOCode, mmLoginLaunchSiteURL, mmLoginLaunchPassport,
            md5, $mmSite, $mmSitesManager, $mmLang, $mmUtil, $state, mmCoreConfigConstants) {

    $log = $log.getInstance('$mmLoginHelper');

    var self = {};

    /**
     * Go to the view to add a new site.
     * If a fixed URL is configured, go to credentials instead.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#goToAddSite
     * @return {Promise} Promise resolved when the state changes.
     */
    self.goToAddSite = function() {
        if (mmCoreConfigConstants.siteurl) {
            // Fixed URL is set, go to credentials page.
            return $state.go('mm_login.credentials', {siteurl: mmCoreConfigConstants.siteurl});
        } else {
            return $state.go('mm_login.site');
        }
    };

    /**
     * Check if the app is configured to use a fixed URL.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#isFixedUrlSet
     * @return {Boolean} True if set, false otherwise.
     */
    self.isFixedUrlSet = function() {
        return typeof mmCoreConfigConstants.siteurl != 'undefined';
    };

    /**
     * Check if SSO login is needed based on code returned by the WS.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#isSSOLoginNeeded
     * @param  {Number}  code Code to check.
     * @return {Boolean}      True if SSO login is needed, false othwerise.
     */
    self.isSSOLoginNeeded = function(code) {
        return code == mmLoginSSOCode;
    };

    /**
     * Open a browser to perform SSO login.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#openBrowserForSSOLogin
     * @param {String} siteurl URL of the site where the SSO login will be performed.
     */
    self.openBrowserForSSOLogin = function(siteurl) {
        var passport = Math.random() * 1000;
        var loginurl = siteurl + "/local/mobile/launch.php?service=" + mmCoreConfigConstants.wsextservice;
        loginurl += "&passport=" + passport;

        // Store the siteurl and passport in $mmConfig for persistence. We are "configuring"
        // the app to wait for an SSO. $mmConfig shouldn't be used as a temporary storage.
        $mmConfig.set(mmLoginLaunchSiteURL, siteurl);
        $mmConfig.set(mmLoginLaunchPassport, passport);

        $mmUtil.openInBrowser(loginurl);
        if (navigator.app) {
            navigator.app.exitApp();
        }
    };

    /**
     * Convenient helper to validate a browser SSO login.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#validateBrowserSSOLogin
     * @param {String} url URL received, to be validated.
     * @return {Promise}   The success contains the signature and token. The reject contains the error message.
     */
    self.validateBrowserSSOLogin = function(url) {
        // Split signature:::token
        var params = url.split(":::");

        return $mmConfig.get(mmLoginLaunchSiteURL).then(function(launchSiteURL) {
            return $mmConfig.get(mmLoginLaunchPassport).then(function(passport) {

                // Reset temporary values.
                $mmConfig.delete(mmLoginLaunchSiteURL);
                $mmConfig.delete(mmLoginLaunchPassport);

                // Validate the signature.
                // We need to check both http and https.
                var signature = md5.createHash(launchSiteURL + passport);
                if (signature != params[0]) {
                    if (launchSiteURL.indexOf("https://") != -1) {
                        launchSiteURL = launchSiteURL.replace("https://", "http://");
                    } else {
                        launchSiteURL = launchSiteURL.replace("http://", "https://");
                    }
                    signature = md5.createHash(launchSiteURL + passport);
                }

                if (signature == params[0]) {
                    $log.debug('Signature validated');
                    return { siteurl: launchSiteURL, token: params[1] };
                } else {
                    $log.debug('Inalid signature in the URL request yours: ' + params[0] + ' mine: '
                                    + signature + ' for passport ' + passport);
                    return $mmLang.translateAndReject('mm.core.unexpectederror');
                }

            });
        });
    };

    /**
     * Convenient helper to handle authentication in the app using a token received by SSO login. If it's a new account,
     * the site is stored and the user is authenticated. If the account already exists, update its token.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#handleSSOLoginAuthentication
     * @param {String} siteurl Site's URL.
     * @param {String} token   User's token.
     * @return {Promise}       Promise resolved when the user is authenticated with the token. Reject returns an error message.
     */
    self.handleSSOLoginAuthentication = function(siteurl, token) {
        if ($mmSite.isLoggedIn()) {
            // User logged in, he is reconnecting.
            var deferred = $q.defer();

            // Retrieve username.
            var info = $mmSite.getInfo();
            if (typeof(info) !== 'undefined' && typeof(info.username) !== 'undefined') {
                $mmSitesManager.updateSiteToken(info.siteurl, info.username, token).then(function() {
                    $mmSitesManager.updateSiteInfoByUrl(info.siteurl, info.username).finally(deferred.resolve);
                }, function() {
                    // Error updating token, return proper error message.
                    $mmLang.translateAndRejectDeferred(deferred, 'mm.login.errorupdatesite');
                });
            } else {
                $mmLang.translateAndRejectDeferred(deferred, 'mm.login.errorupdatesite');
            }
            return deferred.promise;
        } else {
            return $mmSitesManager.newSite(siteurl, token);
        }
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'About' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsAboutCtrl
 */
.controller('mmSettingsAboutCtrl', ["$scope", "$translate", "$window", "$mmApp", "$ionicPlatform", "$mmLang", "$mmFS", "$mmLocalNotifications", "mmCoreConfigConstants", function($scope, $translate, $window, $mmApp, $ionicPlatform, $mmLang, $mmFS,
            $mmLocalNotifications, mmCoreConfigConstants) {

    $scope.versionname = mmCoreConfigConstants.versionname;
    $translate('mm.settings.appname', {version: $scope.versionname}).then(function(appName) {
        $scope.appname = appName;
    });

    $scope.versioncode = mmCoreConfigConstants.versioncode;

    $scope.navigator = $window.navigator;
    if ($window.location && $window.location.href) {
        var url = $window.location.href;
        $scope.locationhref = url.substr(0, url.indexOf('#/site/'));
    }

    $scope.appready = $mmApp.isReady() ? 'mm.core.yes' : 'mm.core.no';
    $scope.devicetype = $ionicPlatform.isTablet() ? 'mm.core.tablet' : 'mm.core.phone';

    if (ionic.Platform.isAndroid()) {
        $scope.deviceos = 'mm.core.android';
    } else if (ionic.Platform.isIOS()) {
        $scope.deviceos = 'mm.core.ios';
    } else if (ionic.Platform.isWindowsPhone()) {
        $scope.deviceos = 'mm.core.windowsphone';
    } else {
        var matches = navigator.userAgent.match(/\(([^\)]*)\)/);
        if (matches && matches.length > 1) {
            $scope.deviceos = matches[1];
        } else {
            $scope.deviceos = 'mm.core.unknown';
        }
    }

    $mmLang.getCurrentLanguage().then(function(lang) {
        $scope.currentlanguage = lang;
    });

    $scope.networkstatus = $mmApp.isOnline() ? 'mm.core.online' : 'mm.core.offline';
    $scope.wificonnection = $mmApp.isNetworkAccessLimited() ? 'mm.core.no' : 'mm.core.yes';
    $scope.devicewebworkers = !!window.Worker && !!window.URL ? 'mm.core.yes' : 'mm.core.no';
    $scope.device = ionic.Platform.device();

    if ($mmFS.isAvailable()) {
        $mmFS.getBasePath().then(function(basepath) {
            $scope.filesystemroot = basepath;
            $scope.fsclickable = $mmFS.usesHTMLAPI();
        });
    }

    $scope.storagetype = $mmApp.getDB().getType();
    $scope.localnotifavailable = $mmLocalNotifications.isAvailable() ? 'mm.core.yes' : 'mm.core.no';
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'General' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsGeneralCtrl
 */
.controller('mmSettingsGeneralCtrl', ["$scope", "$mmLang", "$ionicHistory", "$mmEvents", "$mmConfig", "mmCoreEventLanguageChanged", "mmCoreSettingsReportInBackground", "mmCoreConfigConstants", "mmCoreSettingsDownloadSection", function($scope, $mmLang, $ionicHistory, $mmEvents, $mmConfig, mmCoreEventLanguageChanged,
            mmCoreSettingsReportInBackground, mmCoreConfigConstants, mmCoreSettingsDownloadSection) {

    $scope.langs = mmCoreConfigConstants.languages;

    $mmLang.getCurrentLanguage().then(function(currentLanguage) {
        $scope.selectedLanguage = currentLanguage;
    });

    $scope.languageChanged = function(newLang) {
        $mmLang.changeCurrentLanguage(newLang).finally(function() {
            // Clear cached views.
            $ionicHistory.clearCache();
            $mmEvents.trigger(mmCoreEventLanguageChanged);
        });
    };

    $mmConfig.get(mmCoreSettingsDownloadSection, true).then(function(downloadSectionEnabled) {
        $scope.downloadSection = downloadSectionEnabled;
    });

    $scope.downloadSectionChanged = function(downloadSection) {
        $mmConfig.set(mmCoreSettingsDownloadSection, downloadSection);
    };

    if (localStorage && localStorage.getItem && localStorage.setItem) {
        $scope.showReport = true;
        $scope.reportInBackground = parseInt(localStorage.getItem(mmCoreSettingsReportInBackground), 10) === 1;

        $scope.reportChanged = function(inBackground) {
            localStorage.setItem(mmCoreSettingsReportInBackground, inBackground ? '1' : '0');
        };
    } else {
        $scope.showReport = false;
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'Space Usage' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsSpaceUsageCtrl
 * @todo When "mock site" is implemented we should have functions to calculate the site usage and delete its files.
 */
.controller('mmSettingsSpaceUsageCtrl', ["$log", "$scope", "$mmSitesManager", "$mmFS", "$q", "$mmUtil", "$translate", "$mmText", "$mmFilepool", function($log, $scope, $mmSitesManager, $mmFS, $q, $mmUtil, $translate,
            $mmText, $mmFilepool) {
    $log = $log.getInstance('mmSettingsSpaceUsageCtrl');

    // Convenience function to calculate each site's usage, and the total usage.
    function calculateSizeUsage() {
        return $mmSitesManager.getSites().then(function(sites) {
            var promises = [];
            $scope.sites = sites;

            angular.forEach(sites, function(siteEntry) {
                var promise = $mmSitesManager.getSite(siteEntry.id).then(function(site) {
                    return site.getSpaceUsage().then(function(size) {
                        siteEntry.spaceusage = size;
                    });
                });
                promises.push(promise);
            });

            return $q.all(promises);
        });
    }

    // Convenience function to calculate total usage.
    function calculateTotalUsage() {
        var total = 0;
        angular.forEach($scope.sites, function(site) {
            if (site.spaceusage) {
                total += parseInt(site.spaceusage, 10);
            }
        });
        $scope.totalusage = total;
    }

    // Convenience function to calculate free space in the device.
    function calculateFreeSpace() {
        if ($mmFS.isAvailable()) {
            return $mmFS.calculateFreeSpace().then(function(freespace) {
                $scope.freespace = freespace;
            }, function() {
                $scope.freespace = 0;
            });
        } else {
            $scope.freespace = 0;
        }
    }

    function fetchData() {
        var promises = [];
        promises.push(calculateSizeUsage().then(calculateTotalUsage));
        promises.push($q.when(calculateFreeSpace()));
        return $q.all(promises);
    }
    fetchData().finally(function() {
        $scope.sizeLoaded = true;
    });

    // Pull to refresh.
    $scope.refresh = function() {
        fetchData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Convenience function to update site size, along with total usage and free space.
    function updateSiteUsage(site, newUsage) {
        var oldUsage = site.spaceusage;
        site.spaceusage = newUsage;
        $scope.totalusage -= oldUsage - newUsage;
        $scope.freespace += oldUsage - newUsage;
    }

    $scope.deleteSiteFiles = function(siteData) {
        if (siteData) {
            var siteid = siteData.id,
                sitename = siteData.sitename;

            $mmText.formatText(sitename).then(function(sitename) {
                $translate('mm.settings.deletesitefilestitle').then(function(title) {
                    return $mmUtil.showConfirm($translate('mm.settings.deletesitefiles', {sitename: sitename}), title);
                }).then(function() {
                    return $mmSitesManager.getSite(siteid);
                }).then(function(site) {
                    return site.deleteFolder().then(function() {
                        $mmFilepool.clearAllPackagesStatus(siteid);
                        $mmFilepool.clearFilepool(siteid);
                        updateSiteUsage(siteData, 0);
                    }).catch(function(error) {
                        if (error && error.code === FileError.NOT_FOUND_ERR) {
                            // Not found, set size 0.
                            $mmFilepool.clearAllPackagesStatus(siteid);
                            updateSiteUsage(siteData, 0);
                        } else {
                            // Error, recalculate the site usage.
                            $mmUtil.showErrorModal('mm.settings.errordeletesitefiles', true);
                            site.getSpaceUsage().then(function(size) {
                                updateSiteUsage(siteData, size);
                            });
                        }
                    });
                });
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'Synchronization' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsSynchronizationCtrl
 */
.controller('mmSettingsSynchronizationCtrl', ["$log", "$scope", "$mmSitesManager", "$mmUtil", "$mmFilepool", "$mmEvents", "$mmLang", "$mmConfig", "mmCoreEventSessionExpired", "mmCoreSettingsSyncOnlyOnWifi", function($log, $scope, $mmSitesManager, $mmUtil, $mmFilepool, $mmEvents,
            $mmLang, $mmConfig, mmCoreEventSessionExpired, mmCoreSettingsSyncOnlyOnWifi) {
    $log = $log.getInstance('mmSettingsSynchronizationCtrl');

    $mmSitesManager.getSites().then(function(sites) {
        $scope.sites = sites;
    });

    $mmConfig.get(mmCoreSettingsSyncOnlyOnWifi, true).then(function(syncOnlyOnWifi) {
        $scope.syncOnlyOnWifi = syncOnlyOnWifi;
    });

    $scope.syncWifiChanged = function(syncOnlyOnWifi) {
        $mmConfig.set(mmCoreSettingsSyncOnlyOnWifi, syncOnlyOnWifi);
    };

    $scope.synchronize = function(siteData) {
        if (siteData) {
            var siteid = siteData.id,
                modal = $mmUtil.showModalLoading('mm.settings.synchronizing', true);
            $mmFilepool.invalidateAllFiles(siteid).finally(function() {
                $mmSitesManager.getSite(siteid).then(function(site) {
                    return site.invalidateWsCache().then(function() {
                        // Check if local_mobile was installed to Moodle.
                        return site.checkIfLocalMobileInstalledAndNotUsed().then(function() {
                            // Local mobile was added. Throw invalid session to force reconnect and create a new token.
                            $mmEvents.trigger(mmCoreEventSessionExpired, siteid);
                            return $mmLang.translateAndReject('mm.core.lostconnection');
                        }, function() {
                            // Update site info.
                            return $mmSitesManager.updateSiteInfo(siteid);
                        });
                    }).then(function() {
                        siteData.fullname = site.getInfo().fullname;
                        siteData.sitename = site.getInfo().sitename;
                        $mmUtil.showModal('mm.core.success', 'mm.settings.syncsitesuccess');
                    });
                }).catch(function(error) {
                    if (error) {
                        $mmUtil.showErrorModal(error);
                    } else {
                        $mmUtil.showErrorModal('mm.settings.errorsyncsite', true);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.sidemenu')

/**
 * Controller to handle the side menu.
 *
 * @module mm.core.sidemenu
 * @ngdoc controller
 * @name mmSideMenuCtrl
 */
.controller('mmSideMenuCtrl', ["$scope", "$state", "$mmSideMenuDelegate", "$mmSitesManager", "$mmSite", "$mmEvents", "$timeout", "mmCoreEventLanguageChanged", "mmCoreEventSiteUpdated", function($scope, $state, $mmSideMenuDelegate, $mmSitesManager, $mmSite, $mmEvents,
            $timeout, mmCoreEventLanguageChanged, mmCoreEventSiteUpdated) {

    $scope.handlers = $mmSideMenuDelegate.getNavHandlers();
    $scope.areNavHandlersLoaded = $mmSideMenuDelegate.areNavHandlersLoaded;
    $scope.siteinfo = $mmSite.getInfo();

    $scope.logout = function() {
        $mmSitesManager.logout().finally(function() {
            $state.go('mm_login.sites');
        });
    };

    $mmSite.getDocsUrl().then(function(docsurl) {
        $scope.docsurl = docsurl;
    });

    function updateSiteInfo() {
        // We need to use $timeout to force a $digest and make $watch notice the variable change.
        $scope.siteinfo = undefined;
        $timeout(function() {
            $scope.siteinfo = $mmSite.getInfo();

            // Update docs URL, maybe the Moodle release has changed.
            $mmSite.getDocsUrl().then(function(docsurl) {
                $scope.docsurl = docsurl;
            });
        });
    }

    var langObserver = $mmEvents.on(mmCoreEventLanguageChanged, updateSiteInfo);
    var updateSiteObserver = $mmEvents.on(mmCoreEventSiteUpdated, function(siteid) {
        if ($mmSite.getId() === siteid) {
            updateSiteInfo();
        }
    });

    $scope.$on('$destroy', function() {
        if (langObserver && langObserver.off) {
            langObserver.off();
        }
        if (updateSiteObserver && updateSiteObserver.off) {
            updateSiteObserver.off();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.sidemenu')

/**
 * Service to interact with plugins to be shown in the side menu. Provides functions to register a plugin
 * and notify an update in the data.
 *
 * @module mm.core.sidemenu
 * @ngdoc provider
 * @name $mmSideMenuDelegate
 */
.provider('$mmSideMenuDelegate', function() {
    var navHandlers = {},
        self = {};

    /**
     * Register a navigation handler.
     *
     * @module mm.core.sidemenu
     * @ngdoc method
     * @name $mmSideMenuDelegateProvider#registerNavHandler
     * @param {String} addon The addon's name (mmaFiles, mmaMessages, ...)
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                                                           When using a promise, it should return a boolean.
     *                             - getController (Object) Returns the object that will act as controller.
     *                                                                See core/components/sidemenu/templates/menu.html
     *                                                                for the list of scope variables expected.
     */
    self.registerNavHandler = function(addon, handler, priority) {
        if (typeof navHandlers[addon] !== 'undefined') {
            console.log("$mmSideMenuDelegateProvider: Addon '" + navHandlers[addon].addon + "' already registered as navigation handler");
            return false;
        }
        console.log("$mmSideMenuDelegateProvider: Registered addon '" + addon + "' as navigation handler.");
        navHandlers[addon] = {
            addon: addon,
            handler: handler,
            instance: undefined,
            priority: priority
        };
        return true;
    };

    self.$get = ["$mmUtil", "$q", "$log", "$mmSite", function($mmUtil, $q, $log, $mmSite) {
        var enabledNavHandlers = {},
            currentSiteHandlers = [], // Handlers to return.
            self = {},
            loaded = false; // If site handlers have been loaded.

        $log = $log.getInstance('$mmSideMenuDelegate');

        /**
         * Check if addons are loaded.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#areNavHandlersLoaded
         * @return {Boolean} True if addons are loaded, false otherwise.
         */
        self.areNavHandlersLoaded = function() {
            return loaded;
        };

        /**
         * Clear current site nav handlers. Reserved for core use.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#clearSiteHandlers
         * @return {Void}
         */
        self.clearSiteHandlers = function() {
            loaded = false;
            $mmUtil.emptyArray(currentSiteHandlers);
        };

        /**
         * Get the handlers for the current site.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#getNavHandlers
         * @return {Promise} Resolved with an array of objects containing 'priority' and 'controller'.
         */
        self.getNavHandlers = function() {
            return currentSiteHandlers;
        };

        /**
         * Update the handler for the current site.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#updateNavHandler
         * @param {String} addon The addon.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateNavHandler = function(addon, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledNavHandlers[addon] = {
                        instance: handlerInfo.instance,
                        priority: handlerInfo.priority
                    };
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledNavHandlers[addon];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#updateNavHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateNavHandlers = function() {
            var promises = [];

            $log.debug('Updating navigation handlers for current site.');

            // Loop over all the content handlers.
            angular.forEach(navHandlers, function(handlerInfo, addon) {
                promises.push(self.updateNavHandler(addon, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            }).finally(function() {

                $mmUtil.emptyArray(currentSiteHandlers);

                angular.forEach(enabledNavHandlers, function(handler) {
                    currentSiteHandlers.push({
                        controller: handler.instance.getController(),
                        priority: handler.priority
                    });
                });

                loaded = true;
            });
        };

        return self;
    }];

    return self;

});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.textviewer')

/**
 * Text viewer  controller.
 *
 * @module mm.core.textviewer
 * @ngdoc controller
 * @name mmTextViewerIndexCtrl
 */
.controller('mmTextViewerIndexCtrl', ["$stateParams", "$scope", function($stateParams, $scope) {
    $scope.title = $stateParams.title;
    $scope.content = $stateParams.content;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

/**
 * Controller to handle a user profile page.
 *
 * @module mm.core.user
 * @ngdoc controller
 * @name mmaParticipantsProfileCtrl
 */
.controller('mmUserProfileCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmUser", "$mmUserDelegate", "$mmSite", "$q", "$translate", function($scope, $stateParams, $mmUtil, $mmUser, $mmUserDelegate, $mmSite, $q, $translate) {

    var courseid = $stateParams.courseid,
        userid   = $stateParams.userid;

    $scope.isAndroid = ionic.Platform.isAndroid();
    $scope.plugins = [];

    function fetchUserData() {
        return $mmUser.getProfile(userid, courseid).then(function(user) {

            user.address = $mmUser.formatAddress(user.address, user.city, user.country);
            if (user.address) {
                user.encodedAddress = encodeURIComponent(user.address);
            }

            $mmUser.formatRoleList(user.roles).then(function(roles) {
                user.roles = roles;
            });

            $scope.user = user;
            $scope.title = user.fullname;
            $scope.hasContact = user.email || user.phone1 || user.phone2 || user.city || user.country || user.address;
            $scope.hasDetails = user.url || user.roles || user.interests;

            $scope.isLoadingHandlers = true;
            $mmUserDelegate.getProfileHandlersFor(user, courseid).then(function(handlers) {
                $scope.profileHandlers = handlers;
            }).finally(function() {
                $scope.isLoadingHandlers = false;
            });
        }, function(message) {
            $scope.user = false;
            if (message) {
                $mmUtil.showErrorMessage(message);
            }
            return $q.reject();
        });
    }

    fetchUserData().then(function() {
        // Add log in Moodle.
        return $mmSite.write('core_user_view_user_profile', {
            userid: userid,
            courseid: courseid
        }).catch(function(error) {
            $scope.isDeleted = error === $translate.instant('mm.core.userdeleted');
        });
    }).finally(function() {
        $scope.userLoaded = true;
    });

    $scope.refreshUser = function() {
        $mmUser.invalidateUserCache(userid).finally(function() {
            fetchUserData().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to go to user profile on click.
 *
 * @module mm.core
 * @ngdoc provider
 * @name mmUserLink
 */
.directive('mmUserLink', ["$state", "mmUserProfileState", function($state, mmUserProfileState) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                $state.go(mmUserProfileState, {courseid: attrs.courseid, userid: attrs.userid});
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

/**
 * Service to interact with plugins to be shown in user profile. Provides functions to register a plugin
 * and notify an update in the data.
 *
 * @module mm.core.user
 * @ngdoc provider
 * @name $mmUserDelegate
 */
.provider('$mmUserDelegate', function() {
    var profileHandlers = {},
        self = {};

    /**
     * Register a profile handler.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUserDelegateProvider#registerProfileHandler
     * @param {String} component The addon's name, or addon and sub context (mmaMessages, mmaMessage:blockContact, ...)
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                          returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                                                           When using a promise, it should return a boolean.
     *                             - isEnabledForUser (Boolean|Promise) Whether or not the handler is enabled for a user.
     *                                                                  When using a promise, it should return a boolean.
     *                             - getController(userid) (Function) Returns the function that will act as controller.
     *                                                                See core/components/user/templates/profile.html
     *                                                                for the list of scope variables expected.
     *                           The string can either be 'factoryName' or 'factoryName.functionToCall'.
     * @param {Number} [priority=100] Plugin priority.
     */
    self.registerProfileHandler = function(component, handler, priority) {
        if (typeof profileHandlers[component] !== 'undefined') {
            console.log("$mmUserDelegateProvider: Handler '" + profileHandlers[component].component + "' already registered as profile handler");
            return false;
        }
        console.log("$mmUserDelegateProvider: Registered component '" + component + "' as profile handler.");
        profileHandlers[component] = {
            component: component,
            handler: handler,
            instance: undefined,
            priority: typeof priority === 'undefined' ? 100 : priority
        };
        return true;
    };

    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", function($q, $log, $mmSite, $mmUtil) {
        var enabledProfileHandlers = {},
            self = {};

        $log = $log.getInstance('$mmUserDelegate');

        /**
         * Get the profile handlers for a user.
         *
         * @module mm.core.user
         * @ngdoc method
         * @name $mmUserDelegate#getProfileHandlersFor
         * @param {Object} user The user object.
         * @param {Number} courseId The course ID.
         * @return {Promise} Resolved with an array of objects containing 'priority' and 'controller'.
         */
        self.getProfileHandlersFor = function(user, courseId) {
            var handlers = [],
                promises = [];

            angular.forEach(enabledProfileHandlers, function(handler) {
                // Checks if the handler is enabled for the user.
                var promise = $q.when(handler.instance.isEnabledForUser(user, courseId)).then(function(enabled) {
                    if (enabled) {
                        handlers.push({
                            controller: handler.instance.getController(user, courseId),
                            priority: handler.priority
                        });
                    } else {
                        return $q.reject();
                    }
                }).catch(function() {
                    // Nothing to do here, it is not enabled for this user.
                });
                promises.push(promise);
            });

            return $q.all(promises).then(function() {
                return handlers;
            }).catch(function() {
                // Never fails.
                return handlers;
            });
        };

        /**
         * Update the enabled profile handlers for the current site.
         *
         * @module mm.core.user
         * @ngdoc method
         * @name $mmUserDelegate#updateProfileHandler
         * @param {String} component The component name.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateProfileHandler = function(component, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledProfileHandlers[component] = {
                        instance: handlerInfo.instance,
                        priority: handlerInfo.priority
                    };
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledProfileHandlers[component];
            });
        };

        /**
         * Update the profile handlers for the current site.
         *
         * @module mm.core.user
         * @ngdoc method
         * @name $mmUserDelegate#updateProfileHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateProfileHandlers = function() {
            var promises = [];

            $log.debug('Updating profile handlers for current site.');

            // Loop over all the profile handlers.
            angular.forEach(profileHandlers, function(handlerInfo, component) {
                promises.push(self.updateProfileHandler(component, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            });
        };

        return self;

    }];

    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

/**
 * User handlers factory.
 *
 * @module mm.core.user
 * @ngdoc service
 * @name $mmUserHandlers
 */
.factory('$mmUserHandlers', ["$mmUtil", "$mmContentLinksHelper", function($mmUtil, $mmContentLinksHelper) {

    var self = {};

    /**
     * Content links handler.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUserHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        List of actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a user URL.
            if (url.indexOf('grade/report/user') == -1 &&
                    (url.indexOf('/user/view.php') > -1 || url.indexOf('/user/profile.php') > -1)) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: siteIds,
                        action: function(siteId) {
                            var stateParams = {
                                courseid: params.course,
                                userid: parseInt(params.id, 10)
                            };
                            $mmContentLinksHelper.goInSite('site.mm_user-profile', stateParams, siteId);
                        }
                    }];
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

.constant('mmCoreUsersStore', 'users')

.config(["$mmSitesFactoryProvider", "mmCoreUsersStore", function($mmSitesFactoryProvider, mmCoreUsersStore) {
    var stores = [
        {
            name: mmCoreUsersStore,
            keyPath: 'id'
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Service to provide user functionalities.
 *
 * @module mm.core.user
 * @ngdoc service
 * @name $mmUser
 */
.factory('$mmUser', ["$log", "$q", "$mmSite", "$mmUtil", "$translate", "mmCoreUsersStore", function($log, $q, $mmSite, $mmUtil, $translate, mmCoreUsersStore) {

    $log = $log.getInstance('$mmUser');

    var self = {};

    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @param  {Number} id User ID.
     * @return {Promise}   Promise resolve when the user is deleted.
     */
    self.deleteStoredUser = function(id) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }

        self.invalidateUserCache(id); // Invalidate WS calls.
        return $mmSite.getDb().remove(mmCoreUsersStore, parseInt(id));
    };

    /**
     * Formats a user address, concatenating address, city and country.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#formatAddress
     * @param  {String} address Address.
     * @param  {String} city    City..
     * @param  {String} country Country.
     * @return {String}         Formatted address.
     */
    self.formatAddress = function(address, city, country) {
        if (address) {
            address += city ? ', ' + city : '';
            address += country ? ', ' + country : '';
        }
        return address;
    };

    /**
     * Formats a user role list, translating and concatenating them.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#formatRoleList
     * @param  {Array} roles List of user roles.
     * @return {Promise}     Promise resolved with the formatted roles (string).
     */
    self.formatRoleList = function(roles) {
        var deferred = $q.defer();

        if (roles && roles.length > 0) {
            $translate('mm.core.elementseparator').then(function(separator) {
                var rolekeys = roles.map(function(el) {
                    return 'mm.user.'+el.shortname; // Set the string key to be translated.
                });

                $translate(rolekeys).then(function(roleNames) {
                    var roles = '';
                    for (var roleKey in roleNames) {
                        var roleName = roleNames[roleKey];
                        if (roleName.indexOf('mm.user.') > -1) {
                            // Role name couldn't be translated, leave it like it was.
                            roleName = roleName.replace('mm.user.', '');
                        }
                        roles += (roles != '' ? separator: '') + roleName;
                    }
                    deferred.resolve(roles);
                });
            });
        } else {
            deferred.resolve('');
        }
        return deferred.promise;
    };

    /**
     * Get user profile. The type of profile retrieved depends on the params.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#getProfile
     * @param  {Number} userid      User's ID.
     * @param  {Number} [courseid]  Course ID to get course profile, undefined or 0 to get site profile.
     * @param  {Boolean} forceLocal True to retrieve the user data from local DB, false to retrieve it from WS.
     * @return {Promise}            Promise resolved with the user data.
     */
    self.getProfile = function(userid, courseid, forceLocal) {

        var deferred = $q.defer();

        if (forceLocal) {
            self.getUserFromLocal(userid).then(deferred.resolve, function() {
                self.getUserFromWS(userid, courseid).then(deferred.resolve, deferred.reject);
            });
        } else {
            self.getUserFromWS(userid, courseid).then(deferred.resolve, function() {
                self.getUserFromLocal(userid).then(deferred.resolve, deferred.reject);
            });
        }

        return deferred.promise;
    };

    /**
     * Invalidates user WS calls.
     *
     * @param  {Number} userid User ID.
     * @return {String}        Cache key.
     */
    function getUserCacheKey(userid) {
        return 'mmUser:data:'+userid;
    }

    /**
     * Get user basic information from local DB.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#getUserFromLocal
     * @param  {Number} id User ID.
     * @return {Promise}   Promise resolve when the user is retrieved.
     */
    self.getUserFromLocal = function(id) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }
        return $mmSite.getDb().get(mmCoreUsersStore, parseInt(id));
    };

    /**
     * Get user profile from WS.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#getUserFromWS
     * @param  {Number} id         User ID.
     * @param  {Number} [courseid] Course ID to get course profile, undefined or 0 to get site profile.
     * @return {Promise}           Promise resolve when the user is retrieved.
     */
    self.getUserFromWS = function(userid, courseid) {
        var wsName,
            data,
            preSets ={
                cacheKey: getUserCacheKey(userid)
            };

        // Determine WS and data to use.
        if (courseid > 1) {
            $log.debug('Get participant with ID ' + userid + ' in course '+courseid);
            wsName = 'core_user_get_course_user_profiles';
            data = {
                "userlist[0][userid]": userid,
                "userlist[0][courseid]": courseid
            };
        } else {
            $log.debug('Get user with ID ' + userid);
            if ($mmSite.wsAvailable('core_user_get_users_by_field')) {
                wsName = 'core_user_get_users_by_field';
                data = {
                    'field': 'id',
                    'values[0]': userid
                };
            } else {
                wsName = 'core_user_get_users_by_id';
                data = {
                    'userids[0]': userid
                };
            }
        }

        return $mmSite.read(wsName, data, preSets).then(function(users) {
            if (users.length == 0) {
                return $q.reject();
            }

            var user = users.shift();
            if (user.country) {
                user.country = $mmUtil.getCountryName(user.country);
            }
            self.storeUser(user.id, user.fullname, user.profileimageurl);
            return user;
        });
    };

    /**
     * Invalidates user WS calls.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#invalidateUserCache
     * @param  {Number} userid User ID.
     * @return {Promise}       Promise resolved when the data is invalidated.
     */
    self.invalidateUserCache = function(userid) {
        return $mmSite.invalidateWsCacheForKey(getUserCacheKey(userid));
    };

    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#storeUser
     * @param  {Number} id       User ID.
     * @param  {String} fullname User full name.
     * @param  {String} avatar   User avatar URL.
     * @return {Promise}         Promise resolve when the user is stored.
     */
    self.storeUser = function(id, fullname, avatar) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }

        return $mmSite.getDb().insert(mmCoreUsersStore, {
            id: parseInt(id),
            fullname: fullname,
            profileimageurl: avatar
        });
    };

    /**
     * Store users basic information in local DB.
     *
     * @param  {Object[]} users Users to store. Fields stored: id, fullname, profileimageurl.
     * @return {Promise}        Promise resolve when the user is stored.
     */
    self.storeUsers = function(users) {
        var promises = [];

        angular.forEach(users, function(user) {
            var userid = user.id || user.userid,
                img = user.profileimageurl || user.profileimgurl;
            if (typeof userid != 'undefined') {
                promises.push(self.storeUser(userid, user.fullname, img));
            }
        });

        return $q.all(promises);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar', [])

.constant('mmaCalendarDaysInterval', 30)
.constant('mmaCalendarDefaultNotifTime', 60)
.constant('mmaCalendarComponent', 'mmaCalendarEvents')
.constant('mmaCalendarPriority', 400)

.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaCalendarPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaCalendarPriority) {

    $stateProvider
        .state('site.calendar', {
            url: '/calendar',
            views: {
                'site': {
                    controller: 'mmaCalendarListCtrl',
                    templateUrl: 'addons/calendar/templates/list.html'
                }
            },
            params: {
                eventid: null,
                clear: false
            }
        })

        .state('site.calendar-event', {
            url: '/calendar-event/:id', // We need to add ID to the URL to make ng-href work.
            views: {
                'site': {
                    controller: 'mmaCalendarEventCtrl',
                    templateUrl: 'addons/calendar/templates/event.html'
                }
            }
        });

    // Register side menu addon.
    // FYI: Comment this out to disable from side menu
    $mmSideMenuDelegateProvider.registerNavHandler('mmaCalendar', '$mmaCalendarHandlers.sideMenuNav', mmaCalendarPriority);

}])

.run(["$mmaCalendar", "$mmLocalNotifications", "$state", "$ionicPlatform", "$mmApp", "mmaCalendarComponent", function($mmaCalendar, $mmLocalNotifications, $state, $ionicPlatform, $mmApp, mmaCalendarComponent) {

    // Listen for notification clicks.
    $mmLocalNotifications.registerClick(mmaCalendarComponent, function(data) {
        if (data.eventid) {
            $mmApp.ready().then(function() {
                $state.go('redirect', {siteid: data.siteid, state: 'site.calendar', params: {eventid: data.eventid}});
            });
        }
    });

    $ionicPlatform.ready(function() {
        $mmaCalendar.scheduleAllSitesEventsNotifications();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion', [])

.constant('mmaCourseCompletionPriority', 200)
.constant('mmaCourseCompletionViewCompletionPriority', 200)

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "mmaCourseCompletionPriority", "mmaCourseCompletionViewCompletionPriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, mmaCourseCompletionPriority,
            mmaCourseCompletionViewCompletionPriority) {

    $stateProvider

    .state('site.course-completion', {
        url: '/course-completion',
        views: {
            'site': {
                templateUrl: 'addons/coursecompletion/templates/report.html',
                controller: 'mmaCourseCompletionReportCtrl'
            }
        },
        params: {
            course: null,
            userid: null
        }
    });

    // Register plugin on user profile.
    $mmUserDelegateProvider.registerProfileHandler('mmaCourseCompletion:viewCompletion',
            '$mmaCourseCompletionHandlers.viewCompletion', mmaCourseCompletionViewCompletionPriority);

    // Register courses handler.
    $mmCoursesDelegateProvider.registerNavHandler('mmaCourseCompletion',
            '$mmaCourseCompletionHandlers.coursesNav', mmaCourseCompletionPriority);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files', ['mm.core'])

.constant('mmaFilesUploadStateName', 'site.files-upload')
.constant('mmaFilesSharedFilesStore', 'shared_files')
.constant('mmaFilesMyComponent', 'mmaFilesMy')
.constant('mmaFilesSiteComponent', 'mmaFilesSite')
.constant('mmaFilesPriority', 200)

.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaFilesUploadStateName", "mmaFilesPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaFilesUploadStateName, mmaFilesPriority) {

    $stateProvider
        .state('site.files', {
            url: '/files',
            views: {
                'site': {
                    controller: 'mmaFilesIndexController',
                    templateUrl: 'addons/files/templates/index.html'
                }
            }
        })

        .state('site.files-list', {
            url: '/list',
            params: {
                path: false,
                root: false,
                title: false
            },
            views: {
                'site': {
                    controller: 'mmaFilesListController',
                    templateUrl: 'addons/files/templates/list.html'
                }
            }
        })

        .state(mmaFilesUploadStateName, {
            url: '/upload',
            params: {
                path: false,
                root: false
            },
            views: {
                'site': {
                    controller: 'mmaFilesUploadCtrl',
                    templateUrl: 'addons/files/templates/upload.html'
                }
            }
        })

        .state('site.files-choose-site', {
            url: '/choose-site',
            params: {
                file: null
            },
            views: {
                'site': {
                    controller: 'mmaFilesChooseSiteCtrl',
                    templateUrl: 'addons/files/templates/choosesite.html'
                }
            }
        });

    // Register side menu addon.
    $mmSideMenuDelegateProvider.registerNavHandler('mmaFiles', '$mmaFilesHandlers.sideMenuNav', mmaFilesPriority);

}])

.run(["$mmaFiles", "$state", "$mmSitesManager", "$mmUtil", "$mmaFilesHelper", "$ionicPlatform", "$mmApp", function($mmaFiles, $state, $mmSitesManager, $mmUtil, $mmaFilesHelper, $ionicPlatform, $mmApp) {

    // Search for new files shared with the upload (to upload).
    if (ionic.Platform.isIOS()) {
        // In iOS we need to manually check if there are new files in the app Inbox folder.
        function searchToUpload() {
            $mmApp.ready().then(function() {
                $mmaFiles.checkIOSNewFiles().then(function(fileEntry) {
                    $mmSitesManager.getSites().then(function(sites) {
                        if (sites.length == 0) {
                            $mmUtil.showErrorModal('mma.files.errorreceivefilenosites', true);
                        } else if (sites.length == 1) {
                            $mmaFilesHelper.showConfirmAndUploadInSite(fileEntry, sites[0].id);
                        } else {
                            $state.go('site.files-choose-site', {file: fileEntry});
                        }
                    });
                });
            });
        }
        // We want to check it at app start and when the app is resumed.
        $ionicPlatform.on('resume', searchToUpload);
        searchToUpload();
    }

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.frontpage', [])

.constant('mmaFrontpagePriority', 1000)

.config(["$mmSideMenuDelegateProvider", "mmaFrontpagePriority", function($mmSideMenuDelegateProvider, mmaFrontpagePriority) {
    // Register side menu addon.
    //$mmSideMenuDelegateProvider.registerNavHandler('mmaFrontpage', '$mmaFrontPageHandlers.sideMenuNav', mmaFrontpagePriority);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades', [])

.constant('mmaGradesPriority', 400)
.constant('mmaGradesViewGradesPriority', 400)

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "$mmContentLinksDelegateProvider", "mmaGradesPriority", "mmaGradesViewGradesPriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, $mmContentLinksDelegateProvider,
            mmaGradesPriority, mmaGradesViewGradesPriority) {

    $stateProvider

    .state('site.grades', {
        url: '/grades',
        views: {
            'site': {
                templateUrl: 'addons/grades/templates/table.html',
                controller: 'mmaGradesTableCtrl'
            }
        },
        params: {
            course: null,
            userid: null
        }
    });


    // Register plugin on user profile.
    $mmUserDelegateProvider.registerProfileHandler('mmaGrades:viewGrades', '$mmaGradesHandlers.viewGrades', mmaGradesViewGradesPriority);

    // Register courses content plugin.
    $mmCoursesDelegateProvider.registerNavHandler('mmaGrades', '$mmaGradesHandlers.coursesNav', mmaGradesPriority);

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaGrades', '$mmaGradesHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages', ['mm.core'])

.constant('mmaMessagesDiscussionLoadedEvent', 'mma_messages_discussion_loaded')
.constant('mmaMessagesDiscussionLeftEvent', 'mma_messages_discussion_left')
.constant('mmaMessagesPollInterval', 5000)
.constant('mmaMessagesPriority', 600)
.constant('mmaMessagesSendMessagePriority', 1000)
.constant('mmaMessagesAddContactPriority', 800)
.constant('mmaMessagesBlockContactPriority', 600)
.constant('mmaMessagesNewMessageEvent', 'mma-messages_new_message')

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmSideMenuDelegateProvider", "mmaMessagesSendMessagePriority", "mmaMessagesAddContactPriority", "mmaMessagesBlockContactPriority", "mmaMessagesPriority", "$mmContentLinksDelegateProvider", function($stateProvider, $mmUserDelegateProvider, $mmSideMenuDelegateProvider, mmaMessagesSendMessagePriority,
            mmaMessagesAddContactPriority, mmaMessagesBlockContactPriority, mmaMessagesPriority, $mmContentLinksDelegateProvider) {

    $stateProvider

    .state('site.messages', {
        url: '/messages',
        views: {
            'site': {
                templateUrl: 'addons/messages/templates/index.html',
                controller: 'mmaMessagesIndexCtrl'
            }
        }
    })

    .state('site.messages-discussion', {
        url: '/messages-discussion',
        params: {
            userId: null,
            userFullname: null
        },
        views: {
            'site': {
                templateUrl: 'addons/messages/templates/discussion.html',
                controller: 'mmaMessagesDiscussionCtrl'
            }
        }
    });

    // Register side menu addon.
    $mmSideMenuDelegateProvider.registerNavHandler('mmaMessages', '$mmaMessagesHandlers.sideMenuNav', mmaMessagesPriority);

    // Register user profile addons.
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:sendMessage', '$mmaMessagesHandlers.sendMessage', mmaMessagesSendMessagePriority);
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:addContact', '$mmaMessagesHandlers.addContact', mmaMessagesAddContactPriority);
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:blockContact', '$mmaMessagesHandlers.blockContact', mmaMessagesBlockContactPriority);

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaMessages', '$mmaMessagesHandlers.linksHandler');
}])

.run(["$mmaMessages", "$mmEvents", "$state", "$mmAddonManager", "$mmUtil", "mmCoreEventLogin", function($mmaMessages, $mmEvents, $state, $mmAddonManager, $mmUtil, mmCoreEventLogin) {

    // Invalidate messaging enabled WS calls.
    $mmEvents.on(mmCoreEventLogin, function() {
        $mmaMessages.invalidateEnabledCache();
    });

    // Register push notification clicks.
    var $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate');
    if ($mmPushNotificationsDelegate) {
        $mmPushNotificationsDelegate.registerHandler('mmaMessages', function(notification) {
            if ($mmUtil.isFalseOrZero(notification.notif)) {
                $mmaMessages.isMessagingEnabledForSite(notification.site).then(function() {
                    $mmaMessages.invalidateDiscussionsCache().finally(function() {
                        $state.go('redirect', {siteid: notification.site, state: 'site.messages'});
                    });
                });
                return true;
            }
        });
    }

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign', ['mm.core'])

.constant('mmaModAssignComponent', 'mmaModAssign')
.constant('mmaModAssignSubmissionComponent', 'mmaModAssignSubmission')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_assign', {
        url: '/mod_assign',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignIndexCtrl',
                templateUrl: 'addons/mod_assign/templates/index.html'
            }
        }
    })

    .state('site.mod_assign-submission', {
        url: '/mod_assign-submission',
        params: {
            submission: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignSubmissionCtrl',
                templateUrl: 'addons/mod_assign/templates/submission.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModAssign', 'assign', '$mmaModAssignHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModAssign', '$mmaModAssignHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book', ['mm.core'])

.constant('mmaModBookComponent', 'mmaModBook')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_book', {
      url: '/mod_book',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModBookIndexCtrl',
          templateUrl: 'addons/mod_book/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModBook', 'book', '$mmaModBookHandlers.courseContentHandler');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModBook', 'book', '$mmaModBookPrefetchHandler');

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModBook', '$mmaModBookHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat', [])

.constant('mmaChatPollInterval', 4000)

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_chat', {
        url: '/mod_chat',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModChatIndexCtrl',
                templateUrl: 'addons/mod_chat/templates/index.html'
            }
        }
    })

    .state('site.mod_chat-chat', {
        url: '/mod_chat-chat',
        params: {
            chatid: null,
            courseid: null,
            title: null
        },
        views: {
            'site': {
                controller: 'mmaModChatChatCtrl',
                templateUrl: 'addons/mod_chat/templates/chat.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModChat', 'chat', '$mmaModChatHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModChat', '$mmaModChatHandlers.linksHandler');
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice', [])

.constant('mmaModChoiceResultsNot', 0)
.constant('mmaModChoiceResultsAfterAnswer', 1)
.constant('mmaModChoiceResultsAfterClose', 2)
.constant('mmaModChoiceResultsAlways', 3)

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_choice', {
        url: '/mod_choice',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModChoiceIndexCtrl',
                templateUrl: 'addons/mod_choice/templates/index.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModChoice', 'choice', '$mmaModChoiceHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModChoice', '$mmaModChoiceHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder', ['mm.core'])

.constant('mmaModFolderComponent', 'mmaModFolder')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_folder', {
      url: '/mod_folder',
      params: {
        module: null,
        courseid: null,
        sectionid: null,
        path: null // For subfolders. Use the path instead of a boolean so Angular detects them as different states.
      },
      views: {
        'site': {
          controller: 'mmaModFolderIndexCtrl',
          templateUrl: 'addons/mod_folder/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModFolder', 'folder', '$mmaModFolderHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModFolder', 'folder', '$mmaModFolderPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModFolder', '$mmaModFolderHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum', [])

.constant('mmaModForumDiscPerPage', 10) // Max of discussions per page.
.constant('mmaModForumComponent', 'mmaModForum')
.constant('mmaModForumNewDiscussionEvent', 'mma-mod_forum_new_discussion')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_forum', {
        url: '/mod_forum',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModForumDiscussionsCtrl',
                templateUrl: 'addons/mod_forum/templates/discussions.html'
            }
        }
    })

    .state('site.mod_forum-discussion', {
        url: '/mod_forum-discussion',
        params: {
            discussionid: null,
            cid: null // Not naming it courseid because it collides with 'site.mod_forum' param in split-view.
        },
        views: {
            'site': {
                controller: 'mmaModForumDiscussionCtrl',
                templateUrl: 'addons/mod_forum/templates/discussion.html'
            }
        }
    })

    .state('site.mod_forum-newdiscussion', {
        url: '/mod_forum-newdiscussion',
        params: {
            cid: null, // Not naming it courseid because it collides with 'site.mod_forum' param in split-view.
            forumid: null,
            cmid: null
        },
        views: {
            'site': {
                controller: 'mmaModForumNewDiscussionCtrl',
                templateUrl: 'addons/mod_forum/templates/newdiscussion.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModForum', 'forum', '$mmaModForumHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModForum', '$mmaModForumHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary', ['mm.core'])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_glossary', {
      url: '/mod_glossary',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModGlossaryIndexCtrl',
          templateUrl: 'addons/mod_glossary/templates/index.html'
        }
      }
    })

    .state('site.mod_glossary-entry', {
      url: '/mod_glossary-entry',
      params: {
        cid: null, // Not naming it courseid because it collides with 'site.mod_glossary' param in split-view.
        entry: null
      },
      views: {
        'site': {
          controller: 'mmaModGlossaryEntryCtrl',
          templateUrl: 'addons/mod_glossary/templates/entry.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModGlossary', 'glossary', '$mmaModGlossaryHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModGlossary', '$mmaModGlossaryHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp', ['mm.core'])

.constant('mmaModImscpComponent', 'mmaModImscp')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_imscp', {
      url: '/mod_imscp',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModImscpIndexCtrl',
          templateUrl: 'addons/mod_imscp/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModImscp', 'imscp', '$mmaModImscpHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModImscp', 'imscp', '$mmaModImscpPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModImscp', '$mmaModImscpHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_label', ['mm.core'])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider
    .state('site.mod_label', {
        url: '/mod_label',
        params: {
            description: null
        },
        views: {
            'site': {
                templateUrl: 'addons/mod_label/templates/index.html',
                controller: 'mmaModLabelIndexCtrl'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModLabel', 'label', '$mmaModLabelHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModLabel', '$mmaModLabelHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti', [])

.constant('mmaModLtiComponent', 'mmaModLti')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_lti', {
        url: '/mod_lti',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModLtiIndexCtrl',
                templateUrl: 'addons/mod_lti/templates/index.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModLti', 'lti', '$mmaModLtiHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModLti', '$mmaModLtiHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page', ['mm.core'])

.constant('mmaModPageComponent', 'mmaModPage')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_page', {
      url: '/mod_page',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModPageIndexCtrl',
          templateUrl: 'addons/mod_page/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModPage', 'page', '$mmaModPageHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModPage', 'page', '$mmaModPagePrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModPage', '$mmaModPageHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource', ['mm.core'])

.constant('mmaModResourceComponent', 'mmaModResource')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_resource', {
      url: '/mod_resource',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModResourceIndexCtrl',
          templateUrl: 'addons/mod_resource/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModResource', 'resource', '$mmaModResourceHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModResource', 'resource', '$mmaModResourcePrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModResource', '$mmaModResourceHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm', ['mm.core'])

.constant('mmaModScormComponent', 'mmaModScorm')
.constant('mmaModScormEventLaunchNextSco', 'mma_mod_scorm_launch_next_sco')
.constant('mmaModScormEventLaunchPrevSco', 'mma_mod_scorm_launch_prev_sco')
.constant('mmaModScormEventUpdateToc', 'mma_mod_scorm_update_toc')
.constant('mmaModScormEventGoOffline', 'mma_mod_scorm_go_offline')
.constant('mmaModScormEventAutomSynced', 'mma_mod_scorm_autom_synced')
.constant('mmaModScormSyncTime', 200000) // In milliseconds.

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_scorm', {
      url: '/mod_scorm',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModScormIndexCtrl',
          templateUrl: 'addons/mod_scorm/templates/index.html'
        }
      }
    })

    .state('site.mod_scorm-player', {
      url: '/mod_scorm-player',
      params: {
        scorm: null,
        mode: null,
        newAttempt: false,
        organizationId: null,
        scoId: null
      },
      views: {
        'site': {
          controller: 'mmaModScormPlayerCtrl',
          templateUrl: 'addons/mod_scorm/templates/player.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModScorm', 'scorm', '$mmaModScormHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModScorm', 'scorm', '$mmaModScormPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModScorm', '$mmaModScormHandlers.linksHandler');
}])

.run(["$timeout", "$mmaModScormSync", "$mmApp", "$mmEvents", "$mmSite", "mmCoreEventLogin", function($timeout, $mmaModScormSync, $mmApp, $mmEvents, $mmSite, mmCoreEventLogin) {
    var lastExecution = 0,
        executing = false,
        allSitesCalled = false;

    function syncScorms(allSites) {
        var now = new Date().getTime();

        if (!allSites && !$mmSite.isLoggedIn()) {
            return;
        }

        // Prevent consecutive and simultaneous executions. A sync process shouldn't take more than a few minutes,
        // so if it's been more than 5 minutes since the last execution we'll ignore the executing value.
        if (now - 5000 > lastExecution && (!executing || now - 300000 > lastExecution)) {
            lastExecution = new Date().getTime();
            executing = true;

            $timeout(function() { // Minor delay just to make sure network is fully established.
                $mmaModScormSync.syncAllScorms(allSites ? undefined : $mmSite.getId()).finally(function() {
                    executing = false;
                });
            }, 1000);
        }
    }

    $mmApp.ready().then(function() {
        document.addEventListener('online', function() {
            syncScorms(false);
        }, false); // Cordova event.
        window.addEventListener('online', function() {
            syncScorms(false);
        }, false); // HTML5 event.

        if (!$mmSite.isLoggedIn()) {
            // App was started without any site logged in. Try to sync all sites.
            allSitesCalled = true;
            if ($mmApp.isOnline()) {
                syncScorms(true);
            }
        }
    });

    $mmEvents.on(mmCoreEventLogin, function() {
        var allSites = false;
        if (!allSitesCalled) {
            // App started with a site logged in. Try to sync all sites.
            allSitesCalled = true;
            allSites = true;
        }

        if ($mmApp.isOnline()) {
            syncScorms(allSites);
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_survey', {
        url: '/mod_survey',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModSurveyIndexCtrl',
                templateUrl: 'addons/mod_survey/templates/index.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModSurvey', 'survey', '$mmaModSurveyHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModSurvey', '$mmaModSurveyHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url', ['mm.core'])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_url', {
      url: '/mod_url',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModUrlIndexCtrl',
          templateUrl: 'addons/mod_url/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModUrl', 'url', '$mmaModUrlHandlers.courseContentHandler');

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModUrl', '$mmaModUrlHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes', [])

.constant('mmaNotesPriority', 200)
.constant('mmaNotesAddNotePriority', 200)

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "mmaNotesPriority", "mmaNotesAddNotePriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, mmaNotesPriority, mmaNotesAddNotePriority) {

    $stateProvider

    .state('site.notes-types', {
        url: '/notes-types',
        views: {
            'site': {
                templateUrl: 'addons/notes/templates/types.html',
                controller: 'mmaNotesTypesCtrl'
            }
        },
        params: {
            course: null
        }
    })

    .state('site.notes-list', {
        url: '/notes-list',
        views: {
            'site': {
                templateUrl: 'addons/notes/templates/list.html',
                controller: 'mmaNotesListCtrl'
            }
        },
        params: {
            courseid: null,
            type: null
        }
    });

    // Register plugin on user profile.
    $mmUserDelegateProvider.registerProfileHandler('mmaNotes:addNote', '$mmaNotesHandlers.addNote', mmaNotesAddNotePriority);

    // Register courses handler.
    $mmCoursesDelegateProvider.registerNavHandler('mmaNotes', '$mmaNotesHandlers.coursesNav', mmaNotesPriority);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications', [])

.constant('mmaNotificationsListLimit', 20) // Max of notifications to retrieve in each WS call.
.constant('mmaNotificationsPriority', 800)

.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaNotificationsPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaNotificationsPriority) {

    $stateProvider

    .state('site.notifications', {
        url: '/notifications',
        views: {
            'site': {
                templateUrl: 'addons/notifications/templates/list.html',
                controller: 'mmaNotificationsListCtrl'
            }
        }
    });

    // Register side menu addon.
    $mmSideMenuDelegateProvider.registerNavHandler('mmaNotifications', '$mmaNotificationsHandlers.sideMenuNav', mmaNotificationsPriority);
}])

.run(["$log", "$mmaNotifications", "$mmUtil", "$state", "$mmAddonManager", function($log, $mmaNotifications, $mmUtil, $state, $mmAddonManager) {
    $log = $log.getInstance('mmaNotifications');

    // Register push notification clicks.
    var $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate');
    if ($mmPushNotificationsDelegate) {
        $mmPushNotificationsDelegate.registerHandler('mmaNotifications', function(notification) {
            if ($mmUtil.isTrueOrOne(notification.notif)) {
                $mmaNotifications.isPluginEnabledForSite(notification.site).then(function() {
                    $mmaNotifications.invalidateNotificationsList().finally(function() {
                        $state.go('redirect', {siteid: notification.site, state: 'site.notifications'});
                    });
                });
                return true;
            }
        });
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants', [])

.constant('mmaParticipantsListLimit', 50) // Max of participants to retrieve in each WS call.
.constant('mmaParticipantsPriority', 600)

.config(["$stateProvider", "$mmCoursesDelegateProvider", "$mmContentLinksDelegateProvider", "mmaParticipantsPriority", function($stateProvider, $mmCoursesDelegateProvider, $mmContentLinksDelegateProvider, mmaParticipantsPriority) {

    $stateProvider
        .state('site.participants', {
            url: '/participants',
            views: {
                'site': {
                    controller: 'mmaParticipantsListCtrl',
                    templateUrl: 'addons/participants/templates/list.html'
                }
            },
            params: {
                course: null
            }
        });

    $mmCoursesDelegateProvider.registerNavHandler('mmaParticipants', '$mmaParticipantsHandlers.coursesNavHandler',
                mmaParticipantsPriority);

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaParticipants', '$mmaParticipantsHandlers.linksHandler');

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.pushnotifications', [])

.constant('mmaPushNotificationsComponent', 'mmaPushNotifications')

.run(["$mmaPushNotifications", "$ionicPlatform", "$rootScope", "$mmEvents", "$mmLocalNotifications", "mmCoreEventLogin", "mmaPushNotificationsComponent", "mmCoreEventSiteDeleted", function($mmaPushNotifications, $ionicPlatform, $rootScope, $mmEvents, $mmLocalNotifications, mmCoreEventLogin,
            mmaPushNotificationsComponent, mmCoreEventSiteDeleted) {

    // Register device on GCM or APNS server.
    $ionicPlatform.ready(function() {
        $mmaPushNotifications.registerDevice();
    });

    // Notification received.
    $rootScope.$on('$cordovaPush:notificationReceived', function(e, notification) {
        if (ionic.Platform.isAndroid()) {
            $mmaPushNotifications.onGCMReceived(notification);
        } else if (ionic.Platform.isIOS()) {
            $mmaPushNotifications.onMessageReceived(notification);
        }
    });

    // Register device on Moodle site when login.
    $mmEvents.on(mmCoreEventLogin, function() {
        $mmaPushNotifications.registerDeviceOnMoodle();
    });

    $mmEvents.on(mmCoreEventSiteDeleted, function(site) {
        $mmaPushNotifications.unregisterDeviceOnMoodle(site);
    });

    // Listen for local notification clicks (generated by the app).
    $mmLocalNotifications.registerClick(mmaPushNotificationsComponent, $mmaPushNotifications.notificationClicked);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.remotestyles', [])

.constant('mmaRemoteStylesComponent', 'mmaRemoteStyles')

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventLogout", "mmCoreEventSiteAdded", "mmCoreEventSiteUpdated", "$mmaRemoteStyles", "$mmSite", function($mmEvents, mmCoreEventLogin, mmCoreEventLogout, mmCoreEventSiteAdded, mmCoreEventSiteUpdated, $mmaRemoteStyles,
            $mmSite) {

    $mmEvents.on(mmCoreEventSiteAdded, $mmaRemoteStyles.load);
    $mmEvents.on(mmCoreEventSiteUpdated, function(siteid) {
        // Load only if current site was updated.
        if (siteid === $mmSite.getId()) {
            $mmaRemoteStyles.load();
        }
    });
    $mmEvents.on(mmCoreEventLogin, $mmaRemoteStyles.load);

    // Remove added styles on logout.
    $mmEvents.on(mmCoreEventLogout, $mmaRemoteStyles.clear);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

/**
 * Controller to handle an event.
 *
 * @module mm.addons.calendar
 * @ngdoc controller
 * @name mmaCalendarEventCtrl
 */
.controller('mmaCalendarEventCtrl', ["$scope", "$log", "$stateParams", "$mmaCalendar", "$mmUtil", "$mmCourse", "$mmCourses", "$mmLocalNotifications", function($scope, $log, $stateParams, $mmaCalendar, $mmUtil, $mmCourse, $mmCourses,
        $mmLocalNotifications) {

    $log = $log.getInstance('mmaCalendarEventCtrl');

    var eventid = parseInt($stateParams.id);

    // Convenience function that fetches the event and updates the scope.
    function fetchEvent(refresh) {
        return $mmaCalendar.getEvent(eventid, refresh).then(function(e) {
            $mmaCalendar.formatEventData(e);
            $scope.event = e;
            $scope.title = e.name;

            if (e.moduleicon) {
                // It's a module event, translate the module name to the current language.
                $mmCourse.translateModuleName(e.modulename).then(function(name) {
                    if (name.indexOf('mm.core.mod') === -1) {
                        e.modulename = name;
                    }
                });
            }

            if (e.courseid > 1) {
                // It's a course event, retrieve the course name.
                $mmCourses.getUserCourse(e.courseid, true).then(function(course) {
                    $scope.coursename = course.fullname;
                });
            }

        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.calendar.errorloadevent', true);
            }
        });
    }

    // Get event.
    fetchEvent().finally(function() {
        $scope.eventLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshEvent = function() {
        fetchEvent(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.notificationsEnabled = $mmLocalNotifications.isAvailable();
    if ($scope.notificationsEnabled) {

        $mmaCalendar.getEventNotificationTime(eventid).then(function(notificationtime) {
            $scope.notification = { // Use an object, otherwise changes are not reflected.
                time: String(notificationtime)
            };
        });

        $scope.updateNotificationTime = function() {
            var time = parseInt($scope.notification.time);
            if (!isNaN(time) && $scope.event && $scope.event.id) {
                $mmaCalendar.updateNotificationTime($scope.event, time);
            }
        };
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

/**
 * Controller to handle calendar events.
 *
 * @module mm.addons.calendar
 * @ngdoc controller
 * @name mmaCalendarListCtrl
 */
.controller('mmaCalendarListCtrl', ["$scope", "$stateParams", "$log", "$state", "$mmaCalendar", "$mmUtil", "$ionicHistory", "mmaCalendarDaysInterval", function($scope, $stateParams, $log, $state, $mmaCalendar, $mmUtil, $ionicHistory,
        mmaCalendarDaysInterval) {

    $log = $log.getInstance('mmaCalendarListCtrl');

    var daysLoaded,
        emptyEventsTimes; // Variable to identify consecutive calls returning 0 events.

    if ($stateParams.eventid) {
        // We arrived here via notification click, let's clear history and redirect to event details.
        $ionicHistory.clearHistory();
        $state.go('site.calendar-event', {id: $stateParams.eventid});
    }

    // Convenience function to initialize variables.
    function initVars() {
        daysLoaded = 0;
        emptyEventsTimes = 0;
        $scope.events = [];
    }

    // Convenience function that fetches the events and updates the scope.
    function fetchEvents(refresh) {
        if (refresh) {
            initVars();
        }
        $scope.canLoadMore = false; // Set it to false to prevent consecutive calls.

        return $mmaCalendar.getEvents(daysLoaded, mmaCalendarDaysInterval, refresh).then(function(events) {
            daysLoaded += mmaCalendarDaysInterval;

            if (events.length === 0) {
                emptyEventsTimes++;
                if (emptyEventsTimes > 5) { // Stop execution if we retrieve empty list 6 consecutive times.
                    $scope.canLoadMore = false;
                    $scope.eventsLoaded = true;
                } else {
                    // No events returned, load next events.
                    return fetchEvents();
                }
            } else {
                angular.forEach(events, $mmaCalendar.formatEventData);
                if (refresh) {
                    $scope.events = events;
                } else {
                    $scope.events = $scope.events.concat(events);
                }
                $scope.count = $scope.events.length;
                $scope.eventsLoaded = true;
                $scope.canLoadMore = true;

                // Schedule notifications for the events retrieved (might have new events).
                $mmaCalendar.scheduleEventsNotifications(events);
            }
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.calendar.errorloadevents', true);
            }
            $scope.eventsLoaded = true;
        });
    }

    initVars();
    $scope.count = 0;

    // Get first events.
    fetchEvents();

    // Load more events.
    $scope.loadMoreEvents = function() {
        fetchEvents().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };

    // Pull to refresh.
    $scope.refreshEvents = function() {
        $mmaCalendar.invalidateEventsList().finally(function() {
            fetchEvents(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

.constant('mmaCalendarEventsStore', 'calendar_events')

.config(["$mmSitesFactoryProvider", "mmaCalendarEventsStore", function($mmSitesFactoryProvider, mmaCalendarEventsStore) {
    var stores = [
        {
            name: mmaCalendarEventsStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'notificationtime'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Service to handle calendar events.
 *
 * @module mm.addons.calendar
 * @ngdoc service
 * @name $mmaCalendar
 */
.factory('$mmaCalendar', ["$log", "$q", "$mmSite", "$mmUtil", "$mmCourses", "$mmGroups", "$mmCourse", "$mmLocalNotifications", "$mmSitesManager", "mmCoreSecondsDay", "mmaCalendarDaysInterval", "mmaCalendarEventsStore", "mmaCalendarDefaultNotifTime", "mmaCalendarComponent", function($log, $q, $mmSite, $mmUtil, $mmCourses, $mmGroups, $mmCourse, $mmLocalNotifications,
        $mmSitesManager, mmCoreSecondsDay, mmaCalendarDaysInterval, mmaCalendarEventsStore, mmaCalendarDefaultNotifTime,
        mmaCalendarComponent) {

    $log = $log.getInstance('$mmaCalendar');

    var self = {},
        calendarImgPath = 'addons/calendar/img/',
        eventicons = {
            'course': calendarImgPath + 'courseevent.svg',
            'group': calendarImgPath + 'groupevent.svg',
            'site': calendarImgPath + 'siteevent.svg',
            'user': calendarImgPath + 'userevent.svg'
        };

    /**
     * Get cache key for events list WS calls.
     *
     * @param {Number} daysToStart  Number of days from now to start getting events.
     * @param {Number} daysInterval Number of days between timestart and timeend.
     * @return {String} Cache key.
     */
    function getEventsListCacheKey(daysToStart, daysInterval) {
        return 'mmaCalendar:events:' + daysToStart + ':' + daysInterval;
    }

    /**
     * Get cache key for a single event WS call.
     *
     * @param {Number} id Event ID.
     * @return {String} Cache key.
     */
    function getEventCacheKey(id) {
        return 'mmaCalendar:events:' + id;
    }

    /**
     * Get the common part of the cache keys for events WS calls. Invalidate the whole list also invalidates all the
     * single events.
     *
     * @return {String} Cache key.
     */
    function getEventsCommonCacheKey() {
        return 'mmaCalendar:events:';
    }

    /**
     * Store events in local DB.
     *
     * @param {Object[]} events  Events to store.
     * @param  {String} [siteid] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise}         Promise resolved when the events are stored.
     */
    function storeEventsInLocalDB(events, siteid) {
        siteid = siteid || $mmSite.getId();

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var promises = [],
                db = site.getDb();

            angular.forEach(events, function(event) {
                // Get the event notification time to prevent overriding it in DB.
                var promise = self.getEventNotificationTime(event.id, siteid).then(function(time) {
                    event.notificationtime = time;
                    return db.insert(mmaCalendarEventsStore, event);
                });
                promises.push(promise);
            });

            return $q.all(promises);
        });
    }

    /**
     * Convenience function to format some event data to be rendered. Adds properties 'start', 'end', 'icon'
     * and (if it's a module event) 'moduleicon'.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#formatEventData
     * @param {Object} e Event to format.
     */
    self.formatEventData = function(e) {
        var icon = self.getEventIcon(e.eventtype);
        if (icon === '') {
            // It's a module event.
            icon = $mmCourse.getModuleIconSrc(e.modulename);
            e.moduleicon = icon;
        }
        e.icon = icon;
    };

    /**
     * Get a calendar event from server or cache. If the server request fails and data is not cached,
     * try to get it from local DB.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEvent
     * @param {Number}  id        Event ID.
     * @param {Boolean} [refresh] True when we should update the event data.
     * @return {Promise}          Promise resolved when the event data is retrieved.
     */
    self.getEvent = function(id, refresh) {
        var presets = {},
            data = {
                "options[userevents]": 0,
                "options[siteevents]": 0,
                "events[eventids][0]": id
            };

        presets.cacheKey = getEventCacheKey(id);
        if (refresh) {
            presets.getFromCache = false;
        }
        return $mmSite.read('core_calendar_get_calendar_events', data, presets).then(function(response) {
            var e = response.events[0];
            if (e) {
                return e;
            } else {
                return self.getEventFromLocalDb(id);
            }
        }, function() {
            return self.getEventFromLocalDb(id);
        });
    };

    /**
     * Get a calendar event from local Db.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEventFromLocalDb
     * @param {Number}  id Event ID.
     * @return {Promise}   Promise resolved when the event data is retrieved.
     */
    self.getEventFromLocalDb = function(id) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }
        return $mmSite.getDb().get(mmaCalendarEventsStore, id);
    };

    /**
     * Get event icon name based on event type.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEventIcon
     * @param  {String} type Event type.
     * @return {String}      Event icon name. If type not valid, return empty string.
     */
    self.getEventIcon = function(type) {
        return eventicons[type] || '';
    };

    /**
     * Get event notification time.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEventNotificationTime
     * @param  {Number} id       Event ID.
     * @param  {String} [siteid] ID of the site the event belongs to. If not defined, use current site.
     * @return {String}          Event icon name. If type not valid, return empty string.
     */
    self.getEventNotificationTime = function(id, siteid) {
        siteid = siteid || $mmSite.getId();

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var db = site.getDb();

            return db.get(mmaCalendarEventsStore, id).then(function(e) {
                if (typeof e.notificationtime != 'undefined') {
                    return e.notificationtime;
                }
                return mmaCalendarDefaultNotifTime;
            }, function(err) {
                return mmaCalendarDefaultNotifTime;
            });
        });
    };

    /**
     * Get calendar events in a certain period.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEvents
     * @param {Number} [daysToStart=0]   Number of days from now to start getting events.
     * @param {Number} [daysInterval=30] Number of days between timestart and timeend.
     * @param {Boolean} [refresh]        True when we should not get the value from the cache.
     * @param {String} [siteid]          Site to get the events from. If not defined, use current site.
     * @return {Promise}                 Promise to be resolved when the participants are retrieved.
     * @description
     * Get the events in a certain period. The period is calculated like this:
     *     start time: now + daysToStart
     *     end time: start time + daysInterval
     * E.g. using $mmaCalendar.getEvents(30, 30) is going to get the events starting after 30 days from now
     * and ending before 60 days from now.
     */
    self.getEvents = function(daysToStart, daysInterval, refresh, siteid) {
        daysToStart = daysToStart || 0;
        daysInterval = daysInterval || mmaCalendarDaysInterval;
        siteid = siteid || $mmSite.getId();

         var now = $mmUtil.timestamp(),
            start = now + (mmCoreSecondsDay * daysToStart),
            end = start + (mmCoreSecondsDay * daysInterval);

        // The core_calendar_get_calendar_events needs all the current user courses and groups.
        var data = {
            "options[userevents]": 1,
            "options[siteevents]": 1,
            "options[timestart]": start,
            "options[timeend]": end
        };

        return $mmCourses.getUserCourses(false, siteid).then(function(courses) {
            courses.push({id: 1}); // Add front page.
            angular.forEach(courses, function(course, index) {
                data["events[courseids][" + index + "]"] = course.id;
            });

            return $mmGroups.getUserGroups(courses, refresh, siteid).then(function(groups) {
                angular.forEach(groups, function(group, index) {
                    data["events[groupids][" + index + "]"] = group.id;
                });

                return $mmSitesManager.getSite(siteid).then(function(site) {

                    // We need to retrieve cached data using cache key because we have timestamp in the params.
                    var preSets = {
                        cacheKey: getEventsListCacheKey(daysToStart, daysInterval),
                        getCacheUsingCacheKey: true
                    };
                    return site.read('core_calendar_get_calendar_events', data, preSets).then(function(response) {
                        storeEventsInLocalDB(response.events, siteid);
                        return response.events;
                    });
                });
            });

        });
    };

    /**
     * Invalidates events list and all the single events.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#invalidateEventsList
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateEventsList = function() {
        var p1 = $mmCourses.invalidateUserCourses(),
            p2 = $mmSite.invalidateWsCacheForKeyStartingWith(getEventsCommonCacheKey());
        return $q.all([p1, p2]);
    };

    /**
     * Check if calendar events WS is available.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#isAvailable
     * @return {Boolean} True if calendar events WS is available, false otherwise.
     */
    self.isAvailable = function() {
        return $mmSite.wsAvailable('core_calendar_get_calendar_events');
    };

    /**
     * Get the next events for all the sites and schedules their notifications.
     * If an event notification time is 0, cancel its scheduled notification (if any).
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#scheduleAllSitesEventsNotifications
     * @param  {Object[]} events Events to schedule.
     * @return {Promise}         Promise resolved when all the notifications have been scheduled.
     */
    self.scheduleAllSitesEventsNotifications = function() {

        if ($mmLocalNotifications.isAvailable()) {
            return $mmSitesManager.getSitesIds().then(function(siteids) {

                var promises = [];
                angular.forEach(siteids, function(siteid) {
                    // Get first events.
                    var promise = self.getEvents(undefined, undefined, false, siteid).then(function(events) {
                        return self.scheduleEventsNotifications(events, siteid);
                    });
                    promises.push(promise);
                });

                return $q.all(promises);
            });
        } else {
            var deferred = $q.defer();
            deferred.resolve();
            return deferred.promise;
        }
    };

    /**
     * Schedules an event notification. If time is 0, cancel scheduled notification if any.
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#scheduleEventNotification
     * @param  {Object} event    Event to schedule.
     * @param  {Number} time     Notification setting time (in minutes). E.g. 10 means "notificate 10 minutes before start".
     * @param  {String} [siteid] Site ID the event belongs to. If not defined, use current site.
     * @return {Promise}       Promise resolved when the notification is scheduled.
     */
    self.scheduleEventNotification = function(event, time, siteid) {
        siteid = siteid || $mmSite.getId();

        if ($mmLocalNotifications.isAvailable()) {
            if (time === 0) {
                return $mmLocalNotifications.cancel(event.id, mmaCalendarComponent, siteid); // Cancel if it was scheduled.
            } else {
                var timeend = (event.timestart + event.timeduration) * 1000;
                if (timeend <= new Date().getTime()) {
                    // The event has finished already, don't schedule it.
                    return $q.when();
                }

                var dateTriggered = new Date((event.timestart - (time * 60)) * 1000),
                    startDate = new Date(event.timestart * 1000),
                    notification = {
                        id: event.id,
                        title: event.name,
                        message: startDate.toLocaleString(),
                        at: dateTriggered,
                        smallIcon: 'res://icon',
                        data: {
                            eventid: event.id,
                            siteid: siteid
                        }
                    };

                return $mmLocalNotifications.schedule(notification, mmaCalendarComponent, siteid);
            }
        } else {
            return $q.when();
        }
    };

    /**
     * Schedules the notifications for a list of events.
     * If an event notification time is 0, cancel its scheduled notification (if any).
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#scheduleEventsNotifications
     * @param  {Object[]} events Events to schedule.
     * @param  {String} [siteid] ID of the site the events belong to. If not defined, use current site.
     * @return {Promise}         Promise resolved when all the notifications have been scheduled.
     */
    self.scheduleEventsNotifications = function(events, siteid) {
        siteid = siteid || $mmSite.getId();
        var promises = [];

        if ($mmLocalNotifications.isAvailable()) {
            angular.forEach(events, function(e) {
                var promise = self.getEventNotificationTime(e.id, siteid).then(function(time) {
                    return self.scheduleEventNotification(e, time, siteid);
                });
                promises.push(promise);
            });
        }

        return $q.all(promises);
    };

    /**
     * Updates an event notification time and schedule a new notification.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#updateNotificationTime
     * @param  {Object} event Event to update its notification time.
     * @param  {Number} time  New notification setting time (in minutes). E.g. 10 means "notificate 10 minutes before start".
     * @return {Promise}      Promise resolved when the notification is updated.
     */
    self.updateNotificationTime = function(event, time) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }

        var db = $mmSite.getDb();

        event.notificationtime = time;

        return db.insert(mmaCalendarEventsStore, event).then(function() {
            return self.scheduleEventNotification(event, time);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

/**
 * Calendar handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.calendar
 * @ngdoc service
 * @name $mmaCalendarHandlers
 */
.factory('$mmaCalendarHandlers', ["$log", "$mmaCalendar", function($log, $mmaCalendar) {
    $log = $log.getInstance('$mmaCalendarHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendarHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaCalendar.isAvailable();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.calendar
             * @ngdoc controller
             * @name $mmaCalendarHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-calendar';
                $scope.title = 'mma.calendar.calendarevents';
                $scope.state = 'site.calendar';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion')

/**
 * Controller to handle course completion report.
 *
 * @module mm.addons.coursecompletion
 * @ngdoc controller
 * @name mmaCourseCompletionReportCtrl
 */
.controller('mmaCourseCompletionReportCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaCourseCompletion", "$mmSite", "$ionicPlatform", function($scope, $stateParams, $mmUtil, $mmaCourseCompletion, $mmSite,
            $ionicPlatform) {

    var course = $stateParams.course,
        userid = $stateParams.userid || $mmSite.getUserId();

    $scope.isTablet = $ionicPlatform.isTablet();

    function fetchCompletion() {
        return $mmaCourseCompletion.getCompletion(course.id, userid).then(function(completion) {

            completion.statusText = $mmaCourseCompletion.getCompletedStatusText(completion);

            $scope.completion = completion;
            $scope.showSelfComplete = $mmaCourseCompletion.isSelfCompletionAvailable() &&
                                        $mmaCourseCompletion.canMarkSelfCompleted(userid, completion);
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.coursecompletion.couldnotloadreport', true);
            }
        });
    }

    fetchCompletion().finally(function() {
        $scope.completionLoaded = true;
    });

    // Convenienve function to refresh completion data.
    function refreshCompletion() {
        return $mmaCourseCompletion.invalidateCourseCompletion(course.id, userid).finally(function() {
            return fetchCompletion();
        });
    }

    $scope.refreshCompletion = function() {
        refreshCompletion().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.completeCourse = function() {
        var modal = $mmUtil.showModalLoading('mm.core.sending', true);
        $mmaCourseCompletion.markCourseAsSelfCompleted(course.id).then(function() {
            return refreshCompletion();
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
        }).finally(function() {
            modal.dismiss();
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion')

/**
 * Course completion factory.
 *
 * @module mm.addons.coursecompletion
 * @ngdoc service
 * @name $mmaCourseCompletion
 */
.factory('$mmaCourseCompletion', ["$mmSite", "$log", "$q", "$mmCourses", function($mmSite, $log, $q, $mmCourses) {
    $log = $log.getInstance('$mmaCourseCompletion');

    var self = {};

    /**
     * Returns whether or not the user can mark a course as self completed.
     * It can if it's configured in the course and it hasn't been completed yet.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#canMarkSelfCompleted
     * @param {Number} userid     User ID.
     * @param {Object} completion Course completion.
     * @return {Boolean}          True if user can mark course as self completed, false otherwise.
     */
    self.canMarkSelfCompleted = function(userid, completion) {
        var selfCompletionActive = false,
            alreadyMarked = false;

        if ($mmSite.getUserId() != userid) {
            return false;
        }

        angular.forEach(completion.completions, function(criteria) {
            if (criteria.type === 1) {
                // Self completion criteria found.
                selfCompletionActive = true;
                alreadyMarked = criteria.complete;
            }
        });

        return selfCompletionActive && !alreadyMarked;
    };

    /**
     * Get completed status text. The language code returned is meant to be translated.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#getCompletedStatusText
     * @param {Object} completion Course completion.
     * @return {Promise}          Language code of the text to show.
     */
    self.getCompletedStatusText = function(completion) {
        if (completion.completed) {
            return 'mma.coursecompletion.completed';
        } else {
            // Let's calculate status.
            var hasStarted = false;
            angular.forEach(completion.completions, function(criteria) {
                if (criteria.timecompleted || criteria.complete) {
                    hasStarted = true;
                }
            });
            if (hasStarted) {
                return 'mma.coursecompletion.inprogress';
            } else {
                return 'mma.coursecompletion.notyetstarted';
            }
        }
    };

    /**
     * Get course completion status for a certain course and user.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#getCompletion
     * @param {Number} courseid Course ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise}        Promise to be resolved when the completion is retrieved.
     */
    self.getCompletion = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();

        $log.debug('Get completion for course ' + courseid + ' and user ' + userid);

        var data = {
                courseid : courseid,
                userid: userid
            },
            preSets = {
                cacheKey: getCompletionCacheKey(courseid, userid)
            };

        return $mmSite.read('core_completion_get_course_completion_status', data, preSets).then(function(data) {
            if (data.completionstatus) {
                return data.completionstatus;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for get completion WS calls.
     *
     * @param {Number} courseid Course ID.
     * @param {Number} userid   User ID.
     * @return {String}         Cache key.
     */
    function getCompletionCacheKey(courseid, userid) {
        return 'mmaCourseCompletion:view:' + courseid + ':' + userid;
    }

    /**
     * Invalidates view course completion WS call.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#invalidateCourseCompletion
     * @param {Number} courseid Course ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateCourseCompletion = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();
        return $mmSite.invalidateWsCacheForKey(getCompletionCacheKey(courseid, userid));
    };

    /**
     * Returns whether or not the view course completion plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#isPluginViewEnabled
     * @return {Boolean} True if plugin enabled, false otherwise.
     */
    self.isPluginViewEnabled = function() {
        if (!$mmSite.isLoggedIn()) {
            return false;
        } else if (!$mmSite.wsAvailable('core_completion_get_course_completion_status')) {
            return false;
        }

        return true;
    };

    /**
     * Returns whether or not the view course completion plugin is enabled for a certain course.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#isPluginViewEnabledForCourse
     * @param {Number} courseId Course ID.
     * @return {Promise}        Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginViewEnabledForCourse = function(courseId) {
        if (!courseId) {
            return $q.reject();
        }

        return $mmCourses.getUserCourse(courseId, true).then(function(course) {
            if (course && typeof course.enablecompletion != 'undefined' && !course.enablecompletion) {
                return false;
            }
            return true;
        });
    };

    /**
     * Returns whether or not the self completion is available in current site.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#isSelfCompletionAvailable
     * @return {Boolean} True if self completion is available, false otherwise.
     */
    self.isSelfCompletionAvailable = function() {
        return $mmSite.wsAvailable('core_completion_mark_course_self_completed');
    };

    /**
     * Mark a course as self completed.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#markCourseAsSelfCompleted
     * @param {Number} courseid Course ID.
     * @return {Promise}        Resolved on success.
     */
    self.markCourseAsSelfCompleted = function(courseid) {
        var params = {
            courseid: courseid
        };

        return $mmSite.write('core_completion_mark_course_self_completed', params).then(function(response) {
            if (!response.status) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion')

/**
 * Course completion handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.coursecompletion
 * @ngdoc service
 * @name $mmaCourseCompletionHandlers
 */
.factory('$mmaCourseCompletionHandlers', ["$mmaCourseCompletion", "$state", "mmCoursesAccessMethods", function($mmaCourseCompletion, $state, mmCoursesAccessMethods) {

    var self = {};

    /**
     * View user completion handler.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletionHandlers#viewCompletion
     */
    self.viewCompletion = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaCourseCompletion.isPluginViewEnabled();
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User to check.
         * @param {Number} courseId Course ID.
         * @return {Boolean}        True if handler is enabled, false otherwise.
         */
        self.isEnabledForUser = function(user, courseId) {
            return $mmaCourseCompletion.isPluginViewEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Object} user     Course ID.
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(user, courseId) {

            /**
             * View course completion handler controller.
             *
             * @module mm.addons.coursecompletion
             * @ngdoc controller
             * @name $mmaCourseCompletionHandlers#viewCompletion:controller
             */
            return function($scope) {

                // Button title.
                $scope.title = 'mma.coursecompletion.viewcoursereport';

                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.course-completion', {
                        userid: user.id,
                        course: {id: courseId}
                    });

                };
            };

        };

        return self;
    };

    /**
     * Course nav handler.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletionHandlers#coursesNav
     */
    self.coursesNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaCourseCompletion.isPluginViewEnabled();
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean}          True if handler is enabled, false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return $mmaCourseCompletion.isPluginViewEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(courseId) {

            /**
             * Courses nav handler controller.
             *
             * @module mm.addons.coursecompletion
             * @ngdoc controller
             * @name $mmaCourseCompletionHandlers#coursesNav:controller
             */
            return function($scope, $state) {
                $scope.icon = 'ion-android-checkbox-outline';
                $scope.title = 'mma.coursecompletion.coursecompletion';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.course-completion', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Controller to upload any kind of file on iOS. Lets the user choose the site he wants to upload the file to.
 *
 * @module mm.addons.files
 * @ngdoc controller
 * @name mmaFilesChooseSiteCtrl
 */
.controller('mmaFilesChooseSiteCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmaFilesHelper", "$ionicHistory", function($scope, $state, $stateParams, $mmSitesManager, $mmaFilesHelper, $ionicHistory) {

    var fileEntry = $stateParams.file || {};
    $scope.filename = fileEntry.name;

    $mmSitesManager.getSites().then(function(sites) {
        $scope.sites = sites;
    });

    $scope.uploadInSite = function(siteid) {
        $mmaFilesHelper.showConfirmAndUploadInSite(fileEntry, siteid).then(function() {
            $ionicHistory.nextViewOptions({
                disableBack: true
            });
            $state.go('site.mm_courses');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.controller('mmaFilesIndexController', ["$scope", "$mmaFiles", "$mmSite", "$mmUtil", "$mmApp", "$state", function($scope, $mmaFiles, $mmSite, $mmUtil, $mmApp, $state) {

    $scope.canAccessFiles = $mmaFiles.canAccessFiles;
    $scope.showPrivateFiles = function() {
        return $mmaFiles.canAccessFiles() && $mmSite.canAccessMyFiles();
    };
    $scope.showUpload = function() {
        // Show upload in this page if user can upload but he can't see the My Files option.
        return !$mmaFiles.canAccessFiles() && $mmSite.canAccessMyFiles() && $mmSite.canUploadFiles();
    };
    $scope.canDownload = $mmSite.canDownloadFiles;

    $scope.add = function() {
        if (!$mmApp.isOnline()) {
            $mmUtil.showErrorModal('mma.files.errormustbeonlinetoupload', true);
        } else {
            $state.go('site.files-upload');
        }
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.controller('mmaFilesListController', ["$q", "$scope", "$stateParams", "$mmaFiles", "$mmSite", "$translate", "$mmUtil", "$ionicHistory", "mmaFilesUploadStateName", "$state", "$mmApp", "mmaFilesMyComponent", "mmaFilesSiteComponent", function($q, $scope, $stateParams, $mmaFiles, $mmSite, $translate, $mmUtil,
        $ionicHistory, mmaFilesUploadStateName, $state, $mmApp, mmaFilesMyComponent, mmaFilesSiteComponent) {

    var path = $stateParams.path,
        root = $stateParams.root,
        title,
        promise;

    // We're loading the files.
    $scope.count = -1;
    $scope.component = root === 'my' ? mmaFilesMyComponent : mmaFilesSiteComponent;

    // Convenience function that fetches the files and updates the scope.
    function fetchFiles(root, path) {
        if (!path) {
            // The path is unknown, the user must be requesting a root.
            if (root === 'site') {
                promise = $mmaFiles.getSiteFiles();
                title = $translate('mma.files.sitefiles');
            } else if (root === 'my') {
                promise = $mmaFiles.getMyFiles();
                title = $translate('mma.files.myprivatefiles');
            } else {
                // Upon error we create a fake promise that is rejected.
                promise = $q.reject();
                title = (function() {
                    var q = $q.defer();
                    q.resolve('');
                    return q.promise;
                })();
            }
        } else {
            // Serve the files the user requested.
            pathdata = JSON.parse(path);
            promise = $mmaFiles.getFiles(pathdata);

            // Put the title in a promise to act like translate does.
            title = (function() {
                var q = $q.defer();
                q.resolve($stateParams.title);
                return q.promise;
            })();
        }

        return $q.all([promise, title]).then(function(data) {
            var files = data[0],
                title = data[1];

            $scope.files = files.entries;
            $scope.count = files.count;
            $scope.title = title;
        }, function() {
            $mmUtil.showErrorModal('mma.files.couldnotloadfiles', true);
        });
    }

    fetchFiles(root, path).finally(function() {
        $scope.filesLoaded = true;
    });

    $scope.refreshFiles = function() {
        $mmaFiles.invalidateDirectory(root, path).finally(function() {
            fetchFiles(root, path).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    // Update list if we come from upload page (we don't know if user upoaded a file or not).
    // List is invalidated in upload state after uploading a file.
    $scope.$on('$ionicView.enter', function(e) {
        var forwardView = $ionicHistory.forwardView();
        if (forwardView && forwardView.stateName === mmaFilesUploadStateName) {
            $scope.filesLoaded = false;
            fetchFiles(root, path).finally(function() {
                $scope.filesLoaded = true;
            });
        }
    });

    $scope.showUpload = function() {
        return (root === 'my' && !path && $mmSite.canUploadFiles());
    };

    // When we are in the root of the private files we can add more files.
    $scope.add = function() {
        if (!$mmApp.isOnline()) {
            $mmUtil.showErrorModal('mma.files.errormustbeonlinetoupload', true);
        } else {
            $state.go('site.files-upload', {root: root, path: path});
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Controller to upload any kind of file.
 *
 * @module mm.addons.files
 * @ngdoc controller
 * @name mmaFilesUploadCtrl
 */
.controller('mmaFilesUploadCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaFilesHelper", "$ionicHistory", "$mmaFiles", "$mmApp", function($scope, $stateParams, $mmUtil, $mmaFilesHelper, $ionicHistory, $mmaFiles, $mmApp) {

    var uploadMethods = {
            album: $mmaFilesHelper.uploadImageFromAlbum,
            camera: $mmaFilesHelper.uploadImageFromCamera,
            audio: $mmaFilesHelper.uploadAudio,
            video: $mmaFilesHelper.uploadVideo
        },
        path = $stateParams.path,
        root = $stateParams.root;

    $scope.isAndroid = ionic.Platform.isAndroid();

    // Function called when a file is uploaded.
    function successUploading() {
        $mmaFiles.invalidateDirectory(root, path).finally(function() {
            $mmUtil.showModal('mm.core.success', 'mma.files.fileuploaded');
            $ionicHistory.goBack();
        });
    }

    // Function called when a file upload fails.
    function errorUploading(err) {
        if (err) {
            $mmUtil.showErrorModal(err);
        }
    }

    $scope.upload = function(type) {
        if (!$mmApp.isOnline()) {
            $mmUtil.showErrorModal('mma.files.errormustbeonlinetoupload', true);
        } else {
            if (typeof(uploadMethods[type]) !== 'undefined') {
                uploadMethods[type]().then(successUploading, errorUploading);
            }
        }
    };

    $scope.uploadFile = function(evt) {
        var input = evt.srcElement;
        var file = input.files[0];
        input.value = ''; // Unset input.
        if (file) {
            $mmaFilesHelper.confirmUploadFile(file.size).then(function() {
                // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
                $mmaFilesHelper.copyAndUploadFile(file).then(successUploading, errorUploading);
            }, errorUploading);
        }
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Directive to detect chanegs on file inputs (ng-Change doesn't work in that type of input).
 *
 * @module mm.addons.files
 * @ngdoc directive
 * @name mmaFilesOnChange
 */
.directive('mmaFilesOnChange', function() {
  return {
    restrict: 'A',
    link: function (scope, element, attrs) {
      var onChangeHandler = scope.$eval(attrs.mmaFilesOnChange);
      element.bind('change', onChangeHandler);
    }
  };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.config(["$mmAppProvider", "mmaFilesSharedFilesStore", function($mmAppProvider, mmaFilesSharedFilesStore) {
    var stores = [
        {
            name: mmaFilesSharedFilesStore,
            keyPath: 'id'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

.factory('$mmaFiles', ["$mmSite", "$mmFS", "$q", "$timeout", "$log", "$mmSitesManager", "$mmApp", "md5", "mmaFilesSharedFilesStore", function($mmSite, $mmFS, $q, $timeout, $log, $mmSitesManager, $mmApp, md5,
            mmaFilesSharedFilesStore) {

    $log = $log.getInstance('$mmaFiles');

    var self = {},
        defaultParams = {
            "contextid": 0,
            "component": "",
            "filearea": "",
            "itemid": 0,
            "filepath": "",
            "filename": ""
        };

    /**
     * Check if core_files_get_files WS call is available.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#canAccessFiles
     * @return {Boolean} True if WS is available, false otherwise.
     */
    self.canAccessFiles = function() {
        return $mmSite.wsAvailable('core_files_get_files');
    };

    /**
     * Checks if there is a new file received in iOS. If more than one file is found, treat only the first one.
     * The file returned is marked as "treated" and will be deleted in the next execution.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#checkIOSNewFiles
     * @return {Promise} Promise resolved with a new file to be treated. If no new files found, promise is rejected.
     */
    self.checkIOSNewFiles = function() {

        var deferred = $q.defer();

        $log.debug('Search for new files on iOS');
        $mmFS.getDirectoryContents('Inbox').then(function(entries) {

            if (entries.length > 0) {

                var promises = [];
                angular.forEach(entries, function(entry) {

                    var fileDeferred = $q.defer(),
                        fileId = md5.createHash(entry.name);

                    // Check if file was already treated.
                    $mmApp.getDB().get(mmaFilesSharedFilesStore, fileId).then(function() {
                        // File already treated. Delete it.
                        $log.debug('Delete already treated file: ' + entry.name);
                        fileDeferred.resolve();

                        entry.remove(function() {
                            $log.debug('File deleted: ' + entry.name);
                            $mmApp.getDB().remove(mmaFilesSharedFilesStore, fileId).then(function() {
                                $log.debug('"Treated" mark removed from file: ' + entry.name);
                            }, function() {
                                $log.debug('Error deleting "treated" mark from file: ' + entry.name);
                            });
                        }, function() {
                            $log.debug('Error deleting file in Inbox: ' + entry.name);
                        });

                    }, function() {
                        // File not treated before, send it to resolve so it's a candidate to be notified.
                        $log.debug('Found new file ' + entry.name + ' shared with the app.');
                        fileDeferred.resolve(entry);
                    });

                    promises.push(fileDeferred.promise);
                });

                $q.all(promises).then(function(responses) {
                    var fileToReturn,
                        fileId;
                    for (var i = 0; i < responses.length; i++) {
                        if (typeof(responses[i]) !== 'undefined') {
                            // Found new entry to treat.
                            fileToReturn = responses[i];
                            break;
                        }
                    }
                    if (fileToReturn) {
                        fileId = md5.createHash(fileToReturn.name);
                        // Mark it as "treated".
                        $mmApp.getDB().insert(mmaFilesSharedFilesStore, {id: fileId}).then(function() {
                            $log.debug('File marked as "treated": ' + fileToReturn.name);
                            deferred.resolve(fileToReturn);
                        }, function() {
                            $log.debug('Error marking file as "treated": ' + fileToReturn.name);
                            deferred.reject();
                        });
                    } else {
                        deferred.reject();
                    }
                }, deferred.reject);
            } else {
                deferred.reject();
            }
        });

        return deferred.promise;
    };

    /**
     * Get the list of files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#getFiles
     * @param  {Object} params A list of parameters accepted by the Web service.
     * @return {Object}        An object containing the files in the key 'entries', and 'count'.
     *                         Additional properties is added to the entries, such as:
     *                          - imgpath: The path to the icon.
     *                          - link: The JSON string of params to get to the file.
     *                          - linkId: A hash of the file parameters.
     */
    self.getFiles = function(params) {
        var deferred = $q.defer(),
            options = {};

        options.cacheKey = getFilesListCacheKey(params);

        $mmSite.read('core_files_get_files', params, options).then(function(result) {
            var data = {
                entries: [],
                count: 0
            };

            if (typeof result.files == 'undefined') {
                deferred.reject();
                return;
            }

            angular.forEach(result.files, function(entry) {
                entry.link = {};
                entry.link.contextid = (entry.contextid) ? entry.contextid : "";
                entry.link.component = (entry.component) ? entry.component : "";
                entry.link.filearea = (entry.filearea) ? entry.filearea : "";
                entry.link.itemid = (entry.itemid) ? entry.itemid : 0;
                entry.link.filepath = (entry.filepath) ? entry.filepath : "";
                entry.link.filename = (entry.filename) ? entry.filename : "";

                if (entry.component && entry.isdir) {
                    // Delete unused elements that may break the request.
                    entry.link.filename = "";
                }

                if (entry.isdir) {
                    entry.imgpath = $mmFS.getFolderIcon();
                } else {
                    entry.imgpath = $mmFS.getFileIcon(entry.filename);
                }

                entry.link = JSON.stringify(entry.link);
                entry.linkId = md5.createHash(entry.link);
                // entry.localpath = "";

                // if (!entry.isdir && entry.url) {
                //     // TODO Check $mmSite.
                //     var uniqueId = $mmSite.id + "-" + md5.createHash(entry.url);
                //     var path = MM.db.get("files", uniqueId);
                //     if (path) {
                //         entry.localpath = path.get("localpath");
                //     }
                // }

                data.count += 1;
                data.entries.push(entry);
            });

            deferred.resolve(data);
        }, function() {
            deferred.reject();
        });

        return deferred.promise;
    };

    /**
     * Get cache key for file list WS calls.
     *
     * @param  {Object} params Params of the directory to get.
     * @return {String}        Cache key.
     */
    function getFilesListCacheKey(params) {
        var root = params.component === '' ? 'site' : 'my';
        return 'mmaFiles:list:' + root + ':' + params.contextid + ':' + params.filepath;
    }

    /**
     * Get the private files of the current user.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#getMyFiles
     * @return {Object} See $mmaFiles#getFiles
     */
    self.getMyFiles = function() {
        var params = getMyFilesRootParams();
        return self.getFiles(params);
    };

    /**
     * Get the common part of the cache keys for private files WS calls.
     *
     * @return {String} Cache key.
     */
    function getMyFilesListCommonCacheKey() {
        return 'mmaFiles:list:my';
    }

    /**
     * Get params to get root private files directory.
     *
     * @return {Object} Params.
     */
    function getMyFilesRootParams() {
        var params = angular.copy(defaultParams, {});
        params.component = "user";
        params.filearea = "private";
        params.contextid = -1;
        params.contextlevel = "user";
        params.instanceid = $mmSite.getUserId();
        return params;
    }

    /**
     * Get the site files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#getSiteFiles
     * @return {Object} See $mmaFiles#getFiles
     */
    self.getSiteFiles = function() {
        var params = angular.copy(defaultParams, {});
        return self.getFiles(params);
    };

    /**
     * Get the common part of the cache keys for site files WS calls.
     *
     * @return {String} Cache key.
     */
    function getSiteFilesListCommonCacheKey() {
        return 'mmaFiles:list:site';
    }

    /**
     * Invalidates list of files in a certain directory.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#invalidateDirectory
     * @param  {String} root     Root of the directory ('my' for private files, 'site' for site files).
     * @param  {String} path     Path to the directory.
     * @param  {String} [siteid] Id of the site to invalidate. If not defined, use current site.
     * @return {Promise}         Promise resolved when the list is invalidated.
     */
    self.invalidateDirectory = function(root, path, siteid) {
        siteid = siteid || $mmSite.getId();

        var params = {};
        if (!path) {
            if (root === 'site') {
                params = angular.copy(defaultParams, {});
            } else if (root === 'my') {
                params = getMyFilesRootParams();
            }
        } else {
            params = JSON.parse(path);
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {
            site.invalidateWsCacheForKey(getFilesListCacheKey(params));
        });
    };

    /**
     * Invalidates list of private files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#invalidateMyFiles
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateMyFiles = function() {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getMyFilesListCommonCacheKey());
    };

    /**
     * Invalidates list of site files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#invalidateSiteFiles
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateSiteFiles = function() {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getSiteFilesListCommonCacheKey());
    };

    /**
     * Return whether or not the plugin is enabled. Plugin is enabled if:
     *     - Site supports core_files_get_files
     *     or
     *     - User has capability moodle/user:manageownfiles and WS allows uploading files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#isPluginEnabled
     * @return {Boolean}
     */
    self.isPluginEnabled = function() {
        var canAccessFiles = self.canAccessFiles(),
            canAccessMyFiles = $mmSite.canAccessMyFiles(),
            canUploadFiles = $mmSite.canUploadFiles();

        return canAccessFiles || (canUploadFiles && canAccessMyFiles);
    };

    /**
     * Upload a file.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadFile
     * @param  {Object} uri      File URI.
     * @param  {Object} options  Options for the upload.
     *                           - {Boolean} deleteAfterUpload Whether or not to delete the original after upload.
     *                           - {String} fileKey
     *                           - {String} fileName
     *                           - {String} mimeType
     * @param  {String} [siteid] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}
     */
    self.uploadFile = function(uri, options, siteid) {
        options = options || {};
        siteid = siteid || $mmSite.getId();

        var deleteAfterUpload = options.deleteAfterUpload,
            deferred = $q.defer(),
            ftOptions = {
                fileKey: options.fileKey,
                fileName: options.fileName,
                mimeType: options.mimeType
            };

        function deleteFile() {
            $timeout(function() {
                // Use set timeout, otherwise in Node-Webkit the upload threw an error sometimes.
                $mmFS.removeExternalFile(uri);
            }, 500);
        }

        $mmSitesManager.getSite(siteid).then(function(site) {
            site.uploadFile(uri, ftOptions).then(deferred.resolve, deferred.reject, deferred.notify).finally(function() {
                if (deleteAfterUpload) {
                    deleteFile();
                }
            });
        }, function() {
            if (deleteAfterUpload) {
                deleteFile();
            }
            deferred.reject(error);
        });

        return deferred.promise;
    };

    /**
     * Upload image.
     * @todo Handle Node Webkit.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadImage
     * @param  {String}  uri         File URI.
     * @param  {Boolean} isFromAlbum True if the image was taken from album, false if it's a new image taken with camera.
     * @return {Promise}
     */
    self.uploadImage = function(uri, isFromAlbum) {
        $log.debug('Uploading an image');
        var d = new Date(),
            options = {};

        if (typeof(uri) === 'undefined' || uri === ''){
            // In Node-Webkit, if you successfully upload a picture and then you open the file picker again
            // and cancel, this function is called with an empty uri. Let's filter it.
            $log.debug('Received invalid URI in $mmaFiles.uploadImage()');
            return $q.reject();
        }

        options.deleteAfterUpload = !isFromAlbum;
        options.fileKey = "file";
        options.fileName = "image_" + d.getTime() + ".jpg";
        options.mimeType = "image/jpeg";

        return self.uploadFile(uri, options);
    };

    /**
     * Upload media.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadMedia
     * @param  {Array} mediaFiles Array of file objects.
     * @return {Array} Array of promises.
     */
    self.uploadMedia = function(mediaFiles) {
        $log.debug('Uploading media');
        var promises = [];
        angular.forEach(mediaFiles, function(mediaFile, index) {
            var options = {};
            options.fileKey = null;
            options.fileName = mediaFile.name;
            options.mimeType = null;
            options.deleteAfterUpload = true;
            promises.push(self.uploadFile(mediaFile.fullPath, options));
        });
        return promises;
    };

    /**
     * Upload a file of any type.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadGenericFile
     * @param  {String} uri      File URI.
     * @param  {String} name     File name.
     * @param  {String} type     File type.
     * @param  {String} [siteid] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}     Promise resolved when the file is uploaded.
     */
    self.uploadGenericFile = function(uri, name, type, siteid) {
        var options = {};
        options.fileKey = null;
        options.fileName = name;
        options.mimeType = type;
        // Don't delete the file on iOS, it's going to be deleted on $mmaFiles#checkIOSNewFiles.
        options.deleteAfterUpload = !ionic.Platform.isIOS();

        return self.uploadFile(uri, options, siteid);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Files handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.files
 * @ngdoc service
 * @name $mmaFilesHandlers
 */
.factory('$mmaFilesHandlers', ["$log", "$mmaFiles", function($log, $mmaFiles) {
    $log = $log.getInstance('$mmaFilesHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaFiles.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.files
             * @ngdoc controller
             * @name $mmaFilesHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-folder';
                $scope.title = 'mma.files.myfiles';
                $scope.state = 'site.files';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.constant('mmaFilesFileSizeWarning', 5242880)

.factory('$mmaFilesHelper', ["$q", "$mmUtil", "$mmApp", "$log", "$translate", "$window", "$mmaFiles", "$cordovaCamera", "$cordovaCapture", "$mmLang", "$mmFS", "$mmText", "mmaFilesFileSizeWarning", function($q, $mmUtil, $mmApp, $log, $translate, $window,
        $mmaFiles, $cordovaCamera, $cordovaCapture, $mmLang, $mmFS, $mmText, mmaFilesFileSizeWarning) {

    $log = $log.getInstance('$mmaFilesHelper');

    var self = {};

    /**
     * Convenient helper for the user to upload an image from an album.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadImageFromAlbum
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadImageFromAlbum = function() {
        $log.debug('Trying to get a image from albums');
        var deferred = $q.defer();

        var width  =  $window.innerWidth  - 200;
        var height =  $window.innerHeight - 200;

        // iPad popOver, see https://tracker.moodle.org/browse/MOBILE-208
        var popover = new CameraPopoverOptions(10, 10, width, height, Camera.PopoverArrowDirection.ARROW_ANY);
        $cordovaCamera.getPicture({
            quality: 50,
            destinationType: navigator.camera.DestinationType.FILE_URI,
            sourceType: navigator.camera.PictureSourceType.PHOTOLIBRARY,
            popoverOptions : popover
        }).then(function(img) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $mmaFiles.uploadImage(img, true).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatImageError(error, deferred, 'mma.files.errorgettingimagealbum');
        });

        return deferred.promise;
    };

    /**
     * Convenient helper for the user to take an image with the camera and upload it.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadImageFromCamera
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadImageFromCamera = function() {
        $log.debug('Trying to capture an image with camera');
        var deferred = $q.defer();

        $cordovaCamera.getPicture({
            quality: 50,
            destinationType: navigator.camera.DestinationType.FILE_URI
        }).then(function(img) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $mmaFiles.uploadImage(img, false).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatImageError(error, deferred, 'mma.files.errorcapturingimage');
        });

        return deferred.promise;
    };

    /**
     * Convenient helper for the user to record and upload an audio.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadAudio
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadAudio = function() {
        $log.debug('Trying to record an audio file');
        var deferred = $q.defer();

        $cordovaCapture.captureAudio({limit: 1}).then(function(medias) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $q.all($mmaFiles.uploadMedia(medias)).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatCaptureError(error, deferred, 'mma.files.errorcapturingaudio');
        });

        return deferred.promise;
    };

    /**
     * Convenient helper for the user to record and upload a video.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadVideo
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadVideo = function() {
        $log.debug('Trying to record a video file');
        var deferred = $q.defer();

        $cordovaCapture.captureVideo({limit: 1}).then(function(medias) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $q.all($mmaFiles.uploadMedia(medias)).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatCaptureError(error, deferred, 'mma.files.errorcapturingvideo');
        });

        return deferred.promise;
    };

    /**
     * Show a confirmation modal to the user if he is using a limited connection or the file size is higher than 5MB.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#confirmUploadFile
     * @param  {Number} size File's size.
     * @return {Promise}     Promise resolved when the user confirms or if there's no need to show a modal.
     */
    self.confirmUploadFile = function(size) {
        if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mma.files.errormustbeonlinetoupload');
        }

        if ($mmApp.isNetworkAccessLimited() || size >= mmaFilesFileSizeWarning) {
             var size = $mmText.bytesToSize(size, 2);
            return $mmUtil.showConfirm($translate('mma.files.confirmuploadfile', {size: size}));
        } else {
            var deferred = $q.defer();
            deferred.resolve();
            return deferred.promise;
        }
    };

    /**
     * Create a temporary copy of a file and upload it.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#copyAndUploadFile
     * @param {Object} file File to copy and upload.
     * @return {Promise}    Promise resolved when the file is uploaded.
     */
    self.copyAndUploadFile = function(file) {
        var deferred = $q.defer();

        var modal = $mmUtil.showModalLoading('mma.files.readingfile', true);

        // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
        $mmFS.readFileData(file, $mmFS.FORMATARRAYBUFFER).then(function(data) {

            var filepath = $mmFS.getTmpFolder() + '/' + file.name;

            $mmFS.writeFile(filepath, data).then(function(fileEntry) {
                modal.dismiss();
                self.uploadGenericFile(fileEntry.toURL(), file.name, file.type).then(deferred.resolve, deferred.reject);
            }, function(error) {
                $log.error('Error writing file to upload: '+JSON.stringify(error));
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorreadingfile');
                modal.dismiss();
            });

        }, function(error) {
            $log.error('Error reading file to upload: '+JSON.stringify(error));
            $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorreadingfile');
            modal.dismiss();
        });

        return deferred.promise;
    };

    /**
     * Uploads a file of any type.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadGenericFile
     * @param  {String} uri      File URI.
     * @param  {String} name     File name.
     * @param  {String} type     File type.
     * @param  {String} [siteid] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}         Promise resolved when the file is uploaded.
     */
    self.uploadGenericFile = function(uri, name, type, siteid) {
        var deferred = $q.defer();

        if (!$mmApp.isOnline()) {
            $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errormustbeonlinetoupload');
            return deferred.promise;
        }

        var modal = $mmUtil.showModalLoading('mma.files.uploading', true);

        $mmaFiles.uploadGenericFile(uri, name, type, siteid).then(deferred.resolve, function(error) {
            $log.error('Error uploading file: '+JSON.stringify(error));
            $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
        }).finally(function() {
            modal.dismiss();
        });

        return deferred.promise;
    };

    /**
     * Convenience function to upload a file on a certain site, showing a confirm if needed.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#showConfirmAndUploadInSite
     * @param  {String} fileEntry FileEntry of the file to upload.
     * @param  {String} [siteid]  Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}          Promise resolved when the file is uploaded.
     */
    self.showConfirmAndUploadInSite = function(fileEntry, siteid) {
        return $mmFS.getFileObjectFromFileEntry(fileEntry).then(function(file) {
            return self.confirmUploadFile(file.size).then(function() {
                return self.uploadGenericFile(fileEntry.toURL(), file.name, file.type, siteid).then(function() {
                    // Invalidate my files root dir so the list is refreshed when the user goes in.
                    return $mmaFiles.invalidateDirectory('my', undefined, siteid).finally(function() {
                        $mmUtil.showModal('mm.core.success', 'mma.files.fileuploaded');
                    });
                }, function(err) {
                    if (err) {
                        $mmUtil.showErrorModal(err);
                    }
                    return $q.reject();
                });
            }, function(err) {
                if (err) {
                    $mmUtil.showErrorModal(err);
                }
                return $q.reject();
            });
        }, function() {
            $mmUtil.showErrorModal('mma.files.errorreadingfile', true);
            return $q.reject();
        });
    }

    /**
     * Treat a capture image or browse album error.
     *
     * @param  {String} error          Error returned by the Cordova plugin.
     * @param  {Promise} deferred      Promise to reject.
     * @param  {String} defaultMessage Key of the default message to show.
     */
    function treatImageError(error, deferred, defaultMessage) {
        // Cancelled, or error. If cancelled, error is a string with "Selection cancelled." or "Camera cancelled.".
        if (error) {
            if (typeof(error) === 'string') {
                if (error.toLowerCase().indexOf("error") > -1 || error.toLowerCase().indexOf("unable") > -1) {
                    $log.error('Error getting image: ' + error);
                    deferred.reject(error);
                } else {
                    $log.debug('Cancelled');
                    deferred.reject();
                }
            } else {
                $mmLang.translateAndRejectDeferred(deferred, defaultMessage);
            }
        } else {
            deferred.reject();
        }
    }

    /**
     * Treat a capture audio/video error.
     *
     * @param  {Mixed} error           Error returned by the Cordova plugin. Can be a string or an object.
     * @param  {Promise} deferred      Promise to reject.
     * @param  {String} defaultMessage Key of the default message to show.
     */
    function treatCaptureError(error, deferred, defaultMessage) {
        // Cancelled, or error. If cancelled, error is an object with code = 3.
        if (error) {
            if (typeof(error) === 'string') {
                $log.error('Error while recording audio/video: ' + error);
                if (error.indexOf('No Activity found') > -1) {
                    // User doesn't have an app to do this.
                    $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errornoapp');
                } else {
                    $mmLang.translateAndRejectDeferred(deferred, defaultMessage);
                }
            } else {
                if (error.code != 3) {
                    // Error, not cancelled.
                    $log.error('Error while recording audio/video: ' + JSON.stringify(error));
                    $mmLang.translateAndRejectDeferred(deferred, defaultMessage);
                } else {
                    $log.debug('Cancelled');
                    deferred.reject();
                }
            }
        } else {
            deferred.reject();
        }
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.frontpage')

/**
 * Frontpage factory.
 *
 * @module mm.addons.frontpage
 * @ngdoc service
 * @name $mmaFrontpage
 */
.factory('$mmaFrontpage', ["$mmSite", "$log", "$q", "$mmCourse", function($mmSite, $log, $q, $mmCourse) {
    $log = $log.getInstance('$mmaFrontpage');

    var self = {};

    /**
     * Returns whether or not the plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.frontpage
     * @ngdoc method
     * @name $mmaFrontpage#isPluginEnabled
     * @return {Boolean}
     */
    self.isPluginEnabled = function() {

        if (!$mmSite.isLoggedIn()) {
            return false;
        }

        return true;
    };

    /**
     * Returns whether or not the frontpage is available for the current site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @module mm.addons.frontpage
     * @ngdoc method
     * @name $mmaFrontpage#isFrontpageAvailable
     * @return {Promise} Resolved when enabled, otherwise rejected.
     */
    self.isFrontpageAvailable = function() {

        // On older version we cannot check other than calling a WS. If the request
        // fails there is a very high chance that frontpage is not available.
        $log.debug('Using WS call to check if frontpage is available.');
        return $mmCourse.getSections(1, {emergencyCache: false}).then(function(data) {
            if (!angular.isArray(data) || data.length == 0) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.frontpage')

/**
 * Front page handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.frontpage
 * @ngdoc service
 * @name $mmaFrontPageHandlers
 */
.factory('$mmaFrontPageHandlers', ["$log", "$mmaFrontpage", function($log, $mmaFrontpage) {
    $log = $log.getInstance('$mmaFrontPageHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.frontpage
     * @ngdoc method
     * @name $mmaFrontPageHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Promise|Boolean} If handler is enabled returns a resolved promise. If it's not it can return a
         *                           rejected promise or false.
         */
        self.isEnabled = function() {
            if ($mmaFrontpage.isPluginEnabled()) {
                return $mmaFrontpage.isFrontpageAvailable().then(function() {
                    return true;
                });
            }
            return false;
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.frontpage
             * @ngdoc controller
             * @name $mmaFrontPageHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-home';
                $scope.title = 'mma.frontpage.sitehome';
                $scope.state = 'site.mm_course-section';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades')

/**
 * Controller to handle course grades.
 *
 * @module mm.addons.grades
 * @ngdoc controller
 * @name mmaGradesTableCtrl
 */
.controller('mmaGradesTableCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaGrades", "$mmSite", function($scope, $stateParams, $mmUtil, $mmaGrades, $mmSite) {

    var course = $stateParams.course || {},
        courseid = course.id,
        userid = $stateParams.userid || $mmSite.getUserId();

    function fetchGrades(refresh) {
        return $mmaGrades.getGradesTable(courseid, userid, refresh).then(function(table) {
            $scope.gradesTable = table;
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.errormessage = message;
        });
    }
    fetchGrades().then(function() {
        // Add log in Moodle.
        $mmSite.write('gradereport_user_view_grade_report', {
            courseid: courseid,
            userid: userid
        });
    })
    .finally(function() {
        $scope.gradesLoaded = true;
    });

    $scope.refreshGrades = function() {
        fetchGrades(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades')

/**
 * Service to handle grades.
 *
 * @module mm.addons.grades
 * @ngdoc service
 * @name $mmaGrades
 */
.factory('$mmaGrades', ["$q", "$log", "$mmSite", "$mmText", "$ionicPlatform", "$translate", "$mmCourse", "$mmCourses", "$mmSitesManager", function($q, $log, $mmSite, $mmText, $ionicPlatform, $translate, $mmCourse, $mmCourses, $mmSitesManager) {

    $log = $log.getInstance('$mmaGrades');

    var self = {};

    /**
     * Formats the response of gradereport_user_get_grades_table to be rendered.
     *
     * @param  {Object}  table      JSON object representing a table with data.
     * @param  {Boolean} showSimple True if simple table should be shown, false for full table.
     * @return {Object}             Formatted HTML table.
     */
    function formatGradesTable(table, showSimple) {
        var formatted = {
            columns: [],
            rows: []
        };

        if (!table || !table.tables) {
            return formatted;
        }

        // Columns, by order.
        var columns = [ "itemname", "weight", "grade", "range", "percentage", "lettergrade", "rank",
                        "average", "feedback", "contributiontocoursetotal"];
        var returnedColumns = [];

        var tabledata = [];
        var maxDepth = 0;
        // Check columns returned (maybe some of the above).
        if (table.tables && table.tables[0] && table.tables[0]['tabledata']) {
            tabledata = table.tables[0]['tabledata'];
            maxDepth = table.tables[0]['maxdepth'];
            for (var el in tabledata) {
                // This is a typical row.
                if (!angular.isArray(tabledata[el]) && typeof(tabledata[el]["leader"]) === "undefined") {
                    for (var col in tabledata[el]) {
                        returnedColumns.push(col);
                    }
                    break;
                }
            }
        }

        if (returnedColumns.length > 0) {

            // Reduce the returned columns for phone version.
            if (showSimple) {
                returnedColumns = ["itemname", "grade"];
            }

            for (var el in columns) {
                var colName = columns[el];
                if (returnedColumns.indexOf(colName) > -1) {
                    var width = colName == "itemname" ? maxDepth : 1;
                    var column = {
                        id: colName,
                        name: colName,
                        width: width
                    };
                    formatted.columns.push(column);
                }
            }

            var name, rowspan, tclass, colspan, content, celltype, id, headers,j, img, colspanVal;

            var len = tabledata.length;
            for (var i = 0; i < len; i++) {
                var row = '';
                if (typeof(tabledata[i]['leader']) != "undefined") {
                    rowspan = tabledata[i]['leader']['rowspan'];
                    tclass = tabledata[i]['leader']['class'];
                    row += '<td class="' + tclass + '" rowspan="' + rowspan + '"></td>';
                }
                for (el in returnedColumns) {
                    name = returnedColumns[el];

                    if (typeof(tabledata[i][name]) != "undefined") {
                        tclass = (typeof(tabledata[i][name]['class']) != "undefined")? tabledata[i][name]['class'] : '';
                        colspan = (typeof(tabledata[i][name]['colspan']) != "undefined")? "colspan='"+tabledata[i][name]['colspan']+"'" : '';
                        content = (typeof(tabledata[i][name]['content']) != "undefined")? tabledata[i][name]['content'] : null;
                        celltype = (typeof(tabledata[i][name]['celltype']) != "undefined")? tabledata[i][name]['celltype'] : 'td';
                        id = (typeof(tabledata[i][name]['id']) != "undefined")? "id='" + tabledata[i][name]['id'] +"'" : '';
                        headers = (typeof(tabledata[i][name]['headers']) != "undefined")? "headers='" + tabledata[i][name]['headers'] + "'" : '';

                        if (typeof(content) != "undefined") {
                            img = getImgHTML(content);
                            content = content.replace(/<\/span>/gi, "\n");
                            content = $mmText.cleanTags(content);
                            content = content.replace("\n", "<br />");
                            content = img + " " + content;

                            row += "<" + celltype + " " + id + " " + headers + " " + "class='"+ tclass +"' " + colspan +">";
                            row += content;
                            row += "</" + celltype + ">";
                        }
                    }
                }
                formatted.rows.push(row);
            }
        }

        return formatted;
    }

    /**
     * Gets the HTML code to render the contents img.
     *
     * @param  {String} text HTML where the image will be rendered.
     * @return {String}      HTML code to render the image.
     */
    function getImgHTML(text) {
        var img = '';

        if (text.indexOf("/agg_mean") > -1) {
            img = '<img src="addons/grades/img/agg_mean.png" width="16">';
        } else if (text.indexOf("/agg_sum") > -1) {
            img = '<img src="addons/grades/img/agg_sum.png" width="16">';
        } else if (text.indexOf("/outcomes") > -1) {
            img = '<img src="addons/grades/img/outcomes.png" width="16">';
        } else if (text.indexOf("i/folder") > -1) {
            img = '<img src="addons/grades/img/folder.png" width="16">';
        } else if (text.indexOf("/manual_item") > -1) {
            img = '<img src="addons/grades/img/manual_item.png" width="16">';
        } else if (text.indexOf("/mod/") > -1) {
            var module = text.match(/mod\/([^\/]*)\//);
            if (typeof module[1] != "undefined") {
                var moduleSrc = $mmCourse.getModuleIconSrc(module[1]);
                img = '<img src="' + moduleSrc + '" width="16">';
            }
        }
        if (img) {
            img = '<span class="app-ico">' + img + '</span>';
        }
        return img;
    }

    /**
     * Translates the names of the grades table columns.
     *
     * @param  {Object} table Grades table.
     * @return {Promise}      Promise to be resolved with the translated table.
     */
    function translateGradesTable(table) {
        var columns = angular.copy(table.columns),
            promises = [];

        columns.forEach(function(column) {
            var promise = $translate('mma.grades.'+column.name).then(function(translated) {
                column.name = translated;
            });
            promises.push(promise);
        });

        return $q.all(promises).then(function() {
            return {
                columns: columns,
                rows: table.rows
            };
        });
    };

    /**
     * Returns whether or not the plugin is enabled for a certain site.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGrades#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Boolean}         True if plugin is enabled, false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('gradereport_user_get_grades_table');
        });
    };

    /**
     * Returns whether or not the grade addon is enabled for a certain course.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGrades#isPluginEnabledForCourse
     * @param {Number} courseId  Course ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabledForCourse = function(courseId, siteId) {
        if (!courseId) {
            return $q.reject();
        }

        return $mmCourses.getUserCourse(courseId, true, siteId).then(function(course) {
            if (course && typeof course.showgrades != 'undefined' && !course.showgrades) {
                return false;
            }
            return true;
        });
    };

    /**
     * Get the grades for a certain course.
     * For now we only support gradereport_user_get_grades_table. It returns the complete grades table.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGrades#getGradesTable
     * @param {Number} courseid ID of the course to get the grades from.
     * @param {Number} userid   ID of the user to get the grades from.
     * @param {Boolean} refresh True when we should not get the value from the cache.
     * @return {Promise}        Promise to be resolved when the grades table is retrieved.
     */
    self.getGradesTable = function(courseid, userid, refresh) {

        $log.debug('Get grades for course ' + courseid + ' and user ' + userid);

        var data = {
                courseid : courseid,
                userid   : userid
            },
            presets = {};
        if (refresh) {
            presets.getFromCache = false;
        }

        return $mmSite.read('gradereport_user_get_grades_table', data, presets).then(function(table) {
            table = formatGradesTable(table, !$ionicPlatform.isTablet());
            return translateGradesTable(table);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades')

/**
 * Grades handlers factory.
 *
 * @module mm.addons.grades
 * @ngdoc service
 * @name $mmaGradesHandlers
 */
.factory('$mmaGradesHandlers', ["$mmaGrades", "$state", "$mmUtil", "$mmContentLinksHelper", "mmCoursesAccessMethods", function($mmaGrades, $state, $mmUtil, $mmContentLinksHelper, mmCoursesAccessMethods) {

    var self = {};

    /**
     * Course nav handler.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGradesHandlers#coursesNav
     */
    self.coursesNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Promise} Promise resolved with true if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaGrades.isPluginEnabled();
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Promise}          Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return $mmaGrades.isPluginEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function() {

            /**
             * Courses nav handler controller.
             *
             * @module mm.addons.grades
             * @ngdoc controller
             * @name $mmaGradesHandlers#coursesNav:controller
             */
            return function($scope, $state) {
                $scope.icon = 'ion-stats-bars';
                $scope.title = 'mma.grades.grades';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.grades', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    /**
     * View grades handler.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGradesHandlers#viewGrades
     */
    self.viewGrades = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Promise} Promise resolved with true if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaGrades.isPluginEnabled();
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User to check.
         * @param {Number} courseId Course ID.
         * @return {Promise}        Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
         */
        self.isEnabledForUser = function(user, courseId) {
            return $mmaGrades.isPluginEnabledForCourse(courseId);
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User.
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(user, courseId) {

            /**
             * View grades handler controller.
             *
             * @module mm.addons.grades
             * @ngdoc controller
             * @name $mmaGradesHandlers#viewGrades:controller
             */
            return function($scope) {
                $scope.title = 'mma.grades.viewgrades';

                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.grades', {
                        userid: user.id,
                        course: {id: courseId}
                    });
                };
            };

        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGradesHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site and course.
         *
         * @param  {String} siteId   Site ID.
         * @param  {Number} courseId Course ID.
         * @return {Promise}         Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaGrades.isPluginEnabled(siteId).then(function(enabled) {
                if (enabled) {
                    return $mmaGrades.isPluginEnabledForCourse(courseId, siteId);
                }
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        Promise resolved with the list of actions.
         *                           See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a grade URL.
            if (url.indexOf('/grade/report/user/index.php') > -1) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    var courseId = parseInt(params.id, 10);
                    // Pass false because all sites should have the same siteurl.
                    return $mmContentLinksHelper.filterSupportedSites(siteIds, isEnabled, false, courseId).then(function(ids) {
                        if (!ids.length) {
                            return [];
                        } else {
                            // Return actions.
                            return [{
                                message: 'mm.core.view',
                                icon: 'ion-eye',
                                sites: ids,
                                action: function(siteId) {
                                    var stateParams = {
                                        course: {id: courseId},
                                        userid: parseInt(params.userid, 10)
                                    };
                                    $mmContentLinksHelper.goInSite('site.grades', stateParams, siteId);
                                }
                            }];
                        }
                    });
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Contacts controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesContactsCtrl
 */
.controller('mmaMessagesContactsCtrl', ["$scope", "$mmaMessages", "$mmSite", "$mmUtil", "$mmApp", "mmUserProfileState", function($scope, $mmaMessages, $mmSite, $mmUtil, $mmApp, mmUserProfileState) {

    var currentUserId = $mmSite.getUserId();

    $scope.loaded = false;
    $scope.contactTypes = ['online', 'offline', 'blocked', 'strangers', 'search'];
    $scope.searchType = 'search';
    $scope.hasContacts = false;
    $scope.canSearch = $mmaMessages.isSearchEnabled;
    $scope.formData = {
        searchString: ''
    };
    $scope.userStateName = mmUserProfileState;

    $scope.refresh = function() {
        $mmaMessages.invalidateAllContactsCache(currentUserId).then(function() {
            return fetchContacts(true).then(function() {
                $scope.formData.searchString = '';
            });
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.search = function(query) {
        if (query.length < 3) {
            // The view should handle this case, but adding this check here to document that
            // we do not want users to query on less than 3 characters as they could retrieve
            // too many users!
            return;
        }

        $mmApp.closeKeyboard();

        $scope.loaded = false;
        return $mmaMessages.searchContacts(query).then(function(result) {
            $scope.hasContacts = result.length > 0;
            $scope.contacts = {
                search: result
            };
        }).catch(function(error) {
            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.errorwhileretrievingcontacts', true);
            }
        }).finally(function() {
            $scope.loaded = true;
        });
    };

    $scope.clearSearch = function() {
        $scope.loaded = false;
        fetchContacts().finally(function() {
            $scope.loaded = true;
        });
    };

    function fetchContacts() {
        return $mmaMessages.getAllContacts().then(function(contacts) {
            $scope.contacts = contacts;

            angular.forEach(contacts, function(contact) {
                if (contact.length > 0) {
                    $scope.hasContacts = true;
                }
            });
        }, function(error) {
            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.errorwhileretrievingcontacts', true);
            }
        });
    }
    fetchContacts().finally(function() {
        $scope.loaded = true;
    });
}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Discussion controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesDiscussionCtrl
 */
.controller('mmaMessagesDiscussionCtrl', ["$scope", "$stateParams", "$mmApp", "$mmaMessages", "$mmSite", "$timeout", "$mmEvents", "$window", "$ionicScrollDelegate", "mmUserProfileState", "$mmUtil", "mmaMessagesPollInterval", "$interval", "$log", "$ionicHistory", "$ionicPlatform", "mmCoreEventKeyboardShow", "mmCoreEventKeyboardHide", "mmaMessagesDiscussionLoadedEvent", "mmaMessagesDiscussionLeftEvent", "$mmUser", function($scope, $stateParams, $mmApp, $mmaMessages, $mmSite, $timeout, $mmEvents, $window,
        $ionicScrollDelegate, mmUserProfileState, $mmUtil, mmaMessagesPollInterval, $interval, $log, $ionicHistory, $ionicPlatform,
        mmCoreEventKeyboardShow, mmCoreEventKeyboardHide, mmaMessagesDiscussionLoadedEvent, mmaMessagesDiscussionLeftEvent,
        $mmUser) {

    $log = $log.getInstance('mmaMessagesDiscussionCtrl');

    var userId = $stateParams.userId,
        userFullname = $stateParams.userFullname,
        messagesBeingSent = 0,
        polling,
        backView = $ionicHistory.backView(),
        lastMessage,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaMessagesScroll');

    $scope.loaded = false;
    $scope.messages = [];
    $scope.userId = userId;
    $scope.currentUserId = $mmSite.getUserId();
    $scope.profileLink = true;

    if (userFullname) {
        $scope.title = userFullname;
    } else if (userId) {
        // We don't have the fullname, try to get it.
        $mmUser.getProfile(userId).then(function(user) {
            if (!$scope.title) {
                $scope.title = user.fullname;
            }
        });
    }

    // Disable the profile button if we're coming from a profile. It is safer to prevent forbid the access
    // to the full profile (we do not know the course ID they came from) as some users cannot view the full
    // profile of other users.
    if (backView && backView.stateName === mmUserProfileState) {
        $scope.profileLink = false;
    }

    $scope.isAppOffline = function() {
        return !$mmApp.isOnline();
    };

    $scope.showDate = function(message, prevMessage) {
        if (!prevMessage) {
            return true;
        }

        // Check if day has changed.
        return !moment(message.timecreated * 1000).isSame(prevMessage.timecreated * 1000, 'day');
    };

    $scope.sendMessage = function(text) {
        var message;
        if (!$mmApp.isOnline()) {
            // Silent error, the view should prevent this.
            return;
        } else if (!text.trim()) {
            // Silent error.
            return;
        }

        text = text.replace(/(?:\r\n|\r|\n)/g, '<br />');
        message = {
            sending: true,
            useridfrom: $scope.currentUserId,
            smallmessage: text,
            timecreated: ((new Date()).getTime() / 1000)
        };
        $scope.messages.push(message);

        messagesBeingSent++;
        $mmaMessages.sendMessage(userId, text).then(function() {
            message.sending = false;
            notifyNewMessage();
        }, function(error) {

            // Only close the keyboard if an error happens, we want the user to be able to send multiple
            // messages withoutthe keyboard being closed.
            $mmApp.closeKeyboard();

            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.messagenotsent', true);
            }
            $scope.messages.splice($scope.messages.indexOf(message), 1);
        }).finally(function() {
            messagesBeingSent--;
        });
    };

    // Fetch the messages for the first time.
    $mmaMessages.getDiscussion(userId).then(function(messages) {
        $scope.messages = $mmaMessages.sortMessages(messages);
        if (!userFullname && messages && messages.length > 0) {
            // When we did not receive the fullname via argument. Also it is possible that
            // we cannot resolve the name when no messages were yet exchanged.
            if (messages[0].useridto != $scope.currentUserId) {
                $scope.title = messages[0].usertofullname || '';
            } else {
                $scope.title = messages[0].userfromfullname || '';
            }
        }
        notifyNewMessage();
    }, function(error) {
        if (typeof error === 'string') {
            $mmUtil.showErrorModal(error);
        } else {
            $mmUtil.showErrorModal('mma.messages.errorwhileretrievingmessages', true);
        }
    }).finally(function() {
        $scope.loaded = true;
    });

    $scope.scrollAfterRender = function(scope) {
        if (scope.$last === true) {
            // Need a timeout to leave time to the view to be rendered.
            $timeout(function() {
                scrollView.scrollBottom();
                setScrollWithKeyboard();
            });
        }
    };

    // Set a polling to get new messages every certain time.
    function setPolling() {
        if (polling) {
            // We already have the polling in place.
            return;
        }

        // Start polling.
        polling = $interval(function() {
            $log.debug('Polling new messages for discussion with user ' + userId);
            if (messagesBeingSent > 0) {
                // We do not poll while a message is being sent or we could confuse the user
                // as his message would disappear from the list, and he'd have to wait for the
                // interval to check for new messages.
                return;
            } else if (!$mmApp.isOnline()) {
                // Obviously we cannot check for new messages when the app is offline.
                return;
            }

            // Invalidate the cache before fetching.
            $mmaMessages.invalidateDiscussionCache(userId);
            $mmaMessages.getDiscussion(userId).then(function(messages) {
                if (messagesBeingSent > 0) {
                    // Ignore polling if due to a race condition.
                    return;
                }
                $scope.messages = $mmaMessages.sortMessages(messages);
                notifyNewMessage();
            });
        }, mmaMessagesPollInterval);
    }

    // Unset polling.
    function unsetPolling() {
        if (polling) {
            $log.debug('Cancelling polling for conversation with user ' + userId);
            $interval.cancel(polling);
            polling = undefined;
        }
    }

    if ($ionicPlatform.isTablet()) {
        // Listen for events to set/unset the polling in tablet. We use angular events because we cannot use ionic events
        // (we use ui-view). The behavior is the same, since scope is destroyed on tablet view when navigating to subviews.
        $scope.$on('$viewContentLoaded', function(){
            setPolling();
        });
        $scope.$on('$destroy', function(){
            unsetPolling();
        });
    } else {
        // Listen for events to set/unset the polling in phones. We can use ionic events.
        $scope.$on('$ionicView.enter', function() {
            setPolling();
        });
        $scope.$on('$ionicView.leave', function(e) {
            unsetPolling();
        });

    }

    // Notify the last message found so discussions list controller can tell if last message should be updated.
    function notifyNewMessage() {
        var last = $scope.messages[$scope.messages.length - 1];
        if (last && last.smallmessage !== lastMessage) {
            lastMessage = last.smallmessage;
            $mmEvents.trigger($mmaMessages.getDiscussionEventName(userId), {
                message: lastMessage,
                timecreated: last.timecreated
            });
        }
    }

    // Scroll when keyboard is hide/shown to keep the user scroll. This is only needed for Android.
    function setScrollWithKeyboard() {
        if (ionic.Platform.isAndroid()) {
            $timeout(function() { // Use a $timeout to wait for scroll to correctly measure height.
                var obsShow,
                    obsHide,
                    keyboardHeight,
                    maxInitialScroll = scrollView.getScrollView().__contentHeight - scrollView.getScrollView().__clientHeight,
                    initialHeight = $window.innerHeight;

                obsShow = $mmEvents.on(mmCoreEventKeyboardShow, function(e) {
                    $timeout(function() {
                        // Try to calculate keyboard height ourselves since e.keyboardHeight is not reliable.
                        var heightDifference = initialHeight - $window.innerHeight,
                            newKeyboardHeight = heightDifference > 50 ? heightDifference : e.keyboardHeight;
                        if (newKeyboardHeight) {
                            keyboardHeight = newKeyboardHeight;
                            scrollView.scrollBy(0, newKeyboardHeight);
                        }
                    });
                });

                obsHide = $mmEvents.on(mmCoreEventKeyboardHide, function(e) {
                    if (!scrollView || !scrollView.getScrollPosition()) {
                        return; // Can't get scroll position, stop.
                    }

                    if (scrollView.getScrollPosition().top >= maxInitialScroll) {
                        // scrollBy(0,0) would automatically reset at maxInitialScroll. We need to apply the difference
                        // from there to scroll to the right point.
                        scrollView.scrollBy(0, scrollView.getScrollPosition().top - keyboardHeight - maxInitialScroll);
                    } else {
                        scrollView.scrollBy(0, - keyboardHeight);
                    }
                });

                $scope.$on('$destroy', function() {
                    obsShow && obsShow.off && obsShow.off();
                    obsHide && obsHide.off && obsHide.off();
                });
            });
        }
    }

    if ($ionicPlatform.isTablet()) {
        $mmEvents.trigger(mmaMessagesDiscussionLoadedEvent, userId);
    }
    $scope.$on('$destroy', function() {
        if ($ionicPlatform.isTablet()) {
            $mmEvents.trigger(mmaMessagesDiscussionLeftEvent);
        }
    });

}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Discussions controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesDiscussionsCtrl
 */
.controller('mmaMessagesDiscussionsCtrl', ["$q", "$state", "$scope", "$mmUtil", "$mmaMessages", "$rootScope", "$mmEvents", "mmCoreSplitViewLoad", function($q, $state, $scope, $mmUtil, $mmaMessages, $rootScope, $mmEvents,
            mmCoreSplitViewLoad) {
    var observers = [];

    $scope.loaded = false;

    // Set observers to watch for new messages on discussions. If a user sees a new message in a discussion, we'll update
    // the discussion's last message in discussions list.
    function setObservers(discussions) {
        clearObservers();

        angular.forEach(discussions, function(discussion) {
            observers.push($mmEvents.on($mmaMessages.getDiscussionEventName(discussion.message.user), function(data) {
                if (data && data.timecreated > discussion.message.timecreated) {
                    discussion.message.message = data.message;
                    discussion.message.timecreated = data.timecreated;
                }
            }));
        });
    }

    // Clear observers.
    function clearObservers() {
        angular.forEach(observers, function(observer) {
            if (observer && observer.off) {
                observer.off();
            }
        });
    }

    function fetchDiscussions() {
        return $mmaMessages.getDiscussions().then(function(discussions) {
            // Convert to an array for sorting.
            var array = [];
            angular.forEach(discussions, function(v) {
                array.push(v);
            });
            $scope.discussions = array;
            setObservers(array);
        }, function(error) {
            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.errorwhileretrievingdiscussions', true);
            }
        });
    }

    $scope.refresh = function() {
        $mmaMessages.invalidateDiscussionsCache().then(function() {
            return fetchDiscussions();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    fetchDiscussions().finally(function() {
        $scope.loaded = true;
        // Tell mm-split-view that it can load the first link now in tablets. We need to do it
        // like this because the directive doesn't have access to $scope.loaded variable (because of tabs).
        $rootScope.$broadcast(mmCoreSplitViewLoad);
    });

    $scope.$on('$destroy', function() {
        clearObservers();
    });
}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Messages index controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesIndexCtrl
 */
.controller('mmaMessagesIndexCtrl', ["$scope", "$mmEvents", "$ionicPlatform", "$ionicTabsDelegate", "mmaMessagesDiscussionLoadedEvent", "mmaMessagesDiscussionLeftEvent", function($scope, $mmEvents, $ionicPlatform, $ionicTabsDelegate,
            mmaMessagesDiscussionLoadedEvent, mmaMessagesDiscussionLeftEvent) {
    // Listen for discussion loaded event to show user profile link in tablet view.
    var obsLoaded = $mmEvents.on(mmaMessagesDiscussionLoadedEvent, function(userId) {
        $scope.profileLink = $ionicPlatform.isTablet() && $ionicTabsDelegate.selectedIndex() == 0;
        $scope.userId = userId;
    });

    // Listen for discussion loaded event to show user profile link in tablet view.
    var obsLeft = $mmEvents.on(mmaMessagesDiscussionLeftEvent, function() {
        $scope.profileLink = false;
    });

    $scope.$on('$destroy', function() {
        if (obsLoaded && obsLoaded.off) {
            obsLoaded.off();
        }
        if (obsLeft && obsLeft.off) {
            obsLeft.off();
        }
    });
}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Filter to format a message.
 *
 * @module mma.messages
 * @ngdoc filter
 * @name mmaMessagesFormat
 */
.filter('mmaMessagesFormat', ["$mmText", function($mmText) {
  return function(text) {
    text = text.replace(/-{4,}/ig, '');
    text = text.replace(/<br \/><br \/>/ig, "<br />");
    text = $mmText.replaceNewLines(text, '<br />');
    return text;
  };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Messages handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.messages
 * @ngdoc service
 * @name $mmaMessagesHandlers
 */
.factory('$mmaMessagesHandlers', ["$log", "$mmaMessages", "$mmSite", "$state", "$mmUtil", "$mmContentLinksHelper", function($log, $mmaMessages, $mmSite, $state, $mmUtil, $mmContentLinksHelper) {
    $log = $log.getInstance('$mmaMessagesHandlers');

    var self = {};

    /**
     * Add contact handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#addContact
     */
    self.addContact = function() {

        var self = {};

        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        self.isEnabledForUser = function(user, courseId) {
            return user.id != $mmSite.getUserId();
        };

        /**
         * Add contact handler controller.
         *
         * @module mm.addons.messages
         * @ngdoc controller
         * @name $mmaMessagesHandlers#blockContact:controller
         */
        self.getController = function(user, courseid) {

            return function($scope, $rootScope) {
                var disabled = false;

                function updateTitle() {
                    return $mmaMessages.isContact(user.id).then(function(isContact) {
                        if (isContact) {
                            $scope.title = 'mma.messages.removecontact';
                        } else {
                            $scope.title = 'mma.messages.addcontact';
                        }
                    }).catch(function() {
                        // This fails for some reason, let's just hide the button.
                        $scope.hidden = true;
                    });
                }

                $scope.title = '';
                $scope.spinner = false;
                $scope.action = function($event) {
                    if (disabled) {
                        return;
                    }
                    disabled = true;
                    $scope.spinner = true;
                    $mmaMessages.isContact(user.id).then(function(isContact) {
                        if (isContact) {
                            return $mmaMessages.removeContact(user.id);
                        } else {
                            return $mmaMessages.addContact(user.id);
                        }
                    }).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    }).finally(function() {
                        $rootScope.$broadcast('mmaMessagesHandlers:addUpdated');
                        updateTitle().finally(function() {
                            disabled = false;
                            $scope.spinner = false;
                        });
                    });
                };

                $scope.$on('mmaMessagesHandlers:blockUpdated', function() {
                    updateTitle();
                });

                updateTitle();

            };

        };

        return self;
    };

    /**
     * Block contact handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#blockContact
     */
    self.blockContact = function() {

        var self = {};

        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        self.isEnabledForUser = function(user, courseId) {
            return user.id != $mmSite.getUserId();
        };

        self.getController = function(user, courseid) {

            /**
             * Block contact handler controller.
             *
             * @module mm.addons.messages
             * @ngdoc controller
             * @name $mmaMessagesHandlers#blockContact:controller
             */
            return function($scope, $rootScope) {
                var disabled = false;

                function updateTitle() {
                    return $mmaMessages.isBlocked(user.id).then(function(isBlocked) {
                        if (isBlocked) {
                            $scope.title = 'mma.messages.unblockcontact';
                        } else {
                            $scope.title = 'mma.messages.blockcontact';
                        }
                    }).catch(function() {
                        // This fails for some reason, let's just hide the button.
                        $scope.hidden = true;
                    });
                }

                $scope.title = '';
                $scope.spinner = false;
                $scope.action = function($event) {
                    if (disabled) {
                        return;
                    }
                    disabled = true;
                    $scope.spinner = true;
                    $mmaMessages.isBlocked(user.id).then(function(isBlocked) {
                        if (isBlocked) {
                            return $mmaMessages.unblockContact(user.id);
                        } else {
                            return $mmaMessages.blockContact(user.id);
                        }
                    }).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    }).finally(function() {
                        $rootScope.$broadcast('mmaMessagesHandlers:blockUpdated');
                        updateTitle().finally(function() {
                            disabled = false;
                            $scope.spinner = false;
                        });
                    });
                };

                $scope.$on('mmaMessagesHandlers:addUpdated', function() {
                    updateTitle();
                });

                updateTitle();

            };

        };

        return self;
    };

    /**
     * Send message handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#blockContact
     */
    self.sendMessage = function() {

        var self = {};

        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        self.isEnabledForUser = function(user, courseId) {
            return user.id != $mmSite.getUserId();
        };

        self.getController = function(user, courseid) {

            /**
             * Send message handler controller.
             *
             * @module mm.addons.messages
             * @ngdoc controller
             * @name $mmaMessagesHandlers#sendMessage:controller
             */
            return function($scope) {
                $scope.title = 'mma.messages.sendmessage';
                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.messages-discussion', {
                        userId: user.id,
                        userFullname: user.fullname
                    });
                };
            };

        };

        return self;
    };

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.messages
             * @ngdoc controller
             * @name $mmaMessagesHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-chatbox';
                $scope.title = 'mma.messages.messages';
                $scope.state = 'site.messages';
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId Site ID.
         * @return {Promise}       Promise resolved with true if enabled.
         */
        function isEnabledForSite(siteId) {
            return $mmaMessages.isPluginEnabled(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        Promise resolved with the list of actions.
         *                           See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a messages URL.
            if (url.indexOf('/message/index.php') > -1) {
                // Pass false because all sites should have the same siteurl.
                return $mmContentLinksHelper.filterSupportedSites(siteIds, isEnabledForSite, false).then(function(ids) {
                    if (!ids.length) {
                        return [];
                    } else {
                        // Return actions.
                        var params = $mmUtil.extractUrlParams(url);
                        return [{
                            message: 'mm.core.view',
                            icon: 'ion-eye',
                            sites: ids,
                            action: function(siteId) {
                                var stateName,
                                    stateParams;

                                if (typeof params.user1 != 'undefined' && typeof params.user2 != 'undefined') {
                                    // Check if the current user is in the conversation.
                                    if ($mmSite.getUserId() == params.user1) {
                                        stateName = 'site.messages-discussion';
                                        stateParams = {userId: parseInt(params.user2, 10)};
                                    } else if ($mmSite.getUserId() == params.user2) {
                                        stateName = 'site.messages-discussion';
                                        stateParams = {userId: parseInt(params.user1, 10)};
                                    } else {
                                        // He isn't, open in browser.
                                        $mmUtil.openInBrowser(url);
                                        return;
                                    }
                                } else if (typeof params.id != 'undefined') {
                                    stateName = 'site.messages-discussion';
                                    stateParams = {userId: parseInt(params.id, 10)};
                                }

                                if (!stateName) {
                                    // Go to messaging index page. We use redirect state to view the side menu.
                                    $state.go('redirect', {
                                        siteid: siteId,
                                        state: 'site.messages',
                                        params: {}
                                    });
                                } else {
                                    $mmContentLinksHelper.goInSite(stateName, stateParams, siteId);
                                }
                            }
                        }];
                    }
                });
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Messages factory.
 *
 * @module mm.addons.messages
 * @ngdoc service
 * @name $mmaMessages
 */
.factory('$mmaMessages', ["$mmSite", "$mmSitesManager", "$log", "$q", "$mmUser", "mmaMessagesNewMessageEvent", function($mmSite, $mmSitesManager, $log, $q, $mmUser, mmaMessagesNewMessageEvent) {
    $log = $log.getInstance('$mmaMessages');

    var self = {};

    /**
     * Add a contact.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#addContact
     * @param {Number} to User ID of the person to add.
     * @return {Promise}
     */
    self.addContact = function(userId) {
        return $mmSite.write('core_message_create_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };

    /**
     * Block a contact.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#blockContact
     * @param {Number} to User ID of the person to block.
     * @return {Promise}
     */
    self.blockContact = function(userId) {
        return $mmSite.write('core_message_block_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };

    /**
     * Get all the contacts of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getAllContacts
     * @return {Promise} Resolved with the WS data.
     */
    self.getAllContacts = function() {
        return self.getContacts().then(function(contacts) {
            return self.getBlockedContacts().then(function(blocked) {
                contacts.blocked = blocked.users;
                storeUsersFromAllContacts(contacts);
                return contacts;
            }, function() {
                // The WS for blocked contacts might not be available yet, but we still want the contacts.
                contacts.blocked = [];
                storeUsersFromAllContacts(contacts);
                return contacts;
            });
        });
    };

    /**
     * Get all the blocked contacts of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getBlockedContacts
     * @return {Promise} Resolved with the WS data.
     */
    self.getBlockedContacts = function() {
        var params = {
                userid: $mmSite.getUserId()
            },
            presets = {
                cacheKey: self._getCacheKeyForBlockedContacts($mmSite.getUserId())
            },
            deferred;

        if (!$mmSite.wsAvailable('core_message_get_blocked_users')) {
            // If the WS is not available, we mock an empty response.
            deferred = $q.defer();
            deferred.resolve({users: [], warnings: []});
            return deferred.promise;
        }

        return $mmSite.read('core_message_get_blocked_users', params, presets);
    };

    /**
     * Get the cache key for contacts.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForContacts
     * @return {String}
     * @protected
     */
    self._getCacheKeyForContacts = function() {
        // Note: the contacts WS does not take arguments, so we do not need any here.
        return 'mmaMessages:contacts';
    };

    /**
     * Get the cache key for blocked contacts.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForBlockedContacts
     * @param {Number} userId The user who's contacts we're looking for.
     * @return {String}
     * @protected
     */
    self._getCacheKeyForBlockedContacts = function(userId) {
        return 'mmaMessages:blockedContacts:' + userId;
    };

    /**
     * Get the cache key for a discussion.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForDiscussion
     * @param {Number} userId The other person with whom the current user is having the discussion.
     * @return {String}
     * @protected
     */
    self._getCacheKeyForDiscussion = function(userId) {
        return 'mmaMessages:discussion:' + userId;
    };

    /**
     * Get the cache key for the list of discussions.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForDiscussions
     * @return {String}
     * @protected
     */
    self._getCacheKeyForDiscussions = function() {
        return 'mmaMessages:discussions';
    };

    /**
     * Get the cache key for the messaging enabled call.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForEnabled
     * @return {String}
     * @protected
     */
    self._getCacheKeyForEnabled = function() {
        return 'mmaMessages:enabled';
    };

    /**
     * Get the contacts of the current user.
     *
     * This excludes the blocked users.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getContacts
     * @return {Promise} Resolved with the WS data.
     */
    self.getContacts = function() {
        var presets = {
                cacheKey: self._getCacheKeyForContacts()
            };
        return $mmSite.read('core_message_get_contacts', undefined, presets);
    };

    /**
     * Get the name of the events of a discussion.
     *
     * @param  {Number} userid User ID of the discussion.
     * @return {String}        Name of the event.
     */
    self.getDiscussionEventName = function(userid) {
        return mmaMessagesNewMessageEvent + '_' + $mmSite.getUserId() + '_' + userid;
    }

    /**
     * Return the current user's discussion with another user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getDiscussion
     * @param {Number} userId The ID of the other user.
     * @return {Promise}
     */
    self.getDiscussion = function(userId) {
        var messages,
            presets = {
                cacheKey: self._getCacheKeyForDiscussion(userId)
            },
            params = {
                useridto: $mmSite.getUserId(),
                useridfrom: userId,
                limitfrom: 0,
                limitnum: 50
            };

        return self._getRecentMessages(params, presets).then(function(response) {
            messages = response;
            params.useridto = userId;
            params.useridfrom = $mmSite.getUserId();

            return self._getRecentMessages(params, presets).then(function(response) {
                return messages.concat(response);
            });
        });
    };

    /**
     * Get the discussions of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getDiscussions
     * @return {Promise} Resolved with an object where the keys are the user ID of the other user.
     */
    self.getDiscussions = function() {
        var discussions = {},
            presets = {
                cacheKey: self._getCacheKeyForDiscussions()
            },
            promise;

        return self._getRecentMessages({
            useridto: $mmSite.getUserId(),
            useridfrom: 0,
            limitfrom: 0,
            limitnum: 50
        }, presets).then(function(messages) {

            // Extract the discussions by filtering same senders.
            angular.forEach(messages, function(message) {
                if (typeof discussions[message.useridfrom] === 'undefined') {
                    discussions[message.useridfrom] = {
                        fullname: message.userfromfullname,
                        profileimageurl: ""
                    };

                    if (!message.timeread) {
                        discussions[message.useridfrom].unread = true;
                    }
                }

                // Extract the most recent message.
                if (typeof discussions[message.useridfrom].message === 'undefined' ||
                        discussions[message.useridfrom].message.timecreated < message.timecreated) {

                    discussions[message.useridfrom].message = {
                        user: message.useridfrom,
                        message: message.smallmessage,
                        timecreated: message.timecreated
                    };
                }
            });

            // Now get the last messages sent from which we might not have received a reply yet.
            return self._getRecentMessages({
                useridfrom: $mmSite.getUserId(),
                useridto: 0,
                limitfrom: 0,
                limitnum: 50
            }, presets).then(function(messages) {

                // Extract the discussions by filtering same senders.
                angular.forEach(messages, function(message) {
                    if (typeof discussions[message.useridto] === 'undefined') {
                        discussions[message.useridto] = {
                            fullname: message.usertofullname,
                            profileimageurl: ""
                        };

                        if (!message.timeread) {
                            discussions[message.useridto].unread = true;
                        }
                    }

                    // Extract the most recent message.
                    if (typeof discussions[message.useridto].message === 'undefined' ||
                            discussions[message.useridto].message.timecreated < message.timecreated) {

                        discussions[message.useridto].message = {
                            user: message.useridto,
                            message: message.smallmessage,
                            timecreated: message.timecreated
                        };
                    }
                });

                // Now get the contacts
                return self.getContacts().then(function(contacts) {
                    var types = ['online', 'offline', 'strangers'];

                    angular.forEach(types, function(type) {
                        if (contacts[type] && contacts[type].length > 0) {
                            angular.forEach(contacts[type], function(contact) {

                                if (typeof discussions[contact.id] === 'undefined' && contact.unread) {
                                    // It's a contact with unread messages. Contacts without unread messages are not used.
                                    discussions[contact.id] = {
                                        fullname: contact.fullname,
                                        profileimageurl: "",
                                        message: {
                                            user: contact.id,
                                            message: "...",
                                            timecreated: 0,
                                        }
                                    };
                                }

                                if (typeof discussions[contact.id] !== 'undefined') {
                                    // The contact is used in a discussion.
                                    if (contact.profileimageurl) {
                                        discussions[contact.id].profileimageurl = contact.profileimageurl;
                                    }
                                    if (typeof contact.unread !== 'undefined') {
                                        discussions[contact.id].unread = contact.unread;
                                    }
                                }
                            });
                        }
                    });

                    return self.getDiscussionsUserImg(discussions).then(function(discussions) {
                        storeUsersFromDiscussions(discussions);
                        return discussions;
                    });
                });
            });
        });
    };

    /**
     * Get user images for all the discussions that don't have one already.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getDiscussionsUserImg
     * @param {Object[]} discussions List of discussions.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted discussions.
     */
    self.getDiscussionsUserImg = function(discussions) {
        var promises = [];

        angular.forEach(discussions, function(discussion) {
            if (!discussion.profileimageurl) {
                // We don't have the user image. Try to retrieve it.
                var promise = $mmUser.getProfile(discussion.message.user, 1, true).then(function(user) {
                    discussion.profileimageurl = user.profileimageurl;
                }, function() {
                    // Error getting profile, resolve promise without adding any extra data.
                });
                promises.push(promise);
            }
        });
        return $q.all(promises).then(function() {
            return discussions;
        });
    };

    /**
     * Get messages according to the params.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getMessages
     * @param {Object} params Parameters to pass to the WS.
     * @param {Object} presets Set of presets for the WS.
     * @return {Promise}
     * @protected
     */
    self._getMessages = function(params, presets) {
        params = angular.extend(params, {
            type: 'conversations',
            newestfirst: 1,
        });

        return $mmSite.read('core_message_get_messages', params, presets);
    };

    /**
     * Get the most recent messages.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getRecentMessages
     * @param {Object} params Parameters to pass to the WS.
     * @param {Object} presets Set of presets for the WS.
     * @return {Promise}
     * @protected
     */
    self._getRecentMessages = function(params, presets) {
        params = angular.extend(params, {
            read: 0
        });

        return self._getMessages(params, presets).then(function(response) {
            var messages = response.messages;
            if (messages) {
                if (messages.length >= params.limitnum) {
                    return messages;
                }

                // We need to fetch more messages.
                params.limitnum = params.limitnum - messages.length;
                params.read = 1;

                return self._getMessages(params, presets).then(function(response) {
                    if (response.messages) {
                        messages = messages.concat(response.messages);
                    }
                    return messages;
                }, function() {
                    return messages;
                });

            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Invalidate all contacts cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateAllContactsCache
     * @param {Number} userId The user ID.
     * @return {Promise}
     */
    self.invalidateAllContactsCache = function(userId) {
        return self.invalidateContactsCache().then(function() {
            return self.invalidateBlockedContactsCache(userId);
        });
    };

    /**
     * Invalidate blocked contacts cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateBlockedContactsCache
     * @param {Number} userId The user ID.
     * @return {Promise}
     */
    self.invalidateBlockedContactsCache = function(userId) {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForBlockedContacts(userId));
    };


    /**
     * Invalidate contacts cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateContactsCache
     * @return {Promise}
     */
    self.invalidateContactsCache = function() {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForContacts());
    };

    /**
     * Invalidate discussion cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateDiscussionCache
     * @param {Number} userId The user ID with whom the current user is having the discussion.
     * @return {Promise}
     */
    self.invalidateDiscussionCache = function(userId) {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForDiscussion(userId));
    };

    /**
     * Invalidate discussions cache.
     *
     * Note that {@link $mmaMessages#getDiscussions} uses the contacts, so we need to invalidate contacts too.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateDiscussionsCache
     * @return {Promise}
     */
    self.invalidateDiscussionsCache = function(userId) {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForDiscussions()).then(function(){
            return self.invalidateContactsCache();
        });
    };

    /**
     * Invalidate messaging enabled cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateEnabledCache
     * @return {Promise}
     */
    self.invalidateEnabledCache = function() {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForEnabled());
    };

    /**
     * Checks if the a user is blocked by the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isBlocked
     * @param {Number} userId The user ID to check against.
     * @return {Promise} Resolved with boolean, rejected when we do not know.
     */
    self.isBlocked = function(userId) {
        return self.getBlockedContacts().then(function(blockedContacts) {
            var blocked = false;
            if (!blockedContacts.users || blockedContacts.users.length < 1) {
                return blocked;
            }
            angular.forEach(blockedContacts.users, function(user) {
                if (userId == user.id) {
                    blocked = true;
                }
            });
            return blocked;
        });
    };

    /**
     * Checks if the a user is a contact of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isContact
     * @param {Number} userId The user ID to check against.
     * @return {Promise} Resolved with boolean, rejected when we do not know.
     */
    self.isContact = function(userId) {
        return self.getContacts().then(function(contacts) {
            var isContact = false,
                types = ['online', 'offline'];

            angular.forEach(types, function(type) {
                if (contacts[type] && contacts[type].length > 0) {
                    angular.forEach(contacts[type], function(user) {
                        if (userId == user.id) {
                            isContact = true;
                        }
                    });
                }
            });

            return isContact;
        });
    };

    /**
     * Returns whether or not messaging is enabled for the current site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_isMessagingEnabled
     * @return {Promise} Resolved when enabled, otherwise rejected.
     * @protected
     */
    self._isMessagingEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var enabled = site.canUseAdvancedFeature('messaging', 'unknown');

            if (enabled === 'unknown') {
                // On older version we cannot check other than calling a WS. If the request
                // fails there is a very high chance that messaging is disabled.
                $log.debug('Using WS call to check if messaging is enabled.');
                return site.read('core_message_search_contacts', {
                    searchtext: 'CheckingIfMessagingIsEnabled',
                    onlymycourses: 0
                }, {
                    emergencyCache: false,
                    cacheKey: self._getCacheKeyForEnabled()
                });
            }

            if (enabled) {
                return true;
            }
            return $q.reject();
        });
    };

   /**
     * Returns whether or not messaging is enabled for a certain site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isMessagingEnabledForSite
     * @param {String} siteid Site ID.
     * @return {Promise}      Resolved when enabled, otherwise rejected.
     */
    self.isMessagingEnabledForSite = function(siteid) {
        return $mmSitesManager.getSite(siteid).then(function(site) {
            if (!site.canUseAdvancedFeature('messaging') || !site.wsAvailable('core_message_get_messages')) {
                return $q.reject();
            }

            // On older version we cannot check other than calling a WS. If the request
            // fails there is a very high chance that messaging is disabled.
            $log.debug('Using WS call to check if messaging is enabled.');
            return site.read('core_message_search_contacts', {
                searchtext: 'CheckingIfMessagingIsEnabled',
                onlymycourses: 0
            }, {
                emergencyCache: false,
                cacheKey: self._getCacheKeyForEnabled()
            });
        });
    };

    /**
     * Returns whether or not the plugin is enabled in a certain site.
     *
     * Do not abuse this method.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canUseAdvancedFeature('messaging')) {
                return false;
            } else if (!site.wsAvailable('core_message_get_messages')) {
                return false;
            } else {
                return self._isMessagingEnabled(siteId).then(function() {
                    return true;
                });
            }
        });
    };

    /**
     * Returns whether or not we can search contacts.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isSearchEnabled
     * @return {Boolean}
     */
    self.isSearchEnabled = function() {
        return $mmSite.wsAvailable('core_message_search_contacts');
    };

    /**
     * Remove a contact.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#removeContact
     * @param {Number} to User ID of the person to remove.
     * @return {Promise}
     */
    self.removeContact = function(userId) {
        return $mmSite.write('core_message_delete_contacts', {
            userids: [ userId ]
        }, {
            responseExpected: false
        }).then(function() {
            return self.invalidateContactsCache();
        });
    };

    /**
     * Search for contacts.
     *
     * By default this only returns the first 100 contacts, but note that the WS can return thousands
     * of results which would take a while to process. The limit here is just a convenience to
     * prevent viewed to crash because too many DOM elements are created.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#searchContacts
     * @param {String} query The query string.
     * @param {Number} [limit=100] The number of results to return, 0 for none.
     * @return {Promise}
     */
    self.searchContacts = function(query, limit) {
        var data = {
                searchtext: query,
                onlymycourses: 0
            };
        limit = typeof limit === 'undefined' ? 100 : limit;
        return $mmSite.read('core_message_search_contacts', data).then(function(contacts) {
            if (limit && contacts.length > limit) {
                contacts = contacts.splice(0, limit);
            }
            $mmUser.storeUsers(contacts);
            return contacts;
        });
    };

    /**
     * Send a message to someone.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#sendMessage
     * @param {Number} to User ID to send the message to.
     * @param {String} message The message to send
     * @return {Promise}
     */
    self.sendMessage = function(to, message) {
        return $mmSite.write('core_message_send_instant_messages', {
            messages: [
                {
                    touserid: to,
                    text: message,
                    textformat: 1
                }
            ]
        }).then(function(response) {
            if (response && response[0] && response[0].msgid === -1) {
                // There was an error, and it should be translated already.
                return $q.reject(response[0].errormessage);
            }
            return self.invalidateDiscussionCache(to);
        });
    };

    /**
     * Helper method to sort messages by time.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#sortMessages
     * @param {Object[]} messages Array of messages containing the key 'timecreated'.
     * @return {Object[]} Messages sorted with most recent last.
     */
    self.sortMessages = function(messages) {
        return messages.sort(function (a, b) {
            a = parseInt(a.timecreated, 10);
            b = parseInt(b.timecreated, 10);
            return a >= b ? 1 : -1;
        });
    };

    /**
     * Store user data from contacts in local DB.
     *
     * @param {Object[]} contactTypes List of contacts grouped in types.
     */
    function storeUsersFromAllContacts(contactTypes) {
        angular.forEach(contactTypes, function(contacts) {
            $mmUser.storeUsers(contacts);
        });
    }

    /**
     * Store user data from discussions in local DB.
     *
     * @param {Object[]} discussions List of discussions.
     */
    function storeUsersFromDiscussions(discussions) {
        angular.forEach(discussions, function(discussion, userid) {
            if (typeof userid != 'undefined' && !isNaN(parseInt(userid))) {
                $mmUser.storeUser(userid, discussion.fullname, discussion.profileimageurl);
            }
        });
    }

    /**
     * Unblock a user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#unblockContact
     * @param {Number} to User ID of the person to unblock.
     * @return {Promise}
     */
    self.unblockContact = function(userId) {
        return $mmSite.write('core_message_unblock_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Assign index controller.
 *
 * @module mm.addons.mod_assign
 * @ngdoc controller
 * @name mmaModAssignIndexCtrl
 */
.controller('mmaModAssignIndexCtrl', ["$scope", "$stateParams", "$mmaModAssign", "$mmUtil", "$translate", "mmaModAssignComponent", "mmaModAssignSubmissionComponent", function($scope, $stateParams, $mmaModAssign, $mmUtil, $translate,
        mmaModAssignComponent, mmaModAssignSubmissionComponent) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.assigncomponent = mmaModAssignComponent;
    $scope.submissioncomponent = mmaModAssignSubmissionComponent;
    $scope.assignurl = module.url;
    $scope.courseid = courseid;

    function fetchAssignment(refresh) {
        // Get assignment data.
        return $mmaModAssign.getAssignment(courseid, module.id, refresh).then(function(assign) {
            $scope.title = assign.name || $scope.title;
            $scope.description = assign.intro || $scope.description;
            $scope.assign = assign;

            // Get assignment submissions.
            return $mmaModAssign.getSubmissions(assign.id, refresh).then(function(data) {
                $scope.canviewsubmissions = data.canviewsubmissions;

                if (data.canviewsubmissions) {
                    // We want to show the user data on each submission.
                    return $mmaModAssign.getSubmissionsUserData(data.submissions, courseid).then(function(submissions) {
                        angular.forEach(submissions, function(submission) {
                            submission.text = $mmaModAssign.getSubmissionText(submission);
                            submission.attachments = $mmaModAssign.getSubmissionAttachments(submission);
                        });
                        $scope.submissions = submissions;
                    });
                }
            }, function() {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $translate('mm.core.error').then(function(error) {
                        $mmUtil.showErrorModal(error + ': get_assignment_submissions');
                    });
                }
            });
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $translate('mm.core.error').then(function(error) {
                    $mmUtil.showErrorModal(error + ': get_assignment');
                });
            }
        });
    }

    fetchAssignment().finally(function() {
        $scope.assignmentLoaded = true;
    });

    $scope.refreshAssignment = function() {
        fetchAssignment(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Assign submission controller.
 *
 * @module mm.addons.mod_assign
 * @ngdoc controller
 * @name mmaModAssignSubmissionCtrl
 */
.controller('mmaModAssignSubmissionCtrl', ["$scope", "$stateParams", "mmaModAssignSubmissionComponent", function($scope, $stateParams, mmaModAssignSubmissionComponent) {
    var submission = $stateParams.submission || {};

    $scope.title = submission.userfullname;
    $scope.submission = submission;
    $scope.component = mmaModAssignSubmissionComponent;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Assignments service.
 *
 * @module mm.addons.mod_assign
 * @ngdoc controller
 * @name $mmaModAssign
 */
.factory('$mmaModAssign', ["$mmSite", "$q", "$mmUser", "$mmSitesManager", function($mmSite, $q, $mmUser, $mmSitesManager) {
    var self = {};

    /**
     * Get an assignment.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getAssignment
     * @param {Number} courseid   Course ID the assignment belongs to.
     * @param {Number} cmid       Assignment module ID.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @return {Promise}          Promise resolved with the assignment.
     */
    self.getAssignment = function(courseid, cmid, refresh) {
        var params = {
                "courseids": [courseid]
            },
            preSets = {};

        if (refresh) {
            preSets.getFromCache = false;
        }

        return $mmSite.read('mod_assign_get_assignments', params, preSets).then(function(response) {
            if (response.courses && response.courses.length) {
                var assignments = response.courses[0].assignments;
                for (var i = 0; i < assignments.length; i++) {
                    if (assignments[i].cmid == cmid) {
                        return assignments[i];
                    }
                }
                return $q.reject();
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Get attachments of a submission.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissionAttachments
     * @param {Object} submission Submission.
     * @return {Object[]}         Submission attachments.
     */
    self.getSubmissionAttachments = function(submission) {
        var files = [];
        if (submission.plugins) {
            submission.plugins.forEach(function(plugin) {
                if (plugin.type === 'file' && plugin.fileareas && plugin.fileareas[0] && plugin.fileareas[0].files) {
                    files = plugin.fileareas[0].files;
                    angular.forEach(files, function(file) {
                        file.filename = file.filepath;
                    });
                }
            });
        }
        return files;
    };

    /**
     * Get text of a submission.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissionText
     * @param {Object} submission Submission.
     * @return {String}           Submission text.
     */
    self.getSubmissionText = function(submission) {
        var text = '';
        if (submission.plugins) {
            angular.forEach(submission.plugins, function(plugin) {
                if (plugin.type === 'onlinetext' && plugin.editorfields) {
                    text = plugin.editorfields[0].text;

                    // Online text contains '@@PLUGINFILE@@' for each embedded file. Replace those with the right URL.
                    if (plugin.fileareas && plugin.fileareas[0] && plugin.fileareas[0].files && plugin.fileareas[0].files[0]) {
                        var fileURL =  plugin.fileareas[0].files[0].fileurl;
                        fileURL = fileURL.substr(0, fileURL.lastIndexOf('/')).replace('pluginfile.php/', 'pluginfile.php?file=/');
                        text = text.replace(/@@PLUGINFILE@@/g, fileURL);
                    }
                }
            });
        }
        return text;
    };

    /**
     * Get an assignment submissions.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissions
     * @param {Number}  id        Assignment id.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @return {Promise}          Promise resolved with:
     *                                    - canviewsubmissions: True if user can view submissions, false otherwise.
     *                                    - submissions: Array of submissions.
     */
    self.getSubmissions = function(id, refresh) {
        var params = {
                "assignmentids": [id]
            },
            preSets = {};

        if (refresh) {
            preSets.getFromCache = false;
        }

        return $mmSite.read('mod_assign_get_submissions', params, preSets).then(function(response) {
            // Check if we can view submissions, with enough permissions.
            if (response.warnings.length > 0 && response.warnings[0].warningcode == 1) {
                return {canviewsubmissions: false};
            } else {
                if (response.assignments && response.assignments.length) {
                    return {
                        canviewsubmissions: true,
                        submissions: response.assignments[0].submissions
                    };
                } else {
                    return $q.reject();
                }
            }
        });
    };

    /**
     * Get user data for submissions since they only have userid.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissionsUserData
     * @param {Object[]} submissions Submissions to get the data for.
     * @param {Number}   courseid    ID of the course the submissions belong to.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted submissions.
     */
    self.getSubmissionsUserData = function(submissions, courseid) {
        var promises = [];

        angular.forEach(submissions, function(submission) {
            var promise = $mmUser.getProfile(submission.userid, courseid, true).then(function(user) {
                submission.userfullname = user.fullname;
                submission.userprofileimageurl = user.profileimageurl;
            }, function() {
                // Error getting profile, resolve promise without adding any extra data.
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return submissions;
        });
    };

    /**
     * Check if assignments plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('mod_assign_get_assignments') && site.wsAvailable('mod_assign_get_submissions');
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Mod assign handlers.
 *
 * @module mm.addons.mod_assign
 * @ngdoc service
 * @name $mmaModAssignHandlers
 */
.factory('$mmaModAssignHandlers', ["$mmCourse", "$mmaModAssign", "$state", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModAssign, $state, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssignHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for the site.
         *
         * @return {Promise}
         */
        self.isEnabled = function() {
            return $mmaModAssign.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('assign');
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_assign', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssignHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModAssign.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's an assign URL.
            if (url.indexOf('/mod/assign/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Book index controller.
 *
 * @module mm.addons.mod_book
 * @ngdoc controller
 * @name mmaModBookIndexCtrl
 */
.controller('mmaModBookIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModBook", "$log", "mmaModBookComponent", "$ionicPopover", "$mmApp", "$q", "$mmCourse", "$ionicScrollDelegate", function($scope, $stateParams, $mmUtil, $mmaModBook, $log, mmaModBookComponent,
            $ionicPopover, $mmApp, $q, $mmCourse, $ionicScrollDelegate) {
    $log = $log.getInstance('mmaModBookIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        currentChapter;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModBookComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;

    var chapters = $mmaModBook.getTocList(module.contents);
    currentChapter = $mmaModBook.getFirstChapter(chapters);

    // Convenience function to load a book chapter.
    function loadChapter(chapterId) {
        currentChapter = chapterId;
        $ionicScrollDelegate.scrollTop();
        return $mmaModBook.getChapterContent(module.contents, chapterId, module.id).then(function(content) {
            $scope.content = content;
            $scope.previousChapter = $mmaModBook.getPreviousChapter(chapters, chapterId);
            $scope.nextChapter = $mmaModBook.getNextChapter(chapters, chapterId);
        }).catch(function() {
            $mmUtil.showErrorModal('mma.mod_book.errorchapter', true);
            return $q.reject();
        }).finally(function() {
            $scope.loaded = true;
            $ionicScrollDelegate.resize(); // Call resize to recalculate scroll area.
        });
    }

    // Convenience function to download book contents and load the current chapter.
    function fetchContent(chapterId) {
        var downloadFailed = false;
        return $mmaModBook.downloadAllContent(module).catch(function() {
            // Mark download as failed but go on since the main files could have been downloaded.
            downloadFailed = true;
        }).finally(function() {
            // Show chapter.
            return loadChapter(chapterId).then(function() {
                if (downloadFailed && $mmApp.isOnline()) {
                    // We could load the main file but the download failed. Show error message.
                    $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                }
            });
        });
    }

    $scope.doRefresh = function() {
        $mmaModBook.invalidateContent(module.id).then(function() {
            return fetchContent(currentChapter);
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Function to load a chapter.
    $scope.loadChapter = function(chapterId) {
        $scope.popover.hide();
        $scope.loaded = false;
        loadChapter(chapterId);
    };

    // Menu popover.
    $scope.toc = chapters;
    $ionicPopover.fromTemplateUrl('addons/mod_book/templates/toc.html', {
        scope: $scope,
    }).then(function(popover) {
        $scope.popover = popover;
    });


    fetchContent(currentChapter).then(function() {
        $mmaModBook.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Directive to navigate to previous/next chapter in a book.
 *
 * @module mm.addons.mod_book
 * @ngdoc directive
 * @name mmaModBookArrows
 * @description
 * This directive will show two arrows at the left and right of the screen to navigate to previous/next book chapter when
 * clicked. If no previous/next chapter is defined, that arrow won't be shown.
 *
 * @param {Number}   previous ID of the previous chapter.
 * @param {Number}   next     ID of the next chapter.
 * @param {Function} action   Function to call when an arrow is clicked. Will receive as a param the chapterId to load.
 */
.directive('mmaModBookArrows', function() {
    return {
        restrict: 'E',
        scope: {
            previous: '=?',
            next: '=?',
            action: '=?'
        },
        templateUrl: 'addons/mod_book/templates/arrows.html'
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Book factory.
 *
 * @module mm.addons.mod_book
 * @ngdoc service
 * @name $mmaModBook
 */
.factory('$mmaModBook', ["$mmFilepool", "$mmSite", "$mmFS", "$http", "$log", "$q", "$mmSitesManager", "mmaModBookComponent", function($mmFilepool, $mmSite, $mmFS, $http, $log, $q, $mmSitesManager, mmaModBookComponent) {
    $log = $log.getInstance('$mmaModBook');

    var self = {};

    /**
     * Download all the content.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModBookComponent, module.id, revision, timemod);
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get the book toc as an array.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getToc
     * @param  {array} contents The module contents.
     * @return {Array}          The toc.
     * @protected
     */
    self.getToc = function(contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return JSON.parse(contents[0].content);
    };

    /**
     * Get the book toc as an array of chapters (no nested).
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getTocList
     * @param  {array} contents The module contents.
     * @return {Array}          The toc as a list.
     * @protected
     */
    self.getTocList = function(contents) {
        var chapters = [];
        var toc = self.getToc(contents);
        angular.forEach(toc, function(el) {
            var chapterId = el.href.replace('/index.html', '');
            chapters.push({id: chapterId, title: el.title, level: el.level});
            angular.forEach(el.subitems, function(sel) {
                chapterId = sel.href.replace('/index.html', '');
                chapters.push({id: chapterId, title: sel.title, level: sel.level});
            });
        });
        return chapters;
    };

    /**
     * Get the first chapter of a book.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getFirstChapter
     * @param  {array} chapters  The chapters list.
     * @return {String}          The chapter id.
     * @protected
     */
    self.getFirstChapter = function(chapters) {
        if (!chapters || !chapters.length) {
            return;
        }
        return chapters[0].id;
    };

    /**
     * Get the previous chapter to the given one.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getPreviousChapter
     * @param  {array} chapters     The chapters list.
     * @param  {String} chapterId   The current chapter.
     * @return {String}             The previous chapter id.
     * @protected
     */
    self.getPreviousChapter = function(chapters, chapterId) {
        var previous = 0;

        for (var i = 0, len = chapters.length; i < len; i++) {
            if (chapters[i].id == chapterId) {
                break;
            }
            previous = chapters[i].id;
        }

        return previous;
    };

    /**
     * Get the next chapter to the given one.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getNextChapter
     * @param  {array} chapters     The chapters list.
     * @param  {String} chapterId   The current chapter.
     * @return {String}             The next chapter id.
     * @protected
     */
    self.getNextChapter = function(chapters, chapterId) {
        var next = 0;

        for (var i = 0, len = chapters.length; i < len; i++) {
            if (chapters[i].id == chapterId) {
                if (typeof chapters[i + 1] != 'undefined') {
                    next = chapters[i + 1].id;
                    break;
                }
            }
        }
        return next;
    };

    /**
     * Gets a chapter contents from the book.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getChapterContent
     * @param {Object} contents     The module contents.
     * @param {String} chapterId    Chapter to retrieve.
     * @param {Integer} moduleId    The module ID.
     * @return {Promise}
     */
    self.getChapterContent = function(contents, chapterId, moduleId) {
        var indexUrl,
            paths = {},
            promise;

        // Extract the information about paths from the module contents.
        angular.forEach(contents, function(content) {
            if (self.isFileDownloadable(content)) {
                var key,
                    url = content.fileurl;

                if (!indexUrl && content.filename == 'index.html') {
                    // First chapter, we don't have a chapter id.
                    if (content.filepath == "/" + chapterId + "/") {
                        indexUrl = url;
                    }
                } else {
                    key = content.filename;
                    paths[key] = url;
                }
            }
        });

        // Promise handling when we are in a browser.
        promise = (function() {
            var deferred;
            if (!indexUrl) {
                // If ever that happens.
                $log.debug('Could not locate the index chapter');
                return $q.reject();
            } else if ($mmFS.isAvailable()) {
                // The file system is available.
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModBookComponent, moduleId);
            } else {
                // We return the live URL.
                deferred = $q.defer();
                deferred.resolve($mmSite.fixPluginfileURL(indexUrl));
                return deferred.promise;
            }
        })();

        return promise.then(function(url) {
            // Fetch the URL content.
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    // Now that we have the content, we update the SRC to point back to
                    // the external resource. That will be caught by mm-format-text.
                    var html = angular.element('<div>');
                    html.html(response.data);
                    angular.forEach(html.find('img'), function(img) {
                        var src = paths[decodeURIComponent(img.getAttribute('src'))];
                        if (typeof src !== 'undefined') {
                            img.setAttribute('src', src);
                        }
                    });
                    // We do the same for links.
                    angular.forEach(html.find('a'), function(anchor) {
                        var href = paths[decodeURIComponent(anchor.getAttribute('href'))];
                        if (typeof href !== 'undefined') {
                            anchor.setAttribute('href', href);
                        }
                    });
                    return html.html();
                }
            });
        });
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#invalidateContent
     * @param {Object} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModBookComponent, moduleId);
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Return whether or not the plugin is enabled.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var version = site.getInfo().version;
            // Require Moodle 2.9.
            return version && (parseInt(version) >= 2015051100) && site.canDownloadFiles();
        });
    };

    /**
     * Report a book as being viewed.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                bookid: id
            };
            return $mmSite.write('mod_book_view_book', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModBookComponent, module.id, revision, timemod);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Mod book handlers.
 *
 * @module mm.addons.mod_book
 * @ngdoc service
 * @name $mmaModBookHandlers
 */
.factory('$mmaModBookHandlers', ["$mmCourse", "$mmaModBook", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreDownloaded", "mmCoreEventPackageStatusChanged", "mmaModBookComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModBook, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreDownloaded,
            mmCoreEventPackageStatusChanged, mmaModBookComponent, $mmContentLinksHelper, $q) {

    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookHandlers#courseContentHandler
     */
    self.courseContentHandler = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModBook.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModBook.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();

                        $mmaModBook.invalidateContent(module.id).finally(function() {
                            $mmaModBook.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('book');
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_book', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        // Always show refresh button if a book is downloaded because revision and timemodified aren't reliable.
                        refreshBtn.hidden = status !== mmCoreOutdated && status !== mmCoreDownloaded;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModBookComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModBook.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a book URL.
            if (url.indexOf('/mod/book/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Mod book prefetch handler.
 *
 * @module mm.addons.mod_book
 * @ngdoc service
 * @name $mmaModBookPrefetchHandler
 */
.factory('$mmaModBookPrefetchHandler', ["$mmaModBook", "mmCoreDownloaded", "mmCoreOutdated", "mmaModBookComponent", function($mmaModBook, mmCoreDownloaded, mmCoreOutdated, mmaModBookComponent) {

    var self = {};

    self.component = mmaModBookComponent;

    /**
     * Determine the status of a module based on the current status detected.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#determineStatus
     * @param {String} status Current status.
     * @return {String}       Status to show.
     */
    self.determineStatus = function(status) {
        if (status === mmCoreDownloaded) {
            // Books are always treated as outdated since revision and timemodified aren't reliable.
            return mmCoreOutdated;
        } else {
            return status;
        }
    };

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModBook.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmaModBook.isPluginEnabled();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModBook.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Chat controller.
 *
 * @module mm.addons.mod_chat
 * @ngdoc controller
 * @name mmaModChatChatCtrl
 */
.controller('mmaModChatChatCtrl', ["$scope", "$stateParams", "$mmApp", "$mmaModChat", "$log", "$ionicModal", "$mmUtil", "$ionicHistory", "$ionicScrollDelegate", "$timeout", "$mmSite", "$interval", "mmaChatPollInterval", function($scope, $stateParams, $mmApp, $mmaModChat, $log, $ionicModal, $mmUtil, $ionicHistory,
            $ionicScrollDelegate, $timeout, $mmSite, $interval, mmaChatPollInterval) {

    $log = $log.getInstance('mmaModChatChatCtrl');

    var chatId = $stateParams.chatid,
        courseId = $stateParams.courseid,
        title = $stateParams.title,
        polling;

    $scope.loaded = false;
    $scope.title = title;
    $scope.currentUserId = $mmSite.getUserId();
    $scope.currentUserBeep = 'beep ' + $scope.currentUserId;
    $scope.messages = [];
    $scope.chatUsers = [];

    // We use an object because it works better with forms.
    $scope.newMessage = {
        text: ''
    };
    chatLastTime = 0;

    // Chat users modal.
    $ionicModal.fromTemplateUrl('addons/mod_chat/templates/users.html', {
        scope: $scope,
        animation: 'slide-in-up'
    }).then(function(m) {
        $scope.modal = m;
    });

    // Close the chat users modal.
    $scope.closeModal = function(){
        $scope.modal.hide();
    };

    // Display the chat users modal.
    $scope.showChatUsers = function() {
        $scope.usersLoaded = false;
        $scope.modal.show();
        $mmaModChat.getChatUsers($scope.chatsid).then(function(data) {
            $scope.chatUsers = data.users;
        }).catch(function(error) {
            showError(error, 'mma.mod_chat.errorwhilegettingchatusers');
        }).finally(function() {
            $scope.usersLoaded = true;
        });
    };

    // Add To "user":
    $scope.talkTo = function(user) {
        $scope.newMessage.text = "To " + user + ": ";
        $scope.modal.hide();
    };

    // Beep a user.
    $scope.beepTo = function(userId) {
        $scope.sendMessage('', userId);
        $scope.modal.hide();
    };

    // Check is the app is offline.
    $scope.isAppOffline = function() {
        return !$mmApp.isOnline();
    };

    // Show error modal.
    function showError(error, defaultMessage) {
        if (typeof error === 'string') {
            $mmUtil.showErrorModal(error);
        } else {
            $mmUtil.showErrorModal(defaultMessage, true);
        }
    }

    // Check if the date should be displayed between messages (when the day changes at midnight for example).
    $scope.showDate = function(message, prevMessage) {
        if (!prevMessage) {
            return true;
        }

        // Check if day has changed.
        return !moment(message.timestamp * 1000).isSame(prevMessage.timestamp * 1000, 'day');
    };

    // Send a message to the chat.
    $scope.sendMessage = function(text, beep) {
        beep = beep || '';

        if (!$mmApp.isOnline()) {
            // Silent error, the view should prevent this.
            return;
        } else if (beep === '' && !text.trim()) {
            // Silent error.
            return;
        }
        text = text.replace(/(?:\r\n|\r|\n)/g, '<br />');

        $mmaModChat.sendMessage($scope.chatsid, text, beep).then(function() {
            if (beep === '') {
                $scope.newMessage.text = '';
            }
        }, function(error) {
            // Only close the keyboard if an error happens, we want the user to be able to send multiple
            // messages withoutthe keyboard being closed.
            $mmApp.closeKeyboard();

            showError(error, 'mma.mod_chat.errorwhilesendingmessage');
        });
    };

    // Login the user.
    $mmaModChat.loginUser(chatId).then(function(chatsid) {
        return $mmaModChat.getLatestMessages(chatsid, 0).then(function(messagesInfo) {
            $scope.chatsid = chatsid;
            chatLastTime = messagesInfo.chatnewlasttime;
            return $mmaModChat.getMessagesUserData(messagesInfo.messages, courseId).then(function(messages) {
                $scope.messages = $scope.messages.concat(messages);
            });
        }).catch(function(message) {
            showError(message, 'mma.mod_chat.errorwhileretrievingmessages');
        });
    }, function(error) {
        showError(error, 'mma.mod_chat.errorwhileconnecting');
        $ionicHistory.goBack();
    }).finally(function() {
        $scope.loaded = true;
    });

    // Scroll to the bottom.
    $scope.scrollAfterRender = function(scope) {
        if (scope.$last === true) {
            // Need a timeout to leave time to the view to be rendered.
            $timeout(function() {
                var scrollView = $ionicScrollDelegate.$getByHandle('mmaChatScroll');
                scrollView.scrollBottom();
            });
        }
    };

    // Set up the polling on a view enter, this allows for the user to go back and resume the polling.
    $scope.$on('$ionicView.enter', function() {
        // Strange case, we already have the polling in place.
        if (polling) {
            return;
        }

        // Start polling.
        polling = $interval(function() {
            $log.debug('Polling for messages');
            if (!$mmApp.isOnline()) {
                // Obviously we cannot check for new messages when the app is offline.
                return;
            }

            $mmaModChat.getLatestMessages($scope.chatsid, chatLastTime).then(function(data) {
                chatLastTime = data.chatnewlasttime;
                $mmaModChat.getMessagesUserData(data.messages, courseId).then(function(messages) {
                    $scope.messages = $scope.messages.concat(messages);
                });
            }, function(error) {
                $interval.cancel(polling);
                showError(error, 'mma.mod_chat.errorwhileretrievingmessages');
            });

        }, mmaChatPollInterval);
    });

    // Removing the polling as we leave the page.
    $scope.$on('$ionicView.leave', function(e) {
        if (polling) {
            $log.debug('Cancelling polling for conversation');
            $interval.cancel(polling);
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Chat index controller.
 *
 * @module mm.addons.mod_chat
 * @ngdoc controller
 * @name mmaModChatIndexCtrl
 */
.controller('mmaModChatIndexCtrl', ["$scope", "$stateParams", "$mmaModChat", "$mmUtil", "$q", "$mmCourse", function($scope, $stateParams, $mmaModChat, $mmUtil, $q, $mmCourse) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        chat;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;

    // Convenience function to get chat data.
    function fetchChatData(refresh) {
        return $mmaModChat.getChat(courseid, module.id, refresh).then(function(chatdata) {
            chat = chatdata;
            $scope.title = chat.name || $scope.title;
            $scope.description = chat.intro || $scope.description;
            $scope.chatId = chat.id;
            $scope.chatScheduled = '';

            var now = $mmUtil.timestamp();
            var span = chat.chattime - now;

            if (chat.chattime && chat.schedule > 0 && span > 0) {
                $mmUtil.formatTime(span).then(function(time) {
                    $scope.chatScheduled = time;
                });
            }

        }, function(error) {
            if (!refresh) {
                // Get chat failed, retry without using cache since it might be a new activity.
                return fetchChatData(true);
            }

            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.mod_chat.errorwhilegettingchatdata', true);
            }
            return $q.reject();
        });
    }

    fetchChatData().then(function() {
        $mmaModChat.logView(chat.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.chatLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshChat = function() {
        fetchChatData(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Chat service.
 *
 * @module mm.addons.mod_chat
 * @ngdoc service
 * @name $mmaModChat
 */
.factory('$mmaModChat', ["$q", "$mmSite", "$mmUser", "$mmSitesManager", function($q, $mmSite, $mmUser, $mmSitesManager) {
    var self = {};


    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the chat WS are available.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_chat_get_chats_by_courses') &&
                    site.wsAvailable('mod_chat_login_user') &&
                    site.wsAvailable('mod_chat_get_chat_users') &&
                    site.wsAvailable('mod_chat_send_chat_message') &&
                    site.wsAvailable('mod_chat_get_chat_latest_messages');
        });
    };

    /**
     * Get a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#getChat
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @return {Promise}        Promise resolved when the chat is retrieved.
     */
    self.getChat = function(courseid, cmid, refresh) {
        var params = {
            courseids: [courseid]
            },
            preSets = {};

        if (refresh) {
            preSets.getFromCache = false;
        }

        return $mmSite.read('mod_chat_get_chats_by_courses', params, preSets).then(function(response) {
            if (response.chats) {
                var currentChat;
                angular.forEach(response.chats, function(chat) {
                    if (chat.coursemodule == cmid) {
                        currentChat = chat;
                    }
                });
                if (currentChat) {
                    return currentChat;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#loginUser
     * @param {Number} chatId   Chat instance ID.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.loginUser = function(chatId) {
        var params = {
            chatid: chatId
        };

        return $mmSite.write('mod_chat_login_user', params).then(function(response) {
            if (response.chatsid) {
                return response.chatsid;
            }
            return $q.reject();
        });
    };

    /**
     * Report a chat as being viewed.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                chatid: id
            };
            return $mmSite.write('mod_chat_view_chat', params);
        }
        return $q.reject();
    };

    /**
     * Send a message to a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#sendMessage
     * @param {Number} chatsid  Chat sessiond ID.
     * @param {String} message  Message text.
     * @param {Number} beep     Beep user ID.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.sendMessage = function(chatsid, message, beep) {
        var params = {
            chatsid: chatsid,
            messagetext: message,
            beepid: beep
        };

        return $mmSite.write('mod_chat_send_chat_message', params).then(function(response) {
            if (response.messageid) {
                return response.messageid;
            }
            return $q.reject();
        });
    };

    /**
     * Get the latest messages from a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#getLatestMessages
     * @param {Number} chatsid  Chat sessiond ID.
     * @param {Number} lasttime Last time when messages were retrieved.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.getLatestMessages = function(chatsid, lasttime) {
        var params = {
            chatsid: chatsid,
            chatlasttime: lasttime
        };
        var preSets = {
            getFromCache: false
        };

        return $mmSite.read('mod_chat_get_chat_latest_messages', params, preSets);
    };

    /**
     * Get user data for messages since they only have userid.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaModChat#getMessagesUserData
     * @param {Object[]} messages    Messages to get the data for.
     * @param {Number}   courseid    ID of the course the messages belong to.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted messages.
     */
    self.getMessagesUserData = function(messages, courseid) {
        var promises = [];

        angular.forEach(messages, function(message) {
            var promise = $mmUser.getProfile(message.userid, courseid, true).then(function(user) {
                message.userfullname = user.fullname;
                message.userprofileimageurl = user.profileimageurl;
            }, function() {
                // Error getting profile. Set default data.
                message.userfullname = message.userid;
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return messages;
        });
    };

    /**
     * Get the actives users of a current chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#getChatUsers
     * @param {Number} chatsid  Chat sessiond ID.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.getChatUsers = function(chatsid) {
        var params = {
            chatsid: chatsid
        };
        var preSets = {
            getFromCache: false
        };

        return $mmSite.read('mod_chat_get_chat_users', params, preSets);
    };

    return self;
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Mod chat handlers.
 *
 * @module mm.addons.mod_chat
 * @ngdoc service
 * @name $mmaModChatHandlers
 */
.factory('$mmaModChatHandlers', ["$mmCourse", "$mmaModChat", "$state", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModChat, $state, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChatHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModChat.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('chat');
                $scope.action = function(e) {
                    $state.go('site.mod_chat', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChatHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModChat.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a chat URL.
            if (url.indexOf('/mod/chat/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice')

/**
 * Choice index controller.
 *
 * @module mm.addons.mod_choice
 * @ngdoc controller
 * @name mmaModChoiceIndexCtrl
 * @todo Delete answer if user can update the answer, show selected if choice is closed (WS returns empty options).
 */
.controller('mmaModChoiceIndexCtrl', ["$scope", "$timeout", "$stateParams", "$mmaModChoice", "$mmUtil", "$q", "$mmCourse", "$translate", function($scope, $timeout, $stateParams, $mmaModChoice, $mmUtil, $q, $mmCourse, $translate) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        choice,
        hasAnswered = false;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;

    $scope.d3_options = {
        chart: {
            type: 'discreteBarChart',
            x: function(d){ return d.label; },
            y: function(d){ return d.value; },
            showValues: true,
            valueFormat: function(d){
                return d3.format('')(d);
            },
            transitionDuration: 500,
            xAxis: {},
            yAxis: {
                tickFormat: function(d){ return d3.format(',f')(d) }
            },
            // https://nvd3-community.github.io/nvd3/examples/documentation.html#tooltip
            tooltip: {
                contentGenerator: function(obj) {
                    // console.log(obj);
                    return d3.format('.1%')(obj.data.percent);
                }
            },
            // https://github.com/krispo/angular-nvd3/issues/36
            discretebar: {
                dispatch: {
                    renderEnd: function(e){
                        d3.selectAll(".tick text").call(wrap,_chart.xAxis.rangeBand());
                    },
                }
            },
            callback: function(chart){
                _chart = chart; //global var
            }
        }
    };

    // re-wrap x-axis labels after (swipe down) refresh
    $scope.d3_events = {
        'scroll.refreshComplete': function(e, scope) {
            // The mirky depths of Angular require wrapping this event handler in $timeout()
            // for the text wrapping to persist in the DOM.
            // example: https://github.com/krispo/angular-nvd3/issues/36
            // background: https://docs.angularjs.org/error/$rootScope/inprog
            $timeout(function() {d3.selectAll(".tick text").call(wrap,_chart.xAxis.rangeBand());}, 0);
        }
    };

    // http://bl.ocks.org/mbostock/7555321
    function wrap(text, width) {
      text.each(function() {
        var text = d3.select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            y = text.attr("y"),
            dy = parseFloat(text.attr("dy")),
            tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
          }
        }
      });
    }

    // Convenience function to get choice data.
    function fetchChoiceData(refresh) {
        $scope.now = new Date().getTime();
        return $mmaModChoice.getChoice(courseid, module.id).then(function(choicedata) {
            choice = choicedata;
            choice.timeopen = parseInt(choice.timeopen) * 1000;
            choice.openTimeReadable = moment(choice.timeopen).format('LLL');
            choice.timeclose = parseInt(choice.timeclose) * 1000;
            choice.closeTimeReadable = moment(choice.timeclose).format('LLL');

            $scope.title = choice.name || $scope.title;
            $scope.description = choice.intro || $scope.description;
            $scope.choice = choice;

            // We need fetchOptions to finish before calling fetchResults because it needs hasAnswered variable.
            return fetchOptions().then(function() {
                return fetchResults();
            });
        }).catch(function(message) {
            if (!refresh) {
                // Some call failed, retry without using cache since it might be a new activity.
                return refreshAllData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_choice.errorgetchoice', true);
            }
            return $q.reject();
        });
    }

    // Convenience function to get choice options.
    function fetchOptions() {
        return $mmaModChoice.getOptions(choice.id).then(function(options) {
            var isOpen = isChoiceOpen();
            hasAnswered = false;
            $scope.selectedOption = {id: -1}; // Single choice model.
            angular.forEach(options, function(option) {
                if (option.checked) {
                    hasAnswered = true;
                    if (!choice.allowmultiple) {
                        $scope.selectedOption.id = option.id;
                    }
                }
            });
            $scope.canEdit = isOpen && (choice.allowupdate || !hasAnswered);
            $scope.canDelete = $mmaModChoice.isDeleteResponsesEnabled() && isOpen && choice.allowupdate && hasAnswered;
            $scope.options = options;
        });
    }

    // Convenience function to get choice results.
    function fetchResults() {
        return $mmaModChoice.getResults(choice.id).then(function(results) {
            var hasVotes = false;
            var data     = [];
            angular.forEach(results, function(result) {
                if (result.numberofuser > 0) {
                    hasVotes = true;
                }
                result.percentageamount = parseFloat(result.percentageamount).toFixed(1);
                data.push({
                    'label': result.text,
                    'value': result.numberofuser,
                    'percent': result.percentageamount / 100 });
            });
            $scope.canSeeResults = hasVotes || $mmaModChoice.canStudentSeeResults(choice, hasAnswered);
            $scope.results = results;
            $scope.data = [{
                //key: "Some key to the data?",
                values: data
            }];
        });
    }

    /**
     * Check if a choice is open.
     *
     * @return {Boolean} True if choice is open, false otherwise.
     */
    function isChoiceOpen() {
        return (choice.timeopen === 0 || choice.timeopen <= $scope.now) &&
                (choice.timeclose === 0 || choice.timeclose > $scope.now);
    }

    // Convenience function to refresh all the data.
    function refreshAllData() {
        var p1 = $mmaModChoice.invalidateChoiceData(courseid),
            p2 = choice ? $mmaModChoice.invalidateOptions(choice.id) : $q.when(),
            p3 = choice ? $mmaModChoice.invalidateResults(choice.id) : $q.when();

        return $q.all([p1, p2, p3]).finally(function() {
            return fetchChoiceData(true);
        });
    }

    fetchChoiceData().then(function() {
        $mmaModChoice.logView(choice.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.choiceLoaded = true;
    });

    // Save options selected.
    $scope.save = function() {
        // Only show confirm if choice doesn't allow update.
        var promise = choice.allowupdate ? $q.when() : $mmUtil.showConfirm($translate('mm.core.areyousure'));
        promise.then(function() {
            var responses = [];
            if (choice.allowmultiple) {
                angular.forEach($scope.options, function(option) {
                    if (option.checked) {
                        responses.push(option.id);
                    }
                });
            } else {
                responses.push($scope.selectedOption.id);
            }

            var modal = $mmUtil.showModalLoading('mm.core.sending', true);
            $mmaModChoice.submitResponse(choice.id, responses).then(function() {
                // Success! Let's refresh the data.
                return refreshAllData();
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_choice.cannotsubmit', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };

    // Delete options selected.
    $scope.delete = function() {
        $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
            var modal = $mmUtil.showModalLoading('mm.core.sending', true);
            $mmaModChoice.deleteResponses(choice.id).then(function() {
                // Success! Let's refresh the data.
                return refreshAllData();
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_choice.cannotsubmit', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };

    // Pull to refresh.
    $scope.refreshChoice = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice')

/**
 * Choice service.
 *
 * @module mm.addons.mod_choice
 * @ngdoc service
 * @name $mmaModChoice
 */
.factory('$mmaModChoice', ["$q", "$mmSite", "$mmSitesManager", "mmaModChoiceResultsAfterAnswer", "mmaModChoiceResultsAfterClose", "mmaModChoiceResultsAlways", function($q, $mmSite, $mmSitesManager, mmaModChoiceResultsAfterAnswer, mmaModChoiceResultsAfterClose,
            mmaModChoiceResultsAlways) {
    var self = {};

    /**
     * Check if results can be seen by a student. The student can see the results if:
     *     - they're always published, OR
     *     - they're published after the choice is closed and it's closed, OR
     *     - they're published after answering and the user has answered.
     *
     * @param {Object}  choice      Choice to check.
     * @param {Boolean} hasAnswered True if user has answered the choice, false otherwise.
     * @return {Boolean} [description]
     */
    self.canStudentSeeResults = function(choice, hasAnswered) {
        var now = new Date().getTime();
        return  choice.showresults === mmaModChoiceResultsAlways ||
                choice.showresults === mmaModChoiceResultsAfterClose && choice.timeclose !== 0 && choice.timeclose <= now ||
                choice.showresults === mmaModChoiceResultsAfterAnswer && hasAnswered;
    };

    /**
     * Delete responses from a choice.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#deleteResponses
     * @param {Number} choiceid      Choice ID.
     * @param {Number[]} [responses] IDs of the answers. If not defined, delete all the answers of the current user.
     * @return {Promise}             Promise resolved when the options are deleted.
     */
    self.deleteResponses = function(choiceid, responses) {
        responses = responses || [];
        var params = {
            choiceid: choiceid,
            responses: responses
        };
        return $mmSite.write('mod_choice_delete_choice_responses', params).then(function(response) {
            if (!response || response.status === false) {
                return $q.reject();
            }
        });
    };

    /**
     * Get cache key for choice data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getChoiceDataCacheKey(courseid) {
        return 'mmaModChoice:choice:' + courseid;
    }

    /**
     * Get cache key for choice options WS calls.
     *
     * @param {Number} choiceid Choice ID.
     * @return {String}     Cache key.
     */
    function getChoiceOptionsCacheKey(choiceid) {
        return 'mmaModChoice:options:' + choiceid;
    }

    /**
     * Get cache key for choice results WS calls.
     *
     * @param {Number} choiceid Choice ID.
     * @return {String}     Cache key.
     */
    function getChoiceResultsCacheKey(choiceid) {
        return 'mmaModChoice:results:' + choiceid;
    }

    /**
     * Returns if current site supports deleting choice responses.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#isDeleteResponsesEnabled
     * @return {Boolean} True if supported, false otherwise.
     */
    self.isDeleteResponsesEnabled = function() {
        return $mmSite.wsAvailable('mod_choice_delete_choice_responses');
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the choice WS are available.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_choice_get_choice_options') &&
                    site.wsAvailable('mod_choice_get_choice_results') &&
                    site.wsAvailable('mod_choice_get_choices_by_courses') &&
                    site.wsAvailable('mod_choice_submit_choice_response');
        });
    };

    /**
     * Get a choice.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#getChoice
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the choice is retrieved.
     */
    self.getChoice = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getChoiceDataCacheKey(courseid)
            };

        return $mmSite.read('mod_choice_get_choices_by_courses', params, preSets).then(function(response) {
            if (response.choices) {
                var currentChoice;
                angular.forEach(response.choices, function(choice) {
                    if (choice.coursemodule == cmid) {
                        currentChoice = choice;
                    }
                });
                if (currentChoice) {
                    return currentChoice;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get a choice options.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#getOptions
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved with choice options.
     */
    self.getOptions = function(choiceid) {
        var params = {
                choiceid: choiceid
            },
            preSets = {
                cacheKey: getChoiceOptionsCacheKey(choiceid)
            };

        return $mmSite.read('mod_choice_get_choice_options', params, preSets).then(function(response) {
            if (response.options) {
                return response.options;
            }
            return $q.reject();
        });
    };

    /**
     * Get a choice results.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#getResults
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved with choice results.
     */
    self.getResults = function(choiceid) {
        var params = {
                choiceid: choiceid
            },
            preSets = {
                cacheKey: getChoiceResultsCacheKey(choiceid)
            };

        return $mmSite.read('mod_choice_get_choice_results', params, preSets).then(function(response) {
            if (response.options) {
                return response.options;
            }
            return $q.reject();
        });
    };

    /**
     * Invalidates choice data.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#invalidateChoiceData
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateChoiceData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getChoiceDataCacheKey(courseid));
    };

    /**
     * Invalidates options.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#invalidateOptions
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateOptions = function(choiceid) {
        return $mmSite.invalidateWsCacheForKey(getChoiceOptionsCacheKey(choiceid));
    };

    /**
     * Invalidates results.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#invalidateResults
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateResults = function(choiceid) {
        return $mmSite.invalidateWsCacheForKey(getChoiceResultsCacheKey(choiceid));
    };

    /**
     * Report the choice as being viewed.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#logView
     * @param {String} id Choice ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                choiceid: id
            };
            return $mmSite.write('mod_choice_view_choice', params);
        }
        return $q.reject();
    };

    /**
     * Send a response to a choice to Moodle.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#submitResponse
     * @param {Number} choiceid    Choice ID.
     * @param {Number[]} responses IDs of selected options.
     * @return {Promise}           Promise resolved when results are successfully submitted.
     */
    self.submitResponse = function(choiceid, responses) {
        var params = {
            choiceid: choiceid,
            responses: responses
        };
        return $mmSite.write('mod_choice_submit_choice_response', params);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice')

/**
 * Mod choice handlers.
 *
 * @module mm.addons.mod_choice
 * @ngdoc service
 * @name $mmaModChoiceHandlers
 */
.factory('$mmaModChoiceHandlers', ["$mmCourse", "$mmaModChoice", "$state", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModChoice, $state, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoiceHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModChoice.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('choice');
                $scope.action = function(e) {
                    $state.go('site.mod_choice', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoiceHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModChoice.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a choice URL.
            if (url.indexOf('/mod/choice/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Folder index controller.
 *
 * @module mm.addons.mod_folder
 * @ngdoc controller
 * @name mmaModFolderIndexCtrl
 */
.controller('mmaModFolderIndexCtrl', ["$scope", "$stateParams", "$mmaModFolder", "$mmCourse", "$mmUtil", "$q", function($scope, $stateParams, $mmaModFolder, $mmCourse, $mmUtil, $q) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        sectionid = $stateParams.sectionid,
        path = $stateParams.path;

    // Convenience function to set scope data using module.
    function showModuleData(module) {
        $scope.title = module.name;
        $scope.description = module.description;
        if (path) {
            // Subfolder.
            $scope.contents = module.contents;
        } else {
            $scope.contents = $mmaModFolder.formatContents(module.contents);
            $scope.moduleurl = module.url;
        }
    }

    // Convenience function to fetch folder data from Moodle.
    function fetchFolder() {
        return $mmCourse.getModule(module.id, courseid, sectionid).then(function(module) {
            showModuleData(module);
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.mod_folder.errorwhilegettingfolder', true);
            }

            if (!$scope.title) {
                // Error getting data from server. Use module param.
                showModuleData(module);
            }
            return $q.reject();
        });
    }

    if (path) {
        // Subfolder. Use module param.
        showModuleData(module);
        $scope.folderLoaded = true;
        $scope.canReload = false;
    } else {
        fetchFolder().then(function() {
            $mmaModFolder.logView(module.instance).then(function() {
                $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
            });
        }).finally(function() {
            $scope.folderLoaded = true;
            $scope.canReload = true;
        });
    }

    $scope.refreshFolder = function() {
        $mmCourse.invalidateModule(module.id).finally(function() {
            fetchFolder().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Folder service.
 *
 * @module mm.addons.mod_folder
 * @ngdoc service
 * @name $mmaModFolder
 * @todo Adding a new file in a folder updates the revision of all the files, so they're all shown as outdated.
 *       To ignore revision in folders we'll have to modify $mmCoursePrefetchDelegate, mm-file and $mmFilepool.
 */
.factory('$mmaModFolder', ["$mmSite", "$mmCourse", "$q", "$mmFilepool", "mmaModFolderComponent", function($mmSite, $mmCourse, $q, $mmFilepool, mmaModFolderComponent) {
    var self = {};

    /**
     * Download all the content.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModFolderComponent, module.id, revision, timemod);
    };

    /**
     * Format folder contents, creating directory structure.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#formatContents
     * @param {Object[]} contents Folder contents.
     * @return {Object[]}         Formatted contents.
     * @description
     * Format folder contents, creating directory structure.
     * Folders found in filepaths are added to the array. Each folder has the properties: name, fileicon,
     * type (folder), filepath and contents (array with files and subfolders).
     */
    self.formatContents = function(contents) {
        var files = [],
            folders = [],
            foldericon = $mmCourse.getModuleIconSrc('folder');

        angular.forEach(contents, function(entry) {
            if (entry.filepath !== '/') {
                // It's a file in a subfolder. Lets treat the path to add the subfolders to the array.
                var directories,
                    currentList = folders, // Start at root level.
                    path = entry.filepath,
                    subpath = '';

                // Remove first and last slash if needed.
                if (path.substr(0, 1) === '/') {
                    path = path.substr(1);
                }
                if (path.substr(path.length - 1) === '/') {
                    path = path.slice(0, -1);
                }

                directories = path.split('/');

                angular.forEach(directories, function(directory) {
                    subpath = subpath + '/' + directory;
                    // Search if the directory is already stored in folders array.
                    var found = false;
                    for (var i = 0; i < currentList.length; i++) {
                        if (currentList[i].name === directory) {
                            currentList = currentList[i].contents;
                            found = true;
                            break;
                        }
                    }
                    // Directory not found. Add it to the array.
                    if (!found) {
                        var newFolder = {
                            name: directory,
                            fileicon: foldericon,
                            contents: [],
                            filepath: subpath,
                            type: 'folder'
                        };
                        currentList.push(newFolder);
                        currentList = newFolder.contents;
                    }
                });

                currentList.push(entry);
            } else {
                files.push(entry);
            }
        });

        return folders.concat(files);
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Report a folder as being viewed.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                folderid: id
            };
            return $mmSite.write('mod_folder_view_folder', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#prefetchContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModFolderComponent, module.id, revision, timemod);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Mod Folder handlers.
 *
 * @module mm.addons.mod_folder
 * @ngdoc service
 * @name $mmaModFolderHandlers
 */
.factory('$mmaModFolderHandlers', ["$mmCourse", "$mmaModFolder", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModFolderComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModFolder, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModFolderComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @module mm.addons.mod_folder
         * @ngdoc method
         * @name $mmaModFolderCourseContentHandler#isEnabled
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Get the controller.
         *
         * @module mm.addons.mod_folder
         * @ngdoc method
         * @name $mmaModFolderCourseContentHandler#getController
         * @param {Object} module    The module info.
         * @param {Number} courseid  Course ID.
         * @param {Number} sectionid Section ID.
         * @return {Function}
         */
        self.getController = function(module, courseid, sectionid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                // Prefetch folder contents.
                function prefetchFolder(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    $mmaModFolder.prefetchContent(module).catch(function() {
                        if (!$scope.$$destroyed) {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: prefetchFolder
                };

                refreshBtn = {
                    hidden: true,
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    action: prefetchFolder
                };

                $scope.icon = $mmCourse.getModuleIconSrc('folder');
                $scope.title = module.name;
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_folder', {module: module, courseid: courseid, sectionid: sectionid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModFolderComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            if (courseId) {
                return $q.when(true);
            }
            return $mmCourse.canGetModuleWithoutCourseId(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a folder URL.
            if (url.indexOf('/mod/folder/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Mod folder prefetch handler.
 *
 * @module mm.addons.mod_folder
 * @ngdoc service
 * @name $mmaModFolderPrefetchHandler
 */
.factory('$mmaModFolderPrefetchHandler', ["$mmaModFolder", "$mmSite", "mmaModFolderComponent", function($mmaModFolder, $mmSite, mmaModFolderComponent) {

    var self = {};

    self.component = mmaModFolderComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderPrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModFolder.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return true;
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderPrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModFolder.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Glossary entry controller.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc controller
 * @name mmaModGlossaryEntryCtrl
 */
.controller('mmaModGlossaryEntryCtrl', ["$scope", "$stateParams", "$mmaModGlossary", "$translate", "mmUserProfileState", function($scope, $stateParams, $mmaModGlossary, $translate,
        mmUserProfileState) {
    var entry = $stateParams.entry || {},
        courseid = $stateParams.cid || 0,
        glossary;

    // This is a coding error, for now the course ID is required here as we need it for the author link.
    if (!courseid) {
        notifyErrorOccured();
        return;
    }

    $scope.refreshEntry = function() {
        refreshEntry().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Load the glossary first.
    $mmaModGlossary.getGlossaryById(courseid, entry.glossaryid).then(function(gloss) {
        glossary = gloss;
        var displayFormat = glossary.displayformat;

        $scope.title = entry.concept;
        $scope.entry = entry;
        $scope.courseid = courseid;
        $scope.userStateName = mmUserProfileState;

        if (displayFormat == 'fullwithauthor' || displayFormat == 'encyclopedia') {
            $scope.showAuthor = true;
            $scope.showDate = true;

        } else if (displayFormat == 'fullwithoutauthor') {
            $scope.showAuthor = false;
            $scope.showDate = true;

        // Default, and faq, simple, entrylist, continuous.
        } else {
            $scope.showAuthor = false;
            $scope.showDate = false;
        }

        $scope.loaded = true;

        // Log that the entry was viewed.
        $mmaModGlossary.logEntryView(entry.id);

    }).catch(function() {
        notifyErrorOccured();
    });

    function fetchEntry() {
        return $mmaModGlossary.getEntry(entry.id).then(function(result) {
            $scope.entry = result.entry;
            $scope.title = result.entry.concept;
        });
    }

    function refreshEntry() {
        return $mmaModGlossary.invalidateEntry(entry.id).then(function() {
            return fetchEntry();
        });
    }

    function notifyErrorOccured() {
        $scope.title = $translate.instant('mm.core.error');
        $scope.entry = false;
        $scope.loaded = true;
    }

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Glossary index controller.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc controller
 * @name mmaModGlossaryIndexCtrl
 */
.controller('mmaModGlossaryIndexCtrl', ["$q", "$scope", "$stateParams", "$ionicPopover", "$mmUtil", "$mmaModGlossary", "$ionicScrollDelegate", function($q, $scope, $stateParams, $ionicPopover, $mmUtil, $mmaModGlossary,
        $ionicScrollDelegate) {

    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        glossary,
        noop = function(){},
        limitFrom = 0,
        limitNum = 25,
        popover,
        viewMode,   // The archetype of view (letter, date, author, cat).
        fetchMode = 'letter_all',       // Default.
        fetchFunction,
        fetchInvalidate,
        fetchArguments,
        popoverScope = $scope.$new(true),
        browseModes = [
            {
                key: 'letter_all',
                langkey: 'mma.mod_glossary.byalphabet'
            },
            {
                key: 'search',
                langkey: 'mma.mod_glossary.bysearch'
            }
        ];

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.externalUrl = module.url;
    $scope.courseid = courseId;
    $scope.loaded = false;
    $scope.entries = [];
    $scope.getDivider = noop;
    $scope.showDivider = noop;
    $scope.canLoadMore = false;
    $scope.searchData = {
        searchQuery: ''
    };

    $scope.loadMoreEntries = function() {
        loadMoreEntries().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
    $scope.refreshEntries = function() {
        refreshEntries().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.pickMode = function(e) {
        popoverScope.data.selectedMode = fetchMode;
        popover.show(e);
    };

    $scope.search = function(query) {
        fetchArguments = [glossary.id, query, 1, 'CONCEPT', 'ASC'];
        fetchEntries();
    };

    $scope.trackBy = function(entry) {
        return fetchMode + ':' + entry.id;
    };

    // Controller run.
    $mmaModGlossary.getGlossary(courseId, module.id).then(function(mod) {
        glossary = mod;

        // Preparing browse modes.
        if (glossary.browsemodes.indexOf('date') >= 0) {
            browseModes.push({key: 'newest_first', langkey: 'mma.mod_glossary.bynewestfirst'});
            browseModes.push({key: 'recently_updated', langkey: 'mma.mod_glossary.byrecentlyupdated'});
        }
        if (glossary.browsemodes.indexOf('author') >= 0) {
            browseModes.push({key: 'author_all', langkey: 'mma.mod_glossary.byauthor'});
        }

        // Preparing the popover.
        popoverScope.modes = browseModes;
        popoverScope.modePicked = function(mode) {
            $ionicScrollDelegate.$getByHandle('mmaModGlossaryIndex').scrollTop(false);
            if (switchMode(mode)) {
                $scope.loaded = false;
                fetchEntries().finally(function() {
                    $scope.loaded = true;
                });
            } else {
                // If it's not an instant search, then we reset the values.
                $scope.loaded = true;
                $scope.entries = [];
                $scope.canLoadMore = false;
                $scope.showNoEntries = false;
            }
            popover.hide();
        };
        popoverScope.data = { selectedMode: '' };
        $ionicPopover.fromTemplateUrl('addons/mod_glossary/templates/mode_picker.html', {
            scope: popoverScope
        }).then(function(po) {
            popover = po;
        });
        $scope.$on('$destroy', function() {
            popover.remove();
            popoverScope.$destroy();
        });

        // Preparing the initial mode.
        switchMode();

        // Do not return the promise here, the error modal is already handled.
        fetchEntries().then(function() {
            // After a successful fetch, the glossary can be considered as 'viewed'.
            $mmaModGlossary.logView(glossary.id, viewMode);
        }).finally(function() {
            $scope.loaded = true;
        });
    }).catch(function() {
        $mmUtil.showErrorModal('mma.mod_glossary.errorloadingglossary', true);
        $scope.loaded = true;
    });

    // Controller library.
    function fetchEntries(append) {
        if (!append) {
            limitFrom = 0;
        }
        var args = angular.extend([], fetchArguments);
        args.push(limitFrom);
        args.push(limitNum);

        return fetchFunction.apply(this, args).then(function(result) {
            if (append) {
                $scope.entries = $scope.entries.concat(result.entries);
            } else {
                $scope.entries = result.entries;
            }
            $scope.canLoadMore = (limitFrom + limitNum) < result.count;
            $scope.showNoEntries = result.count <= 0;
        }).catch(function() {
            $mmUtil.showErrorModal('mma.mod_glossary.errorloadingentries', true);
            return $q.reject();
        });
    }

    function refreshEntries() {
        if (fetchMode == 'search' && !$scope.searchQuery) {
            // Ignore search mode that is not set yet.
            return $q.when();
        }
        var args = angular.extend([], fetchArguments);
        return fetchInvalidate.apply(this, args).then(function() {
            limitFrom = 0;
            return fetchEntries();
        });
    }

    function loadMoreEntries() {
        limitFrom += limitNum;
        return fetchEntries(true);
    }

    function switchMode(mode) {
        if (mode == fetchMode) {
            return false;
        }

        var instantFetch = true;
        fetchMode = mode;
        $scope.isSearch = false;

        // Browse by author.
        if (mode == 'author_all') {
            viewMode = 'author';
            fetchFunction = $mmaModGlossary.getEntriesByAuthor;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByAuthor;
            fetchArguments = [glossary.id, 'ALL', 'LASTNAME', 'ASC'];
            $scope.getDivider = function(entry) {
                return entry.userfullname;
            };
            $scope.showDivider = function(entry, previous) {
                if (typeof previous === 'undefined') {
                    return true;
                }
                return entry.userid != previous.userid;
            };

        // Newest first.
        } else if (mode == 'newest_first') {
            viewMode = 'date';
            fetchFunction = $mmaModGlossary.getEntriesByDate;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByDate;
            fetchArguments = [glossary.id, 'CREATION', 'DESC'];
            $scope.getDivider = noop;
            $scope.showDivider = function() { return false; };

        // Recently updated.
        } else if (mode == 'recently_updated') {
            viewMode = 'date';
            fetchFunction = $mmaModGlossary.getEntriesByDate;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByDate;
            fetchArguments = [glossary.id, 'UPDATE', 'DESC'];
            $scope.getDivider = noop;
            $scope.showDivider = function() { return false; };

        // Search for entries.
        } else if (mode == 'search') {
            viewMode = 'search';
            fetchFunction = $mmaModGlossary.getEntriesBySearch;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesBySearch;
            fetchArguments = false; // Dynamically set later.
            $scope.isSearch = true;
            $scope.getDivider = noop;
            $scope.showDivider = function() { return false; };
            instantFetch = false;

        // Consider it is 'letter_all'.
        } else {
            viewMode = 'letter';
            fetchMode = 'letter_all';
            fetchFunction = $mmaModGlossary.getEntriesByLetter;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByLetter;
            fetchArguments = [glossary.id, 'ALL'];
            $scope.getDivider = function(entry) {
                return entry.concept.substr(0, 1).toUpperCase();
            };
            $scope.showDivider = function(entry, previous) {
                if (typeof previous === 'undefined') {
                    return true;
                }
                return $scope.getDivider(entry) != $scope.getDivider(previous);
            };
        }

        return instantFetch;
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Glossary service.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc service
 * @name $mmaModGlossary
 */
.factory('$mmaModGlossary', ["$mmSite", "$q", "$mmSitesManager", function($mmSite, $q, $mmSitesManager) {
    var self = {};

    /**
     * Get the course glossary cache key.
     *
     * @param  {Number} courseId
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getCourseGlossariesCacheKey
     */
    self._getCourseGlossariesCacheKey = function(courseId) {
        return 'mmaModGlossary:courseGlossaries:' + courseId;
    };

    /**
     * Get all the glossaries in a course.
     *
     * @param  {Number} courseId
     * @return {Promise} resolved with the glossaries
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getCourseGlossaries
     */
    self.getCourseGlossaries = function(courseId) {
        var params = {
                courseids: [courseId]
            },
            preSets = {
                cacheKey: self._getCourseGlossariesCacheKey(courseId)
            };
        return $mmSite.read('mod_glossary_get_glossaries_by_courses', params, preSets).then(function(result) {
            return result.glossaries;
        });
    };

    /**
     * Get the course glossary cache key.
     *
     * @param  {Number} courseId
     * @return {Promise}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateCourseGlossaries
     */
    self.invalidateCourseGlossaries = function(courseId) {
        var key = self._getCourseGlossariesCacheKey(courseId);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by author cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @param  {String} sort
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesByAuthorCacheKey
     */
    self._getEntriesByAuthorCacheKey = function(glossaryId, letter, field, sort) {
        return 'mmaModGlossary:entriesByAuthor:' + glossaryId + ":" + letter + ":" + field + ":" + sort;
    };

    /**
     * Get entries by author.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @param  {String} sort
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesByAuthor
     */
    self.getEntriesByAuthor = function(glossaryId, letter, field, sort, from, limit) {
        var params = {
                id: glossaryId,
                letter: letter,
                field: field,
                sort: sort,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesByAuthorCacheKey(glossaryId, letter, field, sort)
            };

        return $mmSite.read('mod_glossary_get_entries_by_author', params, preSets);
    };

    /**
     * Invalidate cache of entries by author.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @param  {String} sort
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesByAuthor
     */
    self.invalidateEntriesByAuthor = function(glossaryId, letter, field, sort) {
        var key = self._getEntriesByAuthorCacheKey(glossaryId, letter, field, sort);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by date cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} order
     * @param  {String} sort
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesByDateCacheKey
     */
    self._getEntriesByDateCacheKey = function(glossaryId, order, sort) {
        return 'mmaModGlossary:entriesByDate:' + glossaryId + ":" + order + ":" + sort;
    };

    /**
     * Get entries by date.
     *
     * @param  {Number} glossaryId
     * @param  {String} order
     * @param  {String} sort
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesByDate
     */
    self.getEntriesByDate = function(glossaryId, order, sort, from, limit) {
        var params = {
                id: glossaryId,
                order: order,
                sort: sort,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesByDateCacheKey(glossaryId, order, sort)
            };

        return $mmSite.read('mod_glossary_get_entries_by_date', params, preSets);
    };

    /**
     * Invalidate cache of entries by date.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesByDate
     */
    self.invalidateEntriesByDate = function(glossaryId, order, sort) {
        var key = self._getEntriesByDateCacheKey(glossaryId, order, sort);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by letter cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesByLetterCacheKey
     */
    self._getEntriesByLetterCacheKey = function(glossaryId, letter) {
        return 'mmaModGlossary:entriesByLetter:' + glossaryId + ":" + letter;
    };

    /**
     * Get entries by letter.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesByLetter
     */
    self.getEntriesByLetter = function(glossaryId, letter, from, limit) {
        var params = {
                id: glossaryId,
                letter: letter,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesByLetterCacheKey(glossaryId, letter)
            };

        return $mmSite.read('mod_glossary_get_entries_by_letter', params, preSets);
    };

    /**
     * Invalidate cache of entries by letter.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesByLetter
     */
    self.invalidateEntriesByLetter = function(glossaryId, letter) {
        var key = self._getEntriesByLetterCacheKey(glossaryId, letter);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by search cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} query
     * @param  {Boolean} fullsearch
     * @param  {String} order
     * @param  {String} sort
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesBySearchCacheKey
     */
    self._getEntriesBySearchCacheKey = function(glossaryId, query, fullsearch, order, sort) {
        return 'mmaModGlossary:entriesBySearch:' + glossaryId + ":" + fullsearch + ":" + order + ":" + sort + ":" + query;
    };

    /**
     * Get entries by search.
     *
     * @param  {Number} glossaryId
     * @param  {String} query
     * @param  {Boolean} fullsearch
     * @param  {String} order
     * @param  {String} sort
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesBySearch
     */
    self.getEntriesBySearch = function(glossaryId, query, fullsearch, order, sort, from, limit) {
        var params = {
                id: glossaryId,
                query: query,
                fullsearch: fullsearch,
                order: order,
                sort: sort,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesBySearchCacheKey(glossaryId, query, fullsearch, order, sort)
            };

        return $mmSite.read('mod_glossary_get_entries_by_search', params, preSets);
    };

    /**
     * Invalidate cache of entries by search.
     *
     * @param  {Number} glossaryId
     * @param  {String} query
     * @param  {Boolean} fullsearch
     * @param  {String} order
     * @param  {String} sort
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesBySearch
     */
    self.invalidateEntriesBySearch = function(glossaryId, query, fullsearch, order, sort) {
        var key = self._getEntriesBySearchCacheKey(glossaryId, query, fullsearch, order, sort);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get an entry by ID cache key.
     *
     * @param  {Number} id
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntryCacheKey
     */
    self._getEntryCacheKey = function(id) {
        return 'mmaModGlossary:getEntry:' + id;
    };

    /**
     * Get one entry by ID.
     *
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntry
     * @param  {Number} id       Entry ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the entry.
     */
    self.getEntry = function(id, siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    id: id
                },
                preSets = {
                    cacheKey: self._getEntryCacheKey(id)
                };

            return site.read('mod_glossary_get_entry_by_id', params, preSets);
        });
    };

    /**
     * Invalidate cache of entry by ID.
     *
     * @param  {Number} id
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntry
     */
    self.invalidateEntry = function(id) {
        var key = self._getEntryCacheKey(id);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get one glossary by cmID.
     *
     * @param  {Number} courseId
     * @param  {Number} cmid
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getGlossary
     */
    self.getGlossary = function(courseId, cmid) {
        return self.getCourseGlossaries(courseId).then(function(glossaries) {
            var result = $q.reject();
            angular.forEach(glossaries, function(glossary) {
                if (glossary.coursemodule == cmid) {
                    result = glossary;
                }
            });
            return result;
        });
    };

    /**
     * Get one glossary by glossary ID.
     *
     * @param  {Number} courseId
     * @param  {Number} id
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getGlossaryById
     */
    self.getGlossaryById = function(courseId, id) {
        return self.getCourseGlossaries(courseId).then(function(glossaries) {
            var result = $q.reject();
            angular.forEach(glossaries, function(glossary) {
                if (glossary.id == id) {
                    result = glossary;
                }
            });
            return result;
        });
    };

    /**
     * Check if glossary plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossary#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            // This function was introduced along with all the other required ones.
            return site.wsAvailable('mod_glossary_get_glossaries_by_courses');
        });
    };

    /**
     * Report a glossary as being viewed.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossary#logView
     * @param {Number} id Glossary ID.
     * @param {String} mode The mode in which the glossary was viewed.
     * @return {Promise} Promise resolved when the WS call is successful.
     */
    self.logView = function(id, mode) {
        var params = {
            id: id,
            mode: mode
        };
        return $mmSite.write('mod_glossary_view_glossary', params);
    };

    /**
     * Report a glossary entry as being viewed.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossary#logEntryView
     * @param {Number} id Entry ID.
     * @return {Promise} Promise resolved when the WS call is successful.
     */
    self.logEntryView = function(id) {
        var params = {
            id: id
        };
        return $mmSite.write('mod_glossary_view_entry', params);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Mod glossary handlers.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc service
 * @name $mmaModGlossaryHandlers
 */
.factory('$mmaModGlossaryHandlers', ["$mmCourse", "$mmaModGlossary", "$state", "$q", "$mmContentLinksHelper", "$mmUtil", "$mmCourseHelper", function($mmCourse, $mmaModGlossary, $state, $q, $mmContentLinksHelper, $mmUtil,
            $mmCourseHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossaryHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModGlossary.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.icon = $mmCourse.getModuleIconSrc('glossary');
                $scope.title = module.name;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_glossary', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossaryHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled to see glossary index for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isIndexEnabled(siteId, courseId) {
            return $mmaModGlossary.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Whether or not the handler is enabled to see glossary entry for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEntryEnabled(siteId, courseId) {
            return $mmaModGlossary.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleByInstance(siteId);
            });
        }

        function getEntry(entryId, siteId) {
            return $mmaModGlossary.getEntry(entryId, siteId).then(function(result) {
                return result.entry;
            }).catch(function(error) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $mmUtil.showErrorModal('mma.mod_glossary.errorloadingentry', true);
                }
                return $q.reject();
            });
        }

        /**
         * Treat a glossary entry link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         */
        function treatEntryLink(siteIds, url, courseId) {
            var params = $mmUtil.extractUrlParams(url);
            if (params.eid != 'undefined') {
                // Pass false because all sites should have the same siteurl.
                return $mmContentLinksHelper.filterSupportedSites(siteIds, isEntryEnabled, false, courseId).then(function(ids) {
                    if (!ids.length) {
                        return [];
                    }

                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: ids,
                        action: function(siteId) {
                            var modal = $mmUtil.showModalLoading();
                            return getEntry(parseInt(params.eid, 10), siteId).then(function(entry) {
                                var promise;
                                if (courseId) {
                                    promise = $q.when(courseId);
                                } else {
                                    promise = $mmCourseHelper.getModuleCourseIdByInstance(entry.glossaryid, 'glossary', siteId);
                                }
                                return promise.then(function(courseId) {
                                    var stateParams = {
                                        entry: entry,
                                        cid: courseId
                                    };
                                    $mmContentLinksHelper.goInSite('site.mod_glossary-entry', stateParams, siteId);
                                });
                            }).finally(function() {
                                modal.dismiss();
                            });
                        }
                    }];
                });
            }
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a glossary URL.
            if (url.indexOf('/mod/glossary/view.php') > -1) {
                // Glossary index.
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isIndexEnabled, courseId);
            } else if (url.indexOf('/mod/glossary/showentry.php') > -1) {
                // Glossary entry.
                return treatEntryLink(siteIds, url, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Forum discussion controller.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name mmaModForumDiscussionCtrl
 */
.controller('mmaModForumDiscussionCtrl', ["$q", "$scope", "$stateParams", "$mmaModForum", "$mmSite", "$mmUtil", "$translate", "$ionicScrollDelegate", "mmaModForumComponent", function($q, $scope, $stateParams, $mmaModForum, $mmSite, $mmUtil, $translate,
            $ionicScrollDelegate, mmaModForumComponent) {

    var discussionid = $stateParams.discussionid,
        courseid = $stateParams.cid,
        scrollView;

    $scope.component = mmaModForumComponent;
    $scope.courseid = courseid;
    $scope.newpost = {
        replyingto: undefined,
        subject: '',
        message: ''
    };

    // Convenience function to get forum discussions.
    function fetchPosts() {
        return $mmaModForum.getDiscussionPosts(discussionid).then(function(posts) {
            $scope.discussion = $mmaModForum.extractStartingPost(posts);
            $scope.posts = posts;

            // Set default reply subject.
            return $translate('mma.mod_forum.re').then(function(strReplyPrefix) {
                $scope.defaultSubject = strReplyPrefix + ' ' + $scope.discussion.subject;
                $scope.newpost.subject = $scope.defaultSubject;
            });
        }, function(message) {
            $mmUtil.showErrorModal(message);
            return $q.reject();
        });
    }

    // Refresh posts.
    function refreshPosts() {
        return $mmaModForum.invalidateDiscussionPosts(discussionid).finally(function() {
            return fetchPosts();
        });
    }

    fetchPosts().then(function() {
        // Add log in Moodle.
        $mmSite.write('mod_forum_view_forum_discussion', {
            discussionid: discussionid
        });
    }).finally(function() {
        $scope.discussionLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshPosts = function() {
        refreshPosts().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // New post added.
    $scope.newPostAdded = function() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmaModForumPostsScroll');
        }
        scrollView && scrollView.scrollTop && scrollView.scrollTop();

        $scope.newpost.replyingto = undefined;
        $scope.newpost.subject = $scope.defaultSubject;
        $scope.newpost.message = '';

        $scope.discussionLoaded = false;
        refreshPosts().finally(function() {
            $scope.discussionLoaded = true;
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Forum discussion list controller.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name mmaModForumDiscussionsCtrl
 */
.controller('mmaModForumDiscussionsCtrl', ["$q", "$scope", "$stateParams", "$mmaModForum", "$mmCourse", "$mmUtil", "$mmGroups", "$mmEvents", "$ionicScrollDelegate", "$ionicPlatform", "mmUserProfileState", "mmaModForumNewDiscussionEvent", function($q, $scope, $stateParams, $mmaModForum, $mmCourse, $mmUtil, $mmGroups,
            $mmEvents, $ionicScrollDelegate, $ionicPlatform, mmUserProfileState, mmaModForumNewDiscussionEvent) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        forum,
        page = 0,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaModForumDiscussionsScroll'),
        shouldScrollTop = false,
        usesGroups = false;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;
    $scope.userStateName = mmUserProfileState;
    $scope.isCreateEnabled = $mmaModForum.isCreateDiscussionEnabled();

    // Convenience function to get forum data and discussions.
    function fetchForumDataAndDiscussions(refresh) {
        return $mmaModForum.getForum(courseid, module.id).then(function(forumdata) {
            forum = forumdata;

            $scope.title = forum.name || $scope.title;
            $scope.description = forum.intro || $scope.description;
            $scope.forum = forum;

            return $mmGroups.getActivityGroupMode(forum.cmid).then(function(mode) {
                usesGroups = mode === $mmGroups.SEPARATEGROUPS || mode === $mmGroups.VISIBLEGROUPS;
            }).finally(function() {
                return fetchDiscussions(refresh);
            });
        }, function(message) {
            if (!refresh) {
                // Get forum failed, retry without using cache since it might be a new activity.
                return refreshData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_forum.errorgetforum', true);
            }
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
            return $q.reject();
        });
    }

    // Convenience function to get forum discussions.
    function fetchDiscussions(refresh) {
        if (refresh) {
            page = 0;
        }

        return $mmaModForum.getDiscussions(forum.id, page).then(function(response) {
            var promise = usesGroups ?
                    $mmaModForum.formatDiscussionsGroups(forum.cmid, response.discussions) : $q.when(response.discussions);
            return promise.then(function(discussions) {
                if (page == 0) {
                    $scope.discussions = discussions;
                } else {
                    $scope.discussions = $scope.discussions.concat(discussions);
                }

                $scope.count = $scope.discussions.length;
                $scope.canLoadMore = response.canLoadMore;
                page++;

                preFetchDiscussionsPosts(discussions);
            });
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
            return $q.reject();
        });
    }

    // Convenience function to prefetch the posts of each discussion, so they're available in offline mode.
    function preFetchDiscussionsPosts(discussions) {
        angular.forEach(discussions, function(discussion) {
            var discussionid = discussion.discussion;
            $mmaModForum.getDiscussionPosts(discussionid);
        });
    }

    // Refresh forum data and discussions list.
    function refreshData() {
        var promises = [];
        promises.push($mmaModForum.invalidateForumData(courseid));
        if (forum) {
            promises.push($mmaModForum.invalidateDiscussionsList(forum.id));
            promises.push($mmGroups.invalidateActivityGroupMode(forum.cmid));
        }
        return $q.all(promises).finally(function() {
            return fetchForumDataAndDiscussions(true);
        });
    }

    fetchForumDataAndDiscussions().then(function() {
        $mmaModForum.logView(forum.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.discussionsLoaded = true;
    });

    // Load more discussions.
    $scope.loadMoreDiscussions = function() {
        fetchDiscussions().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };

    // Pull to refresh.
    $scope.refreshDiscussions = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Listen for discussions added. When a discussion is added, we reload the data.
    var obsNewDisc = $mmEvents.on(mmaModForumNewDiscussionEvent, function(data) {
        if ((forum && forum.id === data.forumid) || data.cmid === module.id) {
            if ($ionicPlatform.isTablet()) {
                scrollView.scrollTop();
            } else {
                // We can't scroll top inmediately because the scroll is not seen.
                shouldScrollTop = true;
            }
            $scope.discussionsLoaded = false;
            refreshData().finally(function() {
                $scope.discussionsLoaded = true;
            });
        }
    });

    // Scroll top if needed.
    $scope.$on('$ionicView.enter', function() {
        if (shouldScrollTop) {
            shouldScrollTop = false;
            scrollView.scrollTop();
        }
    });

    $scope.$on('$destroy', function(){
        if (obsNewDisc && obsNewDisc.off) {
            obsNewDisc.off();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Add new discussion controller.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name mmaModForumNewDiscussionCtrl
 */
.controller('mmaModForumNewDiscussionCtrl', ["$scope", "$stateParams", "$mmGroups", "$q", "$mmaModForum", "$mmEvents", "$ionicPlatform", "$mmUtil", "$ionicHistory", "$translate", "mmaModForumNewDiscussionEvent", function($scope, $stateParams, $mmGroups, $q, $mmaModForum, $mmEvents, $ionicPlatform,
            $mmUtil, $ionicHistory, $translate, mmaModForumNewDiscussionEvent) {

    var courseid = $stateParams.cid,
        forumid = $stateParams.forumid,
        cmid = $stateParams.cmid;

    $scope.newdiscussion = {
        subject: '',
        message: '',
        subscribe: true
    };

    // Fetch if forum uses groups and the groups it uses.
    function fetchGroups(refresh) {
        return $mmGroups.getActivityGroupMode(cmid).then(function(mode) {
            if (mode === $mmGroups.SEPARATEGROUPS || mode === $mmGroups.VISIBLEGROUPS) {
                return $mmGroups.getActivityAllowedGroups(cmid).then(function(forumgroups) {
                    var promise;
                    if (mode === $mmGroups.VISIBLEGROUPS) {
                        // We need to check which of the returned groups the user can post to.
                        promise = validateVisibleGroups(forumgroups, refresh);
                    } else {
                        // WS already filters groups, no need to do it ourselves.
                        promise = $q.when(forumgroups);
                    }

                    return promise.then(function(forumgroups) {
                        if (forumgroups.length > 0) {
                            $scope.groups = forumgroups;
                            $scope.newdiscussion.groupid = forumgroups[0].id;
                            $scope.showGroups = true;
                            $scope.showForm = true;
                        } else {
                            var message = mode === $mmGroups.SEPARATEGROUPS ?
                                                'mma.mod_forum.cannotadddiscussionall' : 'mma.mod_forum.cannotadddiscussion';
                            return $q.reject($translate.instant(message));
                        }
                    });
                });
            } else {
                $scope.showGroups = false;
                $scope.showForm = true;
            }
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_forum.errorgetgroups', true);
            }
            $scope.showForm = false;
            return $q.reject();
        });
    }

    // Validate which of the groups returned by getActivityAllowedGroups in visible groups should be shown to post to.
    function validateVisibleGroups(forumgroups, refresh) {
        if ($mmaModForum.isCanAddDiscussionAvailable()) {
            // Use the canAddDiscussion function to filter the groups.
            // We first check if the user can post to all the groups.
            return $mmaModForum.canAddDiscussionToAll(forumid).catch(function() {
                // The call failed, let's assume he can't.
                return false;
            }).then(function(canAdd) {
                if (canAdd) {
                    // The user can post to all groups, return them all.
                    return forumgroups;
                } else {
                    // The user can't post to all groups, let's check which groups he can post to.
                    var promises = [],
                        filtered = [];

                    angular.forEach(forumgroups, function(group) {
                        promises.push($mmaModForum.canAddDiscussion(forumid, group.id).catch(function() {
                            // The call failed, let's return true so the group is shown. If the user can't post to
                            // it an error will be shown when he tries to add the discussion.
                            return true;
                        }).then(function(canAdd) {
                            if (canAdd) {
                                filtered.push(group);
                            }
                        }));
                    });

                    return $q.all(promises).then(function() {
                        return filtered;
                    });
                }
            });
        } else {
            // We can't check it using WS. We'll get the groups the user belongs to and use them to
            // filter the groups to post.
            return $mmGroups.getUserGroupsInCourse(courseid, refresh).then(function(usergroups) {
                if (usergroups.length === 0) {
                    // User doesn't belong to any group, probably a teacher. Let's return all groups,
                    // if the user can't post to some of them it will be filtered by add discussion WS.
                    return forumgroups;
                }
                return filterGroups(forumgroups, usergroups);
            });
        }
    }

    // Filter forumgroups, returning only those that are inside usergroups.
    function filterGroups(forumgroups, usergroups) {
        var filtered = [],
            usergroupsids = usergroups.map(function(g) {
                return g.id;
            });

        angular.forEach(forumgroups, function(fg) {
            if (usergroupsids.indexOf(fg.id) > -1) {
                filtered.push(fg);
            }
        });

        return filtered;
    }

    fetchGroups().finally(function() {
        $scope.groupsLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshGroups = function() {
        var p1 = $mmGroups.invalidateActivityGroupMode(cmid),
            p2 = $mmGroups.invalidateActivityAllowedGroups(cmid),
            p3 = $mmaModForum.invalidateCanAddDiscussion(forumid);

        $q.all([p1, p2]).finally(function() {
            fetchGroups(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    // Add a new discussion.
    $scope.add = function() {
        var subject = $scope.newdiscussion.subject,
            message = $scope.newdiscussion.message,
            subscribe = $scope.newdiscussion.subscribe,
            groupid = $scope.newdiscussion.groupid;

        if (!subject) {
            $mmUtil.showErrorModal('mma.mod_forum.erroremptysubject', true);
            return;
        }
        if (!message) {
            $mmUtil.showErrorModal('mma.mod_forum.erroremptymessage', true);
            return;
        }
        message = '<p>' + message + '<p>';

        $mmaModForum.addNewDiscussion(forumid, subject, message, subscribe, groupid).then(function(discussionid) {
            var data = {
                forumid: forumid,
                discussionid: discussionid,
                cmid: cmid
            };
            $mmEvents.trigger(mmaModForumNewDiscussionEvent, data);

            if ($ionicPlatform.isTablet()) {
                // Empty form.
                $scope.newdiscussion.subject = '';
                $scope.newdiscussion.message = '';
            } else {
                // Go back to discussions list.
                $ionicHistory.goBack();
            }
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_forum.cannotcreatediscussion', true);
            }
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Directive to show a discussion post, its attachments and the action buttons allowed (reply, etc.).
 *
 * @module mm.addons.mod_forum
 * @ngdoc directive
 * @name mmaForumDiscussionPost
 * @description
 * This directive will show a forum post if the right data is supplied. Attributes:
 *
 * @param {Object} post             Post.
 * @param {Number} courseid         Post's course ID.
 * @param {String} title            Post's title.
 * @param {String} subject          Post's subject.
 * @param {String} component        Component this post belong to.
 * @param {Object} newpost          Object with the new post data. Usually shared between posts.
 * @param {Boolean} showdivider     True if it should have a list divider before the post.
 * @param {Boolean} titleimportant  True if title should be "important" (bold).
 * @oaram {Function} [postadded]    Function to call when a new post is added.
 * @param {String} [defaultsubject] Default subject to set to new posts.
 */
.directive('mmaModForumDiscussionPost', ["$mmaModForum", "$mmUtil", "$translate", "$q", function($mmaModForum, $mmUtil, $translate, $q) {
    return {
        restrict: 'E',
        scope: {
            post: '=',
            courseid: '=',
            title: '=',
            subject: '=',
            component: '=',
            newpost: '=',
            showdivider: '=?',
            titleimportant: '=?',
            postadded: '&?',
            defaultsubject: '=?'
        },
        templateUrl: 'addons/mod_forum/templates/discussionpost.html',
        transclude: true,
        link: function(scope) {
            scope.isReplyEnabled = $mmaModForum.isReplyPostEnabled();

            // Set this post as being replied to.
            scope.showReply = function() {
                scope.newpost.replyingto = scope.post.id;
            };

            // Reply to this post.
            scope.reply = function() {
                if (!scope.newpost.subject) {
                    $mmUtil.showErrorModal('mma.mod_forum.erroremptysubject', true);
                    return;
                }
                if (!scope.newpost.message) {
                    $mmUtil.showErrorModal('mma.mod_forum.erroremptymessage', true);
                    return;
                }

                var message = '<p>' + scope.newpost.message.replace(/\n/g, '<br>') + '</p>',
                    modal = $mmUtil.showModalLoading('mm.core.sending', true);

                $mmaModForum.replyPost(scope.newpost.replyingto, scope.newpost.subject, message).then(function() {
                    if (scope.postadded) {
                        scope.postadded();
                    }
                }).catch(function(message) {
                    if (message) {
                        $mmUtil.showErrorModal(message);
                    } else {
                        $mmUtil.showErrorModal('mma.mod_forum.couldnotadd', true);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            };

            // Cancel reply.
            scope.cancel = function() {
                var promise;
                if (!scope.newpost.subject && !scope.newpost.message) {
                    promise = $q.when(); // Nothing written, cancel right away.
                } else {
                    promise = $mmUtil.showConfirm($translate('mm.core.areyousure'));
                }

                promise.then(function() {
                    scope.newpost.replyingto = undefined;
                    scope.newpost.subject = scope.defaultsubject || '';
                    scope.newpost.message = '';
                });
            };
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Forum service.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name $mmaModForum
 */
.factory('$mmaModForum', ["$q", "$mmSite", "$mmUser", "$mmGroups", "$translate", "$mmSitesManager", "mmaModForumDiscPerPage", function($q, $mmSite, $mmUser, $mmGroups, $translate, $mmSitesManager, mmaModForumDiscPerPage) {
    var self = {};

    /**
     * Get cache key for can add discussion WS calls.
     *
     * @param  {Number} forumid Forum ID.
     * @param  {Number} groupid Group ID.
     * @return {String}         Cache key.
     */
    function getCanAddDiscussionCacheKey(forumid, groupid) {
        return getCommonCanAddDiscussionCacheKey(forumid) + ':' + groupid;
    }

    /**
     * Get common part of cache key for can add discussion WS calls.
     *
     * @param  {Number} forumid Forum ID.
     * @return {String}         Cache key.
     */
    function getCommonCanAddDiscussionCacheKey(forumid) {
        return 'mmaModForum:canadddiscussion:' + forumid;
    }

    /**
     * Get cache key for forum data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getForumDataCacheKey(courseid) {
        return 'mmaModForum:forum:' + courseid;
    }

    /**
     * Get cache key for forum discussion posts WS calls.
     *
     * @param  {Number} discussionid Discussion ID.
     * @return {String}              Cache key.
     */
    function getDiscussionPostsCacheKey(discussionid) {
        return 'mmaModForum:discussion:' + discussionid;
    }

    /**
     * Get cache key for forum discussions list WS calls.
     *
     * @param  {Number} forumid Forum ID.
     * @return {String}         Cache key.
     */
    function getDiscussionsListCacheKey(forumid) {
        return 'mmaModForum:discussions:' + forumid;
    }

    /**
     * Add a new discussion.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#addNewDiscussion
     * @param {Number} forumid   Forum ID.
     * @param {String} subject   New discussion's subject.
     * @param {String} message   New discussion's message.
     * @param {String} subscribe True if should subscribe to the discussion, false otherwise.
     * @param {String} [groupid] Group this discussion belongs to.
     * @return {Promise}         Promise resolved when the discussion is created.
     */
    self.addNewDiscussion = function(forumid, subject, message, subscribe, groupid) {
        var params = {
            forumid: forumid,
            subject: subject,
            message: message,
            options: [
                {
                    name: 'discussionsubscribe',
                    value: !!subscribe
                }
            ]
        };
        if (groupid) {
            params.groupid = groupid;
        }

        return $mmSite.write('mod_forum_add_discussion', params).then(function(response) {
            if (!response || !response.discussionid) {
                return $q.reject();
            } else {
                return response.discussionid;
            }
        });
    };

    /**
     * Check if a user can post to a certain group.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#canAddDiscussion
     * @param  {Number} forumid Forum ID.
     * @param  {Number} groupid Group ID.
     * @return {Promise}        Promise resolved with a boolean: true if can add discussion, false otherwise.
     */
    self.canAddDiscussion = function(forumid, groupid) {
        var params = {
                forumid: forumid,
                groupid: groupid
            },
            preSets = {
                cacheKey: getCanAddDiscussionCacheKey(forumid, groupid)
            };

        return $mmSite.read('mod_forum_can_add_discussion', params, preSets).then(function(result) {
            if (result) {
                return !!result.status;
            }
            return $q.reject();
        });
    };

    /**
     * Check if a user can post to all groups.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#canAddDiscussionToAll
     * @param  {Number} forumid Forum ID.
     * @return {Promise}        Promise resolved with a boolean: true if can add discussion to all, false otherwise.
     */
    self.canAddDiscussionToAll = function(forumid) {
        return self.canAddDiscussion(forumid, -1);
    };

    /**
     * Extract the starting post of a discussion from a list of posts. The post is removed from the array passed as a parameter.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getStartingPost
     * @param  {Object[]} posts Posts to search.
     * @return {Object}         Starting post.
     */
    self.extractStartingPost = function(posts) {
        // Check the last post first, since they'll usually be ordered by create time.
        var lastPost = posts[posts.length - 1];
        if (lastPost.parent == 0) {
            posts.pop(); // Remove it from the array.
            return lastPost;
        }

        // Last post wasn't the starting one. Let's search all the posts until we find the first one.
        for (var i = 0; i < posts.length; i++) {
            if (posts[i].parent == 0) {
                array.splice(i, 1); // Remove it from the array.
                return posts[i];
            }
        }

        return undefined;
    };

    /**
     * Check if canAddDiscussion is available.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isCanAddDiscussionAvailable
     * @return {Boolean} True if available, false otherwise.
     */
    self.isCanAddDiscussionAvailable = function() {
        return $mmSite.wsAvailable('mod_forum_can_add_discussion');
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the forum WS are available.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_forum_get_forums_by_courses') &&
                    site.wsAvailable('mod_forum_get_forum_discussions_paginated') &&
                    site.wsAvailable('mod_forum_get_forum_discussion_posts');
        });
    };

    /**
     * Format discussions, setting groupname if the discussion group is valid.
     *
     * @param  {Number} cmid          Forum cmid.
     * @param  {Object[]} discussions List of discussions to format.
     * @return {Promise}              Promise resolved with the formatted discussions.
     */
    self.formatDiscussionsGroups = function(cmid, discussions) {
        discussions = angular.copy(discussions);
        return $translate('mm.core.allparticipants').then(function(strAllParts) {
            return $mmGroups.getActivityAllowedGroups(cmid).then(function(forumgroups) {
                // Turn groups into an object where each group is identified by id.
                var groups = {};
                angular.forEach(forumgroups, function(fg) {
                    groups[fg.id] = fg;
                });

                // Format discussions.
                angular.forEach(discussions, function(disc) {
                    if (disc.groupid === -1) {
                        disc.groupname = strAllParts;
                    } else {
                        var group = groups[disc.groupid];
                        if (group) {
                            disc.groupname = group.name;
                        }
                    }
                });
                return discussions;
            });
        }).catch(function() {
            return discussions;
        });
    };

    /**
     * Get a forum.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getForum
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the forum is retrieved.
     */
    self.getForum = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getForumDataCacheKey(courseid)
            };

        return $mmSite.read('mod_forum_get_forums_by_courses', params, preSets).then(function(forums) {
            var currentForum;
            angular.forEach(forums, function(forum) {
                if (forum.cmid == cmid) {
                    currentForum = forum;
                }
            });
            if (currentForum) {
                return currentForum;
            }
            return $q.reject();
        });
    };

    /**
     * Get forum discussion posts.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getDiscussionPosts
     * @param {Number} discussionid Discussion ID.
     * @return {Promise}            Promise resolved with forum discussions.
     */
    self.getDiscussionPosts = function(discussionid) {
        var params = {
                discussionid: discussionid
            },
            preSets = {
                cacheKey: getDiscussionPostsCacheKey(discussionid)
            };

        return $mmSite.read('mod_forum_get_forum_discussion_posts', params, preSets).then(function(response) {
            if (response) {
                storeUserData(response.posts);
                return response.posts;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Get forum discussions.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getDiscussions
     * @param {Number} forumid Forum ID.
     * @param {Number} page    Page.
     * @return {Promise}       Promise resolved with forum discussions.
     */
    self.getDiscussions = function(forumid, page) {
        page = page || 0;

        var params = {
                forumid: forumid,
                sortby:  'timemodified',
                sortdirection:  'DESC',
                page: page,
                perpage: mmaModForumDiscPerPage
            },
            preSets = {
                cacheKey: getDiscussionsListCacheKey(forumid)
            };

        return $mmSite.read('mod_forum_get_forum_discussions_paginated', params, preSets).then(function(response) {
            if (response) {
                var canLoadMore = response.discussions.length >= mmaModForumDiscPerPage;
                storeUserData(response.discussions);
                return {discussions: response.discussions, canLoadMore: canLoadMore};
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Invalidates can add discussion WS calls.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateCanAddDiscussion
     * @param  {Number} forumid Forum ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateCanAddDiscussion = function(forumid) {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getCommonCanAddDiscussionCacheKey(forumid));
    };

    /**
     * Invalidates forum discussion posts.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateDiscussionPosts
     * @param {Number} discussionid Discussion ID.
     * @return {Promise}            Promise resolved when the data is invalidated.
     */
    self.invalidateDiscussionPosts = function(discussionid) {
        return $mmSite.invalidateWsCacheForKey(getDiscussionPostsCacheKey(discussionid));
    };

    /**
     * Invalidates discussion list.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateDiscussionsList
     * @param  {Number} forumid Forum ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateDiscussionsList = function(forumid) {
        return $mmSite.invalidateWsCacheForKey(getDiscussionsListCacheKey(forumid));
    };

    /**
     * Invalidates forum data.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateForumData
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateForumData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getForumDataCacheKey(courseid));
    };

    /**
     * Check if the current site allows creating new discussions.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isCreateDiscussionEnabled
     * @return {Boolean} True if enabled, false otherwise.
     */
    self.isCreateDiscussionEnabled = function() {
        return $mmSite.wsAvailable('core_group_get_activity_groupmode') &&
                $mmSite.wsAvailable('core_group_get_activity_allowed_groups') &&
                $mmSite.wsAvailable('mod_forum_add_discussion');
    };

    /**
     * Check if the current site allows replying to posts.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isReplyPostEnabled
     * @return {Boolean} True if enabled, false otherwise.
     */
    self.isReplyPostEnabled = function() {
        return $mmSite.wsAvailable('mod_forum_add_discussion_post');
    };

    /**
     * Report a forum as being viewed.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                forumid: id
            };
            return $mmSite.write('mod_forum_view_forum', params);
        }
        return $q.reject();
    };

    /**
     * Reply to a certain post.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#replyPost
     * @param {Number} postid  ID of the post being replied.
     * @param {String} subject New post's subject.
     * @param {String} message New post's message.
     * @return {Promise}       Promise resolved when the post is created.
     */
    self.replyPost = function(postid, subject, message) {
        var params = {
            postid: postid,
            subject: subject,
            message: message
        };

        return $mmSite.write('mod_forum_add_discussion_post', params).then(function(response) {
            if (!response || !response.postid) {
                return $q.reject();
            } else {
                return response.postid;
            }
        });
    };

    /**
     * Store the users data from a discussions/posts list.
     *
     * @param {Object[]} list Array of posts or discussions.
     */
    function storeUserData(list) {
        var ids = [];
        angular.forEach(list, function(entry) {
            var id = parseInt(entry.userid);
            if (!isNaN(id) && ids.indexOf(id) === -1) {
                ids.push(id);
                $mmUser.storeUser(id, entry.userfullname, entry.userpictureurl);
            }
            if (typeof entry.usermodified != 'undefined') {
                id = parseInt(entry.usermodified);
                if(!isNaN(id) && ids.indexOf(id) === -1) {
                    ids.push(id);
                    $mmUser.storeUser(id, entry.usermodifiedfullname, entry.usermodifiedpictureurl);
                }
            }
        });
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Mod forum handlers.
 *
 * @module mm.addons.mod_forum
 * @ngdoc service
 * @name $mmaModForumHandlers
 */
.factory('$mmaModForumHandlers', ["$mmCourse", "$mmaModForum", "$state", "$mmUtil", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModForum, $state, $mmUtil, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForumHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @module mm.addons.mod_forum
         * @ngdoc method
         * @name $mmaModForumCourseContentHandler#isEnabled
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModForum.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @module mm.addons.mod_forum
         * @ngdoc method
         * @name $mmaModForumCourseContentHandler#isEnabled
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('forum');
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_forum', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForumHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isIndexEnabled(siteId, courseId) {
            return $mmaModForum.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId Site ID.
         * @return {Promise}       Promise resolved with true if enabled.
         */
        function isDiscEnabled(siteId) {
            // We don't check courseId because it's only needed for user profile links, we can afford not passing it.
            return $mmaModForum.isPluginEnabled(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a forum URL.
            if (url.indexOf('/mod/forum/view.php') > -1) {
                // Forum index.
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isIndexEnabled, courseId);
            } else if (url.indexOf('/mod/forum/discuss.php') > -1) {
                // Forum discussion.
                var params = $mmUtil.extractUrlParams(url);
                if (params.d != 'undefined') {
                    // Pass false because all sites should have the same siteurl.
                    return $mmContentLinksHelper.filterSupportedSites(siteIds, isDiscEnabled, false, courseId).then(function(ids) {
                        if (!ids.length) {
                            return [];
                        } else {
                            // Return actions.
                            return [{
                                message: 'mm.core.view',
                                icon: 'ion-eye',
                                sites: ids,
                                action: function(siteId) {
                                    var stateParams = {
                                        discussionid: parseInt(params.d, 10),
                                        cid: courseId
                                    };
                                    $mmContentLinksHelper.goInSite('site.mod_forum-discussion', stateParams, siteId);
                                }
                            }];
                        }
                    });
                }
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * IMSCP index controller.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc controller
 * @name mmaModImscpIndexCtrl
 */
.controller('mmaModImscpIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModImscp", "$log", "mmaModImscpComponent", "$ionicPopover", "$timeout", "$q", "$mmCourse", "$mmApp", function($scope, $stateParams, $mmUtil, $mmaModImscp, $log, mmaModImscpComponent,
            $ionicPopover, $timeout, $q, $mmCourse, $mmApp) {
    $log = $log.getInstance('mmaModImscpIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        currentItem;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModImscpComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;

    // Initialize empty previous/next to prevent showing arrows for an instant before they're hidden.
    $scope.previousItem = '';
    $scope.nextItem = '';

    $scope.items = $mmaModImscp.createItemList(module.contents);
    if ($scope.items.length) {
        currentItem = $scope.items[0].href;
    }

    function loadItem(itemId) {
        currentItem = itemId;
        $scope.previousItem = $mmaModImscp.getPreviousItem($scope.items, itemId);
        $scope.nextItem = $mmaModImscp.getNextItem($scope.items, itemId);
        var src = $mmaModImscp.getFileSrc(module, itemId);
        if ($scope.src && src.toString() == $scope.src.toString()) {
            // Re-loading same page. Set it to empty and then re-set the src in the next digest so it detects it has changed.
            $scope.src = '';
            $timeout(function() {
                $scope.src = src;
            });
        } else {
            $scope.src = src;
        }
    }

    function fetchContent() {
        if (module.contents && module.contents.length) {
            var downloadFailed = false;
            return $mmaModImscp.downloadAllContent(module).catch(function() {
                // Mark download as failed but go on since the main files could have been downloaded.
                downloadFailed = true;
            }).finally(function() {
                return $mmaModImscp.getIframeSrc(module).then(function() {
                    loadItem(currentItem);

                    if (downloadFailed && $mmApp.isOnline()) {
                        // We could load the main file but the download failed. Show error message.
                        $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                    }
                }).catch(function() {
                    $mmUtil.showErrorModal('mma.mod_imscp.deploymenterror', true);
                    return $q.reject();
                }).finally(function() {
                    $scope.loaded = true;
                });
            });
        } else {
            $mmUtil.showErrorModal('mma.mod_imscp.deploymenterror', true);
            return $q.reject();
        }
    }

    $scope.doRefresh = function() {
        $mmaModImscp.invalidateContent(module.id).then(function() {
            return fetchContent();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.loadItem = function(itemId) {
        $scope.popover.hide();
        loadItem(itemId);
    };

    $scope.getNumberForPadding = function(n) {
        return new Array(n);
    };

    $ionicPopover.fromTemplateUrl('addons/mod_imscp/templates/toc.html', {
        scope: $scope,
    }).then(function(popover) {
        $scope.popover = popover;
    });

    fetchContent().then(function() {
        $mmaModImscp.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * Mod IMSCP handlers.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc service
 * @name $mmaModImscpHandlers
 */
.factory('$mmaModImscpHandlers', ["$mmCourse", "$mmaModImscp", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModImscpComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModImscp, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModImscpComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @module mm.addons.mod_imscp
         * @ngdoc method
         * @name $mmaModImscpCourseContentHandler#isEnabled
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModImscp.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @module mm.addons.mod_imscp
         * @ngdoc method
         * @name $mmaModImscpCourseContentHandler#getController
         * @param {Object} module   The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModImscp.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModImscp.invalidateContent(module.id).then(function() {
                            $mmaModImscp.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('imscp');
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_imscp', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModImscpComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModImscp.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's an IMSCP URL.
            if (url.indexOf('/mod/imscp/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * IMSCP factory.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc service
 * @name $mmaModImscp
 */
.factory('$mmaModImscp', ["$mmFilepool", "$mmSite", "$mmFS", "$log", "$q", "$sce", "$mmApp", "$mmSitesManager", "mmaModImscpComponent", function($mmFilepool, $mmSite, $mmFS, $log, $q, $sce, $mmApp, $mmSitesManager, mmaModImscpComponent) {
    $log = $log.getInstance('$mmaModImscp');

    var self = {},
        currentDirPath; // Directory path of the current IMSCP.

    /**
     * Get the IMSCP toc as an array.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getToc
     * @param  {array} contents The module contents.
     * @return {Array}          The toc.
     * @protected
     */
    self.getToc = function(contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return JSON.parse(contents[0].content);
    };

    /**
     * Get the imscp toc as an array of items (no nested) to build the navigation tree.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#createItemList
     * @param  {array} contents The module contents.
     * @return {Array}          The toc as a list.
     * @protected
     */
    self.createItemList = function(contents) {
        var items = [];
        var toc = self.getToc(contents);
        angular.forEach(toc, function(el) {
            items.push({href: el.href, title: el.title, level: el.level});
            angular.forEach(el.subitems, function(sel) {
                items.push({href: sel.href, title: sel.title, level: sel.level});
            });
        });
        return items;
    };

    /**
     * Get the previous item to the given one.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getPreviousItem
     * @param  {array} items     The items list.
     * @param  {String} itemId   The current item.
     * @return {String}          The previous item id.
     * @protected
     */
    self.getPreviousItem = function(items, itemId) {
        var previous = '';

        for (var i = 0, len = items.length; i < len; i++) {
            if (items[i].href == itemId) {
                break;
            }
            previous = items[i].href;
        }

        return previous;
    };

    /**
     * Get the next item to the given one.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getNextItem
     * @param  {array} items     The items list.
     * @param  {String} itemId   The current item.
     * @return {String}           The next item id.
     * @protected
     */
    self.getNextItem = function(items, itemId) {
        var next = '';

        for (var i = 0, len = items.length; i < len; i++) {
            if (items[i].href == itemId) {
                if (typeof items[i + 1] != 'undefined') {
                    next = items[i + 1].href;
                    break;
                }
            }
        }
        return next;
    };


    /**
     * Check if we should ommit the file download.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#checkSpecialFiles
     * @param {String} fileName The file name
     * @return {Boolean}        True if we should ommit the file
     * @protected
     */
    self.checkSpecialFiles = function(fileName) {
        return fileName == 'imsmanifest.xml';
    };

    /**
     * Download all the content. All the files are downloaded inside a folder in filepool, keeping their folder structure.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        return $mmFilepool.getFilePathByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModImscpComponent, module.id, revision, timemod, dirPath);
        });
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }

            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Given a filepath, get a certain fileurl from module contents.
     *
     * @param {Object[]} contents     Module contents.
     * @param {String} targetFilepath Filepath of the searched file.
     * @return {String}               Fileurl.
     * @protected
     */
    self._getFileUrlFromContents = function(contents, targetFilepath) {
        var indexUrl;
        angular.forEach(contents, function(content) {
            if (content.type == 'file' && !indexUrl) {
                var filepath = $mmFS.concatenatePaths(content.filepath, content.filename),
                    filepathalt = filepath.charAt(0) === '/' ? filepath.substr(1) : '/' + filepath;
                // Check if it's main file.
                if (filepath === targetFilepath || filepathalt === targetFilepath) {
                    indexUrl = content.fileurl;
                }
            }
        });
        return indexUrl;
    };

    /**
     * Download all the files needed and returns the src of the iframe.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getIframeSrc
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved with the iframe src.
     */
    self.getIframeSrc = function(module) {
        var toc = self.getToc(module.contents),
            mainFilePath;
        if (!toc.length) {
            return $q.reject();
        }
        mainFilePath = toc[0].href;

        return $mmFilepool.getDirectoryUrlByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            currentDirPath = dirPath;
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, mainFilePath));
        }, function() {
            // Error getting directory, there was an error downloading or we're in browser. Return online URL if connected.
            if ($mmApp.isOnline()) {
                var indexUrl = self._getFileUrlFromContents(module.contents, mainFilePath);
                if (indexUrl) {
                    // This URL is going to be injected in an iframe, we need this to make it work.
                    return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(indexUrl));
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get src of a imscp item.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getFileSrc
     * @param {Object} module    The module object.
     * @param {String} itemId    Item to get the src.
     * @return {String}          Item src.
     */
    self.getFileSrc = function(module, itemId) {
        if (currentDirPath) {
            // IMSCP successfully loaded.
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(currentDirPath, itemId));
        } else {
            // Error loading IMSCP. Let's get online URL.
            if ($mmApp.isOnline()) {
                var indexUrl = self._getFileUrlFromContents(module.contents, itemId);
                if (indexUrl) {
                    // This URL is going to be injected in an iframe, we need this to make it work.
                    return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(indexUrl));
                }
            }
        }
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#invalidateContent
     * @param {Number} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModImscpComponent, moduleId);
    };

    /**
     * Check if a file is downloadable. The file param must have 'type' and 'filename' attributes
     * like in core_course_get_contents response.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file' && !self.checkSpecialFiles(file.filename);
    };

    /**
     * Return whether or not the plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var version = site.getInfo().version;
            // Require Moodle 2.9.
            return version && (parseInt(version) >= 2015051100) && site.canDownloadFiles();
        });
    };

    /**
     * Report a IMSCP as being viewed.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                imscpid: id
            };
            return $mmSite.write('mod_imscp_view_imscp', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content. All the files are downloaded inside a folder in filepool, keeping their folder structure.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        return $mmFilepool.getFilePathByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModImscpComponent, module.id, revision, timemod, dirPath);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * Mod imscp prefetch handler.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc service
 * @name $mmaModImscpPrefetchHandler
 */
.factory('$mmaModImscpPrefetchHandler', ["$mmaModImscp", "mmaModImscpComponent", function($mmaModImscp, mmaModImscpComponent) {

    var self = {};

    self.component = mmaModImscpComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpPrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModImscp.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmaModImscp.isPluginEnabled();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpPrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModImscp.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Label index controller.
 *
 * @module mm.addons.mod_label
 * @ngdoc controller
 * @name mmaModLabelIndexCtrl
 */
.controller('mmaModLabelIndexCtrl', ["$scope", "$stateParams", "$log", function($scope, $stateParams, $log) {
    $log = $log.getInstance('mmaModLabelIndexCtrl');
    $scope.description = $stateParams.description;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_label')

/**
 * Mod label handlers.
 *
 * @module mm.addons.mod_label
 * @ngdoc service
 * @name $mmaModLabelHandlers
 */
.factory('$mmaModLabelHandlers', ["$mmText", "$translate", "$state", "$mmContentLinksHelper", "$q", "$mmCourse", function($mmText, $translate, $state, $mmContentLinksHelper, $q, $mmCourse) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_label
     * @ngdoc method
     * @name $mmaModLabelHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @return {Function}
         */
        self.getController = function(module) {
            return function($scope) {
                var title = $mmText.shortenText($mmText.cleanTags(module.description).trim(), 128);
                if (title.length <= 0) {
                    $translate('mma.mod_label.taptoview').then(function(taptoview) {
                        $scope.title = '<span class="mma-mod_label-empty">' + taptoview + '</span>';
                    });
                } else {
                    $scope.title = title;
                }

                $scope.icon = false;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_label', {description: module.description});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_label
     * @ngdoc method
     * @name $mmaModLabelHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            if (courseId) {
                return $q.when(true);
            }
            return $mmCourse.canGetModuleWithoutCourseId(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a label URL.
            if (url.indexOf('/mod/label/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti')

/**
 * LTI index controller.
 *
 * @module mm.addons.mod_lti
 * @ngdoc controller
 * @name mmaModLtiIndexCtrl
 */
.controller('mmaModLtiIndexCtrl', ["$scope", "$stateParams", "$mmaModLti", "$mmUtil", "$q", "$mmCourse", function($scope, $stateParams, $mmaModLti, $mmUtil, $q, $mmCourse) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        lti;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.courseid = courseid;

    // Convenience function to get LTI data.
    function fetchLTI(refresh) {
        return $mmaModLti.getLti(courseid, module.id).then(function(ltidata) {
            lti = ltidata;

            return $mmaModLti.getLtiLaunchData(lti.id).then(function(launchdata) {
                lti.launchdata = launchdata;
                $scope.title = lti.name || $scope.title;
                $scope.description = lti.intro || $scope.description;
                $scope.isValidUrl = $mmUtil.isValidURL(launchdata.endpoint);
            });
        }).catch(function(message) {
            if (!refresh) {
                // Some call failed, retry without using cache since it might be a new activity.
                return refreshAllData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_lti.errorgetlti', true);
            }
            return $q.reject();
        });
    }

    // Convenience function to refresh all the data.
    function refreshAllData() {
        var p1 = $mmaModLti.invalidateLti(courseid),
            p2 = lti ? $mmaModLti.invalidateLtiLaunchData(lti.id) : $q.when();

        return $q.all([p1, p2]).finally(function() {
            return fetchLTI(true);
        });
    }

    fetchLTI().finally(function() {
        $scope.ltiLoaded = true;
    });

    // Pull to refresh.
    $scope.doRefresh = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Launch the LTI.
    $scope.launch = function() {
        // "View" LTI.
        $mmaModLti.logView(lti.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });

        // Launch LTI.
        $mmaModLti.launch(lti.launchdata.endpoint, lti.launchdata.parameters).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            }
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti')

/**
 * Mod LTI handler.
 *
 * @module mm.addons.mod_lti
 * @ngdoc service
 * @name $mmaModLtiHandlers
 */
.factory('$mmaModLtiHandlers', ["$mmCourse", "$mmaModLti", "$state", "$mmSite", "$mmFilepool", "$mmApp", "$mmUtil", "mmaModLtiComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModLti, $state, $mmSite, $mmFilepool, $mmApp, $mmUtil,
            mmaModLtiComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLtiHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModLti.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('lti'); // Get LTI default icon for now.
                $scope.action = function() {
                    $state.go('site.mod_lti', {module: module, courseid: courseid});
                };

                // Get LTI data.
                var promise = $mmaModLti.getLti(courseid, module.id);

                // Handle custom icons.
                promise.then(function(ltidata) {
                    var icon = ltidata.secureicon || ltidata.icon;
                    if (icon) {
                        $mmFilepool.downloadUrl($mmSite.getId(), icon, false, mmaModLtiComponent, module.id).then(function(url) {
                            $scope.icon = url;
                        }).catch(function() {
                            // Error downloading. If we're online we'll set the online url.
                            if ($mmApp.isOnline()) {
                                $scope.icon = icon;
                            }
                        });
                    }
                });

                // Button to launch the LTI.
                $scope.buttons = [{
                    icon: 'ion-link',
                    label: 'mma.mod_lti.launchactivity',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();

                        var modal = $mmUtil.showModalLoading('mm.core.loading', true);
                        // Get LTI and launch data.
                        promise.then(function(ltidata) {
                            return $mmaModLti.getLtiLaunchData(ltidata.id).then(function(launchdata) {
                                // "View" LTI.
                                $mmaModLti.logView(ltidata.id).then(function() {
                                    $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                                });

                                // Launch LTI.
                                return $mmaModLti.launch(launchdata.endpoint, launchdata.parameters);
                            });
                        }).catch(function(message) {
                            if (message) {
                                $mmUtil.showErrorModal(message);
                            } else {
                                $mmUtil.showErrorModal('mma.mod_lti.errorgetlti', true);
                            }
                        }).finally(function() {
                            modal.dismiss();
                        });
                    }
                }];
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLtiHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModLti.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a LTI URL.
            if (url.indexOf('/mod/lti/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti')

/**
 * LTI service.
 *
 * @module mm.addons.mod_lti
 * @ngdoc service
 * @name $mmaModLti
 */
.factory('$mmaModLti', ["$q", "$mmSite", "$mmFS", "$mmText", "$mmUtil", "$mmLang", "$mmSitesManager", function($q, $mmSite, $mmFS, $mmText, $mmUtil, $mmLang, $mmSitesManager) {
    var self = {},
        launcherFileName = 'lti_launcher.html';

    /**
     * Delete launcher.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#deleteLauncher
     * @return {Promise} Promise resolved when the launcher file is deleted.
     */
    self.deleteLauncher = function() {
        return $mmFS.removeFile(launcherFileName);
    };

    /**
     * Generates a launcher file.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#generateLauncher
     * @param {String} url      Launch URL.
     * @param {Object[]} params Launch params.
     * @return {Promise}        Promise resolved with the file URL.
     */
    self.generateLauncher = function(url, params) {

        if (!$mmFS.isAvailable()) {
            return $q.when(url);
        }

        // Generate a form with the params.
        var text = '<form action="' + url + '" name="ltiLaunchForm" ' +
                    'method="post" encType="application/x-www-form-urlencoded">\n';
        angular.forEach(params, function(p) {
            if (p.name == 'ext_submit') {
                text += '    <input type="submit"';
            } else {
                text += '    <input type="hidden" name="' + $mmText.escapeHTML(p.name) + '"';
            }
            text += ' value="' + $mmText.escapeHTML(p.value) + '"/>\n';
        });
        text += '</form>\n';

        // Add an in-line script to automatically submit the form.
        text += '<script type="text/javascript"> \n' +
            '    document.ltiLaunchForm.submit(); \n' +
            '</script> \n';

        return $mmFS.writeFile(launcherFileName, text).then(function(entry) {
            return entry.toURL();
        });
    };

    /**
     * Get a LTI.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#getLti
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the LTI is retrieved.
     */
    self.getLti = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getLtiCacheKey(courseid)
            };

        return $mmSite.read('mod_lti_get_ltis_by_courses', params, preSets).then(function(response) {
            if (response.ltis) {
                var currentLti;
                angular.forEach(response.ltis, function(lti) {
                    if (lti.coursemodule == cmid) {
                        currentLti = lti;
                    }
                });
                if (currentLti) {
                    return currentLti;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for LTI data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getLtiCacheKey(courseid) {
        return 'mmaModLti:lti:' + courseid;
    }

    /**
     * Get a LTI launch data.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#getLtiLaunchData
     * @param {Number} id LTI ID.
     * @return {Promise}  Promise resolved when the launch data is retrieved.
     */
    self.getLtiLaunchData = function(id) {
        var params = {
                toolid: id
            },
            preSets = {
                cacheKey: getLtiLaunchDataCacheKey(id)
            };

        return $mmSite.read('mod_lti_get_tool_launch_data', params, preSets).then(function(response) {
            if (response.endpoint) {
                return response;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for LTI launch data WS calls.
     *
     * @param {Number} id LTI ID.
     * @return {String}   Cache key.
     */
    function getLtiLaunchDataCacheKey(id) {
        return 'mmaModLti:launch:' + id;
    }

    /**
     * Invalidates LTI data.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#invalidateLti
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateLti = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getLtiCacheKey(courseid));
    };

    /**
     * Invalidates options.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#invalidateLtiLaunchData
     * @param {Number} id LTI ID.
     * @return {Promise}  Promise resolved when the data is invalidated.
     */
    self.invalidateLtiLaunchData = function(id) {
        return $mmSite.invalidateWsCacheForKey(getLtiLaunchDataCacheKey(id));
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the lti WS are available.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_lti_get_ltis_by_courses') &&
                    site.wsAvailable('mod_lti_get_tool_launch_data');
        });
    };

    /**
     * Launch LTI.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#launch
     * @param {String} url      Launch URL.
     * @param {Object[]} params Launch params.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.launch = function(url, params) {
        if (!$mmUtil.isValidURL(url)) {
            return $mmLang.translateAndReject('mma.mod_lti.errorinvalidlaunchurl');
        }

        // Generate launcher and open it.
        return self.generateLauncher(url, params).then(function(url) {
            $mmUtil.openInApp(url);
        });
    };

    /**
     * Report the LTI as being viewed.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#logView
     * @param {String} id LTI ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                ltiid: id
            };
            return $mmSite.write('mod_lti_view_lti', params);
        }
        return $q.reject();
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Page index controller.
 *
 * @module mm.addons.mod_page
 * @ngdoc controller
 * @name mmaModPageIndexCtrl
 */
.controller('mmaModPageIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModPage", "$mmCourse", "$q", "$log", "$mmApp", "mmaModPageComponent", function($scope, $stateParams, $mmUtil, $mmaModPage, $mmCourse, $q, $log, $mmApp,
            mmaModPageComponent) {
    $log = $log.getInstance('mmaModPageIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModPageComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;

    function fetchContent() {
        var downloadFailed = false;
        // Prefetch the content so ALL files are downloaded, not just the ones shown in the page.
        return $mmaModPage.downloadAllContent(module).catch(function(err) {
            // Mark download as failed but go on since the main files could have been downloaded.
            downloadFailed = true;
        }).then(function() {
            return $mmaModPage.getPageHtml(module.contents, module.id).then(function(content) {
                $scope.content = content;

                if (downloadFailed && $mmApp.isOnline()) {
                    // We could load the main file but the download failed. Show error message.
                    $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                }
            }).catch(function() {
                $mmUtil.showErrorModal('mma.mod_page.errorwhileloadingthepage', true);
                return $q.reject();
            }).finally(function() {
                $scope.loaded = true;
            });
        });
    }

    $scope.doRefresh = function() {
        $mmaModPage.invalidateContent(module.id).then(function() {
            return fetchContent();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    fetchContent().then(function() {
        $mmaModPage.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Mod page handlers.
 *
 * @module mm.addons.mod_page
 * @ngdoc service
 * @name $mmaModPageHandlers
 */
.factory('$mmaModPageHandlers', ["$mmCourse", "$mmaModPage", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModPageComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModPage, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModPageComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPageHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModPage.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModPage.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModPage.invalidateContent(module.id).finally(function() {
                            $mmaModPage.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('page');
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_page', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModPageComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPageHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModPage.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a page URL.
            if (url.indexOf('/mod/page/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Page factory.
 *
 * @module mm.addons.mod_page
 * @ngdoc service
 * @name $mmaModPage
 */
.factory('$mmaModPage', ["$mmFilepool", "$mmSite", "$mmFS", "$http", "$log", "$q", "$mmSitesManager", "mmaModPageComponent", function($mmFilepool, $mmSite, $mmFS, $http, $log, $q, $mmSitesManager, mmaModPageComponent) {
    $log = $log.getInstance('$mmaModPage');

    var self = {};

    /**
     * Download all the content.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModPageComponent, module.id, revision, timemod);
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Gets the page HTML.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getPageHtml
     * @param {Object} contents The module contents.
     * @param {Object} moduleId The module ID.
     * @return {Promise}
     */
    self.getPageHtml = function(contents, moduleId) {
        var indexUrl,
            paths = {},
            promise;

        // Extract the information about paths from the module contents.
        angular.forEach(contents, function(content) {
            var key,
                url = content.fileurl;

            if (self._isMainPage(content)) {
                // This seems to be the most reliable way to spot the index page.
                indexUrl = url;
            } else {
                key = content.filename;
                if (content.filepath !== '/') {
                    // Add the folders without the leading slash.
                    key = content.filepath.substr(1) + key;
                }
                paths[key] = url;
            }
        });

        // Promise handling when we are in a browser.
        promise = (function() {
            var deferred;
            if (!indexUrl) {
                // If ever that happens.
                $log.debug('Could not locate the index page');
                return $q.reject();
            } else if ($mmFS.isAvailable()) {
                // The file system is available.
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModPageComponent, moduleId);
            } else {
                // We return the live URL.
                deferred = $q.defer();
                deferred.resolve($mmSite.fixPluginfileURL(indexUrl));
                return deferred.promise;
            }
        })();

        return promise.then(function(url) {
            // Fetch the URL content.
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    // Now that we have the content, we update the SRC to point back to
                    // the external resource. That will be caught by mm-format-text.
                    var html = angular.element('<div>');
                    html.html(response.data);
                    angular.forEach(html.find('img'), function(img) {
                        var src = paths[decodeURIComponent(img.getAttribute('src'))];
                        if (typeof src !== 'undefined') {
                            img.setAttribute('src', src);
                        }
                    });
                    // We do the same for links.
                    angular.forEach(html.find('a'), function(anchor) {
                        var href = paths[decodeURIComponent(anchor.getAttribute('href'))];
                        if (typeof href !== 'undefined') {
                            anchor.setAttribute('href', href);
                        }
                    });
                    return html.html();
                }
            });
        });
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#invalidateContent
     * @param {Object} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModPageComponent, moduleId);
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Returns whether the file is the main page of the module.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#_isMainPage
     * @param {Object} file An object returned from WS containing file info.
     * @return {Boolean}
     * @protected
     */
    self._isMainPage = function(file) {
        var filename = file.filename || undefined,
            fileurl = file.fileurl || '',
            url = '/mod_page/content/index.html',
            encodedUrl = encodeURIComponent(url);

        return (filename === 'index.html' && (fileurl.indexOf(url) > 0 || fileurl.indexOf(encodedUrl) > 0 ));
    };

    /**
     * Check if page plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.canDownloadFiles();
        });
    };

    /**
     * Report a page as being viewed.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                pageid: id
            };
            return $mmSite.write('mod_page_view_page', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModPageComponent, module.id, revision, timemod);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Mod page prefetch handler.
 *
 * @module mm.addons.mod_page
 * @ngdoc service
 * @name $mmaModPagePrefetchHandler
 */
.factory('$mmaModPagePrefetchHandler', ["$mmaModPage", "$mmSite", "mmaModPageComponent", function($mmaModPage, $mmSite, mmaModPageComponent) {

    var self = {};

    self.component = mmaModPageComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPagePrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModPage.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPagePrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmSite.canDownloadFiles();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPagePrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModPage.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Resource index controller.
 *
 * @module mm.addons.mod_resource
 * @ngdoc controller
 * @name mmaModResourceIndexCtrl
 */
.controller('mmaModResourceIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModResource", "$log", "$mmApp", "$mmCourse", "$timeout", "mmaModResourceComponent", function($scope, $stateParams, $mmUtil, $mmaModResource, $log, $mmApp, $mmCourse, $timeout,
            mmaModResourceComponent) {
    $log = $log.getInstance('mmaModResourceIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModResourceComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.mode = false;
    $scope.loaded = false;

    function fetchContent() {
        if (module.contents && module.contents.length) {
            if ($mmaModResource.isDisplayedInIframe(module)) {
                $scope.mode = 'iframe';
                var downloadFailed = false;
                return $mmaModResource.downloadAllContent(module).catch(function(err) {
                    // Mark download as failed but go on since the main files could have been downloaded.
                    downloadFailed = true;
                }).finally(function() {
                    $mmaModResource.getIframeSrc(module).then(function(src) {
                        if ($scope.src && src.toString() == $scope.src.toString()) {
                            // Re-loading same page. Set it to empty and then re-set the src
                            // in the next digest so it detects it has changed.
                            $scope.src = '';
                            $timeout(function() {
                                $scope.src = src;
                            });
                        } else {
                            $scope.src = src;
                        }
                        $mmaModResource.logView(module.instance).then(function() {
                            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                        });
                        if (downloadFailed && $mmApp.isOnline()) {
                            // We could load the main file but the download failed. Show error message.
                            $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                        }
                    }).catch(function() {
                        $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
                    }).finally(function() {
                        $scope.loaded = true;
                    });
                });
            } else if ($mmaModResource.isDisplayedInline(module)) {
                var downloadFailed = false;
                $mmaModResource.downloadAllContent(module).catch(function(err) {
                    // Mark download as failed but go on since the main files could have been downloaded.
                    downloadFailed = true;
                }).finally(function() {
                    $mmaModResource.getResourceHtml(module.contents, module.id).then(function(content) {
                        $scope.mode = 'inline';
                        $scope.content = content;
                        $mmaModResource.logView(module.instance).then(function() {
                            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                        });

                        if (downloadFailed && $mmApp.isOnline()) {
                            // We could load the main file but the download failed. Show error message.
                            $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                        }
                    }).catch(function() {
                        $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
                    }).finally(function() {
                        $scope.loaded = true;
                    });
                });
            } else {
                $scope.loaded = true;
                $scope.mode = 'external';

                $scope.open = function() {
                    var modal = $mmUtil.showModalLoading('mm.core.downloading', true);

                    $mmaModResource.openFile(module.contents, module.id).then(function() {
                        $mmaModResource.logView(module.instance).then(function() {
                            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                        });
                    }).catch(function(error) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
                        }
                    }).finally(function() {
                        modal.dismiss();
                    });
                };
            }
        } else {
            $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
        }
    }

    // Event sent by the directive mmaModResourceHtmlLink when we click an HTML link.
    $scope.$on('mmaModResourceHtmlLinkClicked', function(e, target) {
        $scope.loaded = false;
        $mmaModResource.getResourceHtml(module.contents, module.id, target).then(function(content) {
            $scope.content = content;
        }).catch(function() {
            $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
        }).finally(function() {
            $scope.loaded = true;
        });
    });

    $scope.doRefresh = function() {
        $mmaModResource.invalidateContent(module.id).then(function() {
            return fetchContent();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    fetchContent();
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Directive to open a link in external browser.
 *
 * @module mm.addons.mod_resource
 * @ngdoc directive
 * @name mmaModResourceHtmlLink
 */
.directive('mmaModResourceHtmlLink', function() {
    return {
        restrict: 'A',
        priority: 99,   // Must be lower than mm-browser, or anything listening for a click event.
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                var href = element[0].getAttribute('data-href');
                if (!href) {
                    return;
                }

                // Prevent any other directive from catching the event.
                event.stopImmediatePropagation();
                event.preventDefault();

                // Notify the scope which must handle this click, we do not support bubbling.
                scope.$emit('mmaModResourceHtmlLinkClicked', href);
            });
        }
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Mod resource handlers.
 *
 * @module mm.addons.mod_resource
 * @ngdoc service
 * @name $mmaModResourceHandlers
 */
.factory('$mmaModResourceHandlers', ["$mmCourse", "$mmaModResource", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmCoursePrefetchDelegate", "$mmFilepool", "$mmFS", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModResourceComponent", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModResource, $mmEvents, $state, $mmSite, $mmUtil,
            $mmCoursePrefetchDelegate, $mmFilepool, $mmFS, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated,
            mmCoreEventPackageStatusChanged, mmaModResourceComponent, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourceHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModResource.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module   The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModResource.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModResource.invalidateContent(module.id).finally(function() {
                            $mmaModResource.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;

                if (module.contents.length) {
                    var filename = module.contents[0].filename,
                        extension = $mmFS.getFileExtension(filename);
                    if (module.contents.length == 1 || (extension != "html" && extension != "htm")) {
                        $scope.icon = $mmFS.getFileIcon(filename);
                    } else {
                        $scope.icon = $mmCourse.getModuleIconSrc('resource');
                    }
                } else {
                    $scope.icon = $mmCourse.getModuleIconSrc('resource');
                }
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_resource', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModResourceComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourceHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModResource.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a resource URL.
            if (url.indexOf('/mod/resource/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Mod resource prefetch handler.
 *
 * @module mm.addons.mod_resource
 * @ngdoc service
 * @name $mmaModResourcePrefetchHandler
 */
.factory('$mmaModResourcePrefetchHandler', ["$mmaModResource", "$mmSite", "mmaModResourceComponent", function($mmaModResource, $mmSite, mmaModResourceComponent) {

    var self = {};

    self.component = mmaModResourceComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourcePrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModResource.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourcePrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmSite.canDownloadFiles();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourcePrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModResource.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Resource factory.
 *
 * @module mm.addons.mod_resource
 * @ngdoc service
 * @name $mmaModResource
 */
.factory('$mmaModResource', ["$mmFilepool", "$mmSite", "$mmUtil", "$mmFS", "$http", "$log", "$q", "$sce", "$mmApp", "$mmSitesManager", "mmaModResourceComponent", function($mmFilepool, $mmSite, $mmUtil, $mmFS, $http, $log, $q, $sce, $mmApp, $mmSitesManager,
            mmaModResourceComponent) {
    $log = $log.getInstance('$mmaModResource');

    var self = {};

    /**
     * Download all the content. All the files are downloaded inside a folder in filepool, keeping their folder structure.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            siteid = $mmSite.getId(),
            promise,
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        if (self.isDisplayedInIframe(module)) {
            // Get path of the module folder in filepool.
            promise = $mmFilepool.getFilePathByUrl(siteid, module.url);
        } else {
            promise = $q.when();
        }

        return promise.then(function(dirPath) {
            return $mmFilepool.downloadPackage(siteid, files, mmaModResourceComponent, module.id, revision, timemod, dirPath);
        });
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModresource#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Download all the files needed and returns the src of the iframe.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getIframeSrc
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved with the iframe src.
     */
    self.getIframeSrc = function(module) {
        if (!module.contents.length) {
            return $q.reject();
        }

        var mainFile = module.contents[0],
            mainFilePath = mainFile.filename;

        if (mainFile.filepath !== '/') {
            mainFilePath = mainFile.filepath.substr(1) + mainFilePath;
        }

        return $mmFilepool.getDirectoryUrlByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, mainFilePath));
        }, function() {
            // Error getting directory, there was an error downloading or we're in browser. Return online URL.
            if ($mmApp.isOnline() && mainFile.fileurl) {
                // This URL is going to be injected in an iframe, we need this to make it work.
                return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(mainFile.fileurl));
            }
            return $q.reject();
        });
    };

    /**
     * Gets the resource HTML.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getResourceHtml
     * @param {Object[]} contents Array of content objects.
     * @param {Number} moduleId The module ID.
     * @param {String} [target] The HTML file that the user wants to open, if not defined uses the main file.
     * @return {Promise}
     */
    self.getResourceHtml = function(contents, moduleId, target) {
        var indexUrl,
            paths = {},
            promise;

        // Extract the information about paths from the module contents.
        angular.forEach(contents, function(content, index) {
            var url = content.fileurl,
                fullpath = content.filename;

            if (content.filepath !== '/') {
                fullpath = content.filepath.substr(1) + fullpath;
            }

            if (typeof target !== 'undefined' && target == fullpath) {
                // We use another index.
                indexUrl = url;
            } else if (typeof target === 'undefined' && index === 0) {
                // We use the main page, it should always be the first one.
                indexUrl = url;
            } else {
                // Any other file in the resource.
                paths[fullpath] = url;
            }
        });

        // Promise handling when we are in a browser.
        promise = (function() {
            if (!indexUrl) {
                // If ever that happens.
                $log.debug('Could not locate the index page');
                return $q.reject();
            }
            if ($mmFS.isAvailable()) {
                // The file system is available.
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModResourceComponent, moduleId);
            } else {
                // We return the live URL.
                return $q.when($mmSite.fixPluginfileURL(indexUrl));
            }
        })();

        return promise.then(function(url) {
            // Fetch the URL content.
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    // Now that we have the content, we update the SRC to point back to
                    // the external resource. That will be caught by mm-format-text.
                    var html = angular.element('<div>');
                        html.append(response.data);

                    angular.forEach(html.find('img'), function(img) {
                        var src = paths[decodeURIComponent(img.getAttribute('src'))];
                        if (typeof src !== 'undefined') {
                            img.setAttribute('src', src);
                        }
                    });
                    // We do the same for links.
                    angular.forEach(html.find('a'), function(anchor) {
                        var href = decodeURIComponent(anchor.getAttribute('href')),
                            url = paths[href],
                            ext = $mmFS.getFileExtension(href);
                        if (typeof url !== 'undefined') {
                            anchor.setAttribute('href', url);
                            if (ext == 'html' || ext == 'html') {
                                anchor.setAttribute('mma-mod-resource-html-link', 1);
                                anchor.setAttribute('data-href', href);
                            }
                        }
                    });

                    return html.html();
                }
            });
        });
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#invalidateContent
     * @param {Number} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModResourceComponent, moduleId);
    };

    /**
     * Whether the resource has to be displayed in an iframe.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isDisplayedInIframe
     * @param {Object} module The module object.
     * @return {Boolean}
     */
    self.isDisplayedInIframe = function(module) {
        var inline = self.isDisplayedInline(module);

        if (inline && $mmFS.isAvailable()) {
            for (var i = 0; i < module.contents.length; i++) {
                var ext = $mmFS.getFileExtension(module.contents[i].filename);
                if (ext == 'js' || ext == 'swf' || ext == 'css') {
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * Whether the resource is to be displayed inline (HTML).
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isDisplayedInline
     * @param {Object} module The module object.
     * @return {Boolean}
     */
    self.isDisplayedInline = function(module) {
        if (!module.contents.length) {
            return false;
        }
        var ext = $mmFS.getFileExtension(module.contents[0].filename);
        return ext === 'htm' || ext === 'html';
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Check if resource plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.canDownloadFiles();
        });
    };

    /**
     * Report the resource as being viewed.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                resourceid: id
            };
            return $mmSite.write('mod_resource_view_resource', params);
        }
        return $q.reject();
    };

    /**
     * Download and open the file from the resource.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#openFile
     * @param {Object[]} contents Array of content objects.
     * @param {Number} moduleId The module ID.
     * @return {Promise}
     */
    self.openFile = function(contents, moduleId) {
        if (!contents || !contents.length) {
            return $q.reject();
        }

        var url = contents[0].fileurl,
            promise;

        if ($mmFS.isAvailable()) {
            // The file system is available.
            promise = $mmFilepool.downloadUrl($mmSite.getId(), url, false, mmaModResourceComponent, moduleId);
        } else {
            // We use the live URL.
            promise = $q.when($mmSite.fixPluginfileURL(url));
        }

        return promise.then(function(localUrl) {
            return $mmUtil.openFile(localUrl);
        });
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            siteid = $mmSite.getId(),
            promise,
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        if (self.isDisplayedInIframe(module)) {
            // Get path of the module folder in filepool.
            promise = $mmFilepool.getFilePathByUrl(siteid, module.url);
        } else {
            promise = $q.when();
        }

        return promise.then(function(dirPath) {
            return $mmFilepool.prefetchPackage(siteid, files, mmaModResourceComponent, module.id, revision, timemod, dirPath);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM index controller.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc controller
 * @name mmaModScormIndexCtrl
 */
.controller('mmaModScormIndexCtrl', ["$scope", "$stateParams", "$mmaModScorm", "$mmUtil", "$q", "$mmCourse", "$ionicScrollDelegate", "$mmCoursePrefetchDelegate", "$mmaModScormHelper", "$mmEvents", "$mmSite", "$state", "mmCoreOutdated", "mmCoreNotDownloaded", "mmCoreDownloading", "mmaModScormComponent", "mmCoreEventPackageStatusChanged", "$ionicHistory", "mmaModScormEventAutomSynced", "$mmaModScormSync", "$timeout", function($scope, $stateParams, $mmaModScorm, $mmUtil, $q, $mmCourse, $ionicScrollDelegate,
            $mmCoursePrefetchDelegate, $mmaModScormHelper, $mmEvents, $mmSite, $state, mmCoreOutdated, mmCoreNotDownloaded,
            mmCoreDownloading, mmaModScormComponent, mmCoreEventPackageStatusChanged, $ionicHistory, mmaModScormEventAutomSynced,
            $mmaModScormSync, $timeout) {

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        scorm,
        statusObserver,
        currentStatus,
        lastAttempt,
        lastOffline = false,
        attempts,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaModScormIndexScroll');

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.currentOrganization = {};
    $scope.scormOptions = {
        mode: $mmaModScorm.MODENORMAL
    };

    $scope.modenormal = $mmaModScorm.MODENORMAL;
    $scope.modebrowse = $mmaModScorm.MODEBROWSE;

    // Convenience function to get SCORM data.
    function fetchScormData(refresh) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scormData) {
            scorm = scormData;

            $scope.title = scorm.name || $scope.title;
            $scope.description = scorm.intro || $scope.description;
            $scope.scorm = scorm;

            var result = $mmaModScorm.isScormSupported(scorm);
            if (result === true) {
                $scope.errorMessage = '';
            } else {
                $scope.errorMessage = result;
            }

            if (scorm.warningmessage) {
                return; // SCORM is closed or not open yet, we can't get more data.
            }

            return syncScorm(!refresh, false).catch(function() {
                // Ignore errors, keep getting data even if sync fails.
            }).then(function() {

                // No need to return this promise, it should be faster than the rest.
                $mmaModScormHelper.getScormReadableSyncTime(scorm.id).then(function(syncTime) {
                    $scope.syncTime = syncTime;
                });

                // Get the number of attempts and check if SCORM is incomplete.
                return $mmaModScorm.getAttemptCount(scorm.id).then(function(attemptsData) {
                    attempts = attemptsData;
                    $scope.showSyncButton = attempts.offline.length; // Show sync button only if there are offline attempts.

                    // Determine the attempt that will be continued or reviewed.
                    return $mmaModScormHelper.determineAttemptToContinue(scorm, attempts).then(function(attempt) {
                        lastAttempt = attempt.number;
                        lastOffline = attempt.offline;
                        if (lastAttempt != attempts.lastAttempt.number) {
                            $scope.attemptToContinue = lastAttempt;
                        } else {
                            delete $scope.attemptToContinue;
                        }

                        return $mmaModScorm.isAttemptIncomplete(scorm.id, lastAttempt, lastOffline).then(function(incomplete) {
                            var promises = [];

                            scorm.incomplete = incomplete;
                            scorm.numAttempts = attempts.total;
                            scorm.grademethodReadable = $mmaModScorm.getScormGradeMethod(scorm);
                            scorm.attemptsLeft = $mmaModScorm.countAttemptsLeft(scorm, attempts.lastAttempt.number);
                            if (scorm.forceattempt && scorm.incomplete) {
                                $scope.scormOptions.newAttempt = true;
                            }

                            promises.push(getReportedGrades());

                            promises.push(fetchStructure());

                            if (!scorm.packagesize && $scope.errorMessage === '') {
                                // SCORM is supported but we don't have package size. Try to calculate it.
                                promises.push($mmaModScorm.calculateScormSize(scorm).then(function(size) {
                                    scorm.packagesize = size;
                                }));
                            }

                            // Handle status. We don't add getStatus to promises because it should be fast.
                            setStatusListener();
                            getStatus().then(showStatus);

                            return $q.all(promises);
                        });
                    });
                }).catch(function(message) {
                    return showError(message);
                });

            });

        }, function(message) {
            if (!refresh) {
                // Get scorm failed, retry without using cache since it might be a new activity.
                return refreshData();
            }
            return showError(message);
        });
    }

    // Show error message and return a rejected promise.
    function showError(message, defaultMessage) {
        defaultMessage = defaultMessage || 'mma.mod_scorm.errorgetscorm';
        if (message) {
            $mmUtil.showErrorModal(message);
        } else {
            $mmUtil.showErrorModal(defaultMessage, true);
        }
        return $q.reject();
    }

    // Get the grades of each attempt and the grade of the SCORM.
    function getReportedGrades() {
        var promises = [];
        scorm.onlineAttempts = {};
        scorm.offlineAttempts = {};
        // Calculate the grade for each attempt.
        attempts.online.forEach(function(attempt) {
            // Check that attempt isn't in offline to prevent showing the same attempt twice. Offline should be more recent.
            if (attempts.offline.indexOf(attempt) == -1) {
                promises.push(getAttemptGrade(scorm, attempt));
            }
        });
        attempts.offline.forEach(function(attempt) {
            promises.push(getAttemptGrade(scorm, attempt, true));
        });

        return $q.all(promises).then(function() {

            // Calculate the grade of the whole SCORM. We only use online attempts to calculate this data.
            scorm.grade = $mmaModScorm.calculateScormGrade(scorm, scorm.onlineAttempts);

            // Now format the grades.
            angular.forEach(scorm.onlineAttempts, function(attempt) {
                attempt.grade = $mmaModScorm.formatGrade(scorm, attempt.grade);
            });
            angular.forEach(scorm.offlineAttempts, function(attempt) {
                attempt.grade = $mmaModScorm.formatGrade(scorm, attempt.grade);
            });
            scorm.grade = $mmaModScorm.formatGrade(scorm, scorm.grade);
        });
    }

    // Convenience function to get the grade of an attempt and add it to the scorm attempts list.
    function getAttemptGrade(scorm, attempt, offline) {
        return $mmaModScorm.getAttemptGrade(scorm, attempt, offline).then(function(grade) {
            var entry = {
                number: attempt,
                grade: grade
            };
            if (offline) {
                scorm.offlineAttempts[attempt] = entry;
            } else {
                scorm.onlineAttempts[attempt] = entry;
            }
        });
    }

    // Fetch the structure of the SCORM (TOC).
    function fetchStructure() {
        return $mmaModScorm.getOrganizations(scorm.id).then(function(organizations) {
            $scope.organizations = organizations;

            if (!$scope.currentOrganization.identifier) {
                // Load first organization (if any).
                if (organizations.length) {
                    $scope.currentOrganization.identifier = organizations[0].identifier;
                } else {
                    $scope.currentOrganization.identifier = '';
                }
            }

            return loadOrganizationToc($scope.currentOrganization.identifier);
        });
    }

    // Load the TOC of a certain organization.
    function loadOrganizationToc(organizationId) {
        if (!scorm.displaycoursestructure) {
            // TOC is not displayed, no need to load it.
            return $q.when();
        }

        $scope.loadingToc = true;
        return $mmaModScorm.getOrganizationToc(scorm.id, organizationId, lastAttempt, lastOffline).then(function(toc) {
            $scope.toc = $mmaModScorm.formatTocToArray(toc);
            // Get images for each SCO.
            angular.forEach($scope.toc, function(sco) {
                sco.image = $mmaModScorm.getScoStatusIcon(sco, scorm.incomplete);
            });
            // Search organization title.
            angular.forEach($scope.organizations, function(org) {
                if (org.identifier == organizationId) {
                    $scope.currentOrganization.title = org.title;
                }
            });
            // Resize scroll to prevent empty spaces if new TOC is shorter than previous TOC.
            $ionicScrollDelegate.resize();
        }).finally(function() {
            $scope.loadingToc = false;
        });
    }

    // Get status of the SCORM.
    function getStatus() {
        return $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, scorm.sha1hash, 0);
    }

    // Set a listener to monitor changes on this SCORM status to show a message to the user.
    function setStatusListener() {
        if (typeof statusObserver !== 'undefined') {
            return; // Already set.
        }

        // Listen for changes on this module status to show a message to the user.
        statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
            if (data.siteid === $mmSite.getId() && data.componentId === scorm.coursemodule &&
                    data.component === mmaModScormComponent) {
                showStatus(data.status);
            }
        });
    }

    // Showing or hide a status message depending on the SCORM status.
    function showStatus(status) {
        currentStatus = status;

        if (status == mmCoreOutdated) {
            $scope.statusMessage = 'mma.mod_scorm.scormstatusoutdated';
        } else if (status == mmCoreNotDownloaded) {
            $scope.statusMessage = 'mma.mod_scorm.scormstatusnotdownloaded';
        } else if (status == mmCoreDownloading) {
            if (!$scope.downloading) {
                // It's being downloaded right now but the view isn't tracking it. "Restore" the download.
                downloadScormPackage(true);
            }
        } else {
            $scope.statusMessage = '';
        }
    }

    // Refreshes data.
    function refreshData(dontForceSync) {
        var promises = [];
        promises.push($mmaModScorm.invalidateScormData(courseid));
        if (scorm) {
            promises.push($mmaModScorm.invalidateAllScormData(scorm.id));
        }

        return $q.all(promises).finally(function() {
            return fetchScormData(!dontForceSync);
        });
    }

    // Download a SCORM package or restores an ongoing download.
    function downloadScormPackage() {
        $scope.downloading = true;
        return $mmaModScorm.download(scorm).then(undefined, undefined, function(progress) {

            if (!progress) {
                return;
            }

            if (progress.packageDownload) { // Downloading package.
                if (scorm.packagesize) {
                    $scope.percentage = (parseFloat(progress.loaded / scorm.packagesize) * 100).toFixed(1);
                }
            } else if (progress.message) { // Show a message.
                $scope.progressMessage = progress.message;
            } else if (progress.loaded && progress.total) { // Unzipping package.
                $scope.percentage = (parseFloat(progress.loaded / progress.total) * 100).toFixed(1);
            } else {
                $scope.percentage = undefined;
            }

        }).finally(function() {
            $scope.progressMessage = undefined;
            $scope.percentage = undefined;
            $scope.downloading = false;
        });
    }

    // Open a SCORM package.
    function openScorm(scoId) {
        $state.go('site.mod_scorm-player', {
            scorm: scorm,
            mode: $scope.scormOptions.mode,
            newAttempt: !!$scope.scormOptions.newAttempt,
            organizationId: $scope.currentOrganization.identifier,
            scoId: scoId
        });
    }

    // Tries to synchronize the current SCORM.
    function syncScorm(checkTime, showErrors) {
        var promise = checkTime ? $mmaModScormSync.syncScormIfNeeded(scorm) : $mmaModScormSync.syncScorm(scorm);
        return promise.then(function(warnings) {
            var message = $mmaModScormHelper.buildWarningsMessage(warnings);
            if (message) {
                $mmUtil.showErrorModal(message);
            }
        }).catch(function(err) {
            if (showErrors) {
                return showError(err, 'mma.mod_scorm.errorsyncscorm');
            }
            return $q.reject();
        });
    }

    // Fetch the SCORM data.
    fetchScormData().then(function() {
        $mmaModScorm.logView(scorm.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.scormLoaded = true;
    });

    // Load a organization's TOC.
    $scope.loadOrg = function() {
        loadOrganizationToc($scope.currentOrganization.identifier).catch(function(message) {
            return showError(message);
        });
    };

    $scope.refreshScorm = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Open a SCORM. It will download the SCORM package if it's not downloaded or it has changed.
    // The scoId param indicates the SCO that needs to be loaded when the SCORM is opened. If not defined, load first SCO.
    $scope.open = function(e, scoId) {
        e.preventDefault();
        e.stopPropagation();

        if ($scope.downloading) {
            // Scope is being downloaded, abort.
            return;
        }

        if (currentStatus == mmCoreOutdated || currentStatus == mmCoreNotDownloaded) {
            // SCORM needs to be downloaded.
            $mmaModScormHelper.confirmDownload(scorm).then(function() {
                // Invalidate file if SCORM is outdated.
                var promise = currentStatus == mmCoreOutdated ? $mmaModScorm.invalidateContent(scorm.coursemodule) : $q.when();
                promise.finally(function() {
                    downloadScormPackage().then(function() {
                        // Success downloading, open scorm if user hasn't left the view.
                        if (!$scope.$$destroyed) {
                            openScorm(scoId);
                        }
                    }).catch(function() {
                        if (!$scope.$$destroyed) {
                            $mmaModScormHelper.showDownloadError(scorm);
                        }
                    });
                });
            });
        } else {
            openScorm(scoId);
        }
    };

    // Synchronize the SCORM.
    $scope.sync = function() {
        var modal = $mmUtil.showModalLoading('mm.settings.synchronizing', true);
        syncScorm(false, true).then(function() {
            // Refresh the data.
            $scope.scormLoaded = false;
            scrollView.scrollTop();
            refreshData(true).finally(function() {
                $scope.scormLoaded = true;
            });
        }).finally(function() {
            modal.dismiss();
        });
    };

    // Update data when we come back from the player since it's probable that it has changed.
    // We want to skip the first $ionicView.enter event because it's when the view is created.
    var skip = true;
    $scope.$on('$ionicView.enter', function() {
        if (skip) {
            skip = false;
            return;
        }

        $scope.scormOptions.newAttempt = false; // Uncheck new attempt.

        var forwardView = $ionicHistory.forwardView();
        if (forwardView && forwardView.stateName === 'site.mod_scorm-player') {
            $scope.scormLoaded = false;
            scrollView.scrollTop();
            // Add a delay to make sure the player has started the last writing calls so we can detect conflicts.
            $timeout(function() {
                refreshData().finally(function() {
                    $scope.scormLoaded = true;
                });
            }, 500);
        }
    });

    // Refresh data if this SCORM is synchronized automatically.
    var syncObserver = $mmEvents.on(mmaModScormEventAutomSynced, function(data) {
        if (data && data.siteid == $mmSite.getId() && data.scormid == scorm.id) {
            $scope.scormLoaded = false;
            scrollView.scrollTop();
            fetchScormData().finally(function() {
                $scope.scormLoaded = true;
            });
        }
    });

    $scope.$on('$destroy', function() {
        statusObserver && statusObserver.off && statusObserver.off();
        syncObserver && syncObserver.off && syncObserver.off();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM player controller.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc controller
 * @name mmaModScormPlayerCtrl
 */
.controller('mmaModScormPlayerCtrl', ["$scope", "$stateParams", "$mmaModScorm", "$mmUtil", "$ionicPopover", "$mmaModScormHelper", "$mmEvents", "$timeout", "$q", "mmaModScormEventUpdateToc", "mmaModScormEventLaunchNextSco", "mmaModScormEventLaunchPrevSco", "$mmaModScormDataModel12", "mmaModScormEventGoOffline", "$mmaModScormSync", function($scope, $stateParams, $mmaModScorm, $mmUtil, $ionicPopover, $mmaModScormHelper,
            $mmEvents, $timeout, $q, mmaModScormEventUpdateToc, mmaModScormEventLaunchNextSco, mmaModScormEventLaunchPrevSco,
            $mmaModScormDataModel12, mmaModScormEventGoOffline, $mmaModScormSync) {

    var scorm = $stateParams.scorm || {},
        mode = $stateParams.mode || $mmaModScorm.MODENORMAL,
        newAttempt = $stateParams.newAttempt,
        organizationId = $stateParams.organizationId,
        currentSco,
        attempt,
        userData,
        apiInitialized = false,
        offline = false;

    $scope.title = scorm.name; // We use SCORM name at start, later we'll use the SCO title.
    $scope.scorm = scorm;
    $scope.loadingToc = true;

    if (scorm.popup) {
        // If we receive a value <= 100 we need to assume it's a percentage.
        if (scorm.width <= 100) {
            scorm.width = scorm.width + '%';
        }
        if (scorm.height <= 100) {
            scorm.height = scorm.height + '%';
        }
    }

    // Fetch data needed to play the SCORM.
    function fetchData() {
        // Wait for any ongoing sync to finish. We won't sync a SCORM while it's being played.
        return $mmaModScormSync.waitForSync(scorm.id).then(function() {
            // Get attempts data.
            return $mmaModScorm.getAttemptCount(scorm.id).then(function(attemptsData) {
                return determineAttemptAndMode(attemptsData).then(function() {
                    // Fetch TOC and get user data.
                    var promises = [];
                    promises.push(fetchToc());
                    promises.push($mmaModScorm.getScormUserData(scorm.id, attempt, offline).then(function(data) {
                        userData = data;
                    }));

                    return $q.all(promises);
                });
            }).catch(showError);
        });
    }

    // Determine the attempt to use, the mode (normal/preview) and if it's offline or online.
    function determineAttemptAndMode(attemptsData) {
        return $mmaModScormHelper.determineAttemptToContinue(scorm, attemptsData).then(function(data) {
            attempt = data.number;
            offline = data.offline;
            if (attempt != attemptsData.lastAttempt.number) {
                $scope.attemptToContinue = attempt;
            }

            // Check if current attempt is incomplete.
            var promise;
            if (attempt > 0) {
                promise = $mmaModScorm.isAttemptIncomplete(scorm.id, attempt, offline);
            } else {
                // User doesn't have attempts. Last attempt is not incomplete (since he doesn't have any).
                promise = $q.when(false);
            }

            return promise.then(function(incomplete) {
                // Determine mode and attempt to use.
                var result = $mmaModScorm.determineAttemptAndMode(scorm, mode, attempt, newAttempt, incomplete);

                if (result.attempt > attempt) {
                    // We're creating a new attempt.
                    if (offline) {
                        // Last attempt was offline, so we'll create a new offline attempt.
                        promise = $mmaModScormHelper.createOfflineAttempt(scorm, result.attempt, attemptsData.online.length);
                    } else {
                        // Last attempt was online, verify that we can create a new online attempt. We ignore cache.
                        promise = $mmaModScorm.getScormUserData(scorm.id, result.attempt, false, undefined, undefined, true)
                                    .catch(function() {
                            // Cannot communicate with the server, create an offline attempt.
                            offline = true;
                            return $mmaModScormHelper.createOfflineAttempt(scorm, result.attempt, attemptsData.online.length);
                        });
                    }
                } else {
                    promise = $q.when();
                }

                return promise.then(function() {
                    mode = result.mode;
                    newAttempt = result.newAttempt;
                    attempt = result.attempt;
                    $scope.isBrowse = mode === $mmaModScorm.MODEBROWSE;
                    $scope.isReview = mode === $mmaModScorm.MODEREVIEW;
                });
            });
        });
    }

    // Show error and reject.
    function showError(message) {
        if (message) {
            $mmUtil.showErrorModal(message);
        } else {
            $mmUtil.showErrorModal('mma.mod_scorm.errorgetscorm', true);
        }
        return $q.reject();
    }

    // Fetch TOC.
    function fetchToc() {
        $scope.loadingToc = true;
        // We need to check incomplete again: attempt number might have changed in determineAttemptAndMode,
        // or attempt status might have changed due to an action in the current SCO.
        return $mmaModScorm.isAttemptIncomplete(scorm.id, attempt, offline).then(function(incomplete) {
            scorm.incomplete = incomplete;

            // Get TOC.
            return $mmaModScorm.getOrganizationToc(scorm.id, organizationId, attempt, offline).then(function(toc) {
                $scope.toc = $mmaModScorm.formatTocToArray(toc);
                // Get images for each SCO.
                angular.forEach($scope.toc, function(sco) {
                    sco.image = $mmaModScorm.getScoStatusIcon(sco, scorm.incomplete);
                });
                // Determine current SCO if param is set.
                if ($stateParams.scoId > 0) {
                    // SCO set by parameter, get it from TOC.
                    currentSco = $mmaModScormHelper.getScoFromToc($scope.toc, $stateParams.scoId);
                }

                if (!currentSco) {
                    // No SCO defined. Get the first valid one.
                    return $mmaModScormHelper.getFirstSco(scorm.id, $scope.toc, organizationId, attempt, offline)
                            .then(function(sco) {
                        if (sco) {
                            currentSco = sco;
                        } else {
                            // We couldn't find a SCO to load: they're all inactive or without launch URL.
                            $scope.errorMessage = 'mma.mod_scorm.errornovalidsco';
                        }
                    });
                }
            });
        }).finally(function() {
            $scope.loadingToc = false;
        });
    }

    // Calculate the next and previous SCO.
    function calculateNextAndPreviousSco(scoId) {
        $scope.previousSco = $mmaModScormHelper.getPreviousScoFromToc($scope.toc, scoId);
        $scope.nextSco = $mmaModScormHelper.getNextScoFromToc($scope.toc, scoId);
    }

    // Load a SCO.
    function loadSco(sco) {
        // Setup API.
        if (!apiInitialized) {
            $mmaModScormDataModel12.initAPI(scorm, sco.id, attempt, userData, mode, offline);
            apiInitialized = true;
        } else {
            $mmaModScormDataModel12.loadSco(sco.id);
        }

        currentSco = sco;
        $scope.title = sco.title || scorm.name; // Try to use SCO title.
        calculateNextAndPreviousSco(sco.id);
        $mmaModScorm.getScoSrc(scorm, sco).then(function(src) {
            if ($scope.src && src.toString() == $scope.src.toString()) {
                // Re-loading same page. Set it to empty and then re-set the src in the next digest so it detects it has changed.
                $scope.src = '';
                $timeout(function() {
                    $scope.src = src;
                });
            } else {
                $scope.src = src;
            }
        });

        if (sco.scormtype == 'asset') {
            // Mark the asset as completed.
            var tracks = [{
                element: 'cmi.core.lesson_status',
                value: 'completed'
            }];
            $mmaModScorm.saveTracks(sco.id, attempt, tracks, offline, scorm).catch(function() {
                // Error saving data. We'll go offline if we're online and the asset is not marked as completed already.
                if (!offline) {
                    return $mmaModScorm.getScormUserData(scorm.id, attempt, offline).then(function(data) {
                        if (!data[sco.id] || data[sco.id].userdata['cmi.core.lesson_status'] != 'completed') {
                            // Go offline.
                            return $mmaModScormHelper.convertAttemptToOffline(scorm, attempt).then(function() {
                                offline = true;
                                $mmaModScormDataModel12.setOffline(true);
                                return $mmaModScorm.saveTracks(sco.id, attempt, tracks, offline, scorm);
                            }).catch(showError);
                        }
                    });
                }
            }).then(function() {
                // Refresh TOC, some prerequisites might have changed.
                refreshToc();
            });
        }

        // Trigger SCO launch event.
        $mmaModScorm.logLaunchSco(scorm.id, sco.id);
    }

    // Refresh the TOC.
    function refreshToc() {
        $mmaModScorm.invalidateAllScormData(scorm.id).finally(function() {
            fetchToc().catch(showError);
        });
    }

    // Set SCORM start time.
    function setStartTime(scoId) {
        var tracks = [{
            element: 'x.start.time',
            value: $mmUtil.timestamp()
        }];
        return $mmaModScorm.saveTracks(scoId, attempt, tracks, offline, scorm).then(function() {
            if (!offline) {
                // New online attempt created, update cached data about online attempts.
                $mmaModScorm.getAttemptCount(scorm.id, undefined, undefined, false, true);
            }
        });
    }

    $scope.showToc = $mmaModScorm.displayTocInPlayer(scorm);
    if ($scope.showToc) {
        // Setup TOC popover.
        $ionicPopover.fromTemplateUrl('addons/mod_scorm/templates/toc.html', {
            scope: $scope,
        }).then(function(popover) {
            $scope.popover = popover;
        });
    }

    // Fetch the SCORM data.
    fetchData().then(function() {
        if (currentSco) {
            // Set start time if it's a new attempt.
            var promise = newAttempt ? setStartTime(currentSco.id) : $q.when();
            return promise.catch(showError).finally(function() {
                // Load SCO.
                loadSco(currentSco);
            });
        }
    }).finally(function() {
        $scope.loaded = true;
    });

    $scope.loadSco = function(sco) {
        if (!sco.prereq || !sco.isvisible || !sco.launch) {
            return;
        }

        $scope.popover.hide();
        loadSco(sco);
    };

    // Listen for events to update the TOC and navigate through SCOs.
    var tocObserver = $mmEvents.on(mmaModScormEventUpdateToc, function(data) {
        if (data.scormid === scorm.id) {
            if (offline) {
                // Wait a bit to make sure data is stored.
                $timeout(refreshToc, 100);
            } else {
                refreshToc();
            }
        }
    });

    var launchNextObserver = $mmEvents.on(mmaModScormEventLaunchNextSco, function(data) {
        if (data.scormid === scorm.id && $scope.nextSco) {
            loadSco($scope.nextSco);
        }
    });

    var launchPrevObserver = $mmEvents.on(mmaModScormEventLaunchPrevSco, function(data) {
        if (data.scormid === scorm.id && $scope.previousSco) {
            loadSco($scope.previousSco);
        }
    });

    var goOfflineObserver = $mmEvents.on(mmaModScormEventGoOffline, function(data) {
        if (data.scormid === scorm.id && !offline) {
            offline = true;
            $timeout(function() {
                // Wait a bit to prevent collisions between this store and SCORM API's store.
                $mmaModScormHelper.convertAttemptToOffline(scorm, attempt).catch(showError).finally(function() {
                    refreshToc();
                });
            }, 200);
        }
    });

    // Empty src when leaving the state so unload event is triggered in the iframe.
    $scope.$on('$ionicView.beforeLeave', function() {
        $scope.src = '';
    });

    $scope.$on('$destroy', function() {
        tocObserver && tocObserver.off && tocObserver.off();
        launchNextObserver && launchNextObserver.off && launchNextObserver.off();
        launchPrevObserver && launchPrevObserver.off && launchPrevObserver.off();
        goOfflineObserver && goOfflineObserver.off && goOfflineObserver.off();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM data model implementation for version 1.2.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormDataModel12
 */
.factory('$mmaModScormDataModel12', ["$mmaModScorm", "$mmEvents", "$window", "mmaModScormEventLaunchNextSco", "mmaModScormEventLaunchPrevSco", "mmaModScormEventUpdateToc", "mmaModScormEventGoOffline", function($mmaModScorm, $mmEvents, $window, mmaModScormEventLaunchNextSco,
            mmaModScormEventLaunchPrevSco, mmaModScormEventUpdateToc, mmaModScormEventGoOffline) {
    var self = {};

    /**
     * Initialize the global SCORM API class.
     *
     * @param  {Object} scorm    The SCORM object.
     * @param  {Number} scoId    The SCO id.
     * @param  {Number} attempt  The attempt number.
     * @param  {Object} userData The user default data.
     * @param  {String} mode     Mode. One of $mmaModScorm#MODE constants.
     * @param  {Boolean} offline True if attempt is offline, false otherwise.
     */
    function SCORMAPI(scorm, scoId, attempt, userData, mode, offline) {

        // Contains all the current values for all the data model elements for each SCO.
        var currentUserData = {},
            self = this;

        // Current SCO Id.
        self.scoId = scoId;
        self.offline = offline;

        // Convenience function to trigger events.
        function triggerEvent(name) {
            $mmEvents.trigger(name, {
                scormid: scorm.id,
                scoid: self.scoId,
                attempt: attempt
            });
        }

        // Standard Data Type Definition.
        var CMIString256 = '^[\\u0000-\\uFFFF]{0,255}$';
        var CMIString4096 = '^[\\u0000-\\uFFFF]{0,4096}$';
        var CMITime = '^([0-2]{1}[0-9]{1}):([0-5]{1}[0-9]{1}):([0-5]{1}[0-9]{1})(\.[0-9]{1,2})?$';
        var CMITimespan = '^([0-9]{2,4}):([0-9]{2}):([0-9]{2})(\.[0-9]{1,2})?$';
        var CMIInteger = '^\\d+$';
        var CMISInteger = '^-?([0-9]+)$';
        var CMIDecimal = '^-?([0-9]{0,3})(\.[0-9]*)?$';
        var CMIIdentifier = '^[\\u0021-\\u007E]{0,255}$';
        var CMIFeedback = CMIString256; // This must be redefined.
        var CMIIndex = '[._](\\d+).';

        // Vocabulary Data Type Definition.
        var CMIStatus = '^passed$|^completed$|^failed$|^incomplete$|^browsed$';
        var CMIStatus2 = '^passed$|^completed$|^failed$|^incomplete$|^browsed$|^not attempted$';
        var CMIExit = '^time-out$|^suspend$|^logout$|^$';
        var CMIType = '^true-false$|^choice$|^fill-in$|^matching$|^performance$|^sequencing$|^likert$|^numeric$';
        var CMIResult = '^correct$|^wrong$|^unanticipated$|^neutral$|^([0-9]{0,3})?(\.[0-9]*)?$';
        var NAVEvent = '^previous$|^continue$';

        // Children lists.
        var cmi_children = 'core,suspend_data,launch_data,comments,objectives,student_data,student_preference,interactions';
        var core_children = 'student_id,student_name,lesson_location,credit,lesson_status,entry,score,total_time,lesson_mode,exit,session_time';
        var score_children = 'raw,min,max';
        var comments_children = 'content,location,time';
        var objectives_children = 'id,score,status';
        var correct_responses_children = 'pattern';
        var student_data_children = 'mastery_score,max_time_allowed,time_limit_action';
        var student_preference_children = 'audio,language,speed,text';
        var interactions_children = 'id,objectives,time,type,correct_responses,weighting,student_response,result,latency';

        // Data ranges.
        var score_range = '0#100';
        var audio_range = '-1#100';
        var speed_range = '-100#100';
        var weighting_range = '-100#100';
        var text_range = '-1#1';

        // Prepare the definition array containing the default values.
        var def = {};
        // We need an extra object that will contain the objectives and interactions data (all the .n. elements).
        var defExtra = {};

        angular.forEach(userData, function(sco) {
            def[sco.scoid] = sco.defaultdata;
            defExtra[sco.scoid] = sco.userdata;
        });

        // The SCORM 1.2 data model.
        // Set up data model for each sco.
        var datamodel = {};
        for (var scoid in def) {
            datamodel[scoid] = {
                'cmi._children':{'defaultvalue':cmi_children, 'mod':'r', 'writeerror':'402'},
                'cmi._version':{'defaultvalue':'3.4', 'mod':'r', 'writeerror':'402'},
                'cmi.core._children':{'defaultvalue':core_children, 'mod':'r', 'writeerror':'402'},
                'cmi.core.student_id':{'defaultvalue':def[scoid]['cmi.core.student_id'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.student_name':{'defaultvalue':def[scoid]['cmi.core.student_name'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_location':{'defaultvalue':def[scoid]['cmi.core.lesson_location'], 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.credit':{'defaultvalue':def[scoid]['cmi.core.credit'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_status':{'defaultvalue':def[scoid]['cmi.core.lesson_status'], 'format':CMIStatus, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.entry':{'defaultvalue':def[scoid]['cmi.core.entry'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.score._children':{'defaultvalue':score_children, 'mod':'r', 'writeerror':'402'},
                'cmi.core.score.raw':{'defaultvalue':def[scoid]['cmi.core.score.raw'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.score.max':{'defaultvalue':def[scoid]['cmi.core.score.max'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.score.min':{'defaultvalue':def[scoid]['cmi.core.score.min'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.total_time':{'defaultvalue':def[scoid]['cmi.core.total_time'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_mode':{'defaultvalue':def[scoid]['cmi.core.lesson_mode'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.exit':{'defaultvalue':def[scoid]['cmi.core.exit'], 'format':CMIExit, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.core.session_time':{'format':CMITimespan, 'mod':'w', 'defaultvalue':'00:00:00', 'readerror':'404', 'writeerror':'405'},
                'cmi.suspend_data':{'defaultvalue':def[scoid]['cmi.suspend_data'], 'format':CMIString4096, 'mod':'rw', 'writeerror':'405'},
                'cmi.launch_data':{'defaultvalue':def[scoid]['cmi.launch_data'], 'mod':'r', 'writeerror':'403'},
                'cmi.comments':{'defaultvalue':def[scoid]['cmi.comments'], 'format':CMIString4096, 'mod':'rw', 'writeerror':'405'},
                // Deprecated evaluation attributes.
                'cmi.evaluation.comments._count':{'defaultvalue':'0', 'mod':'r', 'writeerror':'402'},
                'cmi.evaluation.comments._children':{'defaultvalue':comments_children, 'mod':'r', 'writeerror':'402'},
                'cmi.evaluation.comments.n.content':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.evaluation.comments.n.location':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.evaluation.comments.n.time':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMITime, 'mod':'rw', 'writeerror':'405'},
                'cmi.comments_from_lms':{'mod':'r', 'writeerror':'403'},
                'cmi.objectives._children':{'defaultvalue':objectives_children, 'mod':'r', 'writeerror':'402'},
                'cmi.objectives._count':{'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.objectives.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score._children':{'pattern':CMIIndex, 'mod':'r', 'writeerror':'402'},
                'cmi.objectives.n.score.raw':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score.min':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score.max':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.status':{'pattern':CMIIndex, 'format':CMIStatus2, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_data._children':{'defaultvalue':student_data_children, 'mod':'r', 'writeerror':'402'},
                'cmi.student_data.mastery_score':{'defaultvalue':def[scoid]['cmi.student_data.mastery_score'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_data.max_time_allowed':{'defaultvalue':def[scoid]['cmi.student_data.max_time_allowed'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_data.time_limit_action':{'defaultvalue':def[scoid]['cmi.student_data.time_limit_action'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_preference._children':{'defaultvalue':student_preference_children, 'mod':'r', 'writeerror':'402'},
                'cmi.student_preference.audio':{'defaultvalue':def[scoid]['cmi.student_preference.audio'], 'format':CMISInteger, 'range':audio_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.language':{'defaultvalue':def[scoid]['cmi.student_preference.language'], 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.speed':{'defaultvalue':def[scoid]['cmi.student_preference.speed'], 'format':CMISInteger, 'range':speed_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.text':{'defaultvalue':def[scoid]['cmi.student_preference.text'], 'format':CMISInteger, 'range':text_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.interactions._children':{'defaultvalue':interactions_children, 'mod':'r', 'writeerror':'402'},
                'cmi.interactions._count':{'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.objectives._count':{'pattern':CMIIndex, 'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.objectives.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.time':{'pattern':CMIIndex, 'format':CMITime, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.type':{'pattern':CMIIndex, 'format':CMIType, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.correct_responses._count':{'pattern':CMIIndex, 'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.correct_responses.n.pattern':{'pattern':CMIIndex, 'format':CMIFeedback, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.weighting':{'pattern':CMIIndex, 'format':CMIDecimal, 'range':weighting_range, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.student_response':{'pattern':CMIIndex, 'format':CMIFeedback, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.result':{'pattern':CMIIndex, 'format':CMIResult, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.latency':{'pattern':CMIIndex, 'format':CMITimespan, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'nav.event':{'defaultvalue':'', 'format':NAVEvent, 'mod':'w', 'readerror':'404', 'writeerror':'405'}
            };

            currentUserData[scoid] = {};

            // Load default values.
            for (var element in datamodel[scoid]) {
                if (element.match(/\.n\./) === null) {
                    if (typeof datamodel[scoid][element].defaultvalue != 'undefined') {
                        currentUserData[scoid][element] = datamodel[scoid][element].defaultvalue;
                    }
                }
            }

            // Load initial user data for current SCO.
            for (element in def[scoid]) {
                if (element.match(/\.n\./) === null) {
                    if (typeof datamodel[scoid][element].defaultvalue != 'undefined') {
                        currentUserData[scoid][element] = datamodel[scoid][element].defaultvalue;
                    } else if (typeof defExtra[scoid][element] != 'undefined') {
                        // Check in user data values.
                        currentUserData[scoid][element] = defExtra[scoid][element];
                    } else {
                        currentUserData[scoid][element] = '';
                    }
                }
            }

            // Load interactions and objectives, and init the counters.
            var expression = new RegExp(CMIIndex,'g');
            var elementDotFormat, counterElement, currentCounterIndex, currentN;
            for (element in defExtra[scoid]) {
                counterElement = '';
                currentCounterIndex = 0;
                // This check for an indexed element. cmi.objectives.1.id or cmi.objectives_1.id.
                if (element.match(expression)) {
                    // Normalize to the expected value according the standard.
                    // Moodle stores this values using _n. instead .n.
                    elementDotFormat = element.replace(expression, ".$1.");
                    currentUserData[scoid][elementDotFormat] = defExtra[scoid][element];

                    // Get the correct counter and current index.
                    if (elementDotFormat.indexOf("cmi.evaluation.comments") === 0) {
                        counterElement = "cmi.evaluation.comments._count";
                        currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                    } else if (elementDotFormat.indexOf("cmi.objectives") === 0) {
                        counterElement = "cmi.objectives._count";
                        currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                    } else if (elementDotFormat.indexOf("cmi.interactions") === 0) {
                        if (elementDotFormat.indexOf(".objectives.") > 0) {
                            currentN = elementDotFormat.match(/cmi.interactions.(\d+)./)[1];
                            currentCounterIndex = elementDotFormat.match(/objectives.(\d+)./)[1];
                            counterElement = "cmi.interactions." + currentN + ".objectives._count";
                        } else if (elementDotFormat.indexOf(".correct_responses.") > 0) {
                            currentN = elementDotFormat.match(/cmi.interactions.(\d+)./)[1];
                            currentCounterIndex = elementDotFormat.match(/correct_responses.(\d+)./)[1];
                            counterElement = "cmi.interactions." + currentN + ".correct_responses._count";
                        } else {
                            counterElement = "cmi.interactions._count";
                            currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                        }
                    }

                    if (counterElement) {
                        if (typeof currentUserData[scoid][counterElement] == "undefined") {
                            currentUserData[scoid][counterElement] = 0;
                        }
                        // Check if we need to sum.
                        if (parseInt(currentCounterIndex) == parseInt(currentUserData[scoid][counterElement])) {
                            currentUserData[scoid][counterElement] = parseInt(currentUserData[scoid][counterElement]) + 1;
                        }
                        if (parseInt(currentCounterIndex) > parseInt(currentUserData[scoid][counterElement])) {
                            currentUserData[scoid][counterElement] = parseInt(currentCounterIndex) - 1;
                        }
                    }

                }
            }

            // Set default status.
            if (currentUserData[scoid]['cmi.core.lesson_status'] === '') {
                currentUserData[scoid]['cmi.core.lesson_status'] = 'not attempted';
            }

            // Define mode and credit.
            currentUserData[scoid]['cmi.core.credit'] = mode == $mmaModScorm.MODENORMAL ? 'credit' : 'no-credit';
            currentUserData[scoid]['cmi.core.lesson_mode'] = mode;
        }

        // API helper methods.

        /**
         * Get the value of the given element from the non-persistent (current) user data.
         *
         * @param  {String} el The element
         * @return {String}    The element value
         */
        function getEl(el) {
            if (typeof currentUserData[self.scoId] != 'undefined' && typeof currentUserData[self.scoId][el] != 'undefined') {
                return currentUserData[self.scoId][el];
            }
            return '';
        }

        /**
         * Set the value of the given element in the non-persistent (current) user data.
         *
         * @param  {String} el The element
         * @param  {String} value The value
         */
        function setEl(el, value) {
            if (typeof currentUserData[self.scoId] == 'undefined') {
                currentUserData[self.scoId] = {};
            }
            currentUserData[self.scoId][el] = value;
        }

        /**
         * Utility function for cloning an object
         *
         * @param {Object} obj The object to  be cloned
         * @return {Object} The object cloned
         */
        function CloneObj(obj){
            if(obj == null || typeof(obj) != 'object') {
                return obj;
            }

            var temp = new obj.constructor(); // Changed (twice).
            for(var key in obj) {
                temp[key] = CloneObj(obj[key]);
            }

            return temp;
        }

        /**
         * Utility function for adding two times in format hh:mm:ss.
         *
         * @param {String} first  First time.
         * @param {String} second Second time.
         * @return {String}       Total time.
         */
        function AddTime (first, second) {
            var sFirst = first.split(":");
            var sSecond = second.split(":");
            var cFirst = sFirst[2].split(".");
            var cSecond = sSecond[2].split(".");
            var change = 0;

            FirstCents = 0;  //Cents
            if (cFirst.length > 1) {
                FirstCents = parseInt(cFirst[1],10);
            }
            SecondCents = 0;
            if (cSecond.length > 1) {
                SecondCents = parseInt(cSecond[1],10);
            }
            var cents = FirstCents + SecondCents;
            change = Math.floor(cents / 100);
            cents = cents - (change * 100);
            if (Math.floor(cents) < 10) {
                cents = "0" + cents.toString();
            }

            var secs = parseInt(cFirst[0],10) + parseInt(cSecond[0],10) + change;  //Seconds
            change = Math.floor(secs / 60);
            secs = secs - (change * 60);
            if (Math.floor(secs) < 10) {
                secs = "0" + secs.toString();
            }

            mins = parseInt(sFirst[1],10) + parseInt(sSecond[1],10) + change;   //Minutes
            change = Math.floor(mins / 60);
            mins = mins - (change * 60);
            if (mins < 10) {
                mins = "0" + mins.toString();
            }

            hours = parseInt(sFirst[0],10) + parseInt(sSecond[0],10) + change;  //Hours
            if (hours < 10) {
                hours = "0" + hours.toString();
            }

            if (cents != '0') {
                return hours + ":" + mins + ":" + secs + '.' + cents;
            } else {
                return hours + ":" + mins + ":" + secs;
            }
        }

        /**
         * Utility function for calculating the total time spent in the SCO.
         */
        function TotalTime() {
            total_time = AddTime(getEl('cmi.core.total_time'), getEl('cmi.core.session_time'));
            return {'element': 'cmi.core.total_time', value: total_time};
        }

        /**
         * Persist the current user data (this is usually called by LMSCommit)
         *
         * @param {Bool} storetotaltime If true, we need to calculate the total time too
         * @return {Bool} [description]
         */
        function StoreData(storetotaltime) {
            if (storetotaltime) {
                if (getEl('cmi.core.lesson_status') == 'not attempted') {
                    setEl('cmi.core.lesson_status', 'completed');
                }
                if (getEl('cmi.core.lesson_mode') == $mmaModScorm.MODENORMAL) {
                    if (getEl('cmi.core.credit') == 'credit') {
                        if (getEl('cmi.student_data.mastery_score') !== '' && getEl('cmi.core.score.raw') !== '') {
                            if (parseFloat(getEl('cmi.core.score.raw')) >= parseFloat(getEl('cmi.student_data.mastery_score'))) {
                                setEl('cmi.core.lesson_status', 'passed');
                            } else {
                                setEl('cmi.core.lesson_status', 'failed');
                            }
                        }
                    }
                }
                if (getEl('cmi.core.lesson_mode') == $mmaModScorm.MODEBROWSE) {
                    if (datamodel[self.scoId]['cmi.core.lesson_status'].defaultvalue == '' && getEl('cmi.core.lesson_status') == 'not attempted') {
                        setEl('cmi.core.lesson_status', 'browsed');
                    }
                }
                tracks = CollectData();
                tracks.push(TotalTime());
            } else {
                tracks = CollectData();
            }
            var success = $mmaModScorm.saveTracksSync(self.scoId, attempt, tracks, self.offline, scorm, currentUserData);
            if (!self.offline && !success) {
                // Failure storing data in online. Go offline.
                self.offline = true;
                triggerEvent(mmaModScormEventGoOffline);
                return $mmaModScorm.saveTracksSync(self.scoId, attempt, tracks, self.offline, scorm, currentUserData);
            }
            return success;
        }

        /**
         * Collect all the user tracking data that must be persisted in the system, this is usually called by LMSCommit().
         *
         */
        function CollectData() {
            var data = [];
            for (var element in currentUserData[self.scoId]) {
                // Ommit for example the nav. elements.
                if (element.substr(0, 3) == 'cmi') {
                    expression = new RegExp(CMIIndex,'g');

                    // Get the generic name for this element (e.g. convert 'cmi.interactions.1.id' to 'cmi.interactions.n.id')
                    elementmodel = String(element).replace(expression,'.n.');

                    // Ignore the session time element.
                    if (element != "cmi.core.session_time") {

                        // Check if this specific element is not defined in the datamodel,
                        // but the generic element name is.
                        if (typeof datamodel[self.scoId][element] == "undefined" &&
                                typeof datamodel[self.scoId][elementmodel] != "undefined") {

                            // Add this specific element to the data model (by cloning
                            // the generic element) so we can track changes to it.
                            datamodel[self.scoId][element] = CloneObj(datamodel[self.scoId][elementmodel]);
                        }

                        // Check if the current element exists in the datamodel.
                        if (typeof datamodel[self.scoId][element] != "undefined") {

                            // Make sure this is not a read only element.
                            if (datamodel[self.scoId][element].mod != 'r') {

                                var el = {
                                    // Moodle stores the organizations and interactions using _n. instead .n.
                                    'element': element.replace(expression, "_$1."),
                                    'value': getEl(element)
                                };

                                // Check if the element has a default value.
                                if (typeof datamodel[self.scoId][element].defaultvalue != "undefined") {

                                    // Check if the default value is different from the current value.
                                    if (datamodel[self.scoId][element].defaultvalue != el['value'] ||
                                            typeof datamodel[self.scoId][element].defaultvalue != typeof(el['value'])) {

                                        data.push(el);

                                        // Update the element default to reflect the current committed value.
                                        datamodel[self.scoId][element].defaultvalue = el['value'];
                                    }
                                } else {
                                    data.push(el);
                                    // No default value for the element, so set it now.
                                    datamodel[self.scoId][element].defaultvalue = el['value'];
                                }
                            }
                        }
                    }
                }

            }
            return data;
        }

        // API methods now.
        var initialized = false;
        var errorCode;
        var timeout;

        self.LMSInitialize = function(param) {
            errorCode = "0";
            if (param == "") {
                if (!initialized) {
                    initialized = true;
                    errorCode = "0";
                    return "true";
                } else {
                    errorCode = "101";
                }
            } else {
                errorCode = "201";
            }

            return "false";
        };

        self.LMSFinish = function(param) {
            errorCode = "0";
            if (param == "") {
                if (initialized) {
                    initialized = false;
                    result = StoreData(true);
                    if (getEl('nav.event') != '') {
                        if (getEl('nav.event') == 'continue') {
                            triggerEvent(mmaModScormEventLaunchNextSco);
                        } else {
                            triggerEvent(mmaModScormEventLaunchPrevSco);
                        }
                    } else {
                        if (scorm.auto == '1') {
                            triggerEvent(mmaModScormEventLaunchNextSco);
                        }
                    }
                    errorCode = (result) ? '0' : '101';

                    // Trigger TOC update.
                    triggerEvent(mmaModScormEventUpdateToc);
                    return result;
                } else {
                    errorCode = "301";
                }
            } else {
                errorCode = "201";
            }
            return "false";
        };

        self.LMSGetValue = function(element) {
            errorCode = "0";
            if (initialized) {
                if (element != "") {
                    expression = new RegExp(CMIIndex,'g');
                    elementmodel = String(element).replace(expression,'.n.');
                    if (typeof datamodel[self.scoId][elementmodel] != "undefined") {
                        if (datamodel[self.scoId][elementmodel].mod != 'w') {
                            errorCode = "0";
                            return getEl(element);
                        } else {
                            errorCode = datamodel[self.scoId][elementmodel].readerror;
                        }
                    } else {
                        childrenstr = '._children';
                        countstr = '._count';
                        if (elementmodel.substr(elementmodel.length - childrenstr.length,elementmodel.length) == childrenstr) {
                            parentmodel = elementmodel.substr(0,elementmodel.length - childrenstr.length);
                            if (typeof datamodel[self.scoId][parentmodel] != "undefined") {
                                errorCode = "202";
                            } else {
                                errorCode = "201";
                            }
                        } else if (elementmodel.substr(elementmodel.length - countstr.length,elementmodel.length) == countstr) {
                            parentmodel = elementmodel.substr(0,elementmodel.length - countstr.length);
                            if (typeof datamodel[self.scoId][parentmodel] != "undefined") {
                                errorCode = "203";
                            } else {
                                errorCode = "201";
                            }
                        } else {
                            errorCode = "201";
                        }
                    }
                } else {
                    errorCode = "201";
                }
            } else {
                errorCode = "301";
            }
            return "";
        };

        self.LMSSetValue = function(element, value) {
            errorCode = "0";
            if (initialized) {
                if (element != "") {
                    expression = new RegExp(CMIIndex,'g');
                    elementmodel = String(element).replace(expression,'.n.');
                    if (typeof datamodel[self.scoId][elementmodel] != "undefined") {
                        if (datamodel[self.scoId][elementmodel].mod != 'r') {
                            expression = new RegExp(datamodel[self.scoId][elementmodel].format);
                            value = value + '';
                            matches = value.match(expression);
                            if (matches != null) {
                                // Create dynamic data model element.
                                if (element != elementmodel) {

                                    // Init default counters and values.
                                    if (element.indexOf("cmi.objectives") === 0) {
                                        currentN = element.match(/cmi.objectives.(\d+)./)[1];
                                        counterElement = "cmi.objectives." + currentN + ".score";
                                        if (typeof currentUserData[self.scoId][counterElement + '._children'] == "undefined") {
                                            setEl(currentUserData[self.scoId][counterElement + '._children'], score_children);
                                            setEl(currentUserData[self.scoId][counterElement + '.raw'], '');
                                            setEl(currentUserData[self.scoId][counterElement + '.min'], '');
                                            setEl(currentUserData[self.scoId][counterElement + '.max'], '');
                                        }

                                    } else if (element.indexOf("cmi.interactions") === 0) {
                                        currentN = element.match(/cmi.interactions.(\d+)./)[1];

                                        counterElement = "cmi.interactions." + currentN + ".objectives._count";
                                        if (typeof currentUserData[self.scoId][counterElement] == "undefined") {
                                            setEl(counterElement, 0);
                                        }
                                        counterElement = "cmi.interactions." + currentN + ".correct_responses._count";
                                        if (typeof currentUserData[self.scoId][counterElement] == "undefined") {
                                            setEl(counterElement, 0);
                                        }
                                    }

                                    elementIndexes = element.split('.');
                                    subelement = 'cmi';
                                    for (i = 1; i < elementIndexes.length - 1; i++) {
                                        elementIndex = elementIndexes[i];
                                        if (elementIndexes[i + 1].match(/^\d+$/)) {
                                            if (typeof currentUserData[self.scoId][subelement + '.' + elementIndex + '._count'] == "undefined") {
                                                setEl(subelement + '.' + elementIndex + '._count', 0);
                                            }
                                            if (elementIndexes[i + 1] == getEl(subelement + '.' + elementIndex + '._count')) {
                                                var count = getEl(subelement + '.' + elementIndex + '._count');
                                                setEl(subelement + '.' + elementIndex + '._count', parseInt(count) + 1);
                                            }
                                            if (elementIndexes[i + 1] > getEl(subelement + '.' + elementIndex + '._count')) {
                                                errorCode = "201";
                                            }
                                            subelement = subelement.concat('.' + elementIndex + '.' + elementIndexes[i + 1]);
                                            i++;
                                        } else {
                                            subelement = subelement.concat('.' + elementIndex);
                                        }
                                    }
                                    element = subelement.concat('.' + elementIndexes[elementIndexes.length - 1]);
                                }
                                //Store data
                                if (errorCode == "0") {
                                    if (scorm.autocommit && !(timeout)) {
                                        timeout = setTimeout(self.LMSCommit, 60000, [""]);
                                    }
                                    if (typeof datamodel[self.scoId][elementmodel].range != "undefined") {
                                        range = datamodel[self.scoId][elementmodel].range;
                                        ranges = range.split('#');
                                        value = value * 1.0;
                                        if ((value >= ranges[0]) && (value <= ranges[1])) {
                                            setEl(element, value);
                                            errorCode = "0";
                                            return "true";
                                        } else {
                                            errorCode = datamodel[self.scoId][elementmodel].writeerror;
                                        }
                                    } else {
                                        if (element == 'cmi.comments') {
                                            setEl('cmi.comments', getEl('cmi.comments') + value);
                                        } else {
                                            setEl(element, value);
                                        }
                                        errorCode = "0";
                                        return "true";
                                    }
                                }
                            } else {
                                errorCode = datamodel[self.scoId][elementmodel].writeerror;
                            }
                        } else {
                            errorCode = datamodel[self.scoId][elementmodel].writeerror;
                        }
                    } else {
                        errorCode = "201";
                    }
                } else {
                    errorCode = "201";
                }
            } else {
                errorCode = "301";
            }
            return "false";
        };

        self.LMSCommit = function(param) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            errorCode = "0";
            if (param == "") {
                if (initialized) {
                    result = StoreData(false);
                    // Trigger TOC update.
                    triggerEvent(mmaModScormEventUpdateToc);

                    errorCode = result ? '0' : '101';
                    return result;
                } else {
                    errorCode = "301";
                }
            } else {
                errorCode = "201";
            }
            return "false";
        };

        self.LMSGetLastError = function() {
            return errorCode;
        };

        var errorString = [];
        errorString["0"] = "No error";
        errorString["101"] = "General exception";
        errorString["201"] = "Invalid argument error";
        errorString["202"] = "Element cannot have children";
        errorString["203"] = "Element not an array - cannot have count";
        errorString["301"] = "Not initialized";
        errorString["401"] = "Not implemented error";
        errorString["402"] = "Invalid set value, element is a keyword";
        errorString["403"] = "Element is read only";
        errorString["404"] = "Element is write only";
        errorString["405"] = "Incorrect data type";

        self.LMSGetErrorString = function(param) {
            if (param != "") {
                return errorString[param];
            } else {
               return "";
            }
        };

        self.LMSGetDiagnostic = function(param) {
            if (param == "") {
                param = errorCode;
            }
            return param;
        };
    }


    /**
     * Prepare the datamodel for SCORM 1.2 populating all the required data.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormDataModel12#initAPI
     * @param  {Object} scorm    The SCORM object.
     * @param  {Number} scoId    The SCO id.
     * @param  {Number} attempt  The attempt number.
     * @param  {Object} userData The user default data.
     * @param  {String} [mode]   Mode. One of $mmaModScorm#MODE constants. By default, MODENORMAL.
     * @param  {Boolean} offline True if attempt is offline, false otherwise.
     */
    self.initAPI = function(scorm, scoId, attempt, userData, mode, offline) {
        mode = mode || $mmaModScorm.MODENORMAL;
        $window.API = new SCORMAPI(scorm, scoId, attempt, userData, mode, offline);
    };

    /**
     * Set a different SCO id for the current API object.
     * The scoId is like a pointer to be able to retrieve the SCO default values and set the new ones in the overall SCORM data structure
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormDataModel12#loadSco
     * @param  {Number} scoId The new SCO id.
     */
    self.loadSco = function(scoId) {
        $window.API.scoId = scoId;
    };

    /**
     * Set offline mode to true or false.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormDataModel12#setOffline
     * @param  {Boolean} offline True if offline, false otherwise.
     */
    self.setOffline = function(offline) {
        $window.API.offline = offline;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Mod scorm handlers.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormHandlers
 */
.factory('$mmaModScormHandlers', ["$mmCourse", "$mmaModScorm", "$mmEvents", "$state", "$mmSite", "$mmaModScormHelper", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModScormComponent", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModScorm, $mmEvents, $state, $mmSite, $mmaModScormHelper,
        $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
        mmaModScormComponent, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModScorm.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn;

                // Create the buttons without action yet. This is to prevent a glitch in the view.
                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download',
                    label: 'mm.core.download'
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true
                };

                $scope.icon = $mmCourse.getModuleIconSrc('scorm');
                $scope.title = module.name;
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_scorm', {module: module, courseid: courseid});
                };

                // Retrieve SCORM to calculate the rest of data.
                $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
                    var revision = scorm.sha1hash,
                        timemodified = 0;

                    function download() {
                        $mmaModScormHelper.confirmDownload(scorm).then(function() {
                            $mmaModScorm.prefetch(scorm).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmaModScormHelper.showDownloadError(scorm);
                                }
                            });
                        });
                    }

                    // Now add the action to the buttons.
                    downloadBtn.action = function(e) {
                        if (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        download();
                    };

                    refreshBtn.action = function(e) {
                        if (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        $mmaModScorm.invalidateContent(scorm.coursemodule).finally(function() {
                            download();
                        });
                    };

                    // Show buttons according to module status.
                    function showStatus(status) {
                        if (status) {
                            $scope.spinner = status === mmCoreDownloading;
                            downloadBtn.hidden = status !== mmCoreNotDownloaded;
                            refreshBtn.hidden = status !== mmCoreOutdated;
                        }
                    }

                    // Listen for changes on this module status.
                    var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                        if (data.siteid === $mmSite.getId() && data.componentId === scorm.coursemodule &&
                                data.component === mmaModScormComponent) {
                            showStatus(data.status);
                        }
                    });

                    // Get current status to decide which icon should be shown.
                    $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                    $scope.$on('$destroy', function() {
                        statusObserver && statusObserver.off && statusObserver.off();
                    });
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModScorm.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a SCORM URL.
            if (url.indexOf('/mod/scorm/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Helper to gather some common SCORM functions.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmCourseHelper
 */
.factory('$mmaModScormHelper', ["$mmaModScorm", "$mmUtil", "$translate", "$q", "$mmaModScormOffline", "$mmaModScormSync", "$mmSite", function($mmaModScorm, $mmUtil, $translate, $q, $mmaModScormOffline, $mmaModScormSync, $mmSite) {

    var self = {},
        elementsToIgnore = ['status', 'score_raw', 'total_time', 'session_time', 'student_id', 'student_name', 'credit',
                            'mode', 'entry']; // List of elements we want to ignore when copying attempts (they're calculated).

    /**
     * Build message to show warnings.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#buildWarningsMessage
     * @param  {String[]} warnings Warnings to show.
     * @return {String}            Message with all the warnings.
     */
    self.buildWarningsMessage = function(warnings) {
        var message = '';
        angular.forEach(warnings, function(warning) {
            if (warning) {
                message = message + '<p>' + warning + '</p>';
            }
        });
        return message;
    };

    /**
     * Creates a new offline attempt based on an existing online attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#convertAttemptToOffline
     * @param  {Object} scorm   SCORM.
     * @param  {Number} attempt Number of the online attempt.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the attempt is created.
     */
    self.convertAttemptToOffline = function(scorm, attempt, siteId) {
        siteId = siteId || $mmSite.getId();

        // Get data from the online attempt.
        return $mmaModScorm.getScormUserData(scorm.id, attempt, false, siteId).then(function(onlineData) {
            // The SCORM API might have written some data to the offline attempt already.
            // We don't want to override it with cached online data.
            return $mmaModScormOffline.getScormUserData(siteId, scorm.id, attempt).catch(function() {
                // Ignore errors.
            }).then(function(offlineData) {
                var dataToStore = angular.copy(onlineData);
                // Filter the data to copy.
                angular.forEach(dataToStore, function(sco) {
                    // Delete calculated data.
                    elementsToIgnore.forEach(function(el) {
                        delete sco.userdata[el];
                    });

                    // Don't override offline data.
                    if (offlineData && offlineData[sco.scoid] && offlineData[sco.scoid].userdata) {
                        var scoUserData = {};
                        angular.forEach(sco.userdata, function(value, element) {
                            if (!offlineData[sco.scoid].userdata[element]) {
                                // This element is not stored in offline, we can save it.
                                scoUserData[element] = value;
                            }
                        });
                        sco.userdata = scoUserData;
                    }
                });

                return $mmaModScormOffline.createNewAttempt(siteId, scorm, undefined, attempt, dataToStore, onlineData);
            });
        }).catch(function() {
            // Shouldn't happen.
            return $q.reject($translate.instant('mma.mod_scorm.errorcreateofflineattempt'));
        });
    };

    /**
     * Creates a new offline attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#createOfflineAttempt
     * @param  {Object} scorm      SCORM.
     * @param  {Number} newAttempt Number of the new attempt.
     * @param  {Number} lastOnline Number of the last online attempt.
     * @param {String} [siteId]    Site ID. If not defined, current site.
     * @return {Promise}           Promise resolved when the attempt is created.
     */
    self.createOfflineAttempt = function(scorm, newAttempt, lastOnline, siteId) {
        siteId = siteId || $mmSite.getId();
        // Try to get data from online attempts.
        return self.searchOnlineAttemptUserData(scorm.id, lastOnline, siteId).then(function(userData) {
            // We're creating a new attempt, remove all the user data that is not needed for a new attempt.
            // We need to get the SCO data from here because WS get_scoes doesn't return sco_data in Moodle 3.0.
            angular.forEach(userData, function(sco) {
                var filtered = {};
                angular.forEach(sco.userdata, function(value, element) {
                    if (element.indexOf('.') == -1 && elementsToIgnore.indexOf(element) == -1) {
                        // The element doesn't use a dot notation, probably SCO data.
                        filtered[element] = value;
                    }
                });
                sco.userdata = filtered;
            });
            return $mmaModScormOffline.createNewAttempt(siteId, scorm, undefined, newAttempt, userData);
        }).catch(function() {
            return $q.reject($translate.instant('mma.mod_scorm.errorcreateofflineattempt'));
        });
    };

    /**
     * Show a confirm dialog if needed. If SCORM doesn't have size, try to calculate it.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#confirmDownload
     * @param {Object} scorm SCORM to download.
     * @return {Promise}     Promise resolved if the user confirms or no confirmation needed.
     */
    self.confirmDownload = function(scorm) {
        var promise;
        if (!scorm.packagesize) {
            // We don't have package size, try to calculate it.
            promise = $mmaModScorm.calculateScormSize(scorm).then(function(size) {
                // Store it so we don't have to calculate it again when using the same object.
                scorm.packagesize = size;
                return size;
            });
        } else {
            promise = $q.when(scorm.packagesize);
        }

        return promise.then(function(size) {
            return $mmUtil.confirmDownloadSize(size);
        });
    };

    /**
     * Determines the attempt to continue/review. It will be:
     * - The last incomplete online attempt if it hasn't been continued in offline and all offline attempts are complete.
     * - The attempt with highest number without surpassing max attempts otherwise.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#determineAttemptToContinue
     * @param  {Object} scorm    SCORM.
     * @param  {Object} attempts Result of $mmaModScorm#getAttemptCount.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with an object with 2 properties: 'number' and 'offline'.
     */
    self.determineAttemptToContinue = function(scorm, attempts, siteId) {
        siteId = siteId || $mmSite.getId();
        var lastOnline,
            result = {
                number: 0,
                offline: false
            };

        // Get the last attempt. It'll be the highest number as long as it doesn't surpass the max number of attempts.
        function getLastBeforeMax() {
            if (scorm.maxattempt != 0 && attempts.lastAttempt.number > scorm.maxattempt) {
                result.number = scorm.maxattempt;
                result.offline = attempts.offline.indexOf(scorm.maxattempt) > -1;
            } else {
                result.number = attempts.lastAttempt.number;
                result.offline = attempts.lastAttempt.offline;
            }
        }

        // Get last online attempt.
        if (attempts.online.length) {
            lastOnline = Math.max.apply(Math, attempts.online);
        }

        if (lastOnline) {
            // Check if last online incomplete.
            var hasOffline = attempts.offline.indexOf(lastOnline) > -1;
            return $mmaModScorm.isAttemptIncomplete(scorm.id, lastOnline, hasOffline, false, siteId).then(function(incomplete) {
                if (incomplete) {
                    result.number = lastOnline;
                    result.offline = hasOffline;
                } else {
                    getLastBeforeMax();
                }
                return result;
            });
        } else {
            getLastBeforeMax();
            return $q.when(result);
        }
    };

    /**
     * Get the first SCO to load in a SCORM. If a non-empty TOC is provided, it will be the first valid SCO in the TOC.
     * Otherwise, it will be the first valid SCO returned by $mmaModScorm#getScos.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getFirstSco
     * @param {String} scormId        Scorm ID.
     * @param {Object[]} [toc]        SCORM's TOC.
     * @param {String} [organization] Organization to use.
     * @param {Number} attempt        Attempt number.
     * @param {Boolean} offline       True if attempt is offline, false otherwise.
     * @param {String} [siteId]       Site ID. If not defined, current site.
     * @return {Promise}              Promise resolved with the first SCO.
     */
    self.getFirstSco = function(scormId, toc, organization, attempt, offline, siteId) {
        siteId = siteId || $mmSite.getId();
        var promise;
        if (toc && toc.length) {
            promise = $q.when(toc);
        } else {
            // SCORM doesn't have a TOC. Get all the scos.
            promise = $mmaModScorm.getScosWithData(scormId, organization, attempt, offline, false, siteId);
        }

        return promise.then(function(scos) {
            // Search the first valid SCO.
            for (var i = 0; i < scos.length; i++) {
                var sco = scos[i];
                if (sco.isvisible && sco.prereq && sco.launch) {
                    return sco;
                }
            }
        });
    };

    /**
     * Given a TOC in array format (@see $mmaModScorm#formatTocToArray) and a scoId, return the next available SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getNextScoFromToc
     * @param  {Object[]} toc SCORM's TOC.
     * @param  {Number} scoId SCO ID.
     * @return {Object}       Next SCO.
     */
    self.getNextScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                // We found the current SCO. Now let's search the next visible SCO with fulfilled prerequisites.
                for (var j = i + 1; j < len; j++) {
                    if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {
                        return toc[j];
                    }
                }
                break;
            }
        }
    };

    /**
     * Given a TOC in array format (@see $mmaModScorm#formatTocToArray) and a scoId, return the previous available SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getPreviousScoFromToc
     * @param  {Object[]} toc SCORM's TOC.
     * @param  {Number} scoId SCO ID.
     * @return {Object}       Previous SCO.
     */
    self.getPreviousScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                // We found the current SCO. Now let's search the previous visible SCO with fulfilled prerequisites.
                for (var j = i - 1; j >= 0; j--) {
                    if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {
                        return toc[j];
                    }
                }
                break;
            }
        }
    };

    /**
     * Given a TOC in array format (@see $mmaModScorm#formatTocToArray) and a scoId, return the SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getScoFromToc
     * @param  {Object[]} toc SCORM's TOC.
     * @param  {Number} scoId SCO ID.
     * @return {Object}       SCO.
     */
    self.getScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                return toc[i];
            }
        }
    };

    /**
     * Get SCORM sync time in a human readable format.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getScormReadableSyncTime
     * @param  {Number} scormId SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the readable time.
     */
    self.getScormReadableSyncTime = function(scormId, siteId) {
        return $mmaModScormSync.getScormSyncTime(scormId, siteId).then(function(time) {
            if (time == 0) {
                return $translate('mm.core.none');
            } else {
                return moment(time).format('LLL');
            }
        });
    };

    /**
     * Searches user data for an online attempt. If the data can't be retrieved,
     * re-try with the previous online attempt (if exists).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#searchOnlineAttemptUserData
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Online attempt to get the data.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with user data.
     */
    self.searchOnlineAttemptUserData = function(scormId, attempt, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId).catch(function() {
            if (attempt > 0) {
                // We couldn't retrieve the data. Try again with the previous online attempt.
                return self.searchOnlineAttemptUserData(scormId, attempt - 1, siteId);
            } else {
                // No more attempts to try. Reject
                return $q.reject();
            }
        });
    };

    /**
     * Show error because a SCORM download failed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#showDownloadError
     * @param {Object} scorm SCORM downloaded.
     * @return {Void}
     */
    self.showDownloadError = function(scorm) {
        $translate('mma.mod_scorm.errordownloadscorm', {name: scorm.name}).then(function(message) {
            $mmUtil.showErrorModal(message);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Mod SCORM prefetch handler.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormPrefetchHandler
 */
.factory('$mmaModScormPrefetchHandler', ["$mmaModScorm", "mmaModScormComponent", function($mmaModScorm, mmaModScormComponent) {

    var self = {};

    self.component = mmaModScormComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getDownloadSize
     * @param {Object} module   Module to get the size.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Promise}        Promise resolved with the size.
     */
    self.getDownloadSize = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            if ($mmaModScorm.isScormSupported(scorm) !== true) {
                return 0;
            } else if (!scorm.packagesize) {
                // We don't have package size, try to calculate it.
                return $mmaModScorm.calculateScormSize(scorm);
            } else {
                return scorm.packagesize;
            }
        });
    };

    /**
     * Get the list of downloadable files.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getFiles
     * @param {Object} module   Module to get the files.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Promise}         Size.
     */
    self.getFiles = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return $mmaModScorm.getScormFileList(scorm);
        }).catch(function() {
            // SCORM not found, return empty list.
            return [];
        });
    };

    /**
     * Get revision of a SCORM (sha1hash).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getRevision
     * @param {Object} module   Module to get the revision.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Number}         Timemodified.
     */
    self.getRevision = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return scorm.sha1hash;
        });
    };

    /**
     * Get timemodified of a SCORM. It always return 0, we don't use timemodified for SCORM packages.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getTimemodified
     * @param {Object} module   Module to get the timemodified.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Number}         Timemodified.
     */
    self.getTimemodified = function(module, courseid) {
        return 0;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmaModScorm.isPluginEnabled();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#prefetch
     * @param {Object} module   The module object returned by WS.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Promise}        Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return $mmaModScorm.prefetch(scorm);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM service.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScorm
 */
.factory('$mmaModScorm', ["$mmSite", "$q", "$translate", "$mmLang", "$mmFilepool", "$mmFS", "$mmWS", "$sce", "$mmaModScormOnline", "$state", "$mmaModScormOffline", "$mmUtil", "$log", "$mmSitesManager", "mmaModScormComponent", "mmCoreNotDownloaded", function($mmSite, $q, $translate, $mmLang, $mmFilepool, $mmFS, $mmWS, $sce, $mmaModScormOnline, $state,
            $mmaModScormOffline, $mmUtil, $log, $mmSitesManager, mmaModScormComponent, mmCoreNotDownloaded) {
    $log = $log.getInstance('$mmaModScorm');

    var self = {},
        statuses = ['notattempted', 'passed', 'completed', 'failed', 'incomplete', 'browsed', 'suspend'],
        downloadPromises = {}; // Store download promises to be able to restore them.

    // Constants.
    self.GRADESCOES     = 0;
    self.GRADEHIGHEST   = 1;
    self.GRADEAVERAGE   = 2;
    self.GRADESUM       = 3;

    self.HIGHESTATTEMPT = 0;
    self.AVERAGEATTEMPT = 1;
    self.FIRSTATTEMPT   = 2;
    self.LASTATTEMPT    = 3;

    self.MODEBROWSE = 'browse';
    self.MODENORMAL = 'normal';
    self.MODEREVIEW = 'review';

    /**
     * Calculates the SCORM grade based on the grading method and the list of attempts scores.
     * We only treat online attempts to calculate a SCORM grade.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#calculateScormGrade
     * @param  {Object} scorm           SCORM.
     * @param  {Object} onlineAttempts  Online attempts. Each attempt must have a property called "grade".
     * @return {Number}                 Grade. -1 if no grade.
     */
    self.calculateScormGrade = function(scorm, onlineAttempts) {
        if (!onlineAttempts || !Object.keys(onlineAttempts).length) {
            return -1;
        }

        switch (scorm.whatgrade) {
            case self.FIRSTATTEMPT:
                return onlineAttempts[1] ? onlineAttempts[1].grade : -1;
            case self.LASTATTEMPT:
                var max = 0;
                angular.forEach(Object.keys(onlineAttempts), function(number) {
                    max = Math.max(number, max);
                });
                if (max > 0) {
                    return onlineAttempts[max].grade;
                }
                return -1;
            case self.HIGHESTATTEMPT:
                var grade = 0;
                angular.forEach(onlineAttempts, function(attempt) {
                    grade = Math.max(attempt.grade, grade);
                });
                return grade;
            case self.AVERAGEATTEMPT:
                var sumgrades = 0,
                    total = 0;
                angular.forEach(onlineAttempts, function(attempt) {
                    sumgrades += attempt.grade;
                    total++;
                });
                return Math.round(sumgrades / total);
        }

        return -1;
    };

    /**
     * Calculates the size of a SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#calculateScormSize
     * @param {Object} scorm SCORM.
     * @return {Promise}     Promise resolved with the SCORM size.
     */
    self.calculateScormSize = function(scorm) {
        if (scorm.packagesize) {
            return $q.when(scorm.packagesize);
        }

        return $mmWS.getRemoteFileSize(self.getPackageUrl(scorm));
    };

    /**
     * Count the attempts left for the given scorm.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#countAttemptsLeft
     * @param {Object} scorm         SCORM.
     * @param {Number} attemptsCount Number of attempts performed.
     * @return {Number}              Number of attempts left.
     */
    self.countAttemptsLeft = function(scorm, attemptsCount) {
        if (scorm.maxattempt == 0) {
            return Number.MAX_VALUE; // Unlimited attempts.
        }

        attemptsCount = parseInt(attemptsCount, 10);
        if (isNaN(attemptsCount)) {
            return -1;
        }
        return scorm.maxattempt - attemptsCount;
    };

    /**
     * Returns the mode and attempt number to use based on mode selected and SCORM data.
     * This function is based on Moodle's scorm_check_mode.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#determineAttemptAndMode
     * @param {Object} scorm       SCORM.
     * @param {String} mode        Selected mode.
     * @param {Number} attempt     Current attempt.
     * @param {Boolean} newAttempt True if should start a new attempt, false otherwise.
     * @param {Boolean} incomplete True if current attempt is incomplete, false otherwise.
     * @return {Object}            Object with properties: 'mode', 'attempt' and 'newAttempt'.
     */
    self.determineAttemptAndMode = function(scorm, mode, attempt, newAttempt, incomplete) {
        if (mode == self.MODEBROWSE) {
            if (scorm.hidebrowse) {
                // Prevent Browse mode if hidebrowse is set.
                mode = self.MODENORMAL;
            } else {
                // We don't need to check attempts as browse mode is set.
                if (attempt == 0) {
                    attempt = 1;
                    newAttempt = true;
                }

                return {
                    mode: mode,
                    attempt: attempt,
                    newAttempt: newAttempt
                };
            }
        }

        // Validate user request to start a new attempt.
        if (attempt == 0) {
            newAttempt = true;
        } else if (incomplete) {
            // The option to start a new attempt should never have been presented. Force false.
            newAttempt = false;
        } else if (scorm.forcenewattempt) {
            // A new attempt should be forced for already completed attempts.
            newAttempt = true;
        }

        if (newAttempt && (scorm.maxattempt == 0 || attempt < scorm.maxattempt)) {
            // Create a new attempt. Force mode normal.
            attempt++;
            mode = self.MODENORMAL;
        } else {
            if (incomplete) {
                // We can't review an incomplete attempt.
                mode = self.MODENORMAL;
            } else {
                // We aren't starting a new attempt and the current one is complete, force review mode.
                mode = self.MODEREVIEW;
            }
        }

        return {
            mode: mode,
            attempt: attempt,
            newAttempt: newAttempt
        };
    };

    /**
     * Check if TOC should be displayed in the player.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#displayTocInPlayer
     * @param {Object} scorm SCORM.
     * @return {Boolean}     True if should display TOC, false otherwise.
     */
    self.displayTocInPlayer = function(scorm) {
        return scorm.hidetoc !== 3;
    };

    /**
     * Download and unzips the SCORM package.
     * @see $mmaModScorm#_downloadOrPrefetch
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#download
     * @param {Object} scorm SCORM object returned by $mmaModScorm#getScorm.
     * @return {Promise}     Promise resolved when the package is downloaded and unzipped.
     */
    self.download = function(scorm) {
        return self._downloadOrPrefetch(scorm, false);
    };

    /**
     * Downloads/Prefetches and unzips the SCORM package.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#_downloadOrPrefetch
     * @param {Object} scorm     SCORM object returned by $mmaModScorm#getScorm.
     * @param {Boolean} prefetch True if prefetch, false otherwise.
     * @return {Promise}         Promise resolved when the package is downloaded and unzipped. It will call notify in these cases:
     *                                   -File download in progress. Notify object will have these properties:
     *                                       packageDownload {Boolean} Always true.
     *                                       loaded {Number} Number of bytes of the package loaded.
     *                                       fileProgress {Object} FileTransfer's notify param for the current file.
     *                                   -Download or unzip starting. Notify object will have these properties:
     *                                       message {String} Message code related to the starting operation.
     *                                   -File unzip in progress. Notify object will have these properties:
     *                                       loaded {Number} Number of bytes unzipped.
     *                                       total {Number} Total of bytes of the ZIP file.
     * @protected
     */
    self._downloadOrPrefetch = function(scorm, prefetch) {
        var result = self.isScormSupported(scorm),
            siteId = $mmSite.getId();
        if (result !== true) {
            return $mmLang.translateAndReject(result);
        }

        if (downloadPromises[siteId] && downloadPromises[siteId][scorm.id]) {
            // There's already a download ongoing for this package, return the promise.
            return downloadPromises[siteId][scorm.id];
        } else if (!downloadPromises[siteId]) {
            downloadPromises[siteId] = {};
        }

        var files = self.getScormFileList(scorm),
            revision = scorm.sha1hash, // We use sha1hash instead of revision number.
            dirPath,
            deferred = $q.defer(), // We use a deferred to be able to notify.
            fn = prefetch ? $mmFilepool.prefetchPackage : $mmFilepool.downloadPackage;

        downloadPromises[siteId][scorm.id] = deferred.promise; // Store promise to be able to restore it later.

        // Get the folder where the unzipped files will be.
        self.getScormFolder(scorm.moduleurl).then(function(path) {
            dirPath = path;
            // Download the ZIP file to the filepool.
            // Using undefined for success & fail will pass the success/failure to the parent promise.
            deferred.notify({message: 'mm.core.downloading'});
            return fn(siteId, files, mmaModScormComponent, scorm.coursemodule, revision, 0)
                                                        .then(undefined, undefined, deferred.notify);
        }).then(function() {
            // Remove the destination folder to prevent having old unused files.
            return $mmFS.removeDir(dirPath).catch(function() {
                // Ignore errors, it might have failed because the folder doesn't exist.
            });
        }).then(function() {
            // Get the ZIP file path.
            return $mmFilepool.getFilePathByUrl(siteId, self.getPackageUrl(scorm));
        }).then(function(zippath) {
            // Unzip and delete the zip when finished.
            deferred.notify({message: 'mm.core.unzipping'});
            return $mmFS.unzipFile(zippath, dirPath).then(function() {
                return $mmFilepool.removeFileByUrl(siteId, self.getPackageUrl(scorm)).catch(function() {
                    // Ignore errors.
                });
            }, function(error) {
                // Error unzipping. Set status as not downloaded and reject.
                return $mmFilepool.storePackageStatus(siteId, mmaModScormComponent, scorm.coursemodule,
                                            mmCoreNotDownloaded, revision, 0).then(function() {
                    return $q.reject(error);
                });
            }, deferred.notify);
        }).then(deferred.resolve, deferred.reject).finally(function() {
            delete downloadPromises[siteId][scorm.id]; // Delete stored promise.
        });

        return deferred.promise;
    };

    /**
     * This is a little language parser for AICC_SCRIPT.
     * Evaluates the expression and returns a boolean answer.
     * See 2.3.2.5.1. Sequencing/Navigation Today  - from the SCORM 1.2 spec (CAM).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#evalPrerequisites
     * @param  {String} prerequisites The AICC_SCRIPT prerequisites expression.
     * @param  {Object} trackData     The tracked user data of each SCO.
     * @return {Boolean}              True if prerequisites are fulfilled, false otherwise.
     */
    self.evalPrerequisites = function(prerequisites, trackData) {

        var stack = [],
            statuses = {
                'passed': 'passed',
                'completed': 'completed',
                'failed': 'failed',
                'incomplete': 'incomplete',
                'browsed': 'browsed',
                'not attempted': 'notattempted',
                'p': 'passed',
                'c': 'completed',
                'f': 'failed',
                'i': 'incomplete',
                'b': 'browsed',
                'n': 'notattempted'
            };

        // Expand the amp entities.
        prerequisites = prerequisites.replace(/&amp;/gi, '&');
        // Find all my parsable tokens.
        prerequisites = prerequisites.replace(/(&|\||\(|\)|\~)/gi, '\t$1\t');
        // Expand operators.
        prerequisites = prerequisites.replace(/&/gi, '&&');
        prerequisites = prerequisites.replace(/\|/gi, '||');
        // Now - grab all the tokens.
        var elements = prerequisites.trim().split('\t');

        // Process each token to build an expression to be evaluated.
        angular.forEach(elements, function(element) {
            element = element.trim();
            if (!element) {
                return;
            }
            if (!element.match(/^(&&|\|\||\(|\))$/gi)) {
                // Create each individual expression.
                // Search for ~ = <> X*{} .

                var re = /^(\d+)\*\{(.+)\}$/, // Sets like 3*{S34, S36, S37, S39}.
                    reOther = /^(.+)(\=|\<\>)(.+)$/, // Other symbols.
                    matches;

                if (re.test(element)) {
                    matches = element.match(re);

                    var repeat = matches[1],
                        set = matches[2].split(','),
                        count = 0;
                    angular.forEach(set, function(setelement) {
                        setelement = setelement.trim();
                        if (typeof trackData[setelement] != 'undefined' &&
                                (trackData[setelement].status == 'completed' || trackData[setelement].status == 'passed')) {
                            count++;
                        }
                    });
                    if (count >= repeat) {
                        element = 'true';
                    } else {
                        element = 'false';
                    }
                } else if (element == '~') {
                    // Not maps ~.
                    element = '!';
                } else if (reOther.test(element)) {
                    // Other symbols = | <> .
                    matches = element.match(reOther);
                    element = matches[1].trim();
                    if (typeof trackData[element] != 'undefined') {
                        value = matches[3].trim().replace(/(\'|\")/gi);
                        if (typeof statuses[value] != 'undefined') {
                            value = statuses[value];
                        }
                        if (matches[2] == '<>') {
                            oper = '!=';
                        } else {
                            oper = '==';
                        }
                        element = '(\'' + trackData[element].status + '\' ' + oper + ' \'' + value + '\')';
                    } else {
                        element = 'false';
                    }
                } else {
                    // Everything else must be an element defined like S45 ...
                    if (typeof trackData[element] != 'undefined' &&
                            (trackData[element].status == 'completed' || trackData[element].status == 'passed')) {
                        element = 'true';
                    } else {
                        element = 'false';
                    }
                }

            }
            stack.push(' ' + element + ' ');
        });

        return eval(stack.join('') + ';');
    };

    /**
     * Formats a grade to be displayed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#formatGrade
     * @param  {Object} scorm SCORM.
     * @param  {Number} grade Grade.
     * @return {String}       Grade to display.
     */
    self.formatGrade = function(scorm, grade) {
        if (typeof grade == 'undefined' || grade == -1) {
            return $translate.instant('mm.core.none');
        }
        if (scorm.grademethod !== self.GRADESCOES && scorm.maxgrade > 0) {
            grade = (grade / scorm.maxgrade) * 100;
            return $translate.instant('mm.core.percentagenumber', {$a: $mmUtil.roundToDecimals(grade, 2)});
        }
        return grade;
    };

    /**
     * Formats a tree-like TOC into an array.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#formatTocToArray
     * @param {Object[]} toc     SCORM's TOC (tree format).
     * @param {Number} [level=0] The level of the TOC we're right now. 0 by default.
     * @return {Object[]}        SCORM's TOC (array format).
     */
    self.formatTocToArray = function(toc, level) {
        if (!toc || !toc.length) {
            return [];
        }

        if (typeof level == 'undefined') {
            level = 0;
        }

        var formatted = [];
        angular.forEach(toc, function(node) {
            node.level = level;
            formatted.push(node);
            formatted = formatted.concat(self.formatTocToArray(node.children, level + 1));
        });

        return formatted;
    };

    /**
     * Get the number of attempts done by a user in the given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getAttemptCount
     * @param {Number} scormId        SCORM ID.
     * @param {String} [siteId]       Site ID. If not defined, current site.
     * @param {Number} [userId]       User ID. If not defined use site's current user.
     * @param {Boolean} ignoreMissing True if it should ignore attempts without grade/completion. Only for online attempts.
     * @param {Boolean} ignoreCache   True if it should ignore cached data for online attempts.
     * @return {Promise}              Promise resolved when the attempt count is retrieved. It returns an object with
     *                                online attempts, offline attempts, total number of attempts and last attempt.
     */
    self.getAttemptCount = function(scormId, siteId, userId, ignoreMissing, ignoreCache) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var result = {
                    lastAttempt: {
                        number: 0,
                        offline: false
                    }
                },
                promises = [];

            promises.push($mmaModScormOnline.getAttemptCount(siteId, scormId, userId, ignoreMissing, ignoreCache)
                        .then(function(count) {
                // Calculate numbers of online attempts.
                result.online = [];
                for (var i = 1; i <= count; i++) {
                    result.online.push(i);
                }
                // Calculate last attempt.
                if (count > result.lastAttempt.number) {
                    result.lastAttempt.number = count;
                    result.lastAttempt.offline = false;
                }
            }));

            promises.push($mmaModScormOffline.getAttempts(siteId, scormId, userId).then(function(attempts) {
                // Get only attempt numbers.
                result.offline = attempts.map(function(entry) {
                    // Calculate last attempt. We use >= to prioritize offline events if an attempt is both online and offline.
                    if (entry.attempt >= result.lastAttempt.number) {
                        result.lastAttempt.number = entry.attempt;
                        result.lastAttempt.offline = true;
                    }
                    return entry.attempt;
                });
            }));

            return $q.all(promises).then(function() {
                var total = result.online.length;
                result.offline.forEach(function(attempt) {
                    // Check if this attempt also exists in online, it might have been copied to local.
                    if (result.online.indexOf(attempt) == -1) {
                        total++;
                    }
                });
                result.total = total;
                return result;
            });
        });
    };

    /**
     * Get the grade for a certain SCORM and attempt.
     * Based on Moodle's scorm_grade_user_attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getAttemptGrade
     * @param {Number} scormid  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Boolean} offline True if attempt is offline, false otherwise.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the grade. If the attempt hasn't reported grade/completion, grade will be -1.
     */
    self.getAttemptGrade = function(scorm, attempt, offline, siteId) {
        var attemptscore = {
            scos: 0,
            values: 0,
            max: 0,
            sum: 0
        };

        return self.getScormUserData(scorm.id, attempt, offline, siteId).then(function(data) {
            angular.forEach(data, function(scodata) {
                var userdata = scodata.userdata;
                if (userdata.status == 'completed' || userdata.status == 'passed') {
                    attemptscore.scos++;
                }

                if (userdata.score_raw || (typeof scorm.scormtype != 'undefined' &&
                            scorm.scormtype == 'sco' && typeof userdata.score_raw != 'undefined')) {
                    var scoreraw = parseFloat(userdata.score_raw);
                    attemptscore.values++;
                    attemptscore.sum += scoreraw;
                    attemptscore.max = Math.max(scoreraw, attemptscore.max);
                }
            });

            var score = 0;
            switch (scorm.grademethod) {
                case self.GRADEHIGHEST:
                    score = attemptscore.max;
                break;
                case self.GRADEAVERAGE:
                    if (attemptscore.values > 0) {
                        score = attemptscore.sum / attemptscore.values;
                    } else {
                        score = 0;
                    }
                break;
                case self.GRADESUM:
                    score = attemptscore.sum;
                break;
                case self.GRADESCOES:
                    score = attemptscore.scos;
                break;
                default:
                    score = attemptscore.max;   // Remote Learner GRADEHIGHEST is default.
            }

            return score;
        });
    };

    /**
     * Get the list of a organizations defined in a SCORM package.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getOrganizations
     * @param  {Number} scormId SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the list of organizations.
     */
    self.getOrganizations = function(scormId, siteId) {
        return self.getScos(scormId, siteId).then(function(scos) {
            var organizations = [];
            angular.forEach(scos, function(sco) {
                // Is an organization entry?
                if (sco.organization == '' && sco.parent == '/' && sco.scormtype == '') {
                    organizations.push({
                        identifier: sco.identifier,
                        title: sco.title,
                        sortorder: sco.sortorder
                    });
                }
            });
            return organizations;
        });
    };

    /**
     * Get the organization Toc object
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getOrganizationToc
     * @param  {Number} scormId      SCORM ID.
     * @param  {String} organization Organization identifier.
     * @param  {Number} attempt      The attempt number (to populate SCO track data).
     * @param {Boolean} offline      True if attempt is offline, false otherwise.
     * @param {String} [siteId]      Site ID. If not defined, current site.
     * @return {Promise}             Promise resolved with the toc object.
     */
    self.getOrganizationToc = function(scormId, organization, attempt, offline, siteId) {

        return self.getScosWithData(scormId, organization, attempt, offline, false, siteId).then(function(scos) {
            var map = {},
                rootScos = [];

            angular.forEach(scos, function(sco, index) {
                sco.children = [];
                map[sco.identifier] = index;
                if (sco.parent !== '/') {
                    if (sco.parent == organization) {
                        // It's a root SCO, add it to the root array.
                        rootScos.push(sco);
                    } else {
                        // Add this sco to the parent.
                        scos[map[sco.parent]].children.push(sco);
                    }
                }
            });

            return rootScos;
        });
    };

    /**
     * Get the package URL of a given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getPackageUrl
     * @param  {Object} scorm SCORM.
     * @return {String}       Package URL.
     */
    self.getPackageUrl = function(scorm) {
        if (scorm.packageurl) {
            return scorm.packageurl;
        }
        if (scorm.reference) {
            return scorm.reference;
        }
        return '';
    };

    /**
     * Get the user data for a certain SCORM and attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormUserData
     * @param {Number} scormId      SCORM ID.
     * @param {Number} attempt      Attempt number.
     * @param {Boolean} offline     True if attempt is offline, false otherwise.
     * @param {String} [siteId]     Site ID. If not defined, current site.
     * @param {Object[]} [scos]     SCOs returned by $mmaModScorm#getScos. Recommended if offline=true.
     * @param {Boolean} ignoreCache True if it should ignore cached data for online attempts.
     * @return {Promise}            Promise resolved when the user data is retrieved.
     */
    self.getScormUserData = function(scormId, attempt, offline, siteId, scos, ignoreCache) {
        siteId = siteId || $mmSite.getId();
        if (offline) {
            var promise = scos ? $q.when(scos) : self.getScos(scormId, siteId);
            return promise.then(function(scos) {
                return $mmaModScormOffline.getScormUserData(siteId, scormId, attempt, undefined, scos);
            });
        } else {
            return $mmaModScormOnline.getScormUserData(siteId, scormId, attempt, ignoreCache);
        }
    };

    /**
     * Get cache key for get SCORM scos WS calls.
     *
     * @param  {Number} scormId SCORM ID.
     * @return {String}         Cache key.
     */
    function getScosCacheKey(scormId) {
        return 'mmaModScorm:scos:' + scormId;
    }

    /**
     * Retrieves the list of SCO objects for a given SCORM and organization.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScos
     * @param  {Number} scormId        SCORM ID.
     * @param  {String} [siteId]       Site ID. If not defined, current site.
     * @param  {String} [organization] Organization ID.
     * @param  {Boolean} ignoreCache   True if it should ignore cached data (it will always fail if offline or server down).
     * @return {Promise}               Promise resolved with a list of SCO objects.
     */
    self.getScos = function(scormId, siteId, organization, ignoreCache) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            organization = organization || '';

            // Don't send the organization to the WS, we'll filter them locally.
            var params = {
                    scormid: scormId
                },
                preSets = {
                    cacheKey: getScosCacheKey(scormId)
                };

            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }

            return site.read('mod_scorm_get_scorm_scoes', params, preSets).then(function(response) {
                if (response && response.scoes) {
                    var scos = [];
                    if (organization) {
                        // Filter SCOs by organization.
                        angular.forEach(response.scoes, function(sco) {
                            if (sco.organization == organization) {
                                scos.push(sco);
                            }
                        });
                    } else {
                        scos = response.scoes;
                    }
                    return scos;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Retrieves the list of SCO objects for a given SCORM and organization, including data about
     * a certain attempt (status, isvisible, ...).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScosWithData
     * @param  {Number} scormId      SCORM ID.
     * @param  {String} organization Organization ID.
     * @param  {Number} attempt      Attempt number.
     * @param  {Boolean} offline     True if attempt is offline, false otherwise.
     * @param  {Boolean} ignoreCache True if it should ignore cached data for online attempts.
     * @param  {String} [siteId]     Site ID. If not defined, current site.
     * @return {Promise}             Promise resolved with a list of SCO objects.
     */
    self.getScosWithData = function(scormId, organization, attempt, offline, ignoreCache, siteId) {
        // Get organization SCOs.
        return self.getScos(scormId, siteId, organization, ignoreCache).then(function(scos) {
            // Get the track data for all the SCOs in the organization for the given attempt.
            // We'll use this data to set SCO data like isvisible, status and so.
            return self.getScormUserData(scormId, attempt, offline, siteId, scos, ignoreCache).then(function(data) {

                var trackDataBySCO = {};

                // First populate trackDataBySCO to index by SCO identifier.
                angular.forEach(scos, function(sco) {
                    trackDataBySCO[sco.identifier] = data[sco.id].userdata;
                });

                angular.forEach(scos, function(sco) {
                    // Add specific SCO information (related to tracked data).
                    var scodata = data[sco.id].userdata;
                    if (!scodata) {
                        return;
                    }
                    // Check isvisible attribute.
                    sco.isvisible = typeof scodata.isvisible != 'undefined' ?
                                            scodata.isvisible && scodata.isvisible !== 'false' : true;
                    // Check pre-requisites status.
                    sco.prereq = typeof scodata.prerequisites == 'undefined' ||
                                            self.evalPrerequisites(scodata.prerequisites, trackDataBySCO);
                    // Add status.
                    sco.status = (typeof scodata.status == 'undefined' || scodata.status === '') ?
                                            'notattempted' : scodata.status;
                    // Exit var.
                    sco.exitvar = typeof scodata.exitvar == 'undefined' ? 'cmi.core.exit' : scodata.exitvar;
                    sco.exitvalue = scodata[sco.exitvar];
                });

                return scos;
            });
        });
    };

    /**
     * Given a SCORM and a SCO, returns the full launch URL for the SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScoSrc
     * @param  {Object} scorm   SCORM.
     * @param  {Object} sco     SCO.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the URL.
     */
    self.getScoSrc = function(scorm, sco, siteId) {
        if (sco.launch.match(/http(s)?:\/\//)) {
            // It's an online URL.
            return $q.when($sce.trustAsResourceUrl(sco.launch));
        }

        siteId = siteId || $mmSite.getId();

        return $mmFilepool.getDirectoryUrlByUrl(siteId, scorm.moduleurl).then(function(dirPath) {
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, sco.launch));
        });
    };

    /**
     * Get the path to the folder where a SCORM is downloaded.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormFolder
     * @param  {String} moduleUrl Module URL (returned by get_course_contents).
     * @param {String} [siteId]   Site ID. If not defined, current site.
     * @return {Promise}          Promise resolved with the folder path.
     */
    self.getScormFolder = function(moduleUrl, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmFilepool.getFilePathByUrl(siteId, moduleUrl);
    };

    /**
     * Gets a list of files to downlaod for a SCORM, using a format similar to module.contents from get_course_contents.
     * It will only return one file: the ZIP package.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormFileList
     * @param  {Object} scorm SCORM.
     * @return {Object[]}     File list.
     */
    self.getScormFileList = function(scorm) {
        var files = [];
        if (self.isScormSupported(scorm) === true && !scorm.warningmessage) {
            files.push({
                fileurl: self.getPackageUrl(scorm),
                filepath: '/',
                filename: scorm.reference,
                filesize: scorm.packagesize,
                type: 'file',
                timemodified: 0
            });
        }
        return files;
    };

    /**
     * Get the URL and description of the status icon.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScoStatusIcon
     * @param {Object} sco         SCO.
     * @param {Boolean} incomplete True if SCORM is incomplete, false otherwise.
     * @return {Object}            Image URL and description.
     */
    self.getScoStatusIcon = function(sco, incomplete) {
        var imagename = '',
            descname = '',
            status;

        if (sco.scormtype == 'sco') {
            // Not an asset, calculate image using status.
            status = sco.status;
            if (statuses.indexOf(status) < 0) {
                // Status empty or not valid, use 'notattempted'.
                status = 'notattempted';
            }
            if (!incomplete) {
                // Check if SCO is completed or not. If SCORM is incomplete there's no need to check SCO.
                incomplete = self.isStatusIncomplete(status);
            }

            if (incomplete && sco.exitvalue == 'suspend') {
                imagename = 'suspend';
                descname = 'suspended';
            } else {
                imagename = sco.status;
                descname = sco.status;
            }
        } else {
            imagename = 'asset';
            descname = (!sco.status || sco.status == 'notattempted') ? 'asset' : 'assetlaunched';
        }

        return {
            url: 'addons/mod_scorm/img/' + imagename + '.gif',
            description: $translate.instant('mma.mod_scorm.' + descname)
        };
    };

    /**
     * Get cache key for SCORM data WS calls.
     *
     * @param {Number} courseId Course ID.
     * @return {String}         Cache key.
     */
    function getScormDataCacheKey(courseId) {
        return 'mmaModScorm:scorm:' + courseId;
    }

    /**
     * Get a SCORM with key=value. If more than one is found, only the first will be returned.
     *
     * @param  {String} siteId    Site ID.
     * @param  {Number} courseId  Course ID.
     * @param  {String} key       Name of the property to check.
     * @param  {Mixed} value      Value to search.
     * @param  {String} moduleUrl Module URL.
     * @return {Promise}          Promise resolved when the SCORM is retrieved.
     */
    function getScorm(siteId, courseId, key, value, moduleUrl) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getScormDataCacheKey(courseId)
                };

            return site.read('mod_scorm_get_scorms_by_courses', params, preSets).then(function(response) {
                if (response && response.scorms) {
                    var currentScorm;
                    angular.forEach(response.scorms, function(scorm) {
                        if (!currentScorm && scorm[key] == value) {
                            currentScorm = scorm;
                        }
                    });
                    if (currentScorm) {
                        // If the SCORM isn't available the WS returns a warning and it doesn't return timeopen and timeclosed.
                        if (typeof currentScorm.timeopen == 'undefined') {
                            angular.forEach(response.warnings, function(warning) {
                                if (warning.itemid === currentScorm.id) {
                                    currentScorm.warningmessage = warning.message;
                                }
                            });
                        }
                        currentScorm.moduleurl = moduleUrl;
                        return currentScorm;
                    }
                }
                return $q.reject();
            });
        });
    }

    /**
     * Get a SCORM by module ID.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScorm
     * @param {Number} courseId  Course ID.
     * @param {Number} cmid      Course module ID.
     * @parma {String} moduleUrl Module URL.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when the SCORM is retrieved.
     */
    self.getScorm = function(courseId, cmid, moduleUrl, siteId) {
        siteId = siteId || $mmSite.getId();
        return getScorm(siteId, courseId, 'coursemodule', cmid, moduleUrl);
    };

    /**
     * Get a SCORM by SCORM ID.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormById
     * @param {Number} courseId  Course ID.
     * @param {Number} cmid      Course module ID.
     * @parma {String} moduleUrl Module URL.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when the SCORM is retrieved.
     */
    self.getScormById = function(courseId, id, moduleUrl, siteId) {
        siteId = siteId || $mmSite.getId();
        return getScorm(siteId, courseId, 'id', id, moduleUrl);
    };

    /**
     * Get a readable SCORM grade method.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormGradingMethod
     * @param {Object} scorm SCORM.
     * @return {String}      Grading method.
     */
    self.getScormGradeMethod = function(scorm) {
        if (scorm.maxattempt == 1) {
            switch (parseInt(scorm.grademethod, 10)) {
                case self.GRADEHIGHEST:
                    return $translate.instant('mma.mod_scorm.gradehighest');
                case self.GRADEAVERAGE:
                    return $translate.instant('mma.mod_scorm.gradeaverage');
                case self.GRADESUM:
                    return $translate.instant('mma.mod_scorm.gradesum');
                case self.GRADESCOES:
                    return $translate.instant('mma.mod_scorm.gradescoes');
            }
        } else {
            switch (parseInt(scorm.whatgrade, 10)) {
                case self.HIGHESTATTEMPT:
                    return $translate.instant('mma.mod_scorm.highestattempt');
                case self.AVERAGEATTEMPT:
                    return $translate.instant('mma.mod_scorm.averageattempt');
                case self.FIRSTATTEMPT:
                    return $translate.instant('mma.mod_scorm.firstattempt');
                case self.LASTATTEMPT:
                    return $translate.instant('mma.mod_scorm.lastattempt');
            }
        }
    };

    /**
     * Invalidates all the data related to a certain SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateAllScormData
     * @param {Number} scormId  SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateAllScormData = function(scormId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        promises.push($mmaModScormOnline.invalidateAttemptCount(siteId, scormId, userId));
        promises.push(self.invalidateScos(scormId, siteId));
        promises.push($mmaModScormOnline.invalidateScormUserData(siteId, scormId));
        return $q.all(promises);
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateContent
     * @param {Object} moduleId The module ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmFilepool.invalidateFilesByComponent(siteId, mmaModScormComponent, moduleId);
    };

    /**
     * Invalidates SCORM scos for all organizations.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateScos
     * @param {Number} scormId SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}       Promise resolved when the data is invalidated.
     */
    self.invalidateScos = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getScosCacheKey(scormId));
        });
    };

    /**
     * Invalidates SCORM data.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateScormData
     * @param {Number} courseId Course ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateScormData = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getScormDataCacheKey(courseId));
        });
    };

    /**
     * Check if a SCORM's attempt is incomplete.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isAttemptIncomplete
     * @param {Object} scormId      SCORM ID.
     * @param {Number} attempt      Attempt.
     * @param {Boolean} offline     True if attempt is offline, false otherwise.
     * @param {Boolean} ignoreCache True if it should ignore cached data for online attempts.
     * @param {String} [siteId]     Site ID. If not defined, current site.
     * @return {Promise}            Promise resolved with a boolean: true if incomplete, false otherwise.
     */
    self.isAttemptIncomplete = function(scormId, attempt, offline, ignoreCache, siteId) {
        return self.getScosWithData(scormId, undefined, attempt, offline, ignoreCache, siteId).then(function(scos) {
            var incomplete = false;

            angular.forEach(scos, function(sco) {
                // Ignore SCOs not visible or without launch URL.
                if (sco.isvisible && sco.launch) {
                    if (self.isStatusIncomplete(sco.status)) {
                        incomplete = true;
                    }
                }
            });

            return incomplete;
        });
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the scorm WS are available.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_scorm_get_scorm_attempt_count') &&
                    site.wsAvailable('mod_scorm_get_scorm_sco_tracks') &&
                    site.wsAvailable('mod_scorm_get_scorm_scoes') &&
                    site.wsAvailable('mod_scorm_get_scorm_user_data') &&
                    site.wsAvailable('mod_scorm_get_scorms_by_courses') &&
                    site.wsAvailable('mod_scorm_insert_scorm_tracks');
        });
    };

    /**
     * Check if a SCORM is being played right now.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormBeingPlayed
     * @param  {Number}  scormId SCORM ID.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Boolean}         True if it's being played, false otherwise.
     */
    self.isScormBeingPlayed = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSite.getId() == siteId && $state.current.name == 'site.mod_scorm-player' &&
                        $state.params.scorm && $state.params.scorm.id == scormId;
    };

    /**
     * Check if the given SCORM is closed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormClosed
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is closed, false if it hasn't closed yet.
     */
    self.isScormClosed = function(scorm) {
        var timeNow = $mmUtil.timestamp();
        if (scorm.timeclose > 0 && timeNow > scorm.timeclose) {
            return true;
        }
        return false;
    };

    /**
     * Check if the given SCORM is downloadable.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormDownloadable
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is downloadable, false otherwise.
     */
    self.isScormDownloadable = function(scorm) {
        return typeof scorm.protectpackagedownloads != 'undefined' && scorm.protectpackagedownloads === false;
    };

    /**
     * Check if the given SCORM is open.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormOpen
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is open, false if it hasn't opened yet.
     */
    self.isScormOpen = function(scorm) {
        var timeNow = $mmUtil.timestamp();
        if (scorm.timeopen > 0 && scorm.timeopen > timeNow) {
            return false;
        }
        return true;
    };

    /**
     * Check if a SCORM is supported in the app. If it's not, returns the error code to show.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormSupported
     * @param {Object} scorm    SCORM to check.
     * @return {Boolean|String} True if SCORM is supported, string with error code otherwise.
     */
    self.isScormSupported = function(scorm) {
        if (!self.isScormValidVersion(scorm)) {
            return 'mma.mod_scorm.errorinvalidversion';
        } else if (!self.isScormDownloadable(scorm)) {
            return 'mma.mod_scorm.errornotdownloadable';
        } else if (!self.isValidPackageUrl(self.getPackageUrl(scorm))) {
            return 'mma.mod_scorm.errorpackagefile';
        }

        return true;
    };

    /**
     * Check if it's a valid SCORM 1.2.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormValidVersion
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is valid, false otherwise.
     */
    self.isScormValidVersion = function(scorm) {
        return scorm.version == 'SCORM_1.2';
    };

    /**
     * Check if a SCO status is incomplete.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isStatusIncomplete
     * @param  {String}  status SCO status.
     * @return {Boolean}        True if incomplete, false otherwise.
     */
    self.isStatusIncomplete = function(status) {
        return !status || status == 'notattempted' || status == 'incomplete' || status == 'browsed';
    };

    /**
     * Check if a package URL is valid.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isValidPackageUrl
     * @param  {String}  packageUrl Package URL.
     * @return {Boolean}            True if valid, false otherwise.
     */
    self.isValidPackageUrl = function(packageUrl) {
        if (!packageUrl) {
            return false;
        }
        if (packageUrl.indexOf('imsmanifest.xml') > -1) {
            return false;
        }
        return true;
    };

    /**
     * Report a SCORM as being viewed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#logView
     * @param {String} id       Module ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the WS call is successful.
     */
    self.logView = function(id, siteId) {
        siteId = siteId || $mmSite.getId();
        if (id) {
            return $mmSitesManager.getSite(siteId).then(function(site) {
                var params = {
                    scormid: id
                };
                return site.write('mod_scorm_view_scorm', params);
            });
        }
        return $q.reject();
    };

    /**
     * Report a SCO as being launched.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#logLaunchSco
     * @param {Number} scormId  SCORM ID.
     * @param {Number} scoId    SCO ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the WS call is successful.
     */
    self.logLaunchSco = function(scormId, scoId, siteId) {
        siteId = siteId || $mmSite.getId();
        var params = {
            scormid: scormId,
            scoid: scoId
        };
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.write('mod_scorm_launch_sco', params).then(function(response) {
                if (!response || !response.status) {
                    return $q.reject();
                }
            });
        });
    };

    /**
     * Prefetches and unzips the SCORM package, and also prefetches some WS calls.
     * @see $mmaModScorm#_downloadOrPrefetch
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#prefetch
     * @param {Object} scorm SCORM object returned by $mmaModScorm#getScorm.
     * @return {Promise}     Promise resolved when prefetch is done. Resolve param is a warning message (if needed).
     */
    self.prefetch = function(scorm) {
        var promises = [];

        promises.push(self.prefetchPackage(scorm));

        promises.push(self.prefetchData(scorm).catch(function() {
            // If prefetchData fails we don't want to fail the whole downloaded, so we'll ignore the error for now.
            // @todo Implement a warning system so the user knows which SCORMs have failed.
        }));

        return $q.all(promises);
    };

    /**
     * Prefetches some WS data for a SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#prefetchData
     * @param {Object} scorm    SCORM object returned by $mmaModScorm#getScorm.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the data is prefetched.
     */
    self.prefetchData = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];

        // Prefetch number of attempts (including not completed).
        promises.push($mmaModScormOnline.getAttemptCount(siteId, scorm.id).catch(function() {
            // If it fails, assume we have no attempts.
            return 0;
        }).then(function(numAttempts) {
            if (numAttempts > 0) {
                // Get user data for each attempt.
                var datapromises = [],
                    attempts = [];

                // Fill an attempts array to be able to use forEach and prevent problems with attempt variable changing.
                for (var i = 1; i <= numAttempts; i++) {
                    attempts.push(i);
                }

                attempts.forEach(function(attempt) {
                    datapromises.push($mmaModScormOnline.getScormUserData(siteId, scorm.id, attempt).catch(function(err) {
                        // Ignore failures of all the attempts that aren't the last one.
                        if (attempt == numAttempts) {
                            return $q.reject(err);
                        }
                    }));
                });

                return $q.all(datapromises);
            } else {
                // No attempts. We'll still try to get user data to be able to identify SCOs not visible and so.
                return $mmaModScormOnline.getScormUserData(siteId, scorm.id, 0);
            }
        }));

        // Prefetch SCOs.
        promises.push(self.getScos(scorm.id, siteId));

        return $q.all(promises);
    };

    /**
     * Prefetches and unzips the SCORM package.
     * @see $mmaModScorm#_downloadOrPrefetch
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#prefetchPackage
     * @param {Object} scorm SCORM object returned by $mmaModScorm#getScorm.
     * @return {Promise}     Promise resolved when the package is prefetched and unzipped.
     */
    self.prefetchPackage = function(scorm) {
        return self._downloadOrPrefetch(scorm, true);
    };

    /**
     * Saves a SCORM tracking record.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#saveTracks
     * @param  {Number} scoId      Sco ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Object[]} tracks   Tracking data to store.
     * @param  {Boolean} offline   True if attempt is offline, false otherwise.
     * @param  {Object} scorm      SCORM.
     * @param  {Object} [userData] User data for this attempt and SCO. If not defined, it will be retrieved from DB. Recommended.
     * @param  {String} [siteId]   Site ID. If not defined, current site.
     * @return {Promise}           Promise resolved when data is saved.
     */
    self.saveTracks = function(scoId, attempt, tracks, offline, scorm, userData, siteId) {
        siteId = siteId || $mmSite.getId();
        if (offline) {
            var promise = userData ? $q.when(userData) : self.getScormUserData(scorm.id, attempt, offline, siteId);
            return promise.then(function(userData) {
                return $mmaModScormOffline.saveTracks(siteId, scorm, scoId, attempt, tracks, userData);
            });
        } else {
            return $mmaModScormOnline.saveTracks(siteId, scorm.id, scoId, attempt, tracks);
        }
    };

    /**
     * Saves a SCORM tracking record using a synchronous call.
     * Please use this function only if synchronous is a must. It's recommended to use $mmaModScorm#saveTracks.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#saveTracksSync
     * @param  {Number} scoId      Sco ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Object[]} tracks   Tracking data to store.
     * @param  {Boolean} offline   True if attempt is offline, false otherwise.
     * @param  {Object} [scorm]    SCORM. Required if offline=true.
     * @param  {Object} [userData] User data for this attempt and SCO. Required if offline=true.
     * @return {Boolean}           In online returns true if data is inserted, false otherwise.
     *                             In offline returns true if data to insert is valid, false otherwise. True doesn't mean that the
     *                             data has been stored, this function can return true but the insertion can still fail somehow.
     */
    self.saveTracksSync = function(scoId, attempt, tracks, offline, scorm, userData) {
        if (offline) {
            return $mmaModScormOffline.saveTracksSync(scorm, scoId, attempt, tracks, userData);
        } else {
            return $mmaModScormOnline.saveTracksSync(scoId, attempt, tracks);
        }
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

.constant('mmaModScormOfflineAttemptsStore', 'mod_scorm_offline_attempts')
.constant('mmaModScormOfflineTracksStore', 'mod_scorm_offline_scos_tracks')

.config(["$mmSitesFactoryProvider", "mmaModScormOfflineAttemptsStore", "mmaModScormOfflineTracksStore", function($mmSitesFactoryProvider, mmaModScormOfflineAttemptsStore, mmaModScormOfflineTracksStore) {
    var stores = [
        {
            name: mmaModScormOfflineAttemptsStore,
            keyPath: ['scormid', 'userid', 'attempt'],
            indexes: [
                {
                    name: 'attempt' // Attempt number.
                },
                {
                    name: 'userid'
                },
                {
                    name: 'scormid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'timemodified'
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'scormAndUser',
                    generator: function(obj) {
                        return [obj.scormid, obj.userid];
                    }
                }
            ]
        },
        {
            name: mmaModScormOfflineTracksStore,
            keyPath: ['userid', 'scormid', 'scoid', 'attempt', 'element'],
            indexes: [
                {
                    name: 'userid'
                },
                {
                    name: 'scormid'
                },
                {
                    name: 'scoid'
                },
                {
                    name: 'attempt'
                },
                {
                    name: 'element'
                },
                {
                    name: 'synced'
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'scormUserAttempt',
                    generator: function(obj) {
                        return [obj.scormid, obj.userid, obj.attempt];
                    }
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'scormUserAttemptSynced',
                    generator: function(obj) {
                        return [obj.scormid, obj.userid, obj.attempt, obj.synced];
                    }
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Service to handle SCORM offline features.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormOffline
 */
.factory('$mmaModScormOffline', ["$mmSite", "$mmUtil", "$q", "$log", "$mmSitesManager", "mmaModScormOfflineAttemptsStore", "mmaModScormOfflineTracksStore", function($mmSite, $mmUtil, $q, $log, $mmSitesManager, mmaModScormOfflineAttemptsStore,
            mmaModScormOfflineTracksStore) {
    $log = $log.getInstance('$mmaModScormOffline');

    var self = {},
        blockedScorms = {};

    /**
     * Changes an attempt number in the data stored in offline.
     * This function is used to convert attempts into new attempts, so the stored snapshot will be removed and
     * entries will be marked as not synced.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#changeAttemptNumber
     * @param {String} siteId     Site ID.
     * @param {Object} scormId    SCORM ID.
     * @param {Number} attempt    Number of the attempt to change.
     * @param {Number} newAttempt New attempt number.
     * @param {Number} [userId]   User ID. If not defined use site's current user.
     * @return {Promise}          Promise resolved when the attempt number changes.
     */
    self.changeAttemptNumber = function(siteId, scormId, attempt, newAttempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Change attempt number from ' + attempt + ' to ' + newAttempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            var db = site.getDb(),
                newEntry = {
                    scormid: scormId,
                    userid: userId,
                    attempt: newAttempt,
                    timemodified: $mmUtil.timestamp()
                };

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            blockedScorms[siteId][scormId] = true; // Block the SCORM so it can't be synced.

            // Get current data.
            return db.get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).then(function(entry) {
                newEntry.timecreated = entry.timecreated;
                newEntry.courseid = entry.courseid;

                // Insert new attempt.
                return db.insert(mmaModScormOfflineAttemptsStore, newEntry).then(function() {
                    // Copy tracking data to the new attempt.
                    return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                        var promises = [];
                        angular.forEach(entries, function(entry) {
                            entry.attempt = newAttempt;
                            entry.synced = 0;
                            promises.push(db.insert(mmaModScormOfflineTracksStore, entry));
                        });

                        return $mmUtil.allPromises(promises).then(function() {
                            // All entries inserted. Delete the old attempt.
                            return self.deleteAttempt(siteId, scormId, attempt).catch(function() {
                                // The delete failed, it shouldn't happen. Let's retry once.
                                return self.deleteAttempt(siteId, scormId, attempt).catch(function() {});
                            });
                        });
                    }).catch(function() {
                        // Failed to get the data, remove the new attempt.
                        return self.deleteAttempt(siteId, scormId, newAttempt).then(function() {
                            return $q.reject();
                        });
                    });
                });
            }).finally(function() {
                blockedScorms[siteId][scormId] = false; // Unblock the SCORM.
            });
        });
    };

    /**
     * Clear blocked SCORMs.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#clearBlockedScorms
     * @param {String} [siteId] If set, clear the blocked SCORMs only for this site. Otherwise clear all SCORMs.
     * @return {Void}
     */
    self.clearBlockedScorms = function(siteId) {
        if (siteId) {
            delete blockedScorms[siteId];
        } else {
            blockedScorms = {};
        }
    };

    /**
     * Creates a new offline attempt. It can be created from scratch or as a copy of another attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#createNewAttempt
     * @param {String} siteId     Site ID.
     * @param {Object} scorm      SCORM.
     * @param {Number} [userId]   User ID. If not defined use site's current user.
     * @param {Number} attempt    Number of the new attempt.
     * @param {Object} userData   User data to store in the attempt.
     * @param {Object} [snapshot] Optional. Snapshot to store in the attempt.
     * @return {Promise}          Promise resolved when the new attempt is created.
     */
    self.createNewAttempt = function(siteId, scorm, userId, attempt, userData, snapshot) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Creating new offline attempt ' + attempt + ' in SCORM ' + scorm.id);
            userId = userId || site.getUserId();

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            blockedScorms[siteId][scorm.id] = true; // Block the SCORM so it can't be synced.

            // Create attempt in DB.
            var db = site.getDb(),
                entry = {
                    scormid: scorm.id,
                    userid: userId,
                    attempt: attempt,
                    courseid: scorm.course,
                    timecreated: $mmUtil.timestamp(),
                    timemodified: $mmUtil.timestamp()
                };

            if (snapshot) {
                // Save a snapshot of the data we had when we created the attempt.
                // Remove the default data, we don't want to store it.
                entry.snapshot = removeDefaultData(snapshot);
            }

            return db.insert(mmaModScormOfflineAttemptsStore, entry).then(function() {
                // Store all the data in userData.
                var promises = [];
                angular.forEach(userData, function(sco) {
                    var tracks = [];
                    angular.forEach(sco.userdata, function(value, element) {
                        tracks.push({element: element, value: value});
                    });
                    promises.push(self.saveTracks(siteId, scorm, sco.scoid, attempt, tracks, userData));
                });
                return $q.all(promises);
            }).finally(function() {
                blockedScorms[siteId][scorm.id] = false; // Unblock the SCORM.
            });
        });
    };

    /**
     * Delete all the stored data from an attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#deleteAttempt
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when all the data has been deleted.
     */
    self.deleteAttempt = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Delete offline attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                var promises = [],
                    db = site.getDb();

                // Delete all the tracks.
                angular.forEach(entries, function(entry) {
                    var entryId = [entry.userid, entry.scormid, entry.scoid, entry.attempt, entry.element];
                    promises.push(db.remove(mmaModScormOfflineTracksStore, entryId));
                });

                // Delete the attempt.
                promises.push(db.remove(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]));

                return $q.all(promises);
            });
        });
    };

    /**
     * Helper function to return a formatted list of interactions for reports.
     * This function is based in Moodle's scorm_format_interactions.
     *
     * @param  {Object} scoUserData Userdata from a certain SCO.
     * @return {Object}             Formatted userdata.
     */
    function formatInteractions(scoUserData) {
        var formatted = {};

        // Defined in order to unify scorm1.2 and scorm2004.
        formatted.score_raw = '';
        formatted.status = '';
        formatted.total_time = '00:00:00';
        formatted.session_time = '00:00:00';

        angular.forEach(scoUserData, function(value, element) {
            // Ignore elements that are calculated.
            if (element == 'score_raw' || element == 'status' || element == 'total_time' || element == 'session_time') {
                return;
            }

            formatted[element] = value;
            switch (element) {
                case 'cmi.core.lesson_status':
                case 'cmi.completion_status':
                    if (value == 'not attempted') {
                        value = 'notattempted';
                    }
                    formatted.status = value;
                    break;
                case 'cmi.core.score.raw':
                case 'cmi.score.raw':
                    formatted.score_raw = $mmUtil.roundToDecimals(value, 2); // Round to 2 decimals max.
                    break;
                case 'cmi.core.session_time':
                case 'cmi.session_time':
                    formatted.session_time = value;
                    break;
                case 'cmi.core.total_time':
                case 'cmi.total_time':
                    formatted.total_time = value;
                    break;
            }
        });

        return formatted;
    }

    /**
     * Get launch URLs from a list of SCOs, indexing them by SCO ID.
     *
     * @param  {Object[]} scos List of SCOs. Each SCO needs to have 'id' and 'launch' properties.
     * @return {Object}        Launch URLs indexed by SCO ID.
     */
    function getLaunchUrlsFromScos(scos) {
        var response = {};
        angular.forEach(scos, function(sco) {
            response[sco.id] = sco.launch;
        });
        return response;
    }

    /**
     * Get all the offline attempts in a certain site.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAllAttempts
     * @param {String} [siteId] Site ID. If not set, use current site.
     * @return {Promise}        Promise resolved when the offline attempts are retrieved.
     */
    self.getAllAttempts = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            if (!db) {
                return $q.reject();
            }

            return db.getAll(mmaModScormOfflineAttemptsStore);
        });
    };

    /**
     * Get the offline attempts done by a user in the given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAttempts
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when the offline attempts are retrieved.
     */
    self.getAttempts = function(siteId, scormId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var db = site.getDb();
            return db.whereEqual(mmaModScormOfflineAttemptsStore, 'scormAndUser', [scormId, userId]).then(function(attempts) {
                return attempts;
            });
        });
    };

    /**
     * Get the snapshot of an attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAttemptSnapshot
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved with the snapshot or undefined if no snapshot.
     */
    self.getAttemptSnapshot = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).catch(function() {
                return {}; // Attempt not found.
            }).then(function(entry) {
                return entry.snapshot;
            });
        });
    };

    /**
     * Get the creation time of an attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAttemptCreationTime
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved with time the attempt was created.
     */
    self.getAttemptCreationTime = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).catch(function() {
                return {}; // Attempt not found.
            }).then(function(entry) {
                return entry.timecreated;
            });
        });
    };

    /**
     * Get data stored in local DB for a certain scorm and attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getScormStoredData
     * @param {String} siteId            Site ID.
     * @param {Number} scormId           SCORM ID.
     * @param {Number} attempt           Attempt number.
     * @param {Number} [userId]          User ID. If not defined use site's current user.
     * @param {Boolean} excludeSynced    True if it should only return not synced entries.
     * @param {Boolean} excludeNotSynced True if it should only return synced entries.
     * @return {Promise}                 Promise resolved with the entries.
     */
    self.getScormStoredData = function(siteId, scormId, attempt, userId, excludeSynced, excludeNotSynced) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var where;

            if (excludeSynced && excludeNotSynced) {
                return $q.when([]);
            } else if (excludeSynced || excludeNotSynced) {
                where = ['scormUserAttemptSynced', '=', [scormId, userId, attempt, excludeNotSynced ? 1 : 0]];
            } else {
                where = ['scormUserAttempt', '=', [scormId, userId, attempt]];
            }
            return site.getDb().query(mmaModScormOfflineTracksStore, where);
        });
    };

    /**
     * Get the user data for a certain SCORM and offline attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getScormUserData
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @param {Object[]} scos   SCOs returned by $mmaModScorm#getScos. Required.
     * @return {Promise}        Promise resolved when the user data is retrieved.
     */
    self.getScormUserData = function(siteId, scormId, attempt, userId, scos) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            // Get user data. Ordering when using a compound index is complex, so we won't order by scoid.
            return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                var response = {},
                    launchUrls = getLaunchUrlsFromScos(scos),
                    userId = site.getUserId(),
                    username = site.getInfo().username,
                    fullName = site.getInfo().fullname;

                // Gather user data retrieved from DB, grouping it by scoid.
                angular.forEach(entries, function(entry) {
                    var scoid = entry.scoid;
                    if (!response[scoid]) {
                        // Initialize SCO.
                        response[scoid] = {
                            scoid: scoid,
                            userdata: {
                                userid: userId,
                                scoid: scoid,
                                timemodified: 0
                            }
                        };
                    }
                    response[scoid].userdata[entry.element] = entry.value;
                    if (entry.timemodified > response[scoid].userdata.timemodified) {
                        response[scoid].userdata.timemodified = entry.timemodified;
                    }
                });

                // Format each user data retrieved.
                angular.forEach(response, function(sco) {
                    sco.userdata = formatInteractions(sco.userdata);
                });

                // Create empty entries for the SCOs without user data stored.
                angular.forEach(scos, function(sco) {
                    if (!response[sco.id]) {
                        response[sco.id] = {
                            scoid: sco.id,
                            userdata: {
                                status: '',
                                score_raw: ''
                            }
                        };
                    }
                });

                // Calculate defaultdata.
                angular.forEach(response, function(sco) {
                    sco.defaultdata = {};
                    sco.defaultdata['cmi.core.student_id'] = username;
                    sco.defaultdata['cmi.core.student_name'] = fullName;
                    sco.defaultdata['cmi.core.lesson_mode'] = 'normal'; // Overridden in player.
                    sco.defaultdata['cmi.core.credit'] = 'credit'; // Overridden in player.
                    if (sco.userdata.status === '') {
                        sco.defaultdata['cmi.core.entry'] = 'ab-initio';
                    } else if (sco.userdata['cmi.core.exit'] === 'suspend') {
                        sco.defaultdata['cmi.core.entry'] = 'resume';
                    } else {
                        sco.defaultdata['cmi.core.entry'] = '';
                    }
                    sco.defaultdata['cmi.student_data.mastery_score'] = scormIsset(sco.userdata, 'masteryscore');
                    sco.defaultdata['cmi.student_data.max_time_allowed'] = scormIsset(sco.userdata, 'max_time_allowed');
                    sco.defaultdata['cmi.student_data.time_limit_action'] = scormIsset(sco.userdata, 'time_limit_action');
                    sco.defaultdata['cmi.core.total_time'] = scormIsset(sco.userdata, 'cmi.core.total_time', '00:00:00');
                    sco.defaultdata['cmi.launch_data'] = launchUrls[sco.scoid];

                    // Now handle standard userdata items.
                    sco.defaultdata['cmi.core.lesson_location'] = scormIsset(sco.userdata, 'cmi.core.lesson_location');
                    sco.defaultdata['cmi.core.lesson_status'] = scormIsset(sco.userdata, 'cmi.core.lesson_status');
                    sco.defaultdata['cmi.core.score.raw'] = scormIsset(sco.userdata, 'cmi.core.score.raw');
                    sco.defaultdata['cmi.core.score.max'] = scormIsset(sco.userdata, 'cmi.core.score.max');
                    sco.defaultdata['cmi.core.score.min'] = scormIsset(sco.userdata, 'cmi.core.score.min');
                    sco.defaultdata['cmi.core.exit'] = scormIsset(sco.userdata, 'cmi.core.exit');
                    sco.defaultdata['cmi.suspend_data'] = scormIsset(sco.userdata, 'cmi.suspend_data');
                    sco.defaultdata['cmi.comments'] = scormIsset(sco.userdata, 'cmi.comments');
                    sco.defaultdata['cmi.student_preference.language'] = scormIsset(sco.userdata, 'cmi.student_preference.language');
                    sco.defaultdata['cmi.student_preference.audio'] = scormIsset(sco.userdata, 'cmi.student_preference.audio', '0');
                    sco.defaultdata['cmi.student_preference.speed'] = scormIsset(sco.userdata, 'cmi.student_preference.speed', '0');
                    sco.defaultdata['cmi.student_preference.text'] = scormIsset(sco.userdata, 'cmi.student_preference.text', '0');

                    // Some data needs to be both in default data and user data.
                    sco.userdata.student_id = username;
                    sco.userdata.student_name = fullName;
                    sco.userdata.mode = sco.defaultdata['cmi.core.lesson_mode'];
                    sco.userdata.credit = sco.defaultdata['cmi.core.credit'];
                    sco.userdata.entry = sco.defaultdata['cmi.core.entry'];
                });

                return response;
            });
        });
    };

    /**
     * Function to insert a track in the DB. Please do not use it directly, use insertTrack instead.
     *
     * @param  {Object} db           Site's DB.
     * @param  {Number} userId       User ID.
     * @param  {Number} scormId      SCORM ID.
     * @param  {Number} scoId        SCO ID.
     * @param  {Number} attempt      Attempt number.
     * @param  {String} element      Name of the element to insert.
     * @param  {Mixed} value         Value of the element to insert.
     * @param  {Boolean} synchronous True if insert should NOT return a promise. Please use it only if synchronous is a must.
     * @return {Boolean|Promise}     Returns a promise if synchronous=false, otherwise returns a boolean.
     */
    function insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, synchronous) {
        var entry = {
            userid: userId,
            scormid: scormId,
            scoid: scoId,
            attempt: attempt,
            element: element,
            value: value,
            timemodified: $mmUtil.timestamp(),
            synced: 0
        };
        if (synchronous) {
            return db.insertSync(mmaModScormOfflineTracksStore, entry);
        } else {
            return db.insert(mmaModScormOfflineTracksStore, entry);
        }
    }

    /**
     * Insert a track in the offline tracks store.
     * This function is based on Moodle's scorm_insert_track.
     *
     * @param {String} siteId           Site ID.
     * @param  {Number} [userId]        User ID. If not set use site's current user.
     * @param  {Number} scormId         SCORM ID.
     * @param  {Number} scoId           SCO ID.
     * @param  {Number} attempt         Attempt number.
     * @param  {String} element         Name of the element to insert.
     * @param  {Mixed} value            Value of the element to insert.
     * @param  {Boolean} forceCompleted True if SCORM forces completed.
     * @param  {Object} [scoData]       User data for the given SCO.
     * @return {Promise}                Promise resolved when the insert is done.
     */
    function insertTrack(siteId, userId, scormId, scoId, attempt, element, value, forceCompleted, scoData) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            scoData = scoData || {};

            var promises = [], // List of promises for actions previous to the real insert.
                lessonStatusInserted = false,
                scoUserData = scoData.userdata || {},
                db = site.getDb();

            if (forceCompleted) {
                if (element == 'cmi.core.lesson_status' && value == 'incomplete') {
                    if (scoUserData['cmi.core.score.raw']) {
                        value = 'completed';
                    }
                }
                if (element == 'cmi.core.score.raw') {
                    if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {
                        lessonStatusInserted = true;
                        promises.push(insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed'));
                    }
                }
            }

            return $q.all(promises).then(function() {
                // Don't update x.start.time, keep the original value.
                if (!scoUserData[element] || element != 'x.start.time') {

                    return insertTrackToDB(db, userId, scormId, scoId, attempt, element, value).catch(function() {
                        if (lessonStatusInserted) {
                            // Rollback previous insert.
                            return insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete')
                                    .then(function() {
                                return $q.reject();
                            });
                        }
                        return $q.reject();
                    });
                }
            });
        });
    }

    /**
     * Insert a track in the offline tracks store, returning a synchronous value.
     * Please use this function only if synchronous is a must. It's recommended to use insertTrack.
     * This function is based on Moodle's scorm_insert_track.
     *
     * @param  {Number} [userId]        User ID. If not set use current user.
     * @param  {Number} scormId         SCORM ID.
     * @param  {Number} scoId           SCO ID.
     * @param  {Number} attempt         Attempt number.
     * @param  {String} element         Name of the element to insert.
     * @param  {Mixed} value            Value of the element to insert.
     * @param  {Boolean} forceCompleted True if SCORM forces completed.
     * @param  {Object} [scoData]       User data for the given SCO.
     * @return {Promise}                Promise resolved when the insert is done.
     */
    function insertTrackSync(userId, scormId, scoId, attempt, element, value, forceCompleted, scoData) {
        userId = userId || $mmSite.getUserId();
        scoData = scoData || {};

        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return false;
        }

        var lessonStatusInserted = false,
            scoUserData = scoData.userdata || {},
            db = $mmSite.getDb();

        if (forceCompleted) {
            if (element == 'cmi.core.lesson_status' && value == 'incomplete') {
                if (scoUserData['cmi.core.score.raw']) {
                    value = 'completed';
                }
            }
            if (element == 'cmi.core.score.raw') {
                if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {
                    lessonStatusInserted = true;
                    if (!insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed', true)) {
                        return false;
                    }
                }
            }
        }

        // Don't update x.start.time, keep the original value.
        if (!scoUserData[element] || element != 'x.start.time') {
            if (!insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, true)) {
                // Insert failed.
                if (lessonStatusInserted) {
                    // Rollback previous insert.
                    insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete', true);
                }
                return false;
            }
            return true;
        }
    }

    /**
     * Check if a SCORM is blocked by a writing function.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#isScormBlocked
     * @param  {String} siteId   Site ID.
     * @param  {Number} scormId  SCORM ID.
     * @return {Boolean}         True if blocked, false otherwise.
     */
    self.isScormBlocked = function(siteId, scormId) {
        if (!blockedScorms[siteId]) {
            return false;
        }
        return !!blockedScorms[siteId][scormId];
    };

    /**
     * Mark all the entries from a SCO and attempt as synced.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#markAsSynced
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @param {Number} scoId    SCO ID.
     * @return {Promise}        Promise resolved when marked.
     */
    self.markAsSynced = function(siteId, scormId, attempt, userId, scoId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Mark SCO ' + scoId + ' as synced for attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            return self.getScormStoredData(siteId, scormId, attempt, userId, true).then(function(entries) {
                var promises = [],
                    db = site.getDb();

                angular.forEach(entries, function(entry) {
                    if (entry.scoid == scoId) {
                        entry.synced = 1;
                        promises.push(db.insert(mmaModScormOfflineTracksStore, entry));
                    }
                });

                return $q.all(promises);
            });
        });
    };

    /**
     * Removes the default data form user data.
     *
     * @param  {Object} userData User data returned by $mmaModScorm#getScormUserData.
     * @return {Object}          User data without default data.
     */
    function removeDefaultData(userData) {
        var result = angular.copy(userData);
        angular.forEach(result, function(sco) {
            delete sco.defaultdata;
        });
        return result;
    }

    /**
     * Saves a SCORM tracking record in offline.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#saveTracks
     * @param {String} siteId      Site ID.
     * @param  {Object} scorm      SCORM.
     * @param  {Number} scoId      Sco ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Object[]} tracks   Tracking data to store.
     * @param  {Object} userData   User data for this attempt and SCO.
     * @return {Promise}           Promise resolved when data is saved.
     */
    self.saveTracks = function(siteId, scorm, scoId, attempt, tracks, userData) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var userId = site.getUserId(),
                initialBlocked;

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            initialBlocked = !!blockedScorms[siteId][scorm.id]; // Save initial blocked state.
            blockedScorms[siteId][scorm.id] = true; // Block the SCORM so it can't be synced.

            // Insert all the tracks.
            var promises = [];
            angular.forEach(tracks, function(track) {
                promises.push(insertTrack(siteId, userId, scorm.id, scoId, attempt,
                                            track.element, track.value, scorm.forcecompleted, userData[scoId]));
            });
            return $q.all(promises).finally(function() {
                if (!initialBlocked) {
                    blockedScorms[siteId][scorm.id] = false; // Unblock the SCORM only if it wasn't blocked by another function.
                }
            });
        });
    };

    /**
     * Saves a SCORM tracking record in offline returning a synchronous value.
     * Please use this function only if synchronous is a must. It's recommended to use $mmaModScormOffline#saveTracks.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#saveTracksSync
     * @param  {Object} scorm    SCORM.
     * @param  {Number} scoId    Sco ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {Object[]} tracks Tracking data to store.
     * @param  {Object} userData User data for this attempt and SCO.
     * @return {Boolean}         True if data to insert is valid, false otherwise. Returning true doesn't mean that the data
     *                           has been stored, this function can return true but the insertion can still fail somehow.
     */
    self.saveTracksSync = function(scorm, scoId, attempt, tracks, userData) {
        var userId = $mmSite.getUserId(),
            success = true;

        angular.forEach(tracks, function(track) {
            if (!insertTrackSync(userId, scorm.id, scoId, attempt, track.element, track.value,
                                    scorm.forcecompleted, userData[scoId])) {
                success = false;
            }
        });
        return success;
    };

    /**
     * Check for a parameter in userdata and return it if it's set or return 'ifempty' if it's empty.
     * Based on Moodle's scorm_isset function.
     *
     * @param  {Object} userdata  Contains user's data.
     * @param  {String} param     Name of parameter that should be checked.
     * @param  {Mixed}  [ifempty] Value to be replaced with if param is not set.
     * @return {Mixed}            Value from userdata[param] if set, ifempty otherwise.
     */
    function scormIsset(userdata, param, ifempty) {
        if (typeof ifempty == 'undefined') {
            ifempty = '';
        }

        if (typeof userdata[param] != 'undefined') {
            return userdata[param];
        }
        return ifempty;
    }

    /**
     * Set an attempt's snapshot.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#setAttemptSnapshot
     * @param {String} siteId      Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Object} userData User data to store as snapshot.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when snapshot has been stored.
     */
    self.setAttemptSnapshot = function(siteId, scormId, attempt, userData, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Set snapshot for attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).then(function(entry) {
                entry.snapshot = removeDefaultData(userData);
                entry.timemodified = $mmUtil.timestamp();
                return site.getDb().insert(mmaModScormOfflineAttemptsStore, entry);
            });
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Service to handle SCORM online features.
 * This service holds getters and setters that have some kind of equivalent feature in $mmaModScormOffline.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormOnline
 */
.factory('$mmaModScormOnline', ["$mmSitesManager", "$mmSite", "$q", "$mmWS", "$log", "mmCoreWSPrefix", function($mmSitesManager, $mmSite, $q, $mmWS, $log, mmCoreWSPrefix) {
    $log = $log.getInstance('$mmaModScormOnline');

    var self = {},
        blockedScorms = {};

    /**
     * Clear blocked SCORMs.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#clearBlockedScorms
     * @param {String} [siteId] If set, clear the blocked SCORMs only for this site. Otherwise clear all SCORMs.
     * @return {Void}
     */
    self.clearBlockedScorms = function(siteId) {
        if (siteId) {
            delete blockedScorms[siteId];
        } else {
            blockedScorms = {};
        }
    };

    /**
     * Get cache key for SCORM attempt count WS calls.
     *
     * @param {Number} scormId  SCORM ID.
     * @param {Number} [userId] User ID. If not defined, current user.
     * @return {String}         Cache key.
     */
    function getAttemptCountCacheKey(scormId, userId) {
        userId = userId || $mmSite.getUserId();
        return 'mmaModScorm:attemptcount:' + scormId + ':' + userId;
    }

    /**
     * Get the number of attempts done by a user in the given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#getAttemptCount
     * @param {String} siteId         Site ID.
     * @param {Number} scormId        SCORM ID.
     * @param {Number} [userId]       User ID. If not defined use site's current user.
     * @param {Boolean} ignoreMissing True if it should ignore attempts that haven't reported a grade/completion.
     * @param {Boolean} ignoreCache   True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise}              Promise resolved when the attempt count is retrieved.
     */
    self.getAttemptCount = function(siteId, scormId, userId, ignoreMissing, ignoreCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var params = {
                    scormid: scormId,
                    userid: userId,
                    ignoremissingcompletion: ignoreMissing ? 1 : 0
                },
                preSets = {
                    cacheKey: getAttemptCountCacheKey(scormId, userId)
                };

            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }

            return site.read('mod_scorm_get_scorm_attempt_count', params, preSets).then(function(response) {
                if (response && typeof response.attemptscount != 'undefined') {
                    return response.attemptscount;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Get cache key for SCORM user data WS calls.
     *
     * @param {Number} scormId SCORM ID.
     * @param {Number} attempt Attempt number.
     * @return {String}        Cache key.
     */
    function getScormUserDataCacheKey(scormId, attempt) {
        return getScormUserDataCommonCacheKey(scormId) + ':' + attempt;
    }

    /**
     * Get common cache key for SCORM user data WS calls.
     *
     * @param {Number} scormId SCORM ID.
     * @return {String}        Cache key.
     */
    function getScormUserDataCommonCacheKey(scormId) {
        return 'mmaModScorm:userdata:' + scormId;
    }

    /**
     * Get the user data for a certain SCORM and attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#getScormUserData
     * @param {String} siteId       Site ID.
     * @param {Number} scormId      SCORM ID.
     * @param {Number} attempt      Attempt number.
     * @param {Boolean} ignoreCache True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise}            Promise resolved when the user data is retrieved.
     */
    self.getScormUserData = function(siteId, scormId, attempt, ignoreCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    scormid: scormId,
                    attempt: attempt
                },
                preSets = {
                    cacheKey: getScormUserDataCacheKey(scormId, attempt)
                };

            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }

            return site.read('mod_scorm_get_scorm_user_data', params, preSets).then(function(response) {
                if (response && response.data) {
                    // Format the response.
                    var data = {};
                    angular.forEach(response.data, function(sco) {
                        var formattedDefaultData = {},
                            formattedUserData = {};

                        angular.forEach(sco.defaultdata, function(entry) {
                            formattedDefaultData[entry.element] = entry.value;
                        });
                        angular.forEach(sco.userdata, function(entry) {
                            formattedUserData[entry.element] = entry.value;
                        });

                        sco.defaultdata = formattedDefaultData;
                        sco.userdata = formattedUserData;

                        data[sco.scoid] = sco;
                    });
                    return data;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Invalidates attempt count.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#invalidateAttemptCount
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateAttemptCount = function(siteId, scormId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(getAttemptCountCacheKey(scormId, userId));
        });
    };

    /**
     * Invalidates SCORM user data for all attempts.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#invalidateScormUserData
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateScormUserData = function(siteId, scormId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getScormUserDataCommonCacheKey(scormId));
        });
    };

    /**
     * Check if a SCORM is blocked by a writing function.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#isScormBlocked
     * @param  {String} siteId   Site ID. If not set, use current site.
     * @param  {Number} scormId  SCORM ID.
     * @return {Boolean}         True if blocked, false otherwise.
     */
    self.isScormBlocked = function(siteId, scormId) {
        if (!blockedScorms[siteId]) {
            return false;
        }
        return !!blockedScorms[siteId][scormId];
    };

    /**
     * Saves a SCORM tracking record.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#saveTracks
     * @param  {String} siteId   Site ID. If not set, use current site.
     * @param  {Number} scormId  SCORM ID.
     * @param  {Number} scoId    Sco ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {Object[]} tracks Tracking data.
     * @return {Promise}         Promise resolved when data is saved.
     */
    self.saveTracks = function(siteId, scormId, scoId, attempt, tracks) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                scoid: scoId,
                attempt: attempt,
                tracks: tracks
            };

            if (!tracks || !tracks.length) {
                return $q.when(); // Nothing to save.
            }

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            blockedScorms[siteId][scormId] = true;

            return site.write('mod_scorm_insert_scorm_tracks', params).then(function(response) {
                if (response && response.trackids) {
                    return response.trackids;
                }
                return $q.reject();
            }).finally(function() {
                blockedScorms[siteId][scormId] = false;
            });
        });
    };

    /**
     * Saves a SCORM tracking record using a synchronous call.
     * Please use this function only if synchronous is a must. It's recommended to use $mmaModScorm#saveTracks.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#saveTracksSync
     * @param  {Number} scoId    Sco ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {Object[]} tracks Tracking data.
     * @return {Boolean}         True if success, false otherwise.
     */
    self.saveTracksSync = function(scoId, attempt, tracks) {
        var params = {
                scoid: scoId,
                attempt: attempt,
                tracks: tracks
            },
            preSets = {
                siteurl: $mmSite.getURL(),
                wstoken: $mmSite.getToken()
            },
            wsFunction = $mmSite.getCompatibleFunction('mod_scorm_insert_scorm_tracks'),
            response;

        if (!tracks || !tracks.length) {
            return true; // Nothing to save.
        }

        // Check if the method is available, use a prefixed version if possible.
        if (!$mmSite.wsAvailable(wsFunction, false)) {
            if ($mmSite.wsAvailable(mmCoreWSPrefix + wsFunction, false)) {
                wsFunction = mmCoreWSPrefix + wsFunction;
            } else {
                $log.error("WS function '" + wsFunction + "' is not available, even in compatibility mode.");
                return false;
            }
        }

        response = $mmWS.syncCall(wsFunction, params, preSets);
        if (response && !response.error && response.trackids) {
            return true;
        }
        return false;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

.constant('mmaModScormSynchronizationStore', 'mod_scorm_sync')

.config(["$mmSitesFactoryProvider", "mmaModScormSynchronizationStore", function($mmSitesFactoryProvider, mmaModScormSynchronizationStore) {
    var stores = [
        {
            name: mmaModScormSynchronizationStore,
            keyPath: 'scormid',
            indexes: []
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * SCORM synchronization service.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormSync
 */
.factory('$mmaModScormSync', ["$mmaModScorm", "$mmSite", "$q", "$translate", "$mmaModScormOnline", "$mmaModScormOffline", "$mmUtil", "$log", "mmaModScormSynchronizationStore", "mmaModScormSyncTime", "$mmConfig", "mmCoreSettingsSyncOnlyOnWifi", "$mmApp", "$mmEvents", "mmaModScormEventAutomSynced", "$mmSitesManager", function($mmaModScorm, $mmSite, $q, $translate, $mmaModScormOnline, $mmaModScormOffline, $mmUtil,
            $log, mmaModScormSynchronizationStore, mmaModScormSyncTime, $mmConfig, mmCoreSettingsSyncOnlyOnWifi, $mmApp,
            $mmEvents, mmaModScormEventAutomSynced, $mmSitesManager) {
    $log = $log.getInstance('$mmaModScormSync');

    var self = {},
        syncPromises = {}; // Store sync promises.

    /**
     * Get the synchronization time of a SCORM. Returns 0 if no time stored.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#getScormSyncTime
     * @param {Number} scormId  SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the time.
     */
    self.getScormSyncTime = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            return db.get(mmaModScormSynchronizationStore, scormId).then(function(entry) {
                return entry.time;
            }).catch(function() {
                return 0;
            });
        });
    };

    /**
     * Set the synchronization time of a SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#setScormSyncTime
     * @param {Number} scormId  SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @param {Number} [time]   Time to set. If not defined, current time.
     * @return {Promise}        Promise resolved when the time is set.
     */
    self.setScormSyncTime = function(scormId, siteId, time) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            if (typeof time == 'undefined') {
                time = new Date().getTime();
            }
            return db.insert(mmaModScormSynchronizationStore, {scormid: scormId, time: time});
        });
    };

    /**
     * Try to synchronize all SCORMs from current site that need it and haven't been synchronized in a while.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#syncAllScorms
     * @param {String} [siteId] Site ID to sync. If not defined, sync all sites.
     * @return {Promise}        Promise resolved when the sync is done.
     */
    self.syncAllScorms = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all SCORMs because device is offline.');
            return $q.reject();
        }

        // We first check sync settings and current connection to see if we can sync.
        return $mmConfig.get(mmCoreSettingsSyncOnlyOnWifi, true).then(function(syncOnlyOnWifi) {

            if (syncOnlyOnWifi && $mmApp.isNetworkAccessLimited()) {
                $log.debug('Cannot sync all SCORMs because device isn\'t using a WiFi network.');
                return $q.reject();
            }

            var promise;
            if (!siteId) {
                // No site ID defined, sync all sites.
                $log.debug('Try to sync SCORMs in all sites.');
                promise = $mmSitesManager.getSitesIds();
            } else {
                $log.debug('Try to sync SCORMs in site ' + siteId);
                promise = $q.when([siteId]);
            }

            return promise.then(function(siteIds) {
                var sitePromises = [];

                angular.forEach(siteIds, function(siteId) {
                    sitePromises.push($mmaModScormOffline.getAllAttempts(siteId).then(function(attempts) {
                        var scorms = [],
                            ids = [], // To prevent duplicates.
                            promises = [];

                        // Get the IDs of all the SCORMs that have something to be synced.
                        angular.forEach(attempts, function(attempt) {
                            if (ids.indexOf(attempt.scormid) == -1) {
                                ids.push(attempt.scormid);
                                scorms.push({
                                    id: attempt.scormid,
                                    courseid: attempt.courseid
                                });
                            }
                        });

                        // Sync all SCORMs that haven't been synced for a while and that aren't played right now.
                        angular.forEach(scorms, function(scorm) {
                            if (!$mmaModScorm.isScormBeingPlayed(scorm.id, siteId)) {
                                promises.push($mmaModScorm.getScormById(scorm.courseid, scorm.id, '', siteId).then(function(scorm) {
                                    return self.syncScormIfNeeded(scorm, siteId).then(function(warnings) {
                                        if (typeof warnings != 'undefined') {
                                            // We tried to sync. Send event.
                                            $mmEvents.trigger(mmaModScormEventAutomSynced, {
                                                siteid: siteId,
                                                scormid: scorm.id
                                            });
                                        }
                                    });
                                }));
                            }
                        });

                        return $q.all(promises);
                    }));
                });

                return $q.all(sitePromises);
            });
        });
    };

    /**
     * Send data from a SCORM offline attempt to the site.
     * Reserved for core use, please use $mmaModScormSync#syncScorm to synchronize SCORM data.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#_syncAttempt
     * @param  {Number} scormId  SCORM ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when the attempt is successfully synced.
     * @protected
     */
    self._syncAttempt = function(scormId, attempt, siteId) {
        siteId = siteId || $mmSite.getId();
        $log.debug('Try to sync attempt ' + attempt + ' in SCORM ' + scormId + ' and site ' + siteId);
        // Get only not synced entries.
        return $mmaModScormOffline.getScormStoredData(siteId, scormId, attempt, undefined, true).then(function(entries) {
            var scos = {},
                promises = [],
                somethingSynced = false;

            // Get data to send (only elements with dots like cmi.core.exit, in Mobile we store more data to make offline work).
            angular.forEach(entries, function(entry) {
                if (entry.element.indexOf('.') > -1) {
                    if (!scos[entry.scoid]) {
                        scos[entry.scoid] = [];
                    }
                    scos[entry.scoid].push({
                        element: entry.element,
                        value: entry.value
                    });
                }
            });

            angular.forEach(scos, function(tracks, scoId) {
                promises.push($mmaModScormOnline.saveTracks(siteId, scormId, scoId, attempt, tracks).then(function() {
                    // Sco data successfully sent. Mark them as synced. This is needed because some SCOs sync might fail.
                    return $mmaModScormOffline.markAsSynced(siteId, scormId, attempt, undefined, scoId).catch(function() {
                        // Ignore errors.
                    }).then(function() {
                        somethingSynced = true;
                    });
                }));
            });

            return $mmUtil.allPromises(promises).then(function() {
                // Attempt has been sent. Let's delete it from local.
                return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                    // Failed to delete (shouldn't happen). Let's retry once.
                    return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                        // Maybe there's something wrong with the data or the storage implementation.
                        $log.error('After sync: error deleting attempt ' + attempt + ' in SCORM ' + scormId);
                    });
                });
            }).catch(function() {
                if (somethingSynced) {
                    // Some SCOs have been synced and some not. We'll try to store a snapshot of the current state
                    // to be able to re-try the synchronization later.
                    $log.error('Error synchronizing some SCOs for attempt ' + attempt + ' in SCORM ' + scormId + '. Saving snapshot.');
                    return saveSyncSnapshot(scormId, attempt, siteId).then(function() {
                        return $q.reject();
                    });
                } else {
                    $log.error('Error synchronizing attempt ' + attempt + ' in SCORM ' + scormId);
                }
                return $q.reject();
            });
        });
    };

    /**
     * Save a snapshot from a synchronization.
     *
     * @param  {Number} scormId SCORM ID.
     * @param  {Number} attempt Attemot number.
     * @param  {String} siteId  Site ID.
     * @return {Promise}        Promise resolved when the snapshot is stored.
     */
    function saveSyncSnapshot(scormId, attempt, siteId) {
        // Try to get current state from Moodle.
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, true).then(function(data) {
            return $mmaModScormOffline.setAttemptSnapshot(siteId, scormId, attempt, data);
        }, function() {
            // Error getting user data from Moodle. We'll have to build it ourselves.
            // Let's try to get cached data about the attempt.
            return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId).catch(function() {
                // No cached data, Moodle has no data stored.
                return {};
            }).then(function(data) {
                // We need to add the synced data to the snapshot.
                return $mmaModScormOffline.getScormStoredData(siteId, scormId, attempt, undefined, false, true)
                            .then(function(synced) {
                    angular.forEach(synced, function(entry) {
                        if (!data[entry.scoid]) {
                            data[entry.scoid] = {
                                scoid: entry.scoid,
                                userdata: {}
                            };
                        }
                        data[entry.scoid].userdata[entry.element] = entry.value;
                    });
                    return $mmaModScormOffline.setAttemptSnapshot(siteId, scormId, attempt, data);
                });
            });
        });
    }

    /**
     * Sync a SCORM only if a certain time has passed since the last time.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#syncScormIfNeeded
     * @param {Object} scorm    SCORM downloaded.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the SCORM is synced or if it doesn't need to be synced.
     */
    self.syncScormIfNeeded = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.getScormSyncTime(scorm.id, siteId).then(function(time) {
            if (new Date().getTime() - mmaModScormSyncTime >= time) {
                return self.syncScorm(scorm, siteId);
            }
        });
    };

    /**
     * Try to synchronize a SCORM's attempts.
     * The promise returned will be resolved with an array with warnings if the synchronization is successful. A successful
     * synchronization doesn't mean that all the data has been sent to the site, it's possible that some attempt can't be sent.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#syncScorm
     * @param  {Object} scorm   SCORM to sync.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with warnings in success, rejected if synchronization fails.
     */
    self.syncScorm = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        var warnings = [],
            syncPromise,
            deleted = false;

        if (syncPromises[siteId] && syncPromises[siteId][scorm.id]) {
            // There's already a sync ongoing for this SCORM, return the promise.
            return syncPromises[siteId][scorm.id];
        } else if (!syncPromises[siteId]) {
            syncPromises[siteId] = {};
        }

        if ($mmaModScormOnline.isScormBlocked(siteId, scorm.id) || $mmaModScormOffline.isScormBlocked(siteId, scorm.id)) {
            $log.debug('Cannot sync SCORM ' + scorm.id + ' because it is blocked.');
            return $q.reject();
        }

        $log.debug('Try to sync SCORM ' + scorm.id + ' in site ' + siteId);

        // Prefetches data , set sync time and return warnings.
        function finishSync() {
            return $mmaModScorm.invalidateAllScormData(scorm.id, siteId).catch(function() {}).then(function() {
                return $mmaModScorm.prefetchData(scorm, siteId).then(function() {
                    return self.setScormSyncTime(scorm.id, siteId).catch(function() {
                        // Ignore errors.
                    }).then(function() {
                        return warnings; // No offline attempts, nothing to sync.
                    });
                });
            });
        }

        // Get attempts data. We ignore cache for online attempts, so this call will fail if offline or server down.
        syncPromise = $mmaModScorm.getAttemptCount(scorm.id, siteId, undefined, false, true).then(function(attemptsData) {
            if (!attemptsData.offline || !attemptsData.offline.length) {
                return finishSync();
            }

            var collisions = [],
                lastOnline = 0,
                promise;

            // Check if there are collisions between offline and online attempts (same number).
            angular.forEach(attemptsData.online, function(attempt) {
                lastOnline = Math.max(lastOnline, attempt);
                if (attemptsData.offline.indexOf(attempt) > -1) {
                    collisions.push(attempt);
                }
            });

            // Check if last online attempt is finished. Ignore cache.
            promise = lastOnline > 0 ? $mmaModScorm.isAttemptIncomplete(scorm.id, lastOnline, false, true, siteId) : $q.when(false);

            return promise.then(function(incomplete) {
                if (!collisions.length && !incomplete) {
                    // No collisions and last attempt is complete. Send offline attempts to Moodle.
                    var promises = [];
                    angular.forEach(attemptsData.offline, function(attempt) {
                        if (scorm.maxattempt == 0 || attempt <= scorm.maxattempt) {
                            promises.push(self._syncAttempt(scorm.id, attempt, siteId));
                        }
                    });
                    return $q.all(promises).then(function() {
                        return finishSync();
                    });

                } else if (collisions.length) {
                    // We have collisions, treat them.
                    return treatCollisions(scorm.id, siteId, collisions, lastOnline, attemptsData.offline).then(function(warns) {
                        warnings = warnings.concat(warns);

                        // The offline attempts might have changed since some collisions can be converted to new attempts.
                        return $mmaModScormOffline.getAttempts(siteId, scorm.id).then(function(entries) {
                            var promises = [],
                                cannotSyncSome = false;

                            entries = entries.map(function(entry) {
                                return entry.attempt; // Get only the attempt number.
                            });
                            if (incomplete && entries.indexOf(lastOnline) > -1) {
                                // Last online was incomplete, but it was continued in offline.
                                incomplete = false;
                            }

                            angular.forEach(entries, function(attempt) {
                                // We'll always sync attempts previous to lastOnline (failed sync or continued in offline).
                                // We'll only sync new attemps if last online attempt is completed.
                                if (!incomplete || attempt <= lastOnline) {
                                    if (scorm.maxattempt == 0 || attempt <= scorm.maxattempt) {
                                        promises.push(self._syncAttempt(scorm.id, attempt, siteId));
                                    }
                                } else {
                                    cannotSyncSome = true;
                                }
                            });
                            return $q.all(promises).then(function() {
                                if (cannotSyncSome) {
                                    warnings.push($translate.instant('mma.mod_scorm.warningsynconlineincomplete'));
                                }
                                return finishSync();
                            });
                        });
                    });
                } else {
                    // No collisions, but last online attempt is incomplete so we can't send offline attempts.
                    warnings.push($translate.instant('mma.mod_scorm.warningsynconlineincomplete'));
                    return finishSync();
                }
            });
        }).finally(function() {
            deleted = true;
            delete syncPromises[siteId][scorm.id];
        });

        if (!deleted) {
            syncPromises[siteId][scorm.id] = syncPromise;
        }
        return syncPromise;
    };

    /**
     * Treat collisions found in a SCORM synchronization process.
     *
     * @param  {Number} scormId           SCORM ID.
     * @param  {String} siteId            Site ID.
     * @param  {Number[]} collisions      Numbers of attempts that exist both in online and offline.
     * @param  {Number} lastOnline        Last online attempt.
     * @param  {Number[]} offlineAttempts Numbers of offline attempts.
     * @return {Promise}                  Promise resolved when the collisions have been treated. It returns warnings array.
     * @description
     *
     * Treat collisions found in a SCORM synchronization process. A collision is when an attempt exists both in offline
     * and online. A collision can be:
     *
     * - Two different attempts.
     * - An online attempt continued in offline.
     * - A failure in a previous sync.
     *
     * This function will move into new attempts the collisions that can't be merged. It will usually keep the order of the
     * offline attempts EXCEPT if the offline attempt was created after the last offline attempt (edge case).
     *
     * Edge case: A user creates offline attempts and when he syncs we retrieve an incomplete online attempt, so the offline
     * attempts cannot be synced. Then the user continues that online attempt and goes offline, so a collision is created.
     * When we perform the next sync we detect that this collision cannot be merged, so this offline attempt needs to be
     * created as a new attempt. Since this attempt was created after the last offline attempt, it will be added ot the end
     * of the list if the last attempt is completed. If the last attempt is not completed then the offline data will de deleted
     * because we can't create a new attempt.
     */
    function treatCollisions(scormId, siteId, collisions, lastOnline, offlineAttempts) {
        var warnings = [],
            promises = [],
            newAttemptsSameOrder = [], // Attempts that will be created as new attempts but keeping the current order.
            newAttemptsAtEnd = {}, // Attempts that will be created at the end of the list of attempts (should be max 1 attempt).
            lastCollision = Math.max.apply(Math, collisions),
            lastOffline = Math.max.apply(Math, offlineAttempts),
            lastOfflineIncomplete,
            lastOfflineCreated;

        // Get the creation time and the status (complete/incomplete) of the last offline attempt.
        function getLastOfflineAttemptData() {
            // Check if last offline attempt is incomplete.
            return $mmaModScorm.isAttemptIncomplete(scormId, lastOffline, true, false, siteId).then(function(incomplete) {
                lastOfflineIncomplete = incomplete;
                return $mmaModScormOffline.getAttemptCreationTime(siteId, scormId, lastOffline).then(function(time) {
                    lastOfflineCreated = time;
                });
            });
        }

        // Add an attempt to the right new attempts array if possible.
        // If the attempt cannot be created as a new attempt then it will be deleted.
        function addToNewOrDelete(attempt) {
            if (attempt == lastOffline) {
                newAttemptsSameOrder.push(attempt);
                return $q.when();
            }

            return $mmaModScormOffline.getAttemptCreationTime(siteId, scormId, attempt).then(function(time) {
                if (time > lastOfflineCreated) {
                    // This attempt was created after the last offline attempt, we'll add it to the end of the list if possible.
                    if (lastOfflineIncomplete) {
                        // It can't be added because the last offline attempt is incomplete, delete it.
                        $log.debug('Try to delete attempt ' + attempt + ' because it cannot be created as a new attempt.');
                        return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).then(function() {
                            warnings.push($translate.instant('mma.mod_scorm.warningofflinedatadeleted', {number: attempt}));
                        }).catch(function() {
                            // Maybe there's something wrong with the data or the storage implementation.
                        });
                    } else {
                        newAttemptsAtEnd[time] = attempt;
                    }

                } else {
                    newAttemptsSameOrder.push(attempt);
                }
            });
        }

        // Get needed data from the last offline attempt.
        return getLastOfflineAttemptData().then(function() {

            collisions.forEach(function(attempt) {
                // First get synced entries to detect if it was a failed synchronization.
                var getDataFn = $mmaModScormOffline.getScormStoredData,
                    promise = getDataFn(siteId, scormId, attempt, undefined, false, true).then(function(synced) {
                    if (synced && synced.length) {
                        // The attempt has synced entries, it seems to be a failed synchronization.
                        // Let's get the entries that haven't been synced, maybe it just failed to delete the attempt.
                        return getDataFn(siteId, scormId, attempt, undefined, true).then(function(entries) {
                            var hasDataToSend = false;
                            angular.forEach(entries, function(entry) {
                                if (entry.element.indexOf('.') > -1) {
                                    hasDataToSend = true;
                                }
                            });

                            if (hasDataToSend) {
                                // There are elements to sync. We need to check if it's possible to sync them or not.
                                return canRetrySync(scormId, siteId, attempt, lastOnline).catch(function() {
                                    // Cannot retry sync, we'll create a new offline attempt if possible.
                                    return addToNewOrDelete(attempt);
                                });
                            } else {
                                // Nothing to sync, delete the attempt.
                                return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                                    // Maybe there's something wrong with the data or the storage implementation.
                                });
                            }
                        });
                    } else {
                        // It's not a failed synchronization. Check if it's an attempt continued in offline.
                        return $mmaModScormOffline.getAttemptSnapshot(siteId, scormId, attempt).then(function(snapshot) {
                            if (snapshot && Object.keys(snapshot).length) {
                                // It has a snapshot, it means it continued an online attempt. We need to check if they've diverged.
                                // If it's the last attempt we don't need to ignore cache because we already did it.
                                var refresh = lastOnline != attempt;
                                return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, refresh)
                                            .then(function(data) {
                                    if (!snapshotEquals(snapshot, data)) {
                                        // Snapshot has diverged, it will be converted into a new attempt if possible.
                                        return addToNewOrDelete(attempt);
                                    }
                                });
                            } else {
                                // No snapshot, it's a different attempt.
                                newAttemptsSameOrder.push(attempt);
                            }
                        });
                    }
                });
                promises.push(promise);
            });

            return $q.all(promises).then(function() {
                return moveNewAttempts(scormId, siteId, newAttemptsSameOrder, lastOnline, lastCollision, offlineAttempts).then(function() {
                    // The new attempts that need to keep the order have been created. Now we'll create the new attempts
                    // at the end of the list of offline attempts. It should only be 1 attempt max.
                    lastOffline = lastOffline + newAttemptsSameOrder.length;
                    return createNewAttemptsAtEnd(scormId, siteId, newAttemptsAtEnd, lastOffline).then(function() {
                        return warnings;
                    });
                });
            });
        });
    }

    /**
     * Change the number of some offline attempts. We need to move all offline attempts after the collisions
     * too, otherwise we would overwrite data.
     * Example: We have offline attempts 1, 2 and 3. #1 and #2 have collisions. #1 can be synced, but #2 needs
     * to be a new attempt. #3 will now be #4, and #2 will now be #3.
     *
     * @param  {Number} scormId           SCORM ID.
     * @param  {String} siteId            Site ID.
     * @param  {Number[]} newAttempts     Attempts that need to be converted into new attempts.
     * @param  {Number} lastOnline        Last online attempt.
     * @param  {Number} lastCollision     Last attempt with collision (exists in online and offline).
     * @param  {Number[]} offlineAttempts Numbers of offline attempts.
     * @return {Promise}                  Promise resolved when attempts have been moved.
     */
    function moveNewAttempts(scormId, siteId, newAttempts, lastOnline, lastCollision, offlineAttempts) {
        if (!newAttempts.length) {
            return $q.when();
        }

        var promise = $q.when(),
            lastSuccessful;

        // Sort offline attempts in DESC order.
        offlineAttempts = offlineAttempts.sort(function(a, b) {
            return parseInt(a, 10) < parseInt(b, 10);
        });

        // First move the offline attempts after the collisions;
        angular.forEach(offlineAttempts, function(attempt) {
            if (attempt > lastCollision) {
                // We use a chain of promises because we need to move them in order.
                promise = promise.then(function() {
                    var newNumber = attempt + newAttempts.length;
                    return $mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, newNumber).then(function() {
                        lastSuccessful = attempt;
                    });
                });
            }
        });

        return promise.then(function() {
            var promises = [],
                successful = [];

            // Sort newAttempts in ASC order.
            newAttempts = newAttempts.sort(function(a, b) {
                return parseInt(a, 10) > parseInt(b, 10);
            });

            // Now move the attempts in newAttempts.
            angular.forEach(newAttempts, function(attempt, index) {
                // No need to use chain of promises.
                var newNumber = lastOnline + index + 1;
                promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, newNumber).then(function() {
                    successful.push(attempt);
                }));
            });

            return $q.all(promises).catch(function() {
                // Moving the new attempts failed (it shouldn't happen). Let's undo the new attempts move.
                promises = [];
                angular.forEach(successful, function(attempt) {
                    var newNumber = lastOnline + newAttempts.indexOf(attempt) + 1;
                    promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, newNumber, attempt));
                });
                return $mmUtil.allPromises(promises).then(function() {
                    return $q.reject(); // It will now enter the .catch that moves offline attempts after collisions.
                });
            });

        }).catch(function() {
            // Moving offline attempts after collisions failed (it shouldn't happen). Let's undo the changes.
            if (!lastSuccessful) {
                return $q.reject();
            }

            promise = $q.when();

            var attemptsToUndo = [];
            for (var i = lastSuccessful; offlineAttempts.indexOf(i) != -1; i++) {
                attemptsToUndo.push(i);
            }
            attemptsToUndo.forEach(function(attempt) {
                promise = promise.then(function() {
                    // Move it back.
                    return $mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt + newAttempts.length, attempt);
                });
            });
            return promise.then(function() {
                return $q.reject();
            });
        });
    }

    /**
     * Create new attempts at the end of the offline attempts list.
     *
     * @param  {Number} scormId     SCORM ID.
     * @param  {String} siteId      Site ID.
     * @param  {Object} newAttempts Attempts to create. The keys are the timecreated, the values are the attempt number.
     * @param  {Number} lastOffline Number of last offline attempt.
     * @return {Promise}            Promise resolved when the creation is finished.
     */
    function createNewAttemptsAtEnd(scormId, siteId, newAttempts, lastOffline) {
        var times = Object.keys(newAttempts).sort(), // Sort in ASC order.
            promises = [];

        if (!times.length) {
            return $q.when();
        }

        angular.forEach(times, function(time, index) {
            var attempt = newAttempts[time];
            promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, lastOffline + index + 1));
        });
        return $mmUtil.allPromises(promises);
    }

    /**
     * Check if can retry an attempt synchronization.
     *
     * @param  {Number} scormId    SCORM ID.
     * @param  {String} siteId     Site ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Number} lastOnline Last online attempt number.
     * @return {Promise}           Promise resolved if can retry the synchronization, false otherwise.
     */
    function canRetrySync(scormId, siteId, attempt, lastOnline) {
        // If it's the last attempt we don't need to ignore cache because we already did it.
        var refresh = lastOnline != attempt;
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, refresh).then(function(siteData) {
            // Get synchronization snapshot (if sync fails it should store a snapshot).
            return $mmaModScormOffline.getAttemptSnapshot(siteId, scormId, attempt).then(function(snapshot) {
                if (!snapshot || !Object.keys(snapshot).length || !snapshotEquals(snapshot, siteData)) {
                    // No snapshot or it doesn't match, we can't retry the synchronization.
                    return $q.reject();
                }
            });
        });
    }

    /**
     * Compares an attempt's snapshot with the data retrieved from the site.
     * It only compares elements with dot notation. This means that, if some SCO has been added to Moodle web
     * but the user hasn't generated data for it, then the snapshot will be detected as equal.
     *
     * @param  {Object} snapshot Attempt's snapshot.
     * @param  {Object} userData Data retrieved from the site.
     * @return {Boolean}         True if snapshot is equal to the user data, false otherwise.
     */
    function snapshotEquals(snapshot, userData) {
        var scoId,
            element,
            siteSco,
            snapshotSco;

        // Check that snapshot contains the data from the site.
        for (scoId in userData) {
            siteSco = userData[scoId];
            snapshotSco = snapshot[scoId];

            for (element in siteSco.userdata) {
                if (element.indexOf('.') > -1) {
                    if (!snapshotSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {
                        return false;
                    }
                }
            }
        }

        // Now check the opposite way: site userData contains the data from the snapshot.
        for (scoId in snapshot) {
            siteSco = userData[scoId];
            snapshotSco = snapshot[scoId];

            for (element in snapshotSco.userdata) {
                if (element.indexOf('.') > -1) {
                    if (!siteSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    /**
     * If there's an ongoing sync for a certain SCORM, wait for it to end.
     * If there's no sync ongoing the promise will be resolved right away.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#waitForSync
     * @param  {Number} scormId  SCORM to check.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when there's no sync going on for the SCORM.
     */
    self.waitForSync = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        if (syncPromises[siteId] && syncPromises[siteId][scormId]) {
            // There's a sync ongoing for this SCORM.
            return syncPromises[siteId][scormId].catch(function() {});
        }
        return $q.when();
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey')

/**
 * Survey index controller.
 *
 * @module mm.addons.mod_survey
 * @ngdoc controller
 * @name mmaModSurveyIndexCtrl
 */
.controller('mmaModSurveyIndexCtrl', ["$scope", "$stateParams", "$mmaModSurvey", "$mmUtil", "$q", "$mmCourse", "$translate", "$ionicPlatform", "$ionicScrollDelegate", function($scope, $stateParams, $mmaModSurvey, $mmUtil, $q, $mmCourse, $translate,
            $ionicPlatform, $ionicScrollDelegate) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        survey,
        scrollView;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;
    $scope.answers = {};
    $scope.isTablet = $ionicPlatform.isTablet();

    // Convenience function to get survey data.
    function fetchSurveyData(refresh) {
        return $mmaModSurvey.getSurvey(courseid, module.id).then(function(surveydata) {
            survey = surveydata;

            $scope.title = survey.name || $scope.title;
            $scope.description = survey.intro || $scope.description;
            $scope.survey = survey;

            if (!survey.surveydone) {
                return fetchQuestions();
            }
        }).catch(function(message) {
            if (!refresh) {
                // Some call failed, retry without using cache since it might be a new activity.
                return refreshAllData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_survey.errorgetsurvey', true);
            }
            return $q.reject();
        });
    }

    // Convenience function to get survey questions.
    function fetchQuestions() {
        return $mmaModSurvey.getQuestions(survey.id).then(function(questions) {
            return $mmaModSurvey.formatQuestions(questions).then(function(formatted) {
                $scope.questions = formatted;

                // Init answers object.
                angular.forEach(formatted, function(q) {
                    if (q.name) {
                        var isTextArea = q.multi && q.multi.length === 0 && q.type === 0;
                        $scope.answers[q.name] = q.required ? -1 : (isTextArea ? '' : '0');
                    }
                });
            });
        });
    }

    // Convenience function to refresh all the data.
    function refreshAllData() {
        var p1 = $mmaModSurvey.invalidateSurveyData(courseid),
            p2 = survey ? $mmaModSurvey.invalidateQuestions(survey.id) : $q.when();

        return $q.all([p1, p2]).finally(function() {
            return fetchSurveyData(true);
        });
    }

    fetchSurveyData().then(function() {
        $mmaModSurvey.logView(survey.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.surveyLoaded = true;
    });

    // Check if answers are valid to be submitted.
    $scope.isValidResponse = function() {
        var valid = true;
        angular.forEach($scope.answers, function(a) {
            if (a === -1) {
                valid = false;
            }
        });
        return valid;
    };

    // Save options selected.
    $scope.submit = function() {
        $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
            var answers = [],
                modal = $mmUtil.showModalLoading('mm.core.sending', true);

            angular.forEach($scope.answers, function(value, key) {
                answers.push({
                    key: key,
                    value: value
                });
            });

            $mmaModSurvey.submitAnswers(survey.id, answers).then(function() {
                if (!scrollView) {
                    scrollView = $ionicScrollDelegate.$getByHandle('mmaModSurveyScroll');
                }
                scrollView && scrollView.scrollTop && scrollView.scrollTop();
                return refreshAllData();
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_survey.cannotsubmitsurvey', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };

    // Pull to refresh.
    $scope.refreshSurvey = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey')

/**
 * Mod survey handlers.
 *
 * @module mm.addons.mod_survey
 * @ngdoc service
 * @name $mmaModSurveyHandlers
 */
.factory('$mmaModSurveyHandlers', ["$mmCourse", "$mmaModSurvey", "$state", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModSurvey, $state, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurveyHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModSurvey.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('survey');
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_survey', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurveyHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModSurvey.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a survey URL.
            if (url.indexOf('/mod/survey/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey')

/**
 * Survey service.
 *
 * @module mm.addons.mod_survey
 * @ngdoc service
 * @name $mmaModSurvey
 */
.factory('$mmaModSurvey', ["$q", "$mmSite", "$translate", "$mmSitesManager", function($q, $mmSite, $translate, $mmSitesManager) {
    var self = {};

    /**
     * Turns a string with values separated by commas into an array.
     *
     * @param {String} value Value to convert.
     * @return {Array}       Array.
     */
    function commaStringToArray(value) {
        if (typeof value == 'string') {
            if (value !== '') {
                return value.split(',');
            } else {
                return [];
            }
        } else {
            return value;
        }
    }

    /**
     * Format a questions list, turning "multi" and "options" strings into arrays and adding the properties
     * 'num' and 'name'.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#formatQuestions
     * @param {Object[]} questions Questions.
     * @return {Promise}           Promise resolved with the formatted questions.
     */
    self.formatQuestions = function(questions) {
        var stringkeys = [
            'mma.mod_survey.ipreferthat',
            'mma.mod_survey.ifoundthat',
            'mm.core.choose'
        ];

        return $translate(stringkeys).then(function(translates) {
            var stripreferthat = translates[stringkeys[0]],
                strifoundthat = translates[stringkeys[1]],
                strchoose = translates[stringkeys[2]],
                formatted = [],
                parents = self.getParentQuestions(questions),
                num = 1;

            questions = angular.copy(questions); // Copy the array to prevent modifying the original.

            angular.forEach(questions, function(question) {
                var parent = parents[question.parent];

                // Turn multi and options into arrays.
                question.multi = commaStringToArray(question.multi);
                question.options = commaStringToArray(question.options);

                if (parent) {
                    // It's a sub-question.
                    question.required = true;

                    if (parent.type === 1 || parent.type === 2) {
                        // One answer question. Set its name and add it to the returned array.
                        question.name = 'q' + (parent.type == 2 ? 'P' : '') + question.id;
                        question.num = num++;
                    } else {
                        // Two answers per question (COLLES P&A). We'll add two questions.
                        var q2 = angular.copy(question);

                        question.text = stripreferthat + ' ' + question.text;
                        question.name = 'qP' + question.id;
                        question.num = num++;
                        formatted.push(question);

                        q2.text = strifoundthat + ' ' + q2.text;
                        q2.name = 'q' + question.id;
                        q2.num = num++;
                        formatted.push(q2);

                        return;
                    }
                } else if (question.multi && question.multi.length === 0) {
                    // It's a single question.
                    question.name = 'q' + question.id;
                    question.num = num++;
                    if (question.type > 0) { // Add "choose" option since this question is not required.
                        question.options.unshift(strchoose);
                    }
                }

                formatted.push(question);
            });

            return formatted;
        });
    };

    /**
     * Gets the parent questions and puts them in an object: ID -> question.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#getParentQuestions
     * @param {Object[]} questions Questions.
     * @return {Object}            Object with parent questions.
     */
    self.getParentQuestions = function(questions) {
        var parents = {};

        angular.forEach(questions, function(question) {
            if (question.parent === 0) {
                parents[question.id] = question;
            }
        });

        return parents;
    };

    /**
     * Get a survey's questions.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#getQuestions
     * @param {Number} id Survey ID.
     * @return {Promise}  Promise resolved when the questions are retrieved.
     */
    self.getQuestions = function(id) {
        var params = {
                surveyid: id
            },
            preSets = {
                cacheKey: getQuestionsCacheKey(id)
            };

        return $mmSite.read('mod_survey_get_questions', params, preSets).then(function(response) {
            if (response.questions) {
                return response.questions;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for survey questions WS calls.
     *
     * @param {Number} id Survey ID.
     * @return {String}   Cache key.
     */
    function getQuestionsCacheKey(id) {
        return 'mmaModSurvey:questions:' + id;
    }

    /**
     * Get a survey.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#getSurvey
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the survey is retrieved.
     */
    self.getSurvey = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getSurveyDataCacheKey(courseid)
            };

        return $mmSite.read('mod_survey_get_surveys_by_courses', params, preSets).then(function(response) {
            if (response.surveys) {
                var currentSurvey;
                angular.forEach(response.surveys, function(survey) {
                    if (survey.coursemodule == cmid) {
                        currentSurvey = survey;
                    }
                });
                if (currentSurvey) {
                    return currentSurvey;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for survey data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getSurveyDataCacheKey(courseid) {
        return 'mmaModSurvey:survey:' + courseid;
    }

    /**
     * Invalidates survey questions.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#invalidateQuestions
     * @param {Number} id Survey ID.
     * @return {Promise}  Promise resolved when the data is invalidated.
     */
    self.invalidateQuestions = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getQuestionsCacheKey(courseid));
    };

    /**
     * Invalidates survey data.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#invalidateSurveyData
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateSurveyData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getSurveyDataCacheKey(courseid));
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the survey WS are available.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_survey_get_questions') &&
                    site.wsAvailable('mod_survey_get_surveys_by_courses') &&
                    site.wsAvailable('mod_survey_submit_answers');
        });
    };

    /**
     * Report the survey as being viewed.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#logView
     * @param {String} id Survey ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                surveyid: id
            };
            return $mmSite.write('mod_survey_view_survey', params);
        }
        return $q.reject();
    };

    /**
     * Send survey answers to Moodle.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#submitAnswers
     * @param {Number} surveyid  urvey ID.
     * @param {Object[]} answers Answers.
     * @return {Promise}         Promise resolved when answers are successfully submitted.
     */
    self.submitAnswers = function(surveyid, answers) {
        var params = {
            surveyid: surveyid,
            answers: answers
        };
        return $mmSite.write('mod_survey_submit_answers', params).then(function(response) {
            if (!response.status) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url')

/**
 * URL index controller.
 *
 * @module mm.addons.mod_url
 * @ngdoc controller
 * @name mmaModUrlIndexCtrl
 */
.controller('mmaModUrlIndexCtrl', ["$scope", "$stateParams", "$mmaModUrl", "$mmCourse", function($scope, $stateParams, $mmaModUrl, $mmCourse) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.url = (module.contents && module.contents[0] && module.contents[0].fileurl) ? module.contents[0].fileurl : undefined;

    $scope.go = function() {
        $mmaModUrl.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
        $mmaModUrl.open($scope.url);
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url')

/**
 * Mod URL handlers.
 *
 * @module mm.addons.mod_url
 * @ngdoc service
 * @name $mmaModUrlHandlers
 */
.factory('$mmaModUrlHandlers', ["$mmCourse", "$mmaModUrl", "$state", "$mmUtil", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModUrl, $state, $mmUtil, $mmContentLinksHelper, $q) {

    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrlHandlers#courseContentHandler
     */
    self.courseContentHandler = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.icon = $mmCourse.getModuleIconSrc('url');
                $scope.title = module.name;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_url', {module: module, courseid: courseid});
                };

                if (module.contents && module.contents[0] && module.contents[0].fileurl) {
                    $scope.buttons = [{
                        icon: 'ion-link',
                        label: 'mm.core.openinbrowser',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            $mmaModUrl.logView(module.instance).then(function() {
                                $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                            });
                            $mmaModUrl.open(module.contents[0].fileurl);
                        }
                    }];
                }
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrlHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            if (courseId) {
                return $q.when(true);
            }
            return $mmCourse.canGetModuleWithoutCourseId(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a mod_url URL.
            if (url.indexOf('/mod/url/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url')

/**
 * URL service.
 *
 * @module mm.addons.mod_url
 * @ngdoc service
 * @name $mmaModUrl
 */
.factory('$mmaModUrl', ["$mmSite", "$mmUtil", "$q", function($mmSite, $mmUtil, $q) {
    var self = {};

    /**
     * Report a URL as being viewed.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrl#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                urlid: id
            };
            return $mmSite.write('mod_url_view_url', params);
        }
        return $q.reject();
    };

    /**
     * Opens a URL.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrl#open
     * @param {String} url The URL to go to.
     */
    self.open = function(url) {
        $mmUtil.openInBrowser(url);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Controller to handle notes.
 *
 * @module mm.addons.notes
 * @ngdoc controller
 * @name mmaNotesListCtrl
 */
.controller('mmaNotesListCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaNotes", "$mmSite", "$translate", function($scope, $stateParams, $mmUtil, $mmaNotes, $mmSite, $translate) {

    var courseid = $stateParams.courseid,
        type = $stateParams.type;

    $scope.courseid = courseid;
    $scope.type = type;

    $translate('mma.notes.' + type + 'notes').then(function(string) {
        $scope.title = string;
    });

    function fetchNotes(refresh) {
        return $mmaNotes.getNotes(courseid, refresh).then(function(notes) {
            notes = notes[type + 'notes'];

            return $mmaNotes.getNotesUserData(notes, courseid).then(function(notes) {
                $scope.notes = notes;
            });

        }, function(message) {
            $mmUtil.showErrorModal(message);
        });
    }

    fetchNotes().then(function() {
        // Add log in Moodle.
        $mmSite.write('core_notes_view_notes', {
            courseid: courseid,
            userid: 0
        });
    })
    .finally(function() {
        $scope.notesLoaded = true;
    });

    $scope.refreshNotes = function() {
        fetchNotes(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Note types view controller.
 *
 * @module mm.addons.notes
 * @ngdoc controller
 * @name mmaNotesTypesCtrl
 */
.controller('mmaNotesTypesCtrl', ["$scope", "$stateParams", function($scope, $stateParams) {
    var course = $stateParams.course,
        courseid = course.id;
    $scope.courseid = courseid;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Notes handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.notes
 * @ngdoc service
 * @name $mmaNotesHandlers
 */
.factory('$mmaNotesHandlers', ["$mmaNotes", "$mmSite", "$mmApp", "$ionicModal", "$mmUtil", "mmCoursesAccessMethods", function($mmaNotes, $mmSite, $mmApp, $ionicModal, $mmUtil, mmCoursesAccessMethods) {

    var self = {};

    /**
     * Add a note handler.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotesHandlers#addNote
     */
    self.addNote = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaNotes.isPluginAddNoteEnabled();
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User to check.
         * @param {Number} courseId Course ID.
         * @return {Boolean}        True if handler is enabled, false otherwise.
         */
        self.isEnabledForUser = function(user, courseId) {
            // Active course required.
            return courseId && user.id != $mmSite.getUserId();
        };

        /**
         * Get the controller.
         *
         * @param {Object} user     Course ID.
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(user, courseid) {

            /**
             * Add note handler controller.
             *
             * @module mm.addons.notes
             * @ngdoc controller
             * @name $mmaNotesHandlers#addNote:controller
             */
            return function($scope) {

                // Button title.
                $scope.title = 'mma.notes.addnewnote';

                $ionicModal.fromTemplateUrl('addons/notes/templates/add.html', {
                    scope: $scope,
                    animation: 'slide-in-up'
                }).then(function(m) {
                    $scope.modal = m;
                });

                $scope.closeModal = function(){
                    $scope.modal.hide();
                };

                $scope.addNote = function(){

                    $mmApp.closeKeyboard();

                    var loadingModal = $mmUtil.showModalLoading('mm.core.sending', true);
                    // Freeze the add note button.
                    $scope.processing = true;

                    $mmaNotes.addNote(user.id, courseid, $scope.note.publishstate, $scope.note.text).then(function() {
                        $mmUtil.showModal('mm.core.success', 'mma.notes.eventnotecreated');
                        $scope.closeModal();
                    }, function(error) {
                        $mmUtil.showErrorModal(error);
                        $scope.processing = false;
                    }).finally(function() {
                        loadingModal.dismiss();
                    });
                };

                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();

                    $scope.note = {
                        publishstate: 'personal',
                        text: ''
                    };
                    $scope.processing = false;

                    $scope.modal.show();

                };
            };

        };

        return self;
    };

    /**
     * Course nav handler.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotesHandlers#coursesNav
     */
    self.coursesNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaNotes.isPluginViewNotesEnabled();
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean}          True if handler is enabled, false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return true;
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(courseId) {

            /**
             * Courses nav handler controller.
             *
             * @module mm.addons.notes
             * @ngdoc controller
             * @name $mmaNotesHandlers#coursesNav:controller
             */
            return function($scope, $state) {
                $scope.icon = 'ion-ios-list';
                $scope.title = 'mma.notes.notes';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.notes-types', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Notes factory.
 *
 * @module mm.addons.notes
 * @ngdoc service
 * @name $mmaNotes
 */
.factory('$mmaNotes', ["$mmSite", "$log", "$q", "$mmUser", "$translate", function($mmSite, $log, $q, $mmUser, $translate) {
    $log = $log.getInstance('$mmaNotes');

    var self = {};

    /**
     * Add a note.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#addNote
     * @param {Number} userId       User ID of the person to add the note.
     * @param {Number} courseId     Course ID where the note belongs.
     * @param {String} publishState Personal, Site or Course.
     * @param {String} noteText     The note text.
     * @return {Promise}
     */
    self.addNote = function(userId, courseId, publishState, noteText) {
        var data = {
            "notes[0][userid]" : userId,
            "notes[0][publishstate]": publishState,
            "notes[0][courseid]": courseId,
            "notes[0][text]": noteText,
            "notes[0][format]": 1
        };
        return $mmSite.write('core_notes_create_notes', data);
    };

    /**
     * Returns whether or not the add note plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#isPluginAddNoteEnabled
     * @return {Boolean}
     */
    self.isPluginAddNoteEnabled = function() {
        var infos;

        if (!$mmSite.isLoggedIn()) {
            return false;
        } else if (!$mmSite.canUseAdvancedFeature('enablenotes')) {
            return false;
        } else if (!$mmSite.wsAvailable('core_notes_create_notes')) {
            return false;
        }

        return true;
    };

    /**
     * Returns whether or not the read notes plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#isPluginViewNotesEnabled
     * @return {Boolean}
     */
    self.isPluginViewNotesEnabled = function() {
        var infos;

        if (!$mmSite.isLoggedIn()) {
            return false;
        } else if (!$mmSite.canUseAdvancedFeature('enablenotes')) {
            return false;
        } else if (!$mmSite.wsAvailable('core_notes_get_course_notes')) {
            return false;
        }

        return true;
    };

    /**
     * Get users notes for a certain site, course and personal notes.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#getNotes
     * @param {Number} courseid ID of the course to get the notes from.
     * @param {Boolean} refresh True when we should not get the value from the cache.
     * @return {Promise}        Promise to be resolved when the notes are retrieved.
     */
    self.getNotes = function(courseid, refresh) {

        $log.debug('Get notes for course ' + courseid);

        var data = {
                courseid : courseid
            },
            presets = {};
        if (refresh) {
            presets.getFromCache = false;
        }

        return $mmSite.read('core_notes_get_course_notes', data, presets);
    };

    /**
     * Get user data for notes since they only have userid.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#getNotesUserData
     * @param {Object[]} notes       Notes to get the data for.
     * @param {Number}   courseid    ID of the course the notes belong to.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted notes.
     */
    self.getNotesUserData = function(notes, courseid) {
        var promises = [];

        angular.forEach(notes, function(note) {
            var promise = $mmUser.getProfile(note.userid, courseid, true).then(function(user) {
                note.userfullname = user.fullname;
                note.userprofileimageurl = user.profileimageurl;
            }, function() {
                // Error getting profile. Set default data.
                return $translate('mma.notes.userwithid', {id: note.userid}).then(function(str) {
                    note.userfullname = str;
                });
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return notes;
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Controller to handle notification list.
 *
 * @module mm.addons.notifications
 * @ngdoc controller
 * @name mmaNotificationsListCtrl
 */
.controller('mmaNotificationsListCtrl', ["$scope", "$mmUtil", "$mmaNotifications", "mmaNotificationsListLimit", function($scope, $mmUtil, $mmaNotifications, mmaNotificationsListLimit) {

    var readCount = 0,
        unreadCount = 0;

    $scope.notifications = [];

    // Convenience function to get notifications. Get unread notifications first.
    function fetchNotifications(refresh) {

        if (refresh) {
            readCount = 0;
            unreadCount = 0;
        }

        return $mmaNotifications.getUnreadNotifications(unreadCount, mmaNotificationsListLimit).then(function(unread) {
            // Don't add the unread notifications to $scope.notifications yet. If there are no unread notifications
            // that causes that the "There are no notifications" message is shown in pull to refresh.
            unreadCount += unread.length;

            if (unread.length < mmaNotificationsListLimit) {
                // Limit not reached. Get read notifications until reach the limit.
                var readLimit = mmaNotificationsListLimit - unread.length;
                return $mmaNotifications.getReadNotifications(readCount, readLimit).then(function(read) {
                    readCount += read.length;
                    if (refresh) {
                        $scope.notifications = unread.concat(read);
                    } else {
                        $scope.notifications = $scope.notifications.concat(unread).concat(read);
                    }
                    $scope.canLoadMore = read.length >= readLimit;
                }, function(error) {
                    if (unread.length == 0) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mma.notifications.errorgetnotifications', true);
                        }
                        $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
                    }
                });
            } else {
                if (refresh) {
                    $scope.notifications = unread;
                } else {
                    $scope.notifications = $scope.notifications.concat(unread);
                }
                $scope.canLoadMore = true;
            }
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.notifications.errorgetnotifications', true);
            }
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
        });
    }
    fetchNotifications().finally(function() {
        $scope.notificationsLoaded = true;
    });

    $scope.refreshNotifications = function() {
        $mmaNotifications.invalidateNotificationsList().finally(function() {
            fetchNotifications(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    $scope.loadMoreNotifications = function(){
        fetchNotifications().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Notification action directive.
 *
 * @module mm.addons.notifications
 * @ngdoc directive
 * @name mmaNotificationsActions
 */
.directive('mmaNotificationsActions', ["$log", "$mmContentLinksDelegate", function($log, $mmContentLinksDelegate) {
    $log = $log.getInstance('mmaNotificationsActions');

    // Directive link function.
    function link(scope) {
        if (scope.contexturl) {
            $mmContentLinksDelegate.getActionsFor(scope.contexturl, scope.courseid).then(function(actions) {
                scope.actions = actions;
            });
        }
    }

    return {
        link: link,
        restrict: 'E',
        scope: {
            contexturl: '=',
            courseid: '='
        },
        templateUrl: 'addons/notifications/templates/actions.html',
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Filter to format a notification.
 *
 * @module mm.addons.notifications
 * @ngdoc filter
 * @name mmaNotificationsFormat
 */
.filter('mmaNotificationsFormat', ["$mmText", function($mmText) {
  return function(text) {
    text = text.replace(/-{4,}/ig, '');
    text = $mmText.replaceNewLines(text, '<br />');
    return text;
  };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Notifications handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.notifications
 * @ngdoc service
 * @name $mmaNotificationsHandlers
 */
.factory('$mmaNotificationsHandlers', ["$log", "$mmaNotifications", function($log, $mmaNotifications) {
    $log = $log.getInstance('$mmaNotificationsHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotificationsHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaNotifications.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.notifications
             * @ngdoc controller
             * @name $mmaNotificationsHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-ios-bell';
                $scope.title = 'mma.notifications.notifications';
                $scope.state = 'site.notifications';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Service to handle notifications (messages).
 *
 * @module mm.addons.notifications
 * @ngdoc service
 * @name $mmaNotifications
 */
.factory('$mmaNotifications', ["$q", "$log", "$mmSite", "$mmSitesManager", "mmaNotificationsListLimit", function($q, $log, $mmSite, $mmSitesManager, mmaNotificationsListLimit) {

    $log = $log.getInstance('$mmaNotifications');

    var self = {};

    // Function to format notification data.
    function formatNotificationsData(notifications) {
        angular.forEach(notifications, function(notification) {
            // Set message to show.
            if (notification.contexturl && notification.contexturl.indexOf('/mod/forum/')) {
                notification.mobiletext = notification.smallmessage;
            } else {
                notification.mobiletext = notification.fullmessage;
            }

            // Try to set courseid the notification belongs to.
            var cid = notification.fullmessagehtml.match(/course\/view\.php\?id=([^"]*)/);
            if (cid && cid[1]) {
                notification.courseid = cid[1];
            }
        });
    }

    /**
     * Get cache key for notification list WS calls.
     *
     * @return {String} Cache key.
     */
    function getNotificationsCacheKey() {
        return 'mmaNotifications:list';
    };

    /**
     * Get notifications from site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#getNotifications
     * @param {Boolean} read       True if should get read notifications, false otherwise.
     * @param {Number} limitFrom   Position of the first notification to get.
     * @param {Number} limitNumber Number of notifications to get.
     * @return {Promise}           Promise resolved with notifications.
     */
    self.getNotifications = function(read, limitFrom, limitNumber) {
        limitFrom = limitFrom || 0;
        limitNumber = limitNumber || mmaNotificationsListLimit;

        $log.debug('Get ' + (read ? 'read' : 'unread') + ' notifications from ' + limitFrom + '. Limit: ' + limitNumber);

        var data = {
            useridto: $mmSite.getUserId(),
            useridfrom: 0,
            type: 'notifications',
            read: read ? 1 : 0,
            newestfirst: 1,
            limitfrom: limitFrom,
            limitnum: limitNumber
        };
        var preSets = {
            cacheKey: getNotificationsCacheKey()
        };

        // Get unread notifications.
        return $mmSite.read('core_message_get_messages', data, preSets).then(function(response) {
            if (response.messages) {
                var notifications = response.messages;
                formatNotificationsData(notifications);
                return notifications;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Get read notifications from site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#getReadNotifications
     * @param {Number} limitFrom   Position of the first notification to get.
     * @param {Number} limitNumber Number of notifications to get.
     * @return {Promise}           Promise resolved with notifications.
     */
    self.getReadNotifications = function(limitFrom, limitNumber) {
        return self.getNotifications(true, limitFrom, limitNumber);
    };

    /**
     * Get unread notifications from site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#getUnreadNotifications
     * @param {Number} limitFrom   Position of the first notification to get.
     * @param {Number} limitNumber Number of notifications to get.
     * @return {Promise}           Promise resolved with notifications.
     */
    self.getUnreadNotifications = function(limitFrom, limitNumber) {
        return self.getNotifications(false, limitFrom, limitNumber);
    };

    /**
     * Invalidates notifications list WS calls.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#invalidateNotificationsList
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateNotificationsList = function() {
        return $mmSite.invalidateWsCacheForKey(getNotificationsCacheKey());
    };

    /**
     * Check if plugin is available.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#isPluginEnabled
     * @return {Boolean} True if plugin is available, false otherwise.
     */
    self.isPluginEnabled = function() {
        return $mmSite.wsAvailable('core_message_get_messages');
    };

    /**
     * Check if plugin is available for a certain site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#isPluginEnabledForSite
     * @param {String} siteid Site ID.
     * @return {Promise}      Resolved when enabled, otherwise rejected.
     */
    self.isPluginEnabledForSite = function(siteid) {
        return $mmSitesManager.getSite(siteid).then(function(site) {
            if (!site.wsAvailable('core_message_get_messages')) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants')

/**
 * Controller to handle course participants.
 *
 * @module mm.addons.participants
 * @ngdoc controller
 * @name mmaParticipantsListCtrl
 */
.controller('mmaParticipantsListCtrl', ["$scope", "$state", "$stateParams", "$mmUtil", "$mmaParticipants", "$ionicPlatform", "$mmSite", "mmUserProfileState", function($scope, $state, $stateParams, $mmUtil, $mmaParticipants, $ionicPlatform, $mmSite,
            mmUserProfileState) {
    var course = $stateParams.course,
        courseid = course.id;

    $scope.participants = [];
    $scope.courseid = courseid;
    $scope.userStateName = mmUserProfileState;

    function fetchParticipants(refresh) {
        var firstToGet = refresh ? 0 : $scope.participants.length;
        return $mmaParticipants.getParticipants(courseid, firstToGet).then(function(data) {
            if (refresh) {
                $scope.participants = data.participants;
            } else {
                $scope.participants = $scope.participants.concat(data.participants);
            }
            $scope.canLoadMore = data.canLoadMore;
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
        });
    }

    // Get first participants.
    fetchParticipants(true).then(function() {
        // Add log in Moodle.
        $mmSite.write('core_user_view_user_list', {
            courseid: courseid
        });
    }).finally(function() {
        $scope.participantsLoaded = true;
    });

    // Load more participants.
    $scope.loadMoreParticipants = function(){
        fetchParticipants().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };

    $scope.refreshParticipants = function() {
        $mmaParticipants.invalidateParticipantsList(courseid).finally(function() {
            fetchParticipants(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants')

/**
 * Participants handlers.
 *
 * @module mm.addons.participants
 * @ngdoc service
 * @name $mmaParticipantsHandlers
 */
.factory('$mmaParticipantsHandlers', ["$mmaParticipants", "mmCoursesAccessMethods", "$mmUtil", "$mmContentLinksHelper", function($mmaParticipants, mmCoursesAccessMethods, $mmUtil, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course nav handler.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipantsHandlers#coursesNavHandler
     */
    self.coursesNavHandler = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean|Promise}  Promise resolved  with true if handler is enabled,
         *                            false or promise rejected or resolved with false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return $mmaParticipants.isPluginEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(courseId) {
            return function($scope, $state) {
                $scope.icon = 'ion-person-stalker';
                $scope.title = 'mma.participants.participants';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.participants', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipantsHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        List of actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a user URL.
            if (url.indexOf('grade/report/user') == -1 && url.indexOf('/user/index.php') > -1) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: siteIds,
                        action: function(siteId) {
                            var stateParams = {
                                course: {id: parseInt(params.id, 10)}
                            };
                            $mmContentLinksHelper.goInSite('site.participants', stateParams, siteId);
                        }
                    }];
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants')

/**
 * Service to handle course participants.
 *
 * @module mm.addons.participants
 * @ngdoc service
 * @name $mmaParticipants
 */
.factory('$mmaParticipants', ["$log", "$mmSite", "$mmUser", "mmaParticipantsListLimit", function($log, $mmSite, $mmUser, mmaParticipantsListLimit) {

    $log = $log.getInstance('$mmaParticipants');

    var self = {};

    /**
     * Get cache key for participant list WS calls.
     *
     * @param  {Number} courseid Course ID.
     * @return {String}          Cache key.
     */
    function getParticipantsListCacheKey(courseid) {
        return 'mmaParticipants:list:'+courseid;
    }

    /**
     * Get participants for a certain course.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipants#getParticipants
     * @param {String} courseid    ID of the course.
     * @param {Number} limitFrom   Position of the first participant to get.
     * @param {Number} limitNumber Number of participants to get.
     * @return {Promise}           Promise to be resolved when the participants are retrieved.
     */
    self.getParticipants = function(courseid, limitFrom, limitNumber) {

        if (typeof limitFrom == 'undefined') {
            limitFrom = 0;
        }
        if (typeof limitNumber == 'undefined') {
            limitNumber = mmaParticipantsListLimit;
        }

        $log.debug('Get participants for course ' + courseid + ' starting at ' + limitFrom);

        var wsName,
            data = {
                courseid: courseid
            }, preSets = {
                cacheKey: getParticipantsListCacheKey(courseid)
            };

        if ($mmSite.wsAvailable('core_enrol_get_enrolled_users')) {
            wsName = 'core_enrol_get_enrolled_users';
            data.options = [
                {
                    name: 'limitfrom',
                    value: limitFrom
                },
                {
                    name: 'limitnumber',
                    value: limitNumber
                },
                {
                    name: 'sortby',
                    value: 'siteorder'
                }
            ];
        } else {
            wsName = 'moodle_enrol_get_enrolled_users';
            limitNumber = 9999999999; // Set a big limitNumber so canLoadMore is always false (WS not paginated).
        }

        return $mmSite.read(wsName, data, preSets).then(function(users) {
            // Format user data, moodle_enrol_get_enrolled_users returns some attributes with a different name.
            angular.forEach(users, function(user) {
                if (typeof user.id == 'undefined' && typeof user.userid != 'undefined') {
                    user.id = user.userid;
                }
                if (typeof user.profileimageurl == 'undefined' && typeof user.profileimgurl != 'undefined') {
                    user.profileimageurl = user.profileimgurl;
                }
            });

            var canLoadMore = users.length >= limitNumber;
            $mmUser.storeUsers(users);
            return {participants: users, canLoadMore: canLoadMore};
        });
    };

    /**
     * Invalidates participant list for a certain course.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipants#invalidateParticipantsList
     * @param  {Number} courseid Course ID.
     * @return {Promise}         Promise resolved when the list is invalidated.
     */
    self.invalidateParticipantsList = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getParticipantsListCacheKey(courseid));
    };

    /**
     * Returns whether or not the participants addon is enabled for a certain course.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipants#isPluginEnabledForCourse
     * @param {Number} courseId Course ID.
     * @return {Promise}        Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabledForCourse = function(courseId) {
        if (!courseId) {
            return $q.reject();
        }

        // Retrieving one participant will fail if browsing users is disabled by capabilities.
        return self.getParticipants(courseId, 0, 1).then(function(parcitipants) {
            return true;
        }).catch(function(error) {
            return false;
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.pushnotifications')

/**
 * Service to handle push notifications clicks.
 *
 * @module mm.addons.pushnotifications
 * @ngdoc service
 * @name $mmPushNotificationsDelegate
 */
.factory('$mmPushNotificationsDelegate', ["$log", function($log) {

    $log = $log.getInstance('$mmPushNotificationsDelegate');

    var handlers = {},
        self = {};

    /**
     * Function called when a push notification is clicked. Sends notification to handlers.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmPushNotificationsDelegate#clicked
     * @param {Object} notification Notification clicked.
     * @return {Void}
     */
    self.clicked = function(notification) {
        for (var name in handlers) {
            var callback = handlers[name];
            if (typeof callback == 'function') {
                var treated = callback(notification);
                if (treated) {
                    return; // Stop execution when notification is treated.
                }
            }
        }
    };

    /**
     * Register a push notifications handler. The handler will receive a notification to treat.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmPushNotificationsDelegate#registerHandler
     * @param {String} name       Handler's name.
     * @param {Function} callback The callback function. Will get as parameter the URL to handle.
     * @description
     * The handler should return true if the notification is the one expected, false otherwise.
     * @see {@link $mmPushNotificationsDelegate#clicked}
     */
    self.registerHandler = function(name, callback) {
        $log.debug("Registered handler '" + name + "' as push notification handler.");
        handlers[name] = callback;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.pushnotifications')

/**
 * Push notifications factory.
 *
 * @module mm.addons.pushnotifications
 * @ngdoc service
 * @name $mmaPushNotifications
 */
.factory('$mmaPushNotifications', ["$mmSite", "$log", "$cordovaPush", "$mmText", "$q", "$cordovaDevice", "$mmUtil", "mmCoreConfigConstants", "$mmApp", "$mmLocalNotifications", "$mmPushNotificationsDelegate", "$mmSitesManager", "mmaPushNotificationsComponent", function($mmSite, $log, $cordovaPush, $mmText, $q, $cordovaDevice, $mmUtil, mmCoreConfigConstants,
            $mmApp, $mmLocalNotifications, $mmPushNotificationsDelegate, $mmSitesManager, mmaPushNotificationsComponent) {
    $log = $log.getInstance('$mmaPushNotifications');

    var self = {},
        pushID;

    /**
     * Returns whether or not the plugin is enabled for the current site.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#isPluginEnabled
     * @return {Boolean} True if enabled, false otherwise.
     */
    self.isPluginEnabled = function() {
        return $mmSite.wsAvailable('core_user_add_user_device')
                && $mmSite.wsAvailable('message_airnotifier_is_system_configured')
                && $mmSite.wsAvailable('message_airnotifier_are_notification_preferences_configured');
    };

    /**
     * Function called when a push notification is clicked. Redirect the user to the right state.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#notificationClicked
     * @param {Object} data Notification data.
     */
    self.notificationClicked = function(data) {
        $mmApp.ready().then(function() {
            $mmPushNotificationsDelegate.clicked(data);
        });
    };

    /**
     * This function is called from the PushPlugin when we receive a Notification from GCM.
     * The app can be in foreground or background,
     * if we are in background this code is executed when we open the app clicking in the notification bar.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#onGCMReceived
     * @param {Object} notification Notification data.
     */
    self.onGCMReceived = function(notification) {
        $log.debug('GCM notification received. Type: '+notification.event);

        switch (notification.event) {
            case 'registered':
                if (notification.regid.length > 0) {
                    pushID = notification.regid;
                    return self.registerDeviceOnMoodle();
                } else {
                    $log.debug('Device NOT registered in GCM, invalid regid');
                    break;
                }

            case 'message':
                notification.payload.foreground = notification.foreground;
                return self.onMessageReceived(notification.payload);

            case 'error':
                $log.debug('Push messages error');
                break;

            default:
                $log.debug('Push unknown message');
        }
    };

    /**
     * This function is called when we receive a Notification from APNS or a message notification from GCM.
     * The app can be in foreground or background,
     * if we are in background this code is executed when we open the app clicking in the notification bar.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#onMessageReceived
     * @param {Object} data Notification data.
     */
    self.onMessageReceived = function(data) {
        var promise;

        if (data && data.site) {
            promise = $mmSitesManager.getSite(data.site); // Check if site exists.
        } else {
            promise = $q.when(); // No site specified, resolve.
        }

        promise.then(function() {
            if ($mmUtil.isTrueOrOne(data.foreground)) {
                // If the app is in foreground when the notification is received, it's not shown. Let's show it ourselves.
                if ($mmLocalNotifications.isAvailable()) {
                    // Apply formatText to title and message.
                    $mmText.formatText(data.title, true, true).then(function(formattedTitle) {
                        $mmText.formatText(data.message, true, true).then(function(formattedMessage) {
                            var localNotif = {
                                id: 1,
                                title: formattedTitle,
                                message: formattedMessage,
                                at: new Date(),
                                smallIcon: 'res://icon',
                                data: {
                                    notif: data.notif,
                                    site: data.site
                                }
                            };
                            $mmLocalNotifications.schedule(localNotif, mmaPushNotificationsComponent, data.site);
                        });
                    });
                }
            } else {
                self.notificationClicked(data);
            }
        });
    };

    /**
     * Register a device in Apple APNS or Google GCM.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#registerDevice
     * @return {Promise} Promise resolved when the device is registered.
     */
    self.registerDevice = function() {
        try {
            if (ionic.Platform.isIOS()) {
                return self._registerDeviceAPNS();
            } else if (ionic.Platform.isAndroid()) {
                return self._registerDeviceGCM();
            }
        } catch(ex) {}

        return $q.reject();
    };

    /**
     * Register a device in Apple APNS (Apple Push Notificaiton System) using the Phonegap PushPlugin.
     * It also registers the device in the Moodle site using the core_user_add_user_device WebService.
     * We need the device registered in Moodle so we can connect the device with the message output Moode plugin airnotifier.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#_registerDeviceAPNS
     * @return {Promise} Promise resolved when the device is registered.
     * @protected
     */
    self._registerDeviceAPNS = function() {
        var options = {
            alert: 'true',
            badge: 'true',
            sound: 'true'
        };
        return $cordovaPush.register(options).then(function(token) {
            pushID = token;
            return self.registerDeviceOnMoodle();
        }, function(error) {
            return $q.reject();
        });
    };

    /**
     * Register a device in Google GCM using the Phonegap PushPlugin.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#_registerDeviceGCM
     * @return {Promise} Promise resolved when the device is registered.
     * @protected
     */
    self._registerDeviceGCM = function() {
        if (mmCoreConfigConstants.gcmpn) {
            return $cordovaPush.register({
                senderID: mmCoreConfigConstants.gcmpn
            });
        }
        return $q.reject();
    };

    /**
     * Registers a device on current Moodle site.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#registerDeviceOnMoodle
     * @return {Promise}      Promise resolved when device is registered.
     */
    self.registerDeviceOnMoodle = function() {
        $log.debug('Register device on Moodle.');

        if (!$mmSite.isLoggedIn() || !pushID || !$mmApp.isDevice()) {
            return $q.reject();
        }

        var data = {
            appid:      mmCoreConfigConstants.app_id,
            name:       ionic.Platform.device().name || '',
            model:      $cordovaDevice.getModel(),
            platform:   $cordovaDevice.getPlatform(),
            version:    $cordovaDevice.getVersion(),
            pushid:     pushID,
            uuid:       $cordovaDevice.getUUID()
        };
        return $mmSite.write('core_user_add_user_device', data);
    };

    /**
     * Unregisters a device from a certain Moodle site.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#unregisterDeviceOnMoodle
     * @param {Object} site Site to unregister from.
     * @return {Promise}    Promise resolved when device is unregistered.
     */
    self.unregisterDeviceOnMoodle = function(site) {

        if (!site || !$mmApp.isDevice()) {
            return $q.reject();
        }

        $log.debug('Unregister device on Moodle: ' + site.id);

        var data = {
            appid: mmCoreConfigConstants.app_id,
            uuid:  $cordovaDevice.getUUID()
        };
        return site.write('core_user_remove_user_device', data).then(function(response) {
            if (!response || !response.removed) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.remotestyles')

/**
 * Service to handle remote styles.
 *
 * @module mm.addons.remotestyles
 * @ngdoc service
 * @name $mmaRemoteStyles
 */
.factory('$mmaRemoteStyles', ["$log", "$q", "$mmSite", "$mmSitesManager", "$mmFilepool", "$http", "$mmFS", "mmaRemoteStylesComponent", "mmCoreNotDownloaded", function($log, $q, $mmSite, $mmSitesManager, $mmFilepool, $http, $mmFS, mmaRemoteStylesComponent,
            mmCoreNotDownloaded) {

    $log = $log.getInstance('$mmaRemoteStyles');

    var self = {},
        remoteStylesEl = angular.element(document.querySelector('#mobilecssurl'));

    /**
     * Clear remote styles added to the DOM.
     *
     * @module mm.addons.remotestyles
     * @ngdoc method
     * @name $mmaRemoteStyles#clear
     */
    self.clear = function() {
        remoteStylesEl.html('');
    };

    /**
     * Get remote styles of a certain site.
     *
     * @module mm.addons.remotestyles
     * @ngdoc method
     * @name $mmaRemoteStyles#get
     * @param {String} siteid Site ID.
     * @return {Promise}      Promise resolved with the styles.
     */
    self.get = function(siteid) {
        var promise;

        siteid = siteid || $mmSite.getId();
        if (!siteid) {
            return $q.reject();
        }

        // Downloads a CSS file and remove old files if needed.
        function downloadFileAndRemoveOld(url) {
            return $mmFilepool.getFileStateByUrl(siteid, url).then(function(state) {
                return state !== mmCoreNotDownloaded;
            }).catch(function() {
                return true; // An error occurred while getting state (shouldn't happen). Don't delete downloaded file.
            }).then(function(isDownloaded) {
                if (!isDownloaded) {
                    // File not downloaded, URL has changed or first time. Delete downloaded CSS files.
                    return $mmFilepool.removeFilesByComponent(siteid, mmaRemoteStylesComponent, 1);
                }
            }).then(function() {
                return $mmFilepool.downloadUrl(siteid, url, false, mmaRemoteStylesComponent, 1);
            });
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var infos = site.getInfo();
            if (infos && infos.mobilecssurl) {
                if ($mmFS.isAvailable()) {
                    // The file system is available. Download the file and remove old CSS files if needed.
                    return downloadFileAndRemoveOld(infos.mobilecssurl);
                } else {
                    // We return the online URL. We're probably on browser.
                    return infos.mobilecssurl;
                }
            } else {
                if (infos.mobilecssurl === '') {
                    // CSS URL is empty. Delete downloaded files (if any).
                    $mmFilepool.removeFilesByComponent(siteid, mmaRemoteStylesComponent, 1)
                }
                return $q.reject();
            }
        }).then(function(url) {
            $log.debug('Loading styles from: '+url);
            return $http.get(url);
        }).then(function(response) {
            if (typeof response.data == 'string') {
                return response.data;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Load styles for current site.
     *
     * @module mm.addons.remotestyles
     * @ngdoc method
     * @name $mmaRemoteStyles#load
     */
    self.load = function() {
        var siteid = $mmSite.getId();
        if (siteid) {
            self.get(siteid).then(function(styles) {
                if (siteid === $mmSite.getId()) { // Make sure it hasn't logout while retrieving styles.
                    remoteStylesEl.html(styles);
                }
            });
        }
    };

    return self;
}]);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5qcyIsIm1haW4uanMiLCJhZGRvbm1hbmFnZXIuanMiLCJhbmd1bGFyLWlvczktdWl3ZWJ2aWV3LnBhdGNoLmpzIiwiY29uZmlnLmpzIiwiZGIuanMiLCJlbXVsYXRvci5qcyIsImV2ZW50cy5qcyIsImZpbGVwb29sLmpzIiwiZnMuanMiLCJncm91cHMuanMiLCJpbml0LmpzIiwiaW9uaWMtaW9zOS1yYWRpby1maXguanMiLCJsYW5nLmpzIiwibG9jYWxub3RpZi5qcyIsImxvZy5qcyIsInNpdGUuanMiLCJzaXRlc2ZhY3RvcnkuanMiLCJzaXRlc21hbmFnZXIuanMiLCJ0ZXh0LmpzIiwidXBkYXRlbWFuYWdlci5qcyIsInVybGRlbGVnYXRlLmpzIiwidXRpbC5qcyIsIndzLmpzIiwiYnl0ZXN0b3NpemUuanMiLCJjcmVhdGVsaW5rcy5qcyIsImRhdGVfZGF5X29yX3RpbWUuanMiLCJmb3JtYXRkYXRlLmpzIiwibm90YWdzLmpzIiwidGltZWFnby5qcyIsInRvbG9jYWxlc3RyaW5nLmpzIiwiYXV0b2ZvY3VzLmpzIiwiYnJvd3Nlci5qcyIsImNvbXBsZXRpb24uanMiLCJleHRlcm5hbF9jb250ZW50LmpzIiwiZmlsZS5qcyIsImZvcm1hdHRleHQuanMiLCJpZnJhbWUuanMiLCJpbWFnZXZpZXdlci5qcyIsImxvYWRpbmcuanMiLCJuYXZpZ2F0aW9uYmFyLmpzIiwibm9pbnB1dHZhbGlkYXRpb24uanMiLCJzcGxpdHZpZXcuanMiLCJzcGxpdHZpZXdsaW5rLmpzIiwiY29udGVudGxpbmtzL21haW4uanMiLCJjb3Vyc2UvbWFpbi5qcyIsImNvdXJzZXMvbWFpbi5qcyIsImxvZ2luL21haW4uanMiLCJzZXR0aW5ncy9tYWluLmpzIiwic2lkZW1lbnUvbWFpbi5qcyIsInRleHR2aWV3ZXIvbWFpbi5qcyIsInVzZXIvbWFpbi5qcyIsImNvbnRlbnRsaW5rcy9jb250cm9sbGVycy9jaG9vc2VzaXRlLmpzIiwiY29udGVudGxpbmtzL3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwiY29udGVudGxpbmtzL3NlcnZpY2VzL2hlbHBlci5qcyIsImNvdXJzZS9jb250cm9sbGVycy9tb2Rjb250ZW50LmpzIiwiY291cnNlL2NvbnRyb2xsZXJzL3NlY3Rpb24uanMiLCJjb3Vyc2UvY29udHJvbGxlcnMvc2VjdGlvbnMuanMiLCJjb3Vyc2UvZGlyZWN0aXZlcy9tb2RfZGVzY3JpcHRpb24uanMiLCJjb3Vyc2Uvc2VydmljZXMvY29udGVudF9oYW5kbGVyLmpzIiwiY291cnNlL3NlcnZpY2VzL2NvdXJzZS5qcyIsImNvdXJzZS9zZXJ2aWNlcy9jb3Vyc2VzX25hdl9oYW5kbGVyLmpzIiwiY291cnNlL3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwiY291cnNlL3NlcnZpY2VzL2hlbHBlci5qcyIsImNvdXJzZS9zZXJ2aWNlcy9wcmVmZXRjaGRlbGVnYXRlLmpzIiwiY291cnNlcy9jb250cm9sbGVycy9saXN0LmpzIiwiY291cnNlcy9jb250cm9sbGVycy9zZWFyY2guanMiLCJjb3Vyc2VzL2NvbnRyb2xsZXJzL3ZpZXdyZXN1bHQuanMiLCJjb3Vyc2VzL3NlcnZpY2VzL2NvdXJzZXMuanMiLCJjb3Vyc2VzL3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwiY291cnNlcy9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsImxvZ2luL2NvbnRyb2xsZXJzL2NyZWRlbnRpYWxzLmpzIiwibG9naW4vY29udHJvbGxlcnMvaW5pdC5qcyIsImxvZ2luL2NvbnRyb2xsZXJzL3JlY29ubmVjdC5qcyIsImxvZ2luL2NvbnRyb2xsZXJzL3NpdGUuanMiLCJsb2dpbi9jb250cm9sbGVycy9zaXRlcy5qcyIsImxvZ2luL3NlcnZpY2VzL2hlbHBlci5qcyIsInNldHRpbmdzL2NvbnRyb2xsZXJzL2Fib3V0LmpzIiwic2V0dGluZ3MvY29udHJvbGxlcnMvZ2VuZXJhbC5qcyIsInNldHRpbmdzL2NvbnRyb2xsZXJzL3NwYWNlLXVzYWdlLmpzIiwic2V0dGluZ3MvY29udHJvbGxlcnMvc3luY2hyb25pemF0aW9uLmpzIiwic2lkZW1lbnUvY29udHJvbGxlcnMvbWVudS5qcyIsInNpZGVtZW51L3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwidGV4dHZpZXdlci9jb250cm9sbGVycy9pbmRleC5qcyIsInVzZXIvY29udHJvbGxlcnMvcHJvZmlsZS5qcyIsInVzZXIvZGlyZWN0aXZlcy91c2VybGluay5qcyIsInVzZXIvc2VydmljZXMvZGVsZWdhdGUuanMiLCJ1c2VyL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwidXNlci9zZXJ2aWNlcy91c2VyLmpzIiwiY2FsZW5kYXIvbWFpbi5qcyIsImNvdXJzZWNvbXBsZXRpb24vbWFpbi5qcyIsImZpbGVzL21haW4uanMiLCJmcm9udHBhZ2UvbWFpbi5qcyIsImdyYWRlcy9tYWluLmpzIiwibWVzc2FnZXMvbWFpbi5qcyIsIm1vZF9hc3NpZ24vbWFpbi5qcyIsIm1vZF9ib29rL21haW4uanMiLCJtb2RfY2hhdC9tYWluLmpzIiwibW9kX2Nob2ljZS9tYWluLmpzIiwibW9kX2ZvbGRlci9tYWluLmpzIiwibW9kX2ZvcnVtL21haW4uanMiLCJtb2RfZ2xvc3NhcnkvbWFpbi5qcyIsIm1vZF9pbXNjcC9tYWluLmpzIiwibW9kX2xhYmVsL21haW4uanMiLCJtb2RfbHRpL21haW4uanMiLCJtb2RfcGFnZS9tYWluLmpzIiwibW9kX3Jlc291cmNlL21haW4uanMiLCJtb2Rfc2Nvcm0vbWFpbi5qcyIsIm1vZF9zdXJ2ZXkvbWFpbi5qcyIsIm1vZF91cmwvbWFpbi5qcyIsIm5vdGVzL21haW4uanMiLCJub3RpZmljYXRpb25zL21haW4uanMiLCJwYXJ0aWNpcGFudHMvbWFpbi5qcyIsInB1c2hub3RpZmljYXRpb25zL21haW4uanMiLCJyZW1vdGVzdHlsZXMvbWFpbi5qcyIsImNhbGVuZGFyL2NvbnRyb2xsZXJzL2V2ZW50LmpzIiwiY2FsZW5kYXIvY29udHJvbGxlcnMvbGlzdC5qcyIsImNhbGVuZGFyL3NlcnZpY2VzL2NhbGVuZGFyLmpzIiwiY2FsZW5kYXIvc2VydmljZXMvaGFuZGxlcnMuanMiLCJjb3Vyc2Vjb21wbGV0aW9uL2NvbnRyb2xsZXJzL3JlcG9ydC5qcyIsImNvdXJzZWNvbXBsZXRpb24vc2VydmljZXMvY291cnNlY29tcGxldGlvbi5qcyIsImNvdXJzZWNvbXBsZXRpb24vc2VydmljZXMvaGFuZGxlcnMuanMiLCJmaWxlcy9jb250cm9sbGVycy9jaG9vc2VzaXRlLmpzIiwiZmlsZXMvY29udHJvbGxlcnMvaW5kZXguanMiLCJmaWxlcy9jb250cm9sbGVycy9saXN0LmpzIiwiZmlsZXMvY29udHJvbGxlcnMvdXBsb2FkLmpzIiwiZmlsZXMvZGlyZWN0aXZlcy9vbmNoYW5nZS5qcyIsImZpbGVzL3NlcnZpY2VzL2ZpbGVzLmpzIiwiZmlsZXMvc2VydmljZXMvaGFuZGxlcnMuanMiLCJmaWxlcy9zZXJ2aWNlcy9oZWxwZXIuanMiLCJmcm9udHBhZ2Uvc2VydmljZXMvZnJvbnRwYWdlLmpzIiwiZnJvbnRwYWdlL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwiZ3JhZGVzL2NvbnRyb2xsZXJzL3RhYmxlLmpzIiwiZ3JhZGVzL3NlcnZpY2VzL2dyYWRlcy5qcyIsImdyYWRlcy9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1lc3NhZ2VzL2NvbnRyb2xsZXJzL2NvbnRhY3RzLmpzIiwibWVzc2FnZXMvY29udHJvbGxlcnMvZGlzY3Vzc2lvbi5qcyIsIm1lc3NhZ2VzL2NvbnRyb2xsZXJzL2Rpc2N1c3Npb25zLmpzIiwibWVzc2FnZXMvY29udHJvbGxlcnMvaW5kZXguanMiLCJtZXNzYWdlcy9maWx0ZXJzL2Zvcm1hdC5qcyIsIm1lc3NhZ2VzL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibWVzc2FnZXMvc2VydmljZXMvbWVzc2FnZXMuanMiLCJtb2RfYXNzaWduL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX2Fzc2lnbi9jb250cm9sbGVycy9zdWJtaXNzaW9uLmpzIiwibW9kX2Fzc2lnbi9zZXJ2aWNlcy9hc3NpZ24uanMiLCJtb2RfYXNzaWduL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX2Jvb2svY29udHJvbGxlcnMvaW5kZXguanMiLCJtb2RfYm9vay9kaXJlY3RpdmVzL2Fycm93cy5qcyIsIm1vZF9ib29rL3NlcnZpY2VzL2Jvb2suanMiLCJtb2RfYm9vay9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9ib29rL3NlcnZpY2VzL3ByZWZldGNoX2hhbmRsZXIuanMiLCJtb2RfY2hhdC9jb250cm9sbGVycy9jaGF0LmpzIiwibW9kX2NoYXQvY29udHJvbGxlcnMvaW5kZXguanMiLCJtb2RfY2hhdC9zZXJ2aWNlcy9jaGF0LmpzIiwibW9kX2NoYXQvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfY2hvaWNlL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX2Nob2ljZS9zZXJ2aWNlcy9jaG9pY2UuanMiLCJtb2RfY2hvaWNlL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX2ZvbGRlci9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9mb2xkZXIvc2VydmljZXMvZm9sZGVyLmpzIiwibW9kX2ZvbGRlci9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9mb2xkZXIvc2VydmljZXMvcHJlZmV0Y2hfaGFuZGxlci5qcyIsIm1vZF9nbG9zc2FyeS9jb250cm9sbGVycy9lbnRyeS5qcyIsIm1vZF9nbG9zc2FyeS9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9nbG9zc2FyeS9zZXJ2aWNlcy9nbG9zc2FyeS5qcyIsIm1vZF9nbG9zc2FyeS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9mb3J1bS9jb250cm9sbGVycy9kaXNjdXNzaW9uLmpzIiwibW9kX2ZvcnVtL2NvbnRyb2xsZXJzL2Rpc2N1c3Npb25zLmpzIiwibW9kX2ZvcnVtL2NvbnRyb2xsZXJzL25ld2Rpc2N1c3Npb24uanMiLCJtb2RfZm9ydW0vZGlyZWN0aXZlcy9kaXNjdXNzaW9ucG9zdC5qcyIsIm1vZF9mb3J1bS9zZXJ2aWNlcy9mb3J1bS5qcyIsIm1vZF9mb3J1bS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9pbXNjcC9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9pbXNjcC9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9pbXNjcC9zZXJ2aWNlcy9pbXNjcC5qcyIsIm1vZF9pbXNjcC9zZXJ2aWNlcy9wcmVmZXRjaF9oYW5kbGVyLmpzIiwibW9kX2xhYmVsL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX2xhYmVsL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX2x0aS9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9sdGkvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfbHRpL3NlcnZpY2VzL2x0aS5qcyIsIm1vZF9wYWdlL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX3BhZ2Uvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfcGFnZS9zZXJ2aWNlcy9wYWdlLmpzIiwibW9kX3BhZ2Uvc2VydmljZXMvcHJlZmV0Y2hfaGFuZGxlci5qcyIsIm1vZF9yZXNvdXJjZS9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9yZXNvdXJjZS9kaXJlY3RpdmVzL2h0bWxfbGluay5qcyIsIm1vZF9yZXNvdXJjZS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9yZXNvdXJjZS9zZXJ2aWNlcy9wcmVmZXRjaF9oYW5kbGVyLmpzIiwibW9kX3Jlc291cmNlL3NlcnZpY2VzL3Jlc291cmNlLmpzIiwibW9kX3Njb3JtL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX3Njb3JtL2NvbnRyb2xsZXJzL3BsYXllci5qcyIsIm1vZF9zY29ybS9zZXJ2aWNlcy9kYXRhX21vZGVsXzEyLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL2hlbHBlci5qcyIsIm1vZF9zY29ybS9zZXJ2aWNlcy9wcmVmZXRjaF9oYW5kbGVyLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL3Njb3JtLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL3Njb3JtX29mZmxpbmUuanMiLCJtb2Rfc2Nvcm0vc2VydmljZXMvc2Nvcm1fb25saW5lLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL3Njb3JtX3N5bmMuanMiLCJtb2Rfc3VydmV5L2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX3N1cnZleS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9zdXJ2ZXkvc2VydmljZXMvc3VydmV5LmpzIiwibW9kX3VybC9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF91cmwvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfdXJsL3NlcnZpY2VzL3VybC5qcyIsIm5vdGVzL2NvbnRyb2xsZXJzL2xpc3QuanMiLCJub3Rlcy9jb250cm9sbGVycy90eXBlcy5qcyIsIm5vdGVzL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibm90ZXMvc2VydmljZXMvbm90ZXMuanMiLCJub3RpZmljYXRpb25zL2NvbnRyb2xsZXJzL2xpc3QuanMiLCJub3RpZmljYXRpb25zL2RpcmVjdGl2ZXMvYWN0aW9ucy5qcyIsIm5vdGlmaWNhdGlvbnMvZmlsdGVycy9mb3JtYXQuanMiLCJub3RpZmljYXRpb25zL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibm90aWZpY2F0aW9ucy9zZXJ2aWNlcy9ub3RpZmljYXRpb25zLmpzIiwicGFydGljaXBhbnRzL2NvbnRyb2xsZXJzL2xpc3QuanMiLCJwYXJ0aWNpcGFudHMvc2VydmljZXMvaGFuZGxlcnMuanMiLCJwYXJ0aWNpcGFudHMvc2VydmljZXMvcGFydGljaXBhbnRzLmpzIiwicHVzaG5vdGlmaWNhdGlvbnMvc2VydmljZXMvZGVsZWdhdGUuanMiLCJwdXNobm90aWZpY2F0aW9ucy9zZXJ2aWNlcy9wdXNobm90aWZpY2F0aW9ucy5qcyIsInJlbW90ZXN0eWxlcy9zZXJ2aWNlcy9yZW1vdGVzdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsUUFBUSxPQUFPLE1BQU0sQ0FBQyxTQUFTLGFBQWEsZUFBZSwwQkFBMEIsVUFBVSx3QkFBd0I7O0NBRXRILHVCQUFJLFNBQVMs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LE9BQU8sWUFBWSxrQkFBa0IsUUFBUSxLQUFLLEtBQUssU0FBUyxPQUFPO2dCQUNuRSxPQUFPLFVBQVU7ZUFDbEIsTUFBTSxXQUFXO2dCQUNoQixPQUFPO2VBQ1IsS0FBSyxTQUFTLGNBQWM7Z0JBQzNCLElBQUksQ0FBQyxjQUFjOztvQkFFZixPQUFPLFlBQVksdUJBQXVCLFFBQVEsMEJBQTBCOztlQUVqRixLQUFLLFdBQVc7Z0JBQ2YsT0FBTyxZQUFZLFlBQVksUUFBUSxLQUFLLE9BQU8sMEJBQTBCOzs7O1FBSXJGLE9BQU8sZ0JBQWdCLFFBQVEsUUFBUSxLQUFLLFNBQVMsTUFBTTtZQUN2RCxJQUFJLFFBQVEsS0FBSztZQUNqQixJQUFJLFNBQVMsTUFBTSxjQUFjO2dCQUM3QixJQUFJLE1BQU0sZUFBZTs7b0JBRXJCLE9BQU8seUJBQXlCLE1BQU07dUJBQ25DOztvQkFFSCxPQUFPLE1BQU07O21CQUVkO2dCQUNILElBQUksTUFBTSxpQkFBaUIsSUFBSTs7b0JBRTNCLFlBQVksdUJBQXVCLFFBQVEsMEJBQTBCOztnQkFFekUsT0FBTyxHQUFHOztXQUVmLEtBQUssU0FBUyxLQUFLO1lBQ2xCLEtBQUssTUFBTSx3QkFBd0I7WUFDbkMsT0FBTyxNQUFNLElBQUk7V0FDbEIsS0FBSyxTQUFTLFVBQVU7WUFDdkIsSUFBSSxPQUFPLFNBQVMsUUFBUSxVQUFVO2dCQUNsQyxPQUFPLFNBQVM7bUJBQ2I7Z0JBQ0gsT0FBTyxHQUFHOzs7Ozs7Ozs7Ozs7SUFZdEIsS0FBSyxPQUFPLFdBQVc7UUFDbkIsSUFBSSxTQUFTLFFBQVE7UUFDckIsSUFBSSxRQUFRO1lBQ1IsS0FBSyxJQUFJLFFBQVEsS0FBSyxTQUFTLFFBQVE7Z0JBQ25DLElBQUksV0FBVyxRQUFRLFNBQVM7b0JBQzVCLGVBQWUsS0FBSzs7Ozs7O0lBTXBDLE9BQU87O0FBRVgiLCJmaWxlIjoibW0uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBGYWN0b3J5IHRvIHByb3ZpZGUgc29tZSBnbG9iYWwgZnVuY3Rpb25hbGl0aWVzLCBsaWtlIGFjY2VzcyB0byB0aGUgZ2xvYmFsIGFwcCBkYXRhYmFzZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBwcm92aWRlclxuICogQG5hbWUgJG1tQXBwXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgcHJvdmlkZXIgaXMgdGhlIGludGVyZmFjZSB3aXRoIHRoZSBhcHAgZGF0YWJhc2UuIFRoZSBtb2R1bGVzIHRoYXQgbmVlZCB0byBzdG9yZVxuICogaW5mb3JtYXRpb24gaGVyZSBuZWVkIHRvIHJlZ2lzdGVyIHRoZWlyIHN0b3Jlcy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIC5jb25maWcoZnVuY3Rpb24oJG1tQXBwUHJvdmlkZXIpIHtcbiAqICAgICAgJG1tQXBwUHJvdmlkZXIucmVnaXN0ZXJTdG9yZSh7XG4gKiAgICAgICAgICBuYW1lOiAnc2V0dGluZ3MnLFxuICogICAgICAgICAga2V5UGF0aDogJ25hbWUnXG4gKiAgICAgIH0pO1xuICogIH0pXG4gKi9cbi5wcm92aWRlcignJG1tQXBwJywgZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgIC8qKiBEZWZpbmUgdGhlIGFwcCBzdG9yYWdlIHNjaGVtYS4gKi9cbiAgICB2YXIgREJOQU1FID0gJ01vb2RsZU1vYmlsZScsXG4gICAgICAgIGRic2NoZW1hID0ge1xuICAgICAgICAgICAgc3RvcmVzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBkYm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhdXRvU2NoZW1hOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHN0b3JlIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc3RvcmUgVGhlIHN0b3JlIG9iamVjdCBkZWZpbml0aW9uLlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdGhpcy5yZWdpc3RlclN0b3JlID0gZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZihzdG9yZS5uYW1lKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCckbW1BcHA6IEVycm9yOiBzdG9yZSBuYW1lIGlzIHVuZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChzdG9yZUV4aXN0cyhzdG9yZS5uYW1lKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJyRtbUFwcDogRXJyb3I6IHN0b3JlICcgKyBzdG9yZS5uYW1lICsgJyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGJzY2hlbWEuc3RvcmVzLnB1c2goc3RvcmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBtdWx0aXBsZSBzdG9yZXMgYXQgb25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBzdG9yZXMgQXJyYXkgb2Ygc3RvcmUgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHRoaXMucmVnaXN0ZXJTdG9yZXMgPSBmdW5jdGlvbihzdG9yZXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goc3RvcmVzLCBmdW5jdGlvbihzdG9yZSkge1xuICAgICAgICAgICAgc2VsZi5yZWdpc3RlclN0b3JlKHN0b3JlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc3RvcmUgaXMgYWxyZWFkeSBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIHdoZW4gdGhlIHN0b3JlIHdhcyBhbHJlYWR5IGRlZmluZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmVFeGlzdHMobmFtZSkge1xuICAgICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYnNjaGVtYS5zdG9yZXMsIGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgIH1cblxuICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uKCRtbURCLCAkY29yZG92YU5ldHdvcmssICRsb2csICRpbmplY3RvciwgJGlvbmljUGxhdGZvcm0pIHtcblxuICAgICAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tQXBwJyk7XG5cbiAgICAgICAgdmFyIGRiLFxuICAgICAgICAgICAgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgc3RhdGUgaW4gdGhlIFVJLXJvdXRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQXBwI2NyZWF0ZVN0YXRlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgU3RhdGUgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBTdGF0ZSBjb25maWcuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmNyZWF0ZVN0YXRlID0gZnVuY3Rpb24obmFtZSwgY29uZmlnKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdBZGRpbmcgbmV3IHN0YXRlOiAnK25hbWUpO1xuICAgICAgICAgICAgJHN0YXRlUHJvdmlkZXIuc3RhdGUobmFtZSwgY29uZmlnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBrZXlib2FyZCBpZiBwbHVnaW4gaXMgYXZhaWxhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBsdWdpbiBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuY2xvc2VLZXlib2FyZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb3Jkb3ZhICE9ICd1bmRlZmluZWQnICYmIGNvcmRvdmEucGx1Z2lucyAmJiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQgJiYgY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYXBwbGljYXRpb24gZ2xvYmFsIGRhdGFiYXNlLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFwcCdzIERCLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXREQiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYiA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRiID0gJG1tREIuZ2V0REIoREJOQU1FLCBkYnNjaGVtYSwgZGJvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGRhdGFiYXNlIHNjaGVtYS5cbiAgICAgICAgICpcbiAgICAgICAgICogRG8gbm90IHVzZSB0aGlzIG1ldGhvZCB0byBtb2RpZnkgdGhlIHNjaGVtYS4gVXNlICRtbUFwcFByb3ZpZGVyI3JlZ2lzdGVyU3RvcmUgaW5zdGVhZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgc2NoZW1hLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRTY2hlbWEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkYnNjaGVtYTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29yZSBpbml0IHByb2Nlc3MgZm9yIHRoZSBhcHAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGlzIHNob3VsZCBiZSB0aGUgZmlyc3QgaW5pdCBwcm9jZXNzIG9mIGFsbCwgbm8gb3RoZXIgcHJvY2VzcyBzaG91bGQgcnVuIHVudGlsIHdlXG4gICAgICAgICAqIGFyZSBjZXJ0YWluIHRoYXQgdGhlIGNvcmRvdmEgcGx1Z2lucyBhcmUgbG9hZGVkLCB3aGljaCBpcyB3aGF0ICRpb25pY1BsYXRmb3JtIHRlbGxzIHVzLlxuICAgICAgICAgKiBUaGVyZSBzaG91bGQgbm90IGJlIGFueSBsb2dpYyBhY3Rpbmcgb24gdGhlIGRhdGFiYXNlIGhlcmUgYXMgdGhlIHVwZ3JhZGUgaXNcbiAgICAgICAgICogYW5vdGhlciBwcm9jZXNzIGFuZCBoYXMgbm90IHJ1biB5ZXQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICpcbiAgICAgICAgICogS2VlcCB0aGlzIGZhc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlc2VydmVkIGZvciBjb3JlIHVzZSwgZG8gbm90IGNhbGwgZGlyZWN0bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2Mgc2VydmljZVxuICAgICAgICAgKiBAbmFtZSAkbW1BcHAjaW5pdFByb2Nlc3NcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pbml0UHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRpb25pY1BsYXRmb3JtLnJlYWR5KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgYXBwIGlzIHJ1bm5pbmcgaW4gYSByZWFsIGRldmljZSB3aXRoIGNvcmRvdmEtcGx1Z2luLWRldmljZSBpbnN0YWxsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUFwcCNpc0RldmljZVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sfSBUcnVlIGlmIGRldmljZSBpcyBkZWZpbmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRGV2aWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gISF3aW5kb3cuZGV2aWNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgd2UgYXJlIG9ubGluZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQXBwI2lzT25saW5lXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2x9IFRydWUgd2hlbiB3ZSBhcmUuXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGlzIG1ldGhvZHMgcmV0dXJucyB3aGV0aGVyIHRoZSBhcHAgaXMgb25saW5lIG9yIG5vdC5cbiAgICAgICAgICogTm90ZSB0aGF0IGEgYnJvd3NlciBpcyBhbHdheXMgY29uc2lkZXJlZCBiZWluZyBvbmxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzT25saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb25saW5lID0gdHlwZW9mIG5hdmlnYXRvci5jb25uZWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAkY29yZG92YU5ldHdvcmsuaXNPbmxpbmUoKTtcbiAgICAgICAgICAgIC8vIERvdWJsZSBjaGVjayB3ZSBhcmUgbm90IG9ubGluZSBiZWNhdXNlIHdlIGNhbm5vdCByZWx5IDEwMCUgaW4gQ29yZG92YSBBUElzLlxuICAgICAgICAgICAgaWYgKCFvbmxpbmUgJiYgbmF2aWdhdG9yLm9uTGluZSkge1xuICAgICAgICAgICAgICAgIG9ubGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb25saW5lO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIENoZWNrIGlmIGRldmljZSB1c2VzIGEgbGltaXRlZCBjb25uZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1BcHAjaXNOZXR3b3JrQWNjZXNzTGltaXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGRldmljZSB1c2VkIGEgbGltaXRlZCBjb25uZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHVzIHRvIGZpcnN0IGNoZWNrIGlmIGNvcmRvdmEgaXMgbG9hZGVkLFxuICAgICAgICAgKiBvdGhlcndpc2UgZXhjZXB0aW9ucyBjYW4gYmUgdGhyb3duIHdoZW4gdHJ5aW5nIG9uIGEgYnJvd3Nlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNOZXR3b3JrQWNjZXNzTGltaXRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IuY29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBQbHVnaW4gbm90IGRlZmluZWQsIHByb2JhYmx5IGluIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHR5cGUgPSAkY29yZG92YU5ldHdvcmsuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgdmFyIGxpbWl0ZWQgPSBbQ29ubmVjdGlvbi5DRUxMXzJHLCBDb25uZWN0aW9uLkNFTExfM0csIENvbm5lY3Rpb24uQ0VMTF80RywgQ29ubmVjdGlvbi5DRUxMXTtcbiAgICAgICAgICAgIHJldHVybiBsaW1pdGVkLmluZGV4T2YodHlwZSkgPiAtMTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGx5IHJldHVybnMgaWYgdGhlIGFwcCBpcyByZWFkeS5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgYXBwIGlzIHJlYWR5LCByZWZlciB0byB7QGxpbmsgJG1tQXBwI3JlYWR5fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQXBwI3JlYWR5XG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgd2hlbiBpdCBpcywgZmFsc2Ugd2hlbiBub3QuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzUmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gJGluamVjdG9yLmdldCgnJG1tSW5pdERlbGVnYXRlJykucmVhZHkoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLiQkc3RhdGUuc3RhdHVzID09PSAxO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVuIHRoZSBrZXlib2FyZCBpZiBwbHVnaW4gaXMgYXZhaWxhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBsdWdpbiBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYub3BlbktleWJvYXJkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvcmRvdmEgIT0gJ3VuZGVmaW5lZCcgJiYgY29yZG92YS5wbHVnaW5zICYmIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZCAmJiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuc2hvdykge1xuICAgICAgICAgICAgICAgIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5zaG93KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmVzIHdoZW4gdGhlIGFwcCBpcyByZWFkeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQXBwI3JlYWR5XG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGlzIHJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgYXBwIGlzIGluaXRpYWxpc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2FnZTpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgJG1tQXBwLnJlYWR5KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgICAgIC8vIFdoYXQgeW91IHdhbnQgdG8gZG8uXG4gICAgICAgICAqICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhcHAgaXMgaW5pdGlhbGlzZWQuIE5ldmVyIHJlamVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5yZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gSW5qZWN0cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgIHJldHVybiAkaW5qZWN0b3IuZ2V0KCckbW1Jbml0RGVsZWdhdGUnKS5yZWFkeSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScsIFsncGFzY2FscHJlY2h0LnRyYW5zbGF0ZSddKVxuXG4uY29uc3RhbnQoJ21tQ29yZVNlc3Npb25FeHBpcmVkJywgJ21tQ29yZVNlc3Npb25FeHBpcmVkJylcbi5jb25zdGFudCgnbW1Db3JlVXNlckRlbGV0ZWQnLCAnbW1Db3JlVXNlckRlbGV0ZWQnKVxuLmNvbnN0YW50KCdtbUNvcmVTZWNvbmRzWWVhcicsIDMxNTM2MDAwKVxuLmNvbnN0YW50KCdtbUNvcmVTZWNvbmRzRGF5JywgODY0MDApXG4uY29uc3RhbnQoJ21tQ29yZVNlY29uZHNIb3VyJywgMzYwMClcbi5jb25zdGFudCgnbW1Db3JlU2Vjb25kc01pbnV0ZScsIDYwKVxuXG4vLyBTdGF0ZXMgZm9yIGRvd25sb2FkaW5nIGZpbGVzL21vZHVsZXMuXG4uY29uc3RhbnQoJ21tQ29yZURvd25sb2FkZWQnLCAnZG93bmxvYWRlZCcpXG4uY29uc3RhbnQoJ21tQ29yZURvd25sb2FkaW5nJywgJ2Rvd25sb2FkaW5nJylcbi5jb25zdGFudCgnbW1Db3JlTm90RG93bmxvYWRlZCcsICdub3Rkb3dubG9hZGVkJylcbi5jb25zdGFudCgnbW1Db3JlT3V0ZGF0ZWQnLCAnb3V0ZGF0ZWQnKVxuLmNvbnN0YW50KCdtbUNvcmVOb3REb3dubG9hZGFibGUnLCAnbm90ZG93bmxvYWRhYmxlJylcblxuLmNvbnN0YW50KCdtbUNvcmVXaWZpRG93bmxvYWRUaHJlc2hvbGQnLCAxMDQ4NTc2MDApIC8vIDEwME1CLlxuLmNvbnN0YW50KCdtbUNvcmVEb3dubG9hZFRocmVzaG9sZCcsIDEwNDg1NzYwKSAvLyAxME1CLlxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkcHJvdmlkZSwgJGlvbmljQ29uZmlnUHJvdmlkZXIsICRodHRwUHJvdmlkZXIsICRtbVV0aWxQcm92aWRlcixcbiAgICAgICAgJG1tTG9nUHJvdmlkZXIsICRjb21waWxlUHJvdmlkZXIsICRtbUluaXREZWxlZ2F0ZVByb3ZpZGVyLCBtbUluaXREZWxlZ2F0ZU1heEFkZG9uUHJpb3JpdHkpIHtcblxuICAgIC8vIFNldCB0YWJzIHRvIGJvdHRvbSBvbiBBbmRyb2lkLlxuICAgICRpb25pY0NvbmZpZ1Byb3ZpZGVyLnBsYXRmb3JtLmFuZHJvaWQudGFicy5wb3NpdGlvbignYm90dG9tJyk7XG5cbiAgICAvLyBEZWNvcmF0ZSAkaW9uaWNQbGF0Zm9ybS5cbiAgICAkcHJvdmlkZS5kZWNvcmF0b3IoJyRpb25pY1BsYXRmb3JtJywgWyckZGVsZWdhdGUnLCAnJHdpbmRvdycsIGZ1bmN0aW9uKCRkZWxlZ2F0ZSwgJHdpbmRvdykge1xuICAgICAgICAkZGVsZWdhdGUuaXNUYWJsZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBtcSA9ICdvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxKSc7XG4gICAgICAgICAgICByZXR1cm4gJHdpbmRvdy5tYXRjaE1lZGlhKG1xKS5tYXRjaGVzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJGRlbGVnYXRlO1xuICAgIH1dKTtcblxuICAgIC8qKlxuICAgICAqIERlY29yYXRlICRsb2cuIFVzYWdlOlxuICAgICAqICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdNeUZhY3RvcnknKVxuICAgICAqICRsb2cuZGVidWcoJ015IG1lc3NhZ2UnKSAtPiBcImRkL21tL2FhYWEgaGg6bW06c3MgTXlGYWN0b3J5OiBNeSBtZXNzYWdlXCJcbiAgICAgKi9cbiAgICAkcHJvdmlkZS5kZWNvcmF0b3IoJyRsb2cnLCBbJyRkZWxlZ2F0ZScsICRtbUxvZ1Byb3ZpZGVyLmxvZ0RlY29yYXRvcl0pO1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcbiAgICAgICAgLnN0YXRlKCdyZWRpcmVjdCcsIHtcbiAgICAgICAgICAgIHVybDogJy9yZWRpcmVjdCcsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBzaXRlaWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgY29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsICRzdGF0ZVBhcmFtcywgJG1tU2l0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCAkaW9uaWNIaXN0b3J5KSB7XG5cbiAgICAgICAgICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7ZGlzYWJsZUJhY2s6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWRTaXRlQW5kR28oKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5sb2FkU2l0ZSgkc3RhdGVQYXJhbXMuc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCRzdGF0ZVBhcmFtcy5zdGF0ZSwgJHN0YXRlUGFyYW1zLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2l0ZSBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdtbV9sb2dpbi5zaXRlcycpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmVudGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzdGF0ZVBhcmFtcy5zaXRlaWQgJiYgJHN0YXRlUGFyYW1zLnNpdGVpZCAhPSAkbW1TaXRlLmdldElkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RpZmljYXRpb24gYmVsb25ncyB0byBhIGRpZmZlcmVudCBzaXRlLiBDaGFuZ2Ugc2l0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1TaXRlc01hbmFnZXIubG9nb3V0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZFNpdGVBbmRHbygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJHN0YXRlUGFyYW1zLnN0YXRlLCAkc3RhdGVQYXJhbXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc3RhdGVQYXJhbXMuc2l0ZWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZFNpdGVBbmRHbygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ21tX2xvZ2luLnNpdGVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAvLyBUaGlzIGNvZGUgaXMgdG8gYmUgYWJsZSB0byBnZXQgZGF0YSBzZW50IHdpdGggJGh0dHAucG9zdCB1c2luZyAkX1BPU1QgdmFyaWFibGUuXG4gICAgLy8gT3RoZXJ3aXNlIGFsbCB0aGUgZGF0YSBlbmRzIHVwIGluIHBocDovL2lucHV0IGFuZCBzZWVtcyBsaWtlIGxvY2FsL21vYmlsZS9jaGVjay5waHAgZG9lc24ndCBsaWtlIGl0LlxuICAgICRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVycy5wb3N0WydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCc7XG4gICAgJGh0dHBQcm92aWRlci5kZWZhdWx0cy50cmFuc2Zvcm1SZXF1ZXN0ID0gW2Z1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNPYmplY3QoZGF0YSkgJiYgU3RyaW5nKGRhdGEpICE9PSAnW29iamVjdCBGaWxlXScgPyAkbW1VdGlsUHJvdmlkZXIucGFyYW0oZGF0YSkgOiBkYXRhO1xuICAgIH1dO1xuXG4gICAgLy8gQWRkIHNvbWUgcHJvdG9jb2xzIHRvIHNhZmUgcHJvdG9jb2xzLlxuICAgIGZ1bmN0aW9uIGFkZFByb3RvY29sSWZNaXNzaW5nKGxpc3QsIHByb3RvY29sKSB7XG4gICAgICAgIGlmIChsaXN0LmluZGV4T2YocHJvdG9jb2wpID09IC0xKSB7XG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5yZXBsYWNlKCdodHRwcz8nLCAnaHR0cHM/fCcgKyBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgdmFyIGhyZWZsaXN0ID0gJGNvbXBpbGVQcm92aWRlci5hSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdCgpLnNvdXJjZSxcbiAgICAgICAgaW1nbGlzdCA9ICRjb21waWxlUHJvdmlkZXIuaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0KCkuc291cmNlO1xuXG4gICAgaHJlZmxpc3QgPSBhZGRQcm90b2NvbElmTWlzc2luZyhocmVmbGlzdCwgJ2ZpbGUnKTtcbiAgICBocmVmbGlzdCA9IGFkZFByb3RvY29sSWZNaXNzaW5nKGhyZWZsaXN0LCAndGVsJyk7XG4gICAgaHJlZmxpc3QgPSBhZGRQcm90b2NvbElmTWlzc2luZyhocmVmbGlzdCwgJ21haWx0bycpO1xuICAgIGhyZWZsaXN0ID0gYWRkUHJvdG9jb2xJZk1pc3NpbmcoaHJlZmxpc3QsICdnZW8nKTtcbiAgICBocmVmbGlzdCA9IGFkZFByb3RvY29sSWZNaXNzaW5nKGhyZWZsaXN0LCAnZmlsZXN5c3RlbScpOyAvLyBGb3IgSFRNTDUgRmlsZVN5c3RlbS5cbiAgICBpbWdsaXN0ID0gYWRkUHJvdG9jb2xJZk1pc3NpbmcoaW1nbGlzdCwgJ2ZpbGVzeXN0ZW0nKTsgLy8gRm9yIEhUTUw1IEZpbGVTeXN0ZW0uXG5cbiAgICAkY29tcGlsZVByb3ZpZGVyLmFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0KGhyZWZsaXN0KTtcbiAgICAkY29tcGlsZVByb3ZpZGVyLmltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdChpbWdsaXN0KTtcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBjb3JlIGluaXQgcHJvY2VzcywgdGhpcyBzaG91bGQgYmUgdGhlIHZlcnkgZmlyc3QgdGhpbmcuXG4gICAgJG1tSW5pdERlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcm9jZXNzKCdtbUFwcEluaXQnLCAnJG1tQXBwLmluaXRQcm9jZXNzJywgbW1Jbml0RGVsZWdhdGVNYXhBZGRvblByaW9yaXR5ICsgNDAwLCB0cnVlKTtcblxuICAgIC8vIFJlZ2lzdGVyIHVwZ3JhZGUgY2hlY2sgcHJvY2VzcywgdGhpcyBzaG91bGQgaGFwcGVuIGFsbW9zdCBiZWZvcmUgZXZlcnl0aGluZyBlbHNlLlxuICAgICRtbUluaXREZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJvY2VzcygnbW1VcGRhdGVNYW5hZ2VyJywgJyRtbVVwZGF0ZU1hbmFnZXIuY2hlY2snLCBtbUluaXREZWxlZ2F0ZU1heEFkZG9uUHJpb3JpdHkgKyAzMDAsIHRydWUpO1xufSlcblxuLnJ1bihmdW5jdGlvbigkaW9uaWNQbGF0Zm9ybSwgJGlvbmljQm9keSwgJHdpbmRvdywgJG1tRXZlbnRzLCAkbW1Jbml0RGVsZWdhdGUsIG1tQ29yZUV2ZW50S2V5Ym9hcmRTaG93LCBtbUNvcmVFdmVudEtleWJvYXJkSGlkZSkge1xuICAgIC8vIEV4ZWN1dGUgYWxsIHRoZSBpbml0IHByb2Nlc3Nlcy5cbiAgICAkbW1Jbml0RGVsZWdhdGUuZXhlY3V0ZUluaXRQcm9jZXNzZXMoKTtcblxuICAgIC8vIFdoZW4gdGhlIHBsYXRmb3JtIGlzIHJlYWR5LlxuICAgICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hlY2tUYWJsZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRpb25pY0JvZHkuZW5hYmxlQ2xhc3MoJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSwgJ3RhYmxldCcpO1xuICAgICAgICB9O1xuICAgICAgICBpb25pYy5vbigncmVzaXplJywgY2hlY2tUYWJsZXQsICR3aW5kb3cpO1xuICAgICAgICBjaGVja1RhYmxldCgpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3Iga2V5Ym9hcmQgZXZlbnRzLiBXZSBkb24ndCB1c2UgJGNvcmRvdmFLZXlib2FyZCBiZWNhdXNlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBrZXlib2FyZEhlaWdodCBwcm9wZXJ0eS5cbiAgICAgICAgJHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRzaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRLZXlib2FyZFNob3csIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgJHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRoaWRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRLZXlib2FyZEhpZGUsIGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQWRkb25NYW5hZ2VyXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzZXJ2aWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyByZWxhdGVkIHRvIGFkZG9ucywgbGlrZSBjaGVja2luZyBpZiBhbiBhZGRvbiBpcyBhdmFpbGFibGUuXG4gKi9cbi5mYWN0b3J5KCckbW1BZGRvbk1hbmFnZXInLCBmdW5jdGlvbigkbG9nLCAkaW5qZWN0b3IpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1BZGRvbk1hbmFnZXInKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGluc3RhbmNlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc2VydmljZSBpbnN0YW5jZSBpZiBpdCdzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1BZGRvbk1hbmFnZXIjZ2V0XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgU2VydmljZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKHNlbGYuaXNBdmFpbGFibGUobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBzZXJ2aWNlIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1BZGRvbk1hbmFnZXIjaXNBdmFpbGFibGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU2VydmljZSBuYW1lLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNBdmFpbGFibGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlc1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2VzW25hbWVdID0gJGluamVjdG9yLmdldChuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAkbG9nLndhcm4oJ1NlcnZpY2Ugbm90IGF2YWlsYWJsZTogJytuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLyoqXG4gKiA9PT09PT09PT09PT09PT09PT0gIGFuZ3VsYXItaW9zOS11aXdlYnZpZXcucGF0Y2guanMgdjEuMS4wID09PT09PT09PT09PT09PT09PVxuICpcbiAqIFRoaXMgcGF0Y2ggd29ya3MgYXJvdW5kIGlPUzkgVUlXZWJWaWV3IHJlZ3Jlc3Npb24gdGhhdCBjYXVzZXMgaW5maW5pdGUgZGlnZXN0XG4gKiBlcnJvcnMgaW4gQW5ndWxhci5cbiAqXG4gKiBUaGUgcGF0Y2ggY2FuIGJlIGFwcGxpZWQgdG8gQW5ndWxhciAxLjIuMCDigJMgMS40LjUuIE5ld2VyIHZlcnNpb25zIG9mIEFuZ3VsYXJcbiAqIGhhdmUgdGhlIHdvcmthcm91bmQgYmFrZWQgaW4uXG4gKlxuICogVG8gYXBwbHkgdGhpcyBwYXRjaCBsb2FkL2J1bmRsZSB0aGlzIGZpbGUgd2l0aCB5b3VyIGFwcGxpY2F0aW9uIGFuZCBhZGQgYVxuICogZGVwZW5kZW5jeSBvbiB0aGUgXCJuZ0lPUzlQYXRjaFwiIG1vZHVsZSB0byB5b3VyIG1haW4gYXBwIG1vZHVsZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIGFuZ3VsYXIubW9kdWxlKCdteUFwcCcsIFsnbmdSb3V0ZSddKWBcbiAqIGBgYFxuICpcbiAqIGJlY29tZXNcbiAqXG4gKiBgYGBcbiAqIGFuZ3VsYXIubW9kdWxlKCdteUFwcCcsIFsnbmdSb3V0ZScsICduZ0lPUzlVSVdlYlZpZXdQYXRjaCddKVxuICogYGBgXG4gKlxuICpcbiAqIE1vcmUgaW5mbzpcbiAqIC0gaHR0cHM6Ly9vcGVucmFkYXIuYXBwc3BvdC5jb20vMjIxODYxMDlcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9pc3N1ZXMvMTIyNDFcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL2RyaWZ0eWNvL2lvbmljL2lzc3Vlcy80MDgyXG4gKlxuICpcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKU1xuICogKGMpIDIwMTAtMjAxNSBHb29nbGUsIEluYy4gaHR0cDovL2FuZ3VsYXJqcy5vcmdcbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmFuZ3VsYXIubW9kdWxlKCduZ0lPUzlVSVdlYlZpZXdQYXRjaCcsIFsnbmcnXSkuY29uZmlnKGZ1bmN0aW9uKCRwcm92aWRlKSB7XG4gICRwcm92aWRlLmRlY29yYXRvcignJGJyb3dzZXInLCBbJyRkZWxlZ2F0ZScsICckd2luZG93JywgZnVuY3Rpb24oJGRlbGVnYXRlLCAkd2luZG93KSB7XG5cbiAgICBpZiAoaXNJT1M5VUlXZWJWaWV3KCR3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIHJldHVybiBhcHBseUlPUzlTaGltKCRkZWxlZ2F0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICRkZWxlZ2F0ZTtcblxuICAgIGZ1bmN0aW9uIGlzSU9TOVVJV2ViVmlldyh1c2VyQWdlbnQpIHtcbiAgICAgIHJldHVybiAvKGlQaG9uZXxpUGFkfGlQb2QpLiogT1MgOV9cXGQvLnRlc3QodXNlckFnZW50KSAmJiAhL1ZlcnNpb25cXC85XFwuLy50ZXN0KHVzZXJBZ2VudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlJT1M5U2hpbShicm93c2VyKSB7XG4gICAgICB2YXIgcGVuZGluZ0xvY2F0aW9uVXJsID0gbnVsbDtcbiAgICAgIHZhciBvcmlnaW5hbFVybEZuPSBicm93c2VyLnVybDtcblxuICAgICAgYnJvd3Nlci51cmwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBwZW5kaW5nTG9jYXRpb25VcmwgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsVXJsRm4uYXBwbHkoYnJvd3NlciwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwZW5kaW5nTG9jYXRpb25VcmwgfHwgb3JpZ2luYWxVcmxGbi5hcHBseShicm93c2VyLCBhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgY2xlYXJQZW5kaW5nTG9jYXRpb25VcmwsIGZhbHNlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgY2xlYXJQZW5kaW5nTG9jYXRpb25VcmwsIGZhbHNlKTtcblxuICAgICAgZnVuY3Rpb24gY2xlYXJQZW5kaW5nTG9jYXRpb25VcmwoKSB7XG4gICAgICAgIHBlbmRpbmdMb2NhdGlvblVybCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicm93c2VyO1xuICAgIH1cbiAgfV0pO1xufSk7IiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLmNvbnN0YW50KCdtbUNvcmVDb25maWdTdG9yZScsICdjb25maWcnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUFwcFByb3ZpZGVyLCBtbUNvcmVDb25maWdTdG9yZSkge1xuICAgIHZhciBzdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1tQ29yZUNvbmZpZ1N0b3JlLFxuICAgICAgICAgICAga2V5UGF0aDogJ25hbWUnXG4gICAgICAgIH1cbiAgICBdO1xuICAgICRtbUFwcFByb3ZpZGVyLnJlZ2lzdGVyU3RvcmVzKHN0b3Jlcyk7XG59KVxuXG4vKipcbiAqIEZhY3RvcnkgdG8gcHJvdmlkZSBhY2Nlc3MgdG8gZHluYW1pYyBhbmQgcGVybWFuZW50IGNvbmZpZyBhbmQgc2V0dGluZ3MuXG4gKiBJdCBzaG91bGQgbm90IGJlIGFidXNlZCBpbnRvIGEgdGVtcG9yYXJ5IHN0b3JhZ2UuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQ29uZmlnXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgYXBwIHNldHRpbmdzLlxuICovXG4uZmFjdG9yeSgnJG1tQ29uZmlnJywgZnVuY3Rpb24oJHEsICRsb2csICRtbUFwcCwgbW1Db3JlQ29uZmlnU3RvcmUpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Db25maWcnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gYXBwIHNldHRpbmcuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ29uZmlnI2dldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICAgICAgICBUaGUgY29uZmlnIG5hbWUuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gIFtkZWZhdWx0VmFsdWVdIERlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHRoZSBlbnRyeSBpcyBub3QgZm91bmQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFJlc29sdmVzIHVwb24gc3VjY2VzcyBhbG9uZyB3aXRoIHRoZSBjb25maWcgZGF0YS4gUmVqZWN0IG9uIGZhaWx1cmUuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogR2V0IGFuIGFwcCBzZXR0aW5nLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0ID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5nZXQobW1Db3JlQ29uZmlnU3RvcmUsIG5hbWUpLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBhbiBhcHAgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBzZXJ2aWNlXG4gICAgICogQG5hbWUgJG1tQ29uZmlnI3NldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBjb25maWcgbmFtZS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgY29uZmlnIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgb24gc3VjY2VzcywgcHJvdmlkaW5nIG5vIGRhdGEuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2V0IGFuIGFwcCBzZXR0aW5nLlxuICAgICAqL1xuICAgIHNlbGYuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmluc2VydChtbUNvcmVDb25maWdTdG9yZSwge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIGFwcCBzZXR0aW5nLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvbmZpZyNkZWxldGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgY29uZmlnIG5hbWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgUHJvbWlzZSB3aGljaCByZXNvbHZlcyBvbiBzdWNjZXNzLCBwcm92aWRpbmcgbm8gZGF0YS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBEZWxldGUgYW4gYXBwIHNldHRpbmcuXG4gICAgICovXG4gICAgc2VsZi5kZWxldGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5yZW1vdmUobW1Db3JlQ29uZmlnU3RvcmUsIG5hbWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tREJcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHNlcnZpY2UgYWxsb3dzIHRvIGludGVyYWN0IHdpdGggdGhlIGxvY2FsIGRhdGFiYXNlIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBkYXRhLlxuICovXG4uZmFjdG9yeSgnJG1tREInLCBmdW5jdGlvbigkcSwgJGxvZykge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbURCJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBkYkluc3RhbmNlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVudCBoZWxwZXIgdG8gYXBwbHkgYW4gb3JkZXIgdG8gYSBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIFtxdWVyeV0gICBBIHF1ZXJ5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbb3JkZXJdICAgVGhlIGZpZWxkIHRvIG9yZGVyIG9uLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtyZXZlcnNlXSBXaGV0aGVyIHRvIHJldmVyc2UgdGhlIHJlc3VsdHMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgVGhlIHVwZGF0ZWQgcXVlcnkgb2JqZWN0IChvciBpbml0aWFsIG9uZSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwbHlPcmRlcihxdWVyeSwgb3JkZXIsIHJldmVyc2UpIHtcbiAgICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyKG9yZGVyKTtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbnQgaGVscGVyIHRvIGFwcGx5IGEgd2hlcmUgY29uZGl0aW9uIHRvIGEgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtxdWVyeV0gICBBIHF1ZXJ5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIFt3aGVyZV0gICBBcnJheSBvZiBwYXJhbWV0ZXJzLCBpbiBvcmRlcjpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBmaWVsZCB0byBmaWx0ZXIgb25cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBvcGVyYXRvcjogPCwgPD0sID0sID4sID49LCBeIChzdGFydHMgd2l0aClcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSB2YWx1ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQW4gYWRkaXRpb25hbCBvcGVyYXRvclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQW4gYWRkaXRpb25hbCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHVwZGF0ZWQgcXVlcnkgb2JqZWN0IChvciBpbml0aWFsIG9uZSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwbHlXaGVyZShxdWVyeSwgd2hlcmUpIHtcbiAgICAgICAgaWYgKHdoZXJlICYmIHdoZXJlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUuYXBwbHkocXVlcnksIHdoZXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBhIERCIHNpbXBsZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICBkYiAgICAgIERCIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBmdW5jICAgIE5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIG9wZXJhdGlvbiBmaW5pc2hlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsREJGdW5jdGlvbihkYiwgZnVuYykge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGRiKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRiW2Z1bmNdLmFwcGx5KGRiLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHJlc3VsdCkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciBleGVjdXRpbmcgZnVuY3Rpb24gJytmdW5jKycgdG8gREIgJytkYi5nZXROYW1lKCkpO1xuICAgICAgICAgICAgJGxvZy5lcnJvcihleC5uYW1lKyc6ICcrZXgubWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjb3VudCBvZiBlbnRyaWVzIG1hdGNoaW5nIGNlcnRhaW4gY29uZGl0aW9ucy5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICBkYiAgICAgICAgIERCIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBzdG9yZSAgICAgIE5hbWUgb2YgdGhlIHN0b3JlIHRvIGdldCB0aGUgZW50cmllcyBmcm9tLlxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgIHdoZXJlICAgICAgQXJyYXkgb2Ygd2hlcmUgY29uZGl0aW9ucywgc2VlIGFwcGx5V2hlcmUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsQ291bnQoZGIsIHN0b3JlLCB3aGVyZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgcXVlcnk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZGIpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBkYi5mcm9tKHN0b3JlKTtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IGFwcGx5V2hlcmUocXVlcnksIHdoZXJlKTtcbiAgICAgICAgICAgICAgICBxdWVyeS5jb3VudCgpLnRoZW4oZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShjb3VudCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgcXVlcnlpbmcgZGIgJytkYi5nZXROYW1lKCkrJy4gJytleC5uYW1lKyc6ICcrZXgubWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGVudHJpZXMgbWF0Y2hpbmcgY2VydGFpbiBjb25kaXRpb25zLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIGRiICAgICAgICAgREIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHN0b3JlICAgICAgTmFtZSBvZiB0aGUgc3RvcmUgdG8gZ2V0IHRoZSBlbnRyaWVzIGZyb20uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgZmllbGRfbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0aGF0IHNob3VsZCBtYXRjaCB0aGUgY29uZGl0aW9ucy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBvcCAgICAgICAgIEZpcnN0IG9wZXJhdG9yIHN5bWJvbC4gT25lIG9mICc8JywgJzw9JywgJz0nLCAnPicsICc+PScsICdeJy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB2YWx1ZSAgICAgIFZhbHVlIGZvciB0aGUgZmlyc3Qgb3BlcmF0b3IuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgb3AyICAgICAgICBTZWNvbmQgb3BlcmF0b3Igc3ltYm9sLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHZhbHVlMiAgICAgVmFsdWUgZm9yIHRoZSBzZWNvbmQgb3BlcmF0b3IuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGxpc3QgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGxXaGVyZShkYiwgc3RvcmUsIGZpZWxkX25hbWUsIG9wLCB2YWx1ZSwgb3AyLCB2YWx1ZTIpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihkYikgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkYi5mcm9tKHN0b3JlKS53aGVyZShmaWVsZF9uYW1lLCBvcCwgdmFsdWUsIG9wMiwgdmFsdWUyKS5saXN0KCkudGhlbihmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobGlzdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgcXVlcnlpbmcgZGIgJytkYi5nZXROYW1lKCkrJy4gJytleC5uYW1lKyc6ICcrZXgubWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGVudHJpZXMgd2hlcmUgYSBjZXJ0YWluIGZpZWxkIGlzIGVxdWFsIHRvIGEgY2VydGFpbiB2YWx1ZS5cbiAgICAgKiBJbXBvcnRhbnQ6IHRoZSBmaWVsZCBtdXN0IGJlIGFuIGluZGV4LlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIGRiICAgICAgICAgREIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHN0b3JlICAgICAgTmFtZSBvZiB0aGUgc3RvcmUgdG8gZ2V0IHRoZSBlbnRyaWVzIGZyb20uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgZmllbGRfbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB2YWx1ZSAgICAgIFZhbHVlIHRoZSBmaWVsZCBzaG91bGQgYmUgZXF1YWwgdG8uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGxpc3QgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGxXaGVyZUVxdWFsKGRiLCBzdG9yZSwgZmllbGRfbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihkYikgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkYi5mcm9tKHN0b3JlKS53aGVyZShmaWVsZF9uYW1lLCAnPScsIHZhbHVlKS5saXN0KCkudGhlbihmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobGlzdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgZ2V0dGluZyB3aGVyZSBlcXVhbCBmcm9tIGRiICcrZGIuZ2V0TmFtZSgpKycuICcrZXgubmFtZSsnOiAnK2V4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhbiBvcGVyYXRpb24gd2l0aCBldmVyeSBlbnRyeSBpbiBhIGNlcnRhaW4gc3RvcmUuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgIGRiICAgICAgIERCIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgc3RvcmUgICAgTmFtZSBvZiB0aGUgc3RvcmUgdG8gZ2V0IHRoZSBlbnRyaWVzIGZyb20uXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBlYWNoIGVudHJ5LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHRoZSBvcGVyYXRpb24gaGFzIGJlZW4gYXBwbGllZCB0byBhbGwgZW50cmllcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsRWFjaChkYiwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgY2FsbERCRnVuY3Rpb24oZGIsICd2YWx1ZXMnLCBzdG9yZSwgdW5kZWZpbmVkLCA5OTk5OTk5OSkudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbnRyaWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZW50cmllcyBtYXRjaGluZyBjZXJ0YWluIGNvbmRpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICBkYiAgICAgIERCIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBzdG9yZSAgIE5hbWUgb2YgdGhlIHN0b3JlIHRvIGdldCB0aGUgZW50cmllcyBmcm9tLlxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgIHdoZXJlICAgQXJyYXkgb2Ygd2hlcmUgY29uZGl0aW9ucywgc2VlIGFwcGx5V2hlcmUuXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgb3JkZXIgICBUaGUga2V5IHRvIG9yZGVyIG9uLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHJldmVyc2UgV2hldGhlciB0byByZXZlcnNlIHRoZSBvcmRlci5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBsaW1pdCAgIFRoZSBudW1iZXIgb2YgcmVzdWx0IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvUXVlcnkoZGIsIHN0b3JlLCB3aGVyZSwgb3JkZXIsIHJldmVyc2UsIGxpbWl0KSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICBxdWVyeTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihkYikgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IGRiLmZyb20oc3RvcmUpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gYXBwbHlXaGVyZShxdWVyeSwgd2hlcmUpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gYXBwbHlPcmRlcihxdWVyeSwgb3JkZXIsIHJldmVyc2UpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5Lmxpc3QobGltaXQpLnRoZW4oZnVuY3Rpb24obGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGxpc3QpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIHF1ZXJ5aW5nICcgKyBzdG9yZSArICcgb24gJyArIGRiLmdldE5hbWUoKSArICcuICcgKyBleC5uYW1lICsgJzogJyArIGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBsaXN0IG9mIGVudHJpZXMgbWF0Y2hpbmcgY29uZGl0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIGRiICAgICAgREIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHN0b3JlICAgTmFtZSBvZiB0aGUgc3RvcmUgdG8gZ2V0IHRoZSBlbnRyaWVzIGZyb20uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgdmFsdWVzICBUaGUgdmFsdWVzIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICB3aGVyZSAgIEFuIGFycmF5IG9mIHdoZXJlKCkgcGFyYW1ldGVycy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvVXBkYXRlKGRiLCBzdG9yZSwgdmFsdWVzLCB3aGVyZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgcXVlcnk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZGIpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBkYi5mcm9tKHN0b3JlKTtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IGFwcGx5V2hlcmUocXVlcnksIHdoZXJlKTtcbiAgICAgICAgICAgICAgICBxdWVyeS5wYXRjaCh2YWx1ZXMpLnRoZW4oZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShjb3VudCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgcXVlcnlpbmcgJyArIHN0b3JlICsgJyBvbiAnICsgZGIuZ2V0TmFtZSgpICsgJy4gJyArIGV4Lm5hbWUgKyAnOiAnICsgZXgubWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBkYXRhYmFzZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgZGF0YWJhc2Ugb2JqZWN0cyBhcmUgY2FjaGVkIHN0YXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tREIjZ2V0REJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgICAgREIgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjaGVtYSAgREIgc2NoZW1hLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBEQiBvcHRpb25zLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBEQi5cbiAgICAgKi9cbiAgICBzZWxmLmdldERCID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGJJbnN0YW5jZXNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgICAgIHZhciBpc1NhZmFyaSA9ICFpb25pYy5QbGF0Zm9ybS5pc0lPUygpICYmICFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1NhZmFyaScpICE9IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA9PSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PSAtMTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgSURCT2JqZWN0U3RvcmUgPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIElEQk9iamVjdFN0b3JlLnByb3RvdHlwZS5jb3VudCA9PSAndW5kZWZpbmVkJyB8fCBpc1NhZmFyaSkge1xuICAgICAgICAgICAgICAgIC8vIEluZGV4ZWREQiBub3QgaW1wbGVtZW50ZWQgb3Igbm90IGZ1bGx5IGltcGxlbWVudGVkIChHYWxheHkgUzQgTWluaSkuIFVzZSBXZWJTUUwuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1lY2hhbmlzbXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZWNoYW5pc21zID0gWyd3ZWJzcWwnLCAnc3FsaXRlJywgJ2xvY2Fsc3RvcmFnZScsICdzZXNzaW9uc3RvcmFnZScsICd1c2VyZGF0YScsICdtZW1vcnknXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBvcHRpb25zLm1lY2hhbmlzbXMuaW5kZXhPZignaW5kZXhlZGRiJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZWNoYW5pc21zLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYiA9IG5ldyB5ZG4uZGIuU3RvcmFnZShuYW1lLCBzY2hlbWEsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBkYkluc3RhbmNlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXQgREIgbmFtZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gREIgbmFtZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBnZXROYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLmdldE5hbWUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldCBhbiBlbnRyeSBmcm9tIGEgc3RvcmUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmUgTmFtZSBvZiB0aGUgc3RvcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gIGlkICAgIEVudHJ5J3MgaWRlbnRpZmllciAocHJpbWFyeSBrZXkgLyBrZXlQYXRoKS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBlbnRyeSBpcyByZXRyaWV2ZWQuIFJlc29sdmUgcGFyYW06IERCIGVudHJ5IChvYmplY3QpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oc3RvcmUsIGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsREJGdW5jdGlvbihkYiwgJ2dldCcsIHN0b3JlLCBpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXQgYWxsIHRoZSBlbnRyaWVzIGZyb20gYSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdG9yZSBOYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBlbnRyaWVzIGFyZSByZXRyaWV2ZWQuIFJlc29sdmUgcGFyYW06IERCIGVudHJpZXMgKGFycmF5KS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBnZXRBbGw6IGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsREJGdW5jdGlvbihkYiwgJ3ZhbHVlcycsIHN0b3JlLCB1bmRlZmluZWQsIDk5OTk5OTk5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiBhIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlIE5hbWUgb2YgdGhlIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFt3aGVyZV0gQXJyYXkgb2Ygd2hlcmUgY29uZGl0aW9ucywgc2VlIGFwcGx5V2hlcmUuXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY291bnQgaXMgZG9uZS4gUmVzb2x2ZSBwYXJhbTogbnVtYmVyIG9mIGVudHJpZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY291bnQ6IGZ1bmN0aW9uKHN0b3JlLCB3aGVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbENvdW50KGRiLCBzdG9yZSwgd2hlcmUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQWRkIGFuIGVudHJ5IHRvIGEgc3RvcmUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmUgTmFtZSBvZiB0aGUgc3RvcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIE9iamVjdCB0byBzdG9yZS4gUHJpbWFyeSBrZXkgKGtleVBhdGgpIGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SURiS2V5fSBpZCBUaGUga2V5IHdoZW4gbmVlZGVkLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJ5IGlzIGluc2VydGVkLiBSZXNvbHZlIHBhcmFtOiBuZXcgZW50cnkncyBwcmltYXJ5IGtleS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uKHN0b3JlLCB2YWx1ZSwgaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxEQkZ1bmN0aW9uKGRiLCAncHV0Jywgc3RvcmUsIHZhbHVlLCBpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBZGQgYW4gZW50cnkgdG8gYSBzdG9yZSwgcmV0dXJuaW5nIGEgc3luY2hyb25vdXMgdmFsdWUuXG4gICAgICAgICAgICAgICAgICogUGxlYXNlIHVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgaWYgc3luY2hyb25vdXMgaXMgYSBtdXN0LCB5b3Ugc2hvdWxkIGFsd2F5cyB1c2UgJG1tREIjaW5zZXJ0LlxuICAgICAgICAgICAgICAgICAqIFRha2UgaW50byBhY2NvdW50IHRoYXQgdGhlIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgQkVGT1JFIHRoZSB2YWx1ZSBpcyBhY3R1YWxseSBzdG9yZWQuIFRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgICAgICAgICAgICAgKiBib29sZWFuIHJldHVybmVkIG9ubHkgaW5kaWNhdGVzIGlmIGl0IGhhcyBwYXNzZWQgdGhlIGZpcnN0IHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmUgTmFtZSBvZiB0aGUgc3RvcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIE9iamVjdCB0byBzdG9yZS4gUHJpbWFyeSBrZXkgKGtleVBhdGgpIGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIGRhdGEgdG8gaW5zZXJ0IGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuIFJldHVybmluZyB0cnVlIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICBkYXRhIGhhcyBiZWVuIHN0b3JlZCwgdGhpcyBmdW5jdGlvbiBjYW4gcmV0dXJuIHRydWUgYnV0IHRoZSBpbnNlcnRpb24gY2FuIHN0aWxsIGZhaWwuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5zZXJ0U3luYzogZnVuY3Rpb24oc3RvcmUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5wdXQoc3RvcmUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciBleGVjdXRpbmcgZnVuY3Rpb24gc3luYyBwdXQgdG8gREIgJytkYi5nZXROYW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoZXgubmFtZSsnOiAnK2V4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUXVlcnkgdGhlIGRhdGFiYXNlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlIE5hbWUgb2YgdGhlIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFt3aGVyZV0gQXJyYXkgb2Ygd2hlcmUgY29uZGl0aW9ucywgc2VlIGFwcGx5V2hlcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcmRlcl0gVGhlIGtleSB0byBzb3J0IHRoZSByZXN1bHRzIHdpdGguXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbcmV2ZXJzZT1mYWxzZV0gV2hldGhlciB0byByZXZlcnNlIHRoZSByZXN1bHRzLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIFRoZSBudW1iZXIgb2YgcmVzdWx0cyB0byByZXR1cm4uXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIGVudHJpZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcXVlcnk6IGZ1bmN0aW9uKHN0b3JlLCB3aGVyZSwgb3JkZXIsIHJldmVyc2UsIGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb1F1ZXJ5KGRiLCBzdG9yZSwgd2hlcmUsIG9yZGVyLCByZXZlcnNlLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGFuIGVudHJ5IGZyb20gYSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdG9yZSBOYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSAgaWQgICAgRW50cnkncyBpZGVudGlmaWVyIChwcmltYXJ5IGtleSAvIGtleVBhdGgpLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJ5IGlzIGRlbGV0ZWQuIFJlc29sdmUgcGFyYW06IG51bWJlciBvZiBlbnRyaWVzIGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihzdG9yZSwgaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxEQkZ1bmN0aW9uKGRiLCAncmVtb3ZlJywgc3RvcmUsIGlkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYWxsIGVudHJpZXMgZnJvbSBhIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlIE5hbWUgb2YgdGhlIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJpZXMgYXJlIGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbihzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbERCRnVuY3Rpb24oZGIsICdjbGVhcicsIHN0b3JlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVwZGF0ZSByZWNvcmRzIG1hdGNoaW5nLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlIE5hbWUgb2YgdGhlIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW3doZXJlXSBBcnJheSBvZiB3aGVyZSBjb25kaXRpb25zLCBzZWUgYXBwbHlXaGVyZS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oc3RvcmUsIHZhbHVlcywgd2hlcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvVXBkYXRlKGRiLCBzdG9yZSwgdmFsdWVzLCB3aGVyZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGVudHJpZXMgd2hlcmUgYSBmaWVsZCBtYXRjaCBjZXJ0YWluIGNvbmRpdGlvbnMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmUgICAgICBOYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGRfbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3AgICAgICAgICBGaXJzdCBvcGVyYXRvciB0byBhcHBseSB0byB0aGUgZmllbGQuIDwsIDw9LCA9LCA+LCA+PSwgXiAoc3RhcnQgd2l0aCkuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gIHZhbHVlICAgICAgVmFsdWUgdG8gY29tcGFyZSB1c2luZyB0aGUgZmlyc3Qgb3BlcmF0b3IuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wMiAgICAgICAgU2Vjb25kIG9wZXJhdG9yIHRvIGFwcGx5IHRvIHRoZSBmaWVsZC4gT3B0aW9uYWwuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gIHZhbHVlMiAgICAgVmFsdWUgdG8gY29tcGFyZSB1c2luZyB0aGUgc2Vjb25kIG9wZXJhdG9yLiBPcHRpb25hbC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJpZXMgYXJlIHJldHJpZXZlZC4gUmVzb2x2ZSBwYXJhbTogZW50cmllcyAoYXJyYXkpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHdoZXJlOiBmdW5jdGlvbihzdG9yZSwgZmllbGRfbmFtZSwgb3AsIHZhbHVlLCBvcDIsIHZhbHVlMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdoZXJlKGRiLCBzdG9yZSwgZmllbGRfbmFtZSwgb3AsIHZhbHVlLCBvcDIsIHZhbHVlMik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGVudHJpZXMgd2hlcmUgYSBmaWVsZCBpcyBlcXVhbCB0byBhIGNlcnRhaW4gdmFsdWUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmUgICAgICBOYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGRfbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSAgdmFsdWUgICAgICBWYWx1ZSB0byBjb21wYXJlIHRvIHRoZSBmaWVsZC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJpZXMgYXJlIHJldHJpZXZlZC4gUmVzb2x2ZSBwYXJhbTogZW50cmllcyAoYXJyYXkpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHdoZXJlRXF1YWw6IGZ1bmN0aW9uKHN0b3JlLCBmaWVsZF9uYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdoZXJlRXF1YWwoZGIsIHN0b3JlLCBmaWVsZF9uYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDYWxsIGEgZnVuY3Rpb24gd2l0aCBlYWNoIG9mIHRoZSBlbnRyaWVzIGZyb20gYSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdG9yZSAgICAgIE5hbWUgb2YgdGhlIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBlYWNoIGVudHJ5LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBhbGwgZW50cmllcy4gTm8gcmVzb2x2ZSBwYXJhbXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24oc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsRWFjaChkYiwgc3RvcmUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENsb3NlIHRoZSBkYXRhYmFzZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGRiID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2FsbCBhIGNhbGxiYWNrIG9uY2UgREIgaXMgcmVhZHkuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBjYWxsLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG9uUmVhZHk6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLm9uUmVhZHkoY2IpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogR2V0IHN0b3JhZ2UgdHlwZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RvcmFnZSB0eXBlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRiSW5zdGFuY2VzW25hbWVdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBEQi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1EQiNkZWxldGVEQlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSAgIERCIG5hbWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIERCIGlzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgc2VsZi5kZWxldGVEQiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICBmdW5jdGlvbiBkZWxldGVEQigpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkYkluc3RhbmNlc1tuYW1lXTtcbiAgICAgICAgICAgICRxLndoZW4oeWRuLmRiLmRlbGV0ZURhdGFiYXNlKG5hbWUpKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRiSW5zdGFuY2VzW25hbWVdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgREIgaW5zdGFuY2UuIFdhaXQgZm9yIGl0IHRvIGJlIHJlYWR5IGJlZm9yZSBkZWxldGluZyB0aGUgREIuXG4gICAgICAgICAgICBkYkluc3RhbmNlc1tuYW1lXS5vblJlYWR5KGRlbGV0ZURCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZURCKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tRW11bGF0b3JNYW5hZ2VyXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzZXJ2aWNlIGhhbmRsZXMgdGhlIGVtdWxhdGlvbiBvZiBDb3Jkb3ZhIHBsdWdpbnMgaW4gb3RoZXIgZW52aXJvbm1lbnRzIGxpa2UgYnJvd3Nlci5cbiAqL1xuLmZhY3RvcnkoJyRtbUVtdWxhdG9yTWFuYWdlcicsIGZ1bmN0aW9uKCRsb2csICRxLCAkaHR0cCwgJG1tRlMsICR3aW5kb3cpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1FbXVsYXRvck1hbmFnZXInKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBIVE1MIEFQSSB0byBzaW11bGF0ZSBDb3Jkb3ZhIEFQSXMuIFJlc2VydmVkIGZvciBjb3JlIHVzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1FbXVsYXRvck1hbmFnZXIjbG9hZEhUTUxBUElcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIEFQSSBpcyBsb2FkZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYubG9hZEhUTUxBUEkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnU3RvcCBsb2FkaW5nIEhUTUwgQVBJLCBpdCB3YXMgYWxyZWFkeSBsb2FkZWQgb3IgdGhlIGVudmlyb25tZW50IGRvZXNuXFwndCBuZWVkIGl0LicpO1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICBiYXNlUGF0aDtcblxuICAgICAgICAkbG9nLmRlYnVnKCdMb2FkaW5nIEhUTUwgQVBJLicpO1xuXG4gICAgICAgIC8vIEZpbGUgQVBJLlxuICAgICAgICAkd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtICA9ICR3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0gfHwgJHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbTtcbiAgICAgICAgJHdpbmRvdy5yZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMID0gJHdpbmRvdy5yZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMIHx8wqAkd2luZG93LndlYmtpdFJlc29sdmVMb2NhbEZpbGVTeXN0ZW1VUkw7XG5cbiAgICAgICAgJHdpbmRvdy5Mb2NhbEZpbGVTeXN0ZW0gPSB7XG4gICAgICAgICAgICBQRVJTSVNURU5UOiAxXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRmlsZVRyYW5zZmVyIEFQSS5cbiAgICAgICAgJHdpbmRvdy5GaWxlVHJhbnNmZXIgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgICAgICR3aW5kb3cuRmlsZVRyYW5zZmVyLnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uKHVybCwgZmlsZVBhdGgsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgJGh0dHAuZ2V0KHVybCwge3Jlc3BvbnNlVHlwZTogJ2Jsb2InfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGgucmVwbGFjZShiYXNlUGF0aCwgJycpOyAvLyBSZW1vdmUgYmFzZVBhdGggZnJvbSB0aGUgZmlsZVBhdGguXG4gICAgICAgICAgICAgICAgICAgICRtbUZTLndyaXRlRmlsZShmaWxlUGF0aCwgZGF0YS5kYXRhKS50aGVuKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29yZG92YSBaSVAgcGx1Z2luLlxuICAgICAgICAkd2luZG93LnppcCA9IHtcbiAgICAgICAgICAgIHVuemlwOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uLCBjYWxsYmFjaywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBiYXNlUGF0aCBmcm9tIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uLlxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKGJhc2VQYXRoLCAnJyk7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbi5yZXBsYWNlKGJhc2VQYXRoLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAkbW1GUy5yZWFkRmlsZShzb3VyY2UsICRtbUZTLkZPUk1BVEFSUkFZQlVGRkVSKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHppcCA9IG5ldyBKU1ppcChkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHppcC5maWxlcywgZnVuY3Rpb24oZmlsZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVwYXRoID0gJG1tRlMuY29uY2F0ZW5hdGVQYXRocyhkZXN0aW5hdGlvbiwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlLmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgYSBmaWxlLiBHZXQgdGhlIG1pbWV0eXBlIGFuZCB3cml0ZSB0aGUgZmlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJG1tRlMuZ2V0TWltZVR5cGUoJG1tRlMuZ2V0RmlsZUV4dGVuc2lvbihuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GUy53cml0ZUZpbGUoZmlsZXBhdGgsIG5ldyBCbG9iKFtmaWxlLmFzQXJyYXlCdWZmZXIoKV0sIHt0eXBlOiB0eXBlfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBhIGZvbGRlciwgY3JlYXRlIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GUy5jcmVhdGVEaXIoZmlsZXBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yLlxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygtMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQHRvZG86IEltcGxlbWVudCBGaWxlVHJhbnNmZXIudXBsb2FkLlxuXG4gICAgICAgIC8vIFJlcXVlc3QgNTAwTUIuXG4gICAgICAgICR3aW5kb3cud2Via2l0U3RvcmFnZUluZm8ucmVxdWVzdFF1b3RhKFBFUlNJU1RFTlQsIDUwMCAqIDEwMjQgKiAxMDI0LCBmdW5jdGlvbihncmFudGVkKSB7XG4gICAgICAgICAgICAkd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKFBFUlNJU1RFTlQsIGdyYW50ZWQsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgYmFzZVBhdGggPSBlbnRyeS5yb290LnRvVVJMKCk7XG4gICAgICAgICAgICAgICAgJG1tRlMuc2V0SFRNTEJhc2VQYXRoKGJhc2VQYXRoKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICB9LCBkZWZlcnJlZC5yZWplY3QpO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tSW5pdERlbGVnYXRlUHJvdmlkZXIsIG1tSW5pdERlbGVnYXRlTWF4QWRkb25Qcmlvcml0eSkge1xuICAgIGlmICghaW9uaWMuUGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcbiAgICAgICAgJG1tSW5pdERlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcm9jZXNzKCdtbUVtdWxhdG9yJywgJyRtbUVtdWxhdG9yTWFuYWdlci5sb2FkSFRNTEFQSScsXG4gICAgICAgICAgICAgICAgbW1Jbml0RGVsZWdhdGVNYXhBZGRvblByaW9yaXR5ICsgNTAwLCB0cnVlKTtcbiAgICB9XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi5jb25zdGFudCgnbW1Db3JlRXZlbnRLZXlib2FyZFNob3cnLCAna2V5Ym9hcmRfc2hvdycpXG4uY29uc3RhbnQoJ21tQ29yZUV2ZW50S2V5Ym9hcmRIaWRlJywgJ2tleWJvYXJkX2hpZGUnKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudFNlc3Npb25FeHBpcmVkJywgJ3Nlc3Npb25fZXhwaXJlZCcpXG4uY29uc3RhbnQoJ21tQ29yZUV2ZW50TG9naW4nLCAnbG9naW4nKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudExvZ291dCcsICdsb2dvdXQnKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudExhbmd1YWdlQ2hhbmdlZCcsICdsYW5ndWFnZV9jaGFuZ2VkJylcbi5jb25zdGFudCgnbW1Db3JlRXZlbnRTaXRlQWRkZWQnLCAnc2l0ZV9hZGRlZCcpXG4uY29uc3RhbnQoJ21tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQnLCAnc2l0ZV91cGRhdGVkJylcbi5jb25zdGFudCgnbW1Db3JlRXZlbnRTaXRlRGVsZXRlZCcsICdzaXRlX2RlbGV0ZWQnKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudFF1ZXVlRW1wdHknLCAnZmlsZXBvb2xfcXVldWVfZW1wdHknKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudENvbXBsZXRpb25Nb2R1bGVWaWV3ZWQnLCAnY29tcGxldGlvbl9tb2R1bGVfdmlld2VkJylcbi5jb25zdGFudCgnbW1Db3JlRXZlbnRVc2VyRGVsZXRlZCcsICd1c2VyX2RlbGV0ZWQnKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkJywgJ2ZpbGVwb29sX3BhY2thZ2Vfc3RhdHVzX2NoYW5nZWQnKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudFNlY3Rpb25TdGF0dXNDaGFuZ2VkJywgJ3NlY3Rpb25fc3RhdHVzX2NoYW5nZWQnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gc2VuZCBhbmQgbGlzdGVuIHRvIGV2ZW50cy5cbiAqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tRXZlbnRzXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzZXJ2aWNlIGFsbG93cyBzZW5kaW5nIGFuZCBsaXN0ZW5pbmcgdG8gZXZlbnRzIGluIHRoZSBNb29kbGUgTW9iaWxlIGFwcC5cbiAqL1xuLmZhY3RvcnkoJyRtbUV2ZW50cycsIGZ1bmN0aW9uKCRsb2csIG1kNSkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUV2ZW50cycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgb2JzZXJ2ZXJzID0ge30sXG4gICAgICAgIHVuaXF1ZUV2ZW50cyA9IHt9LFxuICAgICAgICB1bmlxdWVFdmVudHNEYXRhID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIG9ic2VydmVyIGZvciBhIGNlcnRhaW4gZXZlbnQuXG4gICAgICogVG8gZGVyZWdpc3RlciB0aGUgZXZlbnQ6XG4gICAgICogdmFyIG9ic2VydmVyID0gJG1tRXZlbnRzLm9uKCdzb21ldGhpbmcnLCBteUNhbGxCYWNrKTtcbiAgICAgKiBvYnNlcnZlci5vZmYoKTtcbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1FdmVudHMjb25cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnROYW1lICBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG8uXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxCYWNrICAgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgT2JqZWN0IHRvIGRlcmVnaXN0ZXIgdGhlIG9ic2VydmVyLiBVbmRlZmluZWQgaWYgaXQncyBhbiBhbHJlYWR5IHRyaWdnZXJlZCB1bmlxdWUgZXZlbnQuXG4gICAgICovXG4gICAgc2VsZi5vbiA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbEJhY2spIHtcblxuICAgICAgICAvLyBJZiBpdCdzIGEgdW5pcXVlIGV2ZW50IGFuZCBoYXMgYmVlbiB0cmlnZ2VyZWQgYWxyZWFkeSwgY2FsbCB0aGUgY2FsbEJhY2suXG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gc3RvcmUgdGhlIG9ic2VydmVyIGJlY2F1c2UgdGhlIGV2ZW50IHdvbid0IGJlIHRyaWdnZXJlZCBhZ2Fpbi5cbiAgICAgICAgaWYgKHVuaXF1ZUV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBjYWxsQmFjayh1bmlxdWVFdmVudHNEYXRhW2V2ZW50TmFtZV0pO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGEgZmFrZSBvYnNlcnZlciB0byBwcmV2ZW50IGVycm9ycy5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IC0xLFxuICAgICAgICAgICAgICAgIG9mZjogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvYnNlcnZlcklEO1xuXG4gICAgICAgIGlmICh0eXBlb2Yob2JzZXJ2ZXJzW2V2ZW50TmFtZV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzW2V2ZW50TmFtZV0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0eXBlb2Yob2JzZXJ2ZXJJRCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlSUQgPSBtZDUuY3JlYXRlSGFzaChNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihvYnNlcnZlcnNbZXZlbnROYW1lXVtjYW5kaWRhdGVJRF0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9ic2VydmVySUQgPSBjYW5kaWRhdGVJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAkbG9nLmRlYnVnKCdPYnNlcnZlciAnICsgb2JzZXJ2ZXJJRCArICcgbGlzdGVuaW5nIHRvIGV2ZW50ICcrZXZlbnROYW1lKTtcblxuICAgICAgICBvYnNlcnZlcnNbZXZlbnROYW1lXVtvYnNlcnZlcklEXSA9IGNhbGxCYWNrO1xuXG4gICAgICAgIC8vIENyZWF0ZSBvYnNlcnZlciBvYmplY3QgdG8gZGVyZWdpc3RlciB0aGUgbGlzdGVuZXIuXG4gICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIGlkOiBvYnNlcnZlcklELFxuICAgICAgICAgICAgb2ZmOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdEaXNhYmxlIG9ic2VydmVyICcgKyBvYnNlcnZlcklEICsgJyBmb3IgZXZlbnQgJytldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYnNlcnZlcnNbZXZlbnROYW1lXVtvYnNlcnZlcklEXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhbiBldmVudCwgbm90aWZ5aW5nIGFsbCB0aGUgb2JzZXJ2ZXJzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUV2ZW50cyN0cmlnZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyaWdnZXIuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gIGRhdGEgIERhdGEgdG8gcGFzcyB0byB0aGUgb2JzZXJ2ZXJzLlxuICAgICAqL1xuICAgIHNlbGYudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICAkbG9nLmRlYnVnKCdFdmVudCAnICsgZXZlbnROYW1lICsgJyB0cmlnZ2VyZWQuJyk7XG4gICAgICAgIHZhciBhZmZlY3RlZCA9IG9ic2VydmVyc1tldmVudE5hbWVdO1xuICAgICAgICBmb3IgKHZhciBvYnNlcnZlck5hbWUgaW4gYWZmZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoYWZmZWN0ZWRbb2JzZXJ2ZXJOYW1lXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZFtvYnNlcnZlck5hbWVdKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgdW5pcXVlIGV2ZW50LCBub3RpZnlpbmcgYWxsIHRoZSBvYnNlcnZlcnMuIElmIHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIHRyaWdnZXJlZCwgZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRXZlbnRzI3RyaWdnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJpZ2dlci5cbiAgICAgKiBAcGFyYW0ge01peGVkfSAgZGF0YSAgRGF0YSB0byBwYXNzIHRvIHRoZSBvYnNlcnZlcnMuXG4gICAgICovXG4gICAgc2VsZi50cmlnZ2VyVW5pcXVlID0gZnVuY3Rpb24oZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgIGlmICh1bmlxdWVFdmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVW5pcXVlIGV2ZW50ICcgKyBldmVudE5hbWUgKyAnIGlnbm9yZWQgYmVjYXVzZSBpdCB3YXMgYWxyZWFkeSB0cmlnZ2VyZWQuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdVbmlxdWUgZXZlbnQgJyArIGV2ZW50TmFtZSArICcgdHJpZ2dlcmVkLicpO1xuICAgICAgICAgICAgdW5pcXVlRXZlbnRzW2V2ZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgdW5pcXVlRXZlbnRzRGF0YVtldmVudE5hbWVdID0gZGF0YTtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZCA9IG9ic2VydmVyc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGFmZmVjdGVkLCBmdW5jdGlvbihjYWxsQmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbEJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEJhY2soZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi5jb25zdGFudCgnbW1GaWxlcG9vbFF1ZXVlUHJvY2Vzc0ludGVydmFsJywgMClcbi5jb25zdGFudCgnbW1GaWxlcG9vbEZvbGRlcicsICdmaWxlcG9vbCcpXG4uY29uc3RhbnQoJ21tRmlsZXBvb2xTdG9yZScsICdmaWxlcG9vbCcpXG4uY29uc3RhbnQoJ21tRmlsZXBvb2xRdWV1ZVN0b3JlJywgJ2ZpbGVzX3F1ZXVlJylcbi5jb25zdGFudCgnbW1GaWxlcG9vbExpbmtzU3RvcmUnLCAnZmlsZXNfbGlua3MnKVxuLmNvbnN0YW50KCdtbUZpbGVwb29sUGFja2FnZXNTdG9yZScsICdmaWxlcG9vbF9wYWNrYWdlcycpXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQXBwUHJvdmlkZXIsICRtbVNpdGVzRmFjdG9yeVByb3ZpZGVyLCBtbUZpbGVwb29sU3RvcmUsIG1tRmlsZXBvb2xMaW5rc1N0b3JlLCBtbUZpbGVwb29sUXVldWVTdG9yZSxcbiAgICAgICAgICAgIG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlKSB7XG4gICAgdmFyIHNpdGVTdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEZpbGUgc3RvcmUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRWFjaCBlbnRyeSBzaG91bGQgY29udGFpbjpcbiAgICAgICAgICAgIC8vIC0gZmlsZUlkOiBBIGhhc2ggb2YgdGhlIGZpbGUgaW5mby5cbiAgICAgICAgICAgIC8vIC0gdXJsOiBVUkwgdG8gZG93bmxvYWQgdGhlIGZpbGUuXG4gICAgICAgICAgICAvLyAtIG1vZGlmaWVkOiBUaGUgdGltZSBhdCB3aGljaCB0aGUgZmlsZSB3YXMgbGFzdCBkb3dubG9hZGVkLlxuICAgICAgICAgICAgLy8gLSBzdGFsZTogV2hlbiB0cnVlLCBpdCBtZWFucyB0aGF0IHRoZSBmaWxlIHNob3VsZCBiZSByZWRvd25sb2FkZWQuXG4gICAgICAgICAgICAvLyAtIGV0YWc6IFN0b3JlIHRoZSBFVEFHIGNvZGUgb2YgdGhlIGZpbGUuXG4gICAgICAgICAgICBuYW1lOiBtbUZpbGVwb29sU3RvcmUsXG4gICAgICAgICAgICBrZXlQYXRoOiAnZmlsZUlkJyxcbiAgICAgICAgICAgIGluZGV4ZXM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEFzc29jaWF0aW9ucyBiZXR3ZWVuIGZpbGVzIGFuZCBjb21wb25lbnRzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVhY2ggZW50cnkgc2hvdWxkIGNvbnRhaW46XG4gICAgICAgICAgICAvLyAtIGZpbGVJZDogSGFzaCB1c2VkIGluIHRoZSBmaWxlIHN0b3JlLlxuICAgICAgICAgICAgLy8gLSBjb21wb25lbnQ6IFRoZSBjb21wb25lbnQgbmFtZSAoZS5nLiBtbWFNb2RQYWdlKS5cbiAgICAgICAgICAgIC8vIC0gY29tcG9uZW50SWQ6IEFuIElEIHRoYXQgY2FuIGJlIHVzZWQgYnkgdGhlIGNvbXBvbmVudC4gLTEgd2hlbiBub3QgcHJvdmlkZWQuXG4gICAgICAgICAgICBuYW1lOiBtbUZpbGVwb29sTGlua3NTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6IFsnZmlsZUlkJywgJ2NvbXBvbmVudCcsICdjb21wb25lbnRJZCddLFxuICAgICAgICAgICAgaW5kZXhlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZpbGVJZCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb21wb25lbnQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgdXNpbmcgY29tcG91bmQgaW5kZXhlcyBiZWNhdXNlIHRoZXkgc2VlbSB0byBoYXZlIGlzc3VlcyB3aXRoIHdoZXJlKCkuXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb21wb25lbnRBbmRJZCcsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW29iai5jb21wb25lbnQsIG9iai5jb21wb25lbnRJZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBhY2thZ2VzIHN0b3JlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVhY2ggZW50cnkgc2hvdWxkIGNvbnRhaW46XG4gICAgICAgICAgICAvLyAtIGlkOiBUaGUgcGFja2FnZSBJRC4gU2VlIHtAbGluayAkbW1GaWxlcG9vbCNnZXRQYWNrYWdlSWR9XG4gICAgICAgICAgICAvLyAtIGNvbXBvbmVudDogUGFja2FnZSdzIGNvbXBvbmVudC5cbiAgICAgICAgICAgIC8vIC0gY29tcG9uZW50SWQ6IFBhY2thZ2UncyBjb21wb25lbnRJZC5cbiAgICAgICAgICAgIC8vIC0gc3RhdHVzOiBUaGUgcGFja2FnZSBzdGF0dXM6IG1tQ29yZURvd25sb2FkZWQsIG1tQ29yZURvd25sb2FkaW5nLCBldGMuXG4gICAgICAgICAgICAvLyAtIHByZXZpb3VzOiAob3B0aW9uYWwpIFRoZSBwYWNrYWdlIHByZXZpb3VzIHN0YXR1cy5cbiAgICAgICAgICAgIC8vIC0gcmV2aXNpb246IFRoZSBwYWNrYWdlIHJldmlzaW9uLlxuICAgICAgICAgICAgLy8gLSB0aW1lbW9kaWZpZWQ6IFRoZSBwYWNrYWdlIHRpbWVtb2RpZmllZC5cbiAgICAgICAgICAgIC8vIC0gdXBkYXRlZDogV2hlbiB3YXMgdGhlIGVudHJ5IHVwZGF0ZWQgZm9yIHRoZSBsYXN0IHRpbWUuXG4gICAgICAgICAgICBuYW1lOiBtbUZpbGVwb29sUGFja2FnZXNTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCcsXG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvbXBvbmVudElkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3N0YXR1cycsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgXTtcbiAgICB2YXIgYXBwU3RvcmVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyBGaWxlcyBxdWV1ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBFYWNoIGVudHJ5IHNob3VsZCBjb250YWluOlxuICAgICAgICAgICAgLy8gLSBzaXRlSWQ6IFRoZSBzaXRlIElELlxuICAgICAgICAgICAgLy8gLSBmaWxlSWQ6IEEgaGFzaCBvZiB0aGUgZmlsZSBpbmZvLlxuICAgICAgICAgICAgLy8gLSB1cmw6IFVSTCB0byBkb3dubG9hZCB0aGUgZmlsZS5cbiAgICAgICAgICAgIC8vIC0gYWRkZWQ6IFRpbWVzdGFtcCAoaW4gbWlsbGlzZWNvbmRzKSBhdCB3aGljaCB0aGUgZmlsZSB3YXMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgLy8gLSBwcmlvcml0eTogSW5kaWNhdGVzIHdoaWNoIGZpbGVzIHNob3VsZCBiZSB0cmVhdGVkIGZpcnN0LiBNYXhpbXVtIHZhbHVlIGlzIDk5OS5cbiAgICAgICAgICAgIC8vIC0gbGlua3M6IEFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBjb21wb25lbnQgYW5kIElEIHRvIGNyZWF0ZSBsaW5rcyBvbmNlIHRoZSBmaWxlIGhhcyBiZWVuIHByb2Nlc3NlZC5cbiAgICAgICAgICAgIG5hbWU6IG1tRmlsZXBvb2xRdWV1ZVN0b3JlLFxuICAgICAgICAgICAga2V5UGF0aDogWydzaXRlSWQnLCAnZmlsZUlkJ10sXG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2l0ZUlkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NvcnRvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGVzIGFuIGluZGV4IHRvIHNvcnQgdGhlIHF1ZXVlIGl0ZW1zIGJ5IHByaW9yaXR5LCBzb3J0IGlzIGFzY2VuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvbGRlc3QgYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIG1vc3QgaW1wb3J0YW50IG9uZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYWRkaXRpb25hbCBwcmlvcml0eSBhcmd1bWVudCBhbGxvd3MgdG8gYnVtcCBhbnkgcXVldWUgaXRlbSBvbiB0b3Agb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGluZGV4IHdpbGwgbG9vayBhcyBmb2xsb3c6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBbOTk5IC0gcHJpb3JpdHldICsgXCItXCIgKyB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIFwiOTk5LTE0MzE0OTEwODY5MTNcIjogaXRlbSB3aXRob3V0IHByaW9yaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgXCI5MDAtMTQzMTQ5MTA4NjkxM1wiOiBpdGVtIHdpdGggcHJpb3JpdHkgb2YgOTkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBcIjAwMC0xNDMxNDkxMDg2OTEzXCI6IGl0ZW0gd2l0aCBtYXggcHJpb3JpdHkuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0b3JkZXIgPSBwYXJzZUludChvYmouYWRkZWQsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9IDk5OSAtIE1hdGgubWF4KDAsIE1hdGgubWluKHBhcnNlSW50KG9iai5wcmlvcml0eSB8fCAwLCAxMCksIDk5OSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBcIjAwMFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0b3JkZXIgPSBcIlwiICsgc29ydG9yZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSBcIlwiICsgcHJpb3JpdHk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsIGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gcGFkZGluZy5zdWJzdHJpbmcoMCwgcGFkZGluZy5sZW5ndGggLSBwcmlvcml0eS5sZW5ndGgpICsgcHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0b3JkZXIgPSBwcmlvcml0eSArICctJyArIHNvcnRvcmRlcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRvcmRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIF07XG4gICAgJG1tQXBwUHJvdmlkZXIucmVnaXN0ZXJTdG9yZXMoYXBwU3RvcmVzKTtcbiAgICAkbW1TaXRlc0ZhY3RvcnlQcm92aWRlci5yZWdpc3RlclN0b3JlcyhzaXRlU3RvcmVzKTtcbn0pXG5cbi8qKlxuICogRmFjdG9yeSBmb3IgaGFuZGxpbmcgdGhlIGZpbGVzIGluIHRoZSBwb29sLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGZhY3RvcnlcbiAqIEBuYW1lICRtbUZpbGVwb29sXG4gKiBAdG9kbyBVc2UgdHJhbnNhY3Rpb25zIChlLmcuIHdoZW4gcXVlcnlpbmcsIHRoZW4gdXBkYXRpbmcpXG4gKiBAdG9kbyBTZXR0aW5nIGZpbGVzIGFzIHN0YWxlIGFmdGVyIGEgY2VydGFpbiB0aW1lXG4gKiBAdG9kbyBVc2UgRVRBR3NcbiAqIEB0b2RvIERvIG5vdCBkb3dubG9hZCBvbiBsaW1pdGVkIG5ldHdvcmtcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFRoaXMgZmFjdG9yeSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgZXh0ZXJuYWwgY29udGVudC5cbiAqXG4gKiBJdCB3aWxsIGFsd2F5cyB0cnkgdG8gZ2V0IGEgZmlsZSBmcm9tIHRoZSBmaWxlcG9vbCBhbmQgcmV0dXJuIGl0LCB3aGVuIHRoZSBmaWxlIGlzIG5vdFxuICogZm91bmQgaXQgd2lsbCBiZSBhZGRlZCB0byBhIHF1ZXVlIHRvIGJlIGRvd25sb2FkZWQgbGF0ZXIuIFRoZSB0d28gbWFpbiBnb2FscyBvZiB0aGlzXG4gKiBpcyB0byBrZWVwIHRoZSBjb250ZW50IGF2YWlsYWJsZSBvZmZsaW5lLCBhbmQgaW1wcm92ZSB0aGUgdXNlciBleHBlcmllbmNlIGJ5IGNhY2hpbmdcbiAqIHRoZSBjb250ZW50IGxvY2FsbHkuXG4gKlxuICogVGhlIGZpbGVwb29sIGhhcyBhIHZlcnkgbGltaXRlZCB1bmRlcnN0YW5kaW5nIG9mIHBsdWdpbmZpbGVzLCB5b3Ugc2hvdWxkIGFsd2F5cyBjYWxsXG4gKiB7QGxpbmsgJG1tVXRpbCNmaXhQbHVnaW5maWxlVVJMfSBwcmlvciB0byBwYXNzaW5nIHRoZSBVUkwuIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdG9cbiAqIGFsbG93IGZvciBhbnkgdHlwZSBvZiBVUkwgdG8gYmUgaGFuZGxlZCBoZXJlLiBXZSBjYW4gZG93bmxvYWQgYW5kIGNhY2hlIGNvbnRlbnRcbiAqIHRoYXQgaXMgbm90IHNlcnZlZCBieSBNb29kbGUuIFRoZSBvbmx5IGxpdHRsZSBoYW5kbGluZyBvZiBwbHVnaW5maWxlIGlzIGxvY2F0ZWQgaW5cbiAqIHtAbGluayAkbW1GaWxlcG9vbCNfZ2V0RmlsZUlkQnlVcmx9LlxuICovXG4uZmFjdG9yeSgnJG1tRmlsZXBvb2wnLCBmdW5jdGlvbigkcSwgJGxvZywgJHRpbWVvdXQsICRtbUFwcCwgJG1tRlMsICRtbVdTLCAkbW1TaXRlc01hbmFnZXIsICRtbUV2ZW50cywgbWQ1LCBtbUZpbGVwb29sU3RvcmUsXG4gICAgICAgIG1tRmlsZXBvb2xMaW5rc1N0b3JlLCBtbUZpbGVwb29sUXVldWVTdG9yZSwgbW1GaWxlcG9vbEZvbGRlciwgbW1GaWxlcG9vbFF1ZXVlUHJvY2Vzc0ludGVydmFsLCBtbUNvcmVFdmVudFF1ZXVlRW1wdHksXG4gICAgICAgIG1tQ29yZURvd25sb2FkZWQsIG1tQ29yZURvd25sb2FkaW5nLCBtbUNvcmVOb3REb3dubG9hZGVkLCBtbUNvcmVPdXRkYXRlZCwgbW1Db3JlTm90RG93bmxvYWRhYmxlLCBtbUZpbGVwb29sUGFja2FnZXNTdG9yZSxcbiAgICAgICAgbW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUZpbGVwb29sJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBleHRlbnNpb25SZWdleCA9IG5ldyBSZWdFeHAoJ15bYS16MC05XSskJyksXG4gICAgICAgIHRva2VuUmVnZXggPSBuZXcgUmVnRXhwKCcoXFxcXD98Jil0b2tlbj0oW0EtWmEtejAtOV0rKScpLFxuICAgICAgICBxdWV1ZVN0YXRlLFxuICAgICAgICB1cmxBdHRyaWJ1dGVzID0gW1xuICAgICAgICAgICAgdG9rZW5SZWdleCxcbiAgICAgICAgICAgIG5ldyBSZWdFeHAoJyhcXFxcP3wmKWZvcmNlZG93bmxvYWQ9WzAtMV0nKVxuICAgICAgICBdLFxuICAgICAgICByZXZpc2lvblJlZ2V4ID0gbmV3IFJlZ0V4cCgnL2NvbnRlbnQvKFswLTldKykvJyksXG4gICAgICAgIHF1ZXVlRGVmZXJyZWRzID0ge30sIC8vIFRvIGhhbmRsZSBmaWxlIGRvd25sb2FkcyB1c2luZyB0aGUgcXVldWUuXG4gICAgICAgIHBhY2thZ2VzUHJvbWlzZXMgPSB7fSwgLy8gVG8gcHJldmVudCBkb3dubG9hZGluZyBwYWNrYWdlcyB0d2ljZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICBmaWxlUHJvbWlzZXMgPSB7fTsgLy8gVG8gcHJldmVudCBkb3dubG9hZGluZyBmaWxlcyB0d2ljZSBhdCB0aGUgc2FtZSB0aW1lLlxuXG4gICAgLy8gUXVldWUgc3RhdHVzIGNvZGVzLlxuICAgIHZhciBRVUVVRV9SVU5OSU5HID0gJ21tRmlsZXBvb2w6UVVFVUVfUlVOTklORycsXG4gICAgICAgIFFVRVVFX1BBVVNFRCA9ICdtbUZpbGVwb29sOlFVRVVFX1BBVVNFRCc7XG5cbiAgICAvLyBFcnJvciBjb2Rlcy5cbiAgICB2YXIgRVJSX1FVRVVFX0lTX0VNUFRZID0gJ21tRmlsZXBvb2xFcnJvcjpFUlJfUVVFVUVfSVNfRU1QVFknLFxuICAgICAgICBFUlJfRlNfT1JfTkVUV09SS19VTkFWQUlMQUJMRSA9ICdtbUZpbGVwb29sRXJyb3I6RVJSX0ZTX09SX05FVFdPUktfVU5BVkFJTEFCTEUnLFxuICAgICAgICBFUlJfUVVFVUVfT05fUEFVU0UgPSAnbW1GaWxlcG9vbEVycm9yOkVSUl9RVUVVRV9PTl9QQVVTRSc7XG5cbiAgICAvKipcbiAgICAgKiBGaWxlcyBzdGF0ZXMuIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgY29yZSBjb25zdGFudHMgaW5zdGVhZDogbW1Db3JlRG93bmxvYWRlZCwgbW1Db3JlRG93bmxvYWRpbmcsIC4uLlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42XG4gICAgICovXG4gICAgc2VsZi5GSUxFRE9XTkxPQURFRCA9ICdkb3dubG9hZGVkJztcbiAgICBzZWxmLkZJTEVET1dOTE9BRElORyA9ICdkb3dubG9hZGluZyc7XG4gICAgc2VsZi5GSUxFTk9URE9XTkxPQURFRCA9ICdub3Rkb3dubG9hZGVkJztcbiAgICBzZWxmLkZJTEVPVVREQVRFRCA9ICdvdXRkYXRlZCc7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW50IHNpdGUgREIgZ2V0dGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNpdGVEYihzaXRlSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlRGIoc2l0ZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaW5rIGEgZmlsZSB3aXRoIGEgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19hZGRGaWxlTGlua1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCBUaGUgZmlsZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gbGluayB0aGUgZmlsZSB0by5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvbmVudElkXSBBbiBJRCB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIG9uIHN1Y2Nlc3MuIFJlamVjdGVkIG9uIGZhaWx1cmUuIEl0IGlzIGFkdmlzZWQgdG8gc2lsZW50bHkgaWdub3JlIGZhaWx1cmVzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9hZGRGaWxlTGluayA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRJZCA9IHNlbGYuX2ZpeENvbXBvbmVudElkKGNvbXBvbmVudElkKTtcbiAgICAgICAgcmV0dXJuIGdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQobW1GaWxlcG9vbExpbmtzU3RvcmUsIHtcbiAgICAgICAgICAgICAgICBmaWxlSWQ6IGZpbGVJZCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRJZDogY29tcG9uZW50SWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGluayBhIGZpbGUgd2l0aCBhIGNvbXBvbmVudCBieSBVUkwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjYWRkRmlsZUxpbmtCeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGZpbGUgVXJsLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgb24gc3VjY2Vzcy4gUmVqZWN0ZWQgb24gZmFpbHVyZS4gSXQgaXMgYWR2aXNlZCB0byBzaWxlbnRseSBpZ25vcmUgZmFpbHVyZXMuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhIGxpbmsgYmV0d2VlbiBhIFVSTCBhbmQgYSBjb21wb25lbnQuIFlvdSB1c3VhbGx5IGRvIG5vdCBuZWVkIHRvIGNhbGxcbiAgICAgKiB0aGlzIG1hbnVhbGx5IGFzIGFkZGluZyBhIGZpbGUgdG8gcXVldWUgYWxsb3dzIHlvdSB0byBkbyBzby4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kXG4gICAgICogZG9lcyBub3QgY2hlY2sgaWYgdGhlIGZpbGUgZXhpc3RzIGluIHRoZSBwb29sLCBzbyB5b3UgcHJvYmFibHkgd2FudCB0byB1c2UgaXMgYWZ0ZXJcbiAgICAgKiBhIHN1Y2Nlc3NmdWwge0BsaW5rICRtbUZpbGVwb29sI2Rvd25sb2FkVXJsfS5cbiAgICAgKi9cbiAgICBzZWxmLmFkZEZpbGVMaW5rQnlVcmwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9hZGRGaWxlTGluayhzaXRlSWQsIGZpbGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMaW5rIGEgZmlsZSB3aXRoIGEgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19hZGRGaWxlTGlua3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gbGlua3MgQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBsaW5rIGNvbXBvbmVudCBhbmQgb3B0aW9uYWxseSBjb21wb25lbnRJZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBvbiBzdWNjZXNzLiBSZWplY3RlZCBvbiBmYWlsdXJlLiBJdCBpcyBhZHZpc2VkIHRvIHNpbGVudGx5IGlnbm9yZSBmYWlsdXJlcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fYWRkRmlsZUxpbmtzID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQsIGxpbmtzKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobGlua3MsIGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5fYWRkRmlsZUxpbmsoc2l0ZUlkLCBmaWxlSWQsIGxpbmsuY29tcG9uZW50LCBsaW5rLmNvbXBvbmVudElkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZmlsZSB0byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfYWRkRmlsZVRvUG9vbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCBUaGUgZmlsZSBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIHN0b3JlIGFib3V0IHRoZSBmaWxlICh0aW1lbW9kaWZpZWQsIHVybCwgLi4uKS4gU2VlIG1tRmlsZXBvb2xTdG9yZSBzY2hlbWEuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHdpbGwgb3ZlcnJpZGUgYW55IGV4aXN0aW5nIGVudHJ5IHdpdGggdGhlIHNhbWUga2V5LlxuICAgICAqIFRoYXQgaXMgdGhlIG9ubHkgd2F5IHRvIHVwZGF0ZSBhbiBlbnRyeS5cbiAgICAgKi9cbiAgICBzZWxmLl9hZGRGaWxlVG9Qb29sID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQsIGRhdGEpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGFuZ3VsYXIuY29weShkYXRhKSB8fCB7fTtcbiAgICAgICAgdmFsdWVzLmZpbGVJZCA9IGZpbGVJZDtcbiAgICAgICAgcmV0dXJuIGdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQobW1GaWxlcG9vbFN0b3JlLCB2YWx1ZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGVudHJ5IHRvIHF1ZXVlIHVzaW5nIGEgVVJMLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2FkZFRvUXVldWVCeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGFic29sdXRlIFVSTCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbXBvbmVudF0gVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQgKG9wdGlvbmFsKS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZD0wXSBUaGUgdGltZSB0aGlzIGZpbGUgd2FzIG1vZGlmaWVkLiBDYW4gYmUgdXNlZCB0byBjaGVjayBmaWxlIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZmlsZVBhdGhdICAgICAgIEZpbGVwYXRoIHRvIGRvd25sb2FkIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHk9MF0gVGhlIHByaW9yaXR5IHRoaXMgZmlsZSBzaG91bGQgZ2V0IGluIHRoZSBxdWV1ZSAocmFuZ2UgMC05OTkpLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIG9uIHN1Y2Nlc3MuIFRoZSByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgaW5jb25zaXN0ZW50LCBkbyBub3QgdXNlLlxuICAgICAqL1xuICAgIHNlbGYuYWRkVG9RdWV1ZUJ5VXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCB0aW1lbW9kaWZpZWQsIGZpbGVQYXRoLCBwcmlvcml0eSkge1xuICAgICAgICB2YXIgZGIgPSAkbW1BcHAuZ2V0REIoKSxcbiAgICAgICAgICAgIGZpbGVJZCxcbiAgICAgICAgICAgIG5vdyA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgcmV2aXNpb24sXG4gICAgICAgICAgICBxdWV1ZURlZmVycmVkO1xuXG4gICAgICAgIGlmICghJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcblxuICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gdGltZW1vZGlmaWVkIHx8IDA7XG4gICAgICAgICAgICByZXZpc2lvbiA9IHNlbGYuZ2V0UmV2aXNpb25Gcm9tVXJsKGZpbGVVcmwpO1xuICAgICAgICAgICAgZmlsZUlkID0gc2VsZi5fZ2V0RmlsZUlkQnlVcmwoZmlsZVVybCk7XG4gICAgICAgICAgICBwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgY29tcG9uZW50LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGluayA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudElkOiBjb21wb25lbnRJZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBxdWV1ZSBkZWZlcnJlZCBub3cgaWYgaXQgZXhpc3RzIHRvIHByZXZlbnQgZXJyb3JzIGlmIGZpbGUgaXMgcmVtb3ZlZCBmcm9tIHF1ZXVlXG4gICAgICAgICAgICAvLyB3aGlsZSB3ZSdyZSBjaGVja2luZyBpZiB0aGUgZmlsZSBpcyBpbiBxdWV1ZS5cbiAgICAgICAgICAgIHF1ZXVlRGVmZXJyZWQgPSBzZWxmLl9nZXRRdWV1ZURlZmVycmVkKHNpdGVJZCwgZmlsZUlkLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkYi5nZXQobW1GaWxlcG9vbFF1ZXVlU3RvcmUsIFtzaXRlSWQsIGZpbGVJZF0pLnRoZW4oZnVuY3Rpb24oZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZExpbmsgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgdGhlIGZpbGUgaW4gcXVldWUsIHdlIHVwZGF0ZSB0aGUgcHJpb3JpdHkgYW5kIGxpbmtzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU9iamVjdC5wcmlvcml0eSA8IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU9iamVjdC5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXZpc2lvbiAmJiBmaWxlT2JqZWN0LnJldmlzaW9uICE9PSByZXZpc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVPYmplY3QucmV2aXNpb24gPSByZXZpc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW1vZGlmaWVkICYmIGZpbGVPYmplY3QudGltZW1vZGlmaWVkICE9PSB0aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlT2JqZWN0LnRpbWVtb2RpZmllZCA9IHRpbWVtb2RpZmllZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZVBhdGggJiYgZmlsZU9iamVjdC5wYXRoICE9PSBmaWxlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVPYmplY3QucGF0aCA9IGZpbGVQYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYWRkIHRoZSBuZXcgbGluayBpZiBpdCBkb2VzIG5vdCBleGlzdCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZmlsZU9iamVjdC5saW5rcywgZnVuY3Rpb24oZmlsZUxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUxpbmsuY29tcG9uZW50ID09IGxpbmsuY29tcG9uZW50ICYmIGZpbGVMaW5rLmNvbXBvbmVudElkID09IGxpbmsuY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRMaW5rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlT2JqZWN0LmxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgb25seSB3aGVuIHJlcXVpcmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVXBkYXRpbmcgZmlsZSAnICsgZmlsZUlkICsgJyB3aGljaCBpcyBhbHJlYWR5IGluIHF1ZXVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KG1tRmlsZXBvb2xRdWV1ZVN0b3JlLCBmaWxlT2JqZWN0KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRRdWV1ZVByb21pc2Uoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdGaWxlICcgKyBmaWxlSWQgKyAnIGFscmVhZHkgaW4gcXVldWUgYW5kIGRvZXMgbm90IHJlcXVpcmUgdXBkYXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZURlZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFibGUgdG8gcmV0cmlldmUgdGhlIHF1ZXVlIGRlZmVycmVkIGJlZm9yZSB3ZSB1c2UgdGhhdCBvbmUsIHNpbmNlIHRoZSBmaWxlIGRvd25sb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtaWdodCBoYXZlIGZpbmlzaGVkIG5vdyBhbmQgdGhlIGRlZmVycmVkIHdvdWxkbid0IGJlIGluIHRoZSBhcnJheSBhbnltb3JlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlRGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRRdWV1ZVByb21pc2Uoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZFRvUXVldWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBVbnN1cmUgd2h5IHdlIGNvdWxkIG5vdCBnZXQgdGhlIHJlY29yZCwgbGV0J3MgYWRkIHRvIHRoZSBxdWV1ZSBhbnl3YXkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZFRvUXVldWUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRUb1F1ZXVlKCkge1xuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0FkZGluZyAnICsgZmlsZUlkICsgJyB0byB0aGUgcXVldWUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KG1tRmlsZXBvb2xRdWV1ZVN0b3JlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGVJZDogc2l0ZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaWxlSWQ6IGZpbGVJZCxcbiAgICAgICAgICAgICAgICAgICAgYWRkZWQ6IG5vdy5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBmaWxlVXJsLFxuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbjogcmV2aXNpb24sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZDogdGltZW1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgbGlua3M6IGxpbmsgPyBbbGlua10gOiBbXVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBxdWV1ZSBpcyBydW5uaW5nLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNoZWNrUXVldWVQcm9jZXNzaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRRdWV1ZVByb21pc2Uoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIHF1ZXVlIHByb2Nlc3NpbmcuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjY2hlY2tRdWV1ZVByb2Nlc3NpbmdcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEluIG1vc2UgY2FzZXMsIHRoaXMgd2lsbCBlbmFibGUgdGhlIHF1ZXVlIHByb2Nlc3NpbmcgaWYgaXQgd2FzIHBhdXNlZC5cbiAgICAgKiBUaG91Z2gsIHRoaXMgd2lsbCBkaXNhYmxlIHRoZSBxdWV1ZSBpZiB3ZSBhcmUgbWlzc2luZyBuZXR3b3JrIG9yIGlmIHRoZSBmaWxlIHN5c3RlbVxuICAgICAqIGlzIG5vdCBhY2Nlc3NpYmxlLiBBbHNvLCB0aGlzIHdpbGwgaGF2ZSBubyBlZmZlY3QgaWYgdGhlIHF1ZXVlIGlzIGFscmVhZHkgcnVubmluZy5cbiAgICAgKlxuICAgICAqIERvIG5vdCB1c2UgZGlyZWN0bHksIGl0IGlzIHJlc2VydmVkIGZvciBjb3JlIHVzZS5cbiAgICAgKi9cbiAgICBzZWxmLmNoZWNrUXVldWVQcm9jZXNzaW5nID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCEkbW1GUy5pc0F2YWlsYWJsZSgpIHx8ICEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgcXVldWVTdGF0ZSA9IFFVRVVFX1BBVVNFRDtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9IGVsc2UgaWYgKHF1ZXVlU3RhdGUgPT09IFFVRVVFX1JVTk5JTkcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlU3RhdGUgPSBRVUVVRV9SVU5OSU5HO1xuICAgICAgICBzZWxmLl9wcm9jZXNzUXVldWUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIHBhY2thZ2VzIHN0YXR1cyBpbiBhIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjY2xlYXJBbGxQYWNrYWdlc1N0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgU2l0ZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgc3RhdHVzIGFyZSBjbGVhcmVkLlxuICAgICAqL1xuICAgIHNlbGYuY2xlYXJBbGxQYWNrYWdlc1N0YXR1cyA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgJGxvZy5kZWJ1ZygnQ2xlYXIgYWxsIHBhY2thZ2VzIHN0YXR1cyBmb3Igc2l0ZSAnICsgc2l0ZUlkKTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBzaXRlLmdldERiKCk7XG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0QWxsKG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYi5yZW1vdmUobW1GaWxlcG9vbFBhY2thZ2VzU3RvcmUsIGVudHJ5LmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBtb2R1bGUgc3RhdHVzIGNoYW5nZWQsIHNldHRpbmcgaXQgYXMgbm90IGRvd25sb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90cmlnZ2VyUGFja2FnZVN0YXR1c0NoYW5nZWQoc2l0ZUlkLCBlbnRyeS5jb21wb25lbnQsIGVudHJ5LmNvbXBvbmVudElkLCBtbUNvcmVOb3REb3dubG9hZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGZpbGVwb29sLiBVc2UgaXQgb25seSB3aGVuIGFsbCB0aGUgZmlsZXMgZnJvbSBhIHNpdGUgYXJlIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjY2xlYXJGaWxlcG9vbFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkIElEIG9mIHRoZSBzaXRlIHRvIGNsZWFyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZXBvb2wgaXMgY2xlYXJlZC5cbiAgICAgKi9cbiAgICBzZWxmLmNsZWFyRmlsZXBvb2wgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5yZW1vdmVBbGwobW1GaWxlcG9vbFN0b3JlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBhIGNvbXBvbmVudCBoYXMgZmlsZXMgaW4gdGhlIHBvb2wuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjY29tcG9uZW50SGFzRmlsZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgbWVhbnMgeWVzLCByZWplY3RlZCBtZWFucyBuby5cbiAgICAgKi9cbiAgICBzZWxmLmNvbXBvbmVudEhhc0ZpbGVzID0gZnVuY3Rpb24oc2l0ZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkKSB7XG4gICAgICAgIHJldHVybiBnZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICB2YXIgd2hlcmU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHdoZXJlID0gWydjb21wb25lbnRBbmRJZCcsICc9JywgW2NvbXBvbmVudCwgc2VsZi5fZml4Q29tcG9uZW50SWQoY29tcG9uZW50SWQpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoZXJlID0gWydjb21wb25lbnQnLCAnPScsIGNvbXBvbmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGIuY291bnQobW1GaWxlcG9vbExpbmtzU3RvcmUsIHdoZXJlKS50aGVuKGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgY3VycmVudCBzdGF0dXMgb2YgYSBsaXN0IG9mIHBhY2thZ2VzIGFuZCB0aGUgc3RhdHVzIG9mIG9uZSBvZiB0aGUgcGFja2FnZXMsXG4gICAgICogZGV0ZXJtaW5lIHRoZSBuZXcgc3RhdHVzIGZvciB0aGUgbGlzdCBvZiBwYWNrYWdlcy4gVGhlIHN0YXR1cyBvZiBhIGxpc3Qgb2YgcGFja2FnZXMgaXM6XG4gICAgICogICAgIC0gbW1Db3JlTm90RG93bmxvYWRhYmxlIGlmIHRoZXJlIGFyZSBubyBkb3dubG9hZGFibGUgcGFja2FnZXMuXG4gICAgICogICAgIC0gbW1Db3JlTm90RG93bmxvYWRlZCBpZiBhdCBsZWFzdCAxIHBhY2thZ2UgaGFzIHN0YXR1cyBtbUNvcmVOb3REb3dubG9hZGVkLlxuICAgICAqICAgICAtIG1tQ29yZURvd25sb2FkZWQgaWYgQUxMIHRoZSBkb3dubG9hZGFibGUgcGFja2FnZXMgaGF2ZSBzdGF0dXMgbW1Db3JlRG93bmxvYWRlZC5cbiAgICAgKiAgICAgLSBtbUNvcmVEb3dubG9hZGluZyBpZiBBTEwgdGhlIGRvd25sb2FkYWJsZSBwYWNrYWdlcyBoYXZlIHN0YXR1cyBtbUNvcmVEb3dubG9hZGluZyBvciBtbUNvcmVEb3dubG9hZGVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggYXQgbGVhc3QgMSBwYWNrYWdlIHdpdGggbW1Db3JlRG93bmxvYWRpbmcuXG4gICAgICogICAgIC0gbW1Db3JlT3V0ZGF0ZWQgaWYgQUxMIHRoZSBkb3dubG9hZGFibGUgcGFja2FnZXMgaGF2ZSBzdGF0dXMgbW1Db3JlT3V0ZGF0ZWQgb3IgbW1Db3JlRG93bmxvYWRlZCBvclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1tQ29yZURvd25sb2FkaW5nLCB3aXRoIGF0IGxlYXN0IDEgcGFja2FnZSB3aXRoIG1tQ29yZU91dGRhdGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2RldGVybWluZVBhY2thZ2VzU3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnQgICAgICAgQ3VycmVudCBzdGF0dXMgb2YgdGhlIGxpc3Qgb2YgcGFja2FnZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhY2thZ2VzdGF0dXMgU3RhdHVzIG9mIG9uZSBvZiB0aGUgcGFja2FnZXMuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgTmV3IHN0YXR1cyBmb3IgdGhlIGxpc3Qgb2YgcGFja2FnZXM7XG4gICAgICovXG4gICAgc2VsZi5kZXRlcm1pbmVQYWNrYWdlc1N0YXR1cyA9IGZ1bmN0aW9uKGN1cnJlbnQsIHBhY2thZ2VzdGF0dXMpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gbW1Db3JlTm90RG93bmxvYWRhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhY2thZ2VzdGF0dXMgPT09IG1tQ29yZU5vdERvd25sb2FkZWQpIHtcbiAgICAgICAgICAgIC8vIElmIDEgcGFja2FnZSBpcyBub3QgZG93bmxvYWRlZCB0aGUgc3RhdHVzIG9mIHRoZSB3aG9sZSBsaXN0IHdpbGwgYWx3YXlzIGJlIG5vdCBkb3dubG9hZGVkLlxuICAgICAgICAgICAgcmV0dXJuIG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAocGFja2FnZXN0YXR1cyA9PT0gbW1Db3JlRG93bmxvYWRlZCAmJiBjdXJyZW50ID09PSBtbUNvcmVOb3REb3dubG9hZGFibGUpIHtcbiAgICAgICAgICAgIC8vIElmIGFsbCBwYWNrYWdlcyBhcmUgZG93bmxvYWRlZCBvciBub3QgZG93bmxvYWRhYmxlIHdpdGggYXQgbGVhc3QgMSBkb3dubG9hZGVkLCBzdGF0dXMgd2lsbCBiZSBkb3dubG9hZGVkLlxuICAgICAgICAgICAgcmV0dXJuIG1tQ29yZURvd25sb2FkZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAocGFja2FnZXN0YXR1cyA9PT0gbW1Db3JlRG93bmxvYWRpbmcgJiYgKGN1cnJlbnQgPT09IG1tQ29yZU5vdERvd25sb2FkYWJsZSB8fCBjdXJyZW50ID09PSBtbUNvcmVEb3dubG9hZGVkKSkge1xuICAgICAgICAgICAgLy8gSWYgYWxsIHBhY2thZ2VzIGFyZSBkb3dubG9hZGluZy9kb3dubG9hZGVkL25vdGRvd25sb2FkYWJsZSB3aXRoIGF0IGxlYXN0IDEgZG93bmxvYWRpbmcsIHN0YXR1cyB3aWxsIGJlIGRvd25sb2FkaW5nLlxuICAgICAgICAgICAgcmV0dXJuIG1tQ29yZURvd25sb2FkaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKHBhY2thZ2VzdGF0dXMgPT09IG1tQ29yZU91dGRhdGVkICYmIGN1cnJlbnQgIT09IG1tQ29yZU5vdERvd25sb2FkZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYWNrYWdlcyBub3Rkb3dubG9hZGVkIGFuZCB0aGVyZSBpcyBhdCBsZWFzdCAxIG91dGRhdGVkLCBzdGF0dXMgd2lsbCBiZSBvdXRkYXRlZC5cbiAgICAgICAgICAgIHJldHVybiBtbUNvcmVPdXRkYXRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXR1cyByZW1haW5zIHRoZSBzYW1lLlxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIG9yIHByZWZldGNoZXMgYSBsaXN0IG9mIGZpbGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19kb3dubG9hZE9yUHJlZmV0Y2hQYWNrYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IGZpbGVMaXN0ICAgTGlzdCBvZiBmaWxlcyB0byBkb3dubG9hZC5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBwcmVmZXRjaCAgICBUcnVlIGlmIHNob3VsZCBwcmVmZXRjaCB0aGUgY29udGVudHMgKHF1ZXVlKSwgZmFsc2UgaWYgdGhleSBzaG91bGQgYmUgZG93bmxvYWRlZCByaWdodCBub3cuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgICAgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXZpc2lvbl0gICAgUGFja2FnZSdzIHJldmlzaW9uLiBJZiBub3QgZGVmaW5lZCwgaXQgd2lsbCBiZSBjYWxjdWxhdGVkIHVzaW5nIHRoZSBsaXN0IG9mIGZpbGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW1vZF0gICAgIFBhY2thZ2UncyB0aW1lbW9kaWZpZWQuIElmIG5vdCBkZWZpbmVkLCBpdCB3aWxsIGJlIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIGxpc3Qgb2YgZmlsZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkaXJQYXRoXSAgICAgTmFtZSBvZiB0aGUgZGlyZWN0b3J5IHdoZXJlIHRvIHN0b3JlIHRoZSBmaWxlcyAoaW5zaWRlIGZpbGVwb29sIGRpcikuIElmIG5vdCBkZWZpbmVkLCBzdG9yZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaWxlcyBkaXJlY3RseSBpbnNpZGUgdGhlIGZpbGVwb29sIGZvbGRlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGZpbGVzIGFyZSBkb3dubG9hZGVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9kb3dubG9hZE9yUHJlZmV0Y2hQYWNrYWdlID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlTGlzdCwgcHJlZmV0Y2gsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHJldmlzaW9uLCB0aW1lbW9kLCBkaXJQYXRoKSB7XG5cbiAgICAgICAgdmFyIHBhY2thZ2VJZCA9IHNlbGYuZ2V0UGFja2FnZUlkKGNvbXBvbmVudCwgY29tcG9uZW50SWQpO1xuXG4gICAgICAgIGlmIChwYWNrYWdlc1Byb21pc2VzW3NpdGVJZF0gJiYgcGFja2FnZXNQcm9taXNlc1tzaXRlSWRdW3BhY2thZ2VJZF0pIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIGRvd25sb2FkIG9uZ29pbmcgZm9yIHRoaXMgcGFja2FnZSwgcmV0dXJuIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgcmV0dXJuIHBhY2thZ2VzUHJvbWlzZXNbc2l0ZUlkXVtwYWNrYWdlSWRdO1xuICAgICAgICB9IGVsc2UgaWYgKCFwYWNrYWdlc1Byb21pc2VzW3NpdGVJZF0pIHtcbiAgICAgICAgICAgIHBhY2thZ2VzUHJvbWlzZXNbc2l0ZUlkXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV2aXNpb24gPSByZXZpc2lvbiB8fCBzZWxmLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KGZpbGVMaXN0KTtcbiAgICAgICAgdGltZW1vZCA9IHRpbWVtb2QgfHwgc2VsZi5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QoZmlsZUxpc3QpO1xuXG4gICAgICAgIHZhciBkd25Qcm9taXNlLFxuICAgICAgICAgICAgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCBwYWNrYWdlIGFzIGRvd25sb2FkaW5nLlxuICAgICAgICBkd25Qcm9taXNlID0gc2VsZi5zdG9yZVBhY2thZ2VTdGF0dXMoc2l0ZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCBtbUNvcmVEb3dubG9hZGluZywgcmV2aXNpb24sIHRpbWVtb2QpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICAgICAgcGFja2FnZUxvYWRlZCA9IDA7IC8vIFVzZSBhIGRlZmVycmVkIHRvIGJlIGFibGUgdG8gdXNlIG5vdGlmeS5cblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZpbGVMaXN0LCBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVMb2FkZWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpclBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwYXRoIHRvIHRoZSBmaWxlLlxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gZmlsZS5maWxlbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuZmlsZXBhdGggIT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGZpbGUuZmlsZXBhdGguc3Vic3RyKDEpICsgcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gJG1tRlMuY29uY2F0ZW5hdGVQYXRocyhkaXJQYXRoLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlZmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHNlbGYuYWRkVG9RdWV1ZUJ5VXJsKHNpdGVJZCwgZmlsZS5maWxldXJsLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCBmaWxlLnRpbWVtb2RpZmllZCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHNlbGYuZG93bmxvYWRVcmwoc2l0ZUlkLCBmaWxlLmZpbGV1cmwsIGZhbHNlLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCBmaWxlLnRpbWVtb2RpZmllZCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgdW5kZWZpbmVkIGZvciBzdWNjZXNzICYgZmFpbCB3aWxsIHBhc3MgdGhlIHN1Y2Nlc3MvZmFpbHVyZSB0byB0aGUgcGFyZW50IHByb21pc2UuXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlLnRoZW4odW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzcyAmJiBwcm9ncmVzcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV3IHNpemUgbG9hZGVkIHRvIHRoZSBwYWNrYWdlIGxvYWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2thZ2VMb2FkZWQgPSBwYWNrYWdlTG9hZGVkICsgKHByb2dyZXNzLmxvYWRlZCAtIGZpbGVMb2FkZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUxvYWRlZCA9IHByb2dyZXNzLmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZURvd25sb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZDogcGFja2FnZUxvYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlUHJvZ3Jlc3M6IHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2VzcyBwcmVmZXRjaGluZywgc3RvcmUgcGFja2FnZSBhcyBkb3dubG9hZGVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnN0b3JlUGFja2FnZVN0YXR1cyhzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIG1tQ29yZURvd25sb2FkZWQsIHJldmlzaW9uLCB0aW1lbW9kKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIGRvd25sb2FkaW5nLCBnbyBiYWNrIHRvIHByZXZpb3VzIHN0YXR1cyBhbmQgcmVqZWN0IHRoZSBwcm9taXNlLlxuXHRcdCRsb2cuZGVidWcoJ0Vycm9yIGRvd25sb2FkaW5nIHBhY2thZ2UuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2V0UGFja2FnZVByZXZpb3VzU3RhdHVzKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIERvd25sb2FkIGZpbmlzaGVkLCBkZWxldGUgdGhlIHByb21pc2UuXG4gICAgICAgICAgICBkZWxldGUgcGFja2FnZXNQcm9taXNlc1tzaXRlSWRdW3BhY2thZ2VJZF07XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFkZWxldGVkKSB7IC8vIEluIGNhc2UgcHJvbWlzZSB3YXMgZmluaXNoZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICBwYWNrYWdlc1Byb21pc2VzW3NpdGVJZF1bcGFja2FnZUlkXSA9IGR3blByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR3blByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIGxpc3Qgb2YgZmlsZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZG93bmxvYWRQYWNrYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSAge09iamVjdFtdfSBmaWxlTGlzdCAgICBMaXN0IG9mIGZpbGVzIHRvIGRvd25sb2FkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgICAgICBUaGUgY29tcG9uZW50IHRvIGxpbmsgdGhlIGZpbGUgdG8uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbXBvbmVudElkICAgIEFuIElEIHRvIGlkZW50aWZ5IHRoZSBkb3dubG9hZC4gTXVzdCBiZSB1bmlxdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXZpc2lvbl0gICAgIFBhY2thZ2UncyByZXZpc2lvbi4gSWYgbm90IGRlZmluZWQsIGl0IHdpbGwgYmUgY2FsY3VsYXRlZCB1c2luZyB0aGUgbGlzdCBvZiBmaWxlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZF0gUGFja2FnZSdzIHRpbWVtb2RpZmllZC4gSWYgbm90IGRlZmluZWQsIGl0IHdpbGwgYmUgY2FsY3VsYXRlZCB1c2luZyB0aGUgbGlzdCBvZiBmaWxlcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RpclBhdGhdICAgICAgTmFtZSBvZiB0aGUgZGlyZWN0b3J5IHdoZXJlIHRvIHN0b3JlIHRoZSBmaWxlcyAoaW5zaWRlIGZpbGVwb29sIGRpcikuIElmIG5vdCBkZWZpbmVkLCBzdG9yZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlsZXMgZGlyZWN0bHkgaW5zaWRlIHRoZSBmaWxlcG9vbCBmb2xkZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgZmlsZXMgYXJlIGRvd25sb2FkZWQuXG4gICAgICovXG4gICAgc2VsZi5kb3dubG9hZFBhY2thZ2UgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVMaXN0LCBjb21wb25lbnQsIGNvbXBvbmVudElkLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkLCBkaXJQYXRoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9kb3dubG9hZE9yUHJlZmV0Y2hQYWNrYWdlKHNpdGVJZCwgZmlsZUxpc3QsIGZhbHNlLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkLCBkaXJQYXRoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgZmlsZSBvbiB0aGUgc3BvdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNkb3dubG9hZFVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGZpbGUgVVJMLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZVN0YWxlXSBUcnVlIGlmICdzdGFsZScgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIGxpbmsgdGhlIGZpbGUgdG8uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb25lbnRJZF0gQW4gSUQgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZD0wXSBUaGUgdGltZSB0aGlzIGZpbGUgd2FzIG1vZGlmaWVkLiBDYW4gYmUgdXNlZCB0byBjaGVjayBmaWxlIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZmlsZVBhdGhdICAgICAgIEZpbGVwYXRoIHRvIGRvd25sb2FkIHRoZSBmaWxlIHRvLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggaW50ZXJuYWwgVVJMIG9uIHN1Y2Nlc3MsIHJlamVjdGVkIG90aGVyd2lzZS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBEb3dubG9hZHMgYSBmaWxlIG9uIHRoZSBzcG90LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGFsc28gdGFrZSBjYXJlIG9mIGFkZGluZyB0aGUgZmlsZSB0byB0aGUgcG9vbCBpZiBpdCdzIG1pc3NpbmcuXG4gICAgICogSG93ZXZlciwgcGxlYXNlIG5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGZvcmNlIGEgZmlsZSB0byBiZSByZS1kb3dubG9hZGVkXG4gICAgICogaWYgaXQgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBwb29sLiBZb3Ugc2hvdWxkIG1hcmsgYSBmaWxlIGFzIHN0YWxlIHVzaW5nXG4gICAgICoge0BsaW5rICRtbUZpbGVwb29sI2ludmFsaWRhdGVGaWxlQnlVcmx9IHRvIHRyaWdnZXIgYSBkb3dubG9hZC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgJG1tRmlsZXBvb2wjX2dldEludGVybmFsVXJsQnlJZH0gZm9yIHRoZSB0eXBlIG9mIGxvY2FsIFVSTCByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBzZWxmLmRvd25sb2FkVXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsLCBpZ25vcmVTdGFsZSwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgdGltZW1vZGlmaWVkLCBmaWxlUGF0aCkge1xuICAgICAgICB2YXIgZmlsZUlkLFxuICAgICAgICAgICAgcmV2aXNpb24sXG4gICAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZml4UGx1Z2luZmlsZVVSTChzaXRlSWQsIGZpbGVVcmwpLnRoZW4oZnVuY3Rpb24oZmlsZVVybCkge1xuICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZCA9IHRpbWVtb2RpZmllZCB8fCAwO1xuICAgICAgICAgICAgICAgIHJldmlzaW9uID0gc2VsZi5nZXRSZXZpc2lvbkZyb21VcmwoZmlsZVVybCk7XG4gICAgICAgICAgICAgICAgZmlsZUlkID0gc2VsZi5fZ2V0RmlsZUlkQnlVcmwoZmlsZVVybCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5faGFzRmlsZUluUG9vbChzaXRlSWQsIGZpbGVJZCkudGhlbihmdW5jdGlvbihmaWxlT2JqZWN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlT2JqZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IGhhdmUgdGhlIGZpbGUsIGRvd25sb2FkIGFuZCBhZGQgdG8gcG9vbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9kb3dubG9hZEZvclBvb2xCeVVybChzaXRlSWQsIGZpbGVVcmwsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQsIGZpbGVQYXRoKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuX2lzRmlsZU91dGRhdGVkKGZpbGVPYmplY3QsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQpICYmICRtbUFwcC5pc09ubGluZSgpICYmICFpZ25vcmVTdGFsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpbGUgaXMgb3V0ZGF0ZWQsIGZvcmNlIHRoZSBkb3dubG9hZCBhbmQgdXBkYXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2Rvd25sb2FkRm9yUG9vbEJ5VXJsKHNpdGVJZCwgZmlsZVVybCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCwgZmlsZVBhdGgsIGZpbGVPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXZlcnl0aGluZyBpcyBmaW5lLCByZXR1cm4gdGhlIGZpbGUgb24gZGlzay5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gc2VsZi5fZ2V0SW50ZXJuYWxVcmxCeVBhdGgoZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHNlbGYuX2dldEludGVybmFsVXJsQnlJZChzaXRlSWQsIGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIHdhcyBub3QgZm91bmQgaW4gdGhlIHBvb2wsIHdlaXJkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2Rvd25sb2FkRm9yUG9vbEJ5VXJsKHNpdGVJZCwgZmlsZVVybCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCwgZmlsZVBhdGgsIGZpbGVPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSBpcyBub3QgaW4gdGhlIHBvb2wganVzdCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9kb3dubG9hZEZvclBvb2xCeVVybChzaXRlSWQsIGZpbGVVcmwsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQsIGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkRmlsZUxpbmsoc2l0ZUlkLCBmaWxlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX25vdGlmeUZpbGVEb3dubG9hZGVkKHNpdGVJZCwgZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9ub3RpZnlGaWxlRG93bmxvYWRFcnJvcihzaXRlSWQsIGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIFVSTCBhbmQgdXBkYXRlIG9yIGFkZCBpdCB0byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIFRoaXMgdXNlcyB0aGUgZmlsZSBzeXN0ZW0sIHlvdSBzaG91bGQgYWx3YXlzIG1ha2Ugc3VyZSB0aGF0IGl0IGlzXG4gICAgICogYWNjZXNzaWJsZSBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfZG93bmxvYWRGb3JQb29sQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgICAgICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCAgICAgICAgICBUaGUgZmlsZSBVUkwuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXZpc2lvbl0gICAgICAgRmlsZSByZXZpc2lvbiBudW1iZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWRdICAgVGhlIHRpbWUgdGhpcyBmaWxlIHdhcyBtb2RpZmllZC4gQ2FuIGJlIHVzZWQgdG8gY2hlY2sgZmlsZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZpbGVQYXRoXSAgICAgICBGaWxlcGF0aCB0byBkb3dubG9hZCB0aGUgZmlsZSB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Bvb2xGaWxlT2JqZWN0XSBXaGVuIHNldCwgdGhlIG9iamVjdCB3aWxsIGJlIHVwZGF0ZWQsIGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCBpbnRlcm5hbCBVUkwgb24gc3VjY2VzcywgcmVqZWN0ZWQgb3RoZXJ3aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9kb3dubG9hZEZvclBvb2xCeVVybCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZVVybCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCwgZmlsZVBhdGgsIHBvb2xGaWxlT2JqZWN0KSB7XG4gICAgICAgIHZhciBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcbiAgICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aCB8fCBzZWxmLl9nZXRGaWxlUGF0aChzaXRlSWQsIGZpbGVJZCk7XG5cbiAgICAgICAgaWYgKHBvb2xGaWxlT2JqZWN0ICYmIHBvb2xGaWxlT2JqZWN0LmZpbGVJZCAhPT0gZmlsZUlkKSB7XG4gICAgICAgICAgICAkbG9nLmVycm9yKCdJbnZhbGlkIG9iamVjdCB0byB1cGRhdGUgcGFzc2VkJyk7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG93bmxvYWRJZCA9IHNlbGYuZ2V0RmlsZURvd25sb2FkSWQoZmlsZVVybCwgZmlsZVBhdGgpLFxuICAgICAgICAgICAgZGVsZXRlZCA9IGZhbHNlLFxuICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICBpZiAoZmlsZVByb21pc2VzW3NpdGVJZF0gJiYgZmlsZVByb21pc2VzW3NpdGVJZF1bZG93bmxvYWRJZF0pIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIGRvd25sb2FkIG9uZ29pbmcgZm9yIHRoaXMgZmlsZSBpbiB0aGlzIGxvY2F0aW9uLCByZXR1cm4gdGhlIHByb21pc2UuXG4gICAgICAgICAgICByZXR1cm4gZmlsZVByb21pc2VzW3NpdGVJZF1bZG93bmxvYWRJZF07XG4gICAgICAgIH0gZWxzZSBpZiAoIWZpbGVQcm9taXNlc1tzaXRlSWRdKSB7XG4gICAgICAgICAgICBmaWxlUHJvbWlzZXNbc2l0ZUlkXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZSA9ICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG5cbiAgICAgICAgICAgIGlmICghc2l0ZS5jYW5Eb3dubG9hZEZpbGVzKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAkbW1XUy5kb3dubG9hZEZpbGUoZmlsZVVybCwgZmlsZVBhdGgpLnRoZW4oZnVuY3Rpb24oZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwb29sRmlsZU9iamVjdCB8fCB7fTtcblxuICAgICAgICAgICAgICAgIGRhdGEuZG93bmxvYWRlZCA9IG5vdy5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgZGF0YS5zdGFsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRhdGEudXJsID0gZmlsZVVybDtcbiAgICAgICAgICAgICAgICBkYXRhLnJldmlzaW9uID0gcmV2aXNpb247XG4gICAgICAgICAgICAgICAgZGF0YS50aW1lbW9kaWZpZWQgPSB0aW1lbW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgZGF0YS5wYXRoID0gZmlsZVBhdGg7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fYWRkRmlsZVRvUG9vbChzaXRlSWQsIGZpbGVJZCwgZGF0YSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVFbnRyeS50b1VSTCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBEb3dubG9hZCBmaW5pc2hlZCwgZGVsZXRlIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgZGVsZXRlIGZpbGVQcm9taXNlc1tzaXRlSWRdW2Rvd25sb2FkSWRdO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZGVsZXRlZCkgeyAvLyBJbiBjYXNlIHByb21pc2Ugd2FzIGZpbmlzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgZmlsZVByb21pc2VzW3NpdGVJZF1bZG93bmxvYWRJZF0gPSBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXggYSBjb21wb25lbnQgSUQgdG8gYWx3YXlzIGJlIGEgTnVtYmVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19maXhDb21wb25lbnRJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnx1bmRlZmluZWR9IFRoZSBjb21wb25lbnQgSUQuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbm9ybWFsaXNlZCBjb21wb25lbnQgSUQuIC0xIHdoZW4gdW5kZWZpbmVkIHdhcyBwYXNzZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2ZpeENvbXBvbmVudElkID0gZnVuY3Rpb24oY29tcG9uZW50SWQpIHtcbiAgICAgICAgdmFyIGlkID0gcGFyc2VJbnQoY29tcG9uZW50SWQsIDEwKTtcbiAgICAgICAgaWYgKGlzTmFOKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSB3c3Rva2VuIHVybCBhbmQgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IHNjcmlwdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfZml4UGx1Z2luZmlsZVVSTFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBmaWxlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBSZXNvbHZlZCB3aXRoIGZpeGVkIFVSTCBvbiBzdWNjZXNzLCByZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5maXhQbHVnaW5maWxlVVJMKGZpbGVVcmwpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBJRCBvZiBhIGZpbGUgZG93bmxvYWQuIFVzZWQgdG8ga2VlcCB0cmFjayBvZiBmaWxlUHJvbWlzZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0RmlsZURvd25sb2FkSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCAgVGhlIGZpbGUgVVJMLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlUGF0aCBUaGUgZmlsZSBkZXN0aW5hdGlvbiBwYXRoLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBGaWxlIGRvd25sb2FkIElELlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVEb3dubG9hZElkID0gZnVuY3Rpb24oZmlsZVVybCwgZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG1kNS5jcmVhdGVIYXNoKGZpbGVVcmwgKyAnIyMjJyArIGZpbGVQYXRoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBldmVudCB1c2VkIHRvIG5vdGlmeSBkb3dubG9hZCBldmVudHMgKCRtbUV2ZW50cykuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0RmlsZUV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCBUaGUgZmlsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIEV2ZW50IG5hbWUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2dldEZpbGVFdmVudE5hbWUgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVJZCkge1xuICAgICAgICByZXR1cm4gJ21tRmlsZXBvb2xGaWxlOicrc2l0ZUlkKyc6JytmaWxlSWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdXNlZCB0byBub3RpZnkgZG93bmxvYWQgZXZlbnRzICgkbW1FdmVudHMpLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldEZpbGVFdmVudE5hbWVCeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBhYnNvbHV0ZSBVUkwgdG8gdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGV2ZW50IG5hbWUuXG4gICAgICovXG4gICAgc2VsZi5nZXRGaWxlRXZlbnROYW1lQnlVcmwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRGaWxlRXZlbnROYW1lKHNpdGVJZCwgZmlsZUlkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGRvd25sb2FkIHByb21pc2UuIElmIHRoZSBwcm9taXNlIGlzIG5vdCBzZXQsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0UGFja2FnZURvd25sb2FkUHJvbWlzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgICAgVGhlIGNvbXBvbmVudCBvZiB0aGUgcGFja2FnZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvbmVudElkXSBBbiBJRCB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgRG93bmxvYWQgcHJvbWlzZSBvciB1bmRlZmluZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRQYWNrYWdlRG93bmxvYWRQcm9taXNlID0gZnVuY3Rpb24oc2l0ZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkKSB7XG4gICAgICAgIHZhciBwYWNrYWdlSWQgPSBzZWxmLmdldFBhY2thZ2VJZChjb21wb25lbnQsIGNvbXBvbmVudElkKTtcbiAgICAgICAgaWYgKHBhY2thZ2VzUHJvbWlzZXNbc2l0ZUlkXSAmJiBwYWNrYWdlc1Byb21pc2VzW3NpdGVJZF1bcGFja2FnZUlkXSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhY2thZ2VzUHJvbWlzZXNbc2l0ZUlkXVtwYWNrYWdlSWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSUQgb2YgYSBwYWNrYWdlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldFBhY2thZ2VJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgICAgIFBhY2thZ2UncyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb25lbnRJZF0gQW4gSUQgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICBQYWNrYWdlIElELlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UGFja2FnZUlkID0gZnVuY3Rpb24oY29tcG9uZW50LCBjb21wb25lbnRJZCkge1xuICAgICAgICByZXR1cm4gbWQ1LmNyZWF0ZUhhc2goY29tcG9uZW50ICsgJyMnICsgc2VsZi5fZml4Q29tcG9uZW50SWQoY29tcG9uZW50SWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgcGFja2FnZSBwcmV2aW91cyBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0UGFja2FnZVByZXZpb3VzU3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgICAgICBQYWNrYWdlJ3MgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdICAgIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBzdGF0dXMuXG4gICAgICovXG4gICAgc2VsZi5nZXRQYWNrYWdlUHJldmlvdXNTdGF0dXMgPSBmdW5jdGlvbihzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBzaXRlLmdldERiKCksXG4gICAgICAgICAgICAgICAgcGFja2FnZUlkID0gc2VsZi5nZXRQYWNrYWdlSWQoY29tcG9uZW50LCBjb21wb25lbnRJZCk7XG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0KG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlLCBwYWNrYWdlSWQpLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkucHJldmlvdXMgfHzCoG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW1Db3JlTm90RG93bmxvYWRlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgcGFja2FnZSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0UGFja2FnZVN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgICAgICAgICAgUGFja2FnZSdzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvbmVudElkXSAgICAgICBBbiBJRCB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW3JldmlzaW9uPTBdIFBhY2thZ2UncyByZXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZD0wXSAgICBQYWNrYWdlJ3MgdGltZW1vZGlmaWVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgc3RhdHVzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UGFja2FnZVN0YXR1cyA9IGZ1bmN0aW9uKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCkge1xuICAgICAgICByZXZpc2lvbiA9IHJldmlzaW9uIHx8IDA7XG4gICAgICAgIHRpbWVtb2RpZmllZCA9IHRpbWVtb2RpZmllZCB8fCAwO1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciBkYiA9IHNpdGUuZ2V0RGIoKSxcbiAgICAgICAgICAgICAgICBwYWNrYWdlSWQgPSBzZWxmLmdldFBhY2thZ2VJZChjb21wb25lbnQsIGNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgLy8gR2V0IHN0YXR1cy5cbiAgICAgICAgICAgIHJldHVybiBkYi5nZXQobW1GaWxlcG9vbFBhY2thZ2VzU3RvcmUsIHBhY2thZ2VJZCkudGhlbihmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5zdGF0dXMgPT09IG1tQ29yZURvd25sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldmlzaW9uICE9IGVudHJ5LnJldmlzaW9uIHx8IHRpbWVtb2RpZmllZCA+IGVudHJ5LnRpbWVtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsZSBpcyBvdXRkYXRlZC4gTGV0J3MgY2hhbmdlIGl0cyBzdGF0dXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdGF0dXMgPSBtbUNvcmVPdXRkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnVwZGF0ZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmluc2VydChtbUZpbGVwb29sUGFja2FnZXNTdG9yZSwgZW50cnkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2VzcyBpbnNlcnRpbmcsIHRyaWdnZXIgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJpZ2dlclBhY2thZ2VTdGF0dXNDaGFuZ2VkKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgbW1Db3JlT3V0ZGF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LnN0YXR1cyA9PT0gbW1Db3JlT3V0ZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldmlzaW9uID09PSBlbnRyeS5yZXZpc2lvbiAmJiB0aW1lbW9kaWZpZWQgPT09IGVudHJ5LnRpbWVtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsZSBpc24ndCBvdXRkYXRlZCBhbnltb3JlLiBMZXQncyBjaGFuZ2UgaXRzIHN0YXR1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN0YXR1cyA9IG1tQ29yZURvd25sb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS51cGRhdGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5pbnNlcnQobW1GaWxlcG9vbFBhY2thZ2VzU3RvcmUsIGVudHJ5KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MgaW5zZXJ0aW5nLCB0cmlnZ2VyIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyaWdnZXJQYWNrYWdlU3RhdHVzQ2hhbmdlZChzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIG1tQ29yZURvd25sb2FkZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnN0YXR1cztcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtbUNvcmVOb3REb3dubG9hZGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlZmVycmVkIG9iamVjdCBmb3IgYSBmaWxlIGluIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfZ2V0UXVldWVEZWZlcnJlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZUlkICAgICAgICAgVGhlIGZpbGUgSUQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3JlYXRlPXRydWVdIFRydWUgaWYgaXQgc2hvdWxkIGNyZWF0ZSBhIG5ldyBkZWZlcnJlZCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICBEZWZlcnJlZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0UXVldWVEZWZlcnJlZCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkLCBjcmVhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjcmVhdGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNyZWF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXF1ZXVlRGVmZXJyZWRzW3NpdGVJZF0pIHtcbiAgICAgICAgICAgIGlmICghY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWVEZWZlcnJlZHNbc2l0ZUlkXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghcXVldWVEZWZlcnJlZHNbc2l0ZUlkXVtmaWxlSWRdKSB7XG4gICAgICAgICAgICBpZiAoIWNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlRGVmZXJyZWRzW3NpdGVJZF1bZmlsZUlkXSA9ICRxLmRlZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXVlRGVmZXJyZWRzW3NpdGVJZF1bZmlsZUlkXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwcm9taXNlIGZvciBhIGZpbGUgaW4gdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19nZXRRdWV1ZVByb21pc2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgICAgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCAgICAgICAgIFRoZSBmaWxlIElELlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NyZWF0ZT10cnVlXSBUcnVlIGlmIGl0IHNob3VsZCBjcmVhdGUgYSBuZXcgcHJvbWlzZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICBQcm9taXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRRdWV1ZVByb21pc2UgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVJZCwgY3JlYXRlKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9nZXRRdWV1ZURlZmVycmVkKHNpdGVJZCwgZmlsZUlkLCBjcmVhdGUpLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBmaWxlIGFscmVhZHkgaW4gdGhlIHBvb2w/XG4gICAgICpcbiAgICAgKiBUaGlzIGRvZXMgbm90IGNoZWNrIGlmIHRoZSBmaWxlIGlzIG9uIHRoZSBkaXNrLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19oYXNGaWxlSW5Qb29sXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCBUaGUgZmlsZSBVUkwuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCBmaWxlIG9iamVjdCBmcm9tIERCIG9uIHN1Y2Nlc3MsIHJlamVjdGVkIG90aGVyd2lzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5faGFzRmlsZUluUG9vbCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0KG1tRmlsZXBvb2xTdG9yZSwgZmlsZUlkKS50aGVuKGZ1bmN0aW9uKGZpbGVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVPYmplY3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVPYmplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBmaWxlIGluIHF1ZXVlP1xuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19oYXNGaWxlSW5RdWV1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGZpbGUgVVJMLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggZmlsZSBvYmplY3QgZnJvbSBEQiBvbiBzdWNjZXNzLCByZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2hhc0ZpbGVJblF1ZXVlID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmdldChtbUZpbGVwb29sUXVldWVTdG9yZSwgW3NpdGVJZCwgZmlsZUlkXSkudGhlbihmdW5jdGlvbihmaWxlT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVPYmplY3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVPYmplY3Q7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbCBVUkwgb2YgYSBkcmVjdG9yeS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNnZXRJbnRlcm5hbFVybEJ5VXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGZpbGUgVVJMLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFJlc29sdmVkIHdpdGggdGhlIFVSTC4gUmVqZWN0ZWQgb3RoZXJ3aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLmdldERpcmVjdG9yeVVybEJ5VXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsKSB7XG4gICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZml4UGx1Z2luZmlsZVVSTChzaXRlSWQsIGZpbGVVcmwpLnRoZW4oZnVuY3Rpb24oZmlsZVVybCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRlMuZ2V0RGlyKHNlbGYuX2dldEZpbGVQYXRoKHNpdGVJZCwgZmlsZUlkKSkudGhlbihmdW5jdGlvbihkaXJFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyRW50cnkudG9VUkwoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHVuaXF1ZSBJRCBiYXNlZCBvbiBhIFVSTC5cbiAgICAgKlxuICAgICAqIFRoaXMgaGFzIGEgbWluaW1hbCBoYW5kbGluZyBvZiBwbHVnaW5maWxlcyBpbiBvcmRlciB0byBnZW5lcmF0ZSBhIGNsZWFuXG4gICAgICogZmlsZSBJRCB3aGljaCB3aWxsIG5vdCBjaGFuZ2UgaWYgcG9pbnRpbmcgdG8gdGhlIHNhbWUgcGx1Z2luZmlsZSBVUkwgZXZlblxuICAgICAqIGlmIHRoZSB0b2tlbiBvciBleHRyYSBhdHRyaWJ1dGVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfZ2V0RmlsZUlkQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCBUaGUgYWJzb2x1dGUgVVJMIHRvIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBmaWxlIElELlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRGaWxlSWRCeVVybCA9IGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgdmFyIHVybCA9IHNlbGYuX3JlbW92ZVJldmlzaW9uRnJvbVVybChmaWxlVXJsKSxcbiAgICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbiA9ICcnO1xuXG4gICAgICAgIGlmICh1cmwuaW5kZXhPZignL3dlYnNlcnZpY2UvcGx1Z2luZmlsZScpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGF0dHJpYnV0ZXMgdGhhdCBkbyBub3QgbWF0dGVyLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHVybEF0dHJpYnV0ZXMsIGZ1bmN0aW9uKHJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UocmVnZXgsICcnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGb3Igbm93IG9ubHkgZ3Vlc3NlcyB0aGUgZXh0ZW5zaW9uIG9mIHRoZSBwbHVnaW4gZmlsZXMuIFdlIG5lZWQgdGhlIGV4dGVuc2lvblxuICAgICAgICAgICAgLy8gZm9yIHRoZSBpbkFwcEJyb3dzZXIgdG8gb3BlbiB0aGUgZmlsZXMgcHJvcGVybHksIGUuZy4gdGhlIGV4dGVuc2lvbiBuZWVkcyB0byBiZVxuICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgZmlsZSBuYW1lLiBBbHNvLCB3ZSBuZWVkIHRoZSBtaW1ldHlwZSB0byBvcGVuIHRoZSBmaWxlIHdpdGhcbiAgICAgICAgICAgIC8vIHdlYiBpbnRlbnRzLiBUaGUgZWFzaWVzdCB3YXkgdG8gcHJvdmlkZSBzdWNoIGluZm9ybWF0aW9uIGlzIHRvIGtlZXAgdGhlIGV4dGVuc2lvblxuICAgICAgICAgICAgLy8gaW4gdGhlIGZpbGUgSUQuIERldmVsb3BlcnMgc2hvdWxkIG5vdCBjYXJlIGFib3V0IGl0LCBidXQgYXMgd2UgYXJlIHVzaW5nIHRoZVxuICAgICAgICAgICAgLy8gZmlsZSBJRCBpbiB0aGUgZmlsZSBwYXRoLCBkZXZzIGFuZCBzeXN0ZW0gY2FuIGd1ZXNzIGl0LlxuICAgICAgICAgICAgY2FuZGlkYXRlID0gc2VsZi5fZ3Vlc3NFeHRlbnNpb25Gcm9tVXJsKHVybCk7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlICYmIGNhbmRpZGF0ZSAhPT0gJ3BocCcpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSAnLicgKyBjYW5kaWRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1kNS5jcmVhdGVIYXNoKCd1cmw6JyArIHVybCkgKyBleHRlbnNpb247XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWJzb2x1dGUgVVJMIHRvIGFjY2VzcyB0aGUgZmlsZSBVUkwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX2dldEZpbGVVcmxCeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGFic29sdXRlIFVSTCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW21vZGU9dXJsXSBUaGUgdHlwZSBvZiBVUkwgdG8gcmV0dXJuLiBBY2NlcHRzICd1cmwnIG9yICdzcmMnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWQ9MF0gVGhlIHRpbWUgdGhpcyBmaWxlIHdhcyBtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIHRoZSBVUkwgdG8gdXNlLiBXaGVuIHJlamVjdGVkLCBub3RoaW5nIGNvdWxkIGJlIGRvbmUuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhpcyB3aWxsIHJldHVybiBhIFVSTCBwb2ludGluZyB0byB0aGUgY29udGVudCBvZiB0aGUgcmVxdWVzdGVkIFVSTC5cbiAgICAgKlxuICAgICAqIFRoaXMgaGFuZGxlcyB0aGUgcXVldWUgYW5kIHZhbGlkaXR5IG9mIHRoZSBmaWxlLiBXaGVuIHdlIGhhdmUgYSBsb2NhbCBjb3B5IG9mIHRoZSBmaWxlXG4gICAgICogd2Ugd2lsbCBhc3Nlc3Mgd2hldGhlciBvciBub3QgaXQgaXMgc3RpbGwgdmFsaWQuIElmIGl0IGlzIG5vdCB2YWxpZCwgb3Igd2UgZGlkIG5vdCBmaW5kXG4gICAgICogdGhlIGZpbGUsIHdlIHdpbGwgYWRkIGl0IHRvIHRoZSBxdWV1ZSB0byBiZSBkb3dubG9hZGVkIGxhdGVyIGFuZCB3ZSB3aWxsIHJldHVybiB0aGUgVVJMXG4gICAgICogd2UgcmVjZWl2ZWQuIFdoZW4gdGhlIGZpbGUgaXMgdmFsaWQgd2UgcmV0dXJuIGEgbG9jYWwgVVJMIHRvIGl0LlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgZmlsZSBjYW5ub3QgYmUgZm91bmQsIGFuZCB3ZSBhcmUgb2ZmbGluZSwgdGhlbiB3ZSByZWplY3QgdGhlIHByb21pc2UgYmVjYXVzZVxuICAgICAqIHRoZXJlIHdhcyBub3RoaW5nIHdlIGNvdWxkIGRvLlxuICAgICAqL1xuICAgIHNlbGYuX2dldEZpbGVVcmxCeVVybCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZVVybCwgbW9kZSwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgdGltZW1vZGlmaWVkKSB7XG4gICAgICAgIHZhciBmaWxlSWQsXG4gICAgICAgICAgICByZXZpc2lvbjtcblxuICAgICAgICByZXR1cm4gc2VsZi5fZml4UGx1Z2luZmlsZVVSTChzaXRlSWQsIGZpbGVVcmwpLnRoZW4oZnVuY3Rpb24oZmlsZVVybCkge1xuICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gdGltZW1vZGlmaWVkIHx8IDA7XG4gICAgICAgICAgICByZXZpc2lvbiA9IHNlbGYuZ2V0UmV2aXNpb25Gcm9tVXJsKGZpbGVVcmwpO1xuICAgICAgICAgICAgdmFyIGZpbGVJZCA9IHNlbGYuX2dldEZpbGVJZEJ5VXJsKGZpbGVVcmwpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2hhc0ZpbGVJblBvb2woc2l0ZUlkLCBmaWxlSWQpLnRoZW4oZnVuY3Rpb24oZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9RdWV1ZSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmbjtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZU9iamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IGhhdmUgdGhlIGZpbGUsIGFkZCBpdCB0byB0aGUgcXVldWUsIGFuZCByZXR1cm4gcmVhbCBVUkwuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkVG9RdWV1ZUJ5VXJsKHNpdGVJZCwgZmlsZVVybCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgdGltZW1vZGlmaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBmaWxlVXJsO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLl9pc0ZpbGVPdXRkYXRlZChmaWxlT2JqZWN0LCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKSAmJiAkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSBpcyBvdXRkYXRlZCwgd2UgYWRkIHRvIHRoZSBxdWV1ZSBhbmQgcmV0dXJuIHJlYWwgVVJMLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZFRvUXVldWVCeVVybChzaXRlSWQsIGZpbGVVcmwsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHRpbWVtb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZmlsZVVybDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHRoZSBmaWxlIGVudHJ5LCBub3cgbG9vayBmb3IgdGhlIGZpbGUgb24gZGlzay5cblxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3NyYycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gc2VsZi5fZ2V0SW50ZXJuYWxTcmNCeUlkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBzZWxmLl9nZXRJbnRlcm5hbFVybEJ5SWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGZuKHNpdGVJZCwgZmlsZUlkKS50aGVuKGZ1bmN0aW9uKGludGVybmFsVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQZXJmZWN0LCB0aGUgZmlsZSBpcyBvbiBkaXNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRoZSB0aW1lIGJlaW5nIHdlIGFzc3VtZSB0aGF0IHRoZSBjb21wb25lbnQgbGluayBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbFVybDtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgcHJvYmxlbSBoZXJlLCB3ZSBjb3VsZCBub3QgcmV0cmlldmUgdGhlIGZpbGUgdGhvdWdoIHdlIHRob3VnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGhhZCBpdCwgd2Ugd2lsbCBkZWxldGUgdGhlIGVudHJpZXMgYXNzb2NpYXRlZCB3aXRoIHRoYXQgSUQuXG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdGaWxlICcgKyBmaWxlSWQgKyAnIG5vdCBmb3VuZCBvbiBkaXNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZW1vdmVGaWxlQnlJZChzaXRlSWQsIGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZFRvUXVldWVCeVVybChzaXRlSWQsIGZpbGVVcmwsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHRpbWVtb2RpZmllZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHN0aWxsIGhhdmUgYSBjaGFuY2UgdG8gc2VydmUgdGhlIHJpZ2h0IGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IGhhdmUgdGhlIGZpbGUgaW4gc3RvcmUgeWV0LlxuICAgICAgICAgICAgICAgIHNlbGYuYWRkVG9RdWV1ZUJ5VXJsKHNpdGVJZCwgZmlsZVVybCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgdGltZW1vZGlmaWVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZVVybDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXRoIHRvIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZG9lcyBub3QgY2hlY2sgaWYgdGhlIGZpbGUgZXhpc3RzIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfZ2V0RmlsZVBhdGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcGF0aCB0byB0aGUgZmlsZSByZWxhdGl2ZSB0byBzdG9yYWdlIHJvb3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2dldEZpbGVQYXRoID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUZTLmdldFNpdGVGb2xkZXIoc2l0ZUlkKSArICcvJyArIG1tRmlsZXBvb2xGb2xkZXIgKyAnLycgKyBmaWxlSWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGF0aCB0byBhIGZpbGUgZnJvbSBpdHMgVVJMLlxuICAgICAqXG4gICAgICogVGhpcyBkb2VzIG5vdCBjaGVjayBpZiB0aGUgZmlsZSBleGlzdHMgb3Igbm90LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldEZpbGVQYXRoQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCBUaGUgZmlsZSBVUkwuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBwYXRoIHRvIHRoZSBmaWxlIHJlbGF0aXZlIHRvIHN0b3JhZ2Ugcm9vdC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVQYXRoQnlVcmwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRGaWxlUGF0aChzaXRlSWQsIGZpbGVJZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWxlIHN0YXRlOiBtbUNvcmVEb3dubG9hZGVkLCBtbUNvcmVEb3dubG9hZGluZywgbW1Db3JlTm90RG93bmxvYWRlZCBvciBtbUNvcmVPdXRkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNnZXRGaWxlU3RhdGVCeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgICAgIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsICAgICAgICAgIEZpbGUgVVJMLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW1vZGlmaWVkPTBdIFRoZSB0aW1lIHRoaXMgZmlsZSB3YXMgbW9kaWZpZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBmaWxlIHN0YXRlLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZVN0YXRlQnlVcmwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwsIHRpbWVtb2RpZmllZCkge1xuICAgICAgICB2YXIgZmlsZUlkLFxuICAgICAgICAgICAgcmV2aXNpb247XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgICAgIHRpbWVtb2RpZmllZCA9IHRpbWVtb2RpZmllZCB8fCAwO1xuICAgICAgICAgICAgcmV2aXNpb24gPSBzZWxmLmdldFJldmlzaW9uRnJvbVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgIGZpbGVJZCA9IHNlbGYuX2dldEZpbGVJZEJ5VXJsKGZpbGVVcmwpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5faGFzRmlsZUluUXVldWUoc2l0ZUlkLCBmaWxlSWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1tQ29yZURvd25sb2FkaW5nO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2hhc0ZpbGVJblBvb2woc2l0ZUlkLCBmaWxlSWQpLnRoZW4oZnVuY3Rpb24oZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5faXNGaWxlT3V0ZGF0ZWQoZmlsZU9iamVjdCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtbUNvcmVPdXRkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtbUNvcmVEb3dubG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtbUNvcmVOb3REb3dubG9hZGVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBTUkMgb2YgYSBmaWxlLlxuICAgICAqXG4gICAgICogVGhlIHJldHVybmVkIFVSTCBmcm9tIHRoaXMgbWV0aG9kIGlzIHR5cGljYWxseSB1c2VkIHdpdGggSU1HIHRhZ3MuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX2dldEludGVybmFsU3JjQnlJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCBUaGUgZmlsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIHRoZSBpbnRlcm5hbCBVUkwuIFJlamVjdGVkIG90aGVyd2lzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0SW50ZXJuYWxTcmNCeUlkID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQpIHtcbiAgICAgICAgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1GUy5nZXRGaWxlKHNlbGYuX2dldEZpbGVQYXRoKHNpdGVJZCwgZmlsZUlkKSkudGhlbihmdW5jdGlvbihmaWxlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdG9JbnRlcm5hbFVSTCBzbyBpbWFnZXMgYXJlIGxvYWRlZCBpbiBpT1M4IHVzaW5nIGltZyBIVE1MIHRhZ3MsXG4gICAgICAgICAgICAgICAgLy8gd2l0aCB0b1VSTCB0aGUgT1MgaXMgdW5hYmxlIHRvIGZpbmQgdGhlIGltYWdlIGZpbGVzLlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GUy5nZXRJbnRlcm5hbFVSTChmaWxlRW50cnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbCBVUkwgb2YgYSBmaWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19nZXRJbnRlcm5hbFVybEJ5SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCB0aGUgVVJMLiBSZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2dldEludGVybmFsVXJsQnlJZCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkKSB7XG4gICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tRlMuZ2V0RmlsZShzZWxmLl9nZXRGaWxlUGF0aChzaXRlSWQsIGZpbGVJZCkpLnRoZW4oZnVuY3Rpb24oZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVFbnRyeS50b1VSTCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbCBVUkwgb2YgYSBmaWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19nZXRJbnRlcm5hbFVybEJ5UGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCBUaGUgZmlsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIHRoZSBVUkwuIFJlamVjdGVkIG90aGVyd2lzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0SW50ZXJuYWxVcmxCeVBhdGggPSBmdW5jdGlvbihmaWxlUGF0aCkge1xuICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUZTLmdldEZpbGUoZmlsZVBhdGgpLnRoZW4oZnVuY3Rpb24oZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVFbnRyeS50b1VSTCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGFja2FnZSByZXZpc2lvbiBudW1iZXIgZnJvbSBhIGxpc3Qgb2YgZmlsZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBmaWxlcyBQYWNrYWdlIGZpbGVzLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgIFBhY2thZ2UgcmV2aXNpb24uXG4gICAgICovXG4gICAgc2VsZi5nZXRSZXZpc2lvbkZyb21GaWxlTGlzdCA9IGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICAgIHZhciByZXZpc2lvbiA9IDA7XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZpbGVzLCBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICBpZiAoZmlsZS5maWxldXJsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBzZWxmLmdldFJldmlzaW9uRnJvbVVybChmaWxlLmZpbGV1cmwpO1xuICAgICAgICAgICAgICAgIGlmIChyID4gcmV2aXNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2aXNpb24gPSByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJldmlzaW9uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJldmlzaW9uIG51bWJlciBmcm9tIGEgZmlsZSBVUkwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX2dldFJldmlzaW9uRnJvbVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIGdldCB0aGUgcmV2aXNpb24gbnVtYmVyLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgUmV2aXNpb24gbnVtYmVyLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLmdldFJldmlzaW9uRnJvbVVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IHVybC5tYXRjaChyZXZpc2lvblJlZ2V4KTtcbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgdHlwZW9mIG1hdGNoZXNbMV0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChtYXRjaGVzWzFdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFic29sdXRlIFVSTCB0byB1c2UgaW4gSU1HIHRhZ3MuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0U3JjQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBhYnNvbHV0ZSBVUkwgdG8gdGhlIGZpbGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIGxpbmsgdGhlIGZpbGUgdG8uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb25lbnRJZF0gQW4gSUQgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZF0gVGhlIHRpbWUgdGhpcyBmaWxlIHdhcyBtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIHRoZSBVUkwgdG8gdXNlLiBXaGVuIHJlamVjdGVkLCBub3RoaW5nIGNvdWxkIGJlIGRvbmUsXG4gICAgICogICAgICAgICAgICAgICAgICAgd2hpY2ggbWVhbnMgdGhhdCB5b3Ugc2hvdWxkIG5vdCBldmVuIHVzZSB0aGUgZmlsZVVybCBwYXNzZWQuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhpcyB3aWxsIHJldHVybiBhIFVSTCBwb2ludGluZyB0byB0aGUgY29udGVudCBvZiB0aGUgcmVxdWVzdGVkIFVSTC5cbiAgICAgKiBUaGUgVVJMIHJldHVybmVkIGlzIGNvbXBhdGlibGUgdG8gdXNlIHdpdGggSU1HIHRhZ3MuXG4gICAgICogU2VlIHtAbGluayAkbW1GaWxlcG9vbCNfZ2V0RmlsZVVybEJ5VXJsfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U3JjQnlVcmwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHRpbWVtb2RpZmllZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZ2V0RmlsZVVybEJ5VXJsKHNpdGVJZCwgZmlsZVVybCwgJ3NyYycsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHRpbWVtb2RpZmllZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBwYWNrYWdlIHRpbWVtb2RpZmllZCBmcm9tIGEgbGlzdCBvZiBmaWxlcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNnZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBmaWxlcyBQYWNrYWdlIGZpbGVzLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgIFBhY2thZ2UgdGltZSBtb2RpZmllZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdCA9IGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICAgIHZhciB0aW1lbW9kID0gMDtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goZmlsZXMsIGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgIGlmIChmaWxlLnRpbWVtb2RpZmllZCA+IHRpbWVtb2QpIHtcbiAgICAgICAgICAgICAgICB0aW1lbW9kID0gZmlsZS50aW1lbW9kaWZpZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aW1lbW9kO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFic29sdXRlIFVSTCB0byBhY2Nlc3MgdGhlIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0VXJsQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBhYnNvbHV0ZSBVUkwgdG8gdGhlIGZpbGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIGxpbmsgdGhlIGZpbGUgdG8uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb25lbnRJZF0gQW4gSUQgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZF0gVGhlIHRpbWUgdGhpcyBmaWxlIHdhcyBtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIHRoZSBVUkwgdG8gdXNlLiBXaGVuIHJlamVjdGVkLCBub3RoaW5nIGNvdWxkIGJlIGRvbmUsXG4gICAgICogICAgICAgICAgICAgICAgICAgd2hpY2ggbWVhbnMgdGhhdCB5b3Ugc2hvdWxkIG5vdCBldmVuIHVzZSB0aGUgZmlsZVVybCBwYXNzZWQuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhpcyB3aWxsIHJldHVybiBhIFVSTCBwb2ludGluZyB0byB0aGUgY29udGVudCBvZiB0aGUgcmVxdWVzdGVkIFVSTC5cbiAgICAgKiBUaGUgVVJMIHJldHVybmVkIGlzIGNvbXBhdGlibGUgdG8gdXNlIHdpdGggYSBsb2NhbCBicm93c2VyLlxuICAgICAqIFNlZSB7QGxpbmsgJG1tRmlsZXBvb2wjX2dldEZpbGVVcmxCeVVybH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFVybEJ5VXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCB0aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2dldEZpbGVVcmxCeVVybChzaXRlSWQsIGZpbGVVcmwsICd1cmwnLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCB0aW1lbW9kaWZpZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHdWVzcyB0aGUgZXh0ZW5zaW9uIG9mIGEgZmlsZSBmcm9tIGl0cyBVUkwuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHZlcnkgd2VhayBhbmQgdW5yZWxpYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfZ3Vlc3NFeHRlbnNpb25Gcm9tVXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGZpbGUgVVJMLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGxvd2VyY2FzZWQgZXh0ZW5zaW9uIHdpdGhvdXQgdGhlIGRvdCwgb3IgdW5kZWZpbmVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9ndWVzc0V4dGVuc2lvbkZyb21VcmwgPSBmdW5jdGlvbihmaWxlVXJsKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGZpbGVVcmwuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbjtcblxuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY2FuZGlkYXRlID0gc3BsaXQucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25SZWdleC50ZXN0KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGFsbCB0aGUgZmlsZXMgaW4gYSBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2ludmFsaWRhdGVBbGxGaWxlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgb24gc3VjY2Vzcy4gUmVqZWN0ZWQgb24gZmFpbHVyZS4gSXQgaXMgYWR2aXNlZCB0byBpZ25vcmUgYSBmYWlsdXJlLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEludmFsaWRhdGVzIGFsbCBmaWxlcyBieSBtYXJraW5nIGl0IHN0YWxlLiBTZWUge0BsaW5rICRtbUZpbGVwb29sI2ludmFsaWRhdGVGaWxlQnlVcmx9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQWxsRmlsZXMgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5nZXRBbGwobW1GaWxlcG9vbFN0b3JlKS50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRiLmluc2VydChtbUZpbGVwb29sU3RvcmUsIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBhIGZpbGUgYnkgVVJMLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2ludmFsaWRhdGVGaWxlQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBmaWxlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBvbiBzdWNjZXNzLiBSZWplY3RlZCBvbiBmYWlsdXJlLiBJdCBpcyBhZHZpc2VkIHRvIGlnbm9yZSBhIGZhaWx1cmUuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogSW52YWxpZGF0ZXMgYSBmaWxlIGJ5IG1hcmtpbmcgaXQgc3RhbGUuIEl0IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBxdWV1ZSBhdXRvbWF0aWNhbGx5LFxuICAgICAqIGJ1dCB0aGUgbmV4dCB0aW1lIHRoaXMgZmlsZSB3aWxsIGJlIHJlcXVlc3RlZCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBxdWV1ZS4gVGhpcyBpcyB0byBhbGxvd1xuICAgICAqIGZvciBjYWNoZSBpbnZhbGlkYXRpb24gd2l0aG91dCBuZWNlc3NhcmlseSByZS10cmlnZ2VyaW5nIGRvd25sb2Fkcy5cbiAgICAgKiBZb3UgY2FuIG1hbnVsbHkgY2FsbCB7QGxpbmsgJG1tRmlsZXBvb2wjYWRkVG9RdWV1ZUJ5VXJsfSB0byBjb3VudGVyIHRoaXMgYmVoYXZpb3VyLlxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgd2hlbiBhIGZpbGUgaXMgbWFya2VkIGFzIHN0YWxlLCB0aGUgdXNlciB3aWxsIGJlIHByZXNlbnRlZCB0aGUgc3RhbGUgZmlsZVxuICAgICAqIG9ubHkgaWYgdGhleSBkbyBub3QgaGF2ZSBuZXR3b3JrIGFjY2Vzcy5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVGaWxlQnlVcmwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRiLmdldChtbUZpbGVwb29sU3RvcmUsIGZpbGVJZCkudGhlbihmdW5jdGlvbihmaWxlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkbywgd2UgZG8gbm90IGhhdmUgdGhlIGZpbGUgaW4gc3RvcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmlsZU9iamVjdC5zdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQobW1GaWxlcG9vbFN0b3JlLCBmaWxlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBhbGwgdGhlIG1hdGNoaW5nIGZpbGVzIGZyb20gYSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjaW52YWxpZGF0ZUZpbGVzQnlDb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgb24gc3VjY2Vzcy4gUmVqZWN0ZWQgb24gZmFpbHVyZS4gSXQgaXMgYWR2aXNlZCB0byBpZ25vcmUgYSBmYWlsdXJlLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEludmFsaWRhdGVzIGEgZmlsZSBieSBtYXJraW5nIGl0IHN0YWxlLiBTZWUge0BsaW5rICRtbUZpbGVwb29sI2ludmFsaWRhdGVGaWxlQnlVcmx9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlRmlsZXNCeUNvbXBvbmVudCA9IGZ1bmN0aW9uKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geyBzdGFsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgd2hlcmU7XG4gICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aGVyZSA9IFsnY29tcG9uZW50QW5kSWQnLCAnPScsIFtjb21wb25lbnQsIHNlbGYuX2ZpeENvbXBvbmVudElkKGNvbXBvbmVudElkKV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlcmUgPSBbJ2NvbXBvbmVudCcsICc9JywgY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGIucXVlcnkobW1GaWxlcG9vbExpbmtzU3RvcmUsIHdoZXJlKS50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IGRiLmdldChtbUZpbGVwb29sU3RvcmUsIGl0ZW0uZmlsZUlkKS50aGVuKGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlRW50cnkuc3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLmluc2VydChtbUZpbGVwb29sU3RvcmUsIGZpbGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgZmlsZSBpcyBkb3dubG9hZGluZy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNpc0ZpbGVEb3dubG9hZGluZ0J5VXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgICAgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgICAgICAgICAgRmlsZSBVUkwuXG4gICAgICogQHBhcmFtIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCBpZiBmaWxlIGlzIGRvd25sb2FkaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc0ZpbGVEb3dubG9hZGluZ0J5VXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9maXhQbHVnaW5maWxlVVJMKHNpdGVJZCwgZmlsZVVybCkudGhlbihmdW5jdGlvbihmaWxlVXJsKSB7XG4gICAgICAgICAgICBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9oYXNGaWxlSW5RdWV1ZShzaXRlSWQsIGZpbGVJZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGZpbGUgaXMgb3V0ZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX2lzRmlsZU91dGRhdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGVPYmplY3QgICAgIEZpbGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmV2aXNpb25dICAgICBGaWxlIHJldmlzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZF0gVGhlIHRpbWUgdGhpcyBmaWxlIHdhcyBtb2RpZmllZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgICAgICAgVHJ1ZSBpZiBmaWxlIGlzIG91dGRhdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5faXNGaWxlT3V0ZGF0ZWQgPSBmdW5jdGlvbihmaWxlT2JqZWN0LCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKSB7XG4gICAgICAgIHJldHVybiBmaWxlT2JqZWN0LnN0YWxlIHx8IHJldmlzaW9uID4gZmlsZU9iamVjdC5yZXZpc2lvbiB8fCB0aW1lbW9kaWZpZWQgPiBmaWxlT2JqZWN0LnRpbWVtb2RpZmllZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IGEgZmlsZSBoYXMgYmVlbiBkb3dubG9hZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19ub3RpZnlGaWxlRG93bmxvYWRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCBUaGUgZmlsZSBJRC5cbiAgICAgKi9cbiAgICBzZWxmLl9ub3RpZnlGaWxlRG93bmxvYWRlZCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkKSB7XG4gICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKHNlbGYuX2dldEZpbGVFdmVudE5hbWUoc2l0ZUlkLCBmaWxlSWQpLCB7c3VjY2VzczogdHJ1ZX0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgZXJyb3Igb2NjdXJyZWQgd2hpbGUgZG93bmxvYWRpbmcgYSBmaWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19ub3RpZnlGaWxlRG93bmxvYWRFcnJvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCBUaGUgZmlsZSBJRC5cbiAgICAgKi9cbiAgICBzZWxmLl9ub3RpZnlGaWxlRG93bmxvYWRFcnJvciA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkKSB7XG4gICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKHNlbGYuX2dldEZpbGVFdmVudE5hbWUoc2l0ZUlkLCBmaWxlSWQpLCB7c3VjY2VzczogZmFsc2V9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlZmV0Y2hlcyBhIGxpc3Qgb2YgZmlsZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjcHJlZmV0Y2hQYWNrYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSAge09iamVjdFtdfSBmaWxlTGlzdCAgICBMaXN0IG9mIGZpbGVzIHRvIGRvd25sb2FkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgICAgICBUaGUgY29tcG9uZW50IHRvIGxpbmsgdGhlIGZpbGUgdG8uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbXBvbmVudElkICAgIEFuIElEIHRvIGlkZW50aWZ5IHRoZSBkb3dubG9hZC4gTXVzdCBiZSB1bmlxdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXZpc2lvbl0gICAgIFBhY2thZ2UncyByZXZpc2lvbi4gSWYgbm90IGRlZmluZWQsIGl0IHdpbGwgYmUgY2FsY3VsYXRlZCB1c2luZyB0aGUgbGlzdCBvZiBmaWxlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZF0gUGFja2FnZSdzIHRpbWVtb2RpZmllZC4gSWYgbm90IGRlZmluZWQsIGl0IHdpbGwgYmUgY2FsY3VsYXRlZCB1c2luZyB0aGUgbGlzdCBvZiBmaWxlcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RpclBhdGhdICAgICAgTmFtZSBvZiB0aGUgZGlyZWN0b3J5IHdoZXJlIHRvIHN0b3JlIHRoZSBmaWxlcyAoaW5zaWRlIGZpbGVwb29sIGRpcikuIElmIG5vdCBkZWZpbmVkLCBzdG9yZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlsZXMgZGlyZWN0bHkgaW5zaWRlIHRoZSBmaWxlcG9vbCBmb2xkZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgZmlsZXMgYXJlIGRvd25sb2FkZWQuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaFBhY2thZ2UgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVMaXN0LCBjb21wb25lbnQsIGNvbXBvbmVudElkLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkLCBkaXJQYXRoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9kb3dubG9hZE9yUHJlZmV0Y2hQYWNrYWdlKHNpdGVJZCwgZmlsZUxpc3QsIHRydWUsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQsIGRpclBhdGgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfcHJvY2Vzc1F1ZXVlXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBQcm9jZXNzZXMgdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogVGhpcyBsb29wcyBvdmVyIGl0c2VsZiB0byBrZWVwIG9uIHByb2Nlc3NpbmcgdGhlIHF1ZXVlIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgICAqIFRoZSBxdWV1ZSBwcm9jZXNzIGlzIHNpdGUgYWdub3N0aWMuXG4gICAgICovXG4gICAgc2VsZi5fcHJvY2Vzc1F1ZXVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICAgIGlmIChxdWV1ZVN0YXRlICE9PSBRVUVVRV9SVU5OSU5HKSB7XG4gICAgICAgICAgICAvLyBTaWxlbnRseSBpZ25vcmUsIHRoZSBxdWV1ZSBpcyBvbiBwYXVzZS5cbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChFUlJfUVVFVUVfT05fUEFVU0UpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG5cbiAgICAgICAgfSBlbHNlIGlmICghJG1tRlMuaXNBdmFpbGFibGUoKSB8fCAhJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChFUlJfRlNfT1JfTkVUV09SS19VTkFWQUlMQUJMRSk7XG4gICAgICAgICAgICBwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHNlbGYuX3Byb2Nlc3NJbXBvcnRhbnRRdWV1ZUl0ZW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEFsbCBnb29kLCB3ZSBzY2hlZHVsZSBuZXh0IGV4ZWN1dGlvbi5cbiAgICAgICAgICAgICR0aW1lb3V0KHNlbGYuX3Byb2Nlc3NRdWV1ZSwgbW1GaWxlcG9vbFF1ZXVlUHJvY2Vzc0ludGVydmFsKTtcblxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuXG4gICAgICAgICAgICAvLyBXZSBoYWQgYW4gZXJyb3IsIGluIHdoaWNoIGNhc2Ugd2UgcGF1c2UgdGhlIHByb2Nlc3NpbmcuXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IEVSUl9GU19PUl9ORVRXT1JLX1VOQVZBSUxBQkxFKSB7XG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRmlsZXN5c2VtIG9yIG5ldHdvcmsgdW5hdmFpbGFibGUsIHBhdXNpbmcgcXVldWUgcHJvY2Vzc2luZy4nKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvciA9PT0gRVJSX1FVRVVFX0lTX0VNUFRZKSB7XG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnUXVldWUgaXMgZW1wdHksIHBhdXNpbmcgcXVldWUgcHJvY2Vzc2luZy4nKTtcbiAgICAgICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbUNvcmVFdmVudFF1ZXVlRW1wdHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxdWV1ZVN0YXRlID0gUVVFVUVfUEFVU0VEO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgbW9zdCBpbXBvcnRhbnQgcXVldWUgaXRlbS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfcHJvY2Vzc0ltcG9ydGFudFF1ZXVlSXRlbVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIG9uIHN1Y2Nlc3MuIFJlamVjdGVkIG9uIGZhaWx1cmUuXG4gICAgICovXG4gICAgc2VsZi5fcHJvY2Vzc0ltcG9ydGFudFF1ZXVlSXRlbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkucXVlcnkobW1GaWxlcG9vbFF1ZXVlU3RvcmUsIHVuZGVmaW5lZCwgJ3NvcnRvcmRlcicsIHVuZGVmaW5lZCwgMSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXMucG9wKCk7XG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KEVSUl9RVUVVRV9JU19FTVBUWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fcHJvY2Vzc1F1ZXVlSXRlbShpdGVtKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KEVSUl9RVUVVRV9JU19FTVBUWSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgcXVldWUgaXRlbS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfcHJvY2Vzc1F1ZXVlSXRlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBvYmplY3QgZnJvbSB0aGUgcXVldWUgc3RvcmUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgb24gc3VjY2Vzcy4gUmVqZWN0ZWQgb24gZmFpbHVyZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fcHJvY2Vzc1F1ZXVlSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHNpdGVJZCA9IGl0ZW0uc2l0ZUlkLFxuICAgICAgICAgICAgZmlsZUlkID0gaXRlbS5maWxlSWQsXG4gICAgICAgICAgICBmaWxlVXJsID0gaXRlbS51cmwsXG4gICAgICAgICAgICByZXZpc2lvbiA9IGl0ZW0ucmV2aXNpb24sXG4gICAgICAgICAgICB0aW1lbW9kaWZpZWQgPSBpdGVtLnRpbWVtb2RpZmllZCxcbiAgICAgICAgICAgIGZpbGVQYXRoID0gaXRlbS5wYXRoLFxuICAgICAgICAgICAgbGlua3MgPSBpdGVtLmxpbmtzIHx8IFtdO1xuXG4gICAgICAgICRsb2cuZGVidWcoJ1Byb2Nlc3NpbmcgcXVldWUgaXRlbTogJyArIHNpdGVJZCArICcsICcgKyBmaWxlSWQpO1xuICAgICAgICByZXR1cm4gZ2V0U2l0ZURiKHNpdGVJZCkudGhlbihmdW5jdGlvbihkYikge1xuICAgICAgICAgICAgcmV0dXJuIGRiLmdldChtbUZpbGVwb29sU3RvcmUsIGZpbGVJZCkudGhlbihmdW5jdGlvbihmaWxlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVPYmplY3QgJiYgIXNlbGYuX2lzRmlsZU91dGRhdGVkKGZpbGVPYmplY3QsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZpbGUsIGl0IGlzIG5vdCBzdGFsZSwgd2UgY2FuIHVwZGF0ZSBsaW5rcyBhbmQgcmVtb3ZlIGZyb20gcXVldWUuXG4gICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1F1ZXVlZCBmaWxlIGFscmVhZHkgaW4gc3RvcmUsIGlnbm9yaW5nLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZEZpbGVMaW5rcyhzaXRlSWQsIGZpbGVJZCwgbGlua3MpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZW1vdmVGcm9tUXVldWUoc2l0ZUlkLCBmaWxlSWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90cmVhdFF1ZXVlRGVmZXJyZWQoc2l0ZUlkLCBmaWxlSWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbm90aWZ5RmlsZURvd25sb2FkZWQoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIGRvZXMgbm90IGV4aXN0LCBvciBpcyBzdGFsZSwgLi4uIGRvd25sb2FkIGl0LlxuICAgICAgICAgICAgICAgIHJldHVybiBkb3dubG9hZChzaXRlSWQsIGZpbGVVcmwsIGZpbGVPYmplY3QsIGxpbmtzKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIGRvZXMgbm90IGV4aXN0LCBkb3dubG9hZCBpdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gZG93bmxvYWQoc2l0ZUlkLCBmaWxlVXJsLCB1bmRlZmluZWQsIGxpbmtzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIENvdWxkbid0IGdldCBzaXRlIERCLCBzaXRlIHdhcyBwcm9iYWJseSBkZWxldGVkLlxuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnSXRlbSBkcm9wcGVkIGZyb20gcXVldWUgZHVlIHRvIHNpdGUgREIgbm90IHJldHJpZXZlZDogJyArIGZpbGVVcmwpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3JlbW92ZUZyb21RdWV1ZShzaXRlSWQsIGZpbGVJZCkuY2F0Y2goZnVuY3Rpb24oKSB7fSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl90cmVhdFF1ZXVlRGVmZXJyZWQoc2l0ZUlkLCBmaWxlSWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9ub3RpZnlGaWxlRG93bmxvYWRFcnJvcihzaXRlSWQsIGZpbGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvd25sb2FkIGhlbHBlciB0byBhdm9pZCBjb2RlIGR1cGxpY2F0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZG93bmxvYWQoc2l0ZUlkLCBmaWxlVXJsLCBmaWxlT2JqZWN0LCBsaW5rcykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2Rvd25sb2FkRm9yUG9vbEJ5VXJsKHNpdGVJZCwgZmlsZVVybCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCwgZmlsZVBhdGgsIGZpbGVPYmplY3QpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzLCB3ZSBhZGQgbGlua3MgYW5kIHJlbW92ZSBmcm9tIHF1ZXVlLlxuICAgICAgICAgICAgICAgIHNlbGYuX2FkZEZpbGVMaW5rcyhzaXRlSWQsIGZpbGVJZCwgbGlua3MpO1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSBzZWxmLl9yZW1vdmVGcm9tUXVldWUoc2l0ZUlkLCBmaWxlSWQpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fdHJlYXRRdWV1ZURlZmVycmVkKHNpdGVJZCwgZmlsZUlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9ub3RpZnlGaWxlRG93bmxvYWRlZChzaXRlSWQsIGZpbGVJZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgaXRlbSB0byBiZSByZW1vdmVkIGZyb20gcXVldWUgYmVmb3JlIHJlc29sdmluZyB0aGUgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaXRlbSBjb3VsZCBub3QgYmUgcmVtb3ZlZCBmcm9tIHF1ZXVlIHdlIHN0aWxsIHJlc29sdmUgdGhlIHByb21pc2UuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuY2F0Y2goZnVuY3Rpb24oKSB7fSk7XG5cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gV2hvb3BzLCB3ZSBoYXZlIGFuIGVycm9yLi4uXG4gICAgICAgICAgICAgICAgdmFyIGRyb3BGcm9tUXVldWUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3JPYmplY3QgIT09ICd1bmRlZmluZWQnICYmIGVycm9yT2JqZWN0LnNvdXJjZSA9PT0gZmlsZVVybCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG1vc3QgbGlrZWx5IGEgJGNvcmRvdmFGaWxlVHJhbnNmZXIgZXJyb3IuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yT2JqZWN0LmNvZGUgPT09IDEpIHsgLy8gRklMRV9OT1RfRk9VTkRfRVJSLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpbGUgd2FzIG5vdCBmb3VuZCwgbW9zdCBsaWtlbHkgYSA0MDQsIHdlIHJlbW92ZSBmcm9tIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEZyb21RdWV1ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvck9iamVjdC5jb2RlID09PSAyKSB7IC8vIElOVkFMSURfVVJMX0VSUi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBVUkwgaXMgaW52YWxpZCwgd2UgZHJvcCB0aGUgZmlsZSBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BGcm9tUXVldWUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JPYmplY3QuY29kZSA9PT0gMykgeyAvLyBDT05ORUNUSU9OX0VSUi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBIVFRQIHN0YXR1cywgdGhlbiBsZXQncyByZW1vdmUgZnJvbSB0aGUgcXVldWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wRnJvbVF1ZXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvck9iamVjdC5jb2RlID09PSA0KSB7IC8vIEFCT1JURURfRVJSLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRyYW5zZmVyIHdhcyBhYm9ydGVkLCB3ZSB3aWxsIGtlZXAgdGhlIGZpbGUgaW4gcXVldWUuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JPYmplY3QuY29kZSA9PT0gNSkgeyAvLyBOT1RfTU9ESUZJRURfRVJSLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgdGhlIGZpbGUsIEhUVFAgMzA0IHN0YXR1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BGcm9tUXVldWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5rbm93biBlcnJvciwgbGV0J3MgcmVtb3ZlIHRoZSBmaWxlIGZyb20gdGhlIHF1ZXVlIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2NraW5nIGRvd24gdGhlIHF1ZXVlIGJlY2F1c2Ugb2Ygb25lIGZpbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wRnJvbVF1ZXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BGcm9tUXVldWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkcm9wRnJvbVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0l0ZW0gZHJvcHBlZCBmcm9tIHF1ZXVlIGR1ZSB0byBlcnJvcjogJyArIGZpbGVVcmwpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gc2VsZi5fcmVtb3ZlRnJvbVF1ZXVlKHNpdGVJZCwgZmlsZUlkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlciB0aGlzIGFzIGEgc2lsZW50IGVycm9yLCBuZXZlciByZWplY3QgdGhlIHByb21pc2UgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuY2F0Y2goZnVuY3Rpb24oKSB7fSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyZWF0UXVldWVEZWZlcnJlZChzaXRlSWQsIGZpbGVJZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbm90aWZ5RmlsZURvd25sb2FkRXJyb3Ioc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjb25zaWRlcmVkIHRoZSBmaWxlIGFzIGxlZ2l0IGJ1dCBkaWQgbm90IGdldCBpdCwgZmFpbHVyZS5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJlYXRRdWV1ZURlZmVycmVkKHNpdGVJZCwgZmlsZUlkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX25vdGlmeUZpbGVEb3dubG9hZEVycm9yKHNpdGVJZCwgZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBwcm9ncmVzcyBvYmplY3QgdG8gdGhlIHF1ZXVlIGRlZmVycmVkLlxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZURlZmVycmVkc1tzaXRlSWRdICYmIHF1ZXVlRGVmZXJyZWRzW3NpdGVJZF1bZmlsZUlkXSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZURlZmVycmVkc1tzaXRlSWRdW2ZpbGVJZF0ubm90aWZ5KHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGZpbGUgZnJvbSB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX3JlbW92ZUZyb21RdWV1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCBUaGUgZmlsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBvbiBzdWNjZXNzLiBSZWplY3RlZCBvbiBmYWlsdXJlLiBJdCBpcyBhZHZpc2VkIHRvIHNpbGVudGx5IGlnbm9yZSBmYWlsdXJlcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fcmVtb3ZlRnJvbVF1ZXVlID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLnJlbW92ZShtbUZpbGVwb29sUXVldWVTdG9yZSwgW3NpdGVJZCwgZmlsZUlkXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGZpbGUgZnJvbSB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfcmVtb3ZlRmlsZUJ5SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgb24gc3VjY2Vzcy4gUmVqZWN0ZWQgb24gZmFpbHVyZS4gSXQgaXMgYWR2aXNlZCB0byBzaWxlbnRseSBpZ25vcmUgZmFpbHVyZXMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX3JlbW92ZUZpbGVCeUlkID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHZhciBwMSwgcDIsIHAzO1xuICAgICAgICAgICAgcDEgPSBkYi5yZW1vdmUobW1GaWxlcG9vbFN0b3JlLCBmaWxlSWQpO1xuICAgICAgICAgICAgcDIgPSBkYi53aGVyZShtbUZpbGVwb29sTGlua3NTdG9yZSwgJ2ZpbGVJZCcsICc9JywgZmlsZUlkKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEuYWxsKGVudHJpZXMubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYi5yZW1vdmUobW1GaWxlcG9vbExpbmtzU3RvcmUsIFtlbnRyeS5maWxlSWQsIGVudHJ5LmNvbXBvbmVudCwgZW50cnkuY29tcG9uZW50SWRdKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHAzID0gJG1tRlMuaXNBdmFpbGFibGUoKSA/ICRtbUZTLnJlbW92ZUZpbGUoc2VsZi5fZ2V0RmlsZVBhdGgoc2l0ZUlkLCBmaWxlSWQpKSA6ICRxLndoZW4oKTtcbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwoW3AxLCBwMiwgcDNdKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbGwgdGhlIG1hdGNoaW5nIGZpbGVzIGZyb20gYSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjcmVtb3ZlRmlsZXNCeUNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgICAgIFRoZSBjb21wb25lbnQgdG8gbGluayB0aGUgZmlsZSB0by5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvbmVudElkXSBBbiBJRCB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgIFJlc29sdmVkIG9uIHN1Y2Nlc3MuIFJlamVjdGVkIG9uIGZhaWx1cmUuXG4gICAgICovXG4gICAgc2VsZi5yZW1vdmVGaWxlc0J5Q29tcG9uZW50ID0gZnVuY3Rpb24oc2l0ZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkKSB7XG4gICAgICAgIHZhciB3aGVyZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdoZXJlID0gWydjb21wb25lbnRBbmRJZCcsICc9JywgW2NvbXBvbmVudCwgc2VsZi5fZml4Q29tcG9uZW50SWQoY29tcG9uZW50SWQpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVyZSA9IFsnY29tcG9uZW50JywgJz0nLCBjb21wb25lbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5xdWVyeShtbUZpbGVwb29sTGlua3NTdG9yZSwgd2hlcmUpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKGl0ZW1zLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3JlbW92ZUZpbGVCeUlkKHNpdGVJZCwgaXRlbS5maWxlSWQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZmlsZSBmcm9tIHRoZSBwb29sLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI3JlbW92ZUZpbGVCeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBmaWxlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBSZXNvbHZlZCBvbiBzdWNjZXNzLCByZWplY3RlZCBvbiBmYWlsdXJlLiBJdCBpcyBhZHZpc2VkIHRvIHNpbGVudGx5IGlnbm9yZSBmYWlsdXJlcy5cbiAgICAgKi9cbiAgICBzZWxmLnJlbW92ZUZpbGVCeVVybCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZVVybCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZml4UGx1Z2luZmlsZVVSTChzaXRlSWQsIGZpbGVVcmwpLnRoZW4oZnVuY3Rpb24oZmlsZVVybCkge1xuICAgICAgICAgICAgdmFyIGZpbGVJZCA9IHNlbGYuX2dldEZpbGVJZEJ5VXJsKGZpbGVVcmwpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3JlbW92ZUZpbGVCeUlkKHNpdGVJZCwgZmlsZUlkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHJldmlzaW9uIG51bWJlciBmcm9tIGEgZmlsZSBVUkwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX3JlbW92ZVJldmlzaW9uRnJvbVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIHJlbW92ZSB0aGUgcmV2aXNpb24gbnVtYmVyLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgVVJMIHdpdGhvdXQgcmV2aXNpb24gbnVtYmVyLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgcmV2aXNpb24gaXMgdXNlZCB0byBrbm93IGlmIGEgZmlsZSBoYXMgY2hhbmdlZC4gV2UgcmVtb3ZlIGl0IGZyb20gdGhlIFVSTCB0byBwcmV2ZW50IHN0b3JpbmcgYSBmaWxlIHBlciByZXZpc2lvbi5cbiAgICAgKi9cbiAgICBzZWxmLl9yZW1vdmVSZXZpc2lvbkZyb21VcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKHJldmlzaW9uUmVnZXgsICcvY29udGVudC8wLycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIHBhY2thZ2Ugc3RhdHVzLCBzZXR0aW5nIGl0IHRvIHRoZSBwcmV2aW91cyBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjc2V0UGFja2FnZVByZXZpb3VzU3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgICBQYWNrYWdlJ3MgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBzdGF0dXMgaXMgY2hhbmdlZC4gUmVzb2x2ZSBwYXJhbTogbmV3IHN0YXR1cy5cbiAgICAgKi9cbiAgICBzZWxmLnNldFBhY2thZ2VQcmV2aW91c1N0YXR1cyA9IGZ1bmN0aW9uKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCkge1xuICAgICAgICAkbG9nLmRlYnVnKCdTZXQgcHJldmlvdXMgc3RhdHVzIGZvciBwYWNrYWdlICcgKyBjb21wb25lbnQgKyAnICcgKyBjb21wb25lbnRJZCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdmFyIGRiID0gc2l0ZS5nZXREYigpLFxuICAgICAgICAgICAgICAgIHBhY2thZ2VJZCA9IHNlbGYuZ2V0UGFja2FnZUlkKGNvbXBvbmVudCwgY29tcG9uZW50SWQpO1xuXG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBzdG9yZWQgZGF0YSwgd2UnbGwgb25seSB1cGRhdGUgJ3N0YXR1cycgYW5kICd1cGRhdGVkJyBmaWVsZHMuXG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0KG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlLCBwYWNrYWdlSWQpLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5zdGF0dXMgPSBlbnRyeS5wcmV2aW91cyB8fCBtbUNvcmVOb3REb3dubG9hZGVkO1xuICAgICAgICAgICAgICAgIGVudHJ5LnVwZGF0ZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdTZXQgc3RhdHVzIFxcJycgKyBlbnRyeS5zdGF0dXMgKyAnXFwnIGZvciBwYWNrYWdlICcgKyBjb21wb25lbnQgKyAnICcgKyBjb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlLCBlbnRyeSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2VzcyB1cGRhdGluZywgdHJpZ2dlciBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJpZ2dlclBhY2thZ2VTdGF0dXNDaGFuZ2VkKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgZW50cnkuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnN0YXR1cztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgcGFja2FnZSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjc3RvcmVQYWNrYWdlU3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgICAgICBQYWNrYWdlJ3MgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdICAgIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXR1cyAgICAgICAgICAgTmV3IHBhY2thZ2Ugc3RhdHVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmV2aXNpb249MF0gICAgIFBhY2thZ2UncyByZXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZD0wXSBQYWNrYWdlJ3MgdGltZW1vZGlmaWVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBzdGF0dXMgaXMgc3RvcmVkLlxuICAgICAqL1xuICAgIHNlbGYuc3RvcmVQYWNrYWdlU3RhdHVzID0gZnVuY3Rpb24oc2l0ZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCBzdGF0dXMsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnU2V0IHN0YXR1cyBcXCcnICsgc3RhdHVzICsgJ1xcJyBmb3IgcGFja2FnZSAnICsgY29tcG9uZW50ICsgJyAnICsgY29tcG9uZW50SWQpO1xuICAgICAgICByZXZpc2lvbiA9IHJldmlzaW9uIHx8IDA7XG4gICAgICAgIHRpbWVtb2RpZmllZCA9IHRpbWVtb2RpZmllZCB8fCAwO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdmFyIGRiID0gc2l0ZS5nZXREYigpLFxuICAgICAgICAgICAgICAgIHBhY2thZ2VJZCA9IHNlbGYuZ2V0UGFja2FnZUlkKGNvbXBvbmVudCwgY29tcG9uZW50SWQpO1xuXG4gICAgICAgICAgICAvLyBTZWFyY2ggY3VycmVudCBzdGF0dXMgdG8gc2V0IGl0IGFzIHByZXZpb3VzIHN0YXR1cy5cbiAgICAgICAgICAgIHJldHVybiBkYi5nZXQobW1GaWxlcG9vbFBhY2thZ2VzU3RvcmUsIHBhY2thZ2VJZCkudGhlbihmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5zdGF0dXM7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBObyBwcmV2aW91cyBzdGF0dXMuXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHByZXZpb3VzU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdHVzID09PSBzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHBhY2thZ2UgYWxyZWFkeSBoYXMgdGhpcyBzdGF0dXMsIG5vIG5lZWQgdG8gY2hhbmdlIGl0LlxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBkYi5pbnNlcnQobW1GaWxlcG9vbFBhY2thZ2VzU3RvcmUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwYWNrYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudElkOiBjb21wb25lbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2aXNpb246IHJldmlzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkOiB0aW1lbW9kaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzIGluc2VydGluZywgdHJpZ2dlciBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJpZ2dlclBhY2thZ2VTdGF0dXNDaGFuZ2VkKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgb3IgcmVqZWN0cyBhIHF1ZXVlIGRlZmVycmVkIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX3RyZWF0UXVldWVEZWZlcnJlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZUlkICAgVGhlIGZpbGUgSUQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXNvbHZlIFRydWUgaWYgcHJvbWlzZSBzaG91bGQgYmUgcmVzb2x2ZWQsIGZhbHNlIGlmIGl0IHNob3VsZCBiZSByZWplY3RlZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgRGVmZXJyZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX3RyZWF0UXVldWVEZWZlcnJlZCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkLCByZXNvbHZlKSB7XG4gICAgICAgIGlmIChxdWV1ZURlZmVycmVkc1tzaXRlSWRdICYmIHF1ZXVlRGVmZXJyZWRzW3NpdGVJZF1bZmlsZUlkXSkge1xuICAgICAgICAgICAgaWYgKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZURlZmVycmVkc1tzaXRlSWRdW2ZpbGVJZF0ucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZURlZmVycmVkc1tzaXRlSWRdW2ZpbGVJZF0ucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgcXVldWVEZWZlcnJlZHNbc2l0ZUlkXVtmaWxlSWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgbW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCB3aXRoIHRoZSByaWdodCBkYXRhLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI190cmlnZ2VyUGFja2FnZVN0YXR1c0NoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgICAgIFBhY2thZ2UncyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb25lbnRJZF0gQW4gSUQgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdHVzICAgICAgICBOZXcgcGFja2FnZSBzdGF0dXMuXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fdHJpZ2dlclBhY2thZ2VTdGF0dXNDaGFuZ2VkID0gZnVuY3Rpb24oc2l0ZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCBzdGF0dXMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBzaXRlaWQ6IHNpdGVJZCxcbiAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgY29tcG9uZW50SWQ6IGNvbXBvbmVudElkLFxuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXNcbiAgICAgICAgfTtcbiAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCwgZGF0YSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSlcblxuLnJ1bihmdW5jdGlvbigkbG9nLCAkaW9uaWNQbGF0Zm9ybSwgJHRpbWVvdXQsICRtbUZpbGVwb29sKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUZpbGVwb29sJyk7XG5cbiAgICAkaW9uaWNQbGF0Zm9ybS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gV2FpdGluZyBmb3IgdGhlIHBsYXRmb3JtIHRvIGJlIHJlYWR5LCBhbmQgYSBmZXcgbW9yZSBiZWZvcmUgd2Ugc3RhcnQgcHJvY2Vzc2luZyB0aGUgcXVldWUuXG4gICAgICAgICR0aW1lb3V0KCRtbUZpbGVwb29sLmNoZWNrUXVldWVQcm9jZXNzaW5nLCAxMDAwKTtcbiAgICB9KTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4uY29uc3RhbnQoJ21tRnNTaXRlc0ZvbGRlcicsICdzaXRlcycpXG4uY29uc3RhbnQoJ21tRnNUbXBGb2xkZXInLCAndG1wJylcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tRlNcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHNlcnZpY2UgaGFuZGxlcyB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgRmlsZVN5c3RlbS5cbiAqL1xuLmZhY3RvcnkoJyRtbUZTJywgZnVuY3Rpb24oJGlvbmljUGxhdGZvcm0sICRjb3Jkb3ZhRmlsZSwgJGxvZywgJHEsICRodHRwLCAkY29yZG92YVppcCwgbW1Gc1NpdGVzRm9sZGVyLCBtbUZzVG1wRm9sZGVyKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tRlMnKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGluaXRpYWxpemVkID0gZmFsc2UsXG4gICAgICAgIGJhc2VQYXRoID0gJycsXG4gICAgICAgIGlzSFRNTEFQSSA9IGZhbHNlLFxuICAgICAgICBtaW1lVHlwZXMgPSB7fTtcblxuICAgIC8vIExvYWRpbmcgYWxsIHRoZSBtaW1ldHlwZXMuXG4gICAgJGh0dHAuZ2V0KCdjb3JlL2Fzc2V0cy9taW1ldHlwZXMuanNvbicpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgbWltZVR5cGVzID0gcmVzcG9uc2UuZGF0YTtcbiAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSXQgZmFpbGVkLCBuZXZlciBtaW5kLi4uXG4gICAgfSk7XG5cbiAgICAvLyBGb3JtYXRzIHRvIHJlYWQgYSBmaWxlLlxuICAgIHNlbGYuRk9STUFUVEVYVCAgICAgICAgID0gMDtcbiAgICBzZWxmLkZPUk1BVERBVEFVUkwgICAgICA9IDE7XG4gICAgc2VsZi5GT1JNQVRCSU5BUllTVFJJTkcgPSAyO1xuICAgIHNlbGYuRk9STUFUQVJSQVlCVUZGRVIgID0gMztcblxuICAgIC8qKlxuICAgICAqIFNldHMgYmFzZVBhdGggdG8gdXNlIHdpdGggSFRNTCBBUEkuIFJlc2VydmVkIGZvciBjb3JlIHVzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNzZXRIVE1MQmFzZVBhdGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBCYXNlIHBhdGggdG8gdXNlLlxuICAgICAqL1xuICAgIHNlbGYuc2V0SFRNTEJhc2VQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBpc0hUTUxBUEkgPSB0cnVlO1xuICAgICAgICBiYXNlUGF0aCA9IHBhdGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB3ZSdyZSB1c2luZyBIVE1MIEFQSS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyN1c2VzSFRNTEFQSVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdXNlcyBIVE1MIEFQSSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYudXNlc0hUTUxBUEkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzSFRNTEFQSTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBiYXNlUGF0aCBiYXNlZCBvbiB0aGUgT1MgaWYgaXQncyBub3QgaW5pdGlhbGl6ZWQgYWxyZWFkeS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNpbml0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBpbml0aWFsaXphdGlvbiBpcyBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBzZWxmLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH1cblxuICAgICAgICAkaW9uaWNQbGF0Zm9ybS5yZWFkeShmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYgKGlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpKSB7XG4gICAgICAgICAgICAgICAgYmFzZVBhdGggPSBjb3Jkb3ZhLmZpbGUuZXh0ZXJuYWxBcHBsaWNhdGlvblN0b3JhZ2VEaXJlY3Rvcnk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlvbmljLlBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgICAgICAgICAgICBiYXNlUGF0aCA9IGNvcmRvdmEuZmlsZS5kb2N1bWVudHNEaXJlY3Rvcnk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzZWxmLmlzQXZhaWxhYmxlKCkgfHwgYmFzZVBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgZ2V0dGluZyBkZXZpY2UgT1MuJyk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdGUyBpbml0aWFsaXplZDogJytiYXNlUGF0aCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcGx1Z2luIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgd2hlbiBjb3Jkb3ZhIGlzIGluaXRpYWxpc2VkLlxuICAgICAqL1xuICAgIHNlbGYuaXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cucmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVVSTCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEZpbGVUcmFuc2ZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjZ2V0RmlsZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHBhdGggUmVsYXRpdmUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRGaWxlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0dldCBmaWxlOiAnK3BhdGgpO1xuICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5jaGVja0ZpbGUoYmFzZVBhdGgsIHBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgZGlyZWN0b3J5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2dldERpclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHBhdGggUmVsYXRpdmUgcGF0aCB0byB0aGUgZGlyZWN0b3J5LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBkaXJlY3RvcnkgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RGlyID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0dldCBkaXJlY3Rvcnk6ICcrcGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLmNoZWNrRGlyKGJhc2VQYXRoLCBwYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBzaXRlIGZvbGRlciBwYXRoLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2dldFNpdGVGb2xkZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCBTaXRlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIFNpdGUgZm9sZGVyIHBhdGguXG4gICAgICovXG4gICAgc2VsZi5nZXRTaXRlRm9sZGVyID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHJldHVybiBtbUZzU2l0ZXNGb2xkZXIgKyAnLycgKyBzaXRlSWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRpcmVjdG9yeSBvciBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpc0RpcmVjdG9yeSAgVHJ1ZSBpZiBhIGRpcmVjdG9yeSBzaG91bGQgYmUgY3JlYXRlZCwgZmFsc2UgaWYgaXQgc2hvdWxkIGNyZWF0ZSBhIGZpbGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgcGF0aCAgICAgICAgIFJlbGF0aXZlIHBhdGggdG8gdGhlIGRpci9maWxlLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGZhaWxJZkV4aXN0cyBUcnVlIGlmIGl0IHNob3VsZCBmYWlsIGlmIHRoZSBkaXIvZmlsZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBiYXNlICAgICAgICAgQmFzZSBwYXRoIHRvIGNyZWF0ZSB0aGUgZGlyL2ZpbGUgaW4uIElmIG5vdCBzZXQsIHVzZSBiYXNlUGF0aC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBkaXIvZmlsZSBpcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpc0RpcmVjdG9yeSwgcGF0aCwgZmFpbElmRXhpc3RzLCBiYXNlKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmluaXQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmFzZSA9IGJhc2UgfHwgYmFzZVBhdGg7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YoJy8nKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdDcmVhdGUgZGlyICcgKyBwYXRoICsgJyBpbiAnICsgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUuY3JlYXRlRGlyKGJhc2UsIHBhdGgsICFmYWlsSWZFeGlzdHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0NyZWF0ZSBmaWxlICcgKyBwYXRoICsgJyBpbiAnICsgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUuY3JlYXRlRmlsZShiYXNlLCBwYXRoLCAhZmFpbElmRXhpc3RzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICRjb3Jkb3ZhRmlsZSBkb2Vzbid0IGFsbG93IGNyZWF0aW5nIG1vcmUgdGhhbiAxIGxldmVsIGF0IGEgdGltZSAoZS5nLiB0bXAvZm9sZGVyKS5cbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSB0aGVtIDEgYnkgMS5cbiAgICAgICAgICAgICAgICB2YXIgZmlyc3REaXIgPSBwYXRoLnN1YnN0cigwLCBwYXRoLmluZGV4T2YoJy8nKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3RPZlBhdGggPSBwYXRoLnN1YnN0cihwYXRoLmluZGV4T2YoJy8nKSArIDEpO1xuXG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ3JlYXRlIGRpciAnICsgZmlyc3REaXIgKyAnIGluICcgKyBiYXNlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUuY3JlYXRlRGlyKGJhc2UsIGZpcnN0RGlyLCB0cnVlKS50aGVuKGZ1bmN0aW9uKG5ld0RpckVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoaXNEaXJlY3RvcnksIHJlc3RPZlBhdGgsIGZhaWxJZkV4aXN0cywgbmV3RGlyRW50cnkudG9VUkwoKSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgY3JlYXRpbmcgZGlyZWN0b3J5ICcgKyBmaXJzdERpciArICcgaW4gJyArIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGlyZWN0b3J5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2NyZWF0ZURpclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHBhdGggICAgICAgICBSZWxhdGl2ZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gZmFpbElmRXhpc3RzIFRydWUgaWYgaXQgc2hvdWxkIGZhaWwgaWYgdGhlIGRpcmVjdG9yeSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBkaXJlY3RvcnkgaXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmNyZWF0ZURpciA9IGZ1bmN0aW9uKHBhdGgsIGZhaWxJZkV4aXN0cykge1xuICAgICAgICBmYWlsSWZFeGlzdHMgPSBmYWlsSWZFeGlzdHMgfHzCoGZhbHNlOyAvLyBEZWZhdWx0IHZhbHVlIGZhbHNlLlxuICAgICAgICByZXR1cm4gY3JlYXRlKHRydWUsIHBhdGgsIGZhaWxJZkV4aXN0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjY3JlYXRlRmlsZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHBhdGggICAgICAgICBSZWxhdGl2ZSBwYXRoIHRvIHRoZSBmaWxlLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGZhaWxJZkV4aXN0cyBUcnVlIGlmIGl0IHNob3VsZCBmYWlsIGlmIHRoZSBmaWxlIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlLi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBmaWxlIGlzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5jcmVhdGVGaWxlID0gZnVuY3Rpb24ocGF0aCwgZmFpbElmRXhpc3RzKSB7XG4gICAgICAgIGZhaWxJZkV4aXN0cyA9IGZhaWxJZkV4aXN0cyB8fMKgZmFsc2U7IC8vIERlZmF1bHQgdmFsdWUgZmFsc2UuXG4gICAgICAgIHJldHVybiBjcmVhdGUoZmFsc2UsIHBhdGgsIGZhaWxJZkV4aXN0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkaXJlY3RvcnkgYW5kIGFsbCBpdHMgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjcmVtb3ZlRGlyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgcGF0aCAgICBSZWxhdGl2ZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGRpcmVjdG9yeSBpcyBkZWxldGVkLlxuICAgICAqL1xuICAgIHNlbGYucmVtb3ZlRGlyID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1JlbW92ZSBkaXJlY3Rvcnk6ICcgKyBwYXRoKTtcbiAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUucmVtb3ZlUmVjdXJzaXZlbHkoYmFzZVBhdGgsIHBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGZpbGUgYW5kIGFsbCBpdHMgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjcmVtb3ZlRmlsZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHBhdGggICAgUmVsYXRpdmUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZSBpcyBkZWxldGVkLlxuICAgICAqL1xuICAgIHNlbGYucmVtb3ZlRmlsZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW5pdCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdSZW1vdmUgZmlsZTogJyArIHBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5yZW1vdmVGaWxlKGJhc2VQYXRoLCBwYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjb250ZW50cyBvZiBhIGRpcmVjdG9yeSAobm90IHN1YmRpcmVjdG9yaWVzKS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNnZXREaXJlY3RvcnlDb250ZW50c1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBSZWxhdGl2ZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgY29udGVudHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldERpcmVjdG9yeUNvbnRlbnRzID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAkbG9nLmRlYnVnKCdHZXQgY29udGVudHMgb2YgZGlyOiAnICsgcGF0aCk7XG4gICAgICAgIHJldHVybiBzZWxmLmdldERpcihwYXRoKS50aGVuKGZ1bmN0aW9uKGRpckVudHJ5KSB7XG5cbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICAgIHZhciBkaXJlY3RvcnlSZWFkZXIgPSBkaXJFbnRyeS5jcmVhdGVSZWFkZXIoKTtcbiAgICAgICAgICAgIGRpcmVjdG9yeVJlYWRlci5yZWFkRW50cmllcyhkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBhIGRpcmVjdG9yeSBvciBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggUmVsYXRpdmUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IG9yIGZpbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgc2l6ZSBpcyBjYWxjdWxhdGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNpemUoZW50cnkpIHtcblxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuXG4gICAgICAgICAgICB2YXIgZGlyZWN0b3J5UmVhZGVyID0gZW50cnkuY3JlYXRlUmVhZGVyKCk7XG4gICAgICAgICAgICBkaXJlY3RvcnlSZWFkZXIucmVhZEVudHJpZXMoZnVuY3Rpb24oZW50cmllcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZ2V0U2l6ZShlbnRyaWVzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKHNpemVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdG9yeVNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZVNpemUgPSBwYXJzZUludChzaXplc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZmlsZVNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5U2l6ZSArPSBmaWxlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGRpcmVjdG9yeVNpemUpO1xuXG4gICAgICAgICAgICAgICAgfSwgZGVmZXJyZWQucmVqZWN0KTtcblxuICAgICAgICAgICAgfSwgZGVmZXJyZWQucmVqZWN0KTtcblxuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICAgICAgZW50cnkuZmlsZShmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShmaWxlLnNpemUpO1xuICAgICAgICAgICAgfSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBhIGRpcmVjdG9yeS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNnZXREaXJlY3RvcnlTaXplXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoIFJlbGF0aXZlIHBhdGggdG8gdGhlIGRpcmVjdG9yeS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXplIGlzIGNhbGN1bGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXREaXJlY3RvcnlTaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAkbG9nLmRlYnVnKCdHZXQgc2l6ZSBvZiBkaXI6ICcgKyBwYXRoKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RGlyKHBhdGgpLnRoZW4oZnVuY3Rpb24oZGlyRW50cnkpIHtcbiAgICAgICAgICAgcmV0dXJuIGdldFNpemUoZGlyRW50cnkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzaXplIG9mIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNnZXRGaWxlU2l6ZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBSZWxhdGl2ZSBwYXRoIHRvIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHNpemUgaXMgY2FsY3VsYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVTaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAkbG9nLmRlYnVnKCdHZXQgc2l6ZSBvZiBmaWxlOiAnICsgcGF0aCk7XG4gICAgICAgIHJldHVybiBzZWxmLmdldEZpbGUocGF0aCkudGhlbihmdW5jdGlvbihmaWxlRW50cnkpIHtcbiAgICAgICAgICAgcmV0dXJuIGdldFNpemUoZmlsZUVudHJ5KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIG9iamVjdCBmcm9tIGEgRmlsZUVudHJ5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2dldEZpbGVTaXplRnJvbUZpbGVFbnRyeVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBSZWxhdGl2ZSBwYXRoIHRvIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHNpemUgaXMgY2FsY3VsYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVPYmplY3RGcm9tRmlsZUVudHJ5ID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnR2V0IGZpbGUgb2JqZWN0IG9mOiAnICsgZW50cnkuZnVsbFBhdGgpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICBlbnRyeS5maWxlKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZmlsZSk7XG4gICAgICAgIH0sIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZyZWUgc3BhY2UgaW4gdGhlIGRpc2suXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjY2FsY3VsYXRlRnJlZVNwYWNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBlc3RpbWF0ZWQgZnJlZSBzcGFjZSBpbiBieXRlcy5cbiAgICAgKi9cbiAgICBzZWxmLmNhbGN1bGF0ZUZyZWVTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNJT1MoKSB8fCBpc0hUTUxBUEkpIHtcbiAgICAgICAgICAgIC8vIGdldEZyZWVEaXNrU3BhY2UgZG9lc24ndCB3b3JrIG9uIGlPUy4gU2VlIGh0dHBzOi8vdHJhY2tlci5tb29kbGUub3JnL2Jyb3dzZS9NT0JJTEUtOTU2LlxuICAgICAgICAgICAgLy8gVWdseSBmaXg6IHJlcXVlc3QgYSBmaWxlIHN5c3RlbSBpbnN0YW5jZSB3aXRoIGEgbWluaW11bSBzaXplIHVudGlsIHdlIGdldCBhbiBlcnJvci5cblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwLFxuICAgICAgICAgICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gNTAsXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUJ5UmVxdWVzdChzaXplLCByYXRpbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbShMb2NhbEZpbGVTeXN0ZW0uUEVSU0lTVEVOVCwgc2l6ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9ucyA+IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUJ5UmVxdWVzdChzaXplICogcmF0aW8sIHJhdGlvKS50aGVuKGRlZmVycmVkLnJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2l6ZSAvIHJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYWwgY2FsY3VsYXRpb24sIGJhc2UgMU1CIGFuZCBpbmNyZWFzaW5nIGZhY3RvciAxLjMuXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlQnlSZXF1ZXN0KDEwNDg1NzYsIDEuMykudGhlbihmdW5jdGlvbihzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gMTA7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vcmUgYWNjdXJhdGUuIEZhY3RvciBpcyAxLjEuXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUJ5UmVxdWVzdChzaXplLCAxLjEpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLmdldEZyZWVEaXNrU3BhY2UoKS50aGVuKGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZSAqIDEwMjQ7IC8vIEdldEZyZWVEaXNrU3BhY2UgcmV0dXJucyBLQi5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhIGZpbGVuYW1lIHRoYXQgdXN1YWxseSBjb21lcyBVUkwgZW5jb2RlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNub3JtYWxpemVGaWxlTmFtZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZW5hbWUgVGhlIGZpbGUgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIFRoZSBmaWxlIG5hbWUgbm9ybWFsaXplZC5cbiAgICAgKi9cbiAgICBzZWxmLm5vcm1hbGl6ZUZpbGVOYW1lID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICAgICAgZmlsZW5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBmaWxlIGZyb20gbG9jYWwgZmlsZSBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjcmVhZEZpbGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBwYXRoICAgUmVsYXRpdmUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBmb3JtYXQgRm9ybWF0IHRvIHJlYWQgdGhlIGZpbGUuIEJ5IGRlZmF1bHQsIEZPUk1BVFRFWFQuIE11c3QgYmUgb25lIG9mOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUZTLkZPUk1BVFRFWFRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1GUy5GT1JNQVREQVRBVVJMXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tRlMuRk9STUFUQklOQVJZU1RSSU5HXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tRlMuRk9STUFUQVJSQVlCVUZGRVJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBmaWxlIGlzIHJlYWQuXG4gICAgICovXG4gICAgc2VsZi5yZWFkRmlsZSA9IGZ1bmN0aW9uKHBhdGgsIGZvcm1hdCkge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgc2VsZi5GT1JNQVRURVhUO1xuICAgICAgICAkbG9nLmRlYnVnKCdSZWFkIGZpbGUgJyArIHBhdGggKyAnIHdpdGggZm9ybWF0ICcrZm9ybWF0KTtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5GT1JNQVREQVRBVVJMOlxuICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUucmVhZEFzRGF0YVVSTChiYXNlUGF0aCwgcGF0aCk7XG4gICAgICAgICAgICBjYXNlIHNlbGYuRk9STUFUQklOQVJZU1RSSU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUucmVhZEFzQmluYXJ5U3RyaW5nKGJhc2VQYXRoLCBwYXRoKTtcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5GT1JNQVRBUlJBWUJVRkZFUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLnJlYWRBc0FycmF5QnVmZmVyKGJhc2VQYXRoLCBwYXRoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5yZWFkQXNUZXh0KGJhc2VQYXRoLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGZpbGUgY29udGVudHMgZnJvbSBhIGZpbGUgZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjcmVhZEZpbGVEYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgZmlsZURhdGEgRmlsZSdzIGRhdGEuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgZm9ybWF0ICAgRm9ybWF0IHRvIHJlYWQgdGhlIGZpbGUuIEJ5IGRlZmF1bHQsIEZPUk1BVFRFWFQuIE11c3QgYmUgb25lIG9mOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUZTLkZPUk1BVFRFWFRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1GUy5GT1JNQVREQVRBVVJMXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tRlMuRk9STUFUQklOQVJZU1RSSU5HXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tRlMuRk9STUFUQVJSQVlCVUZGRVJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGZpbGUgaXMgcmVhZC5cbiAgICAgKi9cbiAgICBzZWxmLnJlYWRGaWxlRGF0YSA9IGZ1bmN0aW9uKGZpbGVEYXRhLCBmb3JtYXQpIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IHNlbGYuRk9STUFUVEVYVDtcbiAgICAgICAgJGxvZy5kZWJ1ZygnUmVhZCBmaWxlIGZyb20gZmlsZSBkYXRhIHdpdGggZm9ybWF0ICcrZm9ybWF0KTtcblxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICBpZiAoZXZ0LnRhcmdldC5yZXN1bHQgIT09IHVuZGVmaW5lZCB8fCBldnQudGFyZ2V0LnJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZXZ0LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldnQudGFyZ2V0LmVycm9yICE9PSB1bmRlZmluZWQgfHwgZXZ0LnRhcmdldC5lcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChldnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHtjb2RlOiBudWxsLCBtZXNzYWdlOiAnUkVBREVSX09OTE9BREVORF9FUlInfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5GT1JNQVREQVRBVVJMOlxuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGVEYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5GT1JNQVRCSU5BUllTVFJJTkc6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyhmaWxlRGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNlbGYuRk9STUFUQVJSQVlCVUZGRVI6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGVEYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZURhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBzb21lIGRhdGEgaW4gYSBmaWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI3dyaXRlRmlsZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHBhdGggUmVsYXRpdmUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBkYXRhIERhdGEgdG8gd3JpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGZpbGUgaXMgd3JpdHRlbi5cbiAgICAgKi9cbiAgICBzZWxmLndyaXRlRmlsZSA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnV3JpdGUgZmlsZTogJyArIHBhdGgpO1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBmaWxlIChhbmQgcGFyZW50IGZvbGRlcnMpIHRvIHByZXZlbnQgZXJyb3JzLlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY3JlYXRlRmlsZShwYXRoKS50aGVuKGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0hUTUxBUEkgJiYgdHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB3cml0ZSBCbG9icy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzZWxmLmdldE1pbWVUeXBlKHNlbGYuZ2V0RmlsZUV4dGVuc2lvbihwYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0sIHt0eXBlOiB0eXBlwqB8fCAndGV4dC9wbGFpbid9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS53cml0ZUZpbGUoYmFzZVBhdGgsIHBhdGgsIGRhdGEsIHRydWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlRW50cnk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBmaWxlIHRoYXQgbWlnaHQgYmUgb3V0c2lkZSB0aGUgYXBwJ3MgZm9sZGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2dldEV4dGVybmFsRmlsZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIGZ1bGxQYXRoIEFic29sdXRlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBmaWxlIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEV4dGVybmFsRmlsZSA9IGZ1bmN0aW9uKGZ1bGxQYXRoKSB7XG4gICAgICAgIHJldHVybiAkY29yZG92YUZpbGUuY2hlY2tGaWxlKGZ1bGxQYXRoLCAnJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBmaWxlIHRoYXQgbWlnaHQgYmUgb3V0c2lkZSB0aGUgYXBwJ3MgZm9sZGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI3JlbW92ZUV4dGVybmFsRmlsZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIGZ1bGxQYXRoIEFic29sdXRlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBmaWxlIGlzIHJlbW92ZWQuXG4gICAgICovXG4gICAgc2VsZi5yZW1vdmVFeHRlcm5hbEZpbGUgPSBmdW5jdGlvbihmdWxsUGF0aCkge1xuICAgICAgICAvLyByZW1vdmVGaWxlKGZ1bGxQYXRoLCAnJykgZG9lcyBub3Qgd29yaywgd2UgbmVlZCB0byBwYXNzIHR3byB2YWxpZCBwYXJhbWV0ZXJzLlxuICAgICAgICB2YXIgZGlyZWN0b3J5ID0gZnVsbFBhdGguc3Vic3RyaW5nKDAsIGZ1bGxQYXRoLmxhc3RJbmRleE9mKCcvJykgKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZnVsbFBhdGguc3Vic3RyKGZ1bGxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5yZW1vdmVGaWxlKGRpcmVjdG9yeSwgZmlsZW5hbWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhc2UgcGF0aCB3aGVyZSB0aGUgYXBwbGljYXRpb24gZmlsZXMgYXJlIHN0b3JlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNnZXRCYXNlUGF0aFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgYmFzZSBwYXRoIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEJhc2VQYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmluaXQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGJhc2VQYXRoLnNsaWNlKC0xKSA9PSAnLycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlUGF0aCArICcvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYmFzZSBwYXRoIHdoZXJlIHRoZSBhcHBsaWNhdGlvbiBmaWxlcyBhcmUgc3RvcmVkIGluIHRoZSBmb3JtYXQgdG8gYmUgdXNlZCBmb3IgZG93bmxvYWRzLlxuICAgICAqIGlPUzogSW50ZXJuYWwgVVJMIChjZHZmaWxlOi8vKS5cbiAgICAgKiBPdGhlcnM6IGJhc2VQYXRoIChmaWxlOi8vKVxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2dldEJhc2VQYXRoVG9Eb3dubG9hZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgYmFzZSBwYXRoIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEJhc2VQYXRoVG9Eb3dubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gaU9TIHdlIHdhbnQgdGhlIGludGVybmFsIFVSTCAoY2R2ZmlsZTovL2xvY2FsaG9zdC9wZXJzaXN0ZW50Ly4uLikuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5jaGVja0RpcihiYXNlUGF0aCwgJycpLnRoZW4oZnVuY3Rpb24oZGlyRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpckVudHJ5LnRvSW50ZXJuYWxVUkwoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIG90aGVyIHBsYXRmb3JtcyB3ZSB1c2UgdGhlIGJhc2VQYXRoIGFzIGl0IGlzIChmaWxlOi8vLi4uKS5cbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGVtcG9yYXJ5IGRpcmVjdG9yeSBwYXRoLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2dldFRtcEZvbGRlclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVG1wIGRpcmVjdG9yeSBwYXRoLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0VG1wRm9sZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtbUZzVG1wRm9sZGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNtb3ZlRW50cnlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luYWxQYXRoIFBhdGggdG8gdGhlIGZpbGUgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3UGF0aCAgICAgIE5ldyBwYXRoIG9mIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBlbnRyeSBpcyBtb3ZlZC5cbiAgICAgKi9cbiAgICBzZWxmLm1vdmVGaWxlID0gZnVuY3Rpb24ob3JpZ2luYWxQYXRoLCBuZXdQYXRoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmluaXQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGlzSFRNTEFQSSkge1xuICAgICAgICAgICAgICAgIC8vIEluIENvcmRvdmEgQVBJIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBsb25nZXN0IG1hdGNoaW5nIHBhdGggdG8gbWFrZSBpdCB3b3JrLlxuICAgICAgICAgICAgICAgIC8vICRjb3Jkb3ZhRmlsZS5tb3ZlRmlsZSgnYS8nLCAnYi9jLmV4dCcsICdhLycsICdiL2QuZXh0JykgZG9lc24ndCB3b3JrLlxuICAgICAgICAgICAgICAgIC8vIGNvcmRvdmFGaWxlLm1vdmVGaWxlKCdhL2IvJywgJ2MuZXh0JywgJ2EvYi8nLCAnZC5leHQnKSB3b3Jrcy5cbiAgICAgICAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IGJhc2VQYXRoLFxuICAgICAgICAgICAgICAgICAgICBkaXJzQSA9IG9yaWdpbmFsUGF0aC5zcGxpdCgnLycpLFxuICAgICAgICAgICAgICAgICAgICBkaXJzQiA9IG5ld1BhdGguc3BsaXQoJy8nKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpciA9IGRpcnNBW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyc0JbaV0gPT09IGRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYSBjb21tb24gZm9sZGVyLCBhZGQgaXQgdG8gY29tbW9uIHBhdGggYW5kIHJlbW92ZSBpdCBmcm9tIGVhY2ggc3BlY2lmaWMgcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IGRpciArICcvJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vblBhdGggPSBzZWxmLmNvbmNhdGVuYXRlUGF0aHMoY29tbW9uUGF0aCwgZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUGF0aCA9IG9yaWdpbmFsUGF0aC5yZXBsYWNlKGRpciwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGF0aCA9IG5ld1BhdGgucmVwbGFjZShkaXIsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvbGRlciBkb2Vzbid0IG1hdGNoLCBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5tb3ZlRmlsZShjb21tb25QYXRoLCBvcmlnaW5hbFBhdGgsIGNvbW1vblBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLm1vdmVGaWxlKGJhc2VQYXRoLCBvcmlnaW5hbFBhdGgsIGJhc2VQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvcHkgYSBmaWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2NvcHlGaWxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZyb20gICBQYXRoIHRvIHRoZSBmaWxlIHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvICAgICBOZXcgcGF0aCBvZiB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZW50cnkgaXMgY29waWVkLlxuICAgICAqL1xuICAgIHNlbGYuY29weUZpbGUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRvIGNvbnRhaW5zIGEgZGlyZWN0b3J5LlxuICAgICAgICAgICAgdmFyIHRvRmlsZSA9IHNlbGYuZ2V0RmlsZUFuZERpcmVjdG9yeUZyb21QYXRoKHRvKTtcbiAgICAgICAgICAgIGlmICh0b0ZpbGUuZGlyZWN0b3J5ID09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5jb3B5RmlsZShiYXNlUGF0aCwgZnJvbSwgYmFzZVBhdGgsIHRvKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGRpcmVjdG9yeSBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNyZWF0ZURpcih0b0ZpbGUuZGlyZWN0b3J5KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLmNvcHlGaWxlKGJhc2VQYXRoLCBmcm9tLCBiYXNlUGF0aCwgdG8pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgZmlsZSBuYW1lIGFuZCBkaXJlY3RvcnkgZnJvbSBhIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjZ2V0RmlsZUFuZERpcmVjdG9yeUZyb21QYXRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggICBQYXRoIHRvIGJlIGV4dHJhY3RlZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlIG5hbWUgYW5kIGRpcmVjdG9yeS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBmaWxlLnBkZiAgICAgICAgIC0+IGRpcmVjdG9yeTogJycsIG5hbWU6ICdmaWxlLnBkZidcbiAgICAgKiAvZmlsZS5wZGYgICAgICAgIC0+IGRpcmVjdG9yeTogJycsIG5hbWU6ICdmaWxlLnBkZidcbiAgICAgKiBwYXRoL2ZpbGUucGRmICAgIC0+IGRpcmVjdG9yeTogJ3BhdGgnLCBuYW1lOiAnZmlsZS5wZGYnXG4gICAgICogcGF0aC8gICAgICAgICAgICAtPiBkaXJlY3Rvcnk6ICdwYXRoJywgbmFtZTogJydcbiAgICAgKiBwYXRoICAgICAgICAgICAgIC0+IGRpcmVjdG9yeTogJycsIG5hbWU6ICdwYXRoJ1xuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZUFuZERpcmVjdG9yeUZyb21QYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICB2YXIgZmlsZSA9IHtcbiAgICAgICAgICAgIGRpcmVjdG9yeTogJycsXG4gICAgICAgICAgICBuYW1lOiAnJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGZpbGUuZGlyZWN0b3J5ID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sYXN0SW5kZXhPZignLycpICk7XG4gICAgICAgIGZpbGUubmFtZSA9IHBhdGguc3Vic3RyKHBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuXG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb25jYXRlbmF0ZSB0d28gcGF0aHMsIGFkZGluZyBhIHNsYXNoIGJldHdlZW4gdGhlbSBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjY29uY2F0ZW5hdGVQYXRoc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsZWZ0UGF0aCAgTGVmdCBwYXRoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByaWdodFBhdGggUmlnaHQgcGF0aC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIENvbmNhdGVuYXRlZCBwYXRoLlxuICAgICAqL1xuICAgIHNlbGYuY29uY2F0ZW5hdGVQYXRocyA9IGZ1bmN0aW9uKGxlZnRQYXRoLCByaWdodFBhdGgpIHtcbiAgICAgICAgdmFyIGxhc3RDaGFyTGVmdCA9IGxlZnRQYXRoLnNsaWNlKC0xKSxcbiAgICAgICAgICAgIGZpcnN0Q2hhclJpZ2h0ID0gcmlnaHRQYXRoLmNoYXJBdCgwKTtcblxuICAgICAgICBpZiAobGFzdENoYXJMZWZ0ID09PSAnLycgJiYgZmlyc3RDaGFyUmlnaHQgPT09ICcvJykge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnRQYXRoICsgcmlnaHRQYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfSBlbHNlIGlmKGxhc3RDaGFyTGVmdCAhPT0gJy8nICYmIGZpcnN0Q2hhclJpZ2h0ICE9PSAnLycpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0UGF0aCArICcvJyArIHJpZ2h0UGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0UGF0aCArIHJpZ2h0UGF0aDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGludGVybmFsIFVSTCBvZiBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjZ2V0SW50ZXJuYWxVUkxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGZpbGVFbnRyeSBGaWxlIEVudHJ5LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIEludGVybmFsIFVSTC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEludGVybmFsVVJMID0gZnVuY3Rpb24oZmlsZUVudHJ5KSB7XG4gICAgICAgIGlmIChpc0hUTUxBUEkpIHtcbiAgICAgICAgICAgIC8vIEhUTUwgQVBJIGRvZXNuJ3QgaW1wbGVtZW50IHRvSW50ZXJuYWxVUkwuXG4gICAgICAgICAgICByZXR1cm4gZmlsZUVudHJ5LnRvVVJMKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGVFbnRyeS50b0ludGVybmFsVVJMKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGZpbGUgaWNvbiBVUkwgYmFzZWQgb24gaXRzIGZpbGUgbmFtZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1VdGlsI2dldEZpbGVJY29uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwYXRoIHRvIGEgZmlsZSBpY29uLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZUljb24gPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICAgICAgICB2YXIgZXh0ID0gc2VsZi5nZXRGaWxlRXh0ZW5zaW9uKGZpbGVuYW1lKSxcbiAgICAgICAgICAgIGljb247XG5cbiAgICAgICAgaWYgKGV4dCAmJiBtaW1lVHlwZXNbZXh0XSAmJiBtaW1lVHlwZXNbZXh0XS5pY29uKSB7XG4gICAgICAgICAgICBpY29uID0gbWltZVR5cGVzW2V4dF0uaWNvbiArICctNjQucG5nJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGljb24gPSAndW5rbm93bi02NC5wbmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdpbWcvZmlsZXMvJyArIGljb247XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZm9sZGVyIGljb24gVVJMLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVV0aWwjZ2V0Rm9sZGVySWNvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHBhdGggdG8gYSBmb2xkZXIgaWNvbi5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZvbGRlckljb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdpbWcvZmlsZXMvZm9sZGVyLTY0LnBuZyc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpbGUgZXh0ZW5zaW9uIG9mIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGZpbGUgZG9lcyBub3QgaGF2ZSBhbiBleHRlbnNpb24sIGl0IHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVV0aWwjZ2V0RmlsZUV4dGVuc2lvblxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZW5hbWUgVGhlIGZpbGUgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgIFRoZSBsb3dlcmNhc2VkIGV4dGVuc2lvbiwgb3IgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gICAgICAgIHZhciBkb3QgPSBmaWxlbmFtZS5sYXN0SW5kZXhPZihcIi5cIiksXG4gICAgICAgICAgICBleHQ7XG5cbiAgICAgICAgaWYgKGRvdCA+IC0xKSB7XG4gICAgICAgICAgICBleHQgPSBmaWxlbmFtZS5zdWJzdHIoZG90ICsgMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWltZXR5cGUgb2YgYW4gZXh0ZW5zaW9uLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVXRpbCNhbGxQcm9taXNlc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXh0ZW5zaW9uIEV4dGVuc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBNaW1ldHlwZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldE1pbWVUeXBlID0gZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgICAgIGlmIChtaW1lVHlwZXNbZXh0ZW5zaW9uXSAmJiBtaW1lVHlwZXNbZXh0ZW5zaW9uXS50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWltZVR5cGVzW2V4dGVuc2lvbl0udHlwZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGV4dGVuc2lvbiBmcm9tIGEgcGF0aCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNyZW1vdmVFeHRlbnNpb25cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggUGF0aC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgUGF0aCB3aXRob3V0IGV4dGVuc2lvbi5cbiAgICAgKi9cbiAgICBzZWxmLnJlbW92ZUV4dGVuc2lvbiA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLicpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGguc3Vic3RyKDAsIGluZGV4KTsgLy8gUmVtb3ZlIGV4dGVuc2lvbi5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgYmFzZVBhdGggdG8gYSBwYXRoIGlmIGl0IGRvZXNuJ3QgaGF2ZSBpdCBhbHJlYWR5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2FkZEJhc2VQYXRoSWZOZWVkZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHRvIHRyZWF0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIFBhdGggd2l0aCBiYXNlUGF0aCBhZGRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmFkZEJhc2VQYXRoSWZOZWVkZWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoYmFzZVBhdGgpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29uY2F0ZW5hdGVQYXRocyhiYXNlUGF0aCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVW56aXBzIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyN1bnppcEZpbGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggICAgICAgICBQYXRoIHRvIHRoZSBaSVAgZmlsZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtkZXN0Rm9sZGVyXSBQYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIuIElmIG5vdCBkZWZpbmVkLCBhIG5ldyBmb2xkZXIgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtZSBsb2NhdGlvbiBhbmQgbmFtZSBhcyB0aGUgWklQIGZpbGUgKHdpdGhvdXQgZXh0ZW5zaW9uKS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGZpbGUgaXMgdW56aXBwZWQuXG4gICAgICovXG4gICAgc2VsZi51bnppcEZpbGUgPSBmdW5jdGlvbihwYXRoLCBkZXN0Rm9sZGVyKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIGFuc29sdXRlIHBhdGhzIChpbmNsdWRpbmcgYmFzZVBhdGgpLlxuICAgICAgICBwYXRoID0gc2VsZi5hZGRCYXNlUGF0aElmTmVlZGVkKHBhdGgpO1xuICAgICAgICAgLy8gSWYgZGVzdEZvbGRlciBpcyBub3Qgc2V0LCB1c2Ugc2FtZSBsb2NhdGlvbiBhcyBaSVAgZmlsZS5cbiAgICAgICAgZGVzdEZvbGRlciA9IHNlbGYuYWRkQmFzZVBhdGhJZk5lZWRlZChkZXN0Rm9sZGVyIHx8IHNlbGYucmVtb3ZlRXh0ZW5zaW9uKHBhdGgpKTtcbiAgICAgICAgcmV0dXJuICRjb3Jkb3ZhWmlwLnVuemlwKHBhdGgsIGRlc3RGb2xkZXIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGhhbmRsZSBncm91cHMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmdyb3Vwc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUdyb3Vwc1xuICovXG4uZmFjdG9yeSgnJG1tR3JvdXBzJywgZnVuY3Rpb24oJGxvZywgJHEsICRtbVNpdGUsICRtbVNpdGVzTWFuYWdlcikge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUdyb3VwcycpO1xuXG4gICAgLy8gR3JvdXAgbW9kZSBjb25zdGFudHMuXG4gICAgc2VsZi5OT0dST1VQUyAgICAgICA9IDA7XG4gICAgc2VsZi5TRVBBUkFURUdST1VQUyA9IDE7XG4gICAgc2VsZi5WSVNJQkxFR1JPVVBTICA9IDI7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGdyb3VwcyBhbGxvd2VkIGluIGFuIGFjdGl2aXR5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmdyb3Vwc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Hcm91cHMjZ2V0QWN0aXZpdHlBbGxvd2VkR3JvdXBzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNtaWQgICAgIENvdXJzZSBtb2R1bGUgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VyaWRdIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCB1c2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGdyb3VwcyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QWN0aXZpdHlBbGxvd2VkR3JvdXBzID0gZnVuY3Rpb24oY21pZCwgdXNlcmlkKSB7XG4gICAgICAgIHVzZXJpZCA9IHVzZXJpZCB8fMKgJG1tU2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNtaWQ6IGNtaWQsXG4gICAgICAgICAgICAgICAgdXNlcmlkOiB1c2VyaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRBY3Rpdml0eUFsbG93ZWRHcm91cHNDYWNoZUtleShjbWlkLCB1c2VyaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ2NvcmVfZ3JvdXBfZ2V0X2FjdGl2aXR5X2FsbG93ZWRfZ3JvdXBzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5ncm91cHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZ3JvdXBzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZ3JvdXAgbW9kZSBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbWlkIENvdXJzZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFjdGl2aXR5QWxsb3dlZEdyb3Vwc0NhY2hlS2V5KGNtaWQsIHVzZXJpZCkge1xuICAgICAgICByZXR1cm4gJ21tR3JvdXBzOmFsbG93ZWRncm91cHM6JyArIGNtaWQgKyAnOicgKyB1c2VyaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBncm91cCBtb2RlIG9mIGFuIGFjdGl2aXR5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmdyb3Vwc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Hcm91cHMjZ2V0QWN0aXZpdHlHcm91cE1vZGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY21pZCBDb3Vyc2UgbW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZ3JvdXAgbW9kZSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRBY3Rpdml0eUdyb3VwTW9kZSA9IGZ1bmN0aW9uKGNtaWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjbWlkOiBjbWlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0QWN0aXZpdHlHcm91cE1vZGVDYWNoZUtleShjbWlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdjb3JlX2dyb3VwX2dldF9hY3Rpdml0eV9ncm91cG1vZGUnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UgfHwgdHlwZW9mIHJlc3BvbnNlLmdyb3VwbW9kZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ncm91cG1vZGU7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBncm91cCBtb2RlIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNtaWQgQ291cnNlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWN0aXZpdHlHcm91cE1vZGVDYWNoZUtleShjbWlkKSB7XG4gICAgICAgIHJldHVybiAnbW1Hcm91cHM6Z3JvdXBtb2RlOicgKyBjbWlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGdyb3VwcyBpbiBjb3Vyc2VzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmdyb3Vwc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Hcm91cHMjZ2V0VXNlckdyb3Vwc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W118TnVtYmVyW119IGNvdXJzZXMgTGlzdCBvZiBjb3Vyc2VzIG9yIGNvdXJzZSBpZHMgdG8gZ2V0IHRoZSBncm91cHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWZyZXNoXSAgICAgICAgIFRydWUgd2hlbiB3ZSBzaG91bGQgbm90IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlaWRdICAgICAgICAgICBTaXRlIHRvIGdldCB0aGUgZ3JvdXBzIGZyb20uIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcmlkXSAgICAgICAgICAgSUQgb2YgdGhlIHVzZXIuIElmIG5vdCBkZWZpbmVkLCB1c2UgdGhlIHVzZXJpZCByZWxhdGVkIHRvIHNpdGVpZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZ3JvdXBzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRVc2VyR3JvdXBzID0gZnVuY3Rpb24oY291cnNlcywgcmVmcmVzaCwgc2l0ZWlkLCB1c2VyaWQpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW10sXG4gICAgICAgICAgICBncm91cHMgPSBbXSxcbiAgICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goY291cnNlcywgZnVuY3Rpb24oY291cnNlKSB7XG4gICAgICAgICAgICB2YXIgY291cnNlaWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvdXJzZSA9PSAnb2JqZWN0JykgeyAvLyBQYXJhbSBpcyBhcnJheSBvZiBjb3Vyc2VzLlxuICAgICAgICAgICAgICAgIGNvdXJzZWlkID0gY291cnNlLmlkO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gUGFyYW0gaXMgYXJyYXkgb2YgY291cnNlaWRzLlxuICAgICAgICAgICAgICAgIGNvdXJzZWlkID0gY291cnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBzZWxmLmdldFVzZXJHcm91cHNJbkNvdXJzZShjb3Vyc2VpZCwgcmVmcmVzaCwgc2l0ZWlkLCB1c2VyaWQpLnRoZW4oZnVuY3Rpb24oY291cnNlZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzID0gZ3JvdXBzLmNvbmNhdChjb3Vyc2Vncm91cHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkcS5hbGwocHJvbWlzZXMpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBVc2UgZmluYWxseSBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gYmxvY2sgdGhlIGxvYWQgb2YgZXZlbnRzIGlmIGEgcmVxdWVzdCBmYWlscy5cbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZ3JvdXBzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGdyb3VwcyBpbiBhIGNvdXJzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5ncm91cHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tR3JvdXBzI2dldFVzZXJHcm91cHNJbkNvdXJzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCAgIElEIG9mIHRoZSBjb3Vyc2UuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVmcmVzaF0gVHJ1ZSB3aGVuIHdlIHNob3VsZCBub3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVpZF0gICBTaXRlIHRvIGdldCB0aGUgZ3JvdXBzIGZyb20uIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcmlkXSAgIElEIG9mIHRoZSB1c2VyLiBJZiBub3QgZGVmaW5lZCwgdXNlIElEIHJlbGF0ZWQgdG8gc2l0ZWlkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGdyb3VwcyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0VXNlckdyb3Vwc0luQ291cnNlID0gZnVuY3Rpb24oY291cnNlaWQsIHJlZnJlc2gsIHNpdGVpZCwgdXNlcmlkKSB7XG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgcHJlc2V0cyA9IHt9LFxuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJpZDogdXNlcmlkIHx8IHNpdGUuZ2V0VXNlcklkKCksXG4gICAgICAgICAgICAgICAgICAgIGNvdXJzZWlkOiBjb3Vyc2VpZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgIHByZXNldHMuZ2V0RnJvbUNhY2hlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5yZWFkKCdjb3JlX2dyb3VwX2dldF9jb3Vyc2VfdXNlcl9ncm91cHMnLCBkYXRhLCBwcmVzZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZ3JvdXBzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIGFjdGl2aXR5IGFsbG93ZWQgZ3JvdXBzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmdyb3Vwc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Hcm91cHMjaW52YWxpZGF0ZUFjdGl2aXR5QWxsb3dlZEdyb3Vwc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbWlkICAgICBDb3Vyc2UgbW9kdWxlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcmlkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUFjdGl2aXR5QWxsb3dlZEdyb3VwcyA9IGZ1bmN0aW9uKGNtaWQsIHVzZXJpZCkge1xuICAgICAgICB1c2VyaWQgPSB1c2VyaWQgfHzCoCRtbVNpdGUuZ2V0VXNlcklkKCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldEFjdGl2aXR5QWxsb3dlZEdyb3Vwc0NhY2hlS2V5KGNtaWQsIHVzZXJpZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBhY3Rpdml0eSBncm91cCBtb2RlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmdyb3Vwc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Hcm91cHMjaW52YWxpZGF0ZUFjdGl2aXR5R3JvdXBNb2RlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNtaWQgQ291cnNlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQWN0aXZpdHlHcm91cE1vZGUgPSBmdW5jdGlvbihjbWlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldEFjdGl2aXR5R3JvdXBNb2RlQ2FjaGVLZXkoY21pZCkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBwcmlvcml0eSBmb3IgaW5pdCBwcm9jZXNzZXMuXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBjb25zdGFudFxuICogQG5hbWUgbW1Jbml0RGVsZWdhdGVEZWZhdWx0UHJpb3JpdHlcbiAqL1xuLmNvbnN0YW50KCdtbUluaXREZWxlZ2F0ZURlZmF1bHRQcmlvcml0eScsIDEwMClcblxuLyoqXG4gKiBUaGUgbWF4aW11bSBwcmlvcml0eSB0aGF0IGFuIGFkZG9uIGNhbiB1c2UgZm9yIGluaXQgcHJvY2VzcywgYW55dGhpbmcgb3ZlciB0aGF0IGlzIHJlc2VydmVkIGZvciBjb3JlIHVzZS5cbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGNvbnN0YW50XG4gKiBAbmFtZSBtbUluaXREZWxlZ2F0ZU1heEFkZG9uUHJpb3JpdHlcbiAqL1xuLmNvbnN0YW50KCdtbUluaXREZWxlZ2F0ZU1heEFkZG9uUHJpb3JpdHknLCA1OTkpXG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGluaXRpYWxpc2F0aW9uIG1lY2hhbmlzbXMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgcHJvdmlkZXJcbiAqIEBuYW1lICRtbUluaXREZWxlZ2F0ZVxuICovXG4ucHJvdmlkZXIoJyRtbUluaXREZWxlZ2F0ZScsIGZ1bmN0aW9uKG1tSW5pdERlbGVnYXRlRGVmYXVsdFByaW9yaXR5KSB7XG4gICAgdmFyIGluaXRQcm9jZXNzZXMgPSB7fSxcbiAgICAgICAgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGluaXRpYWxpc2F0aW9uIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJbml0IHByb2Nlc3NlcyBjYW4gYmUgdXNlZCB0byBhZGQgaW5pdGlhbGlzYXRpb24gbG9naWMgdG8gdGhlIGFwcC4gQW55dGhpbmcgdGhhdCBzaG91bGRcbiAgICAgKiBibG9jayB0aGUgdXNlciBpbnRlcmZhY2Ugd2hpbGUgc29tZSBwcm9jZXNzZXMgYXJlIGRvbmUgc2hvdWxkIGJlIGFuIGluaXQgcHJvY2Vzcy4gV2hlbiBkZWZpbmluZ1xuICAgICAqIGFuIGluaXQgcHJvY2VzcyBtYWtlIHN1cmUgeW91IGRvIG5vdCBzZXQgYSBwcmlvcml0eSBoaWdoZXIgdGhhbiBtbUluaXREZWxlZ2F0ZU1heEFkZG9uUHJpb3JpdHlcbiAgICAgKiBpbiB5b3VyIGFkZG9ucy4gVGhpcyBpcyB0byBtYWtlIHN1cmUgdGhhdCB5b3VyIHByb2Nlc3MgZG9lcyBub3QgaGFwcGVuIGJlZm9yZSBzb21lIGVzc2VudGlhbFxuICAgICAqIG90aGVyIGNvcmUgcHJvY2Vzc2VzIHN1Y2ggYXMgdGhlIHVwZ3JhZGUsIGFuZCByZXN0b3JpbmcgdGhlIHVzZXIgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEFuIGluaXQgcHJvY2VzcyBzaG91bGQgbmV2ZXIgY2hhbmdlIHN0YXRlIG9yIHByb21wdCB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUluaXREZWxlZ2F0ZVByb3ZpZGVyI3JlZ2lzdGVyUHJvY2Vzc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBjYWxsYWJsZSBUaGUgY2FsbGFibGUgb2YgdGhlIHByb2Nlc3MuIFNlZSB7QGxpbmsgJG1tVXRpbC5yZXNvbHZlT2JqZWN0fS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJlc29sdmVkIGZ1bmN0aW9uIHdpbGwgZ2V0ICRpbmplY3RvciBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5PTEwMF0gVGhlIHByaW9yaXR5IG9mIHRoZSBwcm9jZXNzLCB0aGUgaGlnaGVzdCBwcmlvcml0eSBpcyBleGVjdXRlZCBmaXJzdC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtibG9ja2luZz1mYWxzZV0gU2V0IHRoaXMgdG8gdHJ1ZSB3aGVuIHRoaXMgcHJvY2VzcyBzaG91bGQgYmUgcmVzb2x2ZWQgYmVmb3JlIGFueSBmb2xsb3dpbmcgb25lLlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc2VsZi5yZWdpc3RlclByb2Nlc3MgPSBmdW5jdGlvbihuYW1lLCBjYWxsYWJsZSwgcHJpb3JpdHksIGJsb2NraW5nKSB7XG4gICAgICAgIHByaW9yaXR5ID0gdHlwZW9mIHByaW9yaXR5ID09PSAndW5kZWZpbmVkJyA/IG1tSW5pdERlbGVnYXRlRGVmYXVsdFByaW9yaXR5IDogcHJpb3JpdHk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbml0UHJvY2Vzc2VzW25hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJyRtbUluaXREZWxlZ2F0ZVByb3ZpZGVyOiBQcm9jZXNzIFxcJycgKyBuYW1lICsgJ1xcJyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnJG1tSW5pdERlbGVnYXRlUHJvdmlkZXI6IFJlZ2lzdGVyZWQgcHJvY2VzcyBcXCcnICsgbmFtZSArICdcXCcuJyk7XG4gICAgICAgIGluaXRQcm9jZXNzZXNbbmFtZV0gPSB7XG4gICAgICAgICAgICBibG9ja2luZzogYmxvY2tpbmcsXG4gICAgICAgICAgICBjYWxsYWJsZTogY2FsbGFibGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHNlbGYuJGdldCA9IGZ1bmN0aW9uKCRxLCAkbG9nLCAkaW5qZWN0b3IsICRtbVV0aWwpIHtcblxuICAgICAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tSW5pdERlbGVnYXRlJyk7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgICAgIHJlYWRpbmVzcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB0aGUgcHJvY2Vzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIG9mIHRoZSBwcm9jZXNzLlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHByZXBhcmVQcm9jZXNzKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgZm47XG5cbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdFeGVjdXRpbmcgaW5pdCBwcm9jZXNzIFxcJycgKyBkYXRhLm5hbWUgKyAnXFwnJyk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbiA9ICRtbVV0aWwucmVzb2x2ZU9iamVjdChkYXRhLmNhbGxhYmxlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0NvdWxkIG5vdCByZXNvbHZlIG9iamVjdCBvZiBpbml0IHByb2Nlc3MgXFwnJyArIGRhdGEubmFtZSArICdcXCcuICcgKyBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBmbigkaW5qZWN0b3IpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3Igd2hpbGUgY2FsbGluZyB0aGUgaW5pdCBwcm9jZXNzIFxcJycgKyBkYXRhLm5hbWUgKyAnXFwnLiAnICsgZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZXMgdGhlIHJlZ2lzdGVyZWQgaW5pdCBwcm9jZXNzZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlc2VydmVkIGZvciBjb3JlIHVzZSwgZG8gbm90IGNhbGwgZGlyZWN0bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2Mgc2VydmljZVxuICAgICAgICAgKiBAbmFtZSAkbW1Jbml0RGVsZWdhdGUjZXhlY3V0ZUluaXRQcm9jZXNzZXNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5leGVjdXRlSW5pdFByb2Nlc3NlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG9yZGVyZWQgPSBbXSxcbiAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSAkcS53aGVuKCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZGluZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlYWRpbmVzcyA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlLW9yZGVyaW5nIGJ5IHByaW9yaXR5LlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGluaXRQcm9jZXNzZXMsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBvcmRlcmVkLnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9yZGVyZWQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgYWxsIHRoZSBwcm9jZXNzZXMuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gob3JkZXJlZCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBwcm9jZXNzIHRvIHRoZSBkZXBlbmRlbmN5IHN0YWNrLlxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBkZXBlbmRlbmN5LmZpbmFsbHkocHJlcGFyZVByb2Nlc3MoZGF0YSkpO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV3IHByb2Nlc3MgaXMgYmxvY2tpbmcsIHdlIHNldCBpdCBhcyB0aGUgZGVwZW5kZW5jeS5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5ibG9ja2luZykge1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJHEuYWxsKHByb21pc2VzKS5maW5hbGx5KHJlYWRpbmVzcy5yZXNvbHZlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm90aWZpZXMgd2hlbiB0aGUgYXBwIGlzIHJlYWR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgYXBwIGlzIGluaXRpYWxpc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXNlcnZlZCBmb3IgY29yZSB1c2UsIGRvIG5vdCBjYWxsIGRpcmVjdGx5LCB1c2Uge0BsaW5rICRtbUFwcC5yZWFkeX0gaW5zdGVhZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBzZXJ2aWNlXG4gICAgICAgICAqIEBuYW1lICRtbUluaXREZWxlZ2F0ZSNyZWFkeVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGFwcCBpcyBpbml0aWFsaXNlZC4gTmV2ZXIgcmVqZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRpbmVzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHJhY2UgY29uZGl0aW9ucyBpZiB0aGlzIGlzIGNhbGxlZCBiZWZvcmUgZXhlY3V0ZUluaXRQcm9jZXNzZXMuXG4gICAgICAgICAgICAgICAgcmVhZGluZXNzID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlYWRpbmVzcy5wcm9taXNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLyoqXG4gKiBpb25SYWRpb0ZpeCAtIGZpeGVzIGEgYnVnIGluIGlPUyA5IFVJV2ViVmlldyB0aGF0IGJyZWFrcyB0aGUgdGlsZGUgc2VsZWN0b3IgaW4gQ1NTLiBUb1xuICogdXNlIHRoaXMgZml4LCBpbmNsdWRlIGl0IGFmdGVyIHlvdXIgSW9uaWMgYnVuZGxlIEpTLlxuICpcbiAqIE5vdGU6IGR1ZSB0byBBbmd1bGFyIGRpcmVjdGl2ZSBvdmVycmlkZSBsaW1pdGF0aW9ucywgeW91J2xsIG5lZWQgdG8gY2hhbmdlIGFueSByZWZlcmVuY2VcbiAqIHRvIDxpb24tcmFkaW8+IHRvIDxpb24tcmFkaW8tZml4PiB0byBhcHBseSB0aGlzIHBhdGNoZWQgcmFkaW8gYnV0dG9uLlxuICpcbiAqIEFsc28sIG1ha2Ugc3VyZSB0byBhZGQgdGhlIG5ldyBDU1MgZnJvbSB0aGUgc2Vjb25kIHBhcnQgb2YgdGhpcyBnaXN0LlxuICovXG5hbmd1bGFyLm1vZHVsZSgnaW9uaWMnKS5kaXJlY3RpdmUoJ2lvblJhZGlvRml4JywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHJlcXVpcmU6ICc/bmdNb2RlbCcsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZTpcbiAgICAgICc8bGFiZWwgY2xhc3M9XCJpdGVtIGl0ZW0tcmFkaW9cIj4nICtcbiAgICAgICAgJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwicmFkaW8tZ3JvdXBcIj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJyYWRpby1jb250ZW50XCI+JyArXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLWNvbnRlbnQgZGlzYWJsZS1wb2ludGVyLWV2ZW50c1wiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+JyArXG4gICAgICAgICAgJzxpIGNsYXNzPVwicmFkaW8taWNvbiBkaXNhYmxlLXBvaW50ZXItZXZlbnRzIGljb24gaW9uLWNoZWNrbWFya1wiPjwvaT4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgJzwvbGFiZWw+JyxcblxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIGlmIChhdHRyLmljb24pIHtcbiAgICAgICAgdmFyIGljb25FbG0gPSBlbGVtZW50LmZpbmQoJ2knKTtcbiAgICAgICAgaWNvbkVsbS5yZW1vdmVDbGFzcygnaW9uLWNoZWNrbWFyaycpLmFkZENsYXNzKGF0dHIuaWNvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dCA9IGVsZW1lbnQuZmluZCgnaW5wdXQnKTtcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaCh7XG4gICAgICAgICAgJ25hbWUnOiBhdHRyLm5hbWUsXG4gICAgICAgICAgJ3ZhbHVlJzogYXR0ci52YWx1ZSxcbiAgICAgICAgICAnZGlzYWJsZWQnOiBhdHRyLmRpc2FibGVkLFxuICAgICAgICAgICduZy12YWx1ZSc6IGF0dHIubmdWYWx1ZSxcbiAgICAgICAgICAnbmctbW9kZWwnOiBhdHRyLm5nTW9kZWwsXG4gICAgICAgICAgJ25nLWRpc2FibGVkJzogYXR0ci5uZ0Rpc2FibGVkLFxuICAgICAgICAgICduZy1jaGFuZ2UnOiBhdHRyLm5nQ2hhbmdlLFxuICAgICAgICAgICduZy1yZXF1aXJlZCc6IGF0dHIubmdSZXF1aXJlZCxcbiAgICAgICAgICAncmVxdWlyZWQnOiBhdHRyLnJlcXVpcmVkXG4gICAgICB9LCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBpbnB1dC5hdHRyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XG4gICAgICAgIHNjb3BlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlLm5nVmFsdWUgfHwgYXR0ci52YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufSk7IiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tTGFuZ1xuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgc2VydmljZSBhbGxvd3MgdG8gYWRkIG5ldyBsYW5ndWFnZXMgc3RyaW5ncy5cbiAqL1xuLmZhY3RvcnkoJyRtbUxhbmcnLCBmdW5jdGlvbigkdHJhbnNsYXRlLCAkdHJhbnNsYXRlUGFydGlhbExvYWRlciwgJG1tQ29uZmlnLCAkY29yZG92YUdsb2JhbGl6YXRpb24sICRxLCBtbUNvcmVDb25maWdDb25zdGFudHMpIHtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGN1cnJlbnRMYW5ndWFnZTsgLy8gU2F2ZSBjdXJyZW50IGxhbmd1YWdlIGluIGEgdmFyaWFibGUgdG8gc3BlZWQgdXAgdGhlIGdldCBmdW5jdGlvbi5cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgZm9sZGVyIHRvIHNlYXJjaCBsYW5ndWFnZSBmaWxlcyBpbnRvIGl0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxhbmcjcmVnaXN0ZXJMYW5ndWFnZUZvbGRlclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBQYXRoIG9mIHRoZSBmb2xkZXIgdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gZmlsZSBpcyBsb2FkZWQuXG4gICAgICovXG4gICAgc2VsZi5yZWdpc3Rlckxhbmd1YWdlRm9sZGVyID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAkdHJhbnNsYXRlUGFydGlhbExvYWRlci5hZGRQYXJ0KHBhdGgpO1xuICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS5yZWZyZXNoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxhbmcjZ2V0Q3VycmVudExhbmd1YWdlXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgc2VsZi5nZXRDdXJyZW50TGFuZ3VhZ2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRMYW5ndWFnZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oY3VycmVudExhbmd1YWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGxhbmd1YWdlIGZyb20gY29uZmlnICh1c2VyIG1pZ2h0IGhhdmUgY2hhbmdlZCBpdCkuXG4gICAgICAgIHJldHVybiAkbW1Db25maWcuZ2V0KCdjdXJyZW50X2xhbmd1YWdlJykudGhlbihmdW5jdGlvbihsYW5ndWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlciBoYXNuJ3QgZGVmaW5lZCBhIGxhbmd1YWdlLiBHZXQgaXQgZnJvbSBjb3Jkb3ZhIGdsb2JhbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhR2xvYmFsaXphdGlvbi5nZXRQcmVmZXJyZWRMYW5ndWFnZSgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYW5ndWFnZSA9IHJlc3VsdC52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhbmd1YWdlIGNvZGUgZGVmaW5lZCBieSBsb2NhbGUgaGFzIGEgZGFzaCwgbGlrZSBlbi1VUyBvciBlcy1FUy4gQ2hlY2sgaWYgaXQncyBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW1Db3JlQ29uZmlnQ29uc3RhbnRzLmxhbmd1YWdlcyAmJiB0eXBlb2YgbW1Db3JlQ29uZmlnQ29uc3RhbnRzLmxhbmd1YWdlc1tsYW5ndWFnZV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2RlIGlzIE5PVCBzdXBwb3J0ZWQuIEZhbGxiYWNrIHRvIGxhbmd1YWdlIHdpdGhvdXQgZGFzaC4gRS5nLiAnZW4tVVMnIHdvdWxkIGZhbGxiYWNrIHRvICdlbicuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2UgPSBsYW5ndWFnZS5zdWJzdHIoMCwgbGFuZ3VhZ2UuaW5kZXhPZignLScpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3IgZ2V0dGluZyBsb2NhbGUuIFVzZSBkZWZhdWx0IGxhbmd1YWdlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW1Db3JlQ29uZmlnQ29uc3RhbnRzLmRlZmF1bHRfbGFuZyB8fCAnZW4nO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBnZXR0aW5nIGxvY2FsZS4gVXNlIGRlZmF1bHQgbGFuZ3VhZ2UuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5kZWZhdWx0X2xhbmcgfHwgJ2VuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihsYW5ndWFnZSkge1xuICAgICAgICAgICAgY3VycmVudExhbmd1YWdlID0gbGFuZ3VhZ2U7IC8vIFNhdmUgaXQgZm9yIGxhdGVyLlxuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGN1cnJlbnQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTGFuZyNjaGFuZ2VDdXJyZW50TGFuZ3VhZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGFuZ3VhZ2UgTmV3IGxhbmd1YWdlIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjaGFuZ2UgaXMgZmluaXNoZWQuXG4gICAgICovXG4gICAgc2VsZi5jaGFuZ2VDdXJyZW50TGFuZ3VhZ2UgPSBmdW5jdGlvbihsYW5ndWFnZSkge1xuICAgICAgICB2YXIgcDEgPSAkdHJhbnNsYXRlLnVzZShsYW5ndWFnZSksXG4gICAgICAgICAgICBwMiA9ICRtbUNvbmZpZy5zZXQoJ2N1cnJlbnRfbGFuZ3VhZ2UnLCBsYW5ndWFnZSk7XG4gICAgICAgIG1vbWVudC5sb2NhbGUobGFuZ3VhZ2UpO1xuICAgICAgICBjdXJyZW50TGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChbcDEsIHAyXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgYW4gZXJyb3IgbWVzc2FnZSBhbmQgcmV0dXJucyBhIHJlamVjdGVkIHByb21pc2Ugd2l0aCB0aGUgdHJhbnNsYXRlZCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxhbmcjdHJhbnNsYXRlQW5kUmVqZWN0XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBlcnJvcmtleSBLZXkgb2YgdGhlIG1lc3NhZ2UgdG8gc2hvdy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFJlamVjdGVkIHByb21pc2UuXG4gICAgICovXG4gICAgc2VsZi50cmFuc2xhdGVBbmRSZWplY3QgPSBmdW5jdGlvbihlcnJvcmtleSkge1xuICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZShlcnJvcmtleSkudGhlbihmdW5jdGlvbihlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9ya2V5KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgYW4gZXJyb3IgbWVzc2FnZSBhbmQgcmVqZWN0cyBhIGRlZmVycmVkIHdpdGggdGhlIHRyYW5zbGF0ZWQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1MYW5nI3RyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBkZWZlcnJlZCBEZWZlcnJlZCBvYmplY3QgdG8gcmVqZWN0LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXJyb3JrZXkgS2V5IG9mIHRoZSBtZXNzYWdlIHRvIHNob3cuXG4gICAgICovXG4gICAgc2VsZi50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZCA9IGZ1bmN0aW9uKGRlZmVycmVkLCBlcnJvcmtleSkge1xuICAgICAgICAkdHJhbnNsYXRlKGVycm9ya2V5KS50aGVuKGZ1bmN0aW9uKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9ya2V5KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkdHJhbnNsYXRlUHJvdmlkZXIsICR0cmFuc2xhdGVQYXJ0aWFsTG9hZGVyUHJvdmlkZXIpIHtcblxuICAgICR0cmFuc2xhdGVQcm92aWRlci51c2VMb2FkZXIoJyR0cmFuc2xhdGVQYXJ0aWFsTG9hZGVyJywge1xuICAgICAgICB1cmxUZW1wbGF0ZTogJ3twYXJ0fS97bGFuZ30uanNvbidcbiAgICB9KTtcblxuICAgIC8vIExvYWQgdGhlIGJ1aWx0IGxhbmd1YWdlIGZpbGVzIGZyb20gYnVpbGQvbGFuZy5cbiAgICAkdHJhbnNsYXRlUGFydGlhbExvYWRlclByb3ZpZGVyLmFkZFBhcnQoJ2J1aWxkL2xhbmcnKTtcblxuICAgIC8vIFNldCBmYWxsYmFjayBsYW5ndWFnZS5cbiAgICAkdHJhbnNsYXRlUHJvdmlkZXIuZmFsbGJhY2tMYW5ndWFnZSgnZW4nKTtcbiAgICAkdHJhbnNsYXRlUHJvdmlkZXIucHJlZmVycmVkTGFuZ3VhZ2UoJ2VuJyk7IC8vIFNldCBFbmdsaXNoIHVudGlsIHdlIGtub3cgd2hpY2ggbGFuZ3VhZ2UgdG8gdXNlLlxufSlcblxuLnJ1bihmdW5jdGlvbigkaW9uaWNQbGF0Zm9ybSwgJHRyYW5zbGF0ZSwgJG1tTGFuZykge1xuICAgICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1MYW5nLmdldEN1cnJlbnRMYW5ndWFnZSgpLnRoZW4oZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICR0cmFuc2xhdGUudXNlKGxhbmd1YWdlKTtcbiAgICAgICAgICAgIG1vbWVudC5sb2NhbGUobGFuZ3VhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pOyIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8vIFN0b3JlcyB1c2VkIHRvIGNyZWF0ZSB1bmlxdWUgSURzIGZvciBub3RpZmljYXRpb25zLlxuLmNvbnN0YW50KCdtbUNvcmVOb3RpZmljYXRpb25zU2l0ZXNTdG9yZScsICdub3RpZmljYXRpb25fc2l0ZXMnKVxuLmNvbnN0YW50KCdtbUNvcmVOb3RpZmljYXRpb25zQ29tcG9uZW50c1N0b3JlJywgJ25vdGlmaWNhdGlvbl9jb21wb25lbnRzJylcbi5jb25zdGFudCgnbW1Db3JlTm90aWZpY2F0aW9uc1RyaWdnZXJlZFN0b3JlJywgJ25vdGlmaWNhdGlvbnNfdHJpZ2dlcmVkJylcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1BcHBQcm92aWRlciwgbW1Db3JlTm90aWZpY2F0aW9uc1NpdGVzU3RvcmUsIG1tQ29yZU5vdGlmaWNhdGlvbnNDb21wb25lbnRzU3RvcmUsXG4gICAgICAgIG1tQ29yZU5vdGlmaWNhdGlvbnNUcmlnZ2VyZWRTdG9yZSkge1xuICAgIHZhciBzdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1tQ29yZU5vdGlmaWNhdGlvbnNTaXRlc1N0b3JlLCAvLyBTdG9yZSB0byBhc2lnbmUgdW5pcXVlIGNvZGVzIHRvIGVhY2ggc2l0ZS5cbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCcsXG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29kZScsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBtbUNvcmVOb3RpZmljYXRpb25zQ29tcG9uZW50c1N0b3JlLCAvLyBTdG9yZSB0byBhc2lnbmUgdW5pcXVlIGNvZGVzIHRvIGVhY2ggY29tcG9uZW50LlxuICAgICAgICAgICAga2V5UGF0aDogJ2lkJyxcbiAgICAgICAgICAgIGluZGV4ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1tQ29yZU5vdGlmaWNhdGlvbnNUcmlnZ2VyZWRTdG9yZSwgLy8gU3RvcmUgdG8gcHJldmVudCByZS10cmlnZ2VyaW5nIG5vdGlmaWNhdGlvbnMuXG4gICAgICAgICAgICBrZXlQYXRoOiAnaWQnLFxuICAgICAgICAgICAgaW5kZXhlczogW11cbiAgICAgICAgfVxuICAgIF07XG4gICAgJG1tQXBwUHJvdmlkZXIucmVnaXN0ZXJTdG9yZXMoc3RvcmVzKTtcbn0pXG5cbi8qKlxuICogRmFjdG9yeSB0byBoYW5kbGUgbG9jYWwgbm90aWZpY2F0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Mb2NhbE5vdGlmaWNhdGlvbnNcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvdmlkZXMgbWV0aG9kcyB0byB0cmlnZ2VyIG5vdGlmaWNhdGlvbnMsIGxpc3RlbiBjbGlja3Mgb24gdGhlbSwgZXRjLlxuICovXG4uZmFjdG9yeSgnJG1tTG9jYWxOb3RpZmljYXRpb25zJywgZnVuY3Rpb24oJGxvZywgJGNvcmRvdmFMb2NhbE5vdGlmaWNhdGlvbiwgJG1tQXBwLCAkcSxcbiAgICAgICAgbW1Db3JlTm90aWZpY2F0aW9uc1NpdGVzU3RvcmUsIG1tQ29yZU5vdGlmaWNhdGlvbnNDb21wb25lbnRzU3RvcmUsIG1tQ29yZU5vdGlmaWNhdGlvbnNUcmlnZ2VyZWRTdG9yZSkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUxvY2FsTm90aWZpY2F0aW9ucycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgb2JzZXJ2ZXJzID0ge30sXG4gICAgICAgIGNvZGVzID0ge307IC8vIFN0b3JlIGNvZGVzIGluIG1lbW9yeSB0byBtYWtlIGdldENvZGUgZnVuY3Rpb24gZmFzdGVyLlxuXG4gICAgLy8gV2UgbmVlZCBhIHF1ZXVlIHRvIHJlcXVlc3QgdW5pcXVlIGNvZGVzLCB0byBoYW5kbGUgc2ltdWx0YW5lb3VzIHJlcXVlc3RzLlxuICAgIHZhciBjb2RlUmVxdWVzdHNRdWV1ZSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgY29kZSB0byBjcmVhdGUgdW5pcXVlIG5vdGlmaWNhdGlvbnMuIElmIHRoZXJlJ3Mgbm8gY29kZSBhc3NpZ25lZCwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RvcmUgU3RvcmUgdG8gc2VhcmNoIGluIGxvY2FsIERCLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gaWQgICAgSUQgb2YgdGhlIGVsZW1lbnQgdG8gZ2V0IGl0cyBjb2RlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjb2RlIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb2RlKHN0b3JlLCBpZCkge1xuICAgICAgICB2YXIgZGIgPSAkbW1BcHAuZ2V0REIoKSxcbiAgICAgICAgICAgIGtleSA9IHN0b3JlICsgJyMnICsgaWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2Rlc1trZXldICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihjb2Rlc1trZXldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYi5nZXQoc3RvcmUsIGlkKS50aGVuKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHBhcnNlSW50KGVudHJ5LmNvZGUpO1xuICAgICAgICAgICAgY29kZXNba2V5XSA9IGNvZGU7XG4gICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBTaXRlIGlzIG5vdCBpbiB0aGUgREIuIENyZWF0ZSBhIG5ldyBJRCBmb3IgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGIucXVlcnkoc3RvcmUsIHVuZGVmaW5lZCwgJ2NvZGUnLCB0cnVlKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q29kZSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb2RlID0gcGFyc2VJbnQoZW50cmllc1swXS5jb2RlKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQoc3RvcmUsIHtpZDogaWQsIGNvZGU6IG5ld0NvZGV9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rlc1trZXldID0gbmV3Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvZGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc2l0ZSBjb2RlIHRvIGJlIHVzZWQuXG4gICAgICogSWYgaXQncyB0aGUgZmlyc3QgdGltZSB0aGlzIHNpdGUgaXMgdXNlZCB0byBzZW5kIG5vdGlmaWNhdGlvbnMsIGNyZWF0ZSBhIG5ldyBjb2RlIGZvciBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZWlkICAgU2l0ZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgc2l0ZSBjb2RlIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaXRlQ29kZShzaXRlaWQpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RDb2RlKG1tQ29yZU5vdGlmaWNhdGlvbnNTaXRlc1N0b3JlLCBzaXRlaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIG5vdGlmaWNhdGlvbiBjb21wb25lbnQgY29kZSB0byBiZSB1c2VkLlxuICAgICAqIElmIGl0J3MgdGhlIGZpcnN0IHRpbWUgdGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byBzZW5kIG5vdGlmaWNhdGlvbnMsIGNyZWF0ZSBhIG5ldyBjb2RlIGZvciBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgQ29tcG9uZW50IG5hbWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNvbXBvbmVudCBjb2RlIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRDb2RlKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdENvZGUobW1Db3JlTm90aWZpY2F0aW9uc0NvbXBvbmVudHNTdG9yZSwgY29tcG9uZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB1bmlxdWUgbm90aWZpY2F0aW9uIElELCB0cnlpbmcgdG8gcHJldmVudCBjb2xsaXNpb25zLiBHZW5lcmF0ZWQgSUQgbXVzdCBiZSBhIE51bWJlciAoQW5kcm9pZCkuXG4gICAgICogVGhlIGdlbmVyYXRlZCBJRCBzaG91bGRuJ3QgYmUgaGlnaGVyIHRoYW4gMjE0NzQ4MzY0NyBvciBpdCdzIGdvaW5nIHRvIGNhdXNlIHByb2JsZW1zIGluIEFuZHJvaWQuXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHByZXZlbnQgY29sbGlzaW9ucyBhbmQga2VlcCB0aGUgbnVtYmVyIHVuZGVyIEFuZHJvaWQgbGltaXQgaWY6XG4gICAgICogICAgIC1Vc2VyIGhhcyB1c2VkIGxlc3MgdGhhbiAyMSBzaXRlcy5cbiAgICAgKiAgICAgLVRoZXJlIGFyZSBsZXNzIHRoYW4gMTEgY29tcG9uZW50cy5cbiAgICAgKiAgICAgLVRoZSBub3RpZmljYXRpb25pZCBwYXNzZWQgYXMgcGFyYW1ldGVyIGlzIGxvd2VyIHRoYW4gMTAwMDAwMDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG5vdGlmaWNhdGlvbmlkIE5vdGlmaWNhdGlvbiBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgICAgIENvbXBvbmVudCB0cmlnZ2VyaW5nIHRoZSBub3RpZmljYXRpb24uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlaWQgICAgICAgICBTaXRlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBub3RpZmljYXRpb24gSUQgaXMgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFVuaXF1ZU5vdGlmaWNhdGlvbklkKG5vdGlmaWNhdGlvbmlkLCBjb21wb25lbnQsIHNpdGVpZCkge1xuICAgICAgICBpZiAoIXNpdGVpZCB8fCAhY29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0U2l0ZUNvZGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGVjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29kZShjb21wb25lbnQpLnRoZW4oZnVuY3Rpb24oY29tcG9uZW50Y29kZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgJSBvcGVyYXRpb24gdG8ga2VlcCB0aGUgbnVtYmVyIHVuZGVyIEFuZHJvaWQncyBsaW1pdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gKHNpdGVjb2RlICogMTAwMDAwMDAwICsgY29tcG9uZW50Y29kZSAqIDEwMDAwMDAwICsgcGFyc2VJbnQobm90aWZpY2F0aW9uaWQpKSAlIDIxNDc0ODM2NDc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgbmV4dCByZXF1ZXN0IGluIHF1ZXVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NOZXh0UmVxdWVzdCgpIHtcbiAgICAgICAgdmFyIG5leHRLZXkgPSBPYmplY3Qua2V5cyhjb2RlUmVxdWVzdHNRdWV1ZSlbMF0sXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICBpZiAodHlwZW9mIG5leHRLZXkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIE5vIG1vcmUgcmVxdWVzdHMgaW4gcXVldWUsIHN0b3AuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0ID0gY29kZVJlcXVlc3RzUXVldWVbbmV4dEtleV07XG4gICAgICAgIC8vIENoZWNrIGlmIHJlcXVlc3QgaXMgdmFsaWQuXG4gICAgICAgIGlmIChhbmd1bGFyLmlzT2JqZWN0KHJlcXVlc3QpICYmIHR5cGVvZiByZXF1ZXN0LnN0b3JlICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiByZXF1ZXN0LmlkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNvZGUgYW5kIHJlc29sdmUvcmVqZWN0IGFsbCB0aGUgcHJvbWlzZXMgb2YgdGhpcyByZXF1ZXN0LlxuICAgICAgICAgICAgcHJvbWlzZSA9IGdldENvZGUocmVxdWVzdC5zdG9yZSwgcmVxdWVzdC5pZCkudGhlbihmdW5jdGlvbihjb2RlKSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlcXVlc3QucHJvbWlzZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcC5yZXNvbHZlKGNvZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVxdWVzdC5wcm9taXNlcywgZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICBwLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmNlIHRoaXMgaXRlbSBpcyB0cmVhdGVkLCByZW1vdmUgaXQgYW5kIHByb2Nlc3MgbmV4dC5cbiAgICAgICAgcHJvbWlzZS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGVsZXRlIGNvZGVSZXF1ZXN0c1F1ZXVlW25leHRLZXldO1xuICAgICAgICAgICAgcHJvY2Vzc05leHRSZXF1ZXN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgYSB1bmlxdWUgY29kZS4gVGhlIHJlcXVlc3Qgd2lsbCBiZSBhZGRlZCB0byB0aGUgcXVldWUgYW5kIHRoZSBxdWV1ZSBpcyBnb2luZyB0byBiZSBzdGFydGVkIGlmIGl0J3MgcGF1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzdG9yZSBTdG9yZSB0byBzZWFyY2ggaW4gbG9jYWwgREIuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBpZCAgICBJRCBvZiB0aGUgZWxlbWVudCB0byBnZXQgaXRzIGNvZGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNvZGUgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcXVlc3RDb2RlKHN0b3JlLCBpZCkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAga2V5ID0gc3RvcmUrJyMnK2lkLFxuICAgICAgICAgICAgaXNRdWV1ZUVtcHR5ID0gT2JqZWN0LmtleXMoY29kZVJlcXVlc3RzUXVldWUpLmxlbmd0aCA9PSAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29kZVJlcXVlc3RzUXVldWVba2V5XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgcGVuZGluZyByZXF1ZXN0IGZvciB0aGlzIHN0b3JlIGFuZCBJRCwgYWRkIHRoZSBwcm9taXNlIHRvIGl0LlxuICAgICAgICAgICAgY29kZVJlcXVlc3RzUXVldWVba2V5XS5wcm9taXNlcy5wdXNoKGRlZmVycmVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCBhIHBlbmRpbmcgcmVxdWVzdCB0byB0aGUgcXVldWUuXG4gICAgICAgICAgICBjb2RlUmVxdWVzdHNRdWV1ZVtrZXldID0ge1xuICAgICAgICAgICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgcHJvbWlzZXM6IFtkZWZlcnJlZF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNRdWV1ZUVtcHR5KSB7XG4gICAgICAgICAgICBwcm9jZXNzTmV4dFJlcXVlc3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCBhIGxvY2FsIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMjY2FuY2VsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkICAgICAgICBOb3RpZmljYXRpb24gaWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCBDb21wb25lbnQgb2YgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZWlkICAgIFNpdGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIG5vdGlmaWNhdGlvbiBpcyBjYW5jZWxsZWQuXG4gICAgICovXG4gICAgc2VsZi5jYW5jZWwgPSBmdW5jdGlvbihpZCwgY29tcG9uZW50LCBzaXRlaWQpIHtcbiAgICAgICAgcmV0dXJuIGdldFVuaXF1ZU5vdGlmaWNhdGlvbklkKGlkLCBjb21wb25lbnQsIHNpdGVpZCkudGhlbihmdW5jdGlvbih1bmlxdWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhTG9jYWxOb3RpZmljYXRpb24uY2FuY2VsKHVuaXF1ZUlkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbmNlbCBhbGwgdGhlIHNjaGVkdWxlZCBub3RpZmljYXRpb25zIGJlbG9uZ2luZyB0byBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMjY2FuY2VsU2l0ZU5vdGlmaWNhdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZWlkIFNpdGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBub3RpZmljYXRpb25zIGFyZSBjYW5jZWxsZWQuXG4gICAgICovXG4gICAgc2VsZi5jYW5jZWxTaXRlTm90aWZpY2F0aW9ucyA9IGZ1bmN0aW9uKHNpdGVpZCkge1xuXG4gICAgICAgIGlmICghc2VsZi5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzaXRlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkY29yZG92YUxvY2FsTm90aWZpY2F0aW9uLmdldEFsbFNjaGVkdWxlZCgpLnRoZW4oZnVuY3Rpb24oc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICB2YXIgaWRzID0gW107XG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY2hlZHVsZWQsIGZ1bmN0aW9uKG5vdGlmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub3RpZi5kYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmLmRhdGEgPSBKU09OLnBhcnNlKG5vdGlmLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm90aWYuZGF0YSA9PSAnb2JqZWN0JyAmJiBub3RpZi5kYXRhLnNpdGVpZCA9PT0gc2l0ZWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKG5vdGlmLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhTG9jYWxOb3RpZmljYXRpb24uY2FuY2VsKGlkcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgbG9jYWwgbm90aWZpY2F0aW9ucyBwbHVnaW4gaXMgaW5zdGFsbGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvY2FsTm90aWZpY2F0aW9ucyNpc0F2YWlsYWJsZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgd2hlbiBsb2NhbCBub3RpZmljYXRpb25zIHBsdWdpbiBpcyBpbnN0YWxsZWQuXG4gICAgICovXG4gICAgc2VsZi5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnBsdWdpbiAmJiB3aW5kb3cucGx1Z2luLm5vdGlmaWNhdGlvbiAmJiB3aW5kb3cucGx1Z2luLm5vdGlmaWNhdGlvbi5sb2NhbCA/IHRydWU6IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIG5vdGlmaWNhdGlvbiBoYXMgYmVlbiB0cmlnZ2VyZWQgd2l0aCB0aGUgc2FtZSB0cmlnZ2VyIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTG9jYWxOb3RpZmljYXRpb25zI2lzVHJpZ2dlcmVkXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgbm90aWZpY2F0aW9uIE5vdGlmaWNhdGlvbiB0byBjaGVjay4gTmVlZHMgdG8gaGF2ZSAnaWQnIGFuZCAnYXQnIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBwcm9taXNlIGlzIHRyaWdnZXJlZCAodHJ1ZSkgb3Igbm90LlxuICAgICAqL1xuICAgIHNlbGYuaXNUcmlnZ2VyZWQgPSBmdW5jdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmdldChtbUNvcmVOb3RpZmljYXRpb25zVHJpZ2dlcmVkU3RvcmUsIG5vdGlmaWNhdGlvbi5pZCkudGhlbihmdW5jdGlvbihzdG9yZWQpIHtcbiAgICAgICAgICAgIHZhciBub3RpZlRpbWUgPSBub3RpZmljYXRpb24uYXQuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZWQuYXQgPT09IG5vdGlmVGltZTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgbm90aWZpY2F0aW9uIGNsaWNrIHRvIG9ic2VydmVyLiBPbmx5IHRoZSBvYnNlcnZlciB3aXRoIHRoZSBzYW1lIGNvbXBvbmVudCBhcyB0aGUgbm90aWZpY2F0aW9uIHdpbGwgYmUgbm90aWZpZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTG9jYWxOb3RpZmljYXRpb25zI25vdGlmeUNsaWNrXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSByZWNlaXZlZCBieSB0aGUgbm90aWZpY2F0aW9uLlxuICAgICAqL1xuICAgIHNlbGYubm90aWZ5Q2xpY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBkYXRhLmNvbXBvbmVudDtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gb2JzZXJ2ZXJzW2NvbXBvbmVudF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhbiBvYnNlcnZlciB0byBiZSBub3RpZmllZCB3aGVuIGEgbm90aWZpY2F0aW9uIGJlbG9uZ2luZyB0byBhIGNlcnRhaW4gY29tcG9uZW50IGlzIGNsaWNrZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTG9jYWxOb3RpZmljYXRpb25zI3JlZ2lzdGVyQ2xpY2tcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICBDb21wb25lbnQgdG8gbGlzdGVuIG5vdGlmaWNhdGlvbnMgZm9yLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGNhbGwgd2l0aCB0aGUgZGF0YSByZWNlaXZlZCBieSB0aGUgbm90aWZpY2F0aW9uLlxuICAgICAqL1xuICAgIHNlbGYucmVnaXN0ZXJDbGljayA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgJGxvZy5kZWJ1ZyhcIlJlZ2lzdGVyIG9ic2VydmVyICdcIitjb21wb25lbnQrXCInIGZvciBub3RpZmljYXRpb24gY2xpY2suXCIpO1xuICAgICAgICBvYnNlcnZlcnNbY29tcG9uZW50XSA9IGNhbGxiYWNrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBub3RpZmljYXRpb24gZnJvbSB0cmlnZ2VyZWQgc3RvcmUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTG9jYWxOb3RpZmljYXRpb25zI3JlbW92ZVRyaWdnZXJlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBOb3RpZmljYXRpb24gSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBpdCBpcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHNlbGYucmVtb3ZlVHJpZ2dlcmVkID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLnJlbW92ZShtbUNvcmVOb3RpZmljYXRpb25zVHJpZ2dlcmVkU3RvcmUsIGlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGUgYSBsb2NhbCBub3RpZmljYXRpb24uXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20va2F0emVyL2NvcmRvdmEtcGx1Z2luLWxvY2FsLW5vdGlmaWNhdGlvbnMvd2lraS8wNC4tU2NoZWR1bGluZ1xuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvY2FsTm90aWZpY2F0aW9ucyNzY2hlZHVsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZmljYXRpb24gTm90aWZpY2F0aW9uIHRvIHNjaGVkdWxlLiBJdHMgSUQgc2hvdWxkIGJlIGxvd2VyIHRoYW4gMTAwMDAwMDAgYW5kIGl0IHNob3VsZCBiZSB1bmlxdWUgaW5zaWRlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdHMgY29tcG9uZW50IGFuZCBzaXRlLiBJZiB0aGUgSUQgaXMgaGlnaGVyIHRoYW4gdGhhdCBudW1iZXIgdGhlcmUgbWlnaHQgYmUgY29sbGlzaW9ucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgIENvbXBvbmVudCB0cmlnZ2VyaW5nIHRoZSBub3RpZmljYXRpb24uIEl0IGlzIHVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZWlkICAgICAgIFNpdGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIG5vdGlmaWNhdGlvbiBpcyBzY2hlZHVsZWQuXG4gICAgICovXG4gICAgc2VsZi5zY2hlZHVsZSA9IGZ1bmN0aW9uKG5vdGlmaWNhdGlvbiwgY29tcG9uZW50LCBzaXRlaWQpIHtcbiAgICAgICAgcmV0dXJuIGdldFVuaXF1ZU5vdGlmaWNhdGlvbklkKG5vdGlmaWNhdGlvbi5pZCwgY29tcG9uZW50LCBzaXRlaWQpLnRoZW4oZnVuY3Rpb24odW5pcXVlSWQpIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5pZCA9IHVuaXF1ZUlkO1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uLmRhdGEgPSBub3RpZmljYXRpb24uZGF0YSB8fCB7fTtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5kYXRhLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5kYXRhLnNpdGVpZCA9IHNpdGVpZDtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaXNUcmlnZ2VyZWQobm90aWZpY2F0aW9uKS50aGVuKGZ1bmN0aW9uKHRyaWdnZXJlZCkge1xuICAgICAgICAgICAgICAgIGlmICghdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRyaWdnZXJlZCwgc2luY2UgdGhlIG5vdGlmaWNhdGlvbiBjb3VsZCBiZSBpbiB0aGVyZSB3aXRoIGEgZGlmZmVyZW50IHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlVHJpZ2dlcmVkKG5vdGlmaWNhdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUxvY2FsTm90aWZpY2F0aW9uLnNjaGVkdWxlKG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBub3RpZmljYXRpb24gaXMgdHJpZ2dlcmVkLiBTdG9yZXMgdGhlIG5vdGlmaWNhdGlvbiBzbyBpdCdzIG5vdCBzY2hlZHVsZWQgYWdhaW4gdW5sZXNzIHRoZVxuICAgICAqIHRpbWUgaXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMjdHJpZ2dlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZmljYXRpb24gVHJpZ2dlcmVkIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBzdG9yZWQsIHJlamVjdGVkIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLnRyaWdnZXIgPSBmdW5jdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAgICAgdmFyIGlkID0gcGFyc2VJbnQobm90aWZpY2F0aW9uLmlkKTtcbiAgICAgICAgaWYgKCFpc05hTihpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5pbnNlcnQobW1Db3JlTm90aWZpY2F0aW9uc1RyaWdnZXJlZFN0b3JlLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGF0OiBwYXJzZUludChub3RpZmljYXRpb24uYXQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pXG5cbi5ydW4oZnVuY3Rpb24oJHJvb3RTY29wZSwgJGxvZywgJG1tTG9jYWxOb3RpZmljYXRpb25zLCAkbW1FdmVudHMsIG1tQ29yZUV2ZW50U2l0ZURlbGV0ZWQpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tTG9jYWxOb3RpZmljYXRpb25zJyk7XG5cbiAgICAkcm9vdFNjb3BlLiRvbignJGNvcmRvdmFMb2NhbE5vdGlmaWNhdGlvbjp0cmlnZ2VyJywgZnVuY3Rpb24oZSwgbm90aWZpY2F0aW9uLCBzdGF0ZSkge1xuICAgICAgICAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMudHJpZ2dlcihub3RpZmljYXRpb24pO1xuICAgIH0pO1xuXG4gICAgJHJvb3RTY29wZS4kb24oJyRjb3Jkb3ZhTG9jYWxOb3RpZmljYXRpb246Y2xpY2snLCBmdW5jdGlvbihlLCBub3RpZmljYXRpb24sIHN0YXRlKSB7XG4gICAgICAgIGlmIChub3RpZmljYXRpb24gJiYgbm90aWZpY2F0aW9uLmRhdGEpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ05vdGlmaWNhdGlvbiBjbGlja2VkOiAnK25vdGlmaWNhdGlvbi5kYXRhKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShub3RpZmljYXRpb24uZGF0YSk7XG4gICAgICAgICAgICAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMubm90aWZ5Q2xpY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFNpdGVEZWxldGVkLCBmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgIGlmIChzaXRlKSB7XG4gICAgICAgICAgICAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMuY2FuY2VsU2l0ZU5vdGlmaWNhdGlvbnMoc2l0ZS5pZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLmNvbnN0YW50KCdtbUNvcmVMb2dFbmFibGVkRGVmYXVsdCcsIHRydWUpIC8vIERlZmF1bHQgdmFsdWUgZm9yIGxvZ0VuYWJsZWQuXG4uY29uc3RhbnQoJ21tQ29yZUxvZ0VuYWJsZWRDb25maWdOYW1lJywgJ2RlYnVnX2VuYWJsZWQnKVxuXG4vKipcbiAqIFByb3ZpZGVyIHRvIGRlY29yYXRlIGFuZ3VsYXIncyAkbG9nIHNlcnZpY2UuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgcHJvdmlkZXJcbiAqIEBuYW1lICRtbUxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAkbW1Mb2dQcm92aWRlci5sb2dEZWNvcmF0b3IgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gZGVjb3JhdGUgJyRsb2cnLiBJdCBzaG91bGQgYmUgdXNlZCBsaWtlIHRoaXM6XG4gKiAgICAgJHByb3ZpZGUuZGVjb3JhdG9yKCckbG9nJywgWyckZGVsZWdhdGUnLCAkbW1Mb2dQcm92aWRlci5sb2dEZWNvcmF0b3JdKTtcbiAqXG4gKiBEZWNvcmF0ZWQgJGxvZyB1c2FnZTpcbiAqICAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnTXlGYWN0b3J5JylcbiAqICAgICAkbG9nLmRlYnVnKCdNeSBtZXNzYWdlJykgLT4gXCJkZC9tbS9hYWFhIGhoOm1tOnNzIE15RmFjdG9yeTogTXkgbWVzc2FnZVwiXG4gKlxuICogVG8gcGVybWFuZW50bHkgZW5hYmxlL2Rpc2FibGUgbG9nZ2luZyBtZXNzYWdlcywgdXNlOlxuICogICAgICRtbUxvZy5lbmFibGVkKHRydWUvZmFsc2UpXG4gKi9cbi5wcm92aWRlcignJG1tTG9nJywgZnVuY3Rpb24obW1Db3JlTG9nRW5hYmxlZERlZmF1bHQpIHtcblxuICAgIHZhciBpc0VuYWJsZWQgPSBtbUNvcmVMb2dFbmFibGVkRGVmYXVsdCxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBGdW5jdGlvbiB0byBwcmUtY2FwdHVyZSBhIGxvZ2dlciBmdW5jdGlvbi5cbiAgICBmdW5jdGlvbiBwcmVwYXJlTG9nRm4obG9nRm4sIGNsYXNzTmFtZSkge1xuICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XG4gICAgICAgIC8vIEludm9rZSB0aGUgc3BlY2lmaWVkICdsb2dGbicgd2l0aCBvdXIgbmV3IGNvZGUuXG4gICAgICAgIHZhciBlbmhhbmNlZExvZ0ZuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaXNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICBub3cgID0gbW9tZW50KCkuZm9ybWF0KCdsIExUUycpO1xuXG4gICAgICAgICAgICAgICAgYXJnc1swXSA9IG5vdyArICcgJyArIGNsYXNzTmFtZSArICc6ICcgKyBhcmdzWzBdOyAvLyBQcmVwZW5kIHRpbWVzdGFtcCBhbmQgY2xhc3NOYW1lIHRvIHRoZSBvcmlnaW5hbCBtZXNzYWdlLlxuICAgICAgICAgICAgICAgIGxvZ0ZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNwZWNpYWwsIG9ubHkgbmVlZGVkIHRvIHN1cHBvcnQgYW5ndWxhci1tb2NrcyBleHBlY3RhdGlvbnMuXG4gICAgICAgIGVuaGFuY2VkTG9nRm4ubG9ncyA9IFtdO1xuXG4gICAgICAgIHJldHVybiBlbmhhbmNlZExvZ0ZuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuaGFuY2VzICRsb2cgc2VydmljZSwgYWRkaW5nIGRhdGUgYW5kIGNvbXBvbmVudCB0byB0aGUgbG9nZ2VkIG1lc3NhZ2UsIGFuZCBhbGxvd2luZyBkaXNhYmxlIGxvZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1NlcnZpY2V9ICRsb2cgQW5ndWxhcidzICRsb2cgc2VydmljZSB0byBkZWNvcmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtTZXJ2aWNlfSAgICAgIERlY29yYXRlZCAkbG9nLlxuICAgICAqL1xuICAgIHNlbGYubG9nRGVjb3JhdG9yID0gZnVuY3Rpb24oJGxvZykge1xuICAgICAgICAvLyBDb3B5IHRoZSBvcmlnaW5hbCBtZXRob2RzLlxuICAgICAgICB2YXIgXyRsb2cgPSAoZnVuY3Rpb24oJGxvZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb2cgICA6ICRsb2cubG9nLFxuICAgICAgICAgICAgICAgIGluZm8gIDogJGxvZy5pbmZvLFxuICAgICAgICAgICAgICAgIHdhcm4gIDogJGxvZy53YXJuLFxuICAgICAgICAgICAgICAgIGRlYnVnIDogJGxvZy5kZWJ1ZyxcbiAgICAgICAgICAgICAgICBlcnJvciA6ICRsb2cuZXJyb3JcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCRsb2cpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZ2V0SW5zdGFuY2UgbWV0aG9kIHNvIHNlcnZpY2VzL2NvbnRyb2xsZXJzIGNhbiBjb25maWd1cmUgdGhlIGNsYXNzTmFtZSB0byBiZSBzaG93bi5cbiAgICAgICAgdmFyIGdldEluc3RhbmNlID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvZyAgIDogcHJlcGFyZUxvZ0ZuKF8kbG9nLmxvZywgY2xhc3NOYW1lKSxcbiAgICAgICAgICAgICAgICBpbmZvICA6IHByZXBhcmVMb2dGbihfJGxvZy5pbmZvLCBjbGFzc05hbWUpLFxuICAgICAgICAgICAgICAgIHdhcm4gIDogcHJlcGFyZUxvZ0ZuKF8kbG9nLndhcm4sIGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAgZGVidWcgOiBwcmVwYXJlTG9nRm4oXyRsb2cuZGVidWcsIGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAgZXJyb3IgOiBwcmVwYXJlTG9nRm4oXyRsb2cuZXJyb3IsIGNsYXNzTmFtZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGVjb3JhdGUgb3JpZ2luYWwgJGxvZyBmdW5jdGlvbnMgdG9vLiBUaGlzIHdheSBpZiBhIHNlcnZpY2UvY29udHJvbGxlciB1c2VzICRsb2cgd2l0aG91dCAkbG9nLmdldEluc3RhbmNlLFxuICAgICAgICAvLyBpdCdzIGdvaW5nIHRvIHByZXBlbmQgdGhlIGRhdGUgYW5kICdDb3JlJy5cbiAgICAgICAgJGxvZy5sb2cgICA9IHByZXBhcmVMb2dGbigkbG9nLmxvZyk7XG4gICAgICAgICRsb2cuaW5mbyAgPSBwcmVwYXJlTG9nRm4oJGxvZy5pbmZvKTtcbiAgICAgICAgJGxvZy53YXJuICA9IHByZXBhcmVMb2dGbigkbG9nLndhcm4pO1xuICAgICAgICAkbG9nLmRlYnVnID0gcHJlcGFyZUxvZ0ZuKCRsb2cuZGVidWcpO1xuICAgICAgICAkbG9nLmVycm9yID0gcHJlcGFyZUxvZ0ZuKCRsb2cuZXJyb3IpO1xuICAgICAgICAkbG9nLmdldEluc3RhbmNlID0gZ2V0SW5zdGFuY2U7XG5cbiAgICAgICAgcmV0dXJuICRsb2c7XG4gICAgfTtcblxuICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uKCRtbUNvbmZpZywgbW1Db3JlTG9nRW5hYmxlZERlZmF1bHQsIG1tQ29yZUxvZ0VuYWJsZWRDb25maWdOYW1lKSB7XG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgbG9nZ2luZywgZW5hYmxpbmcvZGlzYWJsaW5nIGl0IGJhc2VkIG9uIHNldHRpbmdzIGFuZCBtbUNvcmVMb2dFbmFibGVkRGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tTG9nI2luaXRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tQ29uZmlnLmdldChtbUNvcmVMb2dFbmFibGVkQ29uZmlnTmFtZSkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaXNFbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBzZXQsIHVzZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlzRW5hYmxlZCA9IG1tQ29yZUxvZ0VuYWJsZWREZWZhdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlL2Rpc2FibGUgbG9nZ2luZyBpbiB0aGUgYXBwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Mb2cjZW5hYmxlZFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZsYWcgVHJ1ZSBpZiBsb2cgc2hvdWxkIGJlIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZW5hYmxlZCA9IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICAgICAgICAgICRtbUNvbmZpZy5zZXQobW1Db3JlTG9nRW5hYmxlZENvbmZpZ05hbWUsIGZsYWcpO1xuICAgICAgICAgICAgaXNFbmFibGVkID0gZmxhZztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYXBwIGxvZ2dpbmcgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tTG9nI2lzRW5hYmxlZFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGxvZyBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRW5hYmxlZDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xufSlcblxuLnJ1bihmdW5jdGlvbigkbW1Mb2cpIHtcbiAgICAkbW1Mb2cuaW5pdCgpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gcHJvdmlkZSBmdW5jdGlvbmFsaXRpZXMgcmVsYXRlZCB0byBjdXJyZW50IHNpdGUuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZmFjdG9yeVxuICogQG5hbWUgJG1tU2l0ZVxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHNlcnZpY2VzIHByb3ZpZGVzIGEgc2V0IG9mIGZ1bmN0aW9uYWxpdGllcyByZWxhdGVkIHRvIGN1cnJlbnQgc2l0ZS4gVGhlIGN1cnJlbnQgc2l0ZSBpbnN0YW5jZSBpcyBzdG9yZWQgaW4gJG1tU2l0ZXNNYW5hZ2VyLlxuICogVGhpcyBzZXJ2aWNlIGNhbiBiZSBzZWVuIGFzIGFuIGluc3RhbmNlIG9mIFNpdGUgZGVmaW5lZCBpbiAkbW1TaXRlc0ZhY3RvcnksIHdpdGggb25lIG1ldGhvZCBhZGRlZDogJG1tU2l0ZS5pc0xvZ2dlZEluLlxuICovXG4uZmFjdG9yeSgnJG1tU2l0ZScsIGZ1bmN0aW9uKCRtbVNpdGVzTWFuYWdlciwgJG1tU2l0ZXNGYWN0b3J5KSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBzaXRlTWV0aG9kcyA9ICRtbVNpdGVzRmFjdG9yeS5nZXRTaXRlTWV0aG9kcygpO1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjZ2V0SWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEN1cnJlbnQgc2l0ZSBJRC5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEdldCBjdXJyZW50IHNpdGUgSUQuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNnZXRVUkxcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEN1cnJlbnQgc2l0ZSBVUkwuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBHZXQgY3VycmVudCBzaXRlIFVSTC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2dldFRva2VuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDdXJyZW50IHNpdGUgdG9rZW4uXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBHZXQgY3VycmVudCBzaXRlIHRva2VuLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjZ2V0SW5mb1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBzaXRlIGluZm8uXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBHZXQgY3VycmVudCBzaXRlIGluZm8uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNnZXREYlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBzaXRlIERCLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogR2V0IGN1cnJlbnQgc2l0ZSBEQi5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2dldFVzZXJJZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVXNlcidzIElELlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogR2V0IGN1cnJlbnQgc2l0ZSB1c2VyJ3MgSUQuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNzZXRJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBOZXcgSUQuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBTZXQgY3VycmVudCBzaXRlIElELlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjc2V0VG9rZW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gTmV3IHRva2VuLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogU2V0IGN1cnJlbnQgc2l0ZSB0b2tlbi5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2NhbkFjY2Vzc015RmlsZXNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBGYWxzZSB3aGVuIHRoZXkgY2Fubm90LlxuICAgICAqICNkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgdXNlciBjYW4gYWNjZXNzIHByaXZhdGUgZmlsZXMgaW4gY3VycmVudCBzaXRlLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjY2FuRG93bmxvYWRGaWxlc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IEZhbHNlIHdoZW4gdGhleSBjYW5ub3QuXG4gICAgICogI2Rlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiB1c2VyIGNhbiBkb3dubG9hZCBmaWxlcyBpbiBjdXJyZW50IHNpdGUuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNjYW5Vc2VBZHZhbmNlZEZlYXR1cmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmVhdHVyZSBUaGUgbmFtZSBvZiB0aGUgZmVhdHVyZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aGVuVW5kZWZpbmVkPXRydWVdIFRoZSB2YWx1ZSB0byByZXR1cm4gd2hlbiB0aGUgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IEZhbHNlIHdoZW4gdGhleSBjYW5ub3QuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDYW4gdGhlIHVzZXIgdXNlIGFuIGFkdmFuY2VkIGZlYXR1cmU/XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNjYW5VcGxvYWRGaWxlc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IEZhbHNlIHdoZW4gdGhleSBjYW5ub3QuXG4gICAgICogI2Rlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiB1c2VyIGNhbiB1cGxvYWQgZmlsZXMgaW4gY3VycmVudCBzaXRlLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggc2l0ZSBpbmZvIGZyb20gdGhlIE1vb2RsZSBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjZmV0Y2hTaXRlSW5mb1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIGluZm8gaXMgcmV0cmlldmVkLlxuICAgICAqICNkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRmV0Y2ggc2l0ZSBpbmZvIGZyb20gdGhlIGN1cnJlbnQgTW9vZGxlIHNpdGUuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNyZWFkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSByZWFkICBXUyBtZXRob2QgdG8gdXNlLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSAgICBEYXRhIHRvIHNlbmQgdG8gdGhlIFdTLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gcHJlU2V0cyBPcHRpb25zLiBAc2VlICRtbVNpdGUjcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGZpbmlzaGVkLlxuICAgICAqICNkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVhZCBzb21lIGRhdGEgZnJvbSB0aGUgY3VycmVudCBNb29kbGUgc2l0ZSB1c2luZyBXUy4gUmVxdWVzdHMgYXJlIGNhY2hlZCBieSBkZWZhdWx0LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjd3JpdGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1ldGhvZCAgV1MgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgICAgRGF0YSB0byBzZW5kIHRvIHRoZSBXUy5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHByZVNldHMgT3B0aW9ucy4gQHNlZSAkbW1TaXRlI3JlcXVlc3QuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgcmVxdWVzdCBpcyBmaW5pc2hlZC5cbiAgICAgKiAjZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFNlbmRzIHNvbWUgZGF0YSB0byB0aGUgY3VycmVudCBNb29kbGUgc2l0ZSB1c2luZyBXUy4gUmVxdWVzdHMgYXJlIE5PVCBjYWNoZWQgYnkgZGVmYXVsdC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI3JlcXVlc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSBXZWJTZXJ2aWNlIG1ldGhvZCB0byBiZSBjYWxsZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlU2V0cyBFeHRyYSBzZXR0aW5ncy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBnZXRGcm9tQ2FjaGUgYm9vbGVhbiAoZmFsc2UpIFVzZSB0aGUgY2FjaGUgd2hlbiBwb3NzaWJsZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBzYXZlVG9DYWNoZSBib29sZWFuIChmYWxzZSkgU2F2ZSB0aGUgY2FsbCByZXN1bHRzIHRvIHRoZSBjYWNoZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBvbWl0RXhwaXJlcyBib29sZWFuIChmYWxzZSkgSWdub3JlIGNhY2hlIGV4cGlyeS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBzeW5jIGJvb2xlYW4gKGZhbHNlKSBBZGQgY2FsbCB0byBxdWV1ZSBpZiBkZXZpY2UgaXMgbm90IGNvbm5lY3RlZC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBjYWNoZUtleSAoc3RyaW5nKSBFeHRyYSBrZXkgdG8gYWRkIHRvIHRoZSBjYWNoZSB3aGVuIHN0b3JpbmcgdGhpcyBjYWxsLiBUaGlzIGtleSBpcyB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgdGhlIGNhY2hlIGVudHJ5LCBpdCBkb2Vzbid0IGFmZmVjdCB0aGUgZGF0YSByZXRyaWV2ZWQgaW4gdGhpcyBjYWxsLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIGdldENhY2hlVXNpbmdDYWNoZUtleSAoYm9vbGVhbikgVHJ1ZSBpZiBpdCBzaG91bGQgcmV0cmlldmUgY2FjaGVkIGRhdGEgYnkgY2FjaGVLZXksXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UgaWYgaXQgc2hvdWxkIGdldCB0aGUgZGF0YSBiYXNlZCBvbiB0aGUgcGFyYW1zIHBhc3NlZCAodXN1YWwgYmVoYXZpb3IpLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBTZW5kcyBhIHdlYnNlcnZpY2UgcmVxdWVzdCB0byB0aGUgc2l0ZS4gVGhpcyBtZXRob2Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZCB0aGVcbiAgICAgKiByZXF1aXJlZCBwYXJhbWV0ZXJzIGFuZCBwYXNzIGl0IG9uIHRvIHRoZSBsb3cgbGV2ZWwgQVBJIGluICRtbVdTLmNhbGwoKS5cbiAgICAgKlxuICAgICAqIENhY2hpbmcgaXMgYWxzbyBpbXBsZW1lbnRlZCwgd2hlbiBlbmFibGVkIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuZWQgYSBjYWNoZWRcbiAgICAgKiB2ZXJzaW9uIG9mIGl0c2VsZiByYXRoZXIgdGhhbiBjb250YWN0aW5nIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzbWFydCB3aGljaCBtZWFucyB0aGF0IGl0IHdpbGwgdHJ5IHRvIG1hcCB0aGUgbWV0aG9kIHRvIGFcbiAgICAgKiBjb21wYXRpYmlsaXR5IG9uZSBpZiBuZWVkIGJlLCB1c3VhbGx5IHRoYXQgbWVhbnMgdGhhdCBpdCB3aWxsIGZhbGxiYWNrIG9uXG4gICAgICogdGhlICdsb2NhbF9tb2JpbGVfJyBwcmVmaXhlZCBmdW5jdGlvbiBpZiBpdCBpcyBhdmFpbGFibGUgYW5kIHRoZSBub24tcHJlZml4ZWQgaXMgbm90LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjd3NBdmFpbGFibGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIG1ldGhvZCAgICAgIFdTIG5hbWUuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbj10cnVlfSBjaGVja1ByZWZpeCBXaGVuIHRydWUgYWxzbyBjaGVja3Mgd2l0aCB0aGUgY29tcGF0aWJpbGl0eSBwcmVmaXguXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICBUcnVlIGlmIHRoZSBXUyBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBDaGVjayBpZiBhIFdTIGlzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBzaXRlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGEgd2ViIHNlcnZpY2UgZnVuY3Rpb24gaXMgYXZhaWxhYmxlLiBCeSBkZWZhdWx0IGl0IHdpbGxcbiAgICAgKiBhbHNvIGNoZWNrIGlmIHRoZXJlIGlzIGEgY29tcGF0aWJpbGl0eSBmdW5jdGlvbiBmb3IgaXQsIGUuZy4gYSBwcmVmaXhlZCBvbmUuXG4gICAgICovXG5cbiAgICAvKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI3VwbG9hZEZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXJpIEZpbGUgVVJJLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEZpbGUgc2V0dGluZ3M6IGZpbGVLZXksIGZpbGVOYW1lIGFuZCBtaW1lVHlwZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogVXBsb2FkcyBhIGZpbGUgdG8gdGhlIGN1cnJlbnQgc2l0ZSB1c2luZyBDb3Jkb3ZhIEZpbGUgQVBJLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXlcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGtleSBLZXkgdG8gc2VhcmNoLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY2FjaGUgZW50cmllcyBhcmUgaW52YWxpZGF0ZWQuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBJbnZhbGlkYXRlcyBhbGwgdGhlIGNhY2hlIGVudHJpZXMgd2l0aCBhIGNlcnRhaW4ga2V5LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXlTdGFydGluZ1dpdGhcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGtleSBLZXkgdG8gc2VhcmNoLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY2FjaGUgZW50cmllcyBhcmUgaW52YWxpZGF0ZWQuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBJbnZhbGlkYXRlcyBhbGwgdGhlIGNhY2hlIGVudHJpZXMgd2hvc2Uga2V5IHN0YXJ0cyB3aXRoIGEgY2VydGFpbiB2YWx1ZS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2ZpeFBsdWdpbmZpbGVVUkxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgVGhlIHVybCB0byBiZSBmaXhlZC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgRml4ZWQgVVJMLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogR2VuZXJpYyBmdW5jdGlvbiBmb3IgYWRkaW5nIHRoZSB3c3Rva2VuIHRvIE1vb2RsZSB1cmxzIGFuZCBmb3IgcG9pbnRpbmcgdG8gdGhlIGNvcnJlY3Qgc2NyaXB0LlxuICAgICAqIFVzZXMgJG1tVXRpbC5maXhQbHVnaW5maWxlVVJMLCBwYXNzaW5nIGN1cnJlbnQgc2l0ZSdzIHRva2VuLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjZGVsZXRlREJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIERCIGlzIGRlbGV0ZWQuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBEZWxldGVzIGN1cnJlbnQgc2l0ZSdzIERCLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjZGVsZXRlRm9sZGVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBmb2xkZXIgaXMgZGVsZXRlZC5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIERlbGV0ZXMgY3VycmVudCBzaXRlJ3MgZm9sZGVyLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjZ2V0U3BhY2VVc2FnZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgc2l0ZSBzcGFjZSB1c2FnZSAoc2l6ZSkuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBHZXQgc3BhY2UgdXNhZ2Ugb2YgdGhlIHNpdGUuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNnZXREb2NzVXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYWdlXSAgICBEb2NzIHBhZ2UgdG8gZ28gdG8uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIE1vb2RsZSBkb2NzIFVSTC5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIFVSTCB0byB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGUgYXBwLCBiYXNlZCBvbiBNb29kbGUgdmVyc2lvbiBhbmQgY3VycmVudCBsYW5ndWFnZS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2NoZWNrTG9jYWxNb2JpbGVQbHVnaW5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNoZWNrIGlzIGRvbmUuIFJlc29sdmUgcGFyYW1zOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7TnVtYmVyfSBjb2RlIENvZGUgdG8gaWRlbnRpZnkgdGhlIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCB0byB1c2UuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IFtzZXJ2aWNlXSBJZiBkZWZpbmVkLCBuYW1lIG9mIHRoZSBzZXJ2aWNlIHRvIHVzZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gW3dhcm5pbmddIElmIGRlZmluZWQsIGNvZGUgb2YgdGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHRoZSBsb2NhbF9tb2JpbGUgcGx1Z2luIGlzIGluc3RhbGxlZCBpbiB0aGUgTW9vZGxlIHNpdGUuXG4gICAgICogVGhpcyBwbHVnaW4gcHJvdmlkZSBleHRlbmRlZCBzZXJ2aWNlcy5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2NoZWNrTG9jYWxNb2JpbGVQbHVnaW5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIGl0IGxvY2FsX21vYmlsZSB3YXMgYWRkZWQsIHJlamVjdGVkIG90aGVyd2lzZS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIENoZWNrIGlmIGxvY2FsX21vYmlsZSBoYXMgYmVlbiBpbnN0YWxsZWQgaW4gTW9vZGxlIGJ1dCB0aGUgYXBwIGlzIG5vdCB1c2luZyBpdC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2NvbnRhaW5zVXJsXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgdXJsIFVSTCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSBpZiBVUkwgYmVsb25ncyB0byB0aGlzIHNpdGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIENoZWNrIGlmIGEgVVJMIGJlbG9uZ3MgdG8gdGhpcyBzaXRlLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjZ2V0Q29tcGF0aWJsZUZ1bmN0aW9uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBtZXRob2QgV1MgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgTWV0aG9kIHRvIHVzZSBiYXNlZCBpbiB0aGUgYXZhaWxhYmxlIGZ1bmN0aW9ucy5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJldHVybiB0aGUgZnVuY3Rpb24gdG8gYmUgdXNlZCwgYmFzZWQgb24gdGhlIGF2YWlsYWJsZSBmdW5jdGlvbnMgaW4gdGhlIHNpdGUuIEl0J2xsIHRyeSB0byB1c2Ugbm9uLWRlcHJlY2F0ZWRcbiAgICAgKiBmdW5jdGlvbnMgZmlyc3QsIGFuZCBmYWxsYmFjayB0byBkZXByZWNhdGVkIG9uZXMgaWYgbmVlZGVkLlxuICAgICAqL1xuXG4gICAgLy8gUmVwbGljYXRlIGFsbCBTaXRlIG1ldGhvZHMgcmVmaW5lZCBpbiAkbW1TaXRlc0ZhY3RvcnkgdG8gYmUgdXNlZCB3aXRoIGN1cnJlbnQgc2l0ZS5cbiAgICBhbmd1bGFyLmZvckVhY2goc2l0ZU1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICBzZWxmW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2l0ZSA9ICRtbVNpdGVzTWFuYWdlci5nZXRDdXJyZW50U2l0ZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50U2l0ZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2l0ZVttZXRob2RdLmFwcGx5KGN1cnJlbnRTaXRlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHVzZXIgaXMgbG9nZ2VkIGluIGEgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2lzTG9nZ2VkSW5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB1c2VyIGlzIGxvZ2dlZCBpbiBhIHNpdGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzTG9nZ2VkSW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTaXRlID0gJG1tU2l0ZXNNYW5hZ2VyLmdldEN1cnJlbnRTaXRlKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudFNpdGUgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGN1cnJlbnRTaXRlLnRva2VuICE9ICd1bmRlZmluZWQnICYmIGN1cnJlbnRTaXRlLnRva2VuICE9ICcnO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLnZhbHVlKCdtbUNvcmVXU1ByZWZpeCcsICdsb2NhbF9tb2JpbGVfJylcblxuLmNvbnN0YW50KCdtbUNvcmVXU0NhY2hlU3RvcmUnLCAnd3NjYWNoZScpXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tU2l0ZXNGYWN0b3J5UHJvdmlkZXIsIG1tQ29yZVdTQ2FjaGVTdG9yZSkge1xuICAgIHZhciBzdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1tQ29yZVdTQ2FjaGVTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCcsXG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAna2V5J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIF07XG4gICAgJG1tU2l0ZXNGYWN0b3J5UHJvdmlkZXIucmVnaXN0ZXJTdG9yZXMoc3RvcmVzKTtcbn0pXG5cbi8qKlxuICogUHJvdmlkZXIgdG8gY3JlYXRlIHNpdGVzIGluc3RhbmNlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBwcm92aWRlclxuICogQG5hbWUgJG1tU2l0ZXNGYWN0b3J5XG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgcHJvdmlkZXIgaXMgdGhlIGludGVyZmFjZSB3aXRoIHRoZSBEQiBkYXRhYmFzZS4gVGhlIG1vZHVsZXMgdGhhdCBuZWVkIHRvIHN0b3JlXG4gKiBpbmZvcm1hdGlvbiBoZXJlIG5lZWQgdG8gcmVnaXN0ZXIgdGhlaXIgc3RvcmVzLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogLmNvbmZpZyhmdW5jdGlvbigkbW1TaXRlc0ZhY3RvcnlQcm92aWRlcikge1xuICogICAgICAkbW1TaXRlc0ZhY3RvcnlQcm92aWRlci5yZWdpc3RlclN0b3JlKHtcbiAqICAgICAgICAgIG5hbWU6ICdjb3Vyc2VzJyxcbiAqICAgICAgICAgIGtleVBhdGg6ICdpZCdcbiAqICAgICAgfSk7XG4gKiAgfSlcbiAqXG4gKiBUaGUgc2VydmljZSAkbW1TaXRlc0ZhY3RvcnkgaXMgdXNlZCB0byBjcmVhdGUgc2l0ZSBpbnN0YW5jZXMuIEl0J3Mgbm90IGludGVuZGVkIHRvIGJlIHVzZWQgZGlyZWN0bHksIGl0cyB1c2FnZSBpc1xuICogcmVzdHJpY3RlZCB0byBjb3JlLiBEZXZlbG9wZXJzIHNob3VsZCBvbmx5IHVzZSAkbW1TaXRlc0ZhY3RvcnlQcm92aWRlciwgJG1tU2l0ZXNNYW5hZ2VyIGFuZCAkbW1TaXRlLlxuICovXG4ucHJvdmlkZXIoJyRtbVNpdGVzRmFjdG9yeScsIGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqIERlZmluZSB0aGUgc2l0ZSBzdG9yYWdlIHNjaGVtYS4gKi9cbiAgICB2YXIgc2l0ZVNjaGVtYSA9IHtcbiAgICAgICAgICAgIHN0b3JlczogW11cbiAgICAgICAgfSxcbiAgICAgICAgZGJvcHRpb25zID0ge1xuICAgICAgICAgICAgYXV0b1NjaGVtYTogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBzdG9yZSBzY2hlbWEuXG4gICAgICogSU1QT1JUQU5UOiBNb2RpZnlpbmcgdGhlIHNjaGVtYSBvZiBhbiBhbHJlYWR5IGV4aXN0aW5nIHN0b3JlIGRlbGV0ZXMgYWxsIGl0cyBkYXRhIGluIFdlYlNRTCBTdG9yYWdlLlxuICAgICAqIElmIGEgc3RvcmUgc2NoZW1hIG5lZWRzIHRvIGJlIG1vZGlmaWVkLCB0aGUgZGF0YSBzaG91bGQgYmUgbWFudWFsbHkgbWlncmF0ZWQgdG8gdGhlIG5ldyBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc3RvcmUgVGhlIHN0b3JlIG9iamVjdCBkZWZpbml0aW9uLlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdGhpcy5yZWdpc3RlclN0b3JlID0gZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZihzdG9yZS5uYW1lKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCckbW1TaXRlOiBFcnJvcjogc3RvcmUgbmFtZSBpcyB1bmRlZmluZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoc3RvcmVFeGlzdHMoc3RvcmUubmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCckbW1TaXRlOiBFcnJvcjogc3RvcmUgJyArIHN0b3JlLm5hbWUgKyAnIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzaXRlU2NoZW1hLnN0b3Jlcy5wdXNoKHN0b3JlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgbXVsdGlwbGUgc3RvcmVzIGF0IG9uY2UuXG4gICAgICogSU1QT1JUQU5UOiBNb2RpZnlpbmcgdGhlIHNjaGVtYSBvZiBhbiBhbHJlYWR5IGV4aXN0aW5nIHN0b3JlIGRlbGV0ZXMgYWxsIGl0cyBkYXRhIGluIFdlYlNRTCBTdG9yYWdlLlxuICAgICAqIElmIGEgc3RvcmUgc2NoZW1hIG5lZWRzIHRvIGJlIG1vZGlmaWVkLCB0aGUgZGF0YSBzaG91bGQgYmUgbWFudWFsbHkgbWlncmF0ZWQgdG8gdGhlIG5ldyBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBzdG9yZXMgQXJyYXkgb2Ygc3RvcmUgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHRoaXMucmVnaXN0ZXJTdG9yZXMgPSBmdW5jdGlvbihzdG9yZXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goc3RvcmVzLCBmdW5jdGlvbihzdG9yZSkge1xuICAgICAgICAgICAgc2VsZi5yZWdpc3RlclN0b3JlKHN0b3JlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc3RvcmUgaXMgYWxyZWFkeSBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIHdoZW4gdGhlIHN0b3JlIHdhcyBhbHJlYWR5IGRlZmluZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmVFeGlzdHMobmFtZSkge1xuICAgICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzaXRlU2NoZW1hLnN0b3JlcywgZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgICAgIGlmIChzdG9yZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgfVxuXG4gICAgdGhpcy4kZ2V0ID0gZnVuY3Rpb24oJGh0dHAsICRxLCAkbW1XUywgJG1tREIsICRsb2csIG1kNSwgJG1tQXBwLCAkbW1MYW5nLCAkbW1VdGlsLCAkbW1GUywgbW1Db3JlV1NDYWNoZVN0b3JlLFxuICAgICAgICAgICAgbW1Db3JlV1NQcmVmaXgsIG1tQ29yZVNlc3Npb25FeHBpcmVkLCAkbW1FdmVudHMsIG1tQ29yZUV2ZW50U2Vzc2lvbkV4cGlyZWQsIG1tQ29yZVVzZXJEZWxldGVkLCBtbUNvcmVFdmVudFVzZXJEZWxldGVkLFxuICAgICAgICAgICAgJG1tVGV4dCwgbW1Db3JlQ29uZmlnQ29uc3RhbnRzKSB7XG5cbiAgICAgICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbVNpdGUnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBkZXByZWNhdGVkIFdTIGZ1bmN0aW9ucyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgTk9UIGRlcHJlY2F0ZWQgbmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB0aGUgZnVuY3Rpb24gZG9lcyBub3QgaGF2ZSBhbiBlcXVpdmFsZW50IHNldCBpdHMgdmFsdWUgdG8gdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBkZXByZWNhdGVkRnVuY3Rpb25zID0ge1xuICAgICAgICAgICAgXCJjb3JlX2dyYWRlX2dldF9kZWZpbml0aW9uc1wiOiBcImNvcmVfZ3JhZGluZ19nZXRfZGVmaW5pdGlvbnNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX2NvdXJzZV9jcmVhdGVfY291cnNlc1wiOiBcImNvcmVfY291cnNlX2NyZWF0ZV9jb3Vyc2VzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9jb3Vyc2VfZ2V0X2NvdXJzZXNcIjogXCJjb3JlX2NvdXJzZV9nZXRfY291cnNlc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfZW5yb2xfZ2V0X3VzZXJzX2NvdXJzZXNcIjogXCJjb3JlX2Vucm9sX2dldF91c2Vyc19jb3Vyc2VzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9maWxlX2dldF9maWxlc1wiOiBcImNvcmVfZmlsZXNfZ2V0X2ZpbGVzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9maWxlX3VwbG9hZFwiOiBcImNvcmVfZmlsZXNfdXBsb2FkXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9ncm91cF9hZGRfZ3JvdXBtZW1iZXJzXCI6IFwiY29yZV9ncm91cF9hZGRfZ3JvdXBfbWVtYmVyc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfZ3JvdXBfY3JlYXRlX2dyb3Vwc1wiOiBcImNvcmVfZ3JvdXBfY3JlYXRlX2dyb3Vwc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfZ3JvdXBfZGVsZXRlX2dyb3VwbWVtYmVyc1wiOiBcImNvcmVfZ3JvdXBfZGVsZXRlX2dyb3VwX21lbWJlcnNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX2dyb3VwX2RlbGV0ZV9ncm91cHNcIjogXCJjb3JlX2dyb3VwX2RlbGV0ZV9ncm91cHNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX2dyb3VwX2dldF9jb3Vyc2VfZ3JvdXBzXCI6IFwiY29yZV9ncm91cF9nZXRfY291cnNlX2dyb3Vwc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfZ3JvdXBfZ2V0X2dyb3VwbWVtYmVyc1wiOiBcImNvcmVfZ3JvdXBfZ2V0X2dyb3VwX21lbWJlcnNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX2dyb3VwX2dldF9ncm91cHNcIjogXCJjb3JlX2dyb3VwX2dldF9ncm91cHNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX21lc3NhZ2Vfc2VuZF9pbnN0YW50bWVzc2FnZXNcIjogXCJjb3JlX21lc3NhZ2Vfc2VuZF9pbnN0YW50X21lc3NhZ2VzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9ub3Rlc19jcmVhdGVfbm90ZXNcIjogXCJjb3JlX25vdGVzX2NyZWF0ZV9ub3Rlc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfcm9sZV9hc3NpZ25cIjogXCJjb3JlX3JvbGVfYXNzaWduX3JvbGVcIixcbiAgICAgICAgICAgIFwibW9vZGxlX3JvbGVfdW5hc3NpZ25cIjogXCJjb3JlX3JvbGVfdW5hc3NpZ25fcm9sZVwiLFxuICAgICAgICAgICAgXCJtb29kbGVfdXNlcl9jcmVhdGVfdXNlcnNcIjogXCJjb3JlX3VzZXJfY3JlYXRlX3VzZXJzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV91c2VyX2RlbGV0ZV91c2Vyc1wiOiBcImNvcmVfdXNlcl9kZWxldGVfdXNlcnNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX3VzZXJfZ2V0X2NvdXJzZV9wYXJ0aWNpcGFudHNfYnlfaWRcIjogXCJjb3JlX3VzZXJfZ2V0X2NvdXJzZV91c2VyX3Byb2ZpbGVzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV91c2VyX2dldF91c2Vyc19ieV9jb3Vyc2VpZFwiOiBcImNvcmVfZW5yb2xfZ2V0X2Vucm9sbGVkX3VzZXJzXCIsXG4gICAgICAgICAgICAvLyBCb3RoICpfdXNlcl9nZXRfdXNlcnNfYnlfaWQgYXJlIGRlcHJlY2F0ZWQsIGJ1dCB0aGVyZSBpcyBubyBlcXVpdmFsZW50IGF2YWlsYWJsZSBpbiB0aGUgTW9iaWxlIHNlcnZpY2UuXG4gICAgICAgICAgICBcIm1vb2RsZV91c2VyX2dldF91c2Vyc19ieV9pZFwiOiBcImNvcmVfdXNlcl9nZXRfdXNlcnNfYnlfaWRcIixcbiAgICAgICAgICAgIFwibW9vZGxlX3VzZXJfdXBkYXRlX3VzZXJzXCI6IFwiY29yZV91c2VyX3VwZGF0ZV91c2Vyc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfd2Vic2VydmljZV9nZXRfc2l0ZWluZm9cIjogXCJjb3JlX3dlYnNlcnZpY2VfZ2V0X3NpdGVfaW5mb1wiLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpdGUgb2JqZWN0IHRvIHN0b3JlIHNpdGUgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlkICAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGV1cmwgU2l0ZSBVUkwuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiAgIFVzZXIncyB0b2tlbiBpbiB0aGUgc2l0ZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGluZm9zICAgU2l0ZSdzIGluZm8uXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBTaXRlKGlkLCBzaXRldXJsLCB0b2tlbiwgaW5mb3MpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuc2l0ZXVybCA9IHNpdGV1cmw7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0aGlzLmluZm9zID0gaW5mb3M7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYiA9ICRtbURCLmdldERCKCdTaXRlLScgKyB0aGlzLmlkLCBzaXRlU2NoZW1hLCBkYm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzaXRlIElELlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEN1cnJlbnQgc2l0ZSBJRC5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHNpdGUgVVJMLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEN1cnJlbnQgc2l0ZSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5nZXRVUkwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpdGV1cmw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzaXRlIHRva2VuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEN1cnJlbnQgc2l0ZSB0b2tlbi5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHNpdGUgaW5mby5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IHNpdGUgaW5mby5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmdldEluZm8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZm9zO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc2l0ZSBEQi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IHNpdGUgREIuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5nZXREYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzaXRlIHVzZXIncyBJRC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBVc2VyJ3MgSUQuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5nZXRVc2VySWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbmZvcyAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy5pbmZvcy51c2VyaWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmZvcy51c2VyaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBzaXRlIElELlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gTmV3IElELlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuc2V0SWQgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5kYiA9ICRtbURCLmdldERCKCdTaXRlLScgKyB0aGlzLmlkLCBzaXRlU2NoZW1hLCBkYm9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgc2l0ZSB0b2tlbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IE5ldyB0b2tlbi5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLnNldFRva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHNpdGUgaW5mby5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IE5ldyBpbmZvLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuc2V0SW5mbyA9IGZ1bmN0aW9uKGluZm9zKSB7XG4gICAgICAgICAgICB0aGlzLmluZm9zID0gaW5mb3M7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiB0aGUgdXNlciBhY2Nlc3MgdGhlaXIgcHJpdmF0ZSBmaWxlcz9cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gRmFsc2Ugd2hlbiB0aGV5IGNhbm5vdC5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmNhbkFjY2Vzc015RmlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbmZvcyA9IHRoaXMuZ2V0SW5mbygpO1xuICAgICAgICAgICAgcmV0dXJuIGluZm9zICYmICh0eXBlb2YgaW5mb3MudXNlcmNhbm1hbmFnZW93bmZpbGVzID09PSAndW5kZWZpbmVkJyB8fCBpbmZvcy51c2VyY2FubWFuYWdlb3duZmlsZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW4gdGhlIHVzZXIgZG93bmxvYWQgZmlsZXM/XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IEZhbHNlIHdoZW4gdGhleSBjYW5ub3QuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5jYW5Eb3dubG9hZEZpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5mb3MgPSB0aGlzLmdldEluZm8oKTtcbiAgICAgICAgICAgIHJldHVybiBpbmZvcyAmJiBpbmZvcy5kb3dubG9hZGZpbGVzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW4gdGhlIHVzZXIgdXNlIGFuIGFkdmFuY2VkIGZlYXR1cmU/XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmZWF0dXJlIFRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aGVuVW5kZWZpbmVkPXRydWVdIFRoZSB2YWx1ZSB0byByZXR1cm4gd2hlbiB0aGUgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBGYWxzZSB3aGVuIHRoZXkgY2Fubm90LlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuY2FuVXNlQWR2YW5jZWRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSwgd2hlblVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGluZm9zID0gdGhpcy5nZXRJbmZvKCksXG4gICAgICAgICAgICAgICAgY2FuVXNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgd2hlblVuZGVmaW5lZCA9ICh0eXBlb2Ygd2hlblVuZGVmaW5lZCA9PT0gJ3VuZGVmaW5lZCcpID8gdHJ1ZSA6IHdoZW5VbmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5mb3MuYWR2YW5jZWRmZWF0dXJlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjYW5Vc2UgPSB3aGVuVW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChpbmZvcy5hZHZhbmNlZGZlYXR1cmVzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm5hbWUgPT09IGZlYXR1cmUgJiYgcGFyc2VJbnQoaXRlbS52YWx1ZSwgMTApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5Vc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYW5Vc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiB0aGUgdXNlciB1cGxvYWQgZmlsZXM/XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IEZhbHNlIHdoZW4gdGhleSBjYW5ub3QuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5jYW5VcGxvYWRGaWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGluZm9zID0gdGhpcy5nZXRJbmZvKCk7XG4gICAgICAgICAgICByZXR1cm4gaW5mb3MgJiYgaW5mb3MudXBsb2FkZmlsZXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHNpdGUgaW5mbyBmcm9tIHRoZSBNb29kbGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHNpdGUgaW5mbyBpcyByZXRyaWV2ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5mZXRjaFNpdGVJbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgICAgIHNpdGUgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBnZXRfc2l0ZV9pbmZvIHdvbid0IGJlIGNhY2hlZC5cbiAgICAgICAgICAgIHZhciBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGdldEZyb21DYWNoZTogMCxcbiAgICAgICAgICAgICAgICBzYXZlVG9DYWNoZTogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2l0ZS5yZWFkKCdjb3JlX3dlYnNlcnZpY2VfZ2V0X3NpdGVfaW5mbycsIHt9LCBwcmVTZXRzKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc2l0ZS5yZWFkKCdtb29kbGVfd2Vic2VydmljZV9nZXRfc2l0ZWluZm8nLCB7fSwgcHJlU2V0cykudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIHNvbWUgZGF0YSBmcm9tIHRoZSBNb29kbGUgc2l0ZSB1c2luZyBXUy4gUmVxdWVzdHMgYXJlIGNhY2hlZCBieSBkZWZhdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHJlYWQgIFdTIG1ldGhvZCB0byB1c2UuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSAgICBEYXRhIHRvIHNlbmQgdG8gdGhlIFdTLlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHByZVNldHMgT3B0aW9uczogQHNlZSBTaXRlI3JlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHJlcXVlc3QgaXMgZmluaXNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obWV0aG9kLCBkYXRhLCBwcmVTZXRzKSB7XG4gICAgICAgICAgICBwcmVTZXRzID0gcHJlU2V0cyB8fCB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YocHJlU2V0cy5nZXRGcm9tQ2FjaGUpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByZVNldHMuZ2V0RnJvbUNhY2hlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YocHJlU2V0cy5zYXZlVG9DYWNoZSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcHJlU2V0cy5zYXZlVG9DYWNoZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mKHByZVNldHMuc3luYykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcHJlU2V0cy5zeW5jID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWV0aG9kLCBkYXRhLCBwcmVTZXRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgc29tZSBkYXRhIHRvIHRoZSBNb29kbGUgc2l0ZSB1c2luZyBXUy4gUmVxdWVzdHMgYXJlIE5PVCBjYWNoZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBtZXRob2QgIFdTIG1ldGhvZCB0byB1c2UuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSAgICBEYXRhIHRvIHNlbmQgdG8gdGhlIFdTLlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHByZVNldHMgT3B0aW9uczogQHNlZSBTaXRlI3JlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHJlcXVlc3QgaXMgZmluaXNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG1ldGhvZCwgZGF0YSwgcHJlU2V0cykge1xuICAgICAgICAgICAgcHJlU2V0cyA9IHByZVNldHMgfHwge307XG4gICAgICAgICAgICBpZiAodHlwZW9mKHByZVNldHMuZ2V0RnJvbUNhY2hlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwcmVTZXRzLmdldEZyb21DYWNoZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mKHByZVNldHMuc2F2ZVRvQ2FjaGUpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByZVNldHMuc2F2ZVRvQ2FjaGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZihwcmVTZXRzLnN5bmMpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByZVNldHMuc3luYyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1ldGhvZCwgZGF0YSwgcHJlU2V0cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdTIHJlcXVlc3QgdG8gdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIFdlYlNlcnZpY2UgbWV0aG9kIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByZVNldHMgRXh0cmEgc2V0dGluZ3MuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAtIGdldEZyb21DYWNoZSBib29sZWFuIChmYWxzZSkgVXNlIHRoZSBjYWNoZSB3aGVuIHBvc3NpYmxlLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBzYXZlVG9DYWNoZSBib29sZWFuIChmYWxzZSkgU2F2ZSB0aGUgY2FsbCByZXN1bHRzIHRvIHRoZSBjYWNoZS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgIC0gb21pdEV4cGlyZXMgYm9vbGVhbiAoZmFsc2UpIElnbm9yZSBjYWNoZSBleHBpcnkuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAtIGVtZXJnZW5jeUNhY2hlIGJvb2xlYW4gKHRydWUpIElmIHBvc3NpYmxlLCB1c2UgdGhlIGNhY2hlIHdoZW4gdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAtIHN5bmMgYm9vbGVhbiAoZmFsc2UpIEFkZCBjYWxsIHRvIHF1ZXVlIGlmIGRldmljZSBpcyBub3QgY29ubmVjdGVkLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBjYWNoZUtleSAoc3RyaW5nKSBFeHRyYSBrZXkgdG8gYWRkIHRvIHRoZSBjYWNoZSB3aGVuIHN0b3JpbmcgdGhpcyBjYWxsLiBUaGlzIGtleSBpcyB0b1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFnIHRoZSBjYWNoZSBlbnRyeSwgaXQgZG9lc24ndCBhZmZlY3QgdGhlIGRhdGEgcmV0cmlldmVkIGluIHRoaXMgY2FsbC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgIC0gZ2V0Q2FjaGVVc2luZ0NhY2hlS2V5IChib29sZWFuKSBUcnVlIGlmIGl0IHNob3VsZCByZXRyaWV2ZSBjYWNoZWQgZGF0YSBieSBjYWNoZUtleSxcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UgaWYgaXQgc2hvdWxkIGdldCB0aGUgZGF0YSBiYXNlZCBvbiB0aGUgcGFyYW1zIHBhc3NlZCAodXN1YWwgYmVoYXZpb3IpLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2VuZHMgYSB3ZWJzZXJ2aWNlIHJlcXVlc3QgdG8gdGhlIHNpdGUuIFRoaXMgbWV0aG9kIHdpbGwgYXV0b21hdGljYWxseSBhZGQgdGhlXG4gICAgICAgICAqIHJlcXVpcmVkIHBhcmFtZXRlcnMgYW5kIHBhc3MgaXQgb24gdG8gdGhlIGxvdyBsZXZlbCBBUEkgaW4gJG1tV1MuY2FsbCgpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWNoaW5nIGlzIGFsc28gaW1wbGVtZW50ZWQsIHdoZW4gZW5hYmxlZCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybmVkIGEgY2FjaGVkXG4gICAgICAgICAqIHZlcnNpb24gb2YgaXRzZWxmIHJhdGhlciB0aGFuIGNvbnRhY3RpbmcgdGhlIHNlcnZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgc21hcnQgd2hpY2ggbWVhbnMgdGhhdCBpdCB3aWxsIHRyeSB0byBtYXAgdGhlIG1ldGhvZCB0byBhXG4gICAgICAgICAqIGNvbXBhdGliaWxpdHkgb25lIGlmIG5lZWQgYmUsIHVzdWFsbHkgdGhhdCBtZWFucyB0aGF0IGl0IHdpbGwgZmFsbGJhY2sgb25cbiAgICAgICAgICogdGhlICdsb2NhbF9tb2JpbGVfJyBwcmVmaXhlZCBmdW5jdGlvbiBpZiBpdCBpcyBhdmFpbGFibGUgYW5kIHRoZSBub24tcHJlZml4ZWQgaXMgbm90LlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgZGF0YSwgcHJlU2V0cykge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKSxcbiAgICAgICAgICAgICAgICBzaXRlID0gdGhpcztcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIG1ldGhvZCB0byB1c2UgYmFzZWQgb24gdGhlIGF2YWlsYWJsZSBvbmVzLlxuICAgICAgICAgICAgbWV0aG9kID0gc2l0ZS5nZXRDb21wYXRpYmxlRnVuY3Rpb24obWV0aG9kKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1ldGhvZCBpcyBhdmFpbGFibGUsIHVzZSBhIHByZWZpeGVkIHZlcnNpb24gaWYgcG9zc2libGUuXG4gICAgICAgICAgICAvLyBXZSBpZ25vcmUgdGhpcyBjaGVjayB3aGVuIHdlIGRvIG5vdCBoYXZlIHRoZSBzaXRlIGluZm8sIGFzIHRoZSBsaXN0IG9mIGZ1bmN0aW9ucyBpcyBub3QgbG9hZGVkIHlldC5cbiAgICAgICAgICAgIGlmIChzaXRlLmdldEluZm8oKSAmJiAhc2l0ZS53c0F2YWlsYWJsZShtZXRob2QsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaXRlLndzQXZhaWxhYmxlKG1tQ29yZVdTUHJlZml4ICsgbWV0aG9kLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5pbmZvKFwiVXNpbmcgY29tcGF0aWJpbGl0eSBXUyBtZXRob2QgJ1wiICsgbW1Db3JlV1NQcmVmaXggKyBtZXRob2QgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IG1tQ29yZVdTUHJlZml4ICsgbWV0aG9kO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoXCJXUyBmdW5jdGlvbiAnXCIgKyBtZXRob2QgKyBcIicgaXMgbm90IGF2YWlsYWJsZSwgZXZlbiBpbiBjb21wYXRpYmlsaXR5IG1vZGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW0uY29yZS53c2Z1bmN0aW9ubm90YXZhaWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJlU2V0cyA9IGFuZ3VsYXIuY29weShwcmVTZXRzKSB8fCB7fTtcbiAgICAgICAgICAgIHByZVNldHMud3N0b2tlbiA9IHNpdGUudG9rZW47XG4gICAgICAgICAgICBwcmVTZXRzLnNpdGV1cmwgPSBzaXRlLnNpdGV1cmw7XG5cbiAgICAgICAgICAgIC8vIEVuYWJsZSB0ZXh0IGZpbHRlcmluZy5cbiAgICAgICAgICAgIGRhdGEubW9vZGxld3NzZXR0aW5nZmlsdGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZ2V0RnJvbUNhY2hlKHNpdGUsIG1ldGhvZCwgZGF0YSwgcHJlU2V0cykudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBwYXNzIHRob3NlIG9wdGlvbnMgdG8gdGhlIGNvcmUgV1MgZmFjdG9yeS5cbiAgICAgICAgICAgICAgICB2YXIgd3NQcmVTZXRzID0gYW5ndWxhci5jb3B5KHByZVNldHMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3c1ByZVNldHMuZ2V0RnJvbUNhY2hlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3c1ByZVNldHMuc2F2ZVRvQ2FjaGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHdzUHJlU2V0cy5vbWl0RXhwaXJlcztcbiAgICAgICAgICAgICAgICBkZWxldGUgd3NQcmVTZXRzLmNhY2hlS2V5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3c1ByZVNldHMuZW1lcmdlbmN5Q2FjaGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHdzUHJlU2V0cy5nZXRDYWNoZVVzaW5nQ2FjaGVLZXk7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBTeW5jXG5cbiAgICAgICAgICAgICAgICAkbW1XUy5jYWxsKG1ldGhvZCwgZGF0YSwgd3NQcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZVNldHMuc2F2ZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVUb0NhY2hlKHNpdGUsIG1ldGhvZCwgZGF0YSwgcmVzcG9uc2UsIHByZVNldHMuY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcGFzcyBiYWNrIGEgY2xvbmUgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgdGhpcyBtYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBlcnJvcnMgaWYgaW4gdGhlIGNhbGxiYWNrIHRoZSBvYmplY3QgaXMgbW9kaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoYW5ndWxhci5jb3B5KHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yID09PSBtbUNvcmVTZXNzaW9uRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Vzc2lvbiBleHBpcmVkLCB0cmlnZ2VyIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgJ21tLmNvcmUubG9zdGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50U2Vzc2lvbkV4cGlyZWQsIHNpdGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yID09PSBtbUNvcmVVc2VyRGVsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlciBkZWxldGVkLCB0cmlnZ2VyIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgJ21tLmNvcmUudXNlcmRlbGV0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50VXNlckRlbGV0ZWQsIHtzaXRlaWQ6IHNpdGUuaWQsIHBhcmFtczogZGF0YX0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcmVTZXRzLmVtZXJnZW5jeUNhY2hlICE9PSAndW5kZWZpbmVkJyAmJiAhcHJlU2V0cy5lbWVyZ2VuY3lDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnV1MgY2FsbCAnICsgbWV0aG9kICsgJyBmYWlsZWQuIEVtZXJnZW5jeSBjYWNoZSBpcyBmb3JiaWRkZW4sIHJlamVjdGluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdXUyBjYWxsICcgKyBtZXRob2QgKyAnIGZhaWxlZC4gVHJ5aW5nIHRvIHVzZSB0aGUgZW1lcmdlbmN5IGNhY2hlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlU2V0cy5vbWl0RXhwaXJlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVTZXRzLmdldEZyb21DYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRGcm9tQ2FjaGUoc2l0ZSwgbWV0aG9kLCBkYXRhLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGEgV1MgaXMgYXZhaWxhYmxlIGluIHRoaXMgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBtZXRob2QgV1MgbmFtZS5cbiAgICAgICAgICogQHBhcmFtICB7Qm9vbGVhbj10cnVlfSBjaGVja1ByZWZpeCBXaGVuIHRydWUgYWxzbyBjaGVja3Mgd2l0aCB0aGUgY29tcGF0aWJpbGl0eSBwcmVmaXguXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgIFRydWUgaWYgdGhlIFdTIGlzIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGEgd2ViIHNlcnZpY2UgZnVuY3Rpb24gaXMgYXZhaWxhYmxlLiBCeSBkZWZhdWx0IGl0IHdpbGxcbiAgICAgICAgICogYWxzbyBjaGVjayBpZiB0aGVyZSBpcyBhIGNvbXBhdGliaWxpdHkgZnVuY3Rpb24gZm9yIGl0LCBlLmcuIGEgcHJlZml4ZWQgb25lLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUud3NBdmFpbGFibGUgPSBmdW5jdGlvbihtZXRob2QsIGNoZWNrUHJlZml4KSB7XG4gICAgICAgICAgICBjaGVja1ByZWZpeCA9ICh0eXBlb2YgY2hlY2tQcmVmaXggPT09ICd1bmRlZmluZWQnKSA/IHRydWUgOiBjaGVja1ByZWZpeDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmluZm9zID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5mb3MuZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSB0aGlzLmluZm9zLmZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZi5uYW1lID09IG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExldCdzIHRyeSBhZ2FpbiB3aXRoIHRoZSBjb21wYXRpYmlsaXR5IHByZWZpeC5cbiAgICAgICAgICAgIGlmIChjaGVja1ByZWZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndzQXZhaWxhYmxlKG1tQ29yZVdTUHJlZml4ICsgbWV0aG9kLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBVcGxvYWRzIGEgZmlsZSB1c2luZyBDb3Jkb3ZhIEZpbGUgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdXJpIEZpbGUgVVJJLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBGaWxlIHNldHRpbmdzOiBmaWxlS2V5LCBmaWxlTmFtZSBhbmQgbWltZVR5cGUuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS51cGxvYWRGaWxlID0gZnVuY3Rpb24odXJpLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tV1MudXBsb2FkRmlsZSh1cmksIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBzaXRldXJsOiB0aGlzLnNpdGV1cmwsXG4gICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudG9rZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZhbGlkYXRlcyBhbGwgdGhlIGNhY2hlIGVudHJpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY2FjaGUgZW50cmllcyBhcmUgaW52YWxpZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5pbnZhbGlkYXRlV3NDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRiID0gdGhpcy5kYjtcbiAgICAgICAgICAgIGlmICghZGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0ludmFsaWRhdGUgYWxsIHRoZSBjYWNoZSBmb3Igc2l0ZTogJysgdGhpcy5pZCk7XG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0QWxsKG1tQ29yZVdTQ2FjaGVTdG9yZSkudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMgJiYgZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkYXRlV3NDYWNoZUVudHJpZXMoZGIsIGVudHJpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZhbGlkYXRlcyBhbGwgdGhlIGNhY2hlIGVudHJpZXMgd2l0aCBhIGNlcnRhaW4ga2V5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGtleSBLZXkgdG8gc2VhcmNoLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNhY2hlIGVudHJpZXMgYXJlIGludmFsaWRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBkYiA9IHRoaXMuZGI7XG4gICAgICAgICAgICBpZiAoIWRiIHx8ICFrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0ludmFsaWRhdGUgY2FjaGUgZm9yIGtleTogJytrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGRiLndoZXJlRXF1YWwobW1Db3JlV1NDYWNoZVN0b3JlLCAna2V5Jywga2V5KS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcyAmJiBlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludmFsaWRhdGVXc0NhY2hlRW50cmllcyhkYiwgZW50cmllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludmFsaWRhdGVzIGFsbCB0aGUgY2FjaGUgZW50cmllcyB3aG9zZSBrZXkgc3RhcnRzIHdpdGggYSBjZXJ0YWluIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGtleSBLZXkgdG8gc2VhcmNoLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNhY2hlIGVudHJpZXMgYXJlIGludmFsaWRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXlTdGFydGluZ1dpdGggPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBkYiA9IHRoaXMuZGI7XG4gICAgICAgICAgICBpZiAoIWRiIHx8ICFrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0ludmFsaWRhdGUgY2FjaGUgZm9yIGtleSBzdGFydGluZyB3aXRoOiAnK2tleSk7XG4gICAgICAgICAgICByZXR1cm4gZGIud2hlcmUobW1Db3JlV1NDYWNoZVN0b3JlLCAna2V5JywgJ14nLCBrZXkpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW52YWxpZGF0ZVdzQ2FjaGVFbnRyaWVzKGRiLCBlbnRyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJpYyBmdW5jdGlvbiBmb3IgYWRkaW5nIHRoZSB3c3Rva2VuIHRvIE1vb2RsZSB1cmxzIGFuZCBmb3IgcG9pbnRpbmcgdG8gdGhlIGNvcnJlY3Qgc2NyaXB0LlxuICAgICAgICAgKiBVc2VzICRtbVV0aWwuZml4UGx1Z2luZmlsZVVSTCwgcGFzc2luZyBzaXRlJ3MgdG9rZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICBUaGUgdXJsIHRvIGJlIGZpeGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgRml4ZWQgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuZml4UGx1Z2luZmlsZVVSTCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbVV0aWwuZml4UGx1Z2luZmlsZVVSTCh1cmwsIHRoaXMudG9rZW4pO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZXMgc2l0ZSdzIERCLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIERCIGlzIGRlbGV0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5kZWxldGVEQiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbURCLmRlbGV0ZURCKCdTaXRlLScgKyB0aGlzLmlkKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBzaXRlJ3MgZm9sZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIERCIGlzIGRlbGV0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5kZWxldGVGb2xkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpdGVGb2xkZXIgPSAkbW1GUy5nZXRTaXRlRm9sZGVyKHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GUy5yZW1vdmVEaXIoc2l0ZUZvbGRlcikuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgZXJyb3JzLCAkbW1GUy5yZW1vdmVEaXIgZmFpbHMgaWYgZm9sZGVyIGRvZXNuJ3QgZXhpc3RzLlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc3BhY2UgdXNhZ2Ugb2YgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgc2l0ZSBzcGFjZSB1c2FnZSAoc2l6ZSkuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5nZXRTcGFjZVVzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzaXRlRm9sZGVyUGF0aCA9ICRtbUZTLmdldFNpdGVGb2xkZXIodGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUZTLmdldERpcmVjdG9yeVNpemUoc2l0ZUZvbGRlclBhdGgpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIFVSTCB0byB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGUgYXBwLCBiYXNlZCBvbiBNb29kbGUgdmVyc2lvbiBhbmQgY3VycmVudCBsYW5ndWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYWdlXSAgICBEb2NzIHBhZ2UgdG8gZ28gdG8uXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBNb29kbGUgZG9jcyBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5nZXREb2NzVXJsID0gZnVuY3Rpb24ocGFnZSkge1xuICAgICAgICAgICAgdmFyIHJlbGVhc2UgPSB0aGlzLmluZm9zLnJlbGVhc2UgPyB0aGlzLmluZm9zLnJlbGVhc2UgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gJG1tVXRpbC5nZXREb2NzVXJsKHJlbGVhc2UsIHBhZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiB0aGUgbG9jYWxfbW9iaWxlIHBsdWdpbiBpcyBpbnN0YWxsZWQgaW4gdGhlIE1vb2RsZSBzaXRlLlxuICAgICAgICAgKiBUaGlzIHBsdWdpbiBwcm92aWRlIGV4dGVuZGVkIHNlcnZpY2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHJ5aW5nIFRydWUgaWYgd2UncmUgcmV0cnlpbmcgdGhlIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY2hlY2sgaXMgZG9uZS4gUmVzb2x2ZSBwYXJhbXM6XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtOdW1iZXJ9IGNvZGUgQ29kZSB0byBpZGVudGlmeSB0aGUgYXV0aGVudGljYXRpb24gbWV0aG9kIHRvIHVzZS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gW3NlcnZpY2VdIElmIGRlZmluZWQsIG5hbWUgb2YgdGhlIHNlcnZpY2UgdG8gdXNlLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBbd2FybmluZ10gSWYgZGVmaW5lZCwgY29kZSBvZiB0aGUgd2FybmluZyBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuY2hlY2tMb2NhbE1vYmlsZVBsdWdpbiA9IGZ1bmN0aW9uKHJldHJ5aW5nKSB7XG4gICAgICAgICAgICB2YXIgc2l0ZXVybCA9IHRoaXMuc2l0ZXVybCxcbiAgICAgICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlID0gbW1Db3JlQ29uZmlnQ29uc3RhbnRzLndzZXh0c2VydmljZTtcblxuICAgICAgICAgICAgaWYgKCFzZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZXJuYWwgc2VydmljZSBub3QgZGVmaW5lZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbih7Y29kZTogMH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJGh0dHAucG9zdChzaXRldXJsICsgJy9sb2NhbC9tb2JpbGUvY2hlY2sucGhwJywge3NlcnZpY2U6IHNlcnZpY2V9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9ICd1bmRlZmluZWQnICYmIGRhdGEuZXJyb3Jjb2RlID09PSAncmVxdWlyZWNvcnJlY3RhY2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmV0cnlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2l0ZXVybCA9ICRtbVRleHQuYWRkT3JSZW1vdmVXV1coc2l0ZXVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jaGVja0xvY2FsTW9iaWxlUGx1Z2luKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChkYXRhLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT0gJ3VuZGVmaW5lZCcgfHzCoHR5cGVvZiBkYXRhLmNvZGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9jYWxfbW9iaWxlIHJldHVybmVkIHNvbWV0aGluZyB3ZSBkaWRuJ3QgZXhwZWN0LiBMZXQncyBhc3N1bWUgaXQncyBub3QgaW5zdGFsbGVkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvZGU6IDAsIHdhcm5pbmc6ICdtbS5sb2dpbi5sb2NhbG1vYmlsZXVuZXhwZWN0ZWRyZXNwb25zZSd9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gcGFyc2VJbnQoZGF0YS5jb2RlLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2l0ZSBpbiBtYWludGVuYW5jZSBtb2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0ubG9naW4uc2l0ZWlubWFpbnRlbmFuY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZWIgc2VydmljZXMgbm90IGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5sb2dpbi53ZWJzZXJ2aWNlc25vdGVuYWJsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmRlZCBzZXJ2aWNlIG5vdCBlbmFibGVkLCBidXQgdGhlIG9mZmljaWFsIGlzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2RlOiAwfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWl0aGVyIGV4dGVuZGVkIG9yIG9mZmljaWFsIHNlcnZpY2VzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5sb2dpbi5tb2JpbGVzZXJ2aWNlc25vdGVuYWJsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5jb3JlLnVuZXhwZWN0ZWRlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2RlOiBjb2RlLCBzZXJ2aWNlOiBzZXJ2aWNlfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2NvZGU6IDB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGxvY2FsX21vYmlsZSBoYXMgYmVlbiBpbnN0YWxsZWQgaW4gTW9vZGxlIGJ1dCB0aGUgYXBwIGlzIG5vdCB1c2luZyBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCBpdCBsb2NhbF9tb2JpbGUgd2FzIGFkZGVkLCByZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5jaGVja0lmTG9jYWxNb2JpbGVJbnN0YWxsZWRBbmROb3RVc2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXBwVXNlc0xvY2FsTW9iaWxlID0gZmFsc2U7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2godGhpcy5pbmZvcy5mdW5jdGlvbnMsIGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYy5uYW1lLmluZGV4T2YobW1Db3JlV1NQcmVmaXgpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcFVzZXNMb2NhbE1vYmlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChhcHBVc2VzTG9jYWxNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHAgYWxyZWFkeSB1c2VzIGxvY2FsX21vYmlsZSwgaXQgd2Fzbid0IGFkZGVkLlxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tMb2NhbE1vYmlsZVBsdWdpbigpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS5zZXJ2aWNlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvY2FsX21vYmlsZSBOT1QgaW5zdGFsbGVkLiBSZWplY3QuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYSBVUkwgYmVsb25ncyB0byB0aGlzIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHVybCBVUkwgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIFVSTCBiZWxvbmdzIHRvIHRoaXMgc2l0ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuY29udGFpbnNVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNpdGV1cmwgPSAkbW1UZXh0LnJlbW92ZVByb3RvY29sQW5kV1dXKHRoaXMuc2l0ZXVybCk7XG4gICAgICAgICAgICB1cmwgPSAkbW1UZXh0LnJlbW92ZVByb3RvY29sQW5kV1dXKHVybCk7XG4gICAgICAgICAgICByZXR1cm4gdXJsLmluZGV4T2Yoc2l0ZXVybCkgPT0gMDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW52YWxpZGF0ZSBlbnRyaWVzIGZyb20gdGhlIGNhY2hlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRiICAgICAgREIgdGhlIGVudHJpZXMgYmVsb25nIHRvLlxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheX0gIGVudHJpZXMgRW50cmllcyB0byBpbnZhbGlkYXRlLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjYWNoZSBlbnRyaWVzIGFyZSBpbnZhbGlkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGludmFsaWRhdGVXc0NhY2hlRW50cmllcyhkYiwgZW50cmllcykge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5leHBpcmF0aW9udGltZSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBkYi5pbnNlcnQobW1Db3JlV1NDYWNoZVN0b3JlLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBmdW5jdGlvbiB0byBiZSB1c2VkLCBiYXNlZCBvbiB0aGUgYXZhaWxhYmxlIGZ1bmN0aW9ucyBpbiB0aGUgc2l0ZS4gSXQnbGwgdHJ5IHRvIHVzZSBub24tZGVwcmVjYXRlZFxuICAgICAgICAgKiBmdW5jdGlvbnMgZmlyc3QsIGFuZCBmYWxsYmFjayB0byBkZXByZWNhdGVkIG9uZXMgaWYgbmVlZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1ldGhvZCBXUyBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgTWV0aG9kIHRvIHVzZSBiYXNlZCBpbiB0aGUgYXZhaWxhYmxlIGZ1bmN0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmdldENvbXBhdGlibGVGdW5jdGlvbiA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXByZWNhdGVkRnVuY3Rpb25zW21ldGhvZF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXByZWNhdGVkIGZ1bmN0aW9uIGlzIGJlaW5nIHVzZWQuIFdhcm4gdGhlIGRldmVsb3Blci5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy53c0F2YWlsYWJsZShkZXByZWNhdGVkRnVuY3Rpb25zW21ldGhvZF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cud2FybihcIllvdSBhcmUgdXNpbmcgZGVwcmVjYXRlZCBXZWIgU2VydmljZXM6IFwiICsgbWV0aG9kICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIHlvdSBtdXN0IHJlcGxhY2UgaXQgd2l0aCB0aGUgbmV3ZXIgZnVuY3Rpb246IFwiICsgZGVwcmVjYXRlZEZ1bmN0aW9uc1ttZXRob2RdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcHJlY2F0ZWRGdW5jdGlvbnNbbWV0aG9kXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLndhcm4oXCJZb3UgYXJlIHVzaW5nIGRlcHJlY2F0ZWQgV2ViIFNlcnZpY2VzLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIllvdXIgcmVtb3RlIHNpdGUgc2VlbXMgdG8gYmUgb3V0ZGF0ZWQsIGNvbnNpZGVyIHVwZ3JhZGUgaXQgdG8gdGhlIGxhdGVzdCBNb29kbGUgdmVyc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy53c0F2YWlsYWJsZShtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgLy8gTWV0aG9kIG5vdCBhdmFpbGFibGUuIENoZWNrIGlmIHRoZXJlIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgdG8gdXNlLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIG9sZEZ1bmMgaW4gZGVwcmVjYXRlZEZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwcmVjYXRlZEZ1bmN0aW9uc1tvbGRGdW5jXSA9PT0gbWV0aG9kICYmIHRoaXMud3NBdmFpbGFibGUob2xkRnVuYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRsb2cud2FybihcIllvdXIgcmVtb3RlIHNpdGUgZG9lc24ndCBzdXBwb3J0IHRoZSBmdW5jdGlvbiBcIiArIG1ldGhvZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGl0IHNlZW1zIHRvIGJlIG91dGRhdGVkLCBjb25zaWRlciB1cGdyYWRlIGl0IHRvIHRoZSBsYXRlc3QgTW9vZGxlIHZlcnNpb24uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZEZ1bmM7IC8vIFVzZSBkZXByZWNhdGVkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgV1MgcmVzcG9uc2UgZnJvbSBjYWNoZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNpdGUgICAgU2l0ZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAgVGhlIFdlYlNlcnZpY2UgbWV0aG9kLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlU2V0cyBFeHRyYSBzZXR0aW5ncy5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aXRoIHRoZSBXUyByZXNwb25zZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldEZyb21DYWNoZShzaXRlLCBtZXRob2QsIGRhdGEsIHByZVNldHMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgICAgICAgZGIgPSBzaXRlLmRiLFxuICAgICAgICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKSxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICAgICAgICBpZiAoIWRiKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwcmVTZXRzLmdldEZyb21DYWNoZSkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZCA9IG1kNS5jcmVhdGVIYXNoKG1ldGhvZCArICc6JyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcblxuICAgICAgICAgICAgaWYgKHByZVNldHMuZ2V0Q2FjaGVVc2luZ0NhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IGRiLndoZXJlRXF1YWwobW1Db3JlV1NDYWNoZVN0b3JlLCAna2V5JywgcHJlU2V0cy5jYWNoZUtleSkudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSBrZXkgbm90IGZvdW5kLCBnZXQgYnkgcGFyYW1zIHNlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIuZ2V0KG1tQ29yZVdTQ2FjaGVTdG9yZSwgaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyaWVzWzBdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gZGIuZ2V0KG1tQ29yZVdTQ2FjaGVTdG9yZSwgaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgICAgICBwcmVTZXRzLm9taXRFeHBpcmVzID0gcHJlU2V0cy5vbWl0RXhwaXJlcyB8fCAhJG1tQXBwLmlzT25saW5lKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXByZVNldHMub21pdEV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyA+IGVudHJ5LmV4cGlyYXRpb250aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdDYWNoZWQgZWxlbWVudCBmb3VuZCwgYnV0IGl0IGlzIGV4cGlyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZW50cnkuZGF0YSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwaXJlcyA9IChlbnRyeS5leHBpcmF0aW9udGltZSAtIG5vdykgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmluZm8oJ0NhY2hlZCBlbGVtZW50IGZvdW5kLCBpZDogJyArIGlkICsgJyBleHBpcmVzIGluICcgKyBleHBpcmVzICsgJyBzZWNvbmRzJyk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZW50cnkuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhdmUgYSBXUyByZXNwb25zZSB0byBjYWNoZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNpdGUgICAgU2l0ZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAgIFRoZSBXZWJTZXJ2aWNlIG1ldGhvZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVTZXRzICBFeHRyYSBzZXR0aW5ncy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGNhY2hlS2V5IChPcHRpb25hbCkgRXh0cmEga2V5IHRvIGFkZCB0byB0aGUgY2FjaGUgb2JqZWN0IHRvIGlkZW50aWZ5IHNpbWlsYXIgY2FsbHMuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHJlc3BvbnNlIGlzIHNhdmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2F2ZVRvQ2FjaGUoc2l0ZSwgbWV0aG9kLCBkYXRhLCByZXNwb25zZSwgY2FjaGVLZXkpIHtcbiAgICAgICAgICAgIHZhciBkYiA9IHNpdGUuZGIsXG4gICAgICAgICAgICAgICAgaWQgPSBtZDUuY3JlYXRlSGFzaChtZXRob2QgKyAnOicgKyBKU09OLnN0cmluZ2lmeShkYXRhKSksXG4gICAgICAgICAgICAgICAgY2FjaGVFeHBpcmF0aW9uVGltZSA9IG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5jYWNoZV9leHBpcmF0aW9uX3RpbWUsXG4gICAgICAgICAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIWRiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWNoZUV4cGlyYXRpb25UaW1lID0gaXNOYU4oY2FjaGVFeHBpcmF0aW9uVGltZSkgPyAzMDAwMDAgOiBjYWNoZUV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgICAgICAgIGVudHJ5LmV4cGlyYXRpb250aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBjYWNoZUV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5rZXkgPSBjYWNoZUtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRiLmluc2VydChtbUNvcmVXU0NhY2hlU3RvcmUsIGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIGEgc2l0ZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVNpdGVzRmFjdG9yeSNtYWtlU2l0ZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgICAgICBTaXRlIElELlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZXVybCBTaXRlIFVSTC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuICAgVXNlcidzIHRva2VuIGluIHRoZSBzaXRlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5mb3MgICBTaXRlJ3MgaW5mby5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY3VycmVudCBzaXRlIG9iamVjdC5cbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFRoaXMgcmV0dXJucyBhIHNpdGUgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5tYWtlU2l0ZSA9IGZ1bmN0aW9uKGlkLCBzaXRldXJsLCB0b2tlbiwgaW5mb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2l0ZShpZCwgc2l0ZXVybCwgdG9rZW4sIGluZm9zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgbGlzdCBvZiBTaXRlIG1ldGhvZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVNpdGVzRmFjdG9yeSNnZXRTaXRlTWV0aG9kc1xuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gTGlzdCBvZiBtZXRob2RzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRTaXRlTWV0aG9kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gU2l0ZS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBtZXRob2RzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcztcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4uY29uc3RhbnQoJ21tQ29yZVNpdGVzU3RvcmUnLCAnc2l0ZXMnKVxuLmNvbnN0YW50KCdtbUNvcmVDdXJyZW50U2l0ZVN0b3JlJywgJ2N1cnJlbnRfc2l0ZScpXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQXBwUHJvdmlkZXIsIG1tQ29yZVNpdGVzU3RvcmUsIG1tQ29yZUN1cnJlbnRTaXRlU3RvcmUpIHtcbiAgICB2YXIgc3RvcmVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBtbUNvcmVTaXRlc1N0b3JlLFxuICAgICAgICAgICAga2V5UGF0aDogJ2lkJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBtbUNvcmVDdXJyZW50U2l0ZVN0b3JlLFxuICAgICAgICAgICAga2V5UGF0aDogJ2lkJ1xuICAgICAgICB9XG4gICAgXTtcbiAgICAkbW1BcHBQcm92aWRlci5yZWdpc3RlclN0b3JlcyhzdG9yZXMpO1xufSlcblxuLyoqXG4gKiBTaXRlcyBtYW5hZ2VyIHNlcnZpY2UuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyXG4gKi9cbi5mYWN0b3J5KCckbW1TaXRlc01hbmFnZXInLCBmdW5jdGlvbigkaHR0cCwgJHEsICRtbVNpdGVzRmFjdG9yeSwgbWQ1LCAkbW1MYW5nLCAkbW1BcHAsICRtbVV0aWwsICRtbUV2ZW50cywgJHN0YXRlLFxuICAgICAgICAgICAgJHRyYW5zbGF0ZSwgbW1Db3JlU2l0ZXNTdG9yZSwgbW1Db3JlQ3VycmVudFNpdGVTdG9yZSwgbW1Db3JlRXZlbnRMb2dpbiwgbW1Db3JlRXZlbnRMb2dvdXQsICRsb2csIG1tQ29yZVdTUHJlZml4LFxuICAgICAgICAgICAgbW1Db3JlRXZlbnRTaXRlVXBkYXRlZCwgbW1Db3JlRXZlbnRTaXRlQWRkZWQsIG1tQ29yZUV2ZW50U2Vzc2lvbkV4cGlyZWQsIG1tQ29yZUV2ZW50U2l0ZURlbGV0ZWQsICRtbVRleHQsXG4gICAgICAgICAgICBtbUNvcmVDb25maWdDb25zdGFudHMpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1TaXRlc01hbmFnZXInKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIHNlcnZpY2VzID0ge30sXG4gICAgICAgIHNlc3Npb25SZXN0b3JlZCA9IGZhbHNlLFxuICAgICAgICBjdXJyZW50U2l0ZSxcbiAgICAgICAgc2l0ZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVtbyBkYXRhIG9mIHRoZSBzaXRldXJsIGlmIGl0IGlzIGEgZGVtbyBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciNnZXREZW1vU2l0ZURhdGFcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGV1cmwgVVJMIG9mIHRoZSBzaXRlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBTaXRlIGRhdGEgaWYgaXQncyBhIGRlbW8gc2l0ZSwgdW5kZWZpbmVkIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldERlbW9TaXRlRGF0YSA9IGZ1bmN0aW9uKHNpdGV1cmwpIHtcbiAgICAgICAgdmFyIGRlbW9TaXRlcyA9IG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5kZW1vX3NpdGVzO1xuICAgICAgICBpZiAodHlwZW9mIGRlbW9TaXRlcyAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVtb1NpdGVzW3NpdGV1cmxdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVtb1NpdGVzW3NpdGV1cmxdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc2l0ZSBpcyB2YWxpZCBhbmQgaWYgaXQgaGFzIHNwZWNpZmljcyBzZXR0aW5ncyBmb3IgYXV0aGVudGljYXRpb25cbiAgICAgKiAobGlrZSBmb3JjZSB0byBsb2cgaW4gdXNpbmcgdGhlIGJyb3dzZXIpLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciNjaGVja1NpdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZXVybCAgVVJMIG9mIHRoZSBzaXRlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB0byB1c2UuIElmIG5vdCBkZWZpbmVkLCB1c2UgaHR0cHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIEEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIGlzIGNoZWNrZWQuIFJlc29sdmUgcGFyYW1zOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IGNvZGUgICAgICBDb2RlIHRvIGlkZW50aWZ5IHRoZSBhdXRoZW50aWNhdGlvbiBtZXRob2QgdG8gdXNlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IHNpdGV1cmwgICBTaXRlIHVybCB0byB1c2UgKG1pZ2h0IGhhdmUgY2hhbmdlZCBkdXJpbmcgdGhlIHByb2Nlc3MpLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFt3YXJuaW5nXSBDb2RlIG9mIHRoZSB3YXJuaW5nIG1lc3NhZ2UgdG8gc2hvdyB0byB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBzZWxmLmNoZWNrU2l0ZSA9IGZ1bmN0aW9uKHNpdGV1cmwsIHByb3RvY29sKSB7XG5cbiAgICAgICAgLy8gZm9ybWF0VVJMIGFkZHMgdGhlIHByb3RvY29sIGlmIGlzIG1pc3NpbmcuXG4gICAgICAgIHNpdGV1cmwgPSAkbW1VdGlsLmZvcm1hdFVSTChzaXRldXJsKTtcblxuICAgICAgICBpZiAoc2l0ZXVybC5pbmRleE9mKCc6Ly9sb2NhbGhvc3QnKSA9PSAtMSAmJiAhJG1tVXRpbC5pc1ZhbGlkVVJMKHNpdGV1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmxvZ2luLmludmFsaWRzaXRlJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoISRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmNvcmUubmV0d29ya2Vycm9ybXNnJyk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHByb3RvY29sID0gcHJvdG9jb2wgfHwgXCJodHRwczovL1wiO1xuXG4gICAgICAgICAgICAvLyBOb3csIHJlcGxhY2UgdGhlIHNpdGV1cmwgd2l0aCB0aGUgcHJvdG9jb2wuXG4gICAgICAgICAgICBzaXRldXJsID0gc2l0ZXVybC5yZXBsYWNlKC9eaHR0cChzKT9cXDpcXC9cXC8vaSwgcHJvdG9jb2wpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zaXRlRXhpc3RzKHNpdGV1cmwpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHNpdGUgdG8gY2hlY2sgaWYgbG9jYWxfbW9iaWxlIGlzIGluc3RhbGxlZC5cbiAgICAgICAgICAgICAgICB2YXIgdGVtcG9yYXJ5U2l0ZSA9ICRtbVNpdGVzRmFjdG9yeS5tYWtlU2l0ZSh1bmRlZmluZWQsIHNpdGV1cmwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wb3JhcnlTaXRlLmNoZWNrTG9jYWxNb2JpbGVQbHVnaW4oKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l0ZXVybCA9IHRlbXBvcmFyeVNpdGUuZ2V0VVJMKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2VzW3NpdGV1cmxdID0gZGF0YS5zZXJ2aWNlOyAvLyBObyBuZWVkIHRvIHN0b3JlIGl0IGluIERCLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3NpdGV1cmw6IHNpdGV1cmwsIGNvZGU6IGRhdGEuY29kZSwgd2FybmluZzogZGF0YS53YXJuaW5nfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFNpdGUgZG9lc24ndCBleGlzdC5cblxuICAgICAgICAgICAgICAgIGlmIChzaXRldXJsLmluZGV4T2YoXCJodHRwczovL1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXRyeSB3aXRob3V0IEhUVFBTLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jaGVja1NpdGUoc2l0ZXVybCwgXCJodHRwOi8vXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5jb3JlLmNhbm5vdGNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHNpdGUgZXhpc3RzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciNzaXRlRXhpc3RzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRldXJsIFVSTCBvZiB0aGUgc2l0ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgQSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIGlmIHRoZSBzaXRlIGV4aXN0cy5cbiAgICAgKi9cbiAgICBzZWxmLnNpdGVFeGlzdHMgPSBmdW5jdGlvbihzaXRldXJsKSB7XG4gICAgICAgIHZhciB1cmwgPSBzaXRldXJsICsgJy9sb2dpbi90b2tlbi5waHAnO1xuICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzV2ViVmlldygpKSB7XG4gICAgICAgICAgICAvLyBXZSBwYXNzIGZha2UgcGFyYW1ldGVycyB0byBtYWtlIENPUlMgd29yayAod2l0aG91dCBwYXJhbXMsIHRoZSBzY3JpcHQgc3RvcHMgYmVmb3JlIGFsbG93aW5nIENPUlMpLlxuICAgICAgICAgICAgdXJsID0gdXJsICsgJz91c2VybmFtZT1hJnBhc3N3b3JkPWImc2VydmljZT1jJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KHVybCwge3RpbWVvdXQ6IDMwMDAwfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSB1c2VyIHRva2VuIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjZ2V0VXNlclRva2VuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGV1cmwgICBUaGUgc2l0ZSB1cmwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lICBVc2VyIG5hbWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkICBQYXNzd29yZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlcnZpY2VdIFNlcnZpY2UgdG8gdXNlLiBJZiBub3QgZGVmaW5lZCwgaXQgd2lsbCBiZSBzZWFyY2hlZCBpbiBtZW1vcnkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXRyeSAgICBXZSBhcmUgcmV0cnlpbmcgd2l0aCBhIHByZWZpeGVkIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIEEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSB0b2tlbiBpcyByZXRyaWV2ZWQuIElmIHN1Y2Nlc3MsIHJldHVybnMgYW4gb2JqZWN0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSB0b2tlbiBhbmQgdGhlIHNpdGV1cmwgdG8gdXNlLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0VXNlclRva2VuID0gZnVuY3Rpb24oc2l0ZXVybCwgdXNlcm5hbWUsIHBhc3N3b3JkLCBzZXJ2aWNlLCByZXRyeSkge1xuICAgICAgICByZXRyeSA9IHJldHJ5IHx8IGZhbHNlO1xuXG4gICAgICAgIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0uY29yZS5uZXR3b3JrZXJyb3Jtc2cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2VydmljZSkge1xuICAgICAgICAgICAgc2VydmljZSA9IGRldGVybWluZVNlcnZpY2Uoc2l0ZXVybCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9naW51cmwgPSBzaXRldXJsICsgJy9sb2dpbi90b2tlbi5waHAnO1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcbiAgICAgICAgICAgIHNlcnZpY2U6IHNlcnZpY2VcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJGh0dHAucG9zdChsb2dpbnVybCwgZGF0YSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmNvcmUuY2Fubm90Y29ubmVjdCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEudG9rZW4gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0b2tlbjogZGF0YS50b2tlbiwgc2l0ZXVybDogc2l0ZXVybH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmVycm9yICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGFsbG93IG9uZSByZXRyeSAodG8gYXZvaWQgbG9vcHMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXRyeSAmJiBkYXRhLmVycm9yY29kZSA9PSBcInJlcXVpcmVjb3JyZWN0YWNjZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXRldXJsID0gJG1tVGV4dC5hZGRPclJlbW92ZVdXVyhzaXRldXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRVc2VyVG9rZW4oc2l0ZXVybCwgdXNlcm5hbWUsIHBhc3N3b3JkLCBzZXJ2aWNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChkYXRhLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0ubG9naW4uaW52YWxpZGFjY291bnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmNvcmUuY2Fubm90Y29ubmVjdCcpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IHNpdGUgdG8gdGhlIHNpdGUgbGlzdCBhbmQgYXV0aGVudGljYXRlIHRoZSB1c2VyIGluIHRoaXMgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjbmV3U2l0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRldXJsICBUaGUgc2l0ZSB1cmwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuICAgIFVzZXIncyB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgQSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHNpdGUgaXMgYWRkZWQgYW5kIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWQuXG4gICAgICovXG4gICAgc2VsZi5uZXdTaXRlID0gZnVuY3Rpb24oc2l0ZXVybCwgdG9rZW4pIHtcblxuICAgICAgICB2YXIgY2FuZGlkYXRlU2l0ZSA9ICRtbVNpdGVzRmFjdG9yeS5tYWtlU2l0ZSh1bmRlZmluZWQsIHNpdGV1cmwsIHRva2VuKTtcblxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlU2l0ZS5mZXRjaFNpdGVJbmZvKCkudGhlbihmdW5jdGlvbihpbmZvcykge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRNb29kbGVWZXJzaW9uKGluZm9zKSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0aW9uID0gdmFsaWRhdGVTaXRlSW5mbyhpbmZvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpdGVpZCA9IHNlbGYuY3JlYXRlU2l0ZUlEKGluZm9zLnNpdGV1cmwsIGluZm9zLnVzZXJuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHNpdGUgdG8gc2l0ZXMgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRTaXRlKHNpdGVpZCwgc2l0ZXVybCwgdG9rZW4sIGluZm9zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHVybiBjYW5kaWRhdGUgc2l0ZSBpbnRvIGN1cnJlbnQgc2l0ZS5cbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlU2l0ZS5zZXRJZChzaXRlaWQpO1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVTaXRlLnNldEluZm8oaW5mb3MpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l0ZSA9IGNhbmRpZGF0ZVNpdGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHNlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9naW4oc2l0ZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRTaXRlQWRkZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdHJhbnNsYXRlKHZhbGlkYXRpb24uZXJyb3IsIHZhbGlkYXRpb24ucGFyYW1zKS50aGVuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmxvZ2luLmludmFsaWRtb29kbGV2ZXJzaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaXRlIElEIGJhc2VkIG9uIHNpdGUgVVJMIGFuZCB1c2VybmFtZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjY3JlYXRlU2l0ZUlEXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGV1cmwgIFRoZSBzaXRlIHVybC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgVXNlcm5hbWUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIFNpdGUgSUQuXG4gICAgICovXG4gICAgc2VsZi5jcmVhdGVTaXRlSUQgPSBmdW5jdGlvbihzaXRldXJsLCB1c2VybmFtZSkge1xuICAgICAgICByZXR1cm4gbWQ1LmNyZWF0ZUhhc2goc2l0ZXVybCArIHVzZXJuYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gZm9yIGRldGVybWluZSB3aGljaCBzZXJ2aWNlIHdlIHNob3VsZCB1c2UgKGRlZmF1bHQgb3IgZXh0ZW5kZWQgcGx1Z2luKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZXVybCBUaGUgc2l0ZSBVUkwuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIFRoZSBzZXJ2aWNlIHNob3J0bmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmVTZXJ2aWNlKHNpdGV1cmwpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB0cnkgc2l0ZXVybCBpbiBib3RoIGh0dHBzIG9yIGh0dHAgKGR1ZSB0byBsb2dpbmh0dHBzIHNldHRpbmcpLlxuXG4gICAgICAgIC8vIEZpcnN0IGh0dHA6Ly9cbiAgICAgICAgc2l0ZXVybCA9IHNpdGV1cmwucmVwbGFjZShcImh0dHBzOi8vXCIsIFwiaHR0cDovL1wiKTtcbiAgICAgICAgaWYgKHNlcnZpY2VzW3NpdGV1cmxdKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VydmljZXNbc2l0ZXVybF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgaHR0cHM6Ly9cbiAgICAgICAgc2l0ZXVybCA9IHNpdGV1cmwucmVwbGFjZShcImh0dHA6Ly9cIiwgXCJodHRwczovL1wiKTtcbiAgICAgICAgaWYgKHNlcnZpY2VzW3NpdGV1cmxdKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VydmljZXNbc2l0ZXVybF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gZGVmYXVsdCBzZXJ2aWNlLlxuICAgICAgICByZXR1cm4gbW1Db3JlQ29uZmlnQ29uc3RhbnRzLndzc2VydmljZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgdGhlIG1pbmltdW0gcmVxdWlyZWQgdmVyc2lvbiAoTW9vZGxlIDIuNCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzaXRlZnVuY3Rpb25zIExpc3Qgb2YgZnVuY3Rpb25zIG9mIHRoZSBNb29kbGUgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIFRydWUgaWYgdGhlIG1vb2RsZSB2ZXJzaW9uIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNWYWxpZE1vb2RsZVZlcnNpb24oaW5mb3MpIHtcbiAgICAgICAgaWYgKCFpbmZvcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblZlcnNpb24gPSAyMDEyMTIwMzAwLCAvLyBNb29kbGUgMi40IHZlcnNpb24uXG4gICAgICAgICAgICBtaW5SZWxlYXNlID0gXCIyLjRcIjtcblxuICAgICAgICAvLyBUcnkgdG8gdmFsaWRhdGUgYnkgdmVyc2lvbi5cbiAgICAgICAgaWYgKGluZm9zLnZlcnNpb24pIHtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gcGFyc2VJbnQoaW5mb3MudmVyc2lvbik7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb24gPj0gbWluVmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGNvdWxkbid0IHZhbGlkYXRlIGJ5IHZlcnNpb24gbnVtYmVyLiBMZXQncyB0cnkgdG8gdmFsaWRhdGUgYnkgcmVsZWFzZSBudW1iZXIuXG4gICAgICAgIGlmIChpbmZvcy5yZWxlYXNlKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGluZm9zLnJlbGVhc2UubWF0Y2goL14oW1xcZHxcXC5dKikvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzFdID49IG1pblJlbGVhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3VsZG4ndCB2YWxpZGF0ZSBieSByZWxlYXNlIGVpdGhlci4gQ2hlY2sgaWYgaXQgdXNlcyBsb2NhbF9tb2JpbGUgcGx1Z2luLlxuICAgICAgICB2YXIgYXBwVXNlc0xvY2FsTW9iaWxlID0gZmFsc2U7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChpbmZvcy5mdW5jdGlvbnMsIGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgIGlmIChmdW5jLm5hbWUuaW5kZXhPZihtbUNvcmVXU1ByZWZpeCkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhcHBVc2VzTG9jYWxNb2JpbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXBwVXNlc0xvY2FsTW9iaWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHNpdGUgaW5mbyBpcyB2YWxpZC4gSWYgaXQncyBub3QsIHJldHVybiBlcnJvciBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGluZm9zICAgIFNpdGUgaW5mby5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R8Qm9vbGVhbn0gT2JqZWN0IHdpdGggZXJyb3IgbWVzc2FnZSB0byBzaG93IGFuZCBpdHMgcGFyYW1zIGlmIGluZm8gaXMgbm90IHZhbGlkLCB0cnVlIGlmIGluZm8gaXMgdmFsaWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTaXRlSW5mbyhpbmZvcykge1xuICAgICAgICBpZiAoIWluZm9zLmZpcnN0bmFtZSB8fCAhaW5mb3MubGFzdG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBtb29kbGVMaW5rID0gJzxhIG1tLWJyb3dzZXIgaHJlZj1cIicgKyBpbmZvcy5zaXRldXJsICsgJ1wiPicgKyBpbmZvcy5zaXRldXJsICsgJzwvYT4nO1xuICAgICAgICAgICAgcmV0dXJuIHtlcnJvcjogJ21tLmNvcmUucmVxdWlyZWR1c2VyZGF0YW1pc3NpbmcnLCBwYXJhbXM6IHsnJGEnOiBtb29kbGVMaW5rfX07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgYSBzaXRlIGluIGxvY2FsIERCLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciNhZGRTaXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZXVybCBTaXRlIFVSTC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gICBVc2VyJ3MgdG9rZW4gaW4gdGhlIHNpdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGluZm9zICAgU2l0ZSdzIGluZm8uXG4gICAgICovXG4gICAgc2VsZi5hZGRTaXRlID0gZnVuY3Rpb24oaWQsIHNpdGV1cmwsIHRva2VuLCBpbmZvcykge1xuICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkuaW5zZXJ0KG1tQ29yZVNpdGVzU3RvcmUsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHNpdGV1cmw6IHNpdGV1cmwsXG4gICAgICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgICAgICBpbmZvczogaW5mb3NcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvZ2luIGEgdXNlciB0byBhIHNpdGUgZnJvbSB0aGUgbGlzdCBvZiBzaXRlcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjbG9hZFNpdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZWlkIElEIG9mIHRoZSBzaXRlIHRvIGxvYWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHNpdGUgaXMgbG9hZGVkLlxuICAgICAqL1xuICAgIHNlbGYubG9hZFNpdGUgPSBmdW5jdGlvbihzaXRlaWQpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnTG9hZCBzaXRlICcrc2l0ZWlkKTtcblxuICAgICAgICByZXR1cm4gc2VsZi5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICBjdXJyZW50U2l0ZSA9IHNpdGU7XG4gICAgICAgICAgICBzZWxmLmxvZ2luKHNpdGVpZCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGxvY2FsX21vYmlsZSB3YXMgaW5zdGFsbGVkIHRvIE1vb2RsZS5cbiAgICAgICAgICAgIHJldHVybiBzaXRlLmNoZWNrSWZMb2NhbE1vYmlsZUluc3RhbGxlZEFuZE5vdFVzZWQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIExvY2FsIG1vYmlsZSB3YXMgYWRkZWQuIFRocm93IGludmFsaWQgc2Vzc2lvbiB0byBmb3JjZSByZWNvbm5lY3QgYW5kIGNyZWF0ZSBhIG5ldyB0b2tlbi5cbiAgICAgICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbUNvcmVFdmVudFNlc3Npb25FeHBpcmVkLCBzaXRlaWQpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHNpdGUgaW5mby4gV2UgZG9uJ3QgYmxvY2sgdGhlIFVJLlxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlU2l0ZUluZm8oc2l0ZWlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mb3MgPSBzaXRlLmdldEluZm8oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb24gPSB2YWxpZGF0ZVNpdGVJbmZvKGluZm9zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb24gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpdGUgaW5mbyBpcyBub3QgdmFsaWQuIExvZ291dCB0aGUgdXNlciBhbmQgc2hvdyBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnbW1fbG9naW4uc2l0ZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0cmFuc2xhdGUodmFsaWRhdGlvbi5lcnJvciwgdmFsaWRhdGlvbi5wYXJhbXMpLnRoZW4oZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2dldEN1cnJlbnRTaXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IHNpdGUuXG4gICAgICovXG4gICAgc2VsZi5nZXRDdXJyZW50U2l0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3VycmVudFNpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHNpdGUgZnJvbSB0aGUgc2l0ZXMgbGlzdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjZGVsZXRlU2l0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlaWQgSUQgb2YgdGhlIHNpdGUgdG8gZGVsZXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIGlzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgc2VsZi5kZWxldGVTaXRlID0gZnVuY3Rpb24oc2l0ZWlkKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ0RlbGV0ZSBzaXRlICcrc2l0ZWlkKTtcblxuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRTaXRlICE9ICd1bmRlZmluZWQnICYmIGN1cnJlbnRTaXRlLmlkID09IHNpdGVpZCkge1xuICAgICAgICAgICAgc2VsZi5sb2dvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLmdldFNpdGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLmRlbGV0ZURCKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2l0ZXNbc2l0ZWlkXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkucmVtb3ZlKG1tQ29yZVNpdGVzU3RvcmUsIHNpdGVpZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpdGUuZGVsZXRlRm9sZGVyKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERCIHJlbW92ZSBzaG91bGRuJ3QgZmFpbCwgYnV0IHdlJ2xsIGdvIGFoZWFkIGV2ZW4gaWYgaXQgZG9lcy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpdGUuZGVsZXRlRm9sZGVyKCk7XG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRTaXRlRGVsZXRlZCwgc2l0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGFyZSBubyBzaXRlcyBzdG9yZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2hhc05vU2l0ZXNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIGlmIHRoZXJlIGFyZSBubyBzaXRlcywgYW5kIHJlamVjdGVkIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZS5cbiAgICAgKi9cbiAgICBzZWxmLmhhc05vU2l0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmNvdW50KG1tQ29yZVNpdGVzU3RvcmUpLnRoZW4oZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGVyZSBhcmUgc2l0ZXMgc3RvcmVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciNoYXNTaXRlc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHNpdGUsIGFuZCByZWplY3RlZCBpZiB0aGVyZSBhcmVuJ3QuXG4gICAgICovXG4gICAgc2VsZi5oYXNTaXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkuY291bnQobW1Db3JlU2l0ZXNTdG9yZSkudGhlbihmdW5jdGlvbihjb3VudCkge1xuICAgICAgICAgICAgaWYgKGNvdW50ID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2l0ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2dldFNpdGVcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNpdGVJZCBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2l0ZSA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBpZiAoIXNpdGVJZCkge1xuICAgICAgICAgICAgLy8gU2l0ZSBJRCBub3QgdmFsaWQsIHJlamVjdC5cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U2l0ZSAmJiBjdXJyZW50U2l0ZS5nZXRJZCgpID09PSBzaXRlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKGN1cnJlbnRTaXRlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2l0ZXNbc2l0ZUlkXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oc2l0ZXNbc2l0ZUlkXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkuZ2V0KG1tQ29yZVNpdGVzU3RvcmUsIHNpdGVJZCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpdGUgPSAkbW1TaXRlc0ZhY3RvcnkubWFrZVNpdGUoc2l0ZUlkLCBkYXRhLnNpdGV1cmwsIGRhdGEudG9rZW4sIGRhdGEuaW5mb3MpO1xuICAgICAgICAgICAgICAgIHNpdGVzW3NpdGVJZF0gPSBzaXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXRlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0YWJhc2Ugb2JqZWN0IG9mIGEgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjZ2V0U2l0ZURiXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmdldFNpdGVEYiA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5nZXREYigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIHNpdGVzIHN0b3JlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjZ2V0U2l0ZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBbaWRzXSBJRHMgb2YgdGhlIHNpdGVzIHRvIGdldC4gSWYgbm90IGRlZmluZWQsIHJldHVybiBhbGwgc2l0ZXMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlcyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2l0ZXMgPSBmdW5jdGlvbihpZHMpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmdldEFsbChtbUNvcmVTaXRlc1N0b3JlKS50aGVuKGZ1bmN0aW9uKHNpdGVzKSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkU2l0ZXMgPSBbXTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzaXRlcywgZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaWRzIHx8IGlkcy5pbmRleE9mKHNpdGUuaWQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkU2l0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogc2l0ZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpdGV1cmw6IHNpdGUuc2l0ZXVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxuYW1lOiBzaXRlLmluZm9zLmZ1bGxuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZW5hbWU6IHNpdGUuaW5mb3Muc2l0ZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdmF0YXI6IHNpdGUuaW5mb3MudXNlcnBpY3R1cmV1cmxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVkU2l0ZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgSURzIG9mIHNpdGVzIHN0b3JlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjZ2V0U2l0ZXNJZHNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHNpdGVzIElEcyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2l0ZXNJZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmdldEFsbChtbUNvcmVTaXRlc1N0b3JlKS50aGVuKGZ1bmN0aW9uKHNpdGVzKSB7XG4gICAgICAgICAgICB2YXIgaWRzID0gW107XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2l0ZXMsIGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICAgICBpZHMucHVzaChzaXRlLmlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvZ2luIHRoZSB1c2VyIGluIGEgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjbG9naW5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVpZCBJRCBvZiB0aGUgc2l0ZSB0aGUgdXNlciBpcyBhY2Nlc3NpbmcuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGN1cnJlbnQgc2l0ZSBpcyBzdG9yZWQuXG4gICAgICovXG4gICAgc2VsZi5sb2dpbiA9IGZ1bmN0aW9uKHNpdGVpZCkge1xuICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkuaW5zZXJ0KG1tQ29yZUN1cnJlbnRTaXRlU3RvcmUsIHtcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgc2l0ZWlkOiBzaXRlaWRcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50TG9naW4pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9nb3V0IHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciNsb2dvdXRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHVzZXIgaXMgbG9nZ2VkIG91dC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ291dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjdXJyZW50U2l0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRMb2dvdXQpO1xuICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkucmVtb3ZlKG1tQ29yZUN1cnJlbnRTaXRlU3RvcmUsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIHRoZSBzZXNzaW9uIHRvIHRoZSBwcmV2aW91cyBvbmUgc28gdGhlIHVzZXIgZG9lc24ndCBoYXMgdG8gbG9naW4gZXZlcnl0aW1lIHRoZSBhcHAgaXMgc3RhcnRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjcmVzdG9yZVNlc3Npb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIGlmIGEgc2Vzc2lvbiBpcyByZXN0b3JlZC5cbiAgICAgKi9cbiAgICBzZWxmLnJlc3RvcmVTZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZXNzaW9uUmVzdG9yZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uUmVzdG9yZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5nZXQobW1Db3JlQ3VycmVudFNpdGVTdG9yZSwgMSkudGhlbihmdW5jdGlvbihjdXJyZW50X3NpdGUpIHtcbiAgICAgICAgICAgIHZhciBzaXRlaWQgPSBjdXJyZW50X3NpdGUuc2l0ZWlkO1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnUmVzdG9yZSBzZXNzaW9uIGluIHNpdGUgJytzaXRlaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYubG9hZFNpdGUoc2l0ZWlkKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7IC8vIFJlamVjdCB3aXRob3V0IHBhcmFtcy5cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBzaXRlJ3MgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI3VwZGF0ZVNpdGVUb2tlblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRldXJsICBTaXRlJ3MgVVJMLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZSBVc2VybmFtZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gICAgVXNlcidzIG5ldyB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgQSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHNpdGUgaXMgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLnVwZGF0ZVNpdGVUb2tlbiA9IGZ1bmN0aW9uKHNpdGV1cmwsIHVzZXJuYW1lLCB0b2tlbikge1xuICAgICAgICB2YXIgc2l0ZWlkID0gc2VsZi5jcmVhdGVTaXRlSUQoc2l0ZXVybCwgdXNlcm5hbWUpO1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICBzaXRlLnRva2VuID0gdG9rZW47XG5cbiAgICAgICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5pbnNlcnQobW1Db3JlU2l0ZXNTdG9yZSwge1xuICAgICAgICAgICAgICAgIGlkOiBzaXRlaWQsXG4gICAgICAgICAgICAgICAgc2l0ZXVybDogc2l0ZS5nZXRVUkwoKSxcbiAgICAgICAgICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgaW5mb3M6IHNpdGUuZ2V0SW5mbygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBzaXRlJ3MgaW5mby5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjdXBkYXRlU2l0ZUluZm9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZWlkIFNpdGUncyBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIEEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIGlzIHVwZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi51cGRhdGVTaXRlSW5mbyA9IGZ1bmN0aW9uKHNpdGVpZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5mZXRjaFNpdGVJbmZvKCkudGhlbihmdW5jdGlvbihpbmZvcykge1xuICAgICAgICAgICAgICAgIHNpdGUuc2V0SW5mbyhpbmZvcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmluc2VydChtbUNvcmVTaXRlc1N0b3JlLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBzaXRlaWQsXG4gICAgICAgICAgICAgICAgICAgIHNpdGV1cmw6IHNpdGUuZ2V0VVJMKCksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBzaXRlLmdldFRva2VuKCksXG4gICAgICAgICAgICAgICAgICAgIGluZm9zOiBpbmZvc1xuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsIHNpdGVpZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBzaXRlJ3MgaW5mby5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjdXBkYXRlU2l0ZUluZm9CeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRldXJsICBTaXRlJ3MgVVJMLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZSBVc2VybmFtZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgQSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHNpdGUgaXMgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLnVwZGF0ZVNpdGVJbmZvQnlVcmwgPSBmdW5jdGlvbihzaXRldXJsLCB1c2VybmFtZSkge1xuICAgICAgICB2YXIgc2l0ZWlkID0gc2VsZi5jcmVhdGVTaXRlSUQoc2l0ZXVybCwgdXNlcm5hbWUpO1xuICAgICAgICByZXR1cm4gc2VsZi51cGRhdGVTaXRlSW5mbyhzaXRlaWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNpdGUgSURzIGEgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICogU29tZW9uZSBjYW4gaGF2ZSBtb3JlIHRoYW4gb25lIGFjY291bnQgaW4gdGhlIHNhbWUgc2l0ZSwgdGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYXJyYXkgb2YgSURzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciNnZXRTaXRlc1VybHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICAgVVJMIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJpb3JpdGl6ZSBUcnVlIGlmIGl0IHNob3VsZCBwcmlvcml0aXplIGN1cnJlbnQgc2l0ZS4gSWYgdGhlIFVSTCBiZWxvbmdzIHRvIGN1cnJlbnQgc2l0ZSB0aGVuIGl0IHdvbid0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrIGFueSBvdGhlciBzaXRlLCBpdCB3aWxsIG9ubHkgcmV0dXJuIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBzaXRlIElEcyAoYXJyYXkpLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2l0ZUlkc0Zyb21VcmwgPSBmdW5jdGlvbih1cmwsIHByaW9yaXRpemUpIHtcbiAgICAgICAgLy8gQ2hlY2sgY3VycmVudCBzaXRlIGZpcnN0LCBpdCBoYXMgcHJpb3JpdHkgb3ZlciB0aGUgcmVzdCBvZiBzaXRlcy5cbiAgICAgICAgaWYgKHByaW9yaXRpemUgJiYgY3VycmVudFNpdGUgJiYgY3VycmVudFNpdGUuY29udGFpbnNVcmwodXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW2N1cnJlbnRTaXRlLmdldElkKCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIFVSTCBoYXMgaHR0cChzKSBwcm90b2NvbC5cbiAgICAgICAgaWYgKCF1cmwubWF0Y2goL15odHRwcz86XFwvXFwvL2kpKSB7XG4gICAgICAgICAgICAvLyBVUkwgZG9lc24ndCBoYXZlIGh0dHAocykgcHJvdG9jb2wuIENoZWNrIGlmIGl0IGhhcyBhbnkgcHJvdG9jb2wuXG4gICAgICAgICAgICBpZiAodXJsLm1hdGNoKC9eW146XXsyLDEwfTpcXC9cXC8vaSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgc29tZSBwcm90b2NvbC4gUmV0dXJuIGVtcHR5IGFycmF5LlxuICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gcHJvdG9jb2wsIHByb2JhYmx5IGEgcmVsYXRpdmUgVVJMLiBSZXR1cm4gY3VycmVudCBzaXRlLlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2l0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbihbY3VycmVudFNpdGUuZ2V0SWQoKV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkuZ2V0QWxsKG1tQ29yZVNpdGVzU3RvcmUpLnRoZW4oZnVuY3Rpb24oc2l0ZXMpIHtcbiAgICAgICAgICAgIHZhciBpZHMgPSBbXTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzaXRlcywgZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghc2l0ZXNbc2l0ZS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2l0ZXNbc2l0ZS5pZF0gPSAkbW1TaXRlc0ZhY3RvcnkubWFrZVNpdGUoc2l0ZS5pZCwgc2l0ZS5zaXRldXJsLCBzaXRlLnRva2VuLCBzaXRlLmluZm9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpdGVzW3NpdGUuaWRdLmNvbnRhaW5zVXJsKHVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goc2l0ZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFNob3VsZG4ndCBoYXBwZW4uXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1UZXh0XG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzZXJ2aWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyByZWxhdGVkIHRvIHRleHQsIGxpa2UgZm9ybWF0dGluZyB0ZXh0cyBmcm9tIE1vb2RsZS5cbiAqL1xuLmZhY3RvcnkoJyRtbVRleHQnLCBmdW5jdGlvbigkcSwgJG1tTGFuZywgJHRyYW5zbGF0ZSkge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgc2l6ZSBpbiBieXRlcyBpbnRvIGh1bWFuIHJlYWRhYmxlIGZvcm1hdFxuICAgICAqIGh0dHA6Ly9jb2RlYWlkLm5ldC9qYXZhc2NyaXB0L2NvbnZlcnQtc2l6ZS1pbi1ieXRlcy10by1odW1hbi1yZWFkYWJsZS1mb3JtYXQtKGphdmFzY3JpcHQpXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVGV4dCNieXRlc1RvU2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBieXRlcyAgICAgICAgIE51bWJlciBvZiBieXRlcyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJlY2lzaW9uPTJdIE51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgc2VwYXJhdG9yLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgIFNpemUgaW4gaHVtYW4gcmVhZGFibGUgZm9ybWF0LlxuICAgICAqL1xuICAgIHNlbGYuYnl0ZXNUb1NpemUgPSBmdW5jdGlvbihieXRlcywgcHJlY2lzaW9uKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PSAndW5kZWZpbmVkJyB8fCBieXRlcyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUubm90YXBwbGljYWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVjaXNpb24gPT0gJ3VuZGVmaW5lZCcgfHwgcHJlY2lzaW9uIDwgMCkge1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlzID0gWydtbS5jb3JlLnNpemViJywgJ21tLmNvcmUuc2l6ZWtiJywgJ21tLmNvcmUuc2l6ZW1iJywgJ21tLmNvcmUuc2l6ZWdiJywgJ21tLmNvcmUuc2l6ZXRiJ107XG4gICAgICAgIHZhciB1bml0cyA9ICR0cmFuc2xhdGUuaW5zdGFudChrZXlzKTtcbiAgICAgICAgdmFyIHBvc3R0eHQgPSAwO1xuICAgICAgICBpZiAoYnl0ZXMgPj0gMTAyNCkge1xuICAgICAgICAgICAgd2hpbGUgKGJ5dGVzID49IDEwMjQpIHtcbiAgICAgICAgICAgICAgICBwb3N0dHh0Kys7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcyAvIDEwMjQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieXRlcyA9IE51bWJlcihNYXRoLnJvdW5kKGJ5dGVzKydlKycrcHJlY2lzaW9uKSArICdlLScrcHJlY2lzaW9uKTsgLy8gUm91bmQgdG8gXCJwcmVjaXNpb25cIiBkZWNpbWFscyBpZiBuZWVkZWQuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS5odW1hbnJlYWRhYmxlc2l6ZScsIHtzaXplOiBOdW1iZXIoYnl0ZXMpLCB1bml0OiB1bml0c1trZXlzW3Bvc3R0eHRdXX0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjbGVhbiBIVE1MIHRhZ3MuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVGV4dCNjbGVhblRhZ3NcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB0ZXh0ICAgICAgICAgVGhlIHRleHQgdG8gYmUgY2xlYW5lZC5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbc2luZ2xlTGluZV0gVHJ1ZSBpZiBuZXcgbGluZXMgc2hvdWxkIGJlIHJlbW92ZWQgKGFsbCB0aGUgdGV4dCBpbiBhIHNpbmdsZSBsaW5lKS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgVGV4dCBjbGVhbmVkLlxuICAgICAqL1xuICAgIHNlbGYuY2xlYW5UYWdzID0gZnVuY3Rpb24odGV4dCwgc2luZ2xlTGluZSkge1xuICAgICAgICAvLyBGaXJzdCwgd2UgdXNlIGEgcmVnZXhwci5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvKDwoW14+XSspPikvaWcsXCJcIik7XG4gICAgICAgIC8vIFRoZW4sIHdlIHJlbHkgb24gdGhlIGJyb3dzZXIuIFdlIG5lZWQgdG8gd3JhcCB0aGUgdGV4dCB0byBiZSBzdXJlIGlzIEhUTUwuXG4gICAgICAgIHRleHQgPSBhbmd1bGFyLmVsZW1lbnQoJzxwPicpLmh0bWwodGV4dCkudGV4dCgpOyAvLyBHZXQgZGlyZWN0aXZlJ3MgY29udGVudC5cbiAgICAgICAgLy8gUmVjb3ZlciBvciByZW1vdmUgbmV3IGxpbmVzLlxuICAgICAgICB0ZXh0ID0gc2VsZi5yZXBsYWNlTmV3TGluZXModGV4dCwgc2luZ2xlTGluZSA/ICcgJyA6ICc8YnIgLz4nKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgYWxsIHRoZSBuZXcgbGluZXMgb24gYSBjZXJ0YWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVGV4dCNyZXBsYWNlTmV3TGluZXNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB0ZXh0ICAgICBUaGUgdGV4dCB0byBiZSB0cmVhdGVkLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG5ld1ZhbHVlIFRleHQgdG8gcGxhY2Ugb24gZWFjaCBuZXcgbGluZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUcmVhdGVkIHRleHQuXG4gICAgICovXG4gICAgc2VsZi5yZXBsYWNlTmV3TGluZXMgPSBmdW5jdGlvbih0ZXh0LCBuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8oPzpcXHJcXG58XFxyfFxcbikvZywgbmV3VmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgdGV4dCwgdHJlYXRpbmcgbXVsdGlsYW5nIHRhZ3MgYW5kIGNsZWFuaW5nIEhUTUwgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVRleHQjZm9ybWF0VGV4dFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dCAgICAgICAgICAgICBUZXh0IHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhbiAgICAgICAgICAgVHJ1ZSBpZiBIVE1MIHRhZ3Mgc2hvdWxkIGJlIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbc2luZ2xlTGluZV0gICAgVHJ1ZSBpZiBuZXcgbGluZXMgc2hvdWxkIGJlIHJlbW92ZWQuIE9ubHkgdmFsaWQgaWYgY2xlYW4gaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbc2hvcnRlbkxlbmd0aF0gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gc2hvcnRlbiB0aGUgdGV4dC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBmb3JtYXR0ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBzZWxmLmZvcm1hdFRleHQgPSBmdW5jdGlvbih0ZXh0LCBjbGVhbiwgc2luZ2xlTGluZSwgc2hvcnRlbkxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc2VsZi50cmVhdE11bHRpbGFuZ1RhZ3ModGV4dCkudGhlbihmdW5jdGlvbihmb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIGlmIChjbGVhbikge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZCA9IHNlbGYuY2xlYW5UYWdzKGZvcm1hdHRlZCwgc2luZ2xlTGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvcnRlbkxlbmd0aCAmJiBwYXJzZUludChzaG9ydGVuTGVuZ3RoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQgPSBzZWxmLnNob3J0ZW5UZXh0KGZvcm1hdHRlZCwgcGFyc2VJbnQoc2hvcnRlbkxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3J0ZW5zIGEgdGV4dCB0byBsZW5ndGggYW5kIGFkZHMgYW4gZWxsaXBzaXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVGV4dCNzaG9ydGVuVGV4dFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBiZSBzaG9ydGVuZWQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsZW5ndGggVGhlIGRlc2lyZWQgbGVuZ3RoLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU2hvcnRlbmVkIHRleHQuXG4gICAgICovXG4gICAgc2VsZi5zaG9ydGVuVGV4dCA9IGZ1bmN0aW9uKHRleHQsIGxlbmd0aCkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cigwLCBsZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyBOb3csIHRydW5jYXRlIGF0IHRoZSBsYXN0IHdvcmQgYm91bmRhcnkgKGlmIGV4aXN0cykuXG4gICAgICAgICAgICB2YXIgbGFzdFdvcmRQb3MgPSB0ZXh0Lmxhc3RJbmRleE9mKCcgJyk7XG4gICAgICAgICAgICBpZiAobGFzdFdvcmRQb3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKDAsIGxhc3RXb3JkUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgKz0gJyZoZWxsaXA7JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJlYXQgdGhlIG11bHRpbGFuZyB0YWdzIGZyb20gYSBIVE1MIGNvZGUsIGxlYXZpbmcgb25seSB0aGUgY3VycmVudCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1UZXh0I3RyZWF0TXVsdGlsYW5nVGFnc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0ICAgVGhlIHRleHQgdG8gYmUgZm9ybWF0dGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgSUQgb2YgdGhlIHNpdGUgdG8gdXNlLiBJZiBub3Qgc2V0LCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBmb3JtYXR0ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBzZWxmLnRyZWF0TXVsdGlsYW5nVGFncyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbignJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tTGFuZy5nZXRDdXJyZW50TGFuZ3VhZ2UoKS50aGVuKGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICAvLyBNYXRjaCB0aGUgY3VycmVudCBsYW5ndWFnZVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRMYW5nUmUgPSBuZXcgUmVnRXhwKCc8KD86bGFuZ3xzcGFuKVtePl0rbGFuZz1cIicgKyBsYW5ndWFnZSArICdcIltePl0qPiguKj8pPFxcLyg/Omxhbmd8c3Bhbik+JywgJ2cnKSxcbiAgICAgICAgICAgICAgICBhbnlMYW5nUkUgPSAvPCg/Omxhbmd8c3BhbilbXj5dK2xhbmc9XCJbYS16QS1aMC05Xy1dK1wiW14+XSo+KC4qPyk8XFwvKD86bGFuZ3xzcGFuKT4vZztcblxuICAgICAgICAgICAgaWYgKCF0ZXh0Lm1hdGNoKGN1cnJlbnRMYW5nUmUpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3VycmVudCBsYW5nIG5vdCBmb3VuZC4gVHJ5IHRvIGZpbmQgdGhlIGZpcnN0IGxhbmd1YWdlLlxuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdGV4dC5tYXRjaChhbnlMYW5nUkUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2UgPSBtYXRjaGVzWzBdLm1hdGNoKC9sYW5nPVwiKFthLXpBLVowLTlfLV0rKVwiLylbMV07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYW5nUmUgPSBuZXcgUmVnRXhwKCc8KD86bGFuZ3xzcGFuKVtePl0rbGFuZz1cIicgKyBsYW5ndWFnZSArICdcIltePl0qPiguKj8pPFxcLyg/Omxhbmd8c3Bhbik+JywgJ2cnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBtdWx0aS1sYW5nIHRhZyBmb3VuZCwgc3RvcC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXh0cmFjdCBjb250ZW50cyBvZiBjdXJyZW50IGxhbmd1YWdlLlxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShjdXJyZW50TGFuZ1JlLCAnJDEnKTtcbiAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgcmVzdCBvZiBsYW5ndWFnZXNcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoYW55TGFuZ1JFLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVzY2FwZSBhbiBIVE1MIHRleHQuIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gUEhQJ3MgaHRtbHNwZWNpYWxjaGFycy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1UZXh0I2VzY2FwZUhUTUxcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgVGV4dCB0byBlc2NhcGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgIEVzY2FwZWQgdGV4dC5cbiAgICAgKi9cbiAgICBzZWxmLmVzY2FwZUhUTUwgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PSAndW5kZWZpbmVkJyB8fCB0ZXh0ID09PSBudWxsIHx8ICh0eXBlb2YgdGV4dCA9PSAnbnVtYmVyJyAmJiBpc05hTih0ZXh0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGV4dCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIiYjMDM5O1wiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIG9yIHJlbW92ZSAnd3d3JyBmcm9tIGEgVVJMLiBUaGUgdXJsIG5lZWRzIHRvIGhhdmUgaHR0cCBvciBodHRwcyBwcm90b2NvbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1UZXh0I2FkZE9yUmVtb3ZlV1dXXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgTW9kaWZpZWQgVVJMLlxuICAgICAqL1xuICAgIHNlbGYuYWRkT3JSZW1vdmVXV1cgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh1cmwubWF0Y2goL2h0dHAocyk/OlxcL1xcL3d3d1xcLi8pKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBoYXMgd3d3LiBSZW1vdmUgaXQuXG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3d3dy4nLCAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCdodHRwczovLycsICdodHRwczovL3d3dy4nKTtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgnaHR0cDovLycsICdodHRwOi8vd3d3LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBwcm90b2NvbCBhbmQgd3d3IGZyb20gYSBVUkwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVGV4dCNyZW1vdmVQcm90b2NvbEFuZFdXV1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdXJsIFVSTCB0byB0cmVhdC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBUcmVhdGVkIFVSTC5cbiAgICAgKi9cbiAgICBzZWxmLnJlbW92ZVByb3RvY29sQW5kV1dXID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIC8vIFJlbW92ZSBwcm90b2NvbC5cbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoLy4qPzpcXC9cXC8vZywgJycpO1xuICAgICAgICAvLyBSZW1vdmUgd3d3LlxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXnd3dy4vLCAnJyk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4uY29uc3RhbnQoJ21tQ29yZVZlcnNpb25BcHBsaWVkJywgJ3ZlcnNpb25fYXBwbGllZCcpXG5cbi8qKlxuICogRmFjdG9yeSB0byBoYW5kbGUgYXBwIHVwZGF0ZXMuIFRoaXMgZmFjdG9yeSBzaG91bGRuJ3QgYmUgdXNlZCBvdXRzaWRlIG9mIGNvcmUuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tVXBkYXRlTWFuYWdlclxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHNlcnZpY2UgaGFuZGxlcyBwcm9jZXNzZXMgdGhhdCBuZWVkIHRvIGJlIHJ1biB3aGVuIHVwZGF0aW5nIHRoZSBhcHAsIGxpa2UgbWlncmF0ZSBNTTEgc2l0ZXMgdG8gTU0yLlxuICovXG4uZmFjdG9yeSgnJG1tVXBkYXRlTWFuYWdlcicsIGZ1bmN0aW9uKCRsb2csICRxLCAkbW1Db25maWcsICRtbVNpdGVzTWFuYWdlciwgJG1tRlMsICRjb3Jkb3ZhTG9jYWxOb3RpZmljYXRpb24sICRtbUxvY2FsTm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgICRtbUFwcCwgJG1tRXZlbnRzLCBtbUNvcmVTaXRlc1N0b3JlLCBtbUNvcmVWZXJzaW9uQXBwbGllZCwgbW1Db3JlRXZlbnRTaXRlQWRkZWQsIG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsXG4gICAgICAgICAgICBtbUNvcmVFdmVudFNpdGVEZWxldGVkLCAkaW5qZWN0b3IsICRtbUZpbGVwb29sLCBtbUNvcmVDb3Vyc2VNb2R1bGVzU3RvcmUsIG1tRmlsZXBvb2xMaW5rc1N0b3JlLFxuICAgICAgICAgICAgbW1GaWxlcG9vbFBhY2thZ2VzU3RvcmUsIG1tQ29yZUNvbmZpZ0NvbnN0YW50cykge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbVVwZGF0ZU1hbmFnZXInKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIHNpdGVzRmlsZVBhdGggPSAnbWlncmF0aW9uL3NpdGVzLmpzb24nO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGFwcCBoYXMgYmVlbiB1cGRhdGVkIGFuZCBwZXJmb3JtcyB0aGUgbmVlZGVkIHByb2Nlc3Nlcy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZG4ndCBiZSB1c2VkIG91dHNpZGUgb2YgY29yZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1VcGRhdGVNYW5hZ2VyI2NoZWNrXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSB1cGRhdGUgcHJvY2VzcyBmaW5pc2hlcy5cbiAgICAgKi9cbiAgICBzZWxmLmNoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgdmVyc2lvbkNvZGUgPSBtbUNvcmVDb25maWdDb25zdGFudHMudmVyc2lvbmNvZGU7XG5cbiAgICAgICAgcmV0dXJuICRtbUNvbmZpZy5nZXQobW1Db3JlVmVyc2lvbkFwcGxpZWQsIDApLnRoZW4oZnVuY3Rpb24odmVyc2lvbkFwcGxpZWQpIHtcblxuICAgICAgICAgICAgaWYgKHZlcnNpb25Db2RlID49IDM5MSAmJiB2ZXJzaW9uQXBwbGllZCA8IDM5MSkge1xuICAgICAgICAgICAgICAgIC8vIE1pZ3JhdGluZyBmcm9tIE1NMSB0byBNTTIuXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtaWdyYXRlTU0xU2l0ZXMoKSk7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycyBpbiBjbGVhckFwcEZvbGRlci4gV2UgZG9uJ3Qgd2FudCB0byBjbGVhciB0aGUgZm9sZGVyXG4gICAgICAgICAgICAgICAgLy8gZXZlcnl0aW1lIHRoZSBhcHAgaXMgb3BlbmVkIGlmIHNvbWV0aGluZyBnb2VzIHdyb25nLlxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goY2xlYXJBcHBGb2xkZXIoKS5jYXRjaChmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uQ29kZSA+PSAyMDAzICYmIHZlcnNpb25BcHBsaWVkIDwgMjAwMykge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goY2FuY2VsQW5kcm9pZE5vdGlmaWNhdGlvbnMoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uQ29kZSA+PSAyMDAzKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RvcmVTaXRlc0luRmlsZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmVyc2lvbkNvZGUgPj0gMjAwNyAmJiB2ZXJzaW9uQXBwbGllZCA8IDIwMDcpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG1pZ3JhdGVNb2R1bGVzU3RhdHVzKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db25maWcuc2V0KG1tQ29yZVZlcnNpb25BcHBsaWVkLCB2ZXJzaW9uQ29kZSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciBhcHBseWluZyB1cGRhdGUgZnJvbSAnICsgdmVyc2lvbkFwcGxpZWQgKyAnIHRvICcgKyB2ZXJzaW9uQ29kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBhcHAgZm9sZGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBmb2xkZXIgaXMgY2xlYXJlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhckFwcEZvbGRlcigpIHtcbiAgICAgICAgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1GUy5nZXREaXJlY3RvcnlDb250ZW50cygnJykudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIEFuZHJvaWQsIGRvbid0IGRlbGV0ZSAnY2FjaGUnIGFuZCAnZmlsZXMnIGZvbGRlcnMsIGNyZWF0ZWQgYnkgdGhlIE9TLlxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FuRGVsZXRlQW5kcm9pZCA9IGlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpICYmIGVudHJ5Lm5hbWUgIT09ICdjYWNoZScgJiYgZW50cnkubmFtZSAhPT0gJ2ZpbGVzJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbkRlbGV0ZUlPUyA9IGlvbmljLlBsYXRmb3JtLmlzSU9TKCkgJiYgZW50cnkubmFtZSAhPT0gJ05vQ2xvdWQnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuRGVsZXRlSU9TIHx8IGNhbkRlbGV0ZUFuZHJvaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tRlMucmVtb3ZlRGlyKGVudHJ5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWlncmF0ZSBNb29kbGVNb2JpbGUgMSBzaXRlcyB0byBNb29kbGVNb2JpbGUgMi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgc2l0ZXMgYXJlIG1pZ3JhdGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pZ3JhdGVNTTFTaXRlcygpIHtcbiAgICAgICAgdmFyIHNpdGVzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NpdGVzJyksXG4gICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGlmIChzaXRlcykge1xuICAgICAgICAgICAgc2l0ZXMgPSBzaXRlcy5zcGxpdCgnLCcpO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2l0ZXMsIGZ1bmN0aW9uKHNpdGVpZCkge1xuICAgICAgICAgICAgICAgIGlmICghc2l0ZWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdNaWdyYXRpbmcgc2l0ZSBmcm9tIE1vb2RsZU1vYmlsZSAxOiAnICsgc2l0ZWlkKTtcbiAgICAgICAgICAgICAgICB2YXIgc2l0ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzaXRlcy0nK3NpdGVpZCksXG4gICAgICAgICAgICAgICAgICAgIGluZm9zO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpdGUgPSBKU09OLnBhcnNlKHNpdGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIHNpdGUuIFNob3VsZG4ndCBoYXBwZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9nLndhcm4oJ1NpdGUgJyArIHNpdGVpZCArICcgZGF0YSBpcyBpbnZhbGlkLiBJZ25vcmluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIE1NMSBzaXRlIGluZm8gaXMgbWl4ZWQgd2l0aCBzaXRlIGJhc2ljIGRhdGEgKGlkLCB0b2tlbiwgc2l0ZXVybCkuXG4gICAgICAgICAgICAgICAgICAgIGluZm9zID0gYW5ndWxhci5jb3B5KHNpdGUpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaW5mb3MuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZvcy50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1TaXRlc01hbmFnZXIuYWRkU2l0ZShzaXRlLmlkLCBzaXRlLnNpdGV1cmwsIHNpdGUudG9rZW4sIGluZm9zKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy53YXJuKCdTaXRlICcgKyBzaXRlaWQgKyAnIG5vdCBmb3VuZCBpbiBsb2NhbCBzdG9yYWdlLiBJZ25vcmluZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc2l0ZXMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGFsbCBBbmRyb2lkIG5vdGlmaWNhdGlvbnMuIE1NIDIuMCB3YXMgcmVsZWFzZWQgd2l0aCBhIGJ1ZyBpbiBub3RpZmljYXRpb25zIElEIChBbmRyb2lkKS4gVGhlc2UgSURzIHdlcmUgc3RvcmVkIGluXG4gICAgICogU2hhcmVkUHJlZmVyZW5jZXMsIGNhbmNlbCB0aGVtIGFsbCB3aWxsIGNsZWFyIHRoZSBzdG9yZWQgdmFsdWVzLiBAc2VlIE1PQklMRS0xMTQ4LlxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBub3RpZmljYXRpb25zIGFyZSBjYW5jZWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FuY2VsQW5kcm9pZE5vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgIGlmICgkbW1Mb2NhbE5vdGlmaWNhdGlvbnMuaXNBdmFpbGFibGUoKSAmJiBpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhTG9jYWxOb3RpZmljYXRpb24uY2FuY2VsQWxsKCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgY2FuY2VsbGluZyBBbmRyb2lkIG5vdGlmaWNhdGlvbnMuJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGV2ZW50cyB0byBzdG9yZSB0aGUgc2l0ZXMgaW4gYSBmaWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFN0b3JlU2l0ZXNJbkZpbGUoKSB7XG4gICAgICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFNpdGVBZGRlZCwgc3RvcmVTaXRlc0luRmlsZSk7XG4gICAgICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCBzdG9yZVNpdGVzSW5GaWxlKTtcbiAgICAgICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50U2l0ZURlbGV0ZWQsIHN0b3JlU2l0ZXNJbkZpbGUpO1xuICAgICAgICBzdG9yZVNpdGVzSW5GaWxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHNpdGVzIHN0b3JlZCBpbiBhIGZpbGUuIEl0J2xsIGJlIHVzZWQgdG8gbWlncmF0ZSB0byBDcm9zc3dhbGsgaWYgdXNlcnMgc2tpcHBlZCBTUUxpdGUgbWlncmF0aW9uIHZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdpdGggc2l0ZXMgYXJlIHJldHJpZXZlZC4gUmVzb2x2ZSBwYXJhbSBpcyB0aGUgc2l0ZXMgbGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaXRlc1N0b3JlZEluRmlsZSgpIHtcbiAgICAgICAgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1GUy5yZWFkRmlsZShzaXRlc0ZpbGVQYXRoKS50aGVuKGZ1bmN0aW9uKHNpdGVzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2l0ZXMgPSBKU09OLnBhcnNlKHNpdGVzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICBzaXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2l0ZXM7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciByZWFkaW5nLCBwcm9iYWJseSBmaWxlIGRvZXNuJ3QgZXhpc3QuIFJldHVybiBlbXB0eSBsaXN0LlxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcmUgc2l0ZXMgaW4gYSBmaWxlLiBJdCdsbCBiZSB1c2VkIHRvIG1pZ3JhdGUgdG8gQ3Jvc3N3YWxrIGlmIHVzZXJzIHNraXBwZWQgU1FMaXRlIG1pZ3JhdGlvbiB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIGZpbGUgaXMgd3JpdHRlbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yZVNpdGVzSW5GaWxlKCkge1xuICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmdldEFsbChtbUNvcmVTaXRlc1N0b3JlKS50aGVuKGZ1bmN0aW9uKHNpdGVzKSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNpdGVzLCBmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGUudG9rZW4gPSAncHJpdmF0ZSc7IC8vIFJlbW92ZSB0aGUgdG9rZW4sIHdlIGRvbid0IHdhbnQgaXQgd3JpdHRlbiBpbiBhIGZpbGUuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUZTLndyaXRlRmlsZShzaXRlc0ZpbGVQYXRoLCBKU09OLnN0cmluZ2lmeShzaXRlcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGZpbGUgd2l0aCBzaXRlcyBzdG9yZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gZmlsZSBpcyBkZWxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbGV0ZVNpdGVzRmlsZSgpIHtcbiAgICAgICAgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1GUy5yZW1vdmVGaWxlKHNpdGVzRmlsZVBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pZ3JhdGUgbW1Db3JlQ291cnNlTW9kdWxlc1N0b3JlIHRvIG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBtaWdyYXRpb24gaXMgZmluaXNoZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWlncmF0ZU1vZHVsZXNTdGF0dXMoKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCgkaW5qZWN0b3IuZ2V0KCdtbWFNb2RCb29rQ29tcG9uZW50JykpO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goJGluamVjdG9yLmdldCgnbW1hTW9kSW1zY3BDb21wb25lbnQnKSk7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCgkaW5qZWN0b3IuZ2V0KCdtbWFNb2RQYWdlQ29tcG9uZW50JykpO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goJGluamVjdG9yLmdldCgnbW1hTW9kUmVzb3VyY2VDb21wb25lbnQnKSk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlc0lkcygpLnRoZW4oZnVuY3Rpb24oc2l0ZXMpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNpdGVzLCBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG1pZ3JhdGVTaXRlTW9kdWxlc1N0YXR1cyhzaXRlSWQsIGNvbXBvbmVudHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pZ3JhdGVzIHRoZSBtb2R1bGVzIHN0YXR1cyBmcm9tIGEgY2VydGFpbiBzaXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGNvbXBvbmVudHMgQ29tcG9uZW50cyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgc2l0ZSBtaWdyYXRpb24gaXMgZmluaXNoZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWlncmF0ZVNpdGVNb2R1bGVzU3RhdHVzKHNpdGVJZCwgY29tcG9uZW50cykge1xuICAgICAgICAkbG9nLmRlYnVnKCdNaWdyYXRlIHNpdGUgbW9kdWxlcyBzdGF0dXMgZnJvbSBzaXRlICcgKyBzaXRlSWQpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZURiKHNpdGVJZCkudGhlbihmdW5jdGlvbihkYikge1xuICAgICAgICAgICAgcmV0dXJuIGRiLmdldEFsbChtbUNvcmVDb3Vyc2VNb2R1bGVzU3RvcmUpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VJbnQoZW50cnkuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRoZSBpZCBpcyBub3QgYSBudW1iZXIsIGlnbm9yZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZGV0ZXJtaW5lQ29tcG9uZW50KGRiLCBlbnRyeS5pZCwgY29tcG9uZW50cykudGhlbihmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBuZXcgZW50cnkgaW4gZmlsZXBvb2wgc3RvcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlICRtbUZpbGVwb29sI3N0b3JlUGFja2FnZVN0YXR1cyBiZWNhdXNlIHdlIHdhbnQgdG8ga2VlcCBwcmV2aW91c1N0YXR1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuY29tcG9uZW50SWQgPSBlbnRyeS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5pZCA9ICRtbUZpbGVwb29sLmdldFBhY2thZ2VJZChjb21wb25lbnQsIGVudHJ5LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRiLmluc2VydChtbUZpbGVwb29sUGFja2FnZXNTdG9yZSwgZW50cnkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2VzcyBjcmVhdGluZyBhbGwgdGhlIG5ldyBlbnRyaWVzLiBMZXQncyByZW1vdmUgdGhlIG9sZCBvbmVzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIucmVtb3ZlQWxsKG1tQ29yZUNvdXJzZU1vZHVsZXNTdG9yZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzLlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBjb21wb25lbnQgb2YgYSBtb2R1bGUgc3RhdHVzIGVudHJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBkYiAgICAgICAgICAgU2l0ZSBkYXRhYmFzZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbXBvbmVudElkICBDb21wb25lbnQgSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nW119IGNvbXBvbmVudHMgTGlzdCBvZiBjb21wb25lbnRzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgY29tcG9uZW50IG9yIHVuZGVmaW5lZCBpZiBubyBjb21wb25lbnQgZm91bmQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lQ29tcG9uZW50KGRiLCBjb21wb25lbnRJZCwgY29tcG9uZW50cykge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgIGNvbXBvbmVudDtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29tcG9uZW50cywgZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRiLnF1ZXJ5KG1tRmlsZXBvb2xMaW5rc1N0b3JlLCBbJ2NvbXBvbmVudEFuZElkJywgJz0nLCBbYywgY29tcG9uZW50SWRdXSkudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIHJlamVjdC5cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGhhbmRsZSBjdXN0b20gVVJMcyBzY2hlbWVzLiBOb3RpZmllcyBhbGwgdGhlIG9ic2VydmVycyB3aGVuIHRoZSBhcHAgaXMgaW52b2tlZCB3aXRoIGEgY3VzdG9tIFVSTC5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1VUkxEZWxlZ2F0ZVxuICovXG4uZmFjdG9yeSgnJG1tVVJMRGVsZWdhdGUnLCBmdW5jdGlvbigkbG9nKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tVVJMRGVsZWdhdGUnKTtcblxuICAgIHZhciBvYnNlcnZlcnMgPSB7fSxcbiAgICAgICAgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gb2JzZXJ2ZXIgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgYXBwIGlzIGxhdW5jaGVkIHZpYSBjdXN0b20gVVJMIHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1VUkxEZWxlZ2F0ZSNyZWdpc3RlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICAgIE9ic2VydmVyJ3MgbmFtZS4gTXVzdCBiZSB1bmlxdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gY2FsbCB3aXRoIHRoZSBVUkxzIHJlY2VpdmVkIGJ5IHRoZSBhcHAuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGNoZWNrIGlmIHRoZSBVUkxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0aGUgb25lIGV4cGVjdGVkIGJ5IHRoZSBvYnNlcnZlciBhbmQgcmV0dXJuIHRydWUgaWYgaXQgaXMsIHJldHVybiBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICRsb2cuZGVidWcoXCJSZWdpc3RlciBvYnNlcnZlciAnXCIrbmFtZStcIicgZm9yIGN1c3RvbSBVUkwuXCIpO1xuICAgICAgICBvYnNlcnZlcnNbbmFtZV0gPSBjYWxsYmFjaztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IGFsbCBvYnNlcnZlcnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVVJMRGVsZWdhdGUjbm90aWZ5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gbm90aWZ5IHRvIHRoZSBvYnNlcnZlcnMuXG4gICAgICovXG4gICAgc2VsZi5ub3RpZnkgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdmFyIHRyZWF0ZWQgPSBmYWxzZTsgLy8gT25jZSBhbiBvYnNlcnZlciBhY2NlcHRzIGEgVVJMIChyZXR1cm4gdHJ1ZSkgd2Ugc3RvcCBub3RpZnlpbmcuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChvYnNlcnZlcnMsIGZ1bmN0aW9uKGNhbGxiYWNrLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXRyZWF0ZWQgJiYgdHlwZW9mKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRyZWF0ZWQgPSBjYWxsYmFjayh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KVxuXG4ucnVuKGZ1bmN0aW9uKCRtbVVSTERlbGVnYXRlLCAkbG9nKSB7XG4gICAgd2luZG93LmhhbmRsZU9wZW5VUkwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnQXBwIGxhdW5jaGVkIGJ5IFVSTC4nKTtcbiAgICAgICAgJG1tVVJMRGVsZWdhdGUubm90aWZ5KHVybCk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBQcm92aWRlciB3aXRoIHNvbWUgJ3V0aWwnIGZ1bmN0aW9uYWxpdGllcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBwcm92aWRlclxuICogQG5hbWUgJG1tVXRpbFxuICovXG4ucHJvdmlkZXIoJyRtbVV0aWwnLCBmdW5jdGlvbihtbUNvcmVTZWNvbmRzWWVhciwgbW1Db3JlU2Vjb25kc0RheSwgbW1Db3JlU2Vjb25kc0hvdXIsIG1tQ29yZVNlY29uZHNNaW51dGUpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcywgLy8gVXNlICdzZWxmJyB0byBiZSBjb2hlcmVudCB3aXRoIHRoZSByZXN0IG9mIHNlcnZpY2VzLlxuICAgICAgICBwcm92aWRlciA9IHRoaXM7IC8vIFRvIGFjY2VzcyBwcm92aWRlciBtZXRob2RzIGZyb20gdGhlIHNlcnZpY2UuXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgYW4gb2JqZWN0IHRvIGJlIHVzZWQgaW4gYSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVV0aWxQcm92aWRlciNwYXJhbVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb2JqIE9iamVjdCB0byBzZXJpYWxpemUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgU2VyaWFsaXphdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIHNlbGYucGFyYW0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gJycsIG5hbWUsIHZhbHVlLCBmdWxsU3ViTmFtZSwgc3ViTmFtZSwgc3ViVmFsdWUsIGlubmVyT2JqLCBpO1xuXG4gICAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgICAgIHZhbHVlID0gb2JqW25hbWVdO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgICAgICBmdWxsU3ViTmFtZSA9IG5hbWUgKyAnWycgKyBpICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICBpbm5lck9iaiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpbm5lck9ialtmdWxsU3ViTmFtZV0gPSBzdWJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgKz0gc2VsZi5wYXJhbShpbm5lck9iaikgKyAnJic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHN1Yk5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtzdWJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbFN1Yk5hbWUgPSBuYW1lICsgJ1snICsgc3ViTmFtZSArICddJztcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmogPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmpbZnVsbFN1Yk5hbWVdID0gc3ViVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ICs9IHNlbGYucGFyYW0oaW5uZXJPYmopICsgJyYnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHF1ZXJ5ICs9IGVuY29kZVVSSUNvbXBvbmVudChuYW1lKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgKyAnJic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcXVlcnkubGVuZ3RoID8gcXVlcnkuc3Vic3RyKDAsIHF1ZXJ5Lmxlbmd0aCAtIDEpIDogcXVlcnk7XG4gICAgfTtcblxuICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uKCRpb25pY0xvYWRpbmcsICRpb25pY1BvcHVwLCAkaW5qZWN0b3IsICR0cmFuc2xhdGUsICRodHRwLCAkbG9nLCAkcSwgJG1tTGFuZywgJG1tRlMsICR0aW1lb3V0LCAkbW1BcHAsXG4gICAgICAgICAgICAgICAgJG1tVGV4dCwgbW1Db3JlV2lmaURvd25sb2FkVGhyZXNob2xkLCBtbUNvcmVEb3dubG9hZFRocmVzaG9sZCkge1xuXG4gICAgICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1VdGlsJyk7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTsgLy8gVXNlICdzZWxmJyB0byBiZSBjb2hlcmVudCB3aXRoIHRoZSByZXN0IG9mIHNlcnZpY2VzLlxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JtYXRzIGEgVVJMLCB0cmltLCBsb3dlcmNhc2UsIGV0Yy4uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2Zvcm1hdFVSTFxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybCBUaGUgdXJsIHRvIGJlIGZvcm1hdHRlZC5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgRnJvbWF0dGVkIHVybC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZm9ybWF0VVJMID0gZnVuY3Rpb24odXJsKSB7XG5cbiAgICAgICAgICAgIHVybCA9IHVybC50cmltKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBVUkwgc3RhcnRzIGJ5IGh0dHAgb3IgaHR0cHMuXG4gICAgICAgICAgICBpZiAoISAvXmh0dHAocyk/XFw6XFwvXFwvLiovaS50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUZXN0IGZpcnN0IGFsbHdheXMgaHR0cHMuXG4gICAgICAgICAgICAgICAgdXJsID0gXCJodHRwczovL1wiICsgdXJsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBodHRwIGFsbHdheXMgaW4gbG93ZXJjYXNlLlxuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL15odHRwL2ksICdodHRwJyk7XG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXmh0dHBzL2ksICdodHRwcycpO1xuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIGxhc3Qgc2xhc2guXG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlcyBhbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGlzIGlzIHVzZWQgdG8gcmVzb2x2ZSB3aGF0IGEgY2FsbGJhY2sgc2hvdWxkIGJlIHdoZW4gYXR0YWNoZWQgdG8gYSBkZWxlZ2F0ZS5cbiAgICAgICAgICogRm9yIGluc3RhbmNlLCBpZiB0aGUgb2JqZWN0IGF0dGFjaGVkIGlzIGEgZnVuY3Rpb24sIGl0IGlzIHJldHVybmVkIGFzIGlzLCBidXRcbiAgICAgICAgICogd2UgYWxzbyBzdXBwb3J0IGNvbXBsZXggZGVmaW5pdGlvbiBvZiBvYmplY3RzLiBJZiB3ZSByZWNlaXZlIGEgc3RyaW5nIHdlIHdpbGwgcGFyc2VcbiAgICAgICAgICogaXQgYW5kIHRvIGluamVjdCBpdHMgc2VydmljZSB1c2luZyAkaW5qZWN0b3IgZnJvbSBBbmd1bGFyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlczpcbiAgICAgICAgICogLSAoRnVuY3Rpb24pOiByZXR1cm5zIHRoZSBzYW1lIGZ1bmN0aW9uLlxuICAgICAgICAgKiAtIChPYmplY3QpOiByZXR1cm5zIHRoZSBzYW1lIG9iamVjdC5cbiAgICAgICAgICogLSAnJG1tU29tZXRoaW5nJzogSW5qZWN0cyBhbmQgcmV0dXJucyAkbW1Tb21ldGhpbmcuXG4gICAgICAgICAqIC0gJyRtbVNvbWV0aGluZy5tZXRob2QnOiBJbmplY3RlcyBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gJ21ldGhvZCcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjcmVzb2x2ZU9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gIHtNaXhlZH0gb2JqZWN0IFN0cmluZywgb2JqZWN0IG9yIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbaW5zdGFudGlhdGU9ZmFsc2VdIFdoZW4gdHJ1ZSwgaWYgdGhlIG9iamVjdCByZXNvbHZlZCBpcyBhIGZ1bmN0aW9uLCBpbnN0YW50aWF0ZXMgaXQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IHJlc29sdmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBpbnN0YW50aWF0ZSkge1xuICAgICAgICAgICAgdmFyIHRvSW5qZWN0LFxuICAgICAgICAgICAgICAgIHJlc29sdmVkO1xuXG4gICAgICAgICAgICBpbnN0YW50aWF0ZSA9IGFuZ3VsYXIuaXNVbmRlZmluZWQoaW5zdGFudGlhdGUpID8gZmFsc2UgOiBpbnN0YW50aWF0ZTtcblxuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihvYmplY3QpIHx8IGFuZ3VsYXIuaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gb2JqZWN0O1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHRvSW5qZWN0ID0gb2JqZWN0LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSAkaW5qZWN0b3IuZ2V0KHRvSW5qZWN0WzBdKTtcblxuICAgICAgICAgICAgICAgIGlmICh0b0luamVjdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gcmVzb2x2ZWRbdG9JbmplY3RbMV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihyZXNvbHZlZCkgJiYgaW5zdGFudGlhdGUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHJlc29sdmVkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50IHBhc3NlZCBwYXNzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBpZiBhIFVSTCBpcyBkb3dubG9hZGFibGU6IHBsdWdpbiBmaWxlIE9SIHRoZW1lL2ltYWdlLnBocCBPUiBncmF2YXRhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNpc0Rvd25sb2FkYWJsZVVybFxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB1cmwgVGhlIFVSTCB0byB0ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSB3aGVuIHRoZSBVUkwgaXMgZG93bmxvYWRhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0Rvd25sb2FkYWJsZVVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaXNQbHVnaW5GaWxlVXJsKHVybCkgfHwgc2VsZi5pc1RoZW1lSW1hZ2VVcmwodXJsKSB8fCBzZWxmLmlzR3JhdmF0YXJVcmwodXJsKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBpZiBhIFVSTCBpcyBhIGdyYXZhdGFyIFVSTC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNpc0dyYXZhdGFyVXJsXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHVybCBUaGUgVVJMIHRvIHRlc3QuXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIHdoZW4gdGhlIFVSTCBpcyBhIGdyYXZhdGFyIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNHcmF2YXRhclVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHVybCAmJiB1cmwuaW5kZXhPZignZ3JhdmF0YXIuY29tL2F2YXRhcicpICE9PSAtMTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBpZiBhIFVSTCBpcyBhIHBsdWdpbmZpbGUgVVJMLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2lzUGx1Z2luRmlsZVVybFxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB1cmwgVGhlIFVSTCB0byB0ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSB3aGVuIHRoZSBVUkwgaXMgYSBwbHVnaW5maWxlIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNQbHVnaW5GaWxlVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsICYmIHVybC5pbmRleE9mKCcvcGx1Z2luZmlsZS5waHAnKSAhPT0gLTE7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgaWYgYSBVUkwgaXMgYSB0aGVtZSBpbWFnZSBVUkwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjaXNUaGVtZUltYWdlVXJsXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHVybCBUaGUgVVJMIHRvIHRlc3QuXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIHdoZW4gdGhlIFVSTCBpcyBhIHRoZW1lIGltYWdlIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNUaGVtZUltYWdlVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsICYmIHVybC5pbmRleE9mKCcvdGhlbWUvaW1hZ2UucGhwJykgIT09IC0xO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0ZXMgYSBVUkwgZm9yIGEgc3BlY2lmaWMgcGF0dGVybi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNpc1ZhbGlkVVJMXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVybCB0byB0ZXN0IGFnYWluc3QgdGhlIHBhdHRlcm5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICBUUlVFIGlmIHRoZSB1cmwgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgcGF0dGVybi5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICBGQUxTRSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzVmFsaWRVUkwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiAvXmh0dHAocyk/XFw6XFwvXFwvKFtcXGRhLXpBLVpcXC4tXSspXFwuKFtcXGRhLXpBLVpcXC5dezIsNn0pKFtcXC9cXHcgXFwuLV0qKSpcXC8/L2kudGVzdCh1cmwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmljIGZ1bmN0aW9uIGZvciBhZGRpbmcgdGhlIHdzdG9rZW4gdG8gTW9vZGxlIHVybHMgYW5kIGZvciBwb2ludGluZyB0byB0aGUgY29ycmVjdCBzY3JpcHQuXG4gICAgICAgICAqIEZvciBkb3dubG9hZCByZW1vdGUgZmlsZXMgZnJvbSBNb29kbGUgd2UgbmVlZCB0byB1c2UgdGhlIHNwZWNpYWwgL3dlYnNlcnZpY2UvcGx1Z2luZmlsZSBwYXNzaW5nXG4gICAgICAgICAqIHRoZSB3cyB0b2tlbiBhcyBhIGdldCBwYXJhbWV0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjZml4UGx1Z2luZmlsZVVSTFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgVGhlIHVybCB0byBiZSBmaXhlZC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIFRva2VuIHRvIHVzZS5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgIEZpeGVkIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZml4UGx1Z2luZmlsZVVSTCA9IGZ1bmN0aW9uKHVybCwgdG9rZW4pIHtcblxuICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluIHJlZ2V4cCBjYWxsYmFja3MsIGJldHRlciBub3QgdG8gcmlzayEhXG4gICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgbmVlZCB0byBmaXggdGhpcyB1cmwgb3IgaXMgYWxyZWFkeSBmaXhlZC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZigndG9rZW49JykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpcyBhIHZhbGlkIFVSTCAoY29udGFpbnMgdGhlIHBsdWdpbmZpbGUgZW5kcG9pbnQpLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCdwbHVnaW5maWxlJykgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbiB3aGljaCB3YXkgdGhlIHNlcnZlciBpcyBzZXJ2aW5nIHRoZSBmaWxlcz8gQXJlIHdlIHVzaW5nIHNsYXNoIHBhcmFtZXRlcnM/XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJz9maWxlPScpICE9IC0xIHx8IHVybC5pbmRleE9mKCc/Zm9yY2Vkb3dubG9hZD0nKSAhPSAtMSB8fCB1cmwuaW5kZXhPZignP3Jldj0nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHVybCArPSAnJic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybCArPSAnPyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmwgKz0gJ3Rva2VuPScgKyB0b2tlbjtcblxuICAgICAgICAgICAgLy8gU29tZSB3ZWJzZXJ2aWNlcyByZXR1cm5zIGRpcmVjdGx5IHRoZSBjb3JyZWN0IGRvd25sb2FkIHVybCwgb3RoZXJzIG5vdC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignL3dlYnNlcnZpY2UvcGx1Z2luZmlsZScpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJy9wbHVnaW5maWxlJywgJy93ZWJzZXJ2aWNlL3BsdWdpbmZpbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZW4gYSBmaWxlIHVzaW5nIHBsYXRmb3JtIHNwZWNpZmljIG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogbm9kZS13ZWJraXQ6IFVzaW5nIHRoZSBkZWZhdWx0IGFwcGxpY2F0aW9uIGNvbmZpZ3VyZWQuXG4gICAgICAgICAqIEFuZHJvaWQ6IFVzaW5nIHRoZSBXZWJJbnRlbnQgcGx1Z2luLlxuICAgICAgICAgKiBpT3M6IFVzaW5nIHRoZSB3aW5kb3cub3BlbiBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjb3BlbkZpbGVcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoIFRoZSBsb2NhbCBwYXRoIG9mIHRoZSBmaWxlIHRvIGJlIG9wZW4uXG4gICAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLm9wZW5GaWxlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBSZXN0b3JlIG5vZGUtd2Via2l0IHN1cHBvcnQuXG5cbiAgICAgICAgICAgICAgICAvLyBMaW5rIGlzIHRoZSBmaWxlIHBhdGggaW4gdGhlIGZpbGUgc3lzdGVtLlxuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgbm9kZS13ZWJraXQgc2hlbGwgZm9yIG9wZW4gdGhlIGZpbGUgKHBkZiwgZG9jKSB1c2luZyB0aGUgZGVmYXVsdCBhcHBsaWNhdGlvbiBjb25maWd1cmVkIGluIHRoZSBvcy5cbiAgICAgICAgICAgICAgICAvLyB2YXIgZ3VpID0gcmVxdWlyZSgnbncuZ3VpJyk7XG4gICAgICAgICAgICAgICAgLy8gZ3VpLlNoZWxsLm9wZW5JdGVtKHBhdGgpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cucGx1Z2lucykge1xuICAgICAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSAkbW1GUy5nZXRGaWxlRXh0ZW5zaW9uKHBhdGgpLFxuICAgICAgICAgICAgICAgICAgICBtaW1ldHlwZSA9ICRtbUZTLmdldE1pbWVUeXBlKGV4dGVuc2lvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkgJiYgd2luZG93LnBsdWdpbnMud2ViaW50ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImFuZHJvaWQuaW50ZW50LmFjdGlvbi5WSUVXXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBtaW1ldHlwZVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5wbHVnaW5zLndlYmludGVudC5zdGFydEFjdGl2aXR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0ludGVudCBsYXVuY2hlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdJbnRlbnQgbGF1bmNoaW5nIGZhaWxlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdhY3Rpb246ICcgKyBpUGFyYW1zLmFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygndXJsOiAnICsgaVBhcmFtcy51cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ3R5cGU6ICcgKyBpUGFyYW1zLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleHRlbnNpb24gfHwgZXh0ZW5zaW9uLmluZGV4T2YoJy8nKSA+IC0xIHx8IGV4dGVuc2lvbi5pbmRleE9mKCdcXFxcJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbnNpb24gbm90IGZvdW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW0uY29yZS5lcnJvcm9wZW5maWxlbm9leHRlbnNpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW0uY29yZS5lcnJvcm9wZW5maWxlbm9hcHAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlvbmljLlBsYXRmb3JtLmlzSU9TKCkgJiYgdHlwZW9mIGhhbmRsZURvY3VtZW50V2l0aFVSTCA9PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgJG1tRlMuZ2V0QmFzZVBhdGgoKS50aGVuKGZ1bmN0aW9uKGZzUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlL2RlY29kZSB0aGUgc3BlY2lmaWMgZmlsZSBwYXRoLCBub3RlIHRoYXQgYSBwYXRoIG1heSBjb250YWluIGRpcmVjdG9yaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHdoaXRlIHNwYWNlcywgc3BlY2lhbCBjaGFyYWN0ZXJzLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKGZzUm9vdCA+IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoZnNSb290LCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudChwYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGZzUm9vdCArIHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZURvY3VtZW50V2l0aFVSTChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRmlsZSBvcGVuZWQgd2l0aCBoYW5kbGVEb2N1bWVudFdpdGhVUkwnICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0Vycm9yIG9wZW5pbmcgd2l0aCBoYW5kbGVEb2N1bWVudFdpdGhVUkwnICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVycm9yID09IDUzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdObyBhcHAgdGhhdCBoYW5kbGVzIHRoaXMgZmlsZSB0eXBlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub3BlbkluQnJvd3NlcihwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBMYXN0IHRyeSwgbGF1bmNoIHRoZSBmaWxlIHdpdGggdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3BlbkluQnJvd3NlcihwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdpbmcgX2JsYW5rIGZvciBfc3lzdGVtIG1heSB3b3JrIGluIGNvcmRvdmEgMi40IGFuZCBvbndhcmRzLlxuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ09wZW5pbmcgZXh0ZXJuYWwgZmlsZSB1c2luZyB3aW5kb3cub3BlbigpJyk7XG4gICAgICAgICAgICAgICAgd2luZG93Lm9wZW4ocGF0aCwgJ19ibGFuaycpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZW4gYSBVUkwgdXNpbmcgYSBicm93c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBEbyBub3QgdXNlIGZvciBmaWxlcywgcmVmZXIgdG8ge0BsaW5rICRtbVV0aWwjb3BlbkZpbGV9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI29wZW5JbkJyb3dzZXJcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBvcGVuLlxuICAgICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5vcGVuSW5Ccm93c2VyID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICB3aW5kb3cub3Blbih1cmwsICdfc3lzdGVtJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZW4gYSBVUkwgdXNpbmcgSW5BcHBCcm93c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBEbyBub3QgdXNlIGZvciBmaWxlcywgcmVmZXIgdG8ge0BsaW5rICRtbVV0aWwjb3BlbkZpbGV9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI29wZW5JbkFwcFxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIG9wZW4uXG4gICAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLm9wZW5JbkFwcCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgd2luZG93Lm9wZW4odXJsLCAnX2JsYW5rJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXlzIGEgbG9hZGluZyBtb2RhbCB3aW5kb3cuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjc2hvd01vZGFsTG9hZGluZ1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gIHRleHQgICAgICAgICAgIFRoZSB0ZXh0IG9mIHRoZSBtb2RhbCB3aW5kb3cuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVlZHNUcmFuc2xhdGUgVHJ1ZSBpZiB0aGUgJ3RleHQnIGlzIGEgJHRyYW5zbGF0ZSBrZXksIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICBPYmplY3Qgd2l0aCBhICdkaXNtaXNzJyBmdW5jdGlvbiB0byBjbG9zZSB0aGUgbW9kYWwuXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBVc2FnZTpcbiAgICAgICAgICogICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZyhteVRleHQpO1xuICAgICAgICAgKiAgICAgLi4uXG4gICAgICAgICAqICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnNob3dNb2RhbExvYWRpbmcgPSBmdW5jdGlvbih0ZXh0LCBuZWVkc1RyYW5zbGF0ZSkge1xuICAgICAgICAgICAgdmFyIG1vZGFsQ2xvc2VkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgbW9kYWxTaG93biA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gJ21tLmNvcmUubG9hZGluZyc7XG4gICAgICAgICAgICAgICAgbmVlZHNUcmFuc2xhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzaG93TW9kYWwodGV4dCkge1xuICAgICAgICAgICAgICAgIGlmICghbW9kYWxDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJGlvbmljTG9hZGluZy5zaG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAgICc8aW9uLXNwaW5uZXI+PC9pb24tc3Bpbm5lcj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8cD4nK3RleHQrJzwvcD4nXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtb2RhbFNob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZWVkc1RyYW5zbGF0ZSkge1xuICAgICAgICAgICAgICAgICR0cmFuc2xhdGUodGV4dCkudGhlbihzaG93TW9kYWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaG93TW9kYWwodGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzbWlzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGFsQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGFsU2hvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRpb25pY0xvYWRpbmcuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBhIG1vZGFsIHdpdGggYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNzaG93RXJyb3JNb2RhbFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JNZXNzYWdlICAgIE1lc3NhZ2UgdG8gc2hvdy5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBuZWVkc1RyYW5zbGF0ZSBUcnVlIGlmIHRoZSBlcnJvck1lc3NhZ2UgaXMgYSAkdHJhbnNsYXRlIGtleSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2F1dG9jbG9zZVRpbWVdIE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB0byBjbG9zZSB0aGUgbW9kYWwuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IGRlZmluZWQsIG1vZGFsIHdvbid0IGJlIGF1dG9tYXRpY2FsbHkgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5zaG93RXJyb3JNb2RhbCA9IGZ1bmN0aW9uKGVycm9yTWVzc2FnZSwgbmVlZHNUcmFuc2xhdGUsIGF1dG9jbG9zZVRpbWUpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcktleSA9ICdtbS5jb3JlLmVycm9yJyxcbiAgICAgICAgICAgICAgICBsYW5nS2V5cyA9IFtlcnJvcktleV07XG5cbiAgICAgICAgICAgIGlmIChuZWVkc1RyYW5zbGF0ZSkge1xuICAgICAgICAgICAgICAgIGxhbmdLZXlzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJHRyYW5zbGF0ZShsYW5nS2V5cykudGhlbihmdW5jdGlvbih0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9wdXAgPSAkaW9uaWNQb3B1cC5hbGVydCh7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0cmFuc2xhdGlvbnNbZXJyb3JLZXldLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogbmVlZHNUcmFuc2xhdGUgPyB0cmFuc2xhdGlvbnNbZXJyb3JNZXNzYWdlXSA6IGVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdXRvY2xvc2VUaW1lICE9ICd1bmRlZmluZWQnICYmICFpc05hTihwYXJzZUludChhdXRvY2xvc2VUaW1lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3B1cC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBwYXJzZUludChhdXRvY2xvc2VUaW1lKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBvcHVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IGEgbW9kYWwgd2l0aCBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI3Nob3dNb2RhbFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgICAgICAgIExhbmd1YWdlIGtleS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgICAgICBMYW5ndWFnZSBrZXkuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnNob3dNb2RhbCA9IGZ1bmN0aW9uKHRpdGxlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXG4gICAgICAgICAgICAgICAgJHRyYW5zbGF0ZSh0aXRsZSksXG4gICAgICAgICAgICAgICAgJHRyYW5zbGF0ZShtZXNzYWdlKSxcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbih0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAkaW9uaWNQb3B1cC5hbGVydCh7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0cmFuc2xhdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0cmFuc2xhdGlvbnNbMV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IGEgY29uZmlybSBtb2RhbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNzaG93Q29uZmlybVxuICAgICAgICAgKiBAcGFyYW0gIHtNaXhlZH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gc2hvdyBpbiB0aGUgbW9kYWwgYm9keS4gQ2FuIGJlIGEgc3RyaW5nIG9yIGEgcHJvbWlzZS5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgaWYgdGhlIHVzZXIgY29uZmlybXMgYW5kIHJlamVjdGVkIGlmIGhlIGNhbmNlbHMuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnNob3dDb25maXJtID0gZnVuY3Rpb24odGVtcGxhdGUsIHRpdGxlKSB7XG4gICAgICAgICAgICB2YXIgb2sgPSAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUueWVzJyksXG4gICAgICAgICAgICAgICAgY2FuY2VsID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLm5vJyk7XG5cbiAgICAgICAgICAgIHJldHVybiAkaW9uaWNQb3B1cC5jb25maXJtKHt0ZW1wbGF0ZTogdGVtcGxhdGUsIHRpdGxlOiB0aXRsZSwgb2tUZXh0OiBvaywgY2FuY2VsVGV4dDogY2FuY2VsfSkudGhlbihmdW5jdGlvbihjb25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgYSBwcm9tcHQgbW9kYWwgdG8gaW5wdXQgc29tZSBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI3Nob3dQcm9tcHRcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBib2R5ICAgICAgICAgICAgIE1vZGFsIGJvZHkuXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGUgICAgICAgICAgICBNb2RhbCB0aXRsZS5cbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBpbnB1dFBsYWNlaG9sZGVyIFBsYWNlaG9sZGVyIG9mIHRoZSBpbnB1dCBib3guIEJ5IGRlZmF1bHQsIFwiUGFzc3dvcmRcIi5cbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBbaW5wdXRUeXBlXSAgICAgIFR5cGUgb2YgdGhlIGlucHV0IGJveC4gQnkgZGVmYXVsdCwgcGFzc3dvcmQuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGlucHV0IGRhdGEgaWYgdGhlIHVzZXIgY2xpY2tzIE9LLCByZWplY3RlZCBpZiBjYW5jZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5zaG93UHJvbXB0ID0gZnVuY3Rpb24oYm9keSwgdGl0bGUsIGlucHV0UGxhY2Vob2xkZXIsIGlucHV0VHlwZSkge1xuICAgICAgICAgICAgaW5wdXRUeXBlID0gaW5wdXRUeXBlIHx8ICdwYXNzd29yZCc7XG5cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBib2R5LFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICBpbnB1dFBsYWNlaG9sZGVyOiBpbnB1dFBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIGlucHV0VHlwZTogaW5wdXRUeXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICRpb25pY1BvcHVwLnByb21wdChvcHRpb25zKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyBhbmQgcGFyc2VzIGEgSlNPTiBmaWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI3JlYWRKU09ORmlsZVxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggUGF0aCB0byB0aGUgZmlsZS5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZSBpcyBwYXJzZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnJlYWRKU09ORmlsZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQocGF0aCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb3VudHJ5IG5hbWUgYmFzZWQgb24gY291bnRyeSBjb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2dldENvdW50cnlOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlIENvdW50cnkgY29kZSAoQUYsIEVTLCBVUywgLi4uKS5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgQ291bnRyeSBuYW1lLiBJZiB0aGUgY291bnRyeSBpcyBub3QgZm91bmQsIHJldHVybiB0aGUgY291bnRyeSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb3VudHJ5TmFtZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgICAgICAgIHZhciBjb3VudHJ5S2V5ID0gJ21tLmNvcmUuY291bnRyeS0nICsgY29kZSxcbiAgICAgICAgICAgICAgICBjb3VudHJ5TmFtZSA9ICR0cmFuc2xhdGUuaW5zdGFudChjb3VudHJ5S2V5KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvdW50cnlOYW1lICE9PSBjb3VudHJ5S2V5ID8gY291bnRyeU5hbWUgOiBjb2RlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBVUkwgdG8gdGhlIGRvY3VtZW50YXRpb24gb2YgdGhlIGFwcCwgYmFzZWQgb24gTW9vZGxlIHZlcnNpb24gYW5kIGN1cnJlbnQgbGFuZ3VhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVsZWFzZV0gTW9vZGxlIHJlbGVhc2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFnZV0gICAgRG9jcyBwYWdlIHRvIGdvIHRvLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgTW9vZGxlIGRvY3MgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXREb2NzVXJsID0gZnVuY3Rpb24ocmVsZWFzZSwgcGFnZSkge1xuICAgICAgICAgICAgcGFnZSA9IHBhZ2UgfHzCoCdNb2JpbGVfYXBwJztcblxuICAgICAgICAgICAgdmFyIGRvY3N1cmwgPSAnaHR0cHM6Ly9kb2NzLm1vb2RsZS5vcmcvZW4vJyArIHBhZ2U7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVsZWFzZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gcmVsZWFzZS5zdWJzdHIoMCwgMykucmVwbGFjZShcIi5cIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaXMgYSB2YWxpZCBudW1iZXIuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KHZlcnNpb24pID49IDI0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCByZWxlYXNlIG51bWJlci5cbiAgICAgICAgICAgICAgICAgICAgZG9jc3VybCA9IGRvY3N1cmwucmVwbGFjZSgnaHR0cHM6Ly9kb2NzLm1vb2RsZS5vcmcvJywgJ2h0dHBzOi8vZG9jcy5tb29kbGUub3JnLycgKyB2ZXJzaW9uICsgJy8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvY3N1cmwgPSAnaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvbWlyYWNsZWZpc2guY29tL2JpcmtiZWNrLyc7XG5cbiAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLmdldEN1cnJlbnRMYW5ndWFnZSgpLnRoZW4oZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2NzdXJsLnJlcGxhY2UoJy9lbi8nLCAnLycgKyBsYW5nICsgJy8nKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2NzdXJsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgY3VycmVudCB0aW1lc3RhbXAgKFVOSVggZm9ybWF0LCBzZWNvbmRzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCN0aW1lc3RhbXBcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCB0aW1lc3RhbXAgaW4gc2Vjb25kcy5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYudGltZXN0YW1wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcGFyYW0gaXMgZmFsc2UgKGJvb2wpLCAwIChudW1iZXIpIG9yIFwiMFwiIChzdHJpbmcpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2lzRmFsc2VPclplcm9cbiAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVmFsdWUgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgIFRydWUgaWYgdmFsdWUgaXMgZmFsc2UsIDAgb3IgXCIwXCIuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRmFsc2VPclplcm8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPSAndW5kZWZpbmVkJyAmJiAodmFsdWUgPT09IGZhbHNlIHx8IHBhcnNlSW50KHZhbHVlKSA9PT0gMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBwYXJhbSBpcyB0cnVlIChib29sKSwgMSAobnVtYmVyKSBvciBcIjFcIiAoc3RyaW5nKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNpc1RydWVPck9uZVxuICAgICAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBWYWx1ZSB0byBjaGVjay5cbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgVHJ1ZSBpZiB2YWx1ZSBpcyB0cnVlLCAxIG9yIFwiMVwiLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc1RydWVPck9uZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9ICd1bmRlZmluZWQnICYmICh2YWx1ZSA9PT0gdHJ1ZSB8fCBwYXJzZUludCh2YWx1ZSkgPT09IDEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzIGluIGEgaHVtYW4gcmVhZGFibGUgZm9ybWF0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjZm9ybWF0VGltZVxuICAgICAgICAgKiBAcGFyYW0gIHtJbnRlZ2VyfSBzZWNvbmRzIEEgbnVtYmVyIG9mIHNlY29uZHNcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIEh1bWFuIHJlYWRhYmxlIHNlY29uZHMgZm9ybWF0dGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmZvcm1hdFRpbWUgPSBmdW5jdGlvbihzZWNvbmRzKSB7XG4gICAgICAgICAgICB2YXIgbGFuZ0tleXMgPSBbJ21tLmNvcmUuZGF5JywgJ21tLmNvcmUuZGF5cycsICdtbS5jb3JlLmhvdXInLCAnbW0uY29yZS5ob3VycycsICdtbS5jb3JlLm1pbicsICdtbS5jb3JlLm1pbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtbS5jb3JlLnNlYycsICdtbS5jb3JlLnNlY3MnLCAnbW0uY29yZS55ZWFyJywgJ21tLmNvcmUueWVhcnMnLCAnbW0uY29yZS5ub3cnXTtcblxuICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUobGFuZ0tleXMpLnRoZW4oZnVuY3Rpb24odHJhbnNsYXRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICB0b3RhbFNlY3MgPSBNYXRoLmFicyhzZWNvbmRzKTtcblxuICAgICAgICAgICAgICAgIHZhciB5ZWFycyAgICAgPSBNYXRoLmZsb29yKHRvdGFsU2VjcyAvIG1tQ29yZVNlY29uZHNZZWFyKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gdG90YWxTZWNzIC0gKHllYXJzICogbW1Db3JlU2Vjb25kc1llYXIpO1xuICAgICAgICAgICAgICAgIHZhciBkYXlzICAgICAgPSBNYXRoLmZsb29yKHJlbWFpbmRlciAvIG1tQ29yZVNlY29uZHNEYXkpO1xuICAgICAgICAgICAgICAgIHJlbWFpbmRlciA9IHRvdGFsU2VjcyAtIChkYXlzICogbW1Db3JlU2Vjb25kc0RheSk7XG4gICAgICAgICAgICAgICAgdmFyIGhvdXJzICAgICA9IE1hdGguZmxvb3IocmVtYWluZGVyIC8gbW1Db3JlU2Vjb25kc0hvdXIpO1xuICAgICAgICAgICAgICAgIHJlbWFpbmRlciA9IHJlbWFpbmRlciAtIChob3VycyAqIG1tQ29yZVNlY29uZHNIb3VyKTtcbiAgICAgICAgICAgICAgICB2YXIgbWlucyAgICAgID0gTWF0aC5mbG9vcihyZW1haW5kZXIgLyBtbUNvcmVTZWNvbmRzTWludXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VjcyAgICAgID0gcmVtYWluZGVyIC0gKG1pbnMgKiBtbUNvcmVTZWNvbmRzTWludXRlKTtcblxuICAgICAgICAgICAgICAgIHZhciBzcyA9IChzZWNzID09IDEpICA/IHRyYW5zbGF0aW9uc1snbW0uY29yZS5zZWMnXSAgOiB0cmFuc2xhdGlvbnNbJ21tLmNvcmUuc2VjcyddO1xuICAgICAgICAgICAgICAgIHZhciBzbSA9IChtaW5zID09IDEpICA/IHRyYW5zbGF0aW9uc1snbW0uY29yZS5taW4nXSAgOiB0cmFuc2xhdGlvbnNbJ21tLmNvcmUubWlucyddO1xuICAgICAgICAgICAgICAgIHZhciBzaCA9IChob3VycyA9PSAxKSA/IHRyYW5zbGF0aW9uc1snbW0uY29yZS5ob3VyJ10gOiB0cmFuc2xhdGlvbnNbJ21tLmNvcmUuaG91cnMnXTtcbiAgICAgICAgICAgICAgICB2YXIgc2QgPSAoZGF5cyA9PSAxKSAgPyB0cmFuc2xhdGlvbnNbJ21tLmNvcmUuZGF5J10gIDogdHJhbnNsYXRpb25zWydtbS5jb3JlLmRheXMnXTtcbiAgICAgICAgICAgICAgICB2YXIgc3kgPSAoeWVhcnMgPT0gMSkgPyB0cmFuc2xhdGlvbnNbJ21tLmNvcmUueWVhciddIDogdHJhbnNsYXRpb25zWydtbS5jb3JlLnllYXJzJ107XG5cbiAgICAgICAgICAgICAgICB2YXIgb3llYXJzID0gJycsXG4gICAgICAgICAgICAgICAgICAgIG9kYXlzID0gJycsXG4gICAgICAgICAgICAgICAgICAgIG9ob3VycyA9ICcnLFxuICAgICAgICAgICAgICAgICAgICBvbWlucyA9ICcnLFxuICAgICAgICAgICAgICAgICAgICBvc2VjcyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKHllYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIG95ZWFycyAgPSB5ZWFycyArICcgJyArIHN5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgICAgICAgICBvZGF5cyAgPSBkYXlzICsgJyAnICsgc2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChob3Vycykge1xuICAgICAgICAgICAgICAgICAgICBvaG91cnMgPSBob3VycyArICcgJyArIHNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWlucykge1xuICAgICAgICAgICAgICAgICAgICBvbWlucyAgPSBtaW5zICsgJyAnICsgc207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9zZWNzICA9IHNlY3MgKyAnICcgKyBzcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeWVhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG95ZWFycyArICcgJyArIG9kYXlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2RheXMgKyAnICcgKyBvaG91cnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChob3Vycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2hvdXJzICsgJyAnICsgb21pbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbWlucyArICcgJyArIG9zZWNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2Vjcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3NlY3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGlvbnNbJ21tLmNvcmUubm93J107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW1wdGllcyBhbiBhcnJheSB3aXRob3V0IGxvc2luZyBpdHMgcmVmZXJlbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2VtcHR5QXJyYXlcbiAgICAgICAgICogQHBhcmFtICB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGVtcHR5LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5lbXB0eUFycmF5ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgICAgIGFycmF5Lmxlbmd0aCA9IDA7IC8vIEVtcHR5IGFycmF5IHdpdGhvdXQgbG9zaW5nIGl0cyByZWZlcmVuY2UuXG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbWlsYXIgdG8gJHEuYWxsLCBidXQgaWYgYSBwcm9taXNlIGZhaWxzIHRoaXMgZnVuY3Rpb24ncyBwcm9taXNlIHdvbid0IGJlIHJlamVjdGVkIHVudGlsIEFMTCBwcm9taXNlcyBoYXZlIGZpbmlzaGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2FsbFByb21pc2VzXG4gICAgICAgICAqIEBwYXJhbSAge1Byb21pc2VbXX0gcHJvbWlzZXMgUHJvbWlzZXMuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCBpZiBhbGwgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGFuZCByZWplY3RlZCBpZiBhdCBsZWFzdCAxIHByb21pc2UgZmFpbHMuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmFsbFByb21pc2VzID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcbiAgICAgICAgICAgIGlmICghcHJvbWlzZXMgfHwgIXByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgICAgICAgZmFpbGVkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocHJvbWlzZXMsIGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSBwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBwcm9taXNlcyBoYXZlIGZpbmlzaGVkLCByZWplY3QvcmVzb2x2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgdHdvIG9iamVjdHMuIFRoaXMgZnVuY3Rpb24gd29uJ3QgY29tcGFyZSBmdW5jdGlvbnMgYW5kIHByb3RvIHByb3BlcnRpZXMsIGl0J3MgYSBiYXNpYyBjb21wYXJlLlxuICAgICAgICAgKiBBbHNvLCB0aGlzIHdpbGwgb25seSBjaGVjayBpZiBpdGVtQSdzIHByb3BlcnRpZXMgYXJlIGluIGl0ZW1CIHdpdGggc2FtZSB2YWx1ZS4gVGhpcyBmdW5jdGlvbiB3aWxsIHN0aWxsXG4gICAgICAgICAqIHJldHVybiB0cnVlIGlmIGl0ZW1CIGhhcyBtb3JlIHByb3BlcnRpZXMgdGhhbiBpdGVtQS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNiYXNpY0xlZnRDb21wYXJlXG4gICAgICAgICAqIEBwYXJhbSB7TWl4ZWR9ICBpdGVtQSAgICAgICAgIEZpcnN0IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gIGl0ZW1CICAgICAgICAgU2Vjb25kIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhMZXZlbHM9MF0gTnVtYmVyIG9mIGxldmVscyB0byByZWFjaCBpZiAyIG9iamVjdHMgYXJlIGNvbXBhcmVkLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2xldmVsPTBdICAgICBDdXJyZW50IGRlZXAgbGV2ZWwgKHdoZW4gY29tcGFyaW5nIG9iamVjdHMpLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICBUcnVlIGlmIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmJhc2ljTGVmdENvbXBhcmUgPSBmdW5jdGlvbihpdGVtQSwgaXRlbUIsIG1heExldmVscywgbGV2ZWwpIHtcbiAgICAgICAgICAgIGxldmVsID0gbGV2ZWwgfHzCoDA7XG4gICAgICAgICAgICBtYXhMZXZlbHMgPSBtYXhMZXZlbHPCoHx8IDA7XG5cbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24oaXRlbUEpIHx8wqBhbmd1bGFyLmlzRnVuY3Rpb24oaXRlbUIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIERvbid0IGNvbXBhcmUgZnVuY3Rpb25zLlxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzT2JqZWN0KGl0ZW1BKSAmJiBhbmd1bGFyLmlzT2JqZWN0KGl0ZW1CKSkge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSBtYXhMZXZlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE1heCBkZWVwIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGVxdWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaXRlbUEsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5iYXNpY0xlZnRDb21wYXJlKHZhbHVlLCBpdGVtQltuYW1lXSwgbWF4TGV2ZWxzLCBsZXZlbCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSdsbCB0cmVhdCBcIjJcIiBhbmQgMiBhcyB0aGUgc2FtZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICB2YXIgZmxvYXRBID0gcGFyc2VGbG9hdChpdGVtQSksXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0QiA9IHBhcnNlRmxvYXQoaXRlbUIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihmbG9hdEEpICYmICFpc05hTihmbG9hdEIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG9hdEEgPT0gZmxvYXRCO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbUEgPT09IGl0ZW1CO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZG93bmxvYWQgc2l6ZSBpcyBoaWdoZXIgdGhhbiBhIGNlcnRhaW4gdGhyZXNob2xkIHNob3dzIGEgY29uZmlybSBkaWFsb2cuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjY29uZmlybURvd25sb2FkU2l6ZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAgICAgICAgICAgICAgICAgU2l6ZSB0byBkb3dubG9hZCAoaW4gYnl0ZXMpLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdICAgICAgICAgICAgQ29kZSBvZiB0aGUgbWVzc2FnZSB0byBzaG93LiBEZWZhdWx0OiAnbW0uY291cnNlLmNvbmZpcm1kb3dubG9hZCcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbdW5rbm93bnNpemVtZXNzYWdlXSBDb2RlIG9mIHRoZSBtZXNzYWdlIHRvIHNob3cgaWYgc2l6ZSBpcyB1bmtub3duLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdDogJ21tLmNvdXJzZS5jb25maXJtZG93bmxvYWR1bmtub3duc2l6ZScuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2lmaVRocmVzaG9sZF0gICAgICBUaHJlc2hvbGQgdG8gc2hvdyBjb25maXJtIGluIFdpRmkgY29ubmVjdGlvbi4gRGVmYXVsdDogbW1Db3JlV2lmaURvd25sb2FkVGhyZXNob2xkLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0ZWRUaHJlc2hvbGRdICAgVGhyZXNob2xkIHRvIHNob3cgY29uZmlybSBpbiBsaW1pdGVkIGNvbm5lY3Rpb24uIERlZmF1bHQ6IG1tQ29yZURvd25sb2FkVGhyZXNob2xkLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHVzZXIgY29uZmlybXMgb3IgaWYgbm8gY29uZmlybSBuZWVkZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmNvbmZpcm1Eb3dubG9hZFNpemUgPSBmdW5jdGlvbihzaXplLCBtZXNzYWdlLCB1bmtub3duc2l6ZW1lc3NhZ2UsIHdpZmlUaHJlc2hvbGQsIGxpbWl0ZWRUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHdpZmlUaHJlc2hvbGQgPSB0eXBlb2Ygd2lmaVRocmVzaG9sZCA9PSAndW5kZWZpbmVkJyA/IG1tQ29yZVdpZmlEb3dubG9hZFRocmVzaG9sZCA6IHdpZmlUaHJlc2hvbGQ7XG4gICAgICAgICAgICBsaW1pdGVkVGhyZXNob2xkID0gdHlwZW9mIGxpbWl0ZWRUaHJlc2hvbGQgPT0gJ3VuZGVmaW5lZCcgPyBtbUNvcmVEb3dubG9hZFRocmVzaG9sZCA6IGxpbWl0ZWRUaHJlc2hvbGQ7XG4gICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fMKgJ21tLmNvdXJzZS5jb25maXJtZG93bmxvYWQnO1xuICAgICAgICAgICAgdW5rbm93bnNpemVtZXNzYWdlID0gdW5rbm93bnNpemVtZXNzYWdlIHx8wqAnbW0uY291cnNlLmNvbmZpcm1kb3dubG9hZHVua25vd25zaXplJztcblxuICAgICAgICAgICAgaWYgKHNpemUgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFNlZW1zIHNpemUgd2FzIHVuYWJsZSB0byBiZSBjYWxjdWxhdGVkLiBTaG93IGEgd2FybmluZy5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zaG93Q29uZmlybSgkdHJhbnNsYXRlKHVua25vd25zaXplbWVzc2FnZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA+PSB3aWZpVGhyZXNob2xkIHx8ICgkbW1BcHAuaXNOZXR3b3JrQWNjZXNzTGltaXRlZCgpICYmIHNpemUgPj0gbGltaXRlZFRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGFibGVTaXplID0gJG1tVGV4dC5ieXRlc1RvU2l6ZShzaXplLCAyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zaG93Q29uZmlybSgkdHJhbnNsYXRlKG1lc3NhZ2UsIHtzaXplOiByZWFkYWJsZVNpemV9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JtYXRzIGEgc2l6ZSB0byBiZSB1c2VkIGFzIHdpZHRoL2hlaWdodCBvZiBhbiBlbGVtZW50LlxuICAgICAgICAgKiBJZiB0aGUgc2l6ZSBpcyBhbHJlYWR5IHZhbGlkIChsaWtlICc1MDBweCcgb3IgJzUwJScpIGl0IHdvbid0IGJlIG1vZGlmaWVkLlxuICAgICAgICAgKiBSZXR1cm5lZCBzaXplIHdpbGwgaGF2ZSBhIGZvcm1hdCBsaWtlICc1MDBweCcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjZm9ybWF0UGl4ZWxzU2l6ZVxuICAgICAgICAgKiBAcGFyYW0gIHtNaXhlZH0gc2l6ZSBTaXplIHRvIGZvcm1hdC5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgRm9ybWF0dGVkIHNpemUuIElmIHNpemUgaXMgbm90IHZhbGlkLCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZm9ybWF0UGl4ZWxzU2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PSAnc3RyaW5nJyAmJiAoc2l6ZS5pbmRleE9mKCdweCcpID4gLTEgfHwgc2l6ZS5pbmRleE9mKCclJykgPiAtMSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBzZWVtcyB0byBiZSBhIHZhbGlkIHNpemUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHNpemUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemUgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXJpYWxpemUgYW4gb2JqZWN0IHRvIGJlIHVzZWQgaW4gYSByZXF1ZXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI3BhcmFtXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb2JqIE9iamVjdCB0byBzZXJpYWxpemUuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIFNlcmlhbGl6YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYucGFyYW0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5wYXJhbShvYmopO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSb3VuZHMgYSBudW1iZXIgdG8gdXNlIGEgY2VydGFpbiBhbW91dCBvZiBkZWNpbWFscyBvciBsZXNzLlxuICAgICAgICAgKiBEaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBmdW5jdGlvbiBhbmQgZmxvYXQncyB0b0ZpeGVkOlxuICAgICAgICAgKiA3LnRvRml4ZWQoMikgLT4gNy4wMFxuICAgICAgICAgKiByb3VuZFRvRGVjaW1hbHMoNywgMikgLT4gN1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI3JvdW5kVG9EZWNpbWFsc1xuICAgICAgICAgKiBAcGFyYW0gIHtGbG9hdH0gIG51bWJlciAgICAgICBGbG9hdCB0byByb3VuZC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbZGVjaW1hbHM9Ml0gTnVtYmVyIG9mIGRlY2ltYWxzLiBCeSBkZWZhdWx0LCAyLlxuICAgICAgICAgKiBAcmV0dXJuIHtGbG9hdH0gICAgICAgICAgICAgICBSb3VuZGVkIG51bWJlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYucm91bmRUb0RlY2ltYWxzID0gZnVuY3Rpb24obnVtYmVyLCBkZWNpbWFscykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWNpbWFscyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRlY2ltYWxzID0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChudW1iZXIpICogbXVsdGlwbGllcikgLyBtdWx0aXBsaWVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYWN0cyB0aGUgcGFyYW1ldGVycyBmcm9tIGEgVVJMIGFuZCBzdG9yZXMgdGhlbSBpbiBhbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjZXh0cmFjdFVybFBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybCBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgIE9iamVjdCB3aXRoIHRoZSBwYXJhbXMuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmV4dHJhY3RVcmxQYXJhbXMgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIHZhciByZWdleCA9IC9bPyZdKyhbXj0mXSspPT8oW14mXSopPy9naSxcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHVybC5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihtYXRjaCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogJyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBXZWIgc2VydmljZSBtb2R1bGUuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tV1NcbiAqL1xuLmZhY3RvcnkoJyRtbVdTJywgZnVuY3Rpb24oJGh0dHAsICRxLCAkbG9nLCAkbW1MYW5nLCAkY29yZG92YUZpbGVUcmFuc2ZlciwgJG1tQXBwLCAkbW1GUywgJG1tVGV4dCwgbW1Db3JlU2Vzc2lvbkV4cGlyZWQsXG4gICAgICAgICAgICBtbUNvcmVVc2VyRGVsZXRlZCwgJHRyYW5zbGF0ZSwgJHdpbmRvdywgJG1tVXRpbCkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbVdTJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGZ1bmN0aW9uIGZvciBhIG1vb2RsZSBXZWJTZXJ2aWNlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tV1MjY2FsbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIFdlYlNlcnZpY2UgbWV0aG9kIHRvIGJlIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVTZXRzIEV4dHJhIHNldHRpbmdzIGFuZCBpbmZvcm1hdGlvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBzaXRldXJsIHN0cmluZyBUaGUgc2l0ZSBVUkwuXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gd3N0b2tlbiBzdHJpbmcgVGhlIFdlYnNlcnZpY2UgdG9rZW4uXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gcmVzcG9uc2VFeHBlY3RlZCBib29sZWFuIERlZmF1bHRzIHRvIHRydWUuIFNldCB0byBmYWxzZSB3aGVuIHRoZSBleHBlY3RlZCByZXNwb25zZSBpcyBudWxsLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIHR5cGVFeHBlY3RlZCBzdHJpbmcgRGVmYXVsdHMgdG8gJ29iamVjdCcuIFVzZSBpdCB3aGVuIHlvdSBleHBlY3QgYSB0eXBlIHRoYXQncyBub3QgYW4gb2JqZWN0fGFycmF5LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzcG9uc2UgZGF0YSBpbiBzdWNjZXNzIGFuZCByZWplY3RlZCB3aXRoIHRoZSBlcnJvciBtZXNzYWdlIGlmIGl0IGZhaWxzLlxuICAgICAqL1xuICAgIHNlbGYuY2FsbCA9IGZ1bmN0aW9uKG1ldGhvZCwgZGF0YSwgcHJlU2V0cykge1xuXG4gICAgICAgIHZhciBzaXRldXJsO1xuXG4gICAgICAgIGRhdGEgPSBjb252ZXJ0VmFsdWVzVG9TdHJpbmcoZGF0YSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVTZXRzID09ICd1bmRlZmluZWQnIHx8IHByZVNldHMgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJlU2V0cy53c3Rva2VuID09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcmVTZXRzLnNpdGV1cmwgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0uY29yZS51bmV4cGVjdGVkZXJyb3InKTtcbiAgICAgICAgfSBlbHNlIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0uY29yZS5uZXR3b3JrZXJyb3Jtc2cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZVNldHMudHlwZUV4cGVjdGVkID0gcHJlU2V0cy50eXBlRXhwZWN0ZWQgfHwgJ29iamVjdCc7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlU2V0cy5yZXNwb25zZUV4cGVjdGVkID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwcmVTZXRzLnJlc3BvbnNlRXhwZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS53c2Z1bmN0aW9uID0gbWV0aG9kO1xuICAgICAgICBkYXRhLndzdG9rZW4gPSBwcmVTZXRzLndzdG9rZW47XG4gICAgICAgIHNpdGV1cmwgPSBwcmVTZXRzLnNpdGV1cmwgKyAnL3dlYnNlcnZpY2UvcmVzdC9zZXJ2ZXIucGhwP21vb2RsZXdzcmVzdGZvcm1hdD1qc29uJztcblxuICAgICAgICB2YXIgYWpheERhdGEgPSBkYXRhO1xuXG4gICAgICAgIHJldHVybiAkaHR0cC5wb3N0KHNpdGV1cmwsIGFqYXhEYXRhKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICAgICAgLy8gU29tZSBtb29kbGUgd2ViIHNlcnZpY2VzIHJldHVybiBudWxsLlxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlRXhwZWN0ZWQgdmFsdWUgaXMgc2V0IHRoZW4gc28gbG9uZyBhcyBubyBkYXRhXG4gICAgICAgICAgICAvLyBpcyByZXR1cm5lZCwgd2UgY3JlYXRlIGEgYmxhbmsgb2JqZWN0LlxuICAgICAgICAgICAgaWYgKCghZGF0YSB8fCAhZGF0YS5kYXRhKSAmJiAhcHJlU2V0cy5yZXNwb25zZUV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5kYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmNvcmUuc2VydmVyY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSAhPSBwcmVTZXRzLnR5cGVFeHBlY3RlZCkge1xuICAgICAgICAgICAgICAgICRsb2cud2FybignUmVzcG9uc2Ugb2YgdHlwZSBcIicgKyB0eXBlb2YgZGF0YSArICdcIiByZWNlaXZlZCwgZXhwZWN0aW5nIFwiJyArIHByZVNldHMudHlwZUV4cGVjdGVkICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5jb3JlLmVycm9yaW52YWxpZHJlc3BvbnNlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YoZGF0YS5leGNlcHRpb24pICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yY29kZSA9PSAnaW52YWxpZHRva2VuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGEuZXJyb3Jjb2RlID09ICdhY2Nlc3NleGNlcHRpb24nICYmIGRhdGEubWVzc2FnZS5pbmRleE9mKCdJbnZhbGlkIHRva2VuIC0gdG9rZW4gZXhwaXJlZCcpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoXCJDcml0aWNhbCBlcnJvcjogXCIgKyBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QobW1Db3JlU2Vzc2lvbkV4cGlyZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvcmNvZGUgPT09ICd1c2VyZGVsZXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChtbUNvcmVVc2VyRGVsZXRlZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZihkYXRhLmRlYnVnaW5mbykgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCdFcnJvci4gJyArIGRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRsb2cuaW5mbygnV1M6IERhdGEgcmVjZWl2ZWQgZnJvbSBXUyAnICsgdHlwZW9mKGRhdGEpKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZihkYXRhKSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YoZGF0YS5sZW5ndGgpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgJGxvZy5pbmZvKCdXUzogRGF0YSBudW1iZXIgb2YgZWxlbWVudHMgJysgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0uY29yZS5zZXJ2ZXJjb25uZWN0aW9uJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3RzIHZhbHVlcyB0byBzdHJpbmdzIHdoZXJlIGFwcHJvcHJpYXRlLlxuICAgICAqIEFycmF5cyAoYXNzb2NpYXRpdmUgb3Igb3RoZXJ3aXNlKSB3aWxsIGJlIG1haW50YWluZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSB0aGF0IG5lZWRzIGFsbCB0aGUgbm9uLW9iamVjdCB2YWx1ZXMgc2V0IHRvIHN0cmluZ3MuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xlYW5lZCBvYmplY3QsIHdpdGggbXVsdGlsZXZlbCBhcnJheSBhbmQgb2JqZWN0cyBwcmVzZXJ2ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydFZhbHVlc1RvU3RyaW5nKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoIWFuZ3VsYXIuaXNBcnJheShkYXRhKSAmJiBhbmd1bGFyLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBlbCBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoYW5ndWxhci5pc09iamVjdChkYXRhW2VsXSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbZWxdID0gY29udmVydFZhbHVlc1RvU3RyaW5nKGRhdGFbZWxdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2VsXSA9IGRhdGFbZWxdICsgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBmaWxlIGZyb20gTW9vZGxlIHVzaW5nIENvcmRvdmEgRmlsZSBBUEkuXG4gICAgICogQHRvZG8gVXNlIFdlYiBXb3JrZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgdXJsICAgICAgICBEb3dubG9hZCB1cmwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgcGF0aCAgICAgICBMb2NhbCBwYXRoIHRvIHN0b3JlIHRoZSBmaWxlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gIGJhY2tncm91bmQgVHJ1ZSBpZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBleGVjdXRlZCBpbiBiYWNrZ3JvdW5kIHVzaW5nIFdlYiBXb3JrZXJzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgVGhlIHN1Y2Nlc3MgcmV0dXJucyB0aGUgZmlsZUVudHJ5LCB0aGUgcmVqZWN0IHdpbGwgY29udGFpbiB0aGUgZXJyb3Igb2JqZWN0LlxuICAgICAqL1xuICAgIHNlbGYuZG93bmxvYWRGaWxlID0gZnVuY3Rpb24odXJsLCBwYXRoLCBiYWNrZ3JvdW5kKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ0Rvd25sb2FkaW5nIGZpbGUgJyArIHVybCk7XG5cbiAgICAgICAgcmV0dXJuICRtbUZTLmdldEJhc2VQYXRoVG9Eb3dubG9hZCgpLnRoZW4oZnVuY3Rpb24oYmFzZVBhdGgpIHtcbiAgICAgICAgICAgIC8vIFVzZSBhIHRtcCBwYXRoIHRvIGRvd25sb2FkIHRoZSBmaWxlIGFuZCB0aGVuIG1vdmUgaXQgdG8gZmluYWwgbG9jYXRpb24uIFRoaXMgaXMgYmVjYXVzZSBpZiB0aGUgZG93bmxvYWQgZmFpbHMsXG4gICAgICAgICAgICAvLyB0aGUgbG9jYWwgZmlsZSBpcyBkZWxldGVkLlxuICAgICAgICAgICAgdmFyIHRtcFBhdGggPSBiYXNlUGF0aCArIHBhdGggKyAnLnRtcCc7XG4gICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlVHJhbnNmZXIuZG93bmxvYWQodXJsLCB0bXBQYXRoLCB7IGVuY29kZVVSSTogZmFsc2UgfSwgdHJ1ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRlMubW92ZUZpbGUocGF0aCArICcudG1wJywgcGF0aCkudGhlbihmdW5jdGlvbihtb3ZlZEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1N1Y2Nlc3MgZG93bmxvYWRpbmcgZmlsZSAnICsgdXJsICsgJyB0byAnICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3ZlZEVudHJ5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgZG93bmxvYWRpbmcgJyArIHVybCArICcgdG8gJyArIHBhdGgpO1xuICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoSlNPTi5zdHJpbmdpZnkoZXJyKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIHVzaW5nIENvcmRvdmEgRmlsZSBBUEkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tV1MjdXBsb2FkRmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1cmkgRmlsZSBVUkkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgRmlsZSBzZXR0aW5nczogZmlsZUtleSwgZmlsZU5hbWUgYW5kIG1pbWVUeXBlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzZXRzIENvbnRhaW5zIHNpdGV1cmwgYW5kIHRva2VuLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi51cGxvYWRGaWxlID0gZnVuY3Rpb24odXJpLCBvcHRpb25zLCBwcmVzZXRzKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ1RyeWluZyB0byB1cGxvYWQgZmlsZTogJyArIHVyaSk7XG5cbiAgICAgICAgdmFyIGZ0T3B0aW9ucyA9IHt9LFxuICAgICAgICAgICAgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIGZ0T3B0aW9ucy5maWxlS2V5ID0gb3B0aW9ucy5maWxlS2V5O1xuICAgICAgICBmdE9wdGlvbnMuZmlsZU5hbWUgPSBvcHRpb25zLmZpbGVOYW1lO1xuICAgICAgICBmdE9wdGlvbnMuaHR0cE1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgZnRPcHRpb25zLm1pbWVUeXBlID0gb3B0aW9ucy5taW1lVHlwZTtcbiAgICAgICAgZnRPcHRpb25zLnBhcmFtcyA9IHtcbiAgICAgICAgICAgIHRva2VuOiBwcmVzZXRzLnRva2VuXG4gICAgICAgIH07XG4gICAgICAgIGZ0T3B0aW9ucy5jaHVua2VkTW9kZSA9IGZhbHNlO1xuICAgICAgICBmdE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgIENvbm5lY3Rpb246IFwiY2xvc2VcIlxuICAgICAgICB9O1xuXG4gICAgICAgICRsb2cuZGVidWcoJ0luaXRpYWxpemluZyB1cGxvYWQnKTtcbiAgICAgICAgJGNvcmRvdmFGaWxlVHJhbnNmZXIudXBsb2FkKHByZXNldHMuc2l0ZXVybCArICcvd2Vic2VydmljZS91cGxvYWQucGhwJywgdXJpLCBmdE9wdGlvbnMsIHRydWUpLnRoZW4oZnVuY3Rpb24oc3VjY2Vzcykge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnU3VjY2Vzc2Z1bGx5IHVwbG9hZGVkIGZpbGUnKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc3VjY2Vzcyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciB3aGlsZSB1cGxvYWRpbmcgZmlsZTogJyArIGVycm9yLmV4Y2VwdGlvbik7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9LCBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHByb2dyZXNzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogUGVyZm9ybSBhIEhFQUQgcmVxdWVzdCB0byBnZXQgdGhlIHNpemUgb2YgYSByZW1vdGUgZmlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1XUyNnZXRSZW1vdGVGaWxlU2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1cmkgRmlsZSBVUkkuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHNpemUgb3IgLTEgaWYgZmFpbHVyZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldFJlbW90ZUZpbGVTaXplID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5oZWFkKHVybCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KGRhdGEuaGVhZGVycygnQ29udGVudC1MZW5ndGgnKSwgMTApO1xuICAgICAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGEgc3luY2hyb25vdXMgTW9vZGxlIFdlYlNlcnZpY2UgY2FsbC5cbiAgICAgKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgc3luY2hyb25vdXMgaXMgYSBtdXN0LiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSAkbW1XUyNjYWxsLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVdTI3N5bmNDYWxsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgV2ViU2VydmljZSBtZXRob2QgdG8gYmUgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZVNldHMgRXh0cmEgc2V0dGluZ3MgYW5kIGluZm9ybWF0aW9uLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIHNpdGV1cmwgc3RyaW5nIFRoZSBzaXRlIFVSTC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSB3c3Rva2VuIHN0cmluZyBUaGUgV2Vic2VydmljZSB0b2tlbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSByZXNwb25zZUV4cGVjdGVkIGJvb2xlYW4gRGVmYXVsdHMgdG8gdHJ1ZS4gU2V0IHRvIGZhbHNlIHdoZW4gdGhlIGV4cGVjdGVkIHJlc3BvbnNlIGlzIG51bGwuXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gdHlwZUV4cGVjdGVkIHN0cmluZyBEZWZhdWx0cyB0byAnb2JqZWN0Jy4gVXNlIGl0IHdoZW4geW91IGV4cGVjdCBhIHR5cGUgdGhhdCdzIG5vdCBhbiBvYmplY3R8YXJyYXkuXG4gICAgICogQHJldHVybiB7TWl4ZWR9IFJlcXVlc3QgcmVzcG9uc2UuIElmIHRoZSByZXF1ZXN0IGZhaWxzLCByZXR1cm5zIGFuIG9iamVjdCB3aXRoICdlcnJvcic9dHJ1ZSBhbmQgJ21lc3NhZ2UnIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgc2VsZi5zeW5jQ2FsbCA9IGZ1bmN0aW9uKG1ldGhvZCwgZGF0YSwgcHJlU2V0cykge1xuICAgICAgICB2YXIgc2l0ZXVybCxcbiAgICAgICAgICAgIHhocixcbiAgICAgICAgICAgIGVycm9yUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZGF0YSA9IGNvbnZlcnRWYWx1ZXNUb1N0cmluZyhkYXRhKTtcblxuICAgICAgICBpZiAodHlwZW9mIHByZVNldHMgPT0gJ3VuZGVmaW5lZCcgfHwgcHJlU2V0cyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBwcmVTZXRzLndzdG9rZW4gPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHByZVNldHMuc2l0ZXVybCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZXJyb3JSZXNwb25zZS5tZXNzYWdlID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLnVuZXhwZWN0ZWRlcnJvcicpO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yUmVzcG9uc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoISRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICBlcnJvclJlc3BvbnNlLm1lc3NhZ2UgPSAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUubmV0d29ya2Vycm9ybXNnJyk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JSZXNwb25zZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZVNldHMudHlwZUV4cGVjdGVkID0gcHJlU2V0cy50eXBlRXhwZWN0ZWQgfHwgJ29iamVjdCc7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlU2V0cy5yZXNwb25zZUV4cGVjdGVkID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwcmVTZXRzLnJlc3BvbnNlRXhwZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS53c2Z1bmN0aW9uID0gbWV0aG9kO1xuICAgICAgICBkYXRhLndzdG9rZW4gPSBwcmVTZXRzLndzdG9rZW47XG4gICAgICAgIHNpdGV1cmwgPSBwcmVTZXRzLnNpdGV1cmwgKyAnL3dlYnNlcnZpY2UvcmVzdC9zZXJ2ZXIucGhwP21vb2RsZXdzcmVzdGZvcm1hdD1qc29uJztcblxuICAgICAgICAvLyBTZXJpYWxpemUgZGF0YS5cbiAgICAgICAgZGF0YSA9ICRtbVV0aWwucGFyYW0oZGF0YSk7XG5cbiAgICAgICAgLy8gUGVyZm9ybSBzeW5jIHJlcXVlc3QgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG4gICAgICAgIHhociA9IG5ldyAkd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdwb3N0Jywgc2l0ZXVybCwgZmFsc2UpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG5cbiAgICAgICAgeGhyLnNlbmQoZGF0YSk7XG5cbiAgICAgICAgLy8gR2V0IHJlc3BvbnNlLlxuICAgICAgICBkYXRhID0gKCdyZXNwb25zZScgaW4geGhyKSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG5cbiAgICAgICAgLy8gQ2hlY2sgc3RhdHVzLlxuICAgICAgICB4aHIuc3RhdHVzID0gTWF0aC5tYXgoeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMsIDApO1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA8IDIwMCB8fCB4aHIuc3RhdHVzID49IDMwMCkge1xuICAgICAgICAgICAgLy8gUmVxdWVzdCBmYWlsZWQuXG4gICAgICAgICAgICBlcnJvclJlc3BvbnNlLm1lc3NhZ2UgPSBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yUmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmVhdCByZXNwb25zZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICB9IGNhdGNoKGV4KSB7fVxuXG4gICAgICAgIC8vIFNvbWUgbW9vZGxlIHdlYiBzZXJ2aWNlcyByZXR1cm4gbnVsbC5cbiAgICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlRXhwZWN0ZWQgdmFsdWUgaXMgc2V0IHRoZW4gc28gbG9uZyBhcyBubyBkYXRhIGlzIHJldHVybmVkLCB3ZSBjcmVhdGUgYSBibGFuayBvYmplY3QuXG4gICAgICAgIGlmICgoIWRhdGEgfHwgIWRhdGEuZGF0YSkgJiYgIXByZVNldHMucmVzcG9uc2VFeHBlY3RlZCkge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBlcnJvclJlc3BvbnNlLm1lc3NhZ2UgPSAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUuc2VydmVyY29ubmVjdGlvbicpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhICE9IHByZVNldHMudHlwZUV4cGVjdGVkKSB7XG4gICAgICAgICAgICAkbG9nLndhcm4oJ1Jlc3BvbnNlIG9mIHR5cGUgXCInICsgdHlwZW9mIGRhdGEgKyAnXCIgcmVjZWl2ZWQsIGV4cGVjdGluZyBcIicgKyBwcmVTZXRzLnR5cGVFeHBlY3RlZCArICdcIicpO1xuICAgICAgICAgICAgZXJyb3JSZXNwb25zZS5tZXNzYWdlID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLmVycm9yaW52YWxpZHJlc3BvbnNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXhjZXB0aW9uICE9ICd1bmRlZmluZWQnIHx8wqB0eXBlb2YgZGF0YS5kZWJ1Z2luZm8gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGVycm9yUmVzcG9uc2UubWVzc2FnZSA9IGRhdGEubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvclJlc3BvbnNlLm1lc3NhZ2UgIT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JSZXNwb25zZTtcbiAgICAgICAgfVxuXG4gICAgICAgICRsb2cuaW5mbygnU3luY2hyb25vdXM6IERhdGEgcmVjZWl2ZWQgZnJvbSBXUyAnICsgdHlwZW9mIGRhdGEpO1xuXG4gICAgICAgIGlmICh0eXBlb2YoZGF0YSkgPT0gJ29iamVjdCcgJiYgdHlwZW9mKGRhdGEubGVuZ3RoKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgJGxvZy5pbmZvKCdTeW5jaHJvbm91czogRGF0YSBudW1iZXIgb2YgZWxlbWVudHMgJysgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRmlsdGVyIHRvIHR1cm4gYSBudW1iZXIgaW4gYnl0ZXMgdG8gYSBodW1hbiByZWFkYWJsZSBzaXplIChlLmcuIDUsMjUgTUIpLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1CeXRlc1RvU2l6ZVxuICovXG4uZmlsdGVyKCdtbUJ5dGVzVG9TaXplJywgZnVuY3Rpb24oJG1tVGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiAkbW1UZXh0LmJ5dGVzVG9TaXplKHRleHQpO1xuICAgIH07XG59KTsiLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIEZpbHRlciB0byBzZWFyY2ggVVJMcyB0aGF0IGFyZSBub3QgaW5zaWRlIDxhPiB0YWdzIGFuZCBhZGQgdGhlIGNvcnJlc3BvbmRpbmcgPGE+IHRhZ3MuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZmlsdGVyXG4gKiBAbmFtZSBtbUNyZWF0ZUxpbmtzXG4gKi9cbi5maWx0ZXIoJ21tQ3JlYXRlTGlua3MnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVwbGFjZVBhdHRlcm4gPSAvKFxcYihodHRwcz98ZnRwKTpcXC9cXC9bLUEtWjAtOSsmQCNcXC8lPz1+X3whOiwuO10qWy1BLVowLTkrJkAjXFwvJT1+X3xdKSg/IVtePF0qPnxbXjw+XSo8XFwvKS9naW07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShyZXBsYWNlUGF0dGVybiwgJzxhIGhyZWY9XCIkMVwiPiQxPC9hPicpO1xuICAgIH07XG5cbn0pOyIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRmlsdGVyIHRvIGRpc3BsYXkgYSBkYXRlIHVzaW5nIHRoZSBkYXksIG9yIHRoZSB0aW1lLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgbW1EYXRlRGF5T3JUaW1lXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgc2hvd3MgYSBzaG9ydCB2ZXJzaW9uIG9mIGEgZGF0ZS4gVXNlIHRoaXMgZmlsdGVyIHdoZW4geW91IHdhbnRcbiAqIHRoZSB1c2VyIHRvIHZpc3VhbGlzZSB3aGVuIHRoZSBhY3Rpb24gd2FzIGRvbmUgcmVsYXRpdmVseSB0byB0b2RheSdzIGRhdGUuXG4gKlxuICogRm9yIGluc3RhbmNlLCBpZiB0aGUgYWN0aW9uIGhhcHBlbmVkIGR1cmluZyB0aGlzIGRheSBpdCB3aWxsIGRpc3BsYXkgdGhlIHRpbWUsXG4gKiBidXQgd2hlbiB0aGUgYWN0aW9uIGhhcHBlbmVkIGZldyBkYXlzIGFnbywgaXQgd2lsbCBkaXNwbGF5IHRoZSBkYXkgb2YgdGhlIHdlZWsuXG4gKlxuICogVGhlIG9sZGVyIHRoZSBkYXRlIGlzLCB0aGUgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBpdCB3aWxsIGJlIGRpc3BsYXllZC5cbiAqXG4gKiBUaGlzIGZpbHRlciBleHBlY3RzIGEgdGltZXN0YW1wIE5PVCBpbmNsdWRpbmcgbWlsbGlzZWNvbmRzLlxuICovXG4uZmlsdGVyKCdtbURhdGVEYXlPclRpbWUnLCBmdW5jdGlvbigkdHJhbnNsYXRlKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQodGltZXN0YW1wICogMTAwMCkuY2FsZW5kYXIobnVsbCwge1xuICAgICAgICAgICAgc2FtZURheTogJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLmRmdGltZWRhdGUnKSxcbiAgICAgICAgICAgIGxhc3REYXk6ICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS5kZmxhc3R3ZWVrZGF0ZScpLFxuICAgICAgICAgICAgbGFzdFdlZWs6ICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS5kZmxhc3R3ZWVrZGF0ZScpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBGaWx0ZXIgdG8gZm9ybWF0IGEgZGF0ZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIG1tRm9ybWF0RGF0ZVxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGZvcm1hdHMgYSB0aW1lc3RhbXAgaW50byBhIGRhdGUuIFBhcmFtZXRlcnM6XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcCBUaW1lc3RhbXAgdG8gZm9ybWF0IChpbiBzZWNvbmRzKS4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHRpbWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0ICAgIEZvcm1hdCB0byB1c2UuIEl0IHNob3VsZCBiZSBhIHN0cmluZyBjb2RlIHRvIGhhbmRsZSBpMThuIChlLmcuIG1tLmNvcmUuZGZ0aW1lZGF0ZSkuIElmIHRoZSBjb2RlIGRvZXNuJ3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZSBhIHByZWZpeCwgJ21tLmNvcmUnIHdpbGwgYmUgdXNlZCBieSBkZWZhdWx0LiBFLmcuICdkZnRpbWVkYXRlJyAtPiAnbW0uY29yZS5kZnRpbWVkYXRlJy5cbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgRm9ybWF0dGVkIGRhdGUuXG4gKi9cbi5maWx0ZXIoJ21tRm9ybWF0RGF0ZScsIGZ1bmN0aW9uKCR0cmFuc2xhdGUpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbih0aW1lc3RhbXAsIGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJy4nKSA9PSAtMSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gJ21tLmNvcmUuJyArIGZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9tZW50KHRpbWVzdGFtcCkuZm9ybWF0KCR0cmFuc2xhdGUuaW5zdGFudChmb3JtYXQpKTtcbiAgICB9O1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRmlsdGVyIHRvIHJlbW92ZSBIVE1MIHRhZ3MuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZmlsdGVyXG4gKiBAbmFtZSBtbU5vVGFnc1xuICovXG4uZmlsdGVyKCdtbU5vVGFncycsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGV4dCkucmVwbGFjZSgvKDwoW14+XSspPikvaWcsICcnKTtcbiAgICB9XG59KTsiLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIEZpbHRlciB0byB0dXJuIGEgVU5JWCB0aW1lc3RhbXAgdG8gXCJ0aW1lIGFnb1wiLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgbW1UaW1lQWdvXG4gKi9cbi5maWx0ZXIoJ21tVGltZUFnbycsIGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgICAgICByZXR1cm4gbW9tZW50KHRpbWVzdGFtcCAqIDEwMDApLmZyb21Ob3codHJ1ZSk7XG4gICAgfTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIEZpbHRlciB0byBmb3JtYXQgYSB0aW1lc3RhbXAgdG8gYSBsb2NhbGUgc3RyaW5nLiBUaW1lc3RhbXAgY2FuIGJlIGluIHNlY29uZHMgb3IgbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgbW1Ub0xvY2FsZVN0cmluZ1xuICovXG4uZmlsdGVyKCdtbVRvTG9jYWxlU3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdmFyIHRpbWVzdGFtcCA9IHBhcnNlSW50KHRleHQpO1xuXG4gICAgICAgIGlmIChpc05hTih0aW1lc3RhbXApIHx8IHRpbWVzdGFtcCA8IDApIHtcbiAgICAgICAgICAgIC8vIERhdGUgbm90IHZhbGlkLlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lc3RhbXAgPCAxMDAwMDAwMDAwMDApIHtcbiAgICAgICAgICAgIC8vIFRpbWVzdGFtcCBpcyBpbiBzZWNvbmRzLCBjb252ZXJ0IGl0IHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcCAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBhdXRvIGZvY3VzIGFuIGVsZW1lbnQgd2hlbiBhIHZpZXcgaXMgbG9hZGVkLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1BdXRvRm9jdXNcbiAqL1xuLmRpcmVjdGl2ZSgnbW1BdXRvRm9jdXMnLCBmdW5jdGlvbigkbW1BcHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWwpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRyYW5zaXRpb24gdG8gZmluaXNoIGJlZm9yZSBhdXRvLWZvY3VzLlxuICAgICAgICAgICAgdmFyIHVucmVnaXN0ZXIgPSBzY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlvbmljLnRyYW5zaXRpb24uaXNBY3RpdmU7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihpc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlcigpOyAvLyBTdG9wIHdhdGNoaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9uIHNvbWUgQW5kcm9pZCB2ZXJzaW9ucyB0aGUga2V5Ym9hcmQgZG9lc24ndCBvcGVuIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1BcHAub3BlbktleWJvYXJkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIG9wZW4gYSBsaW5rIGluIGV4dGVybmFsIGJyb3dzZXIuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbUJyb3dzZXJcbiAqL1xuLmRpcmVjdGl2ZSgnbW1Ccm93c2VyJywgZnVuY3Rpb24oJG1tVXRpbCwgJG1tQ29udGVudExpbmtzSGVscGVyKSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICBwcmlvcml0eTogMTAwLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IGVsZW1lbnRbMF0uZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgJG1tQ29udGVudExpbmtzSGVscGVyLmhhbmRsZUxpbmsoaHJlZikudGhlbihmdW5jdGlvbih0cmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChocmVmLmluZGV4T2YoJ2NkdmZpbGU6Ly8nKSA9PT0gMCB8fCBocmVmLmluZGV4T2YoJ2ZpbGU6Ly8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgbG9jYWwgZmlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5vcGVuRmlsZShocmVmKS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgYW4gZXh0ZXJuYWwgbGluaywgd2Ugd2lsbCBvcGVuIHdpdGggYnJvd3Nlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5vcGVuSW5Ccm93c2VyKGhyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBoYW5kbGUgYWN0aXZpdHkgY29tcGxldGlvbi4gSXQgY2FuIGJlIGFkYXB0ZWQgdG8gaGFuZGxlIGNvdXJzZSBjb21wbGV0aW9uIG9uY2UgaXQncyBpbXBsZW1lbnRlZC5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tQ29tcGxldGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGRpcmVjdGl2ZSB3aWxsIHNob3cgYSBjaGVja2JveCB0byBzaG93IGNvbXBsZXRpb24gc3RhdHVzIGFuZCB0byBhbGxvdyBtYW51YWxseSBjaGFuZ2luZyB0aGUgY29tcGxldGlvbiBpZiBpdCdzIGFsbG93ZWQuXG4gKiBBdHRyaWJ1dGVzOlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wbGV0aW9uICAgIENvbXBsZXRpb24gc3RhdHVzIG9mIHRoZSBhY3Rpdml0eS4gUmVxdWlyZWQgcHJvcGVydGllczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGNtaWQ6IE1vZHVsZSBJRC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHN0YXRlOiBDdXJyZW50IGNvbXBsZXRpb24gc3RhdGU6IDAgaW5jb21wbGV0ZSwgMSBjb21wbGV0ZSwgMiBjb21wbGV0ZSBwYXNzLCAzIGNvbXBsZXRlIGZhaWwuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB0cmFja2luZzogMCBtZWFucyBub25lLCAxIG1hbnVhbCwgMiBhdXRvbWF0aWMuXG4gKiBAcGFyYW0ge1N0cmluZ30gYWZ0ZXItY2hhbmdlICBOYW1lIG9mIGEgc2NvcGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGNvbXBsZXRpb24gY2hhbmdlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGUtbmFtZSAgIE5hbWUgb2YgdGhlIG1vZHVsZSB0aGlzIGNvbXBsZXRpb24gcmVmZXJzIHRvLlxuICovXG4uZGlyZWN0aXZlKCdtbUNvbXBsZXRpb24nLCBmdW5jdGlvbigkbW1TaXRlLCAkbW1VdGlsLCAkbW1UZXh0LCAkdHJhbnNsYXRlLCAkcSkge1xuXG4gICAgLy8gU2V0IGltYWdlIGFuZCBkZXNjcmlwdGlvbiB0byBzaG93IGFzIGNvbXBsZXRpb24gaWNvbi5cbiAgICBmdW5jdGlvbiBzaG93U3RhdHVzKHNjb3BlKSB7XG4gICAgICAgIHZhciBsYW5nS2V5LFxuICAgICAgICAgICAgbW9kdWxlTmFtZSA9IHNjb3BlLm1vZHVsZU5hbWUgfHwgJyc7XG5cbiAgICAgICAgaWYgKHNjb3BlLmNvbXBsZXRpb24udHJhY2tpbmcgPT09IDEgJiYgc2NvcGUuY29tcGxldGlvbi5zdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgc2NvcGUuY29tcGxldGlvbkltYWdlID0gJ2ltZy9jb21wbGV0aW9uL2NvbXBsZXRpb24tbWFudWFsLW4uc3ZnJztcbiAgICAgICAgICAgIGxhbmdLZXkgPSAnbW0uY29yZS5jb21wbGV0aW9uLWFsdC1tYW51YWwtbic7XG4gICAgICAgIH0gZWxzZSBpZihzY29wZS5jb21wbGV0aW9uLnRyYWNraW5nID09PSAxICYmIHNjb3BlLmNvbXBsZXRpb24uc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgIHNjb3BlLmNvbXBsZXRpb25JbWFnZSA9ICdpbWcvY29tcGxldGlvbi9jb21wbGV0aW9uLW1hbnVhbC15LnN2Zyc7XG4gICAgICAgICAgICBsYW5nS2V5ID0gJ21tLmNvcmUuY29tcGxldGlvbi1hbHQtbWFudWFsLXknO1xuICAgICAgICB9IGVsc2UgaWYoc2NvcGUuY29tcGxldGlvbi50cmFja2luZyA9PT0gMiAmJiBzY29wZS5jb21wbGV0aW9uLnN0YXRlID09PSAwKSB7XG4gICAgICAgICAgICBzY29wZS5jb21wbGV0aW9uSW1hZ2UgPSAnaW1nL2NvbXBsZXRpb24vY29tcGxldGlvbi1hdXRvLW4uc3ZnJztcbiAgICAgICAgICAgIGxhbmdLZXkgPSAnbW0uY29yZS5jb21wbGV0aW9uLWFsdC1hdXRvLW4nO1xuICAgICAgICB9IGVsc2UgaWYoc2NvcGUuY29tcGxldGlvbi50cmFja2luZyA9PT0gMiAmJiBzY29wZS5jb21wbGV0aW9uLnN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICBzY29wZS5jb21wbGV0aW9uSW1hZ2UgPSAnaW1nL2NvbXBsZXRpb24vY29tcGxldGlvbi1hdXRvLXkuc3ZnJztcbiAgICAgICAgICAgIGxhbmdLZXkgPSAnbW0uY29yZS5jb21wbGV0aW9uLWFsdC1hdXRvLXknO1xuICAgICAgICB9IGVsc2UgaWYoc2NvcGUuY29tcGxldGlvbi50cmFja2luZyA9PT0gMiAmJiBzY29wZS5jb21wbGV0aW9uLnN0YXRlID09PSAyKSB7XG4gICAgICAgICAgICBzY29wZS5jb21wbGV0aW9uSW1hZ2UgPSAnaW1nL2NvbXBsZXRpb24vY29tcGxldGlvbi1hdXRvLXBhc3Muc3ZnJztcbiAgICAgICAgICAgIGxhbmdLZXkgPSAnbW0uY29yZS5jb21wbGV0aW9uLWFsdC1hdXRvLXBhc3MnO1xuICAgICAgICB9IGVsc2UgaWYoc2NvcGUuY29tcGxldGlvbi50cmFja2luZyA9PT0gMiAmJiBzY29wZS5jb21wbGV0aW9uLnN0YXRlID09PSAzKSB7XG4gICAgICAgICAgICBzY29wZS5jb21wbGV0aW9uSW1hZ2UgPSAnaW1nL2NvbXBsZXRpb24vY29tcGxldGlvbi1hdXRvLWZhaWwuc3ZnJztcbiAgICAgICAgICAgIGxhbmdLZXkgPSAnbW0uY29yZS5jb21wbGV0aW9uLWFsdC1hdXRvLWZhaWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgICAgICRtbVRleHQuZm9ybWF0VGV4dChtb2R1bGVOYW1lLCB0cnVlLCB0cnVlLCA1MCkudGhlbihmdW5jdGlvbihmb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgICAgICAkdHJhbnNsYXRlKGxhbmdLZXksIHskYTogZm9ybWF0dGVkfSkudGhlbihmdW5jdGlvbih0cmFuc2xhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmNvbXBsZXRpb25EZXNjcmlwdGlvbiA9IHRyYW5zbGF0ZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgIHByaW9yaXR5OiAxMDAsXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICBjb21wbGV0aW9uOiAnPScsXG4gICAgICAgICAgICBhZnRlckNoYW5nZTogJz0nLFxuICAgICAgICAgICAgbW9kdWxlTmFtZTogJz0/J1xuICAgICAgICB9LFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvdGVtcGxhdGVzL2NvbXBsZXRpb24uaHRtbCcsXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgaWYgKHNjb3BlLmNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgICBzaG93U3RhdHVzKHNjb3BlKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjb3BlLmNvbXBsZXRpb24uY21pZCA9PSAndW5kZWZpbmVkJyB8fCBzY29wZS5jb21wbGV0aW9uLnRyYWNraW5nICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtaWQ6IHNjb3BlLmNvbXBsZXRpb24uY21pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6IHNjb3BlLmNvbXBsZXRpb24uc3RhdGUgPT09IDEgPyAwIDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAkbW1TaXRlLndyaXRlKCdjb3JlX2NvbXBsZXRpb25fdXBkYXRlX2FjdGl2aXR5X2NvbXBsZXRpb25fc3RhdHVzX21hbnVhbGx5JywgcGFyYW1zKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzY29wZS5hZnRlckNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3JjaGFuZ2Vjb21wbGV0aW9uJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gaGFuZGxlIGV4dGVybmFsIGNvbnRlbnQuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbUV4dGVybmFsQ29udGVudFxuICogQGRlc2NyaXB0aW9uXG4gKiBEaXJlY3RpdmUgdG8gaGFuZGxlIGV4dGVybmFsIGNvbnRlbnQuXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgc2hvdWxkIGJlIHVzZWQgd2l0aCBhbnkgZWxlbWVudCB0aGF0IGxpbmtzIHRvIGV4dGVybmFsIGNvbnRlbnRcbiAqIHdoaWNoIHdlIHdhbnQgdG8gaGF2ZSBhdmFpbGFibGUgd2hlbiB0aGUgYXBwIGlzIG9mZmxpbmUuIFR5cGljYWxseSBpbWFnZXMgYW5kIGxpbmtzLlxuICpcbiAqIEl0IHVzZXMge0BsaW5rICRtbUZpbGVwb29sfSBpbiB0aGUgYmFja2dyb3VuZC5cbiAqXG4gKiBBdHRyaWJ1dGVzIGFjY2VwdGVkOlxuICogICAgIC0gc2l0ZWlkOiBSZWZlcmVuY2UgdG8gdGhlIHNpdGUgSUQgaWYgZGlmZmVyZW50IHRoYW4gdGhlIHNpdGUgdGhlIHVzZXIgaXMgY29ubmVjdGVkIHRvLlxuICovXG4uZGlyZWN0aXZlKCdtbUV4dGVybmFsQ29udGVudCcsIGZ1bmN0aW9uKCRsb2csICRtbUZpbGVwb29sLCAkbW1TaXRlLCAkbW1TaXRlc01hbmFnZXIsICRtbVV0aWwpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1FeHRlcm5hbENvbnRlbnQnKTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUV4dGVybmFsQ29udGVudChzaXRlSWQsIGRvbSwgdGFyZ2V0QXR0ciwgdXJsLCBjb21wb25lbnQsIGNvbXBvbmVudElkKSB7XG5cbiAgICAgICAgaWYgKCF1cmwgfHwgISRtbVV0aWwuaXNEb3dubG9hZGFibGVVcmwodXJsKSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnSWdub3Jpbmcgbm9uLWRvd25sb2FkYWJsZSBVUkw6ICcgKyB1cmwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSB3ZWJzZXJ2aWNlIHBsdWdpbmZpbGUgVVJMLCB3ZSBpZ25vcmUgZmFpbHVyZXMgaGVyZS5cbiAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIGlmICghc2l0ZS5jYW5Eb3dubG9hZEZpbGVzKCkgJiYgJG1tVXRpbC5pc1BsdWdpbkZpbGVVcmwodXJsKSkge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmUoKTsgLy8gUmVtb3ZlIGVsZW1lbnQgc2luY2UgaXQnbGwgYmUgYnJva2VuLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZuO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0QXR0ciA9PT0gJ3NyYycpIHtcbiAgICAgICAgICAgICAgICBmbiA9ICRtbUZpbGVwb29sLmdldFNyY0J5VXJsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbiA9ICRtbUZpbGVwb29sLmdldFVybEJ5VXJsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbihzaXRlSWQsIHVybCwgY29tcG9uZW50LCBjb21wb25lbnRJZCkudGhlbihmdW5jdGlvbihmaW5hbFVybCkge1xuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1VzaW5nIFVSTCAnICsgZmluYWxVcmwgKyAnIGZvciAnICsgdXJsKTtcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKHRhcmdldEF0dHIsIGZpbmFsVXJsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgc2l0ZWlkOiAnPSdcbiAgICAgICAgfSxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gZWxlbWVudFswXSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBhdHRycy5jb21wb25lbnQsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50SWQgPSBhdHRycy5jb21wb25lbnRJZCxcbiAgICAgICAgICAgICAgICB0YXJnZXRBdHRyLFxuICAgICAgICAgICAgICAgIG9ic2VydmUgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB1cmw7XG5cbiAgICAgICAgICAgIGlmIChkb20udGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0QXR0ciA9ICdocmVmJztcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoJ25nSHJlZicpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChkb20udGFnTmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRBdHRyID0gJ3NyYyc7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KCduZ1NyYycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBVbnN1cHBvcnRlZCB0YWcuXG4gICAgICAgICAgICAgICAgJGxvZy53YXJuKCdEaXJlY3RpdmUgYXR0YWNoZWQgdG8gbm9uLXN1cHBvcnRlZCB0YWc6ICcgKyBkb20udGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2JzZXJ2ZSkge1xuICAgICAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKHRhcmdldEF0dHIsIGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUV4dGVybmFsQ29udGVudChzY29wZS5zaXRlaWQgfHwgJG1tU2l0ZS5nZXRJZCgpLCBkb20sIHRhcmdldEF0dHIsIHVybCwgY29tcG9uZW50LCBjb21wb25lbnRJZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZUV4dGVybmFsQ29udGVudChzY29wZS5zaXRlaWQgfHwgJG1tU2l0ZS5nZXRJZCgpLCBkb20sIHRhcmdldEF0dHIsIGF0dHJzW3RhcmdldEF0dHJdLCBjb21wb25lbnQsIGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gaGFuZGxlIGEgZmlsZSAobXkgZmlsZXMsIGF0dGFjaG1lbnRzLCBldGMuKS4gVGhlIGZpbGUgaXMgbm90IGRvd25sb2FkZWQgYXV0b21hdGljYWxseS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tRmlsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBEaXJlY3RpdmUgdG8gaGFuZGxlIGZpbGVzIChteSBmaWxlcywgYXR0YWNobWVudHMsIGV0Yy4pLiBTaG93cyB0aGUgZmlsZSBuYW1lLCBpY29uIChkZXBlbmRpbmcgb24gbWltZXR5cGUpIGFuZCBhIGJ1dHRvblxuICogdG8gZG93bmxvYWQvcmVmcmVzaCBpdC5cbiAqXG4gKiBBdHRyaWJ1dGVzOlxuICogQHBhcmFtIHtPYmplY3R9IGZpbGUgICAgICAgICAgICBSZXF1aXJlZC4gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGVuYW1lJzogTmFtZSBvZiB0aGUgZmlsZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmaWxldXJsJyBvciAndXJsJzogRmlsZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbXBvbmVudF0gICAgIENvbXBvbmVudCB0aGUgZmlsZSBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb25lbnRJZF0gICBDb21wb25lbnQgSUQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt0aW1lbW9kaWZpZWRdIElmIHNldCwgdGhlIHZhbHVlIHdpbGwgYmUgdXNlZCB0byBjaGVjayBpZiB0aGUgZmlsZSBpcyBvdXRkYXRlZC5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1GaWxlJywgZnVuY3Rpb24oJHEsICRtbVV0aWwsICRtbUZpbGVwb29sLCAkbW1TaXRlLCAkbW1BcHAsICRtbUV2ZW50cywgJG1tRlMsIG1tQ29yZURvd25sb2FkZWQsIG1tQ29yZURvd25sb2FkaW5nLFxuICAgICAgICAgICAgbW1Db3JlTm90RG93bmxvYWRlZCwgbW1Db3JlT3V0ZGF0ZWQpIHtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCB0aGUgZmlsZSBzdGF0ZSBhbmQgc2V0IHNjb3BlIHZhcmlhYmxlcyBiYXNlZCBvbiBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2NvcGUgICAgICAgICAgRGlyZWN0aXZlJ3Mgc2NvcGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlaWQgICAgICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZXVybCAgICAgICAgRmlsZSBVUkwuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbdGltZW1vZGlmaWVkXSBGaWxlJ3MgdGltZW1vZGlmaWVkLlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U3RhdGUoc2NvcGUsIHNpdGVpZCwgZmlsZXVybCwgdGltZW1vZGlmaWVkKSB7XG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXRGaWxlU3RhdGVCeVVybChzaXRlaWQsIGZpbGV1cmwsIHRpbWVtb2RpZmllZCkudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIGNhbkRvd25sb2FkID0gJG1tU2l0ZS5jYW5Eb3dubG9hZEZpbGVzKCk7XG4gICAgICAgICAgICBzY29wZS5pc0Rvd25sb2FkZWQgPSBzdGF0ZSA9PT0gbW1Db3JlRG93bmxvYWRlZCB8fMKgc3RhdGUgPT09IG1tQ29yZU91dGRhdGVkO1xuICAgICAgICAgICAgc2NvcGUuaXNEb3dubG9hZGluZyA9IGNhbkRvd25sb2FkICYmIHN0YXRlID09PSBtbUNvcmVEb3dubG9hZGluZztcbiAgICAgICAgICAgIHNjb3BlLnNob3dEb3dubG9hZCA9IGNhbkRvd25sb2FkICYmIChzdGF0ZSA9PT0gbW1Db3JlTm90RG93bmxvYWRlZCB8fMKgc3RhdGUgPT09IG1tQ29yZU91dGRhdGVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZG93bmxvYWQgYSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29wZSAgICAgICAgICBEaXJlY3RpdmUncyBzY29wZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVpZCAgICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBmaWxldXJsICAgICAgICBGaWxlIFVSTC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNvbXBvbmVudCAgICAgIENvbXBvbmVudCB0aGUgZmlsZSBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY29tcG9uZW50aWQgICAgQ29tcG9uZW50IElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW3RpbWVtb2RpZmllZF0gRmlsZSdzIHRpbWVtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBmaWxlIGlzIGRvd25sb2FkZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG93bmxvYWRGaWxlKHNjb3BlLCBzaXRlaWQsIGZpbGV1cmwsIGNvbXBvbmVudCwgY29tcG9uZW50aWQsIHRpbWVtb2RpZmllZCkge1xuICAgICAgICBpZiAoISRtbVNpdGUuY2FuRG93bmxvYWRGaWxlcygpKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3JlLmNhbm5vdGRvd25sb2FkZmlsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZG93bmxvYWRVcmwoc2l0ZWlkLCBmaWxldXJsLCB0cnVlLCBjb21wb25lbnQsIGNvbXBvbmVudGlkLCB0aW1lbW9kaWZpZWQpLnRoZW4oZnVuY3Rpb24obG9jYWxVcmwpIHtcbiAgICAgICAgICAgIGdldFN0YXRlKHNjb3BlLCBzaXRlaWQsIGZpbGV1cmwsIHRpbWVtb2RpZmllZCk7IC8vIFVwZGF0ZSBzdGF0ZS5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbFVybDtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RhdGUoc2NvcGUsIHNpdGVpZCwgZmlsZXVybCwgdGltZW1vZGlmaWVkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzY29wZS5pc0Rvd25sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsVXJsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL3RlbXBsYXRlcy9maWxlLmh0bWwnLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgZmlsZTogJz0nXG4gICAgICAgIH0sXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgdmFyIGZpbGV1cmwgPSBzY29wZS5maWxlLmZpbGV1cmwgfHzCoHNjb3BlLmZpbGUudXJsLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gc2NvcGUuZmlsZS5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICB0aW1lbW9kaWZpZWQgPSBhdHRycy50aW1lbW9kaWZpZWQgfHwgMCxcbiAgICAgICAgICAgICAgICBzaXRlaWQgPSAkbW1TaXRlLmdldElkKCksXG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gYXR0cnMuY29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudGlkID0gYXR0cnMuY29tcG9uZW50SWQsXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXI7XG5cbiAgICAgICAgICAgIHNjb3BlLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgICAgICBzY29wZS5maWxlaWNvbiA9ICRtbUZTLmdldEZpbGVJY29uKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIGdldFN0YXRlKHNjb3BlLCBzaXRlaWQsIGZpbGV1cmwsIHRpbWVtb2RpZmllZCk7XG5cbiAgICAgICAgICAgICRtbUZpbGVwb29sLmdldEZpbGVFdmVudE5hbWVCeVVybChzaXRlaWQsIGZpbGV1cmwpLnRoZW4oZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIgPSAkbW1FdmVudHMub24oZXZlbnROYW1lLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFN0YXRlKHNjb3BlLCBzaXRlaWQsIGZpbGV1cmwsIHRpbWVtb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3JlLmVycm9yZG93bmxvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNjb3BlLmRvd25sb2FkID0gZnVuY3Rpb24oZSwgb3BlbkFmdGVyRG93bmxvYWQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5pc0Rvd25sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoISRtbUFwcC5pc09ubGluZSgpICYmICghb3BlbkFmdGVyRG93bmxvYWQgfHwgKG9wZW5BZnRlckRvd25sb2FkICYmICFzY29wZS5pc0Rvd25sb2FkZWQpKSkge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3JlLm5ldHdvcmtlcnJvcm1zZycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wZW5BZnRlckRvd25sb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbGUgbmVlZHMgdG8gYmUgb3BlbmVkIG5vdy4gSWYgZmlsZSBuZWVkcyB0byBiZSBkb3dubG9hZGVkLCBza2lwIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRGaWxlKHNjb3BlLCBzaXRlaWQsIGZpbGV1cmwsIGNvbXBvbmVudCwgY29tcG9uZW50aWQsIHRpbWVtb2RpZmllZCkudGhlbihmdW5jdGlvbihsb2NhbFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5vcGVuRmlsZShsb2NhbFVybCkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIGRvZXNuJ3QgbmVlZCB0byBiZSBvcGVuZWQsIGFkZCBpdCB0byBxdWV1ZS5cbiAgICAgICAgICAgICAgICAgICAgJG1tRmlsZXBvb2wuaW52YWxpZGF0ZUZpbGVCeVVybChzaXRlaWQsIGZpbGV1cmwpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5pc0Rvd25sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbUZpbGVwb29sLmFkZFRvUXVldWVCeVVybChzaXRlaWQsIGZpbGV1cmwsIGNvbXBvbmVudCwgY29tcG9uZW50aWQsIHRpbWVtb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlciAmJiBvYnNlcnZlci5vZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBmb3JtYXQgdGV4dCByZW5kZXJlZC5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tRm9ybWF0VGV4dFxuICogQGRlc2NyaXB0aW9uXG4gKiBEaXJlY3RpdmUgdG8gZm9ybWF0IHRleHQgcmVuZGVyZWQuIEF0dHJpYnV0ZXMgaXQgYWNjZXB0czpcbiAqICAgICAtc2l0ZWlkOiBTaXRlIElEIHRvIHVzZS5cbiAqICAgICAtY29tcG9uZW50OiBUaGUgY29tcG9uZW50IGZvciBtbUV4dGVybmFsQ29udGVudFxuICogICAgIC1jb21wb25lbnQtaWQ6IFRoZSBjb21wb25lbnQgSUQgZm9yIG1tRXh0ZXJuYWxDb250ZW50XG4gKiAgICAgLWFmdGVyLXJlbmRlcjogU2NvcGUgZnVuY3Rpb24gdG8gY2FsbCBvbmNlIHRoZSBjb250ZW50IGlzIHJlbmRlcmVyZWQuIFBhc3NlcyB0aGUgY3VycmVudCBzY29wZSBhcyBhcmd1bWVudC5cbiAqICAgICAtY2xlYW46IFRydWUgaWYgYWxsIEhUTUwgdGFncyBzaG91bGQgYmUgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogICAgIC1zaW5nbGVsaW5lOiBUcnVlIGlmIG5ldyBsaW5lcyBzaG91bGQgYmUgcmVtb3ZlZCAoYWxsIHRoZSB0ZXh0IGluIGEgc2luZ2xlIGxpbmUpLiBPbmx5IHZhbGlkIGlmIGNsZWFuIGlzIHRydWUuXG4gKiAgICAgLXNob3J0ZW46IFRvIHNob3J0ZW4gdGhlIHRleHQuIElmIGEgbnVtYmVyIGlzIHN1cHBsaWVkLCBpdCB3aWxsIHNob3J0ZW4gdGhlIHRleHQgdG8gdGhhdCBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAqICAgICAgICAgICAgICAgSWYgYSBwZXJjZW50YWdlIGlzIHN1cHBsaWVkIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBzaG9ydCB3aWxsIGJlIHRoZSBwZXJjZW50YWdlIG9mIGVsZW1lbnQncyB3aWR0aC5cbiAqICAgICAgICAgICAgICAgRS5nLiA1MCUgb2YgYW4gZWxlbWVudCB3aXRoIDEwMDBweCB3aWR0aCA9IDUwMCBjaGFyYWN0ZXJzLlxuICogICAgICAgICAgICAgICBJZiB0aGUgZWxlbWVudCBoYXMgbm8gd2lkdGggaXQnbGwgdXNlIDEwMCBjaGFyYWN0ZXJzLiBJZiB0aGUgYXR0cmlidXRlIGlzIGVtcHR5IGl0J2xsIHVzZSAzMCUgd2lkdGguXG4gKiAgICAgLWV4cGFuZC1vbi1jbGljazogSW5kaWNhdGUgaWYgY29udGVudHMgc2hvdWxkIGJlIGV4cGFuZGVkIG9uIGNsaWNrICh1bmRvIHNob3J0ZW4pLiBPbmx5IGFwcGxpZWQgaWYgXCJzaG9ydGVuXCIgaXMgc2V0LlxuICogICAgIC1mdWxsdmlldy1vbi1jbGljazogSW5kaWNhdGUgaWYgc2hvdWxkIG9wZW4gYSBuZXcgc3RhdGUgd2l0aCB0aGUgZnVsbCBjb250ZW50cyBvbiBjbGljay4gT25seSBhcHBsaWVkIGlmIFwic2hvcnRlblwiIGlzIHNldC5cbiAqICAgICAtd2F0Y2g6IFRydWUgaWYgdGhlIHZhcmlhYmxlIHVzZWQgaW5zaWRlIHRoZSBkaXJlY3RpdmUgc2hvdWxkIGJlIHdhdGNoZWQgZm9yIGNoYW5nZXMuIElmIHRoZSB2YXJpYWJsZSBkYXRhIGlzIHJldHJpZXZlZFxuICogICAgICAgICAgICAgYXN5bmNocm9ub3VzbHksIHRoaXMgdmFsdWUgbXVzdCBiZSBzZXQgdG8gdHJ1ZSwgb3IgdGhlIGRpcmVjdGl2ZSBzaG91bGQgYmUgaW5zaWRlIGEgbmctaWYsIG5nLXJlcGVhdCBvciBzaW1pbGFyLlxuICovXG4uZGlyZWN0aXZlKCdtbUZvcm1hdFRleHQnLCBmdW5jdGlvbigkaW50ZXJwb2xhdGUsICRtbVRleHQsICRjb21waWxlLCAkdHJhbnNsYXRlLCAkc3RhdGUpIHtcblxuICAgIHZhciBleHRyYWN0VmFyaWFibGVSZWdleCA9IG5ldyBSZWdFeHAoJ3t7KFtefF0rKSh8LiopP319JywgJ2knKSxcbiAgICAgICAgdGFnc1RvSWdub3JlID0gWydBVURJTycsICdWSURFTycsICdCVVRUT04nLCAnSU5QVVQnLCAnU0VMRUNUJywgJ1RFWFRBUkVBJywgJ0EnXTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHNob3J0ZW4gdGhlIHRleHQuIElmIHRoZSB0ZXh0IHNob3VsZG4ndCBiZSBzaG9ydGVuZWQsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBlbGVtZW50ICAgRGlyZWN0aXZlIHJvb3QgRE9NIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2hvcnRlbl0gU2hvcnRlbiBhdHRyaWJ1dGUuIENhbiBiZSB1bmRlZmluZWQgb3IgYSBzdHJpbmc6IGVtcHR5LCBudW1iZXIgb3IgYSBwZXJjZW50YWdlLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHNob3J0ZW4gdGhlIHRleHQgdG8uIFVuZGVmaW5lZCBpZiBpdCBzaG91bGRuJ3Qgc2hvcnRlbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVTaG9ydGVuKGVsZW1lbnQsIHNob3J0ZW4pIHtcbiAgICAgICAgdmFyIG11bHRpcGxpZXI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzaG9ydGVuID09ICdzdHJpbmcnICYmIHNob3J0ZW4uaW5kZXhPZignJScpID4gLTEpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgYSBwZXJjZW50YWdlLiBFeHRyYWN0IHRoZSBtdWx0aXBsaWVyLlxuICAgICAgICAgICAgbXVsdGlwbGllciA9IHBhcnNlSW50KHNob3J0ZW4ucmVwbGFjZSgvJS9nLCAnJykudHJpbSgpKSAvIDEwMDtcbiAgICAgICAgICAgIGlmIChpc05hTihtdWx0aXBsaWVyKSkge1xuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgPSAwLjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNob3J0ZW4gIT0gJ3VuZGVmaW5lZCcgJiYgc2hvcnRlbiA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIE5vdCBkZWZpbmVkLCB1c2UgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSAwLjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQoc2hvcnRlbik7XG4gICAgICAgICAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gUmV0dXJuIHVuZGVmaW5lZCBzbyBpdCdzIG5vdCBzaG9ydGVuZWQuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWwgPSBlbGVtZW50WzBdLFxuICAgICAgICAgICAgZWxXaWR0aCA9IGVsLm9mZnNldFdpZHRoIHx8wqBlbC53aWR0aCB8fMKgZWwuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmICghZWxXaWR0aCkge1xuICAgICAgICAgICAgLy8gQ2Fubm90IGNhbGN1bGF0ZSBlbGVtZW50J3Mgd2lkdGgsIHVzZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgcmV0dXJuIDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGVsV2lkdGggKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBjb250ZW50cyBhbmQgcmVuZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29wZSAgIERpcmVjdGl2ZSBzY29wZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGVsZW1lbnQgRGlyZWN0aXZlIHJvb3QgRE9NIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBhdHRycyAgIERpcmVjdGl2ZSBhdHRyaWJ1dGVzLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dCAgICBEaXJlY3RpdmUgY29udGVudHMuXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXRBbmRSZW5kZXJDb250ZW50cyhzY29wZSwgZWxlbWVudCwgYXR0cnMsIHRleHQpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2hpZGUnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJzLnNob3J0ZW4gPSBjYWxjdWxhdGVTaG9ydGVuKGVsZW1lbnQsIGF0dHJzLnNob3J0ZW4pO1xuXG4gICAgICAgIC8vIElmIGV4cGFuZE9uQ2xpY2sgb3IgZnVsbHZpZXdPbkNsaWNrIGFyZSBzZXQgd2Ugd29uJ3Qgc2hvcnRlbiB0aGUgdGV4dCBvbiBmb3JtYXRDb250ZW50cywgd2UnbGwgZG8gaXQgbGF0ZXIuXG4gICAgICAgIHZhciBzaG9ydGVuID0gKGF0dHJzLmV4cGFuZE9uQ2xpY2sgfHwgYXR0cnMuZnVsbHZpZXdPbkNsaWNrKSA/IDAgOiBhdHRycy5zaG9ydGVuO1xuXG4gICAgICAgIHRleHQgPSAkaW50ZXJwb2xhdGUodGV4dCkoc2NvcGUpOyAvLyBcIkV2YWx1YXRlXCIgc2NvcGUgdmFyaWFibGVzLlxuICAgICAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG5cbiAgICAgICAgZm9ybWF0Q29udGVudHMoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCB0ZXh0LCBzaG9ydGVuKS50aGVuKGZ1bmN0aW9uKGZ1bGxUZXh0KSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMuc2hvcnRlbiAmJiAoYXR0cnMuZXhwYW5kT25DbGljayB8fCBhdHRycy5mdWxsdmlld09uQ2xpY2spKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNob3J0ZW5lZCA9ICRtbVRleHQuc2hvcnRlblRleHQoJG1tVGV4dC5jbGVhblRhZ3MoZnVsbFRleHQsIGZhbHNlKSwgcGFyc2VJbnQoYXR0cnMuc2hvcnRlbikpLFxuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNob3J0ZW5lZC50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb250ZW50IGNvdWxkIGhhdmUgaW1hZ2VzIG9yIG1lZGlhIHRoYXQgd2VyZSByZW1vdmVkIHdpdGggc2hvcnRlblRleHQuIENoZWNrIGlmIHRoYXQncyB0aGUgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lYW5pbmdmdWxUYWdzID0gWydpbWcnLCAndmlkZW8nLCAnYXVkaW8nXTtcblxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobWVhbmluZ2Z1bFRhZ3MsIGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGxUZXh0LmluZGV4T2YoJzwnK3RhZykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbnRlbnQgaGFzIG1lYW5pbmdmdWwgdGFncy4gU2hvdyBhIHBsYWNlaG9sZGVyIHRvIGV4cGFuZCB0aGUgY29udGVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0ZW5lZCA9ICR0cmFuc2xhdGUuaW5zdGFudChhdHRycy5leHBhbmRPbkNsaWNrID8gJ21tLmNvcmUuY2xpY2t0b2hpZGVzaG93JyA6ICdtbS5jb3JlLmNsaWNrdG9zZWVmdWxsJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdzVG9JZ25vcmUuaW5kZXhPZih0YXJnZXQudGFnTmFtZSkgPT09IC0xIHx8ICh0YXJnZXQudGFnTmFtZSA9PT0gJ0EnICYmICF0YXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMuZXhwYW5kT25DbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZC9jb2xsYXBzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA9ICFleHBhbmRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmh0bWwoIGV4cGFuZGVkID8gZnVsbFRleHQgOiBzaG9ydGVuZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY29tcGlsZShlbGVtZW50LmNvbnRlbnRzKCkpKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZW4gYSBuZXcgc3RhdGUgd2l0aCB0aGUgaW50ZXJwb2xhdGVkIGNvbnRlbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tbV90ZXh0dmlld2VyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLmRlc2NyaXB0aW9uJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dChzY29wZSwgZWxlbWVudCwgc2hvcnRlbmVkLCBhdHRycy5hZnRlclJlbmRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRlclRleHQoc2NvcGUsIGVsZW1lbnQsIGZ1bGxUZXh0LCBhdHRycy5hZnRlclJlbmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGZvcm1hdFRleHQgYW5kIHNldCBzdWItZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2NvcGUgICAgIERpcmVjdGl2ZSBzY29wZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGVsZW1lbnQgICBEaXJlY3RpdmUgcm9vdCBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJzICAgICBEaXJlY3RpdmUgYXR0cmlidXRlcy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgICAgICBEaXJlY3RpdmUgY29udGVudHMuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbc2hvcnRlbl0gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gc2hvcnRlbiBjb250ZW50cyB0by4gSWYgbm90IGRlZmluZWQsIGRvbid0IHNob3J0ZW4gdGhlIHRleHQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBmb3JtYXR0ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXRDb250ZW50cyhzY29wZSwgZWxlbWVudCwgYXR0cnMsIHRleHQsIHNob3J0ZW4pIHtcblxuICAgICAgICB2YXIgc2l0ZUlkID0gc2NvcGUuc2l0ZWlkLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gYXR0cnMuY29tcG9uZW50LFxuICAgICAgICAgICAgY29tcG9uZW50SWQgPSBhdHRycy5jb21wb25lbnRJZDtcblxuICAgICAgICAvLyBBcHBseSBmb3JtYXQgdGV4dCBmdW5jdGlvbi5cbiAgICAgICAgcmV0dXJuICRtbVRleHQuZm9ybWF0VGV4dCh0ZXh0LCBhdHRycy5jbGVhbiwgYXR0cnMuc2luZ2xlbGluZSwgc2hvcnRlbikudGhlbihmdW5jdGlvbihmb3JtYXR0ZWQpIHtcblxuICAgICAgICAgICAgdmFyIGVsID0gZWxlbWVudFswXSxcbiAgICAgICAgICAgICAgICBlbFdpZHRoID0gZWwub2Zmc2V0V2lkdGggfHzCoGVsLndpZHRoIHx8wqBlbC5jbGllbnRXaWR0aDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWVkaWFBZGFwdENsYXNzKGVsKSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5lbGVtZW50KGVsKS5hZGRDbGFzcygnbW0tbWVkaWEtYWRhcHQtd2lkdGgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgY29udGVudCBpbnRvIERPTS5cbiAgICAgICAgICAgIHZhciBkb20gPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+JykuaHRtbChmb3JtYXR0ZWQpO1xuXG4gICAgICAgICAgICAvLyBXYWxrIHRocm91Z2ggdGhlIGNvbnRlbnQgdG8gZmluZCB0aGUgbGlua3MgYW5kIGFkZCBvdXIgZGlyZWN0aXZlIHRvIGl0LlxuICAgICAgICAgICAgLy8gSW1wb3J0YW50OiBXZSBuZWVkIHRvIGxvb2sgZm9yIGxpbmtzIGZpcnN0IGJlY2F1c2UgaW4gJ2ltZycgd2UgYWRkIG5ldyBsaW5rcyB3aXRob3V0IG1tLWJyb3dzZXIuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZG9tLmZpbmQoJ2EnKSwgZnVuY3Rpb24oYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnbW0tZXh0ZXJuYWwtY29udGVudCcsICcnKTtcbiAgICAgICAgICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdtbS1icm93c2VyJywgJycpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnY29tcG9uZW50JywgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdjb21wb25lbnQtaWQnLCBjb21wb25lbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpdGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdzaXRlaWQnLCBzaXRlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBXYWxrIHRocm91Z2ggdGhlIGNvbnRlbnQgdG8gZmluZCBpbWFnZXMsIGFuZCBhZGQgb3VyIGRpcmVjdGl2ZS5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkb20uZmluZCgnaW1nJyksIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgICAgIGFkZE1lZGlhQWRhcHRDbGFzcyhpbWcpO1xuICAgICAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ21tLWV4dGVybmFsLWNvbnRlbnQnLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdjb21wb25lbnQnLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ2NvbXBvbmVudC1pZCcsIGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2l0ZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ3NpdGVpZCcsIHNpdGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGltYWdlIHdpZHRoIGhhcyBiZWVuIGFkYXB0ZWQuIElmIHNvLCBhZGQgYW4gaWNvbiB0byB2aWV3IHRoZSBpbWFnZSBhdCBmdWxsIHNpemUuXG4gICAgICAgICAgICAgICAgdmFyIGltZ1dpZHRoID0gaW1nLm9mZnNldFdpZHRoIHx8wqBpbWcud2lkdGggfHwgaW1nLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChpbWdXaWR0aCA+IGVsV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCB0aGUgaW1hZ2UgaW4gYSBuZXcgZGl2IHdpdGggcG9zaXRpb24gcmVsYXRpdmUuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXYgY2xhc3M9XCJtbS1hZGFwdGVkLWltZy1jb250YWluZXJcIj48L2Rpdj4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpxSW1nID0gYW5ndWxhci5lbGVtZW50KGltZyksXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9ICRtbVRleHQuZXNjYXBlSFRNTCgkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUub3BlbmZ1bGxpbWFnZScpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1NyYyA9ICRtbVRleHQuZXNjYXBlSFRNTChpbWcuZ2V0QXR0cmlidXRlKCdzcmMnKSk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zdHlsZS5mbG9hdCA9ICcnOyAvLyBEaXNhYmxlIGZsb2F0IHNpbmNlIGltYWdlIHdpbGwgZmlsbCB0aGUgd2hvbGUgd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGpxSW1nLndyYXAoZGl2KTtcbiAgICAgICAgICAgICAgICAgICAganFJbWcuYWZ0ZXIoJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJtbS1pbWFnZS12aWV3ZXItaWNvblwiIG1tLWltYWdlLXZpZXdlciBpbWc9XCInICsgaW1nU3JjICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIiBhcmlhLWxhYmVsPVwiJyArIGxhYmVsICsgJ1wiPjxpIGNsYXNzPVwiaWNvbiBpb24taW9zLXNlYXJjaC1zdHJvbmdcIj48L2k+PC9hPicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZG9tLmZpbmQoJ2F1ZGlvJyksIGFkZE1lZGlhQWRhcHRDbGFzcyk7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZG9tLmZpbmQoJ3ZpZGVvJyksIGFkZE1lZGlhQWRhcHRDbGFzcyk7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZG9tLmZpbmQoJ2lmcmFtZScpLCBhZGRNZWRpYUFkYXB0Q2xhc3MpO1xuXG4gICAgICAgICAgICByZXR1cm4gZG9tLmh0bWwoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNvbWUgdGV4dCBvbiB0aGUgZGlyZWN0aXZlJ3MgZWxlbWVudCwgY29tcGlsZSBpdCBhbmQgY2FsbCBhZnRlclJlbmRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2NvcGUgICAgICAgICBEaXJlY3RpdmUgc2NvcGUuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBlbGVtZW50ICAgICAgIERpcmVjdGl2ZSByb290IERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dCAgICAgICAgICBEaXJlY3RpdmUgY29udGVudHMuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbYWZ0ZXJSZW5kZXJdIFNjb3BlIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSB0aGUgY29udGVudCBpcyByZW5kZXJlcmVkLlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVuZGVyVGV4dChzY29wZSwgZWxlbWVudCwgdGV4dCwgYWZ0ZXJSZW5kZXIpIHtcbiAgICAgICAgZWxlbWVudC5odG1sKHRleHQpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdoaWRlJyk7XG4gICAgICAgICRjb21waWxlKGVsZW1lbnQuY29udGVudHMoKSkoc2NvcGUpO1xuICAgICAgICAvLyBDYWxsIHRoZSBhZnRlciByZW5kZXIgZnVuY3Rpb24uXG4gICAgICAgIGlmIChhZnRlclJlbmRlciAmJiBzY29wZVthZnRlclJlbmRlcl0pIHtcbiAgICAgICAgICAgIHNjb3BlW2FmdGVyUmVuZGVyXShzY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICBzY29wZTogdHJ1ZSxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZENsYXNzKCdoaWRlJyk7IC8vIEhpZGUgY29udGVudHMgdW50aWwgdGhleSdyZSB0cmVhdGVkLlxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBlbGVtZW50Lmh0bWwoKTsgLy8gR2V0IGRpcmVjdGl2ZSdzIGNvbnRlbnQuXG5cbiAgICAgICAgICAgIGlmIChhdHRycy53YXRjaCkge1xuICAgICAgICAgICAgICAgIC8vIFdhdGNoIHRoZSB2YXJpYWJsZSBpbnNpZGUgdGhlIGRpcmVjdGl2ZS5cbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goZXh0cmFjdFZhcmlhYmxlUmVnZXgpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzICYmIHR5cGVvZiBtYXRjaGVzWzFdID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGNoZXNbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2godmFyaWFibGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0QW5kUmVuZGVyQ29udGVudHMoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRBbmRSZW5kZXJDb250ZW50cyhzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gZGlzcGxheSBjb250ZW50IGluIGFuIGlmcmFtZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tSWZyYW1lXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgICAgICAgICAgVGhlIHNvdXJjZSBvZiB0aGUgaWZyYW1lLlxuICogQHBhcmFtIHtNaXhlZH0gW3dpZHRoPTEwMCVdICBXaWR0aCBvZiB0aGUgaWZyYW1lLiBJZiBub3QgZGVmaW5lZCwgdXNlIDEwMCUuXG4gKiBAcGFyYW0ge01peGVkfSBbaGVpZ2h0PTEwMCVdIEhlaWdodCBvZiB0aGUgaWZyYW1lLiBJZiBub3QgZGVmaW5lZCwgdXNlIDEwMCUuXG4gKi9cbi5kaXJlY3RpdmUoJ21tSWZyYW1lJywgZnVuY3Rpb24oJG1tVXRpbCkge1xuXG4gICAgdmFyIGVycm9yU2hvd25UaW1lID0gMCxcbiAgICAgICAgdGFncyA9IFsnaWZyYW1lJywgJ2ZyYW1lJywgJ29iamVjdCcsICdlbWJlZCddO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJjZXB0IHdpbmRvdy5vcGVuIGluIGEgZnJhbWUgYW5kIGl0cyBzdWJmcmFtZXMsIHNob3dzIGFuIGVycm9yIG1vZGFsIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gdHJlYXQuXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcmNlcHRQb3B1cHMoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gUmVkZWZpbmUgd2luZG93Lm9wZW4gaW4gdGhpcyBlbGVtZW50IGFuZCBzdWIgZnJhbWVzLCBpdCBtaWdodCBoYXZlIGJlZW4gbG9hZGVkIGFscmVhZHkuXG4gICAgICAgICAgICByZWRlZmluZVdpbmRvd09wZW4oZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGxvYWRlZCwgcmVkZWZpbmUgd2luZG93Lm9wZW4gYWdhaW4uXG4gICAgICAgICAgICAgICAgcmVkZWZpbmVXaW5kb3dPcGVuKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRlZmluZSB0aGUgb3BlbiBtZXRob2QgaW4gdGhlIGNvbnRlbnRXaW5kb3cgb2YgYW4gZWxlbWVudCBhbmQgdGhlIHN1YiBmcmFtZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gdHJlYXQuXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWRlZmluZVdpbmRvd09wZW4oZWxlbWVudCkge1xuICAgICAgICB2YXIgZWwgPSBlbGVtZW50WzBdLFxuICAgICAgICAgICAgY29udGVudFdpbmRvdyA9IGVsZW1lbnQuY29udGVudFdpbmRvdyB8fCBlbC5jb250ZW50V2luZG93LFxuICAgICAgICAgICAgY29udGVudHMgPSBlbGVtZW50LmNvbnRlbnRzKCk7XG5cbiAgICAgICAgaWYgKCFjb250ZW50V2luZG93ICYmIGVsICYmIGVsLmNvbnRlbnREb2N1bWVudCkge1xuICAgICAgICAgICAgLy8gSXQncyBwcm9iYWJseSBhbiA8b2JqZWN0Pi4gVHJ5IHRvIGdldCB0aGUgd2luZG93LlxuICAgICAgICAgICAgY29udGVudFdpbmRvdyA9IGVsLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29udGVudFdpbmRvdyAmJiBlbCAmJiBlbC5nZXRTVkdEb2N1bWVudCkge1xuICAgICAgICAgICAgLy8gSXQncyBwcm9iYWJseSBhbiA8ZW1iZWQ+LiBUcnkgdG8gZ2V0IHRoZSB3aW5kb3cuXG4gICAgICAgICAgICB2YXIgc3ZnRG9jID0gZWwuZ2V0U1ZHRG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAoc3ZnRG9jICYmIHN2Z0RvYy5kZWZhdWx0Vmlldykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gYW5ndWxhci5lbGVtZW50KHN2Z2RvYyk7XG4gICAgICAgICAgICAgICAgY29udGVudFdpbmRvdyA9IHN2Z2RvYy5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwud2luZG93KSB7XG4gICAgICAgICAgICAgICAgY29udGVudFdpbmRvdyA9IGVsLndpbmRvdztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwuZ2V0V2luZG93KSB7XG4gICAgICAgICAgICAgICAgY29udGVudFdpbmRvdyA9IGVsLmdldFdpbmRvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIC8vIEludGVyY2VwdCB3aW5kb3cub3Blbi5cbiAgICAgICAgICAgIGNvbnRlbnRXaW5kb3cub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHNob3dpbmcgbW9yZSB0aGFuIG9uZSBjb25zZWN1dGl2ZSBlcnJvci4gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIG9mdGVuIGJlY2F1c2UgaXQgbWVhbnMgdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIHVzaW5nIG1vcmUgdGhhbiBvbmUgd2luZG93Lm9wZW4sIGJ1dCBpdCdzIGJldHRlciB0byBoYW5kbGUgaXQganVzdCBpbiBjYXNlLlxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSAtIGVycm9yU2hvd25UaW1lID4gNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yU2hvd25UaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3JvcGVucG9wdXAnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9OyAvLyBSZXR1cm4gZW1wdHkgXCJ3aW5kb3dcIiBvYmplY3QuXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VhcmNoIHN1YiBmcmFtZXMuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh0YWdzLCBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250ZW50cy5maW5kKHRhZyksIGZ1bmN0aW9uKHN1YmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRQb3B1cHMoYW5ndWxhci5lbGVtZW50KHN1YmVsZW1lbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJpZnJhbWUtd3JhcHBlclwiPjxpZnJhbWUgY2xhc3M9XCJtbS1pZnJhbWVcIiBuZy1zdHlsZT1cIntcXCd3aWR0aFxcJzogd2lkdGgsIFxcJ2hlaWdodFxcJzogaGVpZ2h0fVwiIG5nLXNyYz1cInt7c3JjfX1cIj48L2lmcmFtZT48L2Rpdj4nLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgc3JjOiAnPSdcbiAgICAgICAgfSxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICBzY29wZS53aWR0aCA9ICRtbVV0aWwuZm9ybWF0UGl4ZWxzU2l6ZShhdHRycy5pZnJhbWVXaWR0aCkgfHwgJzEwMCUnO1xuICAgICAgICAgICAgc2NvcGUuaGVpZ2h0ID0gJG1tVXRpbC5mb3JtYXRQaXhlbHNTaXplKGF0dHJzLmlmcmFtZUhlaWdodCkgfHwgJzEwMCUnO1xuXG4gICAgICAgICAgICB2YXIgaWZyYW1lID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnQuZmluZCgnaWZyYW1lJylbMF0pO1xuICAgICAgICAgICAgaW50ZXJjZXB0UG9wdXBzKGlmcmFtZSk7XG4gICAgICAgICAgICBpZnJhbWUub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaWZyYW1lLmNvbnRlbnRzKCkuZmluZCgnYScpLCBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHJlZiAmJiBocmVmLmluZGV4T2YoJ2h0dHAnKSA9PT0gMCkgeyAvLyBDaGVjayB0aGF0IGhyZWYgaXMgbm90IG51bGwuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoZWwpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLm9wZW5JbkJyb3dzZXIoaHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBwcmV2ZW50IGlucHV0IHZhbGlkYXRpb24gb24gaW5wdXQgZmllbGRzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1Ob0lucHV0VmFsaWRhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiBTb21ldGltZXMgd2UgbWlnaHQgd2FudCB0byBkaXNhYmxlIGF1dG9tYXRpYyB2YWxpZGF0aW9uIG9uIHNvbWUgaW5wdXQgZmllbGRzIChsaWtlIFVSTHMpLlxuICogVGhpcyBkaXJlY3RpdmUgYWxsb3dzIHVzIHRvIGRvIHNvLlxuICovXG4uZGlyZWN0aXZlKCdtbUltYWdlVmlld2VyJywgZnVuY3Rpb24oJGlvbmljTW9kYWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICBwcmlvcml0eTogNTAwLFxuICAgICAgICBzY29wZTogdHJ1ZSxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMuaW1nKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuaW1nID0gYXR0cnMuaW1nO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuY2xvc2VNb2RhbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm1vZGFsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLm1vZGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ2NvcmUvdGVtcGxhdGVzL2ltYWdldmlld2VyLmh0bWwnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogJ3NsaWRlLWluLXVwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubW9kYWwgPSBtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLm1vZGFsLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubW9kYWwuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5tb2RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubW9kYWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIHNob3cgYSBsb2FkaW5nIHNwaW5uZXIgYW5kIG1lc3NhZ2Ugd2hpbGUgZGF0YSBpcyBiZWluZyBsb2FkZWQuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbUxvYWRpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogVXNhZ2U6XG4gKiA8bW0tbG9hZGluZyBtZXNzYWdlPVwie3tsb2FkaW5nTWVzc2FnZX19XCIgaGlkZS11bnRpbD1cImRhdGFMb2FkZWRcIiBsb2FkaW5nLXBhZGRpbmctdG9wPVwicGFkZGluZ1RvcFwiPlxuICogICAgIDwhLS0gQ09OVEVOVCBUTyBISURFIFVOVElMIExPQURFRCAtLT5cbiAqIDwvbW0tbG9hZGluZz5cbiAqIFRoaXMgZGlyZWN0aXZlIHdpbGwgc2hvdyBhIGlvbi1zcGlubmVyIHdpdGggYSBtZXNzYWdlIGFuZCBoaWRlIGFsbCB0aGUgY29udGVudCB1bnRpbCAnZGF0YUxvYWRlZCcgdmFyaWFibGUgaXMgc2V0IHRvIHRydWUuXG4gKiBJZiAnbWVzc2FnZScgYXR0cmlidXRlIGlzIG5vdCBzZXQsIGRlZmF1bHQgbWVzc2FnZSBcIkxvYWRpbmdcIiBpcyBzaG93bi5cbiAqICdtZXNzYWdlJyBhdHRyaWJ1dGUgYWNjZXB0cyBoYXJkY29kZWQgc3RyaW5ncywgdmFyaWFibGVzLCBmaWx0ZXJzLCBldGMuIEUuZy4gbWVzc2FnZT1cInt7ICdtbS5jb3JlLmxvYWRpbmcnIHwgdHJhbnNsYXRlfX1cIi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdICAgICAgICAgICBNZXNzYWdlIHRvIHNob3cgd2hpbGUgbG9hZGluZy4gSWYgbm90IHNldCwgZGVmYXVsdCBcIkxvYWRpbmdcIiBtZXNzYWdlIGlzIHNob3duLlxuICogQHBhcmFtIHtTdHJpbmd9IGhpZGVVbnRpbCAgICAgICAgICAgU2NvcGUgdmFyaWFibGUgdG8gZGV0ZXJtaW5lIHdoZW4gc2hvdWxkIHRoZSBjb250ZW50cyBiZSBzaG93bi4gV2hlbiB0aGUgdmFyaWFibGUgaXMgc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0cnVlLCB0aGUgbG9hZGluZyBpcyBoaWRkZW4gYW5kIHRoZSBjb250ZW50cyBhcmUgc2hvd24uXG4gKiBAcGFyYW0ge1N0cmluZ30gW2xvYWRpbmdQYWRkaW5nVG9wXSBQYWRkaW5nIHRvcCB0byBzZXQgdG8gbG9hZGluZyB2aWV3LiBJZiBub3Qgc2V0LCBubyBwYWRkaW5nIHRvcCBpcyBzZXQuIFRoaXMgYXR0cmlidXRlIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFudCB0byBiZSB1c2VkIHdpdGggZHluYW1pYyBwYWRkaW5ncyAoZS5nLiB0byBtb3ZlIHRoZSBsb2FkaW5nIHNwaW5uZXIgdG8gdGhlIHVzZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCkuIFN0YXRpYyBwYWRkaW5nLXRvcCBzaG91bGQgYmUgc2V0IHVzaW5nIENTUy5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1Mb2FkaW5nJywgZnVuY3Rpb24oJHRyYW5zbGF0ZSkge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL3RlbXBsYXRlcy9sb2FkaW5nLmh0bWwnLFxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgaGlkZVVudGlsOiAnPT8nLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0A/JyxcbiAgICAgICAgICAgIGxvYWRpbmdQYWRkaW5nVG9wOiAnPT8nXG4gICAgICAgIH0sXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgdmFyIGVsID0gZWxlbWVudFswXSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nID0gYW5ndWxhci5lbGVtZW50KGVsLnF1ZXJ5U2VsZWN0b3IoJy5tbS1sb2FkaW5nLWNvbnRhaW5lcicpKTtcblxuICAgICAgICAgICAgaWYgKCFhdHRycy5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBsb2FkaW5nIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgJHRyYW5zbGF0ZSgnbW0uY29yZS5sb2FkaW5nJykudGhlbihmdW5jdGlvbihsb2FkaW5nU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm1lc3NhZ2UgPSBsb2FkaW5nU3RyaW5nO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXR0cnMubG9hZGluZ1BhZGRpbmdUb3ApIHtcbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goJ2xvYWRpbmdQYWRkaW5nVG9wJywgZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2VJbnQgb2YgYW4gaW52YWxpZCBzdHJpbmcgaXMgTmFOLCBidXQgcGFyc2VJbnQoJ2EnKSA9PSBOYU4gaXMgRkFMU0UgYW5kIHR5cGVvZiBOYU4gPSAnbnVtYmVyJy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhhdCdzIHdoeSB3ZSB1c2UgbnVtID49IDAgb3IgbnVtIDwgMCB0byBjaGVjayBpZiBpdCdzIGEgdmFsaWQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gcGFyc2VJbnQobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtID49IDAgfHwgbnVtIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZy5jc3MoJ3BhZGRpbmctdG9wJywgbmV3VmFsdWUgKyAncHgnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiBuZXdWYWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF5YmUgdGhleSBzZXQgYSB2YWx1ZSBsaWtlICcyMDBweCcuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nLmNzcygncGFkZGluZy10b3AnLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogVGhpcyBkaXJlY3RpdmUgYWRkcyBhIFwiYmFyXCIgd2l0aCBhcnJvd3MgdG8gbmF2aWdhdGUgZm9yd2FyZC9iYWNrd2FyZCBhbmQgYSBcImluZm9cIiBpY29uIHRvIGRpc3BsYXkgbW9yZSBkYXRhLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1OYXZpZ2F0aW9uQmFyXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgZGlyZWN0aXZlIHdpbGwgc2hvdyB0d28gYXJyb3dzIGF0IHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgc2NyZWVuIHRvIG5hdmlnYXRlIHRvIHByZXZpb3VzL25leHQgaXRlbSB3aGVuIGNsaWNrZWQuXG4gKiBJZiBubyBwcmV2aW91cy9uZXh0IGl0ZW0gaXMgZGVmaW5lZCwgdGhhdCBhcnJvdyB3b24ndCBiZSBzaG93bi4gSXQgd2lsbCBhbHNvIHNob3cgYSBidXR0b24gdG8gc2hvdyBtb3JlIGluZm8uXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gICAgW3ByZXZpb3VzXSBQcmV2aW91cyBpdGVtLiBJZiBub3QgZGVmaW5lZCwgdGhlIHByZXZpb3VzIGFycm93IHdvbid0IGJlIHNob3duLlxuICogQHBhcmFtIHtNaXhlZH0gICAgW25leHRdICAgICBOZXh0IGl0ZW0uIElmIG5vdCBkZWZpbmVkLCB0aGUgbmV4dCBhcnJvdyB3b24ndCBiZSBzaG93bi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFthY3Rpb25dICAgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFuIGFycm93IGlzIGNsaWNrZWQuIFdpbGwgcmVjZWl2ZSBhcyBhIHBhcmFtIHRoZSBpdGVtIHRvIGxvYWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gICBbaW5mb10gICAgIEluZm8gdG8gc2hvdyB3aGVuIGNsaWNraW5nIHRoZSBpbmZvIGJ1dHRvbi4gSWYgbm90IGRlZmluZWQsIHRoZSBpbmZvIGJ1dHRvbiB3b24ndCBiZSBzaG93bi5cbiAqIEBwYXJhbSB7U3RyaW5nfSAgIFt0aXRsZV0gICAgVGl0bGUgdG8gc2hvdyB3aGVuIHNlZWluZyB0aGUgaW5mbyAobmV3IHN0YXRlKS5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1OYXZpZ2F0aW9uQmFyJywgZnVuY3Rpb24oJHN0YXRlLCAkdHJhbnNsYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgIHByZXZpb3VzOiAnPT8nLFxuICAgICAgICAgICAgbmV4dDogJz0/JyxcbiAgICAgICAgICAgIGFjdGlvbjogJz0/JyxcbiAgICAgICAgICAgIGluZm86ICc9PydcbiAgICAgICAgfSxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL3RlbXBsYXRlcy9uYXZpZ2F0aW9uYmFyLmh0bWwnLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgIHNjb3BlLnRpdGxlID0gYXR0cnMudGl0bGUgfHzCoCR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS5pbmZvJyk7XG4gICAgICAgICAgICBzY29wZS5zaG93SW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tbV90ZXh0dmlld2VyJywge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogc2NvcGUudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHNjb3BlLmluZm9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBwcmV2ZW50IGlucHV0IHZhbGlkYXRpb24gb24gaW5wdXQgZmllbGRzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1Ob0lucHV0VmFsaWRhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiBTb21ldGltZXMgd2UgbWlnaHQgd2FudCB0byBkaXNhYmxlIGF1dG9tYXRpYyB2YWxpZGF0aW9uIG9uIHNvbWUgaW5wdXQgZmllbGRzIChsaWtlIFVSTHMpLlxuICogVGhpcyBkaXJlY3RpdmUgYWxsb3dzIHVzIHRvIGRvIHNvLlxuICovXG4uZGlyZWN0aXZlKCdtbU5vSW5wdXRWYWxpZGF0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgcHJpb3JpdHk6IDUwMCxcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24oZWwsIGF0dHJzKSB7XG4gICAgICAgICAgICBhdHRycy4kc2V0KCd0eXBlJyxcbiAgICAgICAgICAgICAgICBudWxsLCAgICAgICAgICAgICAgICAvL3RvIGRlbGV0ZSB0eXBlIGZyb20gYXR0cmlidXRlcyBvYmplY3RcbiAgICAgICAgICAgICAgICBmYWxzZSAgICAgICAgICAgICAgICAvL3RvIHByZXNlcnZlIHR5cGUgYXR0cmlidXRlIGluIERPTVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLmNvbnN0YW50KCdtbUNvcmVTcGxpdFZpZXdMb2FkJywgJ21tU3BsaXRWaWV3OmxvYWQnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBjcmVhdGUgYSBzcGxpdCB2aWV3IGxheW91dC4gVGhpcyBkaXJlY3RpdmUgc2hvdWxkIGJlIHVzZWQgYWxvbmcgd2l0aCBtbS1zcGxpdC12aWV3LWxpbmsuXG4gKlxuICogSU1QT1JUQU5UOiBEdWUgdG8gYSBsaW1pdGF0aW9uIGluIEFuZ3VsYXIgdWktcm91dGVyLCB0aGUgbGVmdCBwYW5lIHN0YXRlIGFuZCB0aGUgcmlnaHQgcGFuZSBzdGF0ZSBzaG91bGQgTk9UIGhhdmVcbiAqIHBhcmFtZXRlcnMgd2l0aCB0aGUgc2FtZSBuYW1lIGJ1dCBkaWZmZXJlbnQgdmFsdWUuIEl0IGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAqIEV4YW1wbGU6IGlmIHRoZSBsZWZ0IHBhbmUgbG9hZHMgYSBzdGF0ZSB3aXRoIHBhcmFtICdjb3Vyc2VpZCcsIHRoZW4gYWxsIHRoZSBzdGF0ZXMgdGhhdCBjYW4gYmUgbG9hZGVkIGluIHRoZSByaWdodCBwYW5lXG4gKiBzaG91bGQgYXZvaWQgaGF2aW5nIGEgcGFyYW1ldGVyIG5hbWVkICdjb3Vyc2VpZCcuIFRoZSByaWdodCBwYW5lIHN0YXRlIGNhbiBoYXZlIGEgJ2NvdXJzZWlkJyBwYXJhbSBvbmx5IGlmIGl0IHdpbGwgYWx3YXlzXG4gKiBoYXZlIHRoZSBzYW1lIHZhbHVlIHRoYW4gaW4gbGVmdCBwYW5lIHN0YXRlLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1TcGxpdFZpZXdcbiAqIEBkZXNjcmlwdGlvblxuICogVXNhZ2U6XG4gKiA8bW0tc3BsaXQtdmlldyBjb21wb25lbnQ9XCJtbWFDYWxlbmRhckV2ZW50c0xpc3RcIj5cbiAqICAgICA8IS0tIENPTlRFTlQgVE8gU0hPVyBPTiBUSEUgTEVGVCBQQU5FTCAoTUVOVSkgLS0+XG4gKiA8L21tLXNwbGl0LXZpZXc+XG4gKlxuICogVG8gY2hhbmdlIHRoZSByaWdodCBwYW5lIGNvbnRlbnRzIChjb250ZW50IHBhbmUpLCBtbVNwbGl0Vmlld0xpbmsgZGlyZWN0aXZlIGlzIG5lZWRlZC5cbiAqIG1tU3BsaXRWaWV3IHdpbGwgYXV0b21hdGljYWxseSB0cnkgdG8gbG9hZCBhIG1tU3BsaXRWaWV3TGluayB3aGVuIHRoZSB2aWV3IGlzIGxvYWRlZC4gVGhpcyBjYW4gYmUgY29uZmlndXJlZCB1c2luZ1xuICogdGhlIGF0dHJpYnV0ZXMgXCJsb2FkXCIgYW5kIFwibG9hZFdoZW5cIi5cbiAqXG4gKiBJZiB5b3UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIGRpcmVjdGl2ZSdzIHNjb3BlIGJ1dCB5b3Ugc3RpbGwgd2FudCB0byBjb25maWd1cmUgd2hlbiBzaG91bGQgdGhlIGRhdGEgYmUgbG9hZGVkIGFuZCB3aGljaFxuICogZWxlbWVudCBzaG91bGQgaXQgbG9hZCB5b3UgY2FuIHVzZSB0aGUgbW1Db3JlU3BsaXRWaWV3TG9hZCBldmVudC4gV2hlbiB0aGUgZGlyZWN0aXZlIHJlY2VpdmVzIHRoaXMgZXZlbnQgaXQgd2lsbCB0cnkgdG9cbiAqIGltbWVkaWF0ZWx5IGxvYWQgdGhlIGxpbmsgc2V0IChpZiBubyBsaW5rIGlzIHNldCBpdCB3aWxsIGxvYWQgdGhlIGZpcnN0IGxpbmsgZm91bmQpLiBFeGFtcGxlOlxuICogJHJvb3RTY29wZS4kYnJvYWRjYXN0KG1tQ29yZVNwbGl0Vmlld0xvYWQsIHtsb2FkOiAyfSk7XG4gKlxuICogSU1QT1JUQU5UOiBEdWUgdG8gYSBsaW1pdGF0aW9uIGluIEFuZ3VsYXIgdWktcm91dGVyLCB0aGUgbGVmdCBwYW5lIHN0YXRlIGFuZCB0aGUgcmlnaHQgcGFuZSBzdGF0ZSBzaG91bGQgTk9UIGhhdmVcbiAqIHBhcmFtZXRlcnMgd2l0aCB0aGUgc2FtZSBuYW1lIGJ1dCBkaWZmZXJlbnQgdmFsdWUuIEl0IGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAqIEV4YW1wbGU6IGlmIHRoZSBsZWZ0IHBhbmUgbG9hZHMgYSBzdGF0ZSB3aXRoIHBhcmFtICdjb3Vyc2VpZCcsIHRoZW4gYWxsIHRoZSBzdGF0ZXMgdGhhdCBjYW4gYmUgbG9hZGVkIGluIHRoZSByaWdodCBwYW5lXG4gKiBzaG91bGQgYXZvaWQgaGF2aW5nIGEgcGFyYW1ldGVyIG5hbWVkICdjb3Vyc2VpZCcuIFRoZSByaWdodCBwYW5lIHN0YXRlIGNhbiBoYXZlIGEgJ2NvdXJzZWlkJyBwYXJhbSBvbmx5IGlmIGl0IHdpbGwgYWx3YXlzXG4gKiBoYXZlIHRoZSBzYW1lIHZhbHVlIHRoYW4gaW4gbGVmdCBwYW5lIHN0YXRlLlxuICpcbiAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwYXJhbXM6XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFttZW51V2lkdGhdIFdpZHRoIG9mIHRoZSBsZWZ0IG1lbnUuIENhbiBiZSBzcGVjaWZpZWQgaW4gcGl4ZWxzICgnMjAwcHgnKSBvciBpbiBwZXJjZW50YWdlICgnMzAlJykuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtsb2FkV2hlbl0gIE5hbWUgb2YgYSBzY29wZSB2YXJpYWJsZS4gV2hlbiB0aGF0IHZhcmlhYmxlIGlzIHNldCB0byB0cnVlLCBhIG1tLXNwbGl0LXZpZXctbGluayB3aWxsIGJlIGxvYWRlZCBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBjb250ZW50cyBwYW5lLiBJZiBub3Qgc2V0LCB0cnkgdG8gbG9hZCBpdCByaWdodCBhdCB0aGUgc3RhcnQuIFNlZSBcImxvYWRcIiBwYXJhbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgQ29tcG9uZW50LiBJbiB0YWJsZXQsIHRoZSBuZXcgdmlldyB3aWxsIGJlIG5hbWVkIGFmdGVyIHRoZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsb2FkXSBMaW5rIHRvIGxvYWQuIElmIG5vdCBzZXQgdGhlbiB0aGUgZmlyc3QgbGluayB3aWxsIGJlIGxvYWRlZCBieSBkZWZhdWx0LiBJZiBpdCdzIHNldCB0aGVuIGl0IHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHRvIGxvYWQgdGhlIG50aCBsaW5rLiBFLmcuIGxvYWQ9MiB3aWxsIGxvYWQgdGhlIHNlY29uZCBsaW5rIGluIHRoZSBwYWdlLlxuICovXG4uZGlyZWN0aXZlKCdtbVNwbGl0VmlldycsIGZ1bmN0aW9uKCRsb2csICRzdGF0ZSwgJGlvbmljUGxhdGZvcm0sICR0aW1lb3V0LCAkbW1VdGlsLCAkaW50ZXJwb2xhdGUsIG1tQ29yZVNwbGl0Vmlld0xvYWQpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbVNwbGl0VmlldycpO1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBjbGljayBvbiBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBsaW5rIERPTSBlbGVtZW50IHRvIHRyaWdnZXIgY2xpY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUgaWYgc3VjY2VzcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJDbGljayhsaW5rKSB7XG4gICAgICAgIGlmIChsaW5rICYmIGxpbmsubGVuZ3RoICYmIGxpbmsudHJpZ2dlckhhbmRsZXIpIHtcbiAgICAgICAgICAgIGxpbmsudHJpZ2dlckhhbmRsZXIoJ2NsaWNrJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRGlyZWN0aXZlIGNvbnRyb2xsZXIuXG4gICAgZnVuY3Rpb24gY29udHJvbGxlcigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIG1lbnVTdGF0ZSxcbiAgICAgICAgICAgIGxpbmtUb0xvYWQsXG4gICAgICAgICAgICBjb21wb25lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBsaW5rcyBtYXJrZWQgYXMgc2VsZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyTWFya2VkTGlua3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1ttbS1zcGxpdC12aWV3LWxpbmtdJykpLnJlbW92ZUNsYXNzKCdtbS1zcGxpdC1pdGVtLXNlbGVjdGVkJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzcGxpdCB2aWV3IG1lbnUncyBzdGF0ZSBuYW1lIChsZWZ0IHBhbmUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IE1lbnUgc3RhdGUgbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0TWVudVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVudVN0YXRlIHx8wqAkc3RhdGUuY3VycmVudC5uYW1lO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkIGEgbW0tc3BsaXQtdmlldy1saW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAgICAgICAgICAgRGlyZWN0aXZlJ3Mgc2NvcGUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW2xvYWRBdHRyXSBOdW1iZXIgb2YgbGluayB0byBsb2FkLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHJ5aW5nICAgICAgICAgVHJ1ZSBpZiB3ZSdyZSByZXRyeWluZyBiZWNhdXNlIHRoZSBmdW5jdGlvbiBmYWlsZWQgKGxpbmsgd2Fzbid0IHJlYWR5KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZExpbmsgPSBmdW5jdGlvbihzY29wZSwgbG9hZEF0dHIsIHJldHJ5aW5nKSB7XG4gICAgICAgICAgICBpZiAoJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSkge1xuICAgICAgICAgICAgICAgIGlmICghbGlua1RvTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBsaW5rIHNldC4gTGV0J3MgZGV0ZXJtaW5lIGlmIGxvYWRBdHRyIGlzIHNldCBhbmQgaXRzIHJlYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZEF0dHIgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHBhcnNlSW50KGxvYWRBdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVtcyBpdCdzIG5vdCBhIG51bWJlci4gVHJ5IHRvIGludGVycG9sYXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcGFyc2VJbnQoJGludGVycG9sYXRlKGxvYWRBdHRyKShzY29wZSksIDEwKTsgLy8gXCJFdmFsdWF0ZVwiIHNjb3BlIHZhcmlhYmxlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5rcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW21tLXNwbGl0LXZpZXctbGlua10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID4gbGlua3MubGVuZ3RoID8gMCA6IHBvc2l0aW9uIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rVG9Mb2FkID0gYW5ndWxhci5lbGVtZW50KGxpbmtzW3Bvc2l0aW9uXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgZmlyc3QgbGlua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtUb0xvYWQgPSBhbmd1bGFyLmVsZW1lbnQoZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdbbW0tc3BsaXQtdmlldy1saW5rXScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgZmlyc3QgbGlua1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua1RvTG9hZCA9IGFuZ3VsYXIuZWxlbWVudChlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ1ttbS1zcGxpdC12aWV3LWxpbmtdJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0cmlnZ2VyQ2xpY2sobGlua1RvTG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGluayBub3QgZm91bmQuIExldCdzIHJldHJ5IG9uY2UgaW4gdGhlIG5leHQgZGlnZXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJldHJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rVG9Mb2FkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2FkTGluayhzY29wZSwgbG9hZEF0dHIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbXAgQ29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRDb21wb25lbnQgPSBmdW5jdGlvbihjbXApIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGNtcDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGRpcmVjdGl2ZSdzIERPTSBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWwgRGlyZWN0aXZlJ3MgRE9NIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgbW0tc3BsaXQtdmlldy1saW5rIHRvIGxvYWQuIFVzZWQgdG8gcmUtbG9hZCBsYXN0IHN0YXRlIGlmIG5lZWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGxpbmsgTGluayB0byBzZXQgKERPTSBlbGVtZW50KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0TGluayA9IGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICAgIGxpbmtUb0xvYWQgPSBsaW5rO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgc3BsaXQgdmlldyBtZW51J3Mgc3RhdGUgbmFtZSAobGVmdCBwYW5lKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlIFN0YXRlIG5hbWUgdG8gc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRNZW51U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgbWVudVN0YXRlID0gc3RhdGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL3RlbXBsYXRlcy9zcGxpdHZpZXcuaHRtbCcsXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgICAgIGNvbnRyb2xsZXI6IGNvbnRyb2xsZXIsXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIGVsID0gZWxlbWVudFswXSxcbiAgICAgICAgICAgICAgICBtZW51ID0gYW5ndWxhci5lbGVtZW50KGVsLnF1ZXJ5U2VsZWN0b3IoJy5tbS1zcGxpdC1wYW5lLW1lbnUnKSksXG4gICAgICAgICAgICAgICAgbWVudVN0YXRlID0gJHN0YXRlLiRjdXJyZW50Lm5hbWUsXG4gICAgICAgICAgICAgICAgbWVudVBhcmFtcyA9ICRzdGF0ZS5wYXJhbXMsXG4gICAgICAgICAgICAgICAgbWVudVdpZHRoID0gYXR0cnMubWVudVdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGF0dHJzLmNvbXBvbmVudCB8fCAndGFibGV0JztcblxuICAgICAgICAgICAgc2NvcGUuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgICBjb250cm9sbGVyLnNldENvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgY29udHJvbGxlci5zZXRFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0TWVudVN0YXRlKG1lbnVTdGF0ZSk7XG5cbiAgICAgICAgICAgIGlmIChtZW51V2lkdGggJiYgJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSkge1xuICAgICAgICAgICAgICAgIG1lbnUuY3NzKCd3aWR0aCcsIG1lbnVXaWR0aCk7XG4gICAgICAgICAgICAgICAgbWVudS5jc3MoJy13ZWJraXQtZmxleC1iYXNpcycsIG1lbnVXaWR0aCk7XG4gICAgICAgICAgICAgICAgbWVudS5jc3MoJy1tb3otZmxleC1iYXNpcycsIG1lbnVXaWR0aCk7XG4gICAgICAgICAgICAgICAgbWVudS5jc3MoJy1tcy1mbGV4LWJhc2lzJywgbWVudVdpZHRoKTtcbiAgICAgICAgICAgICAgICBtZW51LmNzcygnZmxleC1iYXNpcycsIG1lbnVXaWR0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlJ2xsIHNldCBhbGwgdGhlIGxpc3RlbmVycyBldmVuIGlmIGl0J3Mgbm90IGEgdGFibGV0LCB0byBzdXBwb3J0IGNoYW5nZSBiZXR3ZWVuIHRhYmxldC1zbWFydHBob25lIG1vZGUuXG5cbiAgICAgICAgICAgIGlmIChhdHRycy5sb2FkV2hlbikge1xuICAgICAgICAgICAgICAgIC8vIExvYWQgbGluayB3aGVuIHZhcmlhYmxlIGlzIHNldCB0byB0cnVlLlxuICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChhdHRycy5sb2FkV2hlbiwgZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmxvYWRMaW5rKHNjb3BlLCBhdHRycy5sb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmxvYWRMaW5rKHNjb3BlLCBhdHRycy5sb2FkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9hZCBsYXN0IG9wZW5lZCBsaW5rIHdoZW4gd2UgcmUtZW50ZXIgdGhlIHNhbWUgc3RhdGUuIFdlIHVzZSAkc3RhdGVDaGFuZ2VTdWNjZXNzIGluc3RlYWQgb2YgJGlvbmljVmlldy5lbnRlclxuICAgICAgICAgICAgLy8gYmVjYXVzZSAkaW9uaWNWaWV3LmVudGVyIGlzIG5vdCB0cmlnZ2VyZWQgd2hlbiBnb2luZyB0byB0aGUgc2FtZSBzdGF0ZS5cbiAgICAgICAgICAgIHNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uKGV2ZW50LCB0b1N0YXRlLCB0b1BhcmFtcywgZnJvbVN0YXRlLCBmcm9tUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSB0aGF0IG5hbWUgYW5kIHBhcmFtcyBhcmUgc2ltaWxhci4gV2UnbGwgb25seSBjb21wYXJlIDFzdCBsZXZlbCBvZiBwYXJhbXMsIGl0J3Mgbm90IGEgZGVlcCBjb21wYXJlLlxuICAgICAgICAgICAgICAgIGlmICh0b1N0YXRlLm5hbWUgPT09IG1lbnVTdGF0ZSAmJiAkbW1VdGlsLmJhc2ljTGVmdENvbXBhcmUodG9QYXJhbXMsIG1lbnVQYXJhbXMsIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIubG9hZExpbmsoKTsgLy8gTm8gbmVlZCB0byBwYXNzIHNjb3BlIGFuZCBsb2FkLCBsaW5rIHNob3VsZCBiZSBzZXQuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgZXZlbnQgdG8gbG9hZCBsaW5rLlxuICAgICAgICAgICAgc2NvcGUuJG9uKG1tQ29yZVNwbGl0Vmlld0xvYWQsIGZ1bmN0aW9uKGUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5sb2FkTGluayhzY29wZSwgZGF0YS5sb2FkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmxvYWRMaW5rKHNjb3BlLCBhdHRycy5sb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIGxvYWQgYSBzdGF0ZSBpbiBhIHNwbGl0LXZpZXctY29udGVudCBwYW5lIGluIHRhYmxldCBvciBpbiBhIG5ldyBwYWdlIGluIHBob25lLlxuICogUmVxdWlyZXMgYmVpbmcgYSBjaGlsZCBvZiBtbVNwbGl0Vmlldy5cbiAqXG4gKiBJTVBPUlRBTlQ6IER1ZSB0byBhIGxpbWl0YXRpb24gaW4gQW5ndWxhciB1aS1yb3V0ZXIsIHRoZSBsZWZ0IHBhbmUgc3RhdGUgYW5kIHRoZSByaWdodCBwYW5lIHN0YXRlIHNob3VsZCBOT1QgaGF2ZVxuICogcGFyYW1ldGVycyB3aXRoIHRoZSBzYW1lIG5hbWUgYnV0IGRpZmZlcmVudCB2YWx1ZS4gSXQgY2FuIGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxuICogRXhhbXBsZTogaWYgdGhlIGxlZnQgcGFuZSBsb2FkcyBhIHN0YXRlIHdpdGggcGFyYW0gJ2NvdXJzZWlkJywgdGhlbiBhbGwgdGhlIHN0YXRlcyB0aGF0IGNhbiBiZSBsb2FkZWQgaW4gdGhlIHJpZ2h0IHBhbmVcbiAqIHNob3VsZCBhdm9pZCBoYXZpbmcgYSBwYXJhbWV0ZXIgbmFtZWQgJ2NvdXJzZWlkJy4gVGhlIHJpZ2h0IHBhbmUgc3RhdGUgY2FuIGhhdmUgYSAnY291cnNlaWQnIHBhcmFtIG9ubHkgaWYgaXQgd2lsbCBhbHdheXNcbiAqIGhhdmUgdGhlIHNhbWUgdmFsdWUgdGhhbiBpbiBsZWZ0IHBhbmUgc3RhdGUuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbVNwbGl0Vmlld0xpbmtcbiAqIEBkZXNjcmlwdGlvblxuICogVXNhZ2U6XG4gKiA8Li4uIG1tLXNwbGl0LXZpZXctbGluaz1cInNpdGUubW1fdXNlci1wcm9maWxlKHtjb3Vyc2VpZDogY291cnNlaWQsIHVzZXJpZDogcGFydGljaXBhbnQuaWR9KVwiID5cbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSBhY2NlcHRzIGEgc3JlZiBzdHJpbmcgdGhhdCBpbmRpY2F0ZXMgdGhlIHN0YXRlIHRvIGdvIHRvIGFuZCB0aGUgcGFyYW1zLiBTY29wZSB2YXJpYWJsZSBuZWVkIHRvIGJlXG4gKiBpbnNpZGUgY3VybHkgYnJhY2tldHM6IHt7dmFyaWFibGVfbmFtZX19LlxuICogSW4gdGFibGV0LCB0aGUgbmV3IHN0YXRlIGNvbnRlbnRzIHdpbGwgYmUgbG9hZGVkIGluIHNwbGl0LXBhbmUgY29udGVudHMgcGFuZS5cbiAqIEluIHBob25lLCB0aGUgbmV3IHN0YXRlIGNvbnRlbnRzIHdpbGwgYmUgbG9hZGVkIGluIGEgbmV3IHBhZ2UuXG4gKi9cbi5kaXJlY3RpdmUoJ21tU3BsaXRWaWV3TGluaycsIGZ1bmN0aW9uKCRsb2csICRpb25pY1BsYXRmb3JtLCAkc3RhdGUsICRtbUFwcCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbVNwbGl0Vmlld0xpbmsnKTtcblxuICAgIHZhciBzcmVmUmVnZXggPSBuZXcgUmVnRXhwKC8oW15cXChdKikoXFwoKC4qKVxcKSk/JC8pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0YXRlIGZvciB0YWJsZXQgdmlldyAoc3BsaXQtdmlldykuIFRoZSBzdGF0ZSBjcmVhdGVkIHdpbGwgYmUgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGUgdGFyZ2V0IHN0YXRlXG4gICAgICogKHN0YXRlTmFtZSksIGJ1dCBjaGFuZ2luZyB0aGUgbmFtZSBhbmQgdGhlIHZpZXcgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RhdGVOYW1lICAgICAgIE5hbWUgb2YgdGhlIHN0YXRlIHRvIGNvcHkuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0YWJsZXRTdGF0ZU5hbWUgTmFtZSBvZiB0aGUgbmV3IHN0YXRlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmV3Vmlld05hbWUgICAgIE5hbWUgb2YgdGhlIG5ldyB2aWV3LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgIFRydWUgaWYgc3VjY2VzcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRhYmxldFN0YXRlKHN0YXRlTmFtZSwgdGFibGV0U3RhdGVOYW1lLCBuZXdWaWV3TmFtZSkge1xuICAgICAgICB2YXIgdGFyZ2V0U3RhdGUgPSAkc3RhdGUuZ2V0KHN0YXRlTmFtZSksXG4gICAgICAgICAgICBuZXdDb25maWcsXG4gICAgICAgICAgICB2aWV3TmFtZTtcblxuICAgICAgICBpZiAodGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgICAgIG5ld0NvbmZpZyA9IGFuZ3VsYXIuY29weSh0YXJnZXRTdGF0ZSk7XG5cbiAgICAgICAgICAgIC8vIENoYW5nZSBmaXJzdCB2aWV3IG5hbWUgdG8gJ3RhYmxldCcgc28gaXQncyBsb2FkZWQgaW4gdGhlIHNwbGl0LXZpZXcgY29udGVudCBwYW5lLlxuICAgICAgICAgICAgdmlld05hbWUgPSBPYmplY3Qua2V5cyhuZXdDb25maWcudmlld3MpWzBdO1xuICAgICAgICAgICAgbmV3Q29uZmlnLnZpZXdzW25ld1ZpZXdOYW1lXSA9IG5ld0NvbmZpZy52aWV3c1t2aWV3TmFtZV07XG4gICAgICAgICAgICBkZWxldGUgbmV3Q29uZmlnLnZpZXdzW3ZpZXdOYW1lXTtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdDb25maWdbJ25hbWUnXTtcblxuICAgICAgICAgICAgJG1tQXBwLmNyZWF0ZVN0YXRlKHRhYmxldFN0YXRlTmFtZSwgbmV3Q29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignU3RhdGUgZG9lc25cXCd0IGV4aXN0OiAnK3N0YXRlTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBhIHN0cmluZyB1c2luZyBzY29wZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2NvcGUgU2NvcGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB2YWx1ZSBTdHJpbmcgdG8gZXZhbC5cbiAgICAgKiBAcmV0dXJuIHtNaXhlZH0gICAgICAgIEV2YWx1YXRlZCB2YWx1ZSBvciB1bmRlZmluZWQgaWYgbm90IHZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjb3BlRXZhbChzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuJGV2YWwodmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIGV2YWx1YXRpbmcgc3RyaW5nOiAnICsgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgcmVxdWlyZTogJ15tbVNwbGl0VmlldycsXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgc3BsaXRWaWV3Q29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIHNyZWYgPSBhdHRycy5tbVNwbGl0Vmlld0xpbmssXG4gICAgICAgICAgICAgICAgbWVudVN0YXRlID0gc3BsaXRWaWV3Q29udHJvbGxlci5nZXRNZW51U3RhdGUoKSxcbiAgICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgICAgIHN0YXRlTmFtZSxcbiAgICAgICAgICAgICAgICBzdGF0ZVBhcmFtcyxcbiAgICAgICAgICAgICAgICBzdGF0ZVBhcmFtc1N0cmluZyxcbiAgICAgICAgICAgICAgICB0YWJsZXRTdGF0ZU5hbWU7XG5cbiAgICAgICAgICAgIGlmIChzcmVmKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHNyZWYubWF0Y2goc3JlZlJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU5hbWUgPSBtYXRjaGVzWzFdOyAvLyBFLmcuIHNpdGUubW1fdXNlci1wcm9maWxlXG4gICAgICAgICAgICAgICAgICAgIHRhYmxldFN0YXRlTmFtZSA9IG1lbnVTdGF0ZSArICcuJyArIHN0YXRlTmFtZS5zdWJzdHIoc3RhdGVOYW1lLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVBhcmFtc1N0cmluZyA9IG1hdGNoZXNbM107IC8vIEUuZy4ge2NvdXJzZWlkOiBjb3Vyc2VpZCwgdXNlcmlkOiB1c2VyaWR9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlUGFyYW1zID0gc2NvcGVFdmFsKHNjb3BlLCBzdGF0ZVBhcmFtc1N0cmluZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2F0Y2ggZm9yIGNoYW5nZXMgb24gc3RhdGVQYXJhbXMuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChzdGF0ZVBhcmFtc1N0cmluZywgZnVuY3Rpb24obmV3VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVBhcmFtcyA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHN0YXRlLmdldCh0YWJsZXRTdGF0ZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXRlIGRvZXNuJ3QgZXhpc3RzLiBMZXQncyBjcmVhdGUgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3JlYXRlVGFibGV0U3RhdGUoc3RhdGVOYW1lLCB0YWJsZXRTdGF0ZU5hbWUsIHNwbGl0Vmlld0NvbnRyb2xsZXIuZ2V0Q29tcG9uZW50KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRWaWV3Q29udHJvbGxlci5zZXRMaW5rKGVsZW1lbnQpOyAvLyBTZXQgbGFzdCBsaW5rIGxvYWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdFZpZXdDb250cm9sbGVyLmNsZWFyTWFya2VkTGlua3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFkZENsYXNzKCdtbS1zcGxpdC1pdGVtLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKHRhYmxldFN0YXRlTmFtZSwgc3RhdGVQYXJhbXMsIHtsb2NhdGlvbjoncmVwbGFjZSd9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKHN0YXRlTmFtZSwgc3RhdGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdJbnZhbGlkIHNyZWYuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdJbnZhbGlkIHNyZWYuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY29udGVudGxpbmtzJywgW10pXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ21tX2NvbnRlbnRsaW5rcycsIHtcbiAgICAgICAgdXJsOiAnL21tX2NvbnRlbnRsaW5rcycsXG4gICAgICAgIGFic3RyYWN0OiB0cnVlLFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9jb250ZW50bGlua3MvdGVtcGxhdGVzL2Jhc2UuaHRtbCcsXG4gICAgICAgIGNhY2hlOiBmYWxzZSwgICAvLyBEaXNhYmxlIGNhY2hpbmcgdG8gZm9yY2UgY29udHJvbGxlciByZWxvYWQuXG4gICAgfSlcblxuICAgIC5zdGF0ZSgnbW1fY29udGVudGxpbmtzLmNob29zZXNpdGUnLCB7XG4gICAgICAgIHVybDogJy9jaG9vc2VzaXRlJyxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvY29udGVudGxpbmtzL3RlbXBsYXRlcy9jaG9vc2VzaXRlLmh0bWwnLFxuICAgICAgICBjb250cm9sbGVyOiAnbW1Db250ZW50TGlua3NDaG9vc2VTaXRlQ3RybCcsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdXJsOiBudWxsXG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZScsIFsnbW0uY29yZS5jb3Vyc2VzJ10pXG5cbi5jb25zdGFudCgnbW1Db3JlQ291cnNlUHJpb3JpdHknLCA4MDApXG4uY29uc3RhbnQoJ21tQ29yZUNvdXJzZUFsbFNlY3Rpb25zSWQnLCAtMSlcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJG1tQ291cnNlc0RlbGVnYXRlUHJvdmlkZXIsIG1tQ29yZUNvdXJzZVByaW9yaXR5KSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1tX2NvdXJzZScsIHtcbiAgICAgICAgdXJsOiAnL21tX2NvdXJzZScsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgY291cnNlaWQ6IG51bGwsXG4gICAgICAgICAgICBzaWQ6IG51bGwsIC8vIFNlY3Rpb24gdG8gbG9hZC4gTm90IG5hbWluZyBpdCBzZWN0aW9uaWQgYmVjYXVzZSBpdCBjb2xsaWRlcyB3aXRoICdtbV9jb3Vyc2Utc2VjdGlvbicgcGFyYW0gaW4gc3BsaXQtdmlldy5cbiAgICAgICAgICAgIG1vZHVsZWlkOiBudWxsIC8vIE1vZHVsZSB0byBsb2FkLlxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvY291cnNlL3RlbXBsYXRlcy9zZWN0aW9ucy5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1Db3Vyc2VTZWN0aW9uc0N0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1tX2NvdXJzZS1zZWN0aW9uJywge1xuICAgICAgICB1cmw6ICcvbW1fY291cnNlLXNlY3Rpb24nLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHNlY3Rpb25pZDogbnVsbCxcbiAgICAgICAgICAgIGNpZDogbnVsbCwgLy8gTm90IG5hbWluZyBpdCBjb3Vyc2VpZCBiZWNhdXNlIGl0IGNvbGxpZGVzIHdpdGggJ3NpdGUubW1fY291cnNlJyBwYXJhbSBpbiBzcGxpdC12aWV3LlxuICAgICAgICAgICAgbWlkOiBudWxsIC8vIE5vdCBuYW1pbmcgaXQgbW9kdWxlaWQgYmVjYXVzZSBpdCBjb2xsaWRlcyB3aXRoICdzaXRlLm1tX2NvdXJzZScgcGFyYW0gaW4gc3BsaXQtdmlldy5cbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2NvdXJzZS90ZW1wbGF0ZXMvc2VjdGlvbi5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1Db3Vyc2VTZWN0aW9uQ3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ3NpdGUubW1fY291cnNlLW1vZGNvbnRlbnQnLCB7XG4gICAgICAgIHVybDogJy9tbV9jb3Vyc2UtbW9kY29udGVudCcsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgbW9kdWxlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICBzaXRlOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvY291cnNlL3RlbXBsYXRlcy9tb2Rjb250ZW50Lmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbUNvdXJzZU1vZENvbnRlbnRDdHJsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkbW1Db3Vyc2VzRGVsZWdhdGVQcm92aWRlci5yZWdpc3Rlck5hdkhhbmRsZXIoJ21tQ291cnNlJywgJyRtbUNvdXJzZUNvdXJzZXNOYXZIYW5kbGVyJywgbW1Db3JlQ291cnNlUHJpb3JpdHkpO1xufSlcblxuLnJ1bihmdW5jdGlvbigkbW1FdmVudHMsIG1tQ29yZUV2ZW50TG9naW4sIG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsICRtbUNvdXJzZURlbGVnYXRlKSB7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9naW4sICRtbUNvdXJzZURlbGVnYXRlLnVwZGF0ZUNvbnRlbnRIYW5kbGVycyk7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsICRtbUNvdXJzZURlbGVnYXRlLnVwZGF0ZUNvbnRlbnRIYW5kbGVycyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2VzJywgW10pXG5cbi5jb25zdGFudCgnbW1Db3Vyc2VzU2VhcmNoQ29tcG9uZW50JywgJ21tQ291cnNlc1NlYXJjaCcpXG4uY29uc3RhbnQoJ21tQ291cnNlc1NlYXJjaFBlclBhZ2UnLCAyMCkgLy8gTWF4IG9mIGNvdXJzZXMgcGVyIHBhZ2Ugd2hlbiBzZWFyY2hpbmcgY291cnNlcy5cbi5jb25zdGFudCgnbW1Db3Vyc2VzRW5yb2xJbnZhbGlkS2V5JywgJ21tQ291cnNlc0Vucm9sSW52YWxpZEtleScpXG4uY29uc3RhbnQoJ21tQ291cnNlc0V2ZW50TXlDb3Vyc2VzVXBkYXRlZCcsICdteV9jb3Vyc2VzX3VwZGF0ZWQnKVxuLmNvbnN0YW50KCdtbUNvdXJzZXNBY2Nlc3NNZXRob2RzJywge1xuICAgICBndWVzdDogJ2d1ZXN0JyxcbiAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1tX2NvdXJzZXMnLCB7XG4gICAgICAgIHVybDogJy9tbV9jb3Vyc2VzJyxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2NvdXJzZXMvdGVtcGxhdGVzL2xpc3QuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tQ291cnNlc0xpc3RDdHJsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tbV9zZWFyY2hjb3Vyc2VzJywge1xuICAgICAgICB1cmw6ICcvbW1fc2VhcmNoY291cnNlcycsXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9jb3Vyc2VzL3RlbXBsYXRlcy9zZWFyY2guaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tQ291cnNlc1NlYXJjaEN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1tX3ZpZXdyZXN1bHQnLCB7XG4gICAgICAgIHVybDogJy9tbV92aWV3cmVzdWx0JyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBjb3Vyc2U6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2NvdXJzZXMvdGVtcGxhdGVzL3ZpZXdyZXN1bHQuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tQ291cnNlc1ZpZXdSZXN1bHRDdHJsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1Db3Vyc2VzJywgJyRtbUNvdXJzZXNIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pXG5cbi5ydW4oZnVuY3Rpb24oJG1tRXZlbnRzLCBtbUNvcmVFdmVudExvZ2luLCBtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCBtbUNvcmVFdmVudExvZ291dCwgJG1tQ291cnNlc0RlbGVnYXRlLCAkbW1Db3Vyc2VzKSB7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9naW4sICRtbUNvdXJzZXNEZWxlZ2F0ZS51cGRhdGVOYXZIYW5kbGVycyk7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsICRtbUNvdXJzZXNEZWxlZ2F0ZS51cGRhdGVOYXZIYW5kbGVycyk7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9nb3V0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tQ291cnNlc0RlbGVnYXRlLmNsZWFyQ291cnNlc0hhbmRsZXJzKCk7XG4gICAgICAgICRtbUNvdXJzZXMuY2xlYXJDdXJyZW50Q291cnNlcygpO1xuICAgIH0pO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUubG9naW4nLCBbXSlcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJHVybFJvdXRlclByb3ZpZGVyLCAkbW1Jbml0RGVsZWdhdGVQcm92aWRlciwgbW1Jbml0RGVsZWdhdGVNYXhBZGRvblByaW9yaXR5KSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdtbV9sb2dpbicsIHtcbiAgICAgICAgdXJsOiAnL21tX2xvZ2luJyxcbiAgICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2xvZ2luL3RlbXBsYXRlcy9iYXNlLmh0bWwnLFxuICAgICAgICBjYWNoZTogZmFsc2UsICAgLy8gRGlzYWJsZSBjYWNoaW5nIHRvIGZvcmNlIGNvbnRyb2xsZXIgcmVsb2FkLlxuICAgICAgICBvbkVudGVyOiBmdW5jdGlvbigkaW9uaWNIaXN0b3J5KSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBoaXN0b3J5IHN0YWNrIHdoZW4gZ2V0dGluZyBoZXJlLlxuICAgICAgICAgICAgJGlvbmljSGlzdG9yeS5jbGVhckhpc3RvcnkoKTtcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ21tX2xvZ2luLmluaXQnLCB7XG4gICAgICAgIHVybDogJy9pbml0JyxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvbG9naW4vdGVtcGxhdGVzL2luaXQuaHRtbCcsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdtbUxvZ2luSW5pdEN0cmwnLFxuICAgICAgICBjYWNoZTogZmFsc2UgLy8gRGlzYWJsZSBjYWNoaW5nIHRvIGZvcmNlIGNvbnRyb2xsZXIgcmVsb2FkLlxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ21tX2xvZ2luLnNpdGVzJywge1xuICAgICAgICB1cmw6ICcvc2l0ZXMnLFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9sb2dpbi90ZW1wbGF0ZXMvc2l0ZXMuaHRtbCcsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdtbUxvZ2luU2l0ZXNDdHJsJyxcbiAgICAgICAgb25FbnRlcjogZnVuY3Rpb24oJG1tTG9naW5IZWxwZXIsICRtbVNpdGVzTWFuYWdlcikge1xuICAgICAgICAgICAgLy8gU2tpcCB0aGlzIHBhZ2UgaWYgdGhlcmUgYXJlIG5vIHNpdGVzIHlldC5cbiAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5oYXNOb1NpdGVzKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbW1Mb2dpbkhlbHBlci5nb1RvQWRkU2l0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdtbV9sb2dpbi5zaXRlJywge1xuICAgICAgICB1cmw6ICcvc2l0ZScsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2xvZ2luL3RlbXBsYXRlcy9zaXRlLmh0bWwnLFxuICAgICAgICBjb250cm9sbGVyOiAnbW1Mb2dpblNpdGVDdHJsJ1xuICAgIH0pXG5cbiAgICAuc3RhdGUoJ21tX2xvZ2luLmNyZWRlbnRpYWxzJywge1xuICAgICAgICB1cmw6ICcvY3JlZCcsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2xvZ2luL3RlbXBsYXRlcy9jcmVkZW50aWFscy5odG1sJyxcbiAgICAgICAgY29udHJvbGxlcjogJ21tTG9naW5DcmVkZW50aWFsc0N0cmwnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHNpdGV1cmw6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uKCRzdGF0ZSwgJHN0YXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgYWxsb3cgYWNjZXNzIHRvIHRoaXMgcGFnZSB3aGVuIHRoZSBVUkwgd2FzIG5vdCBwYXNzZWQuXG4gICAgICAgICAgICBpZiAoISRzdGF0ZVBhcmFtcy5zaXRldXJsKSB7XG4gICAgICAgICAgICAgICRzdGF0ZS5nbygnbW1fbG9naW4uaW5pdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnbW1fbG9naW4ucmVjb25uZWN0Jywge1xuICAgICAgICB1cmw6ICcvcmVjb25uZWN0JyxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvbG9naW4vdGVtcGxhdGVzL3JlY29ubmVjdC5odG1sJyxcbiAgICAgICAgY29udHJvbGxlcjogJ21tTG9naW5SZWNvbm5lY3RDdHJsJyxcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHNpdGV1cmw6ICcnLFxuICAgICAgICAgICAgdXNlcm5hbWU6ICcnLFxuICAgICAgICAgICAgaW5mb3NpdGV1cmw6ICcnXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERlZmF1bHQgcmVkaXJlY3QgdG8gdGhlIGxvZ2luIHBhZ2UuXG4gICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZShmdW5jdGlvbigkaW5qZWN0b3IpIHtcbiAgICAgICAgdmFyICRzdGF0ZSA9ICRpbmplY3Rvci5nZXQoJyRzdGF0ZScpO1xuICAgICAgICByZXR1cm4gJHN0YXRlLmhyZWYoJ21tX2xvZ2luLmluaXQnKS5yZXBsYWNlKCcjJywgJycpO1xuICAgIH0pO1xuXG4gICAgLy8gUmVzdG9yZSB0aGUgc2Vzc2lvbi5cbiAgICAkbW1Jbml0RGVsZWdhdGVQcm92aWRlci5yZWdpc3RlclByb2Nlc3MoJ21tTG9naW4nLCAnJG1tU2l0ZXNNYW5hZ2VyLnJlc3RvcmVTZXNzaW9uJywgbW1Jbml0RGVsZWdhdGVNYXhBZGRvblByaW9yaXR5ICsgMjAwKTtcbn0pXG5cbi5ydW4oZnVuY3Rpb24oJGxvZywgJHN0YXRlLCAkbW1VdGlsLCAkdHJhbnNsYXRlLCAkbW1TaXRlc01hbmFnZXIsICRyb290U2NvcGUsICRtbVNpdGUsICRtbVVSTERlbGVnYXRlLCAkaW9uaWNIaXN0b3J5LFxuICAgICAgICAgICAgICAgICRtbUV2ZW50cywgJG1tTG9naW5IZWxwZXIsIG1tQ29yZUV2ZW50U2Vzc2lvbkV4cGlyZWQsICRtbUFwcCkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tTG9naW4nKTtcblxuICAgIC8vIExpc3RlbiBmb3Igc2Vzc2lvbkV4cGlyZWQgZXZlbnQgdG8gcmVjb25uZWN0IHRoZSB1c2VyLlxuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFNlc3Npb25FeHBpcmVkLCBzZXNzaW9uRXhwaXJlZCk7XG5cbiAgICAvLyBSZWdpc3RlciBvYnNlcnZlciB0byBjaGVjayBpZiB0aGUgYXBwIHdhcyBsYXVuY2hlZCB2aWEgVVJMIHNjaGVtZS5cbiAgICAkbW1VUkxEZWxlZ2F0ZS5yZWdpc3RlcignbW1Mb2dpblNTTycsIGFwcExhdW5jaGVkQnlVUkwpO1xuXG4gICAgLy8gUmVkaXJlY3QgZGVwZW5kaW5nIG9uIHVzZXIgc2Vzc2lvbi5cbiAgICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbihldmVudCwgdG9TdGF0ZSwgdG9QYXJhbXMsIGZyb21TdGF0ZSwgZnJvbVBhcmFtcykge1xuXG4gICAgICAgIC8vIFByZXZlbnQgc3RhdGUgY2hhbmdlcyB3aGlsZSB0aGUgYXBwIGlzIG5vdCByZWFkeS5cbiAgICAgICAgaWYgKCEkbW1BcHAuaXNSZWFkeSgpICYmIHRvU3RhdGUubmFtZSAhPT0gJ21tX2xvZ2luLmluaXQnKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbygnbW1fbG9naW4uaW5pdCcpO1xuICAgICAgICAgICAgJGxvZy53YXJuKCdGb3JiaWRkaW5nIHN0YXRlIGNoYW5nZSB0byBcXCcnICsgdG9TdGF0ZS5uYW1lICsgJ1xcJy4gQXBwIGlzIG5vdCByZWFkeSB5ZXQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9TdGF0ZS5uYW1lLnN1YnN0cigwLCA4KSA9PT0gJ3JlZGlyZWN0JyB8fMKgdG9TdGF0ZS5uYW1lLnN1YnN0cigwLCAxNSkgPT09ICdtbV9jb250ZW50bGlua3MnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoKHRvU3RhdGUubmFtZS5zdWJzdHIoMCwgOCkgIT09ICdtbV9sb2dpbicgfHwgdG9TdGF0ZS5uYW1lID09PSAnbW1fbG9naW4ucmVjb25uZWN0JykgJiYgISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgbm90IGxvZ2dlZCBpbi5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdSZWRpcmVjdCB0byBsb2dpbiBwYWdlLCByZXF1ZXN0IHdhczogJyArIHRvU3RhdGUubmFtZSk7XG4gICAgICAgICAgICAvLyBEaXNhYmxlIGFuaW1hdGlvbiBhbmQgYmFjayBidXR0b24gZm9yIHRoZSBuZXh0IHRyYW5zaXRpb24uXG4gICAgICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUFuaW1hdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUJhY2s6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbygnbW1fbG9naW4uaW5pdCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRvU3RhdGUubmFtZS5zdWJzdHIoMCwgOCkgPT09ICdtbV9sb2dpbicgJiYgdG9TdGF0ZS5uYW1lICE9PSAnbW1fbG9naW4ucmVjb25uZWN0JyAmJiAkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIGxvZ2dlZCBpbiBhbmQgcmVxdWVzdGVkIHRoZSBsb2dpbiBwYWdlLlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1JlZGlyZWN0IHRvIGNvdXJzZSBwYWdlLCByZXF1ZXN0IHdhczogJyArIHRvU3RhdGUubmFtZSk7XG4gICAgICAgICAgICAvLyBEaXNhYmxlIGFuaW1hdGlvbiBhbmQgYmFjayBidXR0b24gZm9yIHRoZSBuZXh0IHRyYW5zaXRpb24uXG4gICAgICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUFuaW1hdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUJhY2s6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHN0YXRlLnRyYW5zaXRpb25Ubygnc2l0ZS5tbV9jb3Vyc2VzJyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gRnVuY3Rpb24gdG8gaGFuZGxlIHNlc3Npb24gZXhwaXJlZCBldmVudHMuXG4gICAgZnVuY3Rpb24gc2Vzc2lvbkV4cGlyZWQoc2l0ZWlkKSB7XG5cbiAgICAgICAgdmFyIHNpdGV1cmwgPSAkbW1TaXRlLmdldFVSTCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2Yoc2l0ZXVybCkgIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgICAgIGlmIChzaXRlaWQgJiYgc2l0ZWlkICE9PSAkbW1TaXRlLmdldElkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFNpdGUgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50IGlzIG5vdCBjdXJyZW50IHNpdGUuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGF1dGhlbnRpY2F0aW9uIG1ldGhvZC5cbiAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5jaGVja1NpdGUoc2l0ZXVybCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQud2FybmluZykge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKHJlc3VsdC53YXJuaW5nLCB0cnVlLCA0MDAwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoJG1tTG9naW5IZWxwZXIuaXNTU09Mb2dpbk5lZWRlZChyZXN1bHQuY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU1NPLiBVc2VyIG5lZWRzIHRvIGF1dGhlbnRpY2F0ZSBpbiBhIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSgnbW0ubG9naW4ucmVjb25uZWN0c3NvZGVzY3JpcHRpb24nKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbUxvZ2luSGVscGVyLm9wZW5Ccm93c2VyRm9yU1NPTG9naW4ocmVzdWx0LnNpdGV1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9ICRtbVNpdGUuZ2V0SW5mbygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGluZm8pICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YoaW5mby51c2VybmFtZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7ZGlzYWJsZUJhY2s6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnbW1fbG9naW4ucmVjb25uZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c2l0ZXVybDogcmVzdWx0LnNpdGV1cmwsIHVzZXJuYW1lOiBpbmZvLnVzZXJuYW1lLCBpbmZvc2l0ZXVybDogaW5mby5zaXRldXJsfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uIHRvIGhhbmRsZSBVUkwgcmVjZWl2ZWQgYnkgQ3VzdG9tIFVSTCBTY2hlbWUuIElmIGl0J3MgYSBTU08gbG9naW4sIHBlcmZvcm0gYXV0aGVudGljYXRpb24uXG4gICAgZnVuY3Rpb24gYXBwTGF1bmNoZWRCeVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIHNzb1NjaGVtZSA9ICdtb29kbGVtb2JpbGU6Ly90b2tlbj0nO1xuICAgICAgICBpZiAodXJsLmluZGV4T2Yoc3NvU2NoZW1lKSA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwIG9wZW5lZCB1c2luZyBjdXN0b20gVVJMIHNjaGVtZS4gUHJvYmFibHkgYW4gU1NPIGF1dGhlbnRpY2F0aW9uLlxuICAgICAgICAkbG9nLmRlYnVnKCdBcHAgbGF1bmNoZWQgYnkgVVJMJyk7XG5cbiAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbS5sb2dpbi5hdXRoZW50aWNhdGluZycsIHRydWUpO1xuXG4gICAgICAgIC8vIERlbGV0ZSB0aGUgc3NvIHNjaGVtZSBmcm9tIHRoZSBVUkwuXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKHNzb1NjaGVtZSwgJycpO1xuICAgICAgICAvLyBEZWNvZGUgZnJvbSBiYXNlNjQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cmwgPSBhdG9iKHVybCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAvLyBFcnJvciBkZWNvZGluZyB0aGUgcGFyYW1ldGVyLlxuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgZGVjb2RpbmcgcGFyYW1ldGVyIHJlY2VpdmVkIGZvciBsb2dpbiBTU08nKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgICRtbUxvZ2luSGVscGVyLnZhbGlkYXRlQnJvd3NlclNTT0xvZ2luKHVybCkudGhlbihmdW5jdGlvbihzaXRlZGF0YSkge1xuXG4gICAgICAgICAgICAkbW1Mb2dpbkhlbHBlci5oYW5kbGVTU09Mb2dpbkF1dGhlbnRpY2F0aW9uKHNpdGVkYXRhLnNpdGV1cmwsIHNpdGVkYXRhLnRva2VuKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tbV9jb3Vyc2VzJyk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZXJyb3JNZXNzYWdlKSA9PT0gJ3N0cmluZycgJiYgZXJyb3JNZXNzYWdlICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5zZXR0aW5ncycsIFtdKVxuXG4uY29uc3RhbnQoJ21tQ29yZVNldHRpbmdzRG93bmxvYWRTZWN0aW9uJywgJ21tQ29yZVNldHRpbmdzRG93bmxvYWRTZWN0aW9uJylcbi5jb25zdGFudCgnbW1Db3JlU2V0dGluZ3NSZXBvcnRJbkJhY2tncm91bmQnLCAnbW1Db3JlUmVwb3J0SW5CYWNrZ3JvdW5kJylcbi5jb25zdGFudCgnbW1Db3JlU2V0dGluZ3NTeW5jT25seU9uV2lmaScsICdtbUNvcmVTeW5jT25seU9uV2lmaScpXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW1fc2V0dGluZ3MnLCB7XG4gICAgICAgIHVybDogJy9tbV9zZXR0aW5ncycsXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9zZXR0aW5ncy90ZW1wbGF0ZXMvbGlzdC5odG1sJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tbV9zZXR0aW5ncy1hYm91dCcsIHtcbiAgICAgICAgdXJsOiAnL21tX3NldHRpbmdzLWFib3V0JyxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL3NldHRpbmdzL3RlbXBsYXRlcy9hYm91dC5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1TZXR0aW5nc0Fib3V0Q3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ3NpdGUubW1fc2V0dGluZ3MtZ2VuZXJhbCcsIHtcbiAgICAgICAgdXJsOiAnL21tX3NldHRpbmdzLWdlbmVyYWwnLFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvc2V0dGluZ3MvdGVtcGxhdGVzL2dlbmVyYWwuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tU2V0dGluZ3NHZW5lcmFsQ3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ3NpdGUubW1fc2V0dGluZ3Mtc3BhY2V1c2FnZScsIHtcbiAgICAgICAgdXJsOiAnL21tX3NldHRpbmdzLXNwYWNldXNhZ2UnLFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvc2V0dGluZ3MvdGVtcGxhdGVzL3NwYWNlLXVzYWdlLmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbVNldHRpbmdzU3BhY2VVc2FnZUN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1tX3NldHRpbmdzLXN5bmNocm9uaXphdGlvbicsIHtcbiAgICAgICAgdXJsOiAnL21tX3NldHRpbmdzLXN5bmNocm9uaXphdGlvbicsXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9zZXR0aW5ncy90ZW1wbGF0ZXMvc3luY2hyb25pemF0aW9uLmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbVNldHRpbmdzU3luY2hyb25pemF0aW9uQ3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5zaWRlbWVudScsIFtdKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlJywge1xuICAgICAgICB1cmw6ICcvc2l0ZScsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL3NpZGVtZW51L3RlbXBsYXRlcy9tZW51Lmh0bWwnLFxuICAgICAgICBjb250cm9sbGVyOiAnbW1TaWRlTWVudUN0cmwnLFxuICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICBvbkVudGVyOiBmdW5jdGlvbigkaW9uaWNIaXN0b3J5LCAkc3RhdGUsICRtbVNpdGUsICR0aW1lb3V0KSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxvZ2luIHBhZ2UgZnJvbSB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICAgICAgICAgICRpb25pY0hpc3RvcnkuY2xlYXJIaXN0b3J5KCk7XG5cbiAgICAgICAgICAgIC8vIEdvIHRvIGxvZ2luIGlmIHVzZXIgaXMgbm90IGxvZ2dlZCBpbi5cbiAgICAgICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ21tX2xvZ2luLmluaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4ucnVuKGZ1bmN0aW9uKCRtbUV2ZW50cywgbW1Db3JlRXZlbnRMb2dpbiwgbW1Db3JlRXZlbnRTaXRlVXBkYXRlZCwgbW1Db3JlRXZlbnRMb2dvdXQsICRtbVNpZGVNZW51RGVsZWdhdGUpIHtcbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRMb2dpbiwgJG1tU2lkZU1lbnVEZWxlZ2F0ZS51cGRhdGVOYXZIYW5kbGVycyk7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsICRtbVNpZGVNZW51RGVsZWdhdGUudXBkYXRlTmF2SGFuZGxlcnMpO1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudExvZ291dCwgJG1tU2lkZU1lbnVEZWxlZ2F0ZS5jbGVhclNpdGVIYW5kbGVycyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS50ZXh0dmlld2VyJywgW10pXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW1fdGV4dHZpZXdlcicsIHtcbiAgICAgICAgdXJsOiAnL21tX3RleHR2aWV3ZXInLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgICAgICAgY29udGVudDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvdGV4dHZpZXdlci90ZW1wbGF0ZXMvdGV4dHZpZXdlci5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1UZXh0Vmlld2VySW5kZXhDdHJsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLnVzZXInLCBbXSlcblxuLnZhbHVlKCdtbVVzZXJQcm9maWxlU3RhdGUnLCAnc2l0ZS5tbV91c2VyLXByb2ZpbGUnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgICAgIC5zdGF0ZSgnc2l0ZS5tbV91c2VyLXByb2ZpbGUnLCB7XG4gICAgICAgICAgICB1cmw6ICcvbW1fdXNlci1wcm9maWxlJyxcbiAgICAgICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbVVzZXJQcm9maWxlQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL3VzZXIvdGVtcGxhdGVzL3Byb2ZpbGUuaHRtbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgY291cnNlaWQ6IDAsXG4gICAgICAgICAgICAgICAgdXNlcmlkOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgY29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1Vc2VyJywgJyRtbVVzZXJIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcblxufSlcblxuLnJ1bihmdW5jdGlvbigkbW1FdmVudHMsIG1tQ29yZUV2ZW50TG9naW4sIG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsICRtbVVzZXJEZWxlZ2F0ZSwgJG1tU2l0ZSwgbW1Db3JlRXZlbnRVc2VyRGVsZXRlZCwgJG1tVXNlcikge1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudExvZ2luLCAkbW1Vc2VyRGVsZWdhdGUudXBkYXRlUHJvZmlsZUhhbmRsZXJzKTtcbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRTaXRlVXBkYXRlZCwgJG1tVXNlckRlbGVnYXRlLnVwZGF0ZVByb2ZpbGVIYW5kbGVycyk7XG5cbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRVc2VyRGVsZXRlZCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5zaXRlaWQgJiYgZGF0YS5zaXRlaWQgPT09ICRtbVNpdGUuZ2V0SWQoKSAmJiBkYXRhLnBhcmFtcykge1xuICAgICAgICAgICAgLy8gU2VhcmNoIGZvciB1c2VyaWQgaW4gcGFyYW1zLlxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGRhdGEucGFyYW1zLFxuICAgICAgICAgICAgICAgIHVzZXJpZCA9IDA7XG4gICAgICAgICAgICBpZiAocGFyYW1zLnVzZXJpZCkge1xuICAgICAgICAgICAgICAgIHVzZXJpZCA9IHBhcmFtcy51c2VyaWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy51c2VyaWRzKSB7XG4gICAgICAgICAgICAgICAgdXNlcmlkID0gcGFyYW1zLnVzZXJpZHNbMF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5maWVsZCA9PT0gJ2lkJyAmJiBwYXJhbXMudmFsdWVzICYmIHBhcmFtcy52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdXNlcmlkID0gcGFyYW1zLnZhbHVlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnVzZXJsaXN0ICYmIHBhcmFtcy51c2VybGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB1c2VyaWQgPSBwYXJhbXMudXNlcmxpc3RbMF0udXNlcmlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1c2VyaWQgPSBwYXJzZUludCh1c2VyaWQpO1xuICAgICAgICAgICAgaWYgKHVzZXJpZCA+IDApIHtcbiAgICAgICAgICAgICAgICAkbW1Vc2VyLmRlbGV0ZVN0b3JlZFVzZXIodXNlcmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY29udGVudGxpbmtzJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGNob29zZSBhbiBhY2NvdW50IHRvIGhhbmRsZSBjb250ZW50IGxpbmtzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb250ZW50bGlua3NcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbUNvbnRlbnRMaW5rc0Nob29zZVNpdGVDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbUNvbnRlbnRMaW5rc0Nob29zZVNpdGVDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbVNpdGVzTWFuYWdlciwgJG1tVXRpbCwgJGlvbmljSGlzdG9yeSwgJHN0YXRlLCAkcSxcbiAgICAgICAgICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlLCAkbW1Db250ZW50TGlua3NIZWxwZXIpIHtcblxuICAgICRzY29wZS51cmwgPSAkc3RhdGVQYXJhbXMudXJsIHx8wqAnJztcblxuICAgIHZhciBhY3Rpb247XG5cbiAgICBmdW5jdGlvbiBsZWF2ZVZpZXcoKSB7XG4gICAgICAgICRtbVNpdGVzTWFuYWdlci5sb2dvdXQoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGRpc2FibGVBbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVCYWNrOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzdGF0ZS5nbygnbW1fbG9naW4uc2l0ZXMnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCEkc2NvcGUudXJsKSB7XG4gICAgICAgIGxlYXZlVmlldygpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGUuZ2V0QWN0aW9uc0Zvcigkc2NvcGUudXJsKS50aGVuKGZ1bmN0aW9uKGFjdGlvbnMpIHtcbiAgICAgICAgYWN0aW9uID0gJG1tQ29udGVudExpbmtzSGVscGVyLmdldEZpcnN0VmFsaWRBY3Rpb24oYWN0aW9ucyk7XG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZXMoYWN0aW9uLnNpdGVzKS50aGVuKGZ1bmN0aW9uKHNpdGVzKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2l0ZXMgPSBzaXRlcztcbiAgICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvbnRlbnRsaW5rcy5lcnJvcm5vc2l0ZXMnLCB0cnVlKTtcbiAgICAgICAgbGVhdmVWaWV3KCk7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuc2l0ZUNsaWNrZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgYWN0aW9uLmFjdGlvbihzaXRlSWQpO1xuICAgIH07XG5cbiAgICAkc2NvcGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxlYXZlVmlldygpO1xuICAgIH07XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvbnRlbnRsaW5rcycpXG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgbGlua3MgZm91bmQgaW4gY29udGVudHMuIEFsbG93cyB0byBjYXB0dXJlIGxpbmtzIGluIGNvbnRlbnQgYW5kIHJlZGlyZWN0IHRvIGNlcnRhaW4gcGFydHNcbiAqIG9mIHRoZSBhcHAgaW5zdGVhZCBvZiBvcGVuaW5nIHRoZW0gaW4gYnJvd3Nlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuY29udGVudGxpbmtzXG4gKiBAbmdkb2MgcHJvdmlkZXJcbiAqIEBuYW1lICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlXG4gKi9cbi5wcm92aWRlcignJG1tQ29udGVudExpbmtzRGVsZWdhdGUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGlua0hhbmRsZXJzID0ge30sXG4gICAgICAgIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgbGluayBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvbnRlbnRsaW5rc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyI3JlZ2lzdGVyTGlua0hhbmRsZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgICAgICAgICAgICAgICAgICAgSGFuZGxlcidzIG5hbWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEZ1bmN0aW9ufSBoYW5kbGVyIE11c3QgYmUgcmVzb2x2ZWQgdG8gYW4gb2JqZWN0IGRlZmluaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zLiBPciB0byBhIGZ1bmN0aW9uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuaW5nIGFuIG9iamVjdCBkZWZpbmluZyB0aGVzZSBmdW5jdGlvbnMuIFNlZSB7QGxpbmsgJG1tVXRpbCNyZXNvbHZlT2JqZWN0fS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBnZXRBY3Rpb25zKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIChQcm9taXNlKSBSZXR1cm5zIGxpc3Qgb2YgYWN0aW9ucy4gRWFjaCBhY3Rpb24gbXVzdCBoYXZlOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1lc3NhZ2U6IE1lc3NhZ2UgcmVsYXRlZCB0byB0aGUgYWN0aW9uIHRvIGRvLiBFLmcuICdWaWV3Jy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBpY29uOiBJY29uIHJlbGF0ZWQgdG8gdGhlIGFjdGlvbiB0byBkby5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBzaXRlczogU2l0ZXMgSURzIHRoYXQgc3VwcG9ydCB0aGUgYWN0aW9uLiBTdWJzZXQgb2YgJ3NpdGVJZHMnLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGFjdGlvbihzaXRlSWQpOiBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBsaW5rIGlzIGNsaWNrZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eV0gICAgICAgICAgICAgIEhhbmRsZXIncyBwcmlvcml0eS5cbiAgICAgKi9cbiAgICBzZWxmLnJlZ2lzdGVyTGlua0hhbmRsZXIgPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyLCBwcmlvcml0eSkge1xuICAgICAgICBpZiAodHlwZW9mIGxpbmtIYW5kbGVyc1tuYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcjogQWRkb24gJ1wiICsgbGlua0hhbmRsZXJzW25hbWVdLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInIGFscmVhZHkgcmVnaXN0ZXJlZCBhcyBsaW5rIGhhbmRsZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCIkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyOiBSZWdpc3RlcmVkIGhhbmRsZXIgJ1wiICsgbmFtZSArIFwiJyBhcyBsaW5rIGhhbmRsZXIuXCIpO1xuICAgICAgICBsaW5rSGFuZGxlcnNbbmFtZV0gPSB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICAgIGluc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmlvcml0eTogdHlwZW9mIHByaW9yaXR5ID09PSAndW5kZWZpbmVkJyA/IDEwMCA6IHByaW9yaXR5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBzZWxmLiRnZXQgPSBmdW5jdGlvbigkbW1VdGlsLCAkbG9nLCAkcSwgJG1tU2l0ZXNNYW5hZ2VyKSB7XG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGlzdCBvZiBwb3NzaWJsZSBhY3Rpb25zIHRvIGRvIGZvciBhIFVSTC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLmNvbnRlbnRsaW5rc1xuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI2dldExpbmtIYW5kbGVyc0ZvclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gaGFuZGxlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLiBPcHRpb25hbCBidXQgcmVjb21tZW5kZWQgc2luY2Ugc29tZSBoYW5kbGVycyBtaWdodCByZXF1aXJlXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGtub3cgdGhlIGNvdXJzZWlkIGlmIE1vb2RsZSB2ZXJzaW9uIGlzIHByZXZpb3VzIHRvIDMuMC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBhY3Rpb25zLiBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zRm9yID0gZnVuY3Rpb24odXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGlzdCBvZiBzaXRlcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGVJZHNGcm9tVXJsKHVybCwgdHJ1ZSkudGhlbihmdW5jdGlvbihzaXRlSWRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtBY3Rpb25zID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobGlua0hhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5pbnN0YW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuaW5zdGFuY2UgPSAkbW1VdGlsLnJlc29sdmVPYmplY3QoaGFuZGxlci5oYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRxLndoZW4oaGFuZGxlci5pbnN0YW5jZS5nZXRBY3Rpb25zKHNpdGVJZHMsIHVybCwgY291cnNlSWQpKS50aGVuKGZ1bmN0aW9uKGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9ucyAmJiBhY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rQWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBoYW5kbGVyLnByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1VdGlsLmFsbFByb21pc2VzKHByb21pc2VzKS5jYXRjaChmdW5jdGlvbigpIHt9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IGxpbmsgYWN0aW9ucyBieSBwcmlvcml0eS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRBY3Rpb25zQnlQcmlvcml0eShsaW5rQWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU29ydCBhY3Rpb25zIGJ5IHByaW9yaXR5LiBFYWNoIG9iamVjdCBpbiB0aGUgYWN0aW9ucyBwYXJhbSBtdXN0IGhhdmUgYSBwcmlvcml0eSBhbmQgYSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqIFRoZSByZXR1cm5lZCBhcnJheSBvbmx5IGNvbnRhaW5zIHRoZSBhY3Rpb25zIG9yZGVyZWQgYnkgcHJpb3JpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdFtdfSBhY3Rpb25zIEFjdGlvbnMgdG8gc29ydC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0W119ICAgICAgICAgU29ydGVkIGFjdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzb3J0QWN0aW9uc0J5UHJpb3JpdHkoYWN0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNvcnRlZCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBTb3J0IGJ5IHByaW9yaXR5LlxuICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgPiBiLnByaW9yaXR5O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZpbGwgcmVzdWx0IGFycmF5LlxuICAgICAgICAgICAgYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgc29ydGVkID0gc29ydGVkLmNvbmNhdChlbnRyeS5hY3Rpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvbnRlbnRsaW5rcycpXG5cbi8qKlxuICogU2VydmljZSB0byBwcm92aWRlIHNvbWUgaGVscGVyIGZ1bmN0aW9uYWxpdGllcyBmb3IgdGhlIGNvbnRlbnRsaW5rcyBjb21wb25lbnQuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvbnRlbnRsaW5rc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUNvbnRlbnRMaW5rc0hlbHBlclxuICovXG4uZmFjdG9yeSgnJG1tQ29udGVudExpbmtzSGVscGVyJywgZnVuY3Rpb24oJGxvZywgJGlvbmljSGlzdG9yeSwgJHN0YXRlLCAkbW1TaXRlLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSwgJG1tVXRpbCwgJHRyYW5zbGF0ZSxcbiAgICAgICAgICAgICRtbUNvdXJzZUhlbHBlcikge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUNvbnRlbnRMaW5rc0hlbHBlcicpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgc2l0ZXMgYmFzZWQgb24gYSBpc0VuYWJsZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY29udGVudGxpbmtzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvbnRlbnRMaW5rc0hlbHBlciNmaWx0ZXJTdXBwb3J0ZWRTaXRlc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ1tdfSBzaXRlSWRzICAgICBTaXRlIElEcyB0byBmaWx0ZXIuXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGlzRW5hYmxlZEZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggc2l0ZS4gTXVzdCByZXR1cm4gYSBwcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLiBJdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlcyBhIHNpdGVJZCBwYXJhbSBhbmQgYWxsIHRoZSBwYXJhbXMgc2VudCB0byB0aGlzIGZ1bmN0aW9uIGFmdGVyICdjaGVja0FsbCcuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2hlY2tBbGwgICAgIFRydWUgaWYgaXQgc2hvdWxkIGNoZWNrIGFsbCB0aGUgc2l0ZXMsIGZhbHNlIGlmIGl0IHNob3VsZCBjaGVjayBvbmx5IDEgYW5kIHRyZWF0IHRoZW0gYWxsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGluZyBvbiB0aGlzIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gIHtNaXhlZH0gICAgICAgICAgICAgICAgQWxsIHRoZSBwYXJhbXMgc2VudCBhZnRlciBjaGVja0FsbCB3aWxsIGJlIHBhc3NlZCB0byBpc0VuYWJsZWRGbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIHN1cHBvcnRlZCBzaXRlcy5cbiAgICAgKi9cbiAgICBzZWxmLmZpbHRlclN1cHBvcnRlZFNpdGVzID0gZnVuY3Rpb24oc2l0ZUlkcywgaXNFbmFibGVkRm4sIGNoZWNrQWxsKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgc3VwcG9ydGVkID0gW10sXG4gICAgICAgICAgICBleHRyYVBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7IC8vIFBhcmFtcyByZWNlaXZlZCBhZnRlciAnY2hlY2tBbGwnLlxuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzaXRlSWRzLCBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgICAgIGlmIChjaGVja0FsbCB8fCAhcHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChpc0VuYWJsZWRGbi5hcHBseShpc0VuYWJsZWRGbiwgW3NpdGVJZF0uY29uY2F0KGV4dHJhUGFyYW1zKSkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWQucHVzaChzaXRlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gJG1tVXRpbC5hbGxQcm9taXNlcyhwcm9taXNlcykuY2F0Y2goZnVuY3Rpb24oKSB7fSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tBbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l0ZUlkczsgLy8gQ2hlY2tpbmcgMSB3YXMgZW5vdWdoIGFuZCBpdCBzdWNjZWVkZWQsIGFsbCBzaXRlcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBDaGVja2luZyAxIHdhcyBlbm91Z2ggYW5kIGl0IGZhaWxlZCwgbm8gc2l0ZXMgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgdmFsaWQgYWN0aW9uIGluIGEgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvbnRlbnRsaW5rc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db250ZW50TGlua3NIZWxwZXIjZ2V0Rmlyc3RWYWxpZEFjdGlvblxuICAgICAqIEBwYXJhbSAge09iamVjdFtdfSBhY3Rpb25zIExpc3Qgb2YgYWN0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBGaXJzdCB2YWxpZCBhY3Rpb24uIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vIHZhbGlkIGFjdGlvbiBmb3VuZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpcnN0VmFsaWRBY3Rpb24gPSBmdW5jdGlvbihhY3Rpb25zKSB7XG4gICAgICAgIGlmIChhY3Rpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICYmIGFjdGlvbi5zaXRlcyAmJiBhY3Rpb24uc2l0ZXMubGVuZ3RoICYmIGFuZ3VsYXIuaXNGdW5jdGlvbihhY3Rpb24uYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHb2VzIHRvIGEgY2VydGFpbiBzdGF0ZSBpbiBhIGNlcnRhaW4gc2l0ZS4gSWYgdGhlIHNpdGUgaXMgY3VycmVudCBzaXRlIGl0IHdpbGwgcGVyZm9ybSBhIHJlZ3VsYXIgbmF2aWdhdGlvbixcbiAgICAgKiBvdGhlcndpc2UgaXQgdXNlcyB0aGUgJ3JlZGlyZWN0JyBzdGF0ZSB0byBjaGFuZ2UgdGhlIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY29udGVudGxpbmtzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvbnRlbnRMaW5rc0hlbHBlciNnb0luU2l0ZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RhdGVOYW1lICAgTmFtZSBvZiB0aGUgc3RhdGUgdG8gZ28uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzdGF0ZVBhcmFtcyBQYXJhbXMgdG8gc2VuZCB0byB0aGUgc3RhdGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSAgICBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBzdGF0ZSBpcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIHNlbGYuZ29JblNpdGUgPSBmdW5jdGlvbihzdGF0ZU5hbWUsIHN0YXRlUGFyYW1zLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgaWYgKHNpdGVJZCA9PSAkbW1TaXRlLmdldElkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkc3RhdGUuZ28oc3RhdGVOYW1lLCBzdGF0ZVBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHN0YXRlLmdvKCdyZWRpcmVjdCcsIHtcbiAgICAgICAgICAgICAgICBzaXRlaWQ6IHNpdGVJZCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVOYW1lLFxuICAgICAgICAgICAgICAgIHBhcmFtczogc3RhdGVQYXJhbXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdvIHRvIHRoZSB2aWV3IHRvIGNob29zZSBhIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY29udGVudGxpbmtzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvbnRlbnRMaW5rc0hlbHBlciNnb1RvQ2hvb3NlU2l0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIHRyZWF0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHNlbGYuZ29Ub0Nob29zZVNpdGUgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe1xuICAgICAgICAgICAgZGlzYWJsZUJhY2s6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAkc3RhdGUuZ28oJ21tX2NvbnRlbnRsaW5rcy5jaG9vc2VzaXRlJywge3VybDogdXJsfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIGxpbmsuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY29udGVudGxpbmtzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvbnRlbnRMaW5rc0hlbHBlciNoYW5kbGVMaW5rXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmwgVVJMIHRvIGhhbmRsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggYSBib29sZWFuOiB0cnVlIGlmIFVSTCB3YXMgdHJlYXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaGFuZGxlTGluayA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbGluayBzaG91bGQgYmUgdHJlYXRlZCBieSBzb21lIGNvbXBvbmVudC9hZGRvbi5cbiAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlLmdldEFjdGlvbnNGb3IodXJsKS50aGVuKGZ1bmN0aW9uKGFjdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBzZWxmLmdldEZpcnN0VmFsaWRBY3Rpb24oYWN0aW9ucyk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbi5zaXRlcy5sZW5ndGggPT0gMSAmJiBhY3Rpb24uc2l0ZXNbMF0gPT0gJG1tU2l0ZS5nZXRJZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgc2l0ZS5cbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmFjdGlvbihhY3Rpb24uc2l0ZXNbMF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBjdXJyZW50IHNpdGUgb3IgbW9yZSB0aGFuIG9uZSBzaXRlLiBBc2sgZm9yIGNvbmZpcm1hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93Q29uZmlybSgkdHJhbnNsYXRlKCdtbS5jb250ZW50bGlua3MuY29uZmlybXVybG90aGVyc2l0ZScpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbi5zaXRlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5hY3Rpb24oYWN0aW9uLnNpdGVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5nb1RvQ2hvb3NlU2l0ZSh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJlYXRzIGEgVVJMIHRoYXQgYmVsb25ncyB0byBhIG1vZHVsZSdzIGluZGV4IHBhZ2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY29udGVudGxpbmtzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvbnRlbnRMaW5rc0hlbHBlciN0cmVhdE1vZHVsZUluZGV4VXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGlzRW5hYmxlZCBGdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgbW9kdWxlIGlzIGVuYWJsZWQuIEBzZWUgJG1tQ29udGVudExpbmtzSGVscGVyI2ZpbHRlclN1cHBvcnRlZFNpdGVzIC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSAgQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICovXG4gICAgc2VsZi50cmVhdE1vZHVsZUluZGV4VXJsID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSAkbW1VdGlsLmV4dHJhY3RVcmxQYXJhbXModXJsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuaWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIFBhc3MgZmFsc2UgYmVjYXVzZSBhbGwgc2l0ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2l0ZXVybC5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmZpbHRlclN1cHBvcnRlZFNpdGVzKHNpdGVJZHMsIGlzRW5hYmxlZCwgZmFsc2UsIGNvdXJzZUlkKS50aGVuKGZ1bmN0aW9uKGlkcykge1xuICAgICAgICAgICAgICAgIGlmICghaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ21tLmNvcmUudmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWV5ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXRlczogaWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db3Vyc2VIZWxwZXIubmF2aWdhdGVUb01vZHVsZShwYXJzZUludChwYXJhbXMuaWQsIDEwKSwgc2l0ZUlkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2UnKVxuXG4vKipcbiAqIE1vZCBjb250ZW50IGNvbnRyb2xsZXIuXG4gKlxuICogQHRvZG8gTURMLTUwMTE0wqBUaGUgZGVzY3JpcHRpb24gbWlnaHQgYmUgbWlzc2luZyBiZWNhdXNlIHRoaXMgZGF0YSBpcyBiYXNlZCBvbiB0aGUgY291cnNlXG4gKiAgICAgICBjb250ZW50cyB3aGljaCBkb2VzIG5vdCBhbHdheXMgaW5jbHVkZSBpdC5cbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbUNvdXJzZU1vZENvbnRlbnRDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbUNvdXJzZU1vZENvbnRlbnRDdHJsJywgZnVuY3Rpb24oJGxvZywgJHN0YXRlUGFyYW1zLCAkc2NvcGUpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1Db3Vyc2VNb2RDb250ZW50Q3RybCcpO1xuICAgIHZhciBtb2R1bGUgPSAkc3RhdGVQYXJhbXMubW9kdWxlIHx8IHt9O1xuICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAkc2NvcGUudXJsID0gbW9kdWxlLnVybDtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZScpXG5cbi8qKlxuICogU2VjdGlvbiB2aWV3IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tQ291cnNlU2VjdGlvbkN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tQ291cnNlU2VjdGlvbkN0cmwnLCBmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZSwgJG1tQ291cnNlLCAkbW1VdGlsLCAkc2NvcGUsICRzdGF0ZVBhcmFtcywgJHRyYW5zbGF0ZSwgJG1tU2l0ZSxcbiAgICAgICAgICAgICRtbUV2ZW50cywgJGlvbmljU2Nyb2xsRGVsZWdhdGUsICRtbUNvdXJzZXMsICRxLCBtbUNvcmVFdmVudENvbXBsZXRpb25Nb2R1bGVWaWV3ZWQsICRjb250cm9sbGVyKSB7XG5cbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBhcmUgY291cnNlIDEgKGZyb250IHBhZ2UpIGFuZCBhbGwgc2VjdGlvbnMuXG4gICAgdmFyIGNvdXJzZUlkID0gJHN0YXRlUGFyYW1zLmNpZCB8fCAxLFxuICAgICAgICBzZWN0aW9uSWQgPSAkc3RhdGVQYXJhbXMuc2VjdGlvbmlkIHx8IC0xLFxuICAgICAgICBtb2R1bGVJZCA9ICRzdGF0ZVBhcmFtcy5taWQ7XG5cbiAgICAkc2NvcGUuc2l0ZWhvbWUgPSAoY291cnNlSWQgPT09IDEpOyAvLyBBcmUgd2UgdmlzaXRpbmcgdGhlIHNpdGUgaG9tZT9cbiAgICAkc2NvcGUuc2VjdGlvbnMgPSBbXTsgLy8gUmVzZXQgc2NvcGUuc2VjdGlvbnMsIG90aGVyd2lzZSBhbiBlcnJvciBpcyBzaG93biBpbiBjb25zb2xlIHdpdGggdGFibGV0IHZpZXcuXG5cbiAgICBpZiAoc2VjdGlvbklkIDwgMCkge1xuICAgICAgICAvLyBTcGVjaWFsIHNjZW5hcmlvLCB3ZSB3YW50IGFsbCBzZWN0aW9ucy5cbiAgICAgICAgaWYgKCRzY29wZS5zaXRlaG9tZSkge1xuICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEuZnJvbnRwYWdlLnNpdGVob21lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvdXJzZS5hbGxzZWN0aW9ucycpO1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5zdW1tYXJ5ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBmZXRjaCBzZWN0aW9uKHMpLlxuICAgIGZ1bmN0aW9uIGxvYWRDb250ZW50KHNlY3Rpb25JZCkge1xuICAgICAgICByZXR1cm4gJG1tQ291cnNlcy5nZXRVc2VyQ291cnNlKGNvdXJzZUlkLCB0cnVlKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFVzZXIgbm90IGVucm9sbGVkIGluIHRoZSBjb3Vyc2Ugb3IgYW4gZXJyb3Igb2NjdXJyZWQsIGlnbm9yZSB0aGUgZXJyb3IuXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oY291cnNlKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgICAgIGlmIChjb3Vyc2UgJiYgY291cnNlLmVuYWJsZWNvbXBsZXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oW10pOyAvLyBDb21wbGV0aW9uIG5vdCBlbmFibGVkLCByZXR1cm4gZW1wdHkgYXJyYXkuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1Db3Vyc2UuZ2V0QWN0aXZpdGllc0NvbXBsZXRpb25TdGF0dXMoY291cnNlSWQpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107IC8vIElmIGZhaWwsIHJldHVybiBlbXB0eSBhcnJheSAoYXMgaWYgdGhlcmUgd2FzIG5vIGNvbXBsZXRpb24pLlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHN0YXR1c2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25udW1iZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbklkIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9ubnVtYmVyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRtbUNvdXJzZS5nZXRTZWN0aW9ucyhjb3Vyc2VJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbm51bWJlciA9IHNlY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRtbUNvdXJzZS5nZXRTZWN0aW9uKGNvdXJzZUlkLCBzZWN0aW9uSWQpLnRoZW4oZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gc2VjdGlvbi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnN1bW1hcnkgPSBzZWN0aW9uLnN1bW1hcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NlY3Rpb25dO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgc2l0ZSBob21lLCB3ZSBuZWVkIHRvIHJldmVyc2UgdGhlIG9yZGVyIHRvIGRpc3BsYXkgZmlyc3QgdGhlIHNpdGUgaG9tZSBzZWN0aW9uIHRvcGljLlxuICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLnNpdGVob21lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzQ29udGVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzZWN0aW9ucywgZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24uc3VtbWFyeSAhPSAnJyB8fCBzZWN0aW9uLm1vZHVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzZWN0aW9uLm1vZHVsZXMsIGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5fY29udHJvbGxlciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db3Vyc2VEZWxlZ2F0ZS5nZXRDb250ZW50SGFuZGxlckNvbnRyb2xsZXJGb3IobW9kdWxlLm1vZG5hbWUsIG1vZHVsZSwgY291cnNlSWQsIHNlY3Rpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGFjdGl2aXR5IGhhcyBjb21wbGV0aW9ucyBhbmQgaWYgaXQncyBtYXJrZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHN0YXR1c2VzW21vZHVsZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5pZCA9PSBtb2R1bGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBtb2R1bGUgd2UncmUgbG9va2luZyBmb3IuIE9wZW4gaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY29wZSA9ICRzY29wZS4kbmV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRjb250cm9sbGVyKG1vZHVsZS5fY29udHJvbGxlciwgeyRzY29wZTogc2NvcGV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuYWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5oYXNDb250ZW50ID0gaGFzQ29udGVudDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbG9nIGluIE1vb2RsZS5cbiAgICAgICAgICAgICAgICAgICAgJG1tU2l0ZS53cml0ZSgnY29yZV9jb3Vyc2Vfdmlld19jb3Vyc2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9ubnVtYmVyOiBzZWN0aW9ubnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3Vyc2UuY291bGRub3Rsb2Fkc2VjdGlvbmNvbnRlbnQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvYWRDb250ZW50KHNlY3Rpb25JZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLnNlY3Rpb25Mb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLmRvUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1Db3Vyc2UuaW52YWxpZGF0ZVNlY3Rpb25zKGNvdXJzZUlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbG9hZENvbnRlbnQoc2VjdGlvbklkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFJlZnJlc2ggbGlzdCBhZnRlciBhIGNvbXBsZXRpb24gY2hhbmdlIHNpbmNlIHRoZXJlIGNvdWxkIGJlIG5ldyBhY3Rpdml0aWVzIG9yIHNvLlxuICAgIGZ1bmN0aW9uIHJlZnJlc2hBZnRlckNvbXBsZXRpb25DaGFuZ2UoKSB7XG4gICAgICAgIHZhciBzY3JvbGxWaWV3ID0gJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKCdtbVNlY3Rpb25TY3JvbGwnKTtcbiAgICAgICAgaWYgKHNjcm9sbFZpZXcgJiYgc2Nyb2xsVmlldy5nZXRTY3JvbGxQb3NpdGlvbigpKSB7XG4gICAgICAgICAgICAkc2NvcGUubG9hZGluZ1BhZGRpbmdUb3AgPSBzY3JvbGxWaWV3LmdldFNjcm9sbFBvc2l0aW9uKCkudG9wO1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5zZWN0aW9uTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICRzY29wZS5zZWN0aW9ucyA9IFtdO1xuICAgICAgICBsb2FkQ29udGVudChzZWN0aW9uSWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2VjdGlvbkxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAkc2NvcGUubG9hZGluZ1BhZGRpbmdUb3AgPSAwO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb21wbGV0aW9uIGNoYW5nZWQgZm9yIGF0IGxlYXN0IG9uZSBtb2R1bGUuIEludmFsaWRhdGUgZGF0YSBhbmQgcmUtbG9hZCBpdC5cbiAgICAkc2NvcGUuY29tcGxldGlvbkNoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tQ291cnNlLmludmFsaWRhdGVTZWN0aW9ucyhjb3Vyc2VJZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlZnJlc2hBZnRlckNvbXBsZXRpb25DaGFuZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIExpc3RlbiBmb3Igdmlld2VkIG1vZHVsZXMuIElmIGFuIGF1dG9tYXRpYyBjb21wbGV0aW9uIG1vZHVsZSBpcyB2aWV3ZWQsIHJlZnJlc2ggdGhlIHdob2xlIGxpc3QuXG4gICAgdmFyIG9ic2VydmVyID0gJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50Q29tcGxldGlvbk1vZHVsZVZpZXdlZCwgZnVuY3Rpb24oY2lkKSB7XG4gICAgICAgIGlmIChjaWQgPT09IGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZWZyZXNoQWZ0ZXJDb21wbGV0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAob2JzZXJ2ZXIgJiYgb2JzZXJ2ZXIub2ZmKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5vZmYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlJylcblxuLyoqXG4gKiBTZWN0aW9ucyB2aWV3IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tQ291cnNlU2VjdGlvbnNDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbUNvdXJzZVNlY3Rpb25zQ3RybCcsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tVXRpbCwgJHNjb3BlLCAkc3RhdGVQYXJhbXMsICR0cmFuc2xhdGUsICRtbUNvdXJzZUhlbHBlciwgJG1tRXZlbnRzLFxuICAgICAgICAgICAgJG1tU2l0ZSwgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSwgJG1tQ291cnNlcywgJHEsICRpb25pY0hpc3RvcnksICRpb25pY1BsYXRmb3JtLCBtbUNvcmVDb3Vyc2VBbGxTZWN0aW9uc0lkLFxuICAgICAgICAgICAgbW1Db3JlRXZlbnRTZWN0aW9uU3RhdHVzQ2hhbmdlZCwgJG1tQ29uZmlnLCBtbUNvcmVTZXR0aW5nc0Rvd25sb2FkU2VjdGlvbiwgJHN0YXRlLCAkdGltZW91dCkge1xuICAgIHZhciBjb3Vyc2VJZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZCxcbiAgICAgICAgc2VjdGlvbklkID0gJHN0YXRlUGFyYW1zLnNpZCxcbiAgICAgICAgbW9kdWxlSWQgPSAkc3RhdGVQYXJhbXMubW9kdWxlaWQsXG4gICAgICAgIGRvd25sb2FkU2VjdGlvbnNFbmFibGVkO1xuXG4gICAgJHNjb3BlLmNvdXJzZUlkID0gY291cnNlSWQ7XG4gICAgJHNjb3BlLnNlY3Rpb25Ub0xvYWQgPSAyOyAvLyBMb2FkIFwiR2VuZXJhbFwiIHNlY3Rpb24gYnkgZGVmYXVsdC5cblxuICAgIGZ1bmN0aW9uIGNoZWNrRG93bmxvYWRTZWN0aW9uc0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiAkbW1Db25maWcuZ2V0KG1tQ29yZVNldHRpbmdzRG93bmxvYWRTZWN0aW9uLCB0cnVlKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvd25sb2FkU2VjdGlvbnNFbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBTaG91bGRuJ3QgaGFwcGVuLlxuICAgICAgICAgICAgZG93bmxvYWRTZWN0aW9uc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZFNlY3Rpb25zKHJlZnJlc2gpIHtcbiAgICAgICAgLy8gR2V0IGZ1bGwgY291cnNlIGRhdGEuIElmIG5vdCByZWZyZXNoaW5nIHdlJ2xsIHRyeSB0byBnZXQgaXQgZnJvbSBjYWNoZSB0byBzcGVlZCB1cCB0aGUgcmVzcG9uc2UuXG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2VzLmdldFVzZXJDb3Vyc2UoY291cnNlSWQpLnRoZW4oZnVuY3Rpb24oY291cnNlKSB7XG4gICAgICAgICAgICAkc2NvcGUuZnVsbG5hbWUgPSBjb3Vyc2UuZnVsbG5hbWU7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHNlY3Rpb25zLlxuICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZS5nZXRTZWN0aW9ucyhjb3Vyc2VJZCkudGhlbihmdW5jdGlvbihzZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIGZha2UgZmlyc3Qgc2VjdGlvbiAoYWxsIHNlY3Rpb25zKS5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZSgnbW0uY291cnNlLmFsbHNlY3Rpb25zJykudGhlbihmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkaW5nIGZha2UgZmlyc3Qgc2VjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbW1Db3JlQ291cnNlQWxsU2VjdGlvbnNJZFxuICAgICAgICAgICAgICAgICAgICB9XS5jb25jYXQoc2VjdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zZWN0aW9ucyA9IHJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRTZWN0aW9uc0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzdGF0dXMgb2YgdGhlIHNlY3Rpb25zLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZUhlbHBlci5jYWxjdWxhdGVTZWN0aW9uc1N0YXR1cyhyZXN1bHQsIGNvdXJzZUlkLCB0cnVlLCByZWZyZXNoKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIChzaG91bGRuJ3QgaGFwcGVuKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZG93bmxvYWRwcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlc3RvcmVkIGFueSBkb3dubG9hZCB3ZSdsbCByZWNhbGN1bGF0ZSB0aGUgc3RhdHVzIG9uY2UgYWxsIG9mIHRoZW0gaGF2ZSBmaW5pc2hlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRwcm9taXNlcyAmJiBkb3dubG9hZHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLmFsbFByb21pc2VzKGRvd25sb2FkcHJvbWlzZXMpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRkZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3Vyc2UuZXJyb3Jkb3dubG9hZGluZ3NlY3Rpb24nLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgdGhlIHN0YXR1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db3Vyc2VIZWxwZXIuY2FsY3VsYXRlU2VjdGlvbnNTdGF0dXMoJHNjb3BlLnNlY3Rpb25zLCBjb3Vyc2VJZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY291cnNlLmNvdWxkbm90bG9hZHNlY3Rpb25zJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFByZWZldGNoIGEgc2VjdGlvbi4gVGhlIHNlY29uZCBwYXJhbWV0ZXIgaW5kaWNhdGVzIGlmIHRoZSBwcmVmZXRjaCB3YXMgc3RhcnRlZCBtYW51YWxseSAodHJ1ZSlcbiAgICAvLyBvciBpdCB3YXMgYXV0b21hdGljYWxseSBzdGFydGVkIGJlY2F1c2UgYWxsIG1vZHVsZXMgYXJlIGJlaW5nIGRvd25sb2FkZWQgKGZhbHNlKS5cbiAgICBmdW5jdGlvbiBwcmVmZXRjaChzZWN0aW9uLCBtYW51YWwpIHtcbiAgICAgICAgJG1tQ291cnNlSGVscGVyLnByZWZldGNoKHNlY3Rpb24sIGNvdXJzZUlkLCAkc2NvcGUuc2VjdGlvbnMpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gRG9uJ3Qgc2hvdyBlcnJvciBtZXNzYWdlIGlmIHNjb3BlIGlzIGRlc3Ryb3llZCBvciBpdCdzIGFuIGF1dG9tYXRpYyBkb3dubG9hZCBidXQgd2UgYXJlbid0IGluIHRoaXMgc3RhdGUuXG4gICAgICAgICAgICBpZiAoJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9ICRpb25pY0hpc3RvcnkuY3VycmVudFN0YXRlTmFtZSgpLFxuICAgICAgICAgICAgICAgIGlzQ3VycmVudCA9ICgkaW9uaWNQbGF0Zm9ybS5pc1RhYmxldCgpICYmIGN1cnJlbnQgPT0gJ3NpdGUubW1fY291cnNlLm1tX2NvdXJzZS1zZWN0aW9uJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoISRpb25pY1BsYXRmb3JtLmlzVGFibGV0KCkgJiYgY3VycmVudCA9PSAnc2l0ZS5tbV9jb3Vyc2UnKTtcbiAgICAgICAgICAgIGlmICghbWFudWFsICYmICFpc0N1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvdXJzZS5lcnJvcmRvd25sb2FkaW5nc2VjdGlvbicsIHRydWUpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRkZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSB0aGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgICRtbUNvdXJzZUhlbHBlci5jYWxjdWxhdGVTZWN0aW9uc1N0YXR1cygkc2NvcGUuc2VjdGlvbnMsIGNvdXJzZUlkLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGF1dG9sb2FkIGEgc2VjdGlvbiBpZiBzZWN0aW9uSWQgcGFyYW0gaXMgc2V0LlxuICAgIGZ1bmN0aW9uIGF1dG9sb2FkU2VjdGlvbigpIHtcbiAgICAgICAgaWYgKHNlY3Rpb25JZCkge1xuICAgICAgICAgICAgaWYgKCRpb25pY1BsYXRmb3JtLmlzVGFibGV0KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWN0aW9uIHRvIGxvYWQuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5zZWN0aW9ucywgZnVuY3Rpb24oc2VjdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24uaWQgPT0gc2VjdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2VjdGlvblRvTG9hZCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFNldCBtb2R1bGVJZCB0byBwYXNzIGl0IHRvIHRoZSBuZXcgc3RhdGUgd2hlbiB0aGUgc2VjdGlvbiBpcyBhdXRvbG9hZGVkLiBXZSB1bnNldCBpdCBhZnRlciB0aGlzXG4gICAgICAgICAgICAgICAgLy8gdG8gcHJldmVudCBhdXRvbG9hZGluZyB0aGUgbW9kdWxlIHdoZW4gdGhlIHVzZXIgbWFudWFsbHkgbG9hZHMgYSBzZWN0aW9uLlxuICAgICAgICAgICAgICAgICRzY29wZS5tb2R1bGVJZCA9IG1vZHVsZUlkO1xuICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUubW9kdWxlSWQgPSBudWxsOyAvLyBVbnNldCBtb2R1bGVJZCB3aGVuXG4gICAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1tX2NvdXJzZS1zZWN0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uaWQ6IHNlY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgY2lkOiBjb3Vyc2VJZCxcbiAgICAgICAgICAgICAgICAgICAgbWlkOiBtb2R1bGVJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJHNjb3BlLmRvUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1Db3Vyc2VzLmludmFsaWRhdGVVc2VyQ291cnNlcygpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1Db3Vyc2UuaW52YWxpZGF0ZVNlY3Rpb25zKGNvdXJzZUlkKSk7XG5cbiAgICAgICAgJHEuYWxsKHByb21pc2VzKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbG9hZFNlY3Rpb25zKHRydWUpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLnByZWZldGNoID0gZnVuY3Rpb24oZSwgc2VjdGlvbikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgJG1tQ291cnNlSGVscGVyLmNvbmZpcm1Eb3dubG9hZFNpemUoY291cnNlSWQsIHNlY3Rpb24sICRzY29wZS5zZWN0aW9ucykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHByZWZldGNoKHNlY3Rpb24sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY2hlY2tEb3dubG9hZFNlY3Rpb25zRW5hYmxlZCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRTZWN0aW9ucygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhdXRvbG9hZFNlY3Rpb24oKTtcbiAgICAgICAgICAgICRzY29wZS5zZWN0aW9uc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuIGZvciBzZWN0aW9uIHN0YXR1cyBjaGFuZ2VzLlxuICAgIHZhciBzdGF0dXNPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFNlY3Rpb25TdGF0dXNDaGFuZ2VkLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkb3dubG9hZFNlY3Rpb25zRW5hYmxlZCAmJiAkc2NvcGUuc2VjdGlvbnMgJiYgJHNjb3BlLnNlY3Rpb25zLmxlbmd0aCAmJiBkYXRhLnNpdGVpZCA9PT0gJG1tU2l0ZS5nZXRJZCgpICYmXG4gICAgICAgICAgICAgICAgICAgICEkc2NvcGUuJCRkZXN0cm95ZWQmJiBkYXRhLnNlY3Rpb25pZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFmZmVjdGVkIHNlY3Rpb24gaXMgYmVpbmcgZG93bmxvYWRlZC4gSWYgc28sIHdlIGRvbid0IHVwZGF0ZSBzZWN0aW9uIHN0YXR1c1xuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCdsbCBhbHJlYWR5IGJlIHVwZGF0ZWQgd2hlbiB0aGUgZG93bmxvYWQgZmluaXNoZXMuXG4gICAgICAgICAgICBpZiAoJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5pc0JlaW5nRG93bmxvYWRlZCgkbW1Db3Vyc2VIZWxwZXIuZ2V0U2VjdGlvbkRvd25sb2FkSWQoe2lkOiBkYXRhLnNlY3Rpb25pZH0pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgdGhlIHN0YXR1cy5cbiAgICAgICAgICAgICRtbUNvdXJzZUhlbHBlci5jYWxjdWxhdGVTZWN0aW9uc1N0YXR1cygkc2NvcGUuc2VjdGlvbnMsIGNvdXJzZUlkLCBmYWxzZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VjdGlvbjtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLnNlY3Rpb25zLCBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmlkID09PSBkYXRhLnNlY3Rpb25pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbiA9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRpZCA9ICRtbUNvdXJzZUhlbHBlci5nZXRTZWN0aW9uRG93bmxvYWRJZChzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24uaXNEb3dubG9hZGluZyAmJiAhJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5pc0JlaW5nRG93bmxvYWRlZChkb3dubG9hZGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIHRoZSBtb2R1bGVzIGFyZSBub3cgZG93bmxvYWRpbmcsIHNldCBhIGRvd25sb2FkIGFsbCBwcm9taXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2goc2VjdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0YXR1c09ic2VydmVyICYmIHN0YXR1c09ic2VydmVyLm9mZiAmJiBzdGF0dXNPYnNlcnZlci5vZmYoKTtcbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZScpXG5cbi8qKlxuICogQ291cnNlIE1vZCBEZXNjcmlwdGlvbiBkaXJlY3RpdmUuXG4gKlxuICogVG8gdXNlIHRvIGRpc3BsYXkgdGhlIGRlc2NyaXB0aW9uIG9mIGEgbW9kdWxlLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tQ291cnNlTW9kRGVzY3JpcHRpb25cbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIG1lYW50IHRvIGRpc3BsYXkgYSBtb2R1bGUgZGVzY3JpcHRpb24gaW4gYSBzaW1pbGFyIHdheSB0aHJvdWdob3V0XG4gKiBhbGwgdGhlIG1vZHVsZXMuIEl0IGhhcyBpdHMgb3duIHNjb3BlIGFuZCBzbyB3aWxsIHVzZSB0aGUgYXR0cmlidXRlICdkZXNjcmlwdGlvbicgdG9cbiAqIGtub3cgd2hhdCBzY29wZSB2YXJpYWJsZSB0byBsb29rIGZvciBpbiB0aGUgcGFyZW50IHNjb3BlLlxuICpcbiAqIElmIHRoZSBkZXNjcmlwdGlvbiBpcyBhc3luY2hyb25vdXMgeW91IHNob3VsZCBzZXQgdGhlIGF0dHJpYnV0ZSAnd2F0Y2gnIHRvIHRydWUuXG4gKiBUaGlzIGF0dHJpYnV0ZSBpcyBkaXJlY3RseSBzaGFyZWQgd2l0aCBtbUZvcm1hdFRleHQgd2hpY2ggbmVlZHMgaXQuXG4gKlxuICogWW91IGNhbiBhZGQgYSBub3RlIGF0IHRoZSByaWdodCBzaWRlIG9mIHRoZSBkZXNjcmlwdGlvbiBieSB1c2luZyB0aGUgJ25vdGUnIGF0dHJpYnV0ZS5cbiAqXG4gKiBNb2R1bGUgZGVzY3JpcHRpb25zIGFyZSBzaG9ydGVuZWQgYnkgZGVmYXVsdCwgYWxsb3dpbmcgdGhlIHVzZXIgdG8gc2VlIHRoZSBmdWxsIGRlc2NyaXB0aW9uIGJ5IGNsaWNraW5nIGluIGl0LlxuICogSWYgeW91IHdhbnQgdGhlIHdob2xlIGRlc2NyaXB0aW9uIHRvIGJlIHNob3duIHlvdSBjYW4gdXNlIHRoZSAnc2hvd2Z1bGwnIGF0dHJpYnV0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIDxtbS1jb3Vyc2UtbW9kLWRlc2NyaXB0aW9uIGRlc2NyaXB0aW9uPVwibXlEZXNjcmlwdGlvblwiPjwvbW0tY291cnNlLW1vZC1kZXNjcmlwdGlvbj5cbiAqXG4gKiA8bW0tY291cnNlLW1vZC1kZXNjcmlwdGlvbiBkZXNjcmlwdGlvbj1cIm15QXN5bmNEZXNjXCIgd2F0Y2g9XCJ0cnVlXCI+PC9tbS1jb3Vyc2UtbW9kLWRlc2NyaXB0aW9uPlxuICovXG4uZGlyZWN0aXZlKCdtbUNvdXJzZU1vZERlc2NyaXB0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgIGlmIChhdHRycy53YXRjaCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZmluZCgnbW0tZm9ybWF0LXRleHQnKS5hdHRyKCd3YXRjaCcsIGF0dHJzLndhdGNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlKSB7IC8vIExpbmsgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgc2NvcGUuc2hvd2Z1bGwgPSAhIWF0dHJzLnNob3dmdWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnPScsXG4gICAgICAgICAgICBub3RlOiAnPSdcbiAgICAgICAgfSxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvY291cnNlL3RlbXBsYXRlcy9tb2RfZGVzY3JpcHRpb24uaHRtbCdcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlJylcblxuLyoqXG4gKiBEZWZhdWx0IGNvdXJzZSBjb250ZW50IGhhbmRsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUNvdXJzZUNvbnRlbnRIYW5kbGVyXG4gKi9cbi5mYWN0b3J5KCckbW1Db3Vyc2VDb250ZW50SGFuZGxlcicsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldENvbnRyb2xsZXI6IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYyhtb2R1bGUubW9kbmFtZSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW1fY291cnNlLW1vZGNvbnRlbnQnLCB7bW9kdWxlOiBtb2R1bGV9KTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYnV0dG9ucyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWlvcy1icm93c2Vycy1vdXRsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnbW0uY29yZS5vcGVuaW5icm93c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwub3BlbkluQnJvd3Nlcihtb2R1bGUudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2UnKVxuXG4uY29uc3RhbnQoJ21tQ29yZUNvdXJzZU1vZHVsZXNTdG9yZScsICdjb3Vyc2VfbW9kdWxlcycpIC8vIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LiBQbGVhc2UgZG8gbm90IHVzZS5cblxuLmNvbmZpZyhmdW5jdGlvbigkbW1TaXRlc0ZhY3RvcnlQcm92aWRlciwgbW1Db3JlQ291cnNlTW9kdWxlc1N0b3JlKSB7XG4gICAgdmFyIHN0b3JlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogbW1Db3JlQ291cnNlTW9kdWxlc1N0b3JlLFxuICAgICAgICAgICAga2V5UGF0aDogJ2lkJ1xuICAgICAgICB9XG4gICAgXTtcbiAgICAkbW1TaXRlc0ZhY3RvcnlQcm92aWRlci5yZWdpc3RlclN0b3JlcyhzdG9yZXMpO1xufSlcblxuLyoqXG4gKiBGYWN0b3J5IGNvbnRhaW5pbmcgY291cnNlIHJlbGF0ZWQgbWV0aG9kcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQ291cnNlXG4gKi9cbi5mYWN0b3J5KCckbW1Db3Vyc2UnLCBmdW5jdGlvbigkbW1TaXRlLCAkdHJhbnNsYXRlLCAkcSwgJGxvZywgJG1tRXZlbnRzLCAkbW1TaXRlc01hbmFnZXIsIG1tQ29yZUV2ZW50Q29tcGxldGlvbk1vZHVsZVZpZXdlZCkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUNvdXJzZScpO1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgbW9kcyA9IFtcImFzc2lnblwiLCBcImFzc2lnbm1lbnRcIiwgXCJib29rXCIsIFwiY2hhdFwiLCBcImNob2ljZVwiLCBcImRhdGFcIiwgXCJkYXRhYmFzZVwiLCBcImRhdGVcIiwgXCJleHRlcm5hbC10b29sXCIsXG4gICAgICAgICAgICBcImZlZWRiYWNrXCIsIFwiZmlsZVwiLCBcImZvbGRlclwiLCBcImZvcnVtXCIsIFwiZ2xvc3NhcnlcIiwgXCJpbXNcIiwgXCJpbXNjcFwiLCBcImxhYmVsXCIsIFwibGVzc29uXCIsIFwibHRpXCIsIFwicGFnZVwiLCBcInF1aXpcIixcbiAgICAgICAgICAgIFwicmVzb3VyY2VcIiwgXCJzY29ybVwiLCBcInN1cnZleVwiLCBcInVybFwiLCBcIndpa2lcIiwgXCJ3b3Jrc2hvcFwiXG4gICAgICAgIF0sXG4gICAgICAgIG1vZHNXaXRoQ29udGVudCA9IFsnYm9vaycsICdmb2xkZXInLCAnaW1zY3AnLCAncGFnZScsICdyZXNvdXJjZScsICd1cmwnXTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhICdjb250ZW50cycgcHJvcGVydHkgaWYgdGhlIG1vZHVsZSBuZWVkcyBpdCBhbmQgaXQgZG9lc24ndCBoYXZlIGl0IGFscmVhZHkuIEluIHNvbWUgd2VpcmQgY2FzZXMgdGhlIHNpdGVcbiAgICAgKiBkb2Vzbid0IHJldHVybiB0aGlzIHByb3BlcnR5IGFuZCBpdCdzIG5lZWRlZC4gU2VlIE1PQklMRS0xMzgxLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBNb2R1bGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBNb2R1bGUgd2l0aCBjb250ZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRDb250ZW50c0lmTmVlZGVkKG1vZHVsZSkge1xuICAgICAgICBpZiAobW9kc1dpdGhDb250ZW50LmluZGV4T2YobW9kdWxlLm1vZG5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIG1vZHVsZS5jb250ZW50cyA9IG1vZHVsZS5jb250ZW50cyB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBzaXRlIGlzIHByZXBhcmVkIHRvIHJldHVybiBhIG1vZHVsZSB3aXRob3V0IGhhdmluZyBpdHMgY291cnNlIElELlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgY2FuIHJldHVybiBpdCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLndzQXZhaWxhYmxlKCdjb3JlX2NvdXJzZV9nZXRfY291cnNlX21vZHVsZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHNpdGUgaXMgcHJlcGFyZWQgdG8gcmV0dXJuIGEgbW9kdWxlIGJ5IGluc3RhbmNlIElELlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjY2FuR2V0TW9kdWxlQnlJbnN0YW5jZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGNhbiByZXR1cm4gaXQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuY2FuR2V0TW9kdWxlQnlJbnN0YW5jZSA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUud3NBdmFpbGFibGUoJ2NvcmVfY291cnNlX2dldF9jb3Vyc2VfbW9kdWxlX2J5X2luc3RhbmNlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBtb2R1bGUgY29tcGxldGlvbiBjb3VsZCBoYXZlIGNoYW5nZWQuIElmIGl0IGNvdWxkIGhhdmUsIHRyaWdnZXIgZXZlbnQuIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkLFxuICAgICAqIGZvciBleGFtcGxlLCBhZnRlciBjYWxsaW5nIGEgXCJtb2R1bGVfdmlld1wiIFdTIHNpbmNlIGl0IGNhbiBjaGFuZ2UgdGhlIG1vZHVsZSBjb21wbGV0aW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjY2hlY2tNb2R1bGVDb21wbGV0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkICAgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wbGV0aW9uIENvbXBsZXRpb24gc3RhdHVzIG9mIHRoZSBtb2R1bGUuXG4gICAgICovXG4gICAgc2VsZi5jaGVja01vZHVsZUNvbXBsZXRpb24gPSBmdW5jdGlvbihjb3Vyc2VJZCwgY29tcGxldGlvbikge1xuICAgICAgICBpZiAoY29tcGxldGlvbiAmJiBjb21wbGV0aW9uLnRyYWNraW5nID09PSAyICYmIGNvbXBsZXRpb24uc3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGYuaW52YWxpZGF0ZVNlY3Rpb25zKGNvdXJzZUlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50Q29tcGxldGlvbk1vZHVsZVZpZXdlZCwgY291cnNlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbXBsZXRpb24gc3RhdHVzIG9mIGFsbCB0aGUgYWN0aXZpdGllcyBpbiBhIGNvdXJzZSBmb3IgYSBjZXJ0YWluIHVzZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZSNnZXRBY3Rpdml0aWVzQ29tcGxldGlvblN0YXR1c1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW3VzZXJpZF0gVXNlciBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgY29tcGxldGlvbiBzdGF0dXNlczogb2JqZWN0IHdoZXJlIHRoZSBrZXkgaXMgbW9kdWxlIElELlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QWN0aXZpdGllc0NvbXBsZXRpb25TdGF0dXMgPSBmdW5jdGlvbihjb3Vyc2VpZCwgdXNlcmlkKSB7XG4gICAgICAgIHVzZXJpZCA9IHVzZXJpZCB8fCAkbW1TaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICRsb2cuZGVidWcoJ0dldHRpbmcgY29tcGxldGlvbiBzdGF0dXMgZm9yIHVzZXIgJyArIHVzZXJpZCArICcgaW4gY291cnNlICcgKyBjb3Vyc2VpZCk7XG5cbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlaWQsXG4gICAgICAgICAgICAgICAgdXNlcmlkOiB1c2VyaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRBY3Rpdml0aWVzQ29tcGxldGlvbkNhY2hlS2V5KGNvdXJzZWlkLCB1c2VyaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ2NvcmVfY29tcGxldGlvbl9nZXRfYWN0aXZpdGllc19jb21wbGV0aW9uX3N0YXR1cycsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnN0YXR1c2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFN0YXR1c2VzID0ge307XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRhdGEuc3RhdHVzZXMsIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdGF0dXNlc1tzdGF0dXMuY21pZF0gPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFN0YXR1c2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgYWN0aXZpdGllcyBjb21wbGV0aW9uIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VyaWQgICBVc2VyIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFjdGl2aXRpZXNDb21wbGV0aW9uQ2FjaGVLZXkoY291cnNlaWQsIHVzZXJpZCkge1xuICAgICAgICByZXR1cm4gJ21tQ291cnNlOmFjdGl2aXRpZXNjb21wbGV0aW9uOicgKyBjb3Vyc2VpZCArICc6JyArIHVzZXJpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbW9kdWxlIGJhc2ljIGluZm8gYnkgbW9kdWxlIElELlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjZ2V0TW9kdWxlQmFzaWNJbmZvXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBtb2R1bGVJZCBNb2R1bGUgSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBtb2R1bGUncyBpbmZvLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0TW9kdWxlQmFzaWNJbmZvID0gZnVuY3Rpb24obW9kdWxlSWQsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY21pZDogbW9kdWxlSWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRNb2R1bGVDYWNoZUtleShtb2R1bGVJZClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5yZWFkKCdjb3JlX2NvdXJzZV9nZXRfY291cnNlX21vZHVsZScsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5jbSAmJiAoIXJlc3BvbnNlLndhcm5pbmdzIHx8wqAhcmVzcG9uc2Uud2FybmluZ3MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuY207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIG1vZHVsZSBiYXNpYyBpbmZvIGJ5IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjZ2V0TW9kdWxlQmFzaWNJbmZvQnlJbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAgICAgICAgSW5zdGFuY2UgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZSAgICBOYW1lIG9mIHRoZSBtb2R1bGUuIEUuZy4gJ2dsb3NzYXJ5Jy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIG1vZHVsZSdzIGluZm8uXG4gICAgICovXG4gICAgc2VsZi5nZXRNb2R1bGVCYXNpY0luZm9CeUluc3RhbmNlID0gZnVuY3Rpb24oaWQsIG1vZHVsZSwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaWQsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0TW9kdWxlQnlJbnN0YW5jZUNhY2hlS2V5KGlkLCBtb2R1bGUpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHNpdGUucmVhZCgnY29yZV9jb3Vyc2VfZ2V0X2NvdXJzZV9tb2R1bGVfYnlfaW5zdGFuY2UnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuY20gJiYgKCFyZXNwb25zZS53YXJuaW5ncyB8fMKgIXJlc3BvbnNlLndhcm5pbmdzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmNtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIG1vZHVsZSBmcm9tIE1vb2RsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlI2dldE1vZHVsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb2R1bGVJZCAgICBUaGUgbW9kdWxlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdICBUaGUgY291cnNlIElELiBSZWNvbW1lbmRlZCB0byBzcGVlZCB1cCB0aGUgcHJvY2VzcyBhbmQgbWluaW1pemUgZGF0YSB1c2FnZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlY3Rpb25JZF0gVGhlIHNlY3Rpb24gSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmdldE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZUlkLCBjb3Vyc2VJZCwgc2VjdGlvbklkKSB7XG5cbiAgICAgICAgaWYgKCFtb2R1bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgICAgaWYgKCFjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gTm8gY291cnNlSWQgcGFzc2VkLCB0cnkgdG8gcmV0cmlldmUgaXQuXG4gICAgICAgICAgICBwcm9taXNlID0gc2VsZi5nZXRNb2R1bGVCYXNpY0luZm8obW9kdWxlSWQpLnRoZW4oZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5jb3Vyc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKGNvdXJzZUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgY291cnNlSWQsIHdlIGNhbiB1c2UgY29yZV9jb3Vyc2VfZ2V0X2NvbnRlbnRzIGZvciBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnR2V0dGluZyBtb2R1bGUgJyArIG1vZHVsZUlkICsgJyBpbiBjb3Vyc2UgJyArIGNvdXJzZUlkKTtcblxuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkOiBjb3Vyc2VJZCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjbWlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtb2R1bGVJZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldE1vZHVsZUNhY2hlS2V5KG1vZHVsZUlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHNlY3Rpb25JZCkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5vcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2VjdGlvbmlkJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNlY3Rpb25JZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdjb3JlX2NvdXJzZV9nZXRfY29udGVudHMnLCBwYXJhbXMsIHByZVNldHMpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIGdldHRpbmcgdGhlIG1vZHVsZS4gVHJ5IHRvIGdldCBhbGwgY29udGVudHMgKHdpdGhvdXQgZmlsdGVyaW5nKS5cbiAgICAgICAgICAgICAgICBwYXJhbXMub3B0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIHByZVNldHMuY2FjaGVLZXkgPSBnZXRTZWN0aW9uc0NhY2hlS2V5KGNvdXJzZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdjb3JlX2NvdXJzZV9nZXRfY29udGVudHMnLCBwYXJhbXMsIHByZVNldHMpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihzZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBzZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGU7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBzZWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uLm1vZHVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSA9IHNlY3Rpb24ubW9kdWxlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuaWQgPT0gbW9kdWxlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUuY291cnNlID0gY291cnNlSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZENvbnRlbnRzSWZOZWVkZWQobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIG1vZHVsZSBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAgICAgSW5zdGFuY2UgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZSBOYW1lIG9mIHRoZSBtb2R1bGUuIEUuZy4gJ2dsb3NzYXJ5Jy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNb2R1bGVCeUluc3RhbmNlQ2FjaGVLZXkoaWQsIG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gJ21tQ291cnNlOm1vZHVsZUJ5SW5zdGFuY2U6JyArIG1vZHVsZSArICc6JyArIGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIG1vZHVsZSBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb2R1bGVpZCBNb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNb2R1bGVDYWNoZUtleShtb2R1bGVpZCkge1xuICAgICAgICByZXR1cm4gJ21tQ291cnNlOm1vZHVsZTonICsgbW9kdWxlaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc291cmNlIHRvIGEgbW9kdWxlIGljb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZSNnZXRNb2R1bGVJY29uU3JjXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZU5hbWUgVGhlIG1vZHVsZSBuYW1lLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIElNRyBzcmMuXG4gICAgICovXG4gICAgc2VsZi5nZXRNb2R1bGVJY29uU3JjID0gZnVuY3Rpb24obW9kdWxlTmFtZSkge1xuICAgICAgICBpZiAobW9kcy5pbmRleE9mKG1vZHVsZU5hbWUpIDwgMCkge1xuICAgICAgICAgICAgbW9kdWxlTmFtZSA9IFwiZXh0ZXJuYWwtdG9vbFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiaW1nL21vZC9cIiArIG1vZHVsZU5hbWUgKyBcIi5zdmdcIjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzZWN0aW9uIElEIGEgbW9kdWxlIGJlbG9uZ3MgdG8uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZSNnZXRNb2R1bGVTZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9kdWxlSWQgICBUaGUgbW9kdWxlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIFRoZSBjb3Vyc2UgSUQuIFJlcXVpcmVkIGlmIE1vb2RsZSBzaXRlIGlzIHByaW9yIHRvIDMuMC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gICBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5nZXRNb2R1bGVTZWN0aW9uSWQgPSBmdW5jdGlvbihtb2R1bGVJZCwgY291cnNlSWQsIHNpdGVJZCkge1xuXG4gICAgICAgIGlmICghbW9kdWxlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyeSB0byBnZXQgdGhlIHNlY3Rpb24gdXNpbmcgZ2V0TW9kdWxlQmFzaWNJbmZvLlxuICAgICAgICByZXR1cm4gc2VsZi5nZXRNb2R1bGVCYXNpY0luZm8obW9kdWxlSWQsIHNpdGVJZCkudGhlbihmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuc2VjdGlvbjtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWNvdXJzZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgZmFpbGVkIGFuZCB3ZSBkb24ndCBoYXZlIGNvdXJzZUlkLCByZWplY3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgYWxsIHRoZSBzZWN0aW9ucyBpbiB0aGUgY291cnNlIGFuZCBpdGVyYXRlIG92ZXIgdGhlbSB0byBmaW5kIGl0LlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2VjdGlvbnMoY291cnNlSWQsIHt9LCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2VjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlLmlkID09IG1vZHVsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb24uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE5vdCBmb3VuZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHNwZWNpZmljIHNlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZSNnZXRTZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIFRoZSBjb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY3Rpb25pZCBUaGUgc2VjdGlvbiBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcmVqZWN0IGNvbnRhaW5zIHRoZSBlcnJvciBtZXNzYWdlLCBlbHNlIGNvbnRhaW5zIHRoZSBzZWN0aW9uLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2VjdGlvbiA9IGZ1bmN0aW9uKGNvdXJzZWlkLCBzZWN0aW9uaWQpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICBpZiAoc2VjdGlvbmlkIDwgMCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdJbnZhbGlkIHNlY3Rpb24gSUQnKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5nZXRTZWN0aW9ucyhjb3Vyc2VpZCkudGhlbihmdW5jdGlvbihzZWN0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uc1tpXS5pZCA9PSBzZWN0aW9uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzZWN0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoJ1Vua293biBzZWN0aW9uJyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb3Vyc2Ugc2VjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZSNnZXRTZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCAgVGhlIGNvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3ByZVNldHNdIE9wdGlvbmFsLiBQcmVzZXRzIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcmVqZWN0IGNvbnRhaW5zIHRoZSBlcnJvciBtZXNzYWdlLCBlbHNlIGNvbnRhaW5zIHRoZSBzZWN0aW9ucy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNlY3Rpb25zID0gZnVuY3Rpb24oY291cnNlaWQsIHByZVNldHMsIHNpdGVJZCkge1xuICAgICAgICBwcmVTZXRzID0gcHJlU2V0cyB8fCB7fTtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcHJlU2V0cy5jYWNoZUtleSA9IGdldFNlY3Rpb25zQ2FjaGVLZXkoY291cnNlaWQpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUucmVhZCgnY29yZV9jb3Vyc2VfZ2V0X2NvbnRlbnRzJywge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkOiBjb3Vyc2VpZCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBbXVxuICAgICAgICAgICAgfSwgcHJlU2V0cykudGhlbihmdW5jdGlvbihzZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzZWN0aW9ucywgZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2VjdGlvbi5tb2R1bGVzLCBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbnRlbnRzSWZOZWVkZWQobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb25zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBzZWN0aW9uIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTZWN0aW9uc0NhY2hlS2V5KGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAnbW1Db3Vyc2U6c2VjdGlvbnM6JyArIGNvdXJzZWlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIG1vZHVsZSBXUyBjYWxsLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjaW52YWxpZGF0ZU1vZHVsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb2R1bGVpZCBNb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVNb2R1bGUgPSBmdW5jdGlvbihtb2R1bGVpZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRNb2R1bGVDYWNoZUtleShtb2R1bGVpZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBtb2R1bGUgV1MgY2FsbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlI2ludmFsaWRhdGVNb2R1bGVCeUluc3RhbmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkICAgICBJbnN0YW5jZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kdWxlIE5hbWUgb2YgdGhlIG1vZHVsZS4gRS5nLiAnZ2xvc3NhcnknLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZU1vZHVsZUJ5SW5zdGFuY2UgPSBmdW5jdGlvbihpZCwgbW9kdWxlKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldE1vZHVsZUJ5SW5zdGFuY2VDYWNoZUtleShpZCwgbW9kdWxlKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHNlY3Rpb25zIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZSNpbnZhbGlkYXRlU2VjdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt1c2VyaWRdIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlU2VjdGlvbnMgPSBmdW5jdGlvbihjb3Vyc2VpZCwgdXNlcmlkKSB7XG4gICAgICAgIHVzZXJpZCA9IHVzZXJpZCB8fCAkbW1TaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgIHZhciBwMSA9ICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0U2VjdGlvbnNDYWNoZUtleShjb3Vyc2VpZCkpLFxuICAgICAgICAgICAgcDIgPSAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldEFjdGl2aXRpZXNDb21wbGV0aW9uQ2FjaGVLZXkoY291cnNlaWQsIHVzZXJpZCkpO1xuICAgICAgICByZXR1cm4gJHEuYWxsKFtwMSwgcDJdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlIGEgbW9kdWxlIG5hbWUgdG8gY3VycmVudCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlI3RyYW5zbGF0ZU1vZHVsZU5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kdWxlTmFtZSBUaGUgbW9kdWxlIG5hbWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSB0cmFuc2xhdGVkIG5hbWUuXG4gICAgICovXG4gICAgc2VsZi50cmFuc2xhdGVNb2R1bGVOYW1lID0gZnVuY3Rpb24obW9kdWxlTmFtZSkge1xuICAgICAgICBpZiAobW9kcy5pbmRleE9mKG1vZHVsZU5hbWUpIDwgMCkge1xuICAgICAgICAgICAgbW9kdWxlTmFtZSA9IFwiZXh0ZXJuYWwtdG9vbFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhbmdrZXkgPSAnbW0uY29yZS5tb2RfJyttb2R1bGVOYW1lO1xuICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZShsYW5na2V5KS50aGVuKGZ1bmN0aW9uKHRyYW5zbGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkICE9PSBsYW5na2V5ID8gdHJhbnNsYXRlZCA6IG1vZHVsZU5hbWU7XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlJylcblxuLyoqXG4gKiBDb3Vyc2VzIG5hdiBoYW5kbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Db3Vyc2VDb3Vyc2VzTmF2SGFuZGxlclxuICovXG4uZmFjdG9yeSgnJG1tQ291cnNlQ291cnNlc05hdkhhbmRsZXInLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgdGhpcyBjb3Vyc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCAgIENvdXJzZSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFjY2Vzc0RhdGEgVHlwZSBvZiBhY2Nlc3MgdG8gdGhlIGNvdXJzZTogZGVmYXVsdCwgZ3Vlc3QsIC4uLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNFbmFibGVkRm9yQ291cnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBDb250cm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29udHJvbGxlcjogZnVuY3Rpb24oY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJ2lvbi1icmllZmNhc2UnO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbS5jb3Vyc2UuY29udGVudHMnO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUsIGNvdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW1fY291cnNlJywge2NvdXJzZWlkOiBjb3Vyc2UuaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZScpXG5cbi8qKlxuICogRGVsZWdhdGUgdG8gcmVnaXN0ZXIgY29udGVudCBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQ291cnNlRGVsZWdhdGVcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFRvIHJlZ2lzdGVyIGEgY29udGVudCBoYW5kbGVyOlxuICpcbiAqIC5jb25maWcoJG1tQ291cnNlRGVsZWdhdGUsIGZ1bmN0aW9uKCkge1xuICogICAgICRtbUNvdXJzZURlbGVnYXRlLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYVlvdXJBZGRvbicsICdtb2R1bGVOYW1lJywgJ2hhbmRsZXJOYW1lJyk7XG4gKiAgICAgJG1tQ291cnNlRGVsZWdhdGUucmVnaXN0ZXJDb250ZW50SGFuZGxlcignbW1hTW9kUGFnZScsICdwYWdlJywgJyRtbWFNb2RQYWdlQ291cnNlQ29udGVudEhhbmRsZXInKTtcbiAqIH0pXG4gKlxuICogVGhlIGNvbnRlbnQgaGFuZGxlciBtdXN0IHByb3ZpZGUgdHdvIG1ldGhvZHMuXG4gKlxuICogMS8gaXNFbmFibGVkKCkgd2hpY2ggd2lsbCBiZSBjYWxsZWQgb25jZSBpbiBhIHdoaWxlIHRvIGNoZWNrIGlmIHRoZSBwbHVnaW4gd29ya3Mgb24gdGhlIGN1cnJlbnQgc2l0ZS5cbiAqIDIvIGdldENvbnRyb2xsZXIobW9kdWxlLCBjb3Vyc2VpZCkgd2hpY2ggc2hvdWxkIHJldHVybiBhIGNvbnRyb2xsZXIgb2JqZWN0XG4gKlxuICogVGhlIGNvbnRyb2xsZXIgaGFzIGl0cyBvd24gc2NvcGUgaW5oZXJpdGluZyB0aGUgcGFyZW50IG9uZS4gVGhvdWdoIHlvdSBzaG91bGQgbm90IHVzZSB0aGVcbiAqIHBhcmVudCBzY29wZS4gVG8gZmluZCBvdXQgbW9yZSB3aGF0IHNjb3BlIHZhcmlhYmxlcyBhcmUgZXhwZWN0ZWQgbG9vayBhdCB0aGUgdGVtcGxhdGVcbiAqIGNvcmUvY29tcG9uZW50cy9jb3Vyc2UvdGVtcGxhdGVzL3NlY3Rpb24uaHRtbCBhbmQgYXQgZXhpc3RpbmcgY29udGVudCBoYW5kbGVycy5cbiAqL1xuLnByb3ZpZGVyKCckbW1Db3Vyc2VEZWxlZ2F0ZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250ZW50SGFuZGxlcnMgPSB7fSxcbiAgICAgICAgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjb250ZW50IGhhbmRsZXIuIElmIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgc2l0ZSwgaGFuZGxlciBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlRGVsZWdhdGUjcmVnaXN0ZXJDb250ZW50SGFuZGxlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRvbiBUaGUgYWRkb24ncyBuYW1lIChtbWFMYWJlbCwgbW1hRm9ydW0sIC4uLilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlcyBUaGUgbW9kdWxlIHRoaXMgaGFuZGxlciBoYW5kbGVzLCBlLmcuIGZvcnVtLCBsYWJlbC4gVGhpcyB2YWx1ZSB3aWxsIGJlIGNvbXBhcmVkIHdpdGhcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdmFsdWUgY29udGFpbmVkIGluIG1vZHVsZS5tb2RuYW1lIGZyb20gdGhlIFdlYnNlcnZpY2UgY29yZV9jb3Vyc2VfZ2V0X2NvbnRlbnRzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gaGFuZGxlciBNdXN0IGJlIHJlc29sdmVkIHRvIGFuIG9iamVjdCBkZWZpbmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucy4gT3IgdG8gYSBmdW5jdGlvblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuaW5nIGFuIG9iamVjdCBkZWZpbmluZyB0aGVzZSBmdW5jdGlvbnMuIFNlZSB7QGxpbmsgJG1tVXRpbCNyZXNvbHZlT2JqZWN0fS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBpc0VuYWJsZWQgKEJvb2xlYW4pIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgb24gYSBzaXRlIGxldmVsLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGdldENvbnRyb2xsZXIobW9kdWxlLCBjb3Vyc2VpZCkgKEZ1bmN0aW9uKSBSZXR1cm5zIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYWN0IGFzIGNvbnRyb2xsZXIuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGNvcmUvY29tcG9uZW50cy9jb3Vyc2UvdGVtcGxhdGVzL3NlY3Rpb24uaHRtbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgbGlzdCBvZiBzY29wZSB2YXJpYWJsZXMgZXhwZWN0ZWQuXG4gICAgICovXG4gICAgc2VsZi5yZWdpc3RlckNvbnRlbnRIYW5kbGVyID0gZnVuY3Rpb24oYWRkb24sIGhhbmRsZXMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50SGFuZGxlcnNbaGFuZGxlc10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXI6IEFkZG9uICdcIiArIGNvbnRlbnRIYW5kbGVyc1toYW5kbGVzXS5hZGRvbiArIFwiJyBhbHJlYWR5IHJlZ2lzdGVyZWQgYXMgaGFuZGxlciBmb3IgJ1wiICsgaGFuZGxlcyArIFwiJ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIiRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXI6IFJlZ2lzdGVyZWQgYWRkb24gJ1wiICsgYWRkb24gKyBcIicgYXMgY291cnNlIGNvbnRlbnQgaGFuZGxlci5cIik7XG4gICAgICAgIGNvbnRlbnRIYW5kbGVyc1toYW5kbGVzXSA9IHtcbiAgICAgICAgICAgIGFkZG9uOiBhZGRvbixcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICBpbnN0YW5jZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBzZWxmLiRnZXQgPSBmdW5jdGlvbigkcSwgJGxvZywgJG1tU2l0ZSwgJG1tVXRpbCwgJG1tQ291cnNlQ29udGVudEhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGVuYWJsZWRIYW5kbGVycyA9IHt9LFxuICAgICAgICAgICAgc2VsZiA9IHt9O1xuXG4gICAgICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Db3Vyc2VEZWxlZ2F0ZScpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIgYSBjb250ZW50IGhhbmRsZXIgcHJvdmlkZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCBmaXJzdCBnZXQgdGhlIGRlZmF1bHQgZGF0YSwgdGhlbiBjYWxsIHRoZSBoYW5kbGVyIGlmIGFueSBhbmQgb3ZlcnJpZGVcbiAgICAgICAgICogdGhlIGRlZmF1bHQgZGF0YSB3aXRoIHRoZSBuZXcgZGF0YSBmcm9tIHRoZSBoYW5kbGVyLiBUaGF0IG1lYW5zIHRoYXQgYSBoYW5kbGVyXG4gICAgICAgICAqIHNob3VsZCBhbHdheXMgb3ZlcnJpZGUgYW55IGV4aXN0aW5nIGF0dHJpYnV0ZSBpZiB0aGV5IHdhbnQgdG8gY2hhbmdlIHRoZSBkZWZhdWx0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZURlbGVnYXRlI2dldENvbnRlbnRIYW5kbGVyQ29udHJvbGxlckZvclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlcyAgIFRoZSBtb2R1bGUgdG8gd29yayBvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlICAgIFRoZSBtb2R1bGUgZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgIFRoZSBjb3Vyc2UgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWN0aW9uaWQgVGhlIHNlY3Rpb24gSUQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udGVudEhhbmRsZXJDb250cm9sbGVyRm9yID0gZnVuY3Rpb24oaGFuZGxlcywgbW9kdWxlLCBjb3Vyc2VpZCwgc2VjdGlvbmlkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWRIYW5kbGVyc1toYW5kbGVzXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5hYmxlZEhhbmRsZXJzW2hhbmRsZXNdLmdldENvbnRyb2xsZXIobW9kdWxlLCBjb3Vyc2VpZCwgc2VjdGlvbmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkbW1Db3Vyc2VDb250ZW50SGFuZGxlci5nZXRDb250cm9sbGVyKG1vZHVsZSwgY291cnNlaWQsIHNlY3Rpb25pZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgZW5hYmxlZCBoYW5kbGVycyBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZURlbGVnYXRlI3VwZGF0ZUNvbnRlbnRIYW5kbGVyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYW5kbGVzIFRoZSBtb2R1bGUgdGhpcyBoYW5kbGVyIGhhbmRsZXMsIGUuZy4gZm9ydW0sIGxhYmVsLiBUaGlzIHZhbHVlIHdpbGwgYmUgY29tcGFyZWQgd2l0aFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlckluZm8gVGhlIGhhbmRsZXIgZGV0YWlscy5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBlbmFibGVkLCByZWplY3RlZCB3aGVuIG5vdC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi51cGRhdGVDb250ZW50SGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXMsIGhhbmRsZXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVySW5mby5pbnN0YW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVySW5mby5pbnN0YW5jZSA9ICRtbVV0aWwucmVzb2x2ZU9iamVjdChoYW5kbGVySW5mby5oYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oaGFuZGxlckluZm8uaW5zdGFuY2UuaXNFbmFibGVkKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGNvbnRlbnQgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWRIYW5kbGVyc1toYW5kbGVzXSA9IGhhbmRsZXJJbmZvLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW5hYmxlZEhhbmRsZXJzW2hhbmRsZXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgaGFuZGxlcnMgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VEZWxlZ2F0ZSN1cGRhdGVDb250ZW50SGFuZGxlcnNcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBkb25lLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnVwZGF0ZUNvbnRlbnRIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW10sXG4gICAgICAgICAgICAgICAgZW5hYmxlZEhhbmRsZXJzID0ge307XG5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1VwZGF0aW5nIGNvbnRlbnQgaGFuZGxlcnMgZm9yIGN1cnJlbnQgc2l0ZS4nKTtcblxuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIGFsbCB0aGUgY29udGVudCBoYW5kbGVycy5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250ZW50SGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXJJbmZvLCBoYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLnVwZGF0ZUNvbnRlbnRIYW5kbGVyKGhhbmRsZXMsIGhhbmRsZXJJbmZvKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE5ldmVyIHJlamVjdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlJylcblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2F0aGVyIHNvbWUgY29tbW9uIGNvdXJzZSBmdW5jdGlvbnMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUNvdXJzZUhlbHBlclxuICovXG4uZmFjdG9yeSgnJG1tQ291cnNlSGVscGVyJywgZnVuY3Rpb24oJHEsICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUsICRtbUZpbGVwb29sLCAkbW1VdGlsLCAkbW1Db3Vyc2UsICRtbVNpdGUsICRzdGF0ZSxcbiAgICAgICAgICAgIG1tQ29yZU5vdERvd25sb2FkZWQsIG1tQ29yZU91dGRhdGVkLCBtbUNvcmVEb3dubG9hZGluZywgbW1Db3JlQ291cnNlQWxsU2VjdGlvbnNJZCkge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc3RhdHVzIG9mIGEgc2VjdGlvbi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlSGVscGVyI2NhbGN1bGF0ZVNlY3Rpb25TdGF0dXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBzZWN0aW9uICAgICAgICAgIFNlY3Rpb24gdG8gY2FsY3VsYXRlIGl0cyBzdGF0dXMuIENhbid0IGJlIFwiQWxsIHNlY3Rpb25zXCIuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VpZCAgICAgICAgICBDb3Vyc2UgSUQgdGhlIHNlY3Rpb24gYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlc3RvcmVEb3dubG9hZHMgIFRydWUgaWYgaXQgc2hvdWxkIHJlc3RvcmUgZG93bmxvYWRzLiBJdCB3aWxsIHRyeSB0byByZXN0b3JlIHRoaXMgc2VjdGlvbiBkb3dubG9hZHMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZWZyZXNoICAgICAgICAgICBUcnVlIGlmIGl0IHNob3VsZG4ndCB1c2UgbW9kdWxlIHN0YXR1cyBjYWNoZSAoc2xvd2VyKS5cbiAgICAgKiBAcGFyYW0ge1Byb21pc2VbXX0gW2R3bnByb21pc2VzXSAgIElmIHNlY3Rpb24gZG93bmxvYWQgaXMgcmVzdG9yZWQsIGEgcHJvbWlzZSB3aWxsIGJlIGFkZGVkIHRvIHRoaXMgYXJyYXkuIFJlcXVpcmVkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiByZXN0b3JlRG93bmxvYWRzPXRydWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHN0YXRlIGlzIGNhbGN1bGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5jYWxjdWxhdGVTZWN0aW9uU3RhdHVzID0gZnVuY3Rpb24oc2VjdGlvbiwgY291cnNlaWQsIHJlc3RvcmVEb3dubG9hZHMsIHJlZnJlc2gsIGR3bnByb21pc2VzKSB7XG5cbiAgICAgICAgaWYgKHNlY3Rpb24uaWQgIT09IG1tQ29yZUNvdXJzZUFsbFNlY3Rpb25zSWQpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgc3RhdHVzIG9mIHRoaXMgc2VjdGlvbi5cbiAgICAgICAgICAgIHJldHVybiAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLmdldE1vZHVsZXNTdGF0dXMoc2VjdGlvbi5pZCwgc2VjdGlvbi5tb2R1bGVzLCBjb3Vyc2VpZCwgcmVmcmVzaCwgcmVzdG9yZURvd25sb2FkcylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGJlaW5nIGRvd25sb2FkZWQuIFdlIGNhbid0IHRydXN0IHN0YXR1cyAxMDAlIGJlY2F1c2UgZG93bmxvYWRlZCBib29rcyBhcmUgYWx3YXlzIG91dGRhdGVkLlxuICAgICAgICAgICAgICAgIHZhciBkb3dubG9hZGlkID0gc2VsZi5nZXRTZWN0aW9uRG93bmxvYWRJZChzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5pc0JlaW5nRG93bmxvYWRlZChkb3dubG9hZGlkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhdHVzID0gbW1Db3JlRG93bmxvYWRpbmc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoaXMgc2VjdGlvbiBkYXRhLlxuICAgICAgICAgICAgICAgIHNlY3Rpb24uc2hvd0Rvd25sb2FkID0gcmVzdWx0LnN0YXR1cyA9PT0gbW1Db3JlTm90RG93bmxvYWRlZDtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnNob3dSZWZyZXNoID0gcmVzdWx0LnN0YXR1cyA9PT0gbW1Db3JlT3V0ZGF0ZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gbW1Db3JlRG93bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5pc0Rvd25sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24udG90YWwgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlc3RvcmVEb3dubG9hZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGRvd25sb2FkIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24uY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLnRvdGFsID0gcmVzdWx0W21tQ29yZU91dGRhdGVkXS5sZW5ndGggKyByZXN1bHRbbW1Db3JlTm90RG93bmxvYWRlZF0ubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFttbUNvcmVEb3dubG9hZGluZ10ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb3IgcmUtc3RhcnQgdGhlIHByZWZldGNoLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYuc3RhcnRPclJlc3RvcmVQcmVmZXRjaChzZWN0aW9uLCByZXN1bHQsIGNvdXJzZWlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtY2FsY3VsYXRlIHRoZSBzdGF0dXMgb2YgdGhpcyBzZWN0aW9uIG9uY2UgZmluaXNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxjdWxhdGVTZWN0aW9uU3RhdHVzKHNlY3Rpb24sIGNvdXJzZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkd25wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHducHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc3RhdHVzIG9mIGEgbGlzdCBvZiBzZWN0aW9ucywgc2V0dGluZyBhdHRyaWJ1dGVzIHRvIGRldGVybWluZSB0aGUgaWNvbnMvZGF0YSB0byBiZSBzaG93bi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlSGVscGVyI2NhbGN1bGF0ZVNlY3Rpb25zU3RhdHVzXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gc2VjdGlvbnMgICAgICAgICBTZWN0aW9ucyB0byBjYWxjdWxhdGUgdGhlaXIgc3RhdHVzLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlaWQgICAgICAgICAgQ291cnNlIElEIHRoZSBzZWN0aW9ucyBiZWxvbmcgdG8uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXN0b3JlRG93bmxvYWRzICBUcnVlIGlmIGl0IHNob3VsZCByZXN0b3JlIGRvd25sb2Fkcy4gSXQgd2lsbCB0cnkgdG8gcmVzdG9yZSBzZWN0aW9uIGRvd25sb2Fkc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVmcmVzaCAgICAgICAgICAgVHJ1ZSBpZiBpdCBzaG91bGRuJ3QgdXNlIG1vZHVsZSBzdGF0dXMgY2FjaGUgKHNsb3dlcikuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHN0YXRlcyBhcmUgY2FsY3VsYXRlZC4gUmV0dXJucyBhbiBhcnJheSBvZiBkb3dubG9hZCBwcm9taXNlc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgcmVzdG9yZWQgZG93bmxvYWRzIChvbmx5IGlmIHJlc3RvcmVEb3dubG9hZHM9dHJ1ZSkuXG4gICAgICovXG4gICAgc2VsZi5jYWxjdWxhdGVTZWN0aW9uc1N0YXR1cyA9IGZ1bmN0aW9uKHNlY3Rpb25zLCBjb3Vyc2VpZCwgcmVzdG9yZURvd25sb2FkcywgcmVmcmVzaCkge1xuXG4gICAgICAgIHZhciBhbGxzZWN0aW9uc3NlY3Rpb24sXG4gICAgICAgICAgICBhbGxzZWN0aW9uc3N0YXR1cyxcbiAgICAgICAgICAgIGRvd25sb2FkcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgIHN0YXR1c3Byb21pc2VzID0gW107XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNlY3Rpb25zLCBmdW5jdGlvbihzZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi5pZCA9PT0gbW1Db3JlQ291cnNlQWxsU2VjdGlvbnNJZCkge1xuICAgICAgICAgICAgICAgIC8vIFwiQWxsIHNlY3Rpb25zXCIgc2VjdGlvbiBzdGF0dXMgaXMgY2FsY3VsYXRlZCB1c2luZyB0aGUgc3RhdHVzIG9mIHRoZSByZXN0IG9mIHNlY3Rpb25zLlxuICAgICAgICAgICAgICAgIGFsbHNlY3Rpb25zc2VjdGlvbiA9IHNlY3Rpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXR1c3Byb21pc2VzLnB1c2goc2VsZi5jYWxjdWxhdGVTZWN0aW9uU3RhdHVzKHNlY3Rpb24sIGNvdXJzZWlkLCByZXN0b3JlRG93bmxvYWRzLCByZWZyZXNoLCBkb3dubG9hZHByb21pc2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIFwiQWxsIHNlY3Rpb25zXCIgc3RhdHVzLlxuICAgICAgICAgICAgICAgICAgICBhbGxzZWN0aW9uc3N0YXR1cyA9ICRtbUZpbGVwb29sLmRldGVybWluZVBhY2thZ2VzU3RhdHVzKGFsbHNlY3Rpb25zc3RhdHVzLCByZXN1bHQuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwoc3RhdHVzcHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoYWxsc2VjdGlvbnNzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IFwiQWxsIHNlY3Rpb25zXCIgZGF0YS5cbiAgICAgICAgICAgICAgICBhbGxzZWN0aW9uc3NlY3Rpb24uc2hvd0Rvd25sb2FkID0gYWxsc2VjdGlvbnNzdGF0dXMgPT09IG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgICAgICAgICAgYWxsc2VjdGlvbnNzZWN0aW9uLnNob3dSZWZyZXNoID0gYWxsc2VjdGlvbnNzdGF0dXMgPT09IG1tQ29yZU91dGRhdGVkO1xuICAgICAgICAgICAgICAgIGFsbHNlY3Rpb25zc2VjdGlvbi5pc0Rvd25sb2FkaW5nID0gYWxsc2VjdGlvbnNzdGF0dXMgPT09IG1tQ29yZURvd25sb2FkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvd25sb2FkcHJvbWlzZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNpemUgb2YgdGhlIGRvd25sb2FkIGFuZCBzaG93IGEgY29uZmlybSBtb2RhbCBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZUhlbHBlciNjb25maXJtRG93bmxvYWRTaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkICAgQ291cnNlIElEIHRoZSBzZWN0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlY3Rpb24gICAgU2VjdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBzZWN0aW9ucyBMaXN0IG9mIHNlY3Rpb25zLiBVc2VkIHdoZW4gZG93bmxvYWRpbmcgYWxsIHRoZSBzZWN0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIGlmIHRoZSB1c2VyIGNvbmZpcm1zIG9yIHRoZXJlJ3Mgbm8gbmVlZCB0byBjb25maXJtLlxuICAgICAqL1xuICAgIHNlbGYuY29uZmlybURvd25sb2FkU2l6ZSA9IGZ1bmN0aW9uKGNvdXJzZWlkLCBzZWN0aW9uLCBzZWN0aW9ucykge1xuICAgICAgICB2YXIgc2l6ZVByb21pc2U7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzaXplIG9mIHRoZSBkb3dubG9hZC5cbiAgICAgICAgaWYgKHNlY3Rpb24uaWQgIT0gbW1Db3JlQ291cnNlQWxsU2VjdGlvbnNJZCkge1xuICAgICAgICAgICAgc2l6ZVByb21pc2UgPSAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLmdldERvd25sb2FkU2l6ZShzZWN0aW9uLm1vZHVsZXMsIGNvdXJzZWlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgIHNpemUgPSAwO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNlY3Rpb25zLCBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMuaWQgIT0gbW1Db3JlQ291cnNlQWxsU2VjdGlvbnNJZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUuZ2V0RG93bmxvYWRTaXplKHMubW9kdWxlcywgY291cnNlaWQpLnRoZW4oZnVuY3Rpb24oc2VjdGlvbnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSBzaXplICsgc2VjdGlvbnNpemU7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNpemVQcm9taXNlID0gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2l6ZVByb21pc2UudGhlbihmdW5jdGlvbihzaXplKSB7XG4gICAgICAgICAgICAvLyBTaG93IGNvbmZpcm0gbW9kYWwgaWYgbmVlZGVkLlxuICAgICAgICAgICAgcmV0dXJuICRtbVV0aWwuY29uZmlybURvd25sb2FkU2l6ZShzaXplKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY291cnNlIElEIGZyb20gYSBtb2R1bGUsIHNob3dpbmcgYW4gZXJyb3IgbWVzc2FnZSBpZiBpdCBjYW4ndCBiZSByZXRyaWV2ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZUhlbHBlciNnZXRNb2R1bGVDb3Vyc2VJZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAgICAgICAgSW5zdGFuY2UgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZSAgICBOYW1lIG9mIHRoZSBtb2R1bGUuIEUuZy4gJ2dsb3NzYXJ5Jy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIG1vZHVsZSdzIGNvdXJzZSBJRC5cbiAgICAgKi9cbiAgICBzZWxmLmdldE1vZHVsZUNvdXJzZUlkQnlJbnN0YW5jZSA9IGZ1bmN0aW9uKGlkLCBtb2R1bGUsIHNpdGVJZCkge1xuICAgICAgICByZXR1cm4gJG1tQ291cnNlLmdldE1vZHVsZUJhc2ljSW5mb0J5SW5zdGFuY2UoaWQsIG1vZHVsZSwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgICAgICByZXR1cm4gY20uY291cnNlO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvdXJzZS5lcnJvcmdldG1vZHVsZScsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkb3dubG9hZCBJRCBvZiBhIHNlY3Rpb24uIEl0J3MgdXNlZCB0byBpbnRlcmFjdCB3aXRoICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZUhlbHBlciNnZXRTZWN0aW9uRG93bmxvYWRJZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWN0aW9uIFNlY3Rpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgU2VjdGlvbiBkb3dubG9hZCBJRC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNlY3Rpb25Eb3dubG9hZElkID0gZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gJ1NlY3Rpb24tJytzZWN0aW9uLmlkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNvdXJzZUlkIG9mIHRoZSBtb2R1bGUgYW5kIG5hdmlnYXRlcyB0byBpdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlSGVscGVyI25hdmlnYXRlVG9Nb2R1bGVcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1vZHVsZUlkICAgIE1vZHVsZSdzIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gIENvdXJzZSBJRC4gSWYgbm90IGRlZmluZWQgd2UnbGwgdHJ5IHRvIHJldHJpZXZlIGl0IGZyb20gdGhlIHNpdGUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbc2VjdGlvbklkXSBTZWN0aW9uIHRoZSBtb2R1bGUgYmVsb25ncyB0by4gSWYgbm90IGRlZmluZWQgd2UnbGwgdHJ5IHRvIHJldHJpZXZlIGl0IGZyb20gdGhlIHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHN0YXRlIGNoYW5nZXMuXG4gICAgICovXG4gICAgc2VsZi5uYXZpZ2F0ZVRvTW9kdWxlID0gZnVuY3Rpb24obW9kdWxlSWQsIHNpdGVJZCwgY291cnNlSWQsIHNlY3Rpb25JZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoKSxcbiAgICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgcmV0dXJuICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChjb3Vyc2VJZCAmJiBzZWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHJldHJpZXZlIG1vcmUgZGF0YS5cbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghY291cnNlSWQgJiYgIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGVub3VnaCBkYXRhIGFuZCB3ZSBjYW4ndCByZXRyaWV2ZSBpdC5cbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjb3Vyc2VJZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY291cnNlSWQgYnV0IFdTIGlzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRtbUNvdXJzZS5nZXRNb2R1bGVCYXNpY0luZm8obW9kdWxlSWQsIHNpdGVJZCkudGhlbihmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291cnNlSWQgPSBtb2R1bGUuY291cnNlO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uSWQgPSBtb2R1bGUuc2VjdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBzZWN0aW9uSWQgYnV0IHdlIGhhdmUgY291cnNlSWQuXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRtbUNvdXJzZS5nZXRNb2R1bGVTZWN0aW9uSWQobW9kdWxlSWQsIGNvdXJzZUlkLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbklkID0gaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS5nbygncmVkaXJlY3QnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGVpZDogc2l0ZUlkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3NpdGUubW1fY291cnNlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVpZDogbW9kdWxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWQ6IHNlY3Rpb25JZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3Vyc2UuZXJyb3JnZXRtb2R1bGUnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIG9yIHJlc3RvcmUgdGhlIHByZWZldGNoIG9mIG9uZSBzZWN0aW9uIG9yIGFsbCB0aGUgc2VjdGlvbnMuXG4gICAgICogSWYgdGhlIHNlY3Rpb24gaXMgXCJBbGwgc2VjdGlvbnNcIiBpdCB3aWxsIHByZWZldGNoIGFsbCB0aGUgc2VjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZUhlbHBlciNwcmVmZXRjaFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2VjdGlvbiAgICBTZWN0aW9uLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlaWQgICBDb3Vyc2UgSUQgdGhlIHNlY3Rpb24gYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gc2VjdGlvbnMgTGlzdCBvZiBzZWN0aW9ucy4gVXNlZCB3aGVuIGRvd25sb2FkaW5nIGFsbCB0aGUgc2VjdGlvbnMuXG4gICAgICogQHJldHVybiB7cHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgcHJlZmV0Y2ggaXMgZmluaXNoZWQuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaCA9IGZ1bmN0aW9uKHNlY3Rpb24sIGNvdXJzZWlkLCBzZWN0aW9ucykge1xuXG4gICAgICAgIGlmIChzZWN0aW9uLmlkICE9IG1tQ29yZUNvdXJzZUFsbFNlY3Rpb25zSWQpIHtcbiAgICAgICAgICAgIC8vIERvd25sb2FkIG9ubHkgdGhpcyBzZWN0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJlZmV0Y2hTZWN0aW9uKHNlY3Rpb24sIGNvdXJzZWlkLCB0cnVlLCBzZWN0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEb3dubG9hZCBhbGwgdGhlIHNlY3Rpb25zIGV4Y2VwdCBcIkFsbCBzZWN0aW9uc1wiLlxuICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBhIGZhaWx1cmUsIHdlIHdhbnQgdGhhdCBBTEwgcHJvbWlzZXMgaGF2ZSBmaW5pc2hlZCBiZWZvcmUgcmVqZWN0aW5nIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgIHNlY3Rpb24uaXNEb3dubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2VjdGlvbnMsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocy5pZCAhPSBtbUNvcmVDb3Vyc2VBbGxTZWN0aW9uc0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5wcmVmZXRjaFNlY3Rpb24ocywgY291cnNlaWQsIGZhbHNlLCBzZWN0aW9ucykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBvbmx5IHRoZSBzZWN0aW9uIHRoYXQgZmluaXNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxjdWxhdGVTZWN0aW9uU3RhdHVzKHMsIGNvdXJzZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJG1tVXRpbC5hbGxQcm9taXNlcyhwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlZmV0Y2ggb3IgcmVzdG9yZSB0aGUgcHJlZmV0Y2ggb2YgYSBjZXJ0YWluIHNlY3Rpb24gaWYgaXQgbmVlZHMgdG8gYmUgcHJlZmV0Y2hlZC5cbiAgICAgKiBJZiB0aGUgc2VjdGlvbiBpcyBcIkFsbCBzZWN0aW9uc1wiIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlSGVscGVyI3ByZWZldGNoU2VjdGlvblxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2VjdGlvbiAgICAgICAgIFNlY3Rpb24gdG8gcHJlZmV0Y2guXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VpZCAgICAgICAgQ291cnNlIElEIHRoZSBzZWN0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gc2luZ2xlRG93bmxvYWQgVHJ1ZSBpZiB1c2VyIGlzIG9ubHkgZG93bmxvYWRpbmcgdGhpcyBzZWN0aW9uLCBmYWxzZSBpZiB1c2VyIGlzIGRvd25sb2FkaW5nIGFsbCBzZWN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBbc2VjdGlvbnNdICAgICBMaXN0IG9mIHNlY3Rpb25zLiBVc2VkIG9ubHkgaWYgc2luZ2xlRG93bmxvYWQgaXMgdHJ1ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHNlY3Rpb24gaXMgcHJlZmV0Y2hlZC5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoU2VjdGlvbiA9IGZ1bmN0aW9uKHNlY3Rpb24sIGNvdXJzZWlkLCBzaW5nbGVEb3dubG9hZCwgc2VjdGlvbnMpIHtcblxuICAgICAgICBpZiAoc2VjdGlvbi5pZCA9PSBtbUNvcmVDb3Vyc2VBbGxTZWN0aW9uc0lkKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VjdGlvbi5pc0Rvd25sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgc2VjdGlvbiBuZWVkcyB0byBiZSBkb3dubG9hZGVkIGFuZCBjYWxjdWxhdGUgYW1vdW50IG9mIG1vZHVsZXMgdGhhdCBuZWVkIHRvIGJlIGRvd25sb2FkZWQuXG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLmdldE1vZHVsZXNTdGF0dXMoc2VjdGlvbi5pZCwgc2VjdGlvbi5tb2R1bGVzLCBjb3Vyc2VpZCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBtbUNvcmVOb3REb3dubG9hZGVkIHx8IHJlc3VsdC5zdGF0dXMgPT09IG1tQ29yZU91dGRhdGVkIHx8wqByZXN1bHQuc3RhdHVzID09PSBtbUNvcmVEb3dubG9hZGluZykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gc2VsZi5zdGFydE9yUmVzdG9yZVByZWZldGNoKHNlY3Rpb24sIHJlc3VsdCwgY291cnNlaWQpO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVEb3dubG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZS1jYWxjdWxhdGUgc3RhdHVzIHRvIGRldGVybWluZSB0aGUgcmlnaHQgc3RhdHVzIGZvciB0aGUgXCJBbGwgc2VjdGlvbnNcIiBzZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGN1bGF0ZVNlY3Rpb25zU3RhdHVzKHNlY3Rpb25zLCBjb3Vyc2VpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4uXG4gICAgICAgICAgICBzZWN0aW9uLmlzRG93bmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9yIHJlc3RvcmUgdGhlIHByZWZldGNoIG9mIGEgc2VjdGlvbi5cbiAgICAgKiBJZiB0aGUgc2VjdGlvbiBpcyBcIkFsbCBzZWN0aW9uc1wiIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlSGVscGVyI3N0YXJ0T3JSZXN0b3JlUHJlZmV0Y2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VjdGlvbiBTZWN0aW9uIHRvIGRvd25sb2FkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0dXMgIFJlc3VsdCBvZiAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlI2dldE1vZHVsZXNTdGF0dXMgZm9yIHRoaXMgc2VjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHNlY3Rpb24gaGFzIGJlZW4gcHJlZmV0Y2hlZC5cbiAgICAgKi9cbiAgICBzZWxmLnN0YXJ0T3JSZXN0b3JlUHJlZmV0Y2ggPSBmdW5jdGlvbihzZWN0aW9uLCBzdGF0dXMsIGNvdXJzZWlkKSB7XG5cbiAgICAgICAgaWYgKHNlY3Rpb24uaWQgPT0gbW1Db3JlQ291cnNlQWxsU2VjdGlvbnNJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIG9ubHkgZG93bmxvYWQgbW9kdWxlcyB3aXRoIHN0YXR1cyBub3Rkb3dubG9hZGVkLCBkb3dubG9hZGluZyBvciBvdXRkYXRlZC5cbiAgICAgICAgdmFyIG1vZHVsZXMgPSBzdGF0dXNbbW1Db3JlT3V0ZGF0ZWRdLmNvbmNhdChzdGF0dXNbbW1Db3JlTm90RG93bmxvYWRlZF0pLmNvbmNhdChzdGF0dXNbbW1Db3JlRG93bmxvYWRpbmddKSxcbiAgICAgICAgICAgIGRvd25sb2FkaWQgPSBzZWxmLmdldFNlY3Rpb25Eb3dubG9hZElkKHNlY3Rpb24pLFxuICAgICAgICAgICAgbW9kdWxlaWRzO1xuXG4gICAgICAgIG1vZHVsZWlkcyA9IG1vZHVsZXMubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBtLmlkO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZXQgZG93bmxvYWQgZGF0YS5cbiAgICAgICAgc2VjdGlvbi5jb3VudCA9IDA7XG4gICAgICAgIHNlY3Rpb24udG90YWwgPSBtb2R1bGVzLmxlbmd0aDtcbiAgICAgICAgc2VjdGlvbi5pc0Rvd25sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBXZSBwcmVmZXRjaCBhbGwgdGhlIG1vZHVsZXMgdG8gcHJldmVudCBpbmNvZWhlcmVuY2VzIGluIHRoZSBkb3dubG9hZCBjb3VudFxuICAgICAgICAvLyBhbmQgYWxzbyB0byBkb3dubG9hZCBzdGFsZSBkYXRhIHRoYXQgbWlnaHQgbm90IGJlIG1hcmtlZCBhcyBvdXRkYXRlZC5cbiAgICAgICAgcmV0dXJuICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUucHJlZmV0Y2hBbGwoZG93bmxvYWRpZCwgbW9kdWxlcywgY291cnNlaWQpLnRoZW4oZnVuY3Rpb24oKSB7fSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIHNvIGVycm9ycyBhcmUgaGFuZGxlZCBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAvLyBQcm9ncmVzcy4gQ2hlY2sgdGhhdCB0aGUgbW9kdWxlIGRvd25sb2FkZWQgaXMgb25lIG9mIHRoZSBleHBlY3RlZCBvbmVzLlxuICAgICAgICAgICAgdmFyIGluZGV4ID0gbW9kdWxlaWRzLmluZGV4T2YoaWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIG9uZSBvZiB0aGUgbW9kdWxlcyB3ZSB3ZXJlIGV4cGVjdGluZyB0byBkb3dubG9hZC5cbiAgICAgICAgICAgICAgICBtb2R1bGVpZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLmNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBEZWxlZ2F0ZSB0byByZWdpc3RlciBwcmVmZXRjaCBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBUbyByZWdpc3RlciBhIHByZWZldGNoIGhhbmRsZXI6XG4gKlxuICogLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIpIHtcbiAqICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcmVmZXRjaEhhbmRsZXIoJ21tYVlvdXJBZGRvbicsICdtb2R1bGVOYW1lJywgJ2hhbmRsZXJOYW1lJyk7XG4gKiB9KVxuICpcbiAqIFRvIHNlZSB0aGUgbWV0aG9kcyB0aGF0IG11c3QgcHJvdmlkZSB0aGUgcHJlZmV0Y2ggaGFuZGxlciBzZWUge0BsaW5rICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGVQcm92aWRlciNyZWdpc3RlclByZWZldGNoSGFuZGxlcn0uXG4gKi9cbi5wcm92aWRlcignJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcmVmZXRjaEhhbmRsZXJzID0ge30sXG4gICAgICAgIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgcHJlZmV0Y2ggaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIjcmVnaXN0ZXJQcmVmZXRjaEhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkb24gVGhlIGFkZG9uJ3MgbmFtZSAobW1hTGFiZWwsIG1tYUZvcnVtLCAuLi4pXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXMgVGhlIG1vZHVsZSB0aGlzIGhhbmRsZXIgaGFuZGxlcywgZS5nLiBmb3J1bSwgbGFiZWwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEZ1bmN0aW9ufSBoYW5kbGVyIE11c3QgYmUgcmVzb2x2ZWQgdG8gYW4gb2JqZWN0IGRlZmluaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zLiBPciB0byBhIGZ1bmN0aW9uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5pbmcgYW4gb2JqZWN0IGRlZmluaW5nIHRoZXNlIHByb3BlcnRpZXMuIFNlZSB7QGxpbmsgJG1tVXRpbCNyZXNvbHZlT2JqZWN0fS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBjb21wb25lbnQgKFN0cmluZykgSGFuZGxlcidzIGNvbXBvbmVudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBnZXREb3dubG9hZFNpemUobW9kdWxlLCBjb3Vyc2VpZCkgKE51bWJlcnxQcm9taXNlKSBHZXQgdGhlIGRvd25sb2FkIHNpemUgb2YgYSBtb2R1bGUuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gaXNFbmFibGVkKCkgKEJvb2xlYW58UHJvbWlzZSkgV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBvbiBhIHNpdGUgbGV2ZWwuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJlZmV0Y2gobW9kdWxlLCBjb3Vyc2VpZCkgKFByb21pc2UpIFByZWZldGNoZXMgYSBtb2R1bGUuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gKE9wdGlvbmFsKSBnZXRGaWxlcyhtb2R1bGUsIGNvdXJzZWlkKSAoT2JqZWN0W118UHJvbWlzZSkgR2V0IGxpc3Qgb2YgZmlsZXMuIElmIG5vdCBkZWZpbmVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlJ2xsIGFzc3VtZSB0aGV5J3JlIGluIG1vZHVsZS5jb250ZW50cy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAoT3B0aW9uYWwpIGRldGVybWluZVN0YXR1cyhzdGF0dXMpIChTdHJpbmcpIFJldHVybnMgc3RhdHVzIHRvIHNob3cgYmFzZWQgb24gY3VycmVudC4gRS5nLiBmb3JcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9va3Mgd2UnbGwgc2hvdyBcIm91dGRhdGVkXCIgZXZlbiBpZiBzdGF0ZSBpcyBcImRvd25sb2FkZWRcIi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAoT3B0aW9uYWwpIGdldFJldmlzaW9uKG1vZHVsZSwgY291cnNlaWQpIChTdHJpbmd8TnVtYmVyfFByb21pc2UpIFJldHVybnMgdGhlIG1vZHVsZSByZXZpc2lvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IGRlZmluZWQgd2UnbGwgY2FsY3VsYXRlIGl0IHVzaW5nIG1vZHVsZSBmaWxlcy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAoT3B0aW9uYWwpIGdldFRpbWVtb2RpZmllZChtb2R1bGUsIGNvdXJzZWlkKSAoTnVtYmVyfFByb21pc2UpIFJldHVybnMgdGhlIG1vZHVsZSB0aW1lbW9kaWZpZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBkZWZpbmVkIHdlJ2xsIGNhbGN1bGF0ZSBpdCB1c2luZyBtb2R1bGUgZmlsZXMuXG4gICAgICovXG4gICAgc2VsZi5yZWdpc3RlclByZWZldGNoSGFuZGxlciA9IGZ1bmN0aW9uKGFkZG9uLCBoYW5kbGVzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZmV0Y2hIYW5kbGVyc1toYW5kbGVzXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyOiBBZGRvbiAnXCIgKyBwcmVmZXRjaEhhbmRsZXJzW2hhbmRsZXNdLmFkZG9uICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIicgYWxyZWFkeSByZWdpc3RlcmVkIGFzIGhhbmRsZXIgZm9yICdcIiArIGhhbmRsZXMgKyBcIidcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCIkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXI6IFJlZ2lzdGVyZWQgYWRkb24gJ1wiICsgYWRkb24gKyBcIicgYXMgcHJlZmV0Y2ggaGFuZGxlci5cIik7XG4gICAgICAgIHByZWZldGNoSGFuZGxlcnNbaGFuZGxlc10gPSB7XG4gICAgICAgICAgICBhZGRvbjogYWRkb24sXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2VsZi4kZ2V0ID0gZnVuY3Rpb24oJHEsICRsb2csICRtbVNpdGUsICRtbVV0aWwsICRtbUZpbGVwb29sLCAkbW1FdmVudHMsIG1tQ29yZURvd25sb2FkZWQsIG1tQ29yZURvd25sb2FkaW5nLFxuICAgICAgICAgICAgICAgIG1tQ29yZU5vdERvd25sb2FkZWQsIG1tQ29yZU91dGRhdGVkLCBtbUNvcmVOb3REb3dubG9hZGFibGUsIG1tQ29yZUV2ZW50U2VjdGlvblN0YXR1c0NoYW5nZWQpIHtcbiAgICAgICAgdmFyIGVuYWJsZWRIYW5kbGVycyA9IHt9LFxuICAgICAgICAgICAgc2VsZiA9IHt9LFxuICAgICAgICAgICAgZGVmZXJyZWRzID0ge30sXG4gICAgICAgICAgICBzdGF0dXNDYWNoZSA9IHt9OyAvLyBUbyBzcGVlZCB1cCB0aGUgZ2V0TW9kdWxlc1N0YXR1cyBmdW5jdGlvbi5cblxuICAgICAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZScpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciB0aGUgc3RhdHVzIGNhY2hlIChtZW1vcnkgb2JqZWN0KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSNjbGVhclN0YXR1c0NhY2hlXG4gICAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmNsZWFyU3RhdHVzQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0YXR1c0NhY2hlID0ge307XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgYSBtb2R1bGUgc3RhdHVzIGJhc2VkIG9uIGN1cnJlbnQgc3RhdHVzLCByZXN0b3JpbmcgZG93bmxvYWRzIGlmIG5lZWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSNkZXRlcm1pbmVNb2R1bGVTdGF0dXNcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBtb2R1bGUgICAgICAgICAgIE1vZHVsZS5cbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzdGF0dXMgICAgICAgICAgIEN1cnJlbnQgc3RhdHVzLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlc3RvcmVEb3dubG9hZHMgVHJ1ZSBpZiBpdCBzaG91bGQgcmVzdG9yZSBkb3dubG9hZHMgaWYgbmVlZGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgTW9kdWxlIHN0YXR1cy5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZGV0ZXJtaW5lTW9kdWxlU3RhdHVzID0gZnVuY3Rpb24obW9kdWxlLCBzdGF0dXMsIHJlc3RvcmVEb3dubG9hZHMpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZW5hYmxlZEhhbmRsZXJzW21vZHVsZS5tb2RuYW1lXTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09IG1tQ29yZURvd25sb2FkaW5nICYmIHJlc3RvcmVEb3dubG9hZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRvd25sb2FkIGlzIGJlaW5nIGhhbmRsZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghJG1tRmlsZXBvb2wuZ2V0UGFja2FnZURvd25sb2FkUHJvbWlzZSgkbW1TaXRlLmdldElkKCksIGhhbmRsZXIuY29tcG9uZW50LCBtb2R1bGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCwgdGhlIGFwcCB3YXMgcHJvYmFibHkgcmVzdGFydGVkIG9yIHNvbWV0aGluZyB3ZWlyZCBoYXBwZW5lZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXN0YXJ0IGRvd25sb2FkIChmaWxlcyBhbHJlYWR5IG9uIHF1ZXVlIG9yIGFscmVhZHkgZG93bmxvYWRlZCB3aWxsIGJlIHNraXBwZWQpLlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5wcmVmZXRjaChtb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyLmRldGVybWluZVN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaGFuZGxlciBpbXBsZW1lbnRzIGEgZGV0ZXJtaW5lU3RhdHVzIGZ1bmN0aW9uLiBBcHBseSBpdC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuZGV0ZXJtaW5lU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IG1vZHVsZXMgZG93bmxvYWQgc2l6ZS4gT25seSB0cmVhdCB0aGUgbW9kdWxlcyB3aXRoIHN0YXR1cyBub3QgZG93bmxvYWRlZCBvciBvdXRkYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSNnZXREb3dubG9hZFNpemVcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0W119IG1vZHVsZXMgTGlzdCBvZiBtb2R1bGVzLlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZWlkICBDb3Vyc2UgSUQgdGhlIG1vZHVsZXMgYmVsb25nIHRvLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGRvd25sb2FkIHNpemUuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldERvd25sb2FkU2l6ZSA9IGZ1bmN0aW9uKG1vZHVsZXMsIGNvdXJzZWlkKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IDAsXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZHVsZXMsIGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbnVsbCBjb250ZW50cy5cbiAgICAgICAgICAgICAgICBtb2R1bGUuY29udGVudHMgPSBtb2R1bGUuY29udGVudHMgfHwgW107XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbW9kdWxlIGhhcyBhIHByZWZldGNoIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBlbmFibGVkSGFuZGxlcnNbbW9kdWxlLm1vZG5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaWxlIHdpbGwgYmUgZG93bmxvYWRlZC5cbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLmdldE1vZHVsZVN0YXR1cyhtb2R1bGUsIGNvdXJzZWlkKS50aGVuKGZ1bmN0aW9uKG1vZHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHN0YXR1cyA9PT0gbW1Db3JlTm90RG93bmxvYWRlZCB8fCBtb2RzdGF0dXMgPT09IG1tQ29yZU91dGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oaGFuZGxlci5nZXREb3dubG9hZFNpemUobW9kdWxlLCBjb3Vyc2VpZCkpLnRoZW4oZnVuY3Rpb24obW9kdWxlc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHNpemUgb2YgdGhlIGRvd25sb2FkYWJsZSBmaWxlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHNpemUgKyBtb2R1bGVzaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtb2R1bGUgc3RhdHVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlI2dldE1vZHVsZVN0YXR1c1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlICAgICAgICAgTW9kdWxlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgICAgICAgQ291cnNlIElEIHRoZSBtb2R1bGUgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXZpc2lvbl0gICAgIE1vZHVsZSdzIHJldmlzaW9uLiBJZiBub3QgZGVmaW5lZCwgaXQgd2lsbCBiZSBjYWxjdWxhdGVkIHVzaW5nIG1vZHVsZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZF0gTW9kdWxlJ3MgdGltZW1vZGlmaWVkLiBJZiBub3QgZGVmaW5lZCwgaXQgd2lsbCBiZSBjYWxjdWxhdGVkIHVzaW5nIG1vZHVsZSBkYXRhLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBzdGF0dXMuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldE1vZHVsZVN0YXR1cyA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZW5hYmxlZEhhbmRsZXJzW21vZHVsZS5tb2RuYW1lXSxcbiAgICAgICAgICAgICAgICBzaXRlaWQgPSAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgICAgICBtb2R1bGUuY29udGVudHMgPSBtb2R1bGUuY29udGVudHMgfHwgW107XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhhbmRsZXIgZG9lc24ndCBkZWZpbmUgYSBmdW5jdGlvbiB0byBnZXQgdGhlIGZpbGVzLCB1c2UgbW9kdWxlLmNvbnRlbnRzLlxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gaGFuZGxlci5nZXRGaWxlcyA/ICRxLndoZW4oaGFuZGxlci5nZXRGaWxlcyhtb2R1bGUsIGNvdXJzZWlkKSkgOiAkcS53aGVuKG1vZHVsZS5jb250ZW50cyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGZpbGVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkgeyAvLyBObyBmaWxlcywgdHJlYXQgaXMgYXMgZG93bmxvYWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKG1tQ29yZURvd25sb2FkZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHJldmlzaW9uIGFuZCB0aW1lbW9kaWZpZWQgaWYgdGhleSBhcmVuJ3QgZGVmaW5lZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFuZGxlciBkb2Vzbid0IGRlZmluZSBhIGZ1bmN0aW9uIHRvIGdldCB0aGVtLCBnZXQgdGhlbSBmcm9tIGZpbGUgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXZpc2lvbiA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuZ2V0UmV2aXNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRxLndoZW4oaGFuZGxlci5nZXRSZXZpc2lvbihtb2R1bGUsIGNvdXJzZWlkKSkudGhlbihmdW5jdGlvbihyZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2aXNpb24gPSByZXY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZpc2lvbiA9ICRtbUZpbGVwb29sLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KGZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZW1vZGlmaWVkID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5nZXRUaW1lbW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRxLndoZW4oaGFuZGxlci5nZXRUaW1lbW9kaWZpZWQobW9kdWxlLCBjb3Vyc2VpZCkpLnRoZW4oZnVuY3Rpb24odGltZW1vZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbW9kaWZpZWQgPSB0aW1lbW9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KGZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3cgZ2V0IHRoZSBzdGF0dXMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZ2V0UGFja2FnZVN0YXR1cyhzaXRlaWQsIGhhbmRsZXIuY29tcG9uZW50LCBtb2R1bGUuaWQsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRldGVybWluZU1vZHVsZVN0YXR1cyhtb2R1bGUsIHN0YXR1cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSBsaXN0IG9mIG1vZHVsZXMsIGFsb25nIHdpdGggdGhlIGxpc3RzIG9mIG1vZHVsZXMgZm9yIGVhY2ggc3RhdHVzLlxuICAgICAgICAgKiBAc2VlIHtAbGluayAkbW1GaWxlcG9vbCNkZXRlcm1pbmVQYWNrYWdlc1N0YXR1c31cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSNnZXRNb2R1bGVzU3RhdHVzXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2VjdGlvbmlkICAgICAgICAgSUQgb2YgdGhlIHNlY3Rpb24gdGhlIG1vZHVsZXMgYmVsb25nIHRvLlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gbW9kdWxlcyAgICAgICAgIExpc3Qgb2YgbW9kdWxlcyB0byBwcmVmZXRjaC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VpZCAgICAgICAgICBDb3Vyc2UgSUQgdGhlIG1vZHVsZXMgYmVsb25nIHRvLlxuICAgICAgICAgKiBAcGFyYW0gIHtCb29sZWFufSByZWZyZXNoICAgICAgICAgIFRydWUgaWYgaXQgc2hvdWxkIGFsd2F5cyBjaGVjayB0aGUgREIgKHNsb3dlcikuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzdG9yZURvd25sb2FkcyAgVHJ1ZSBpZiBpdCBzaG91bGQgcmVzdG9yZSBkb3dubG9hZHMuIEl0J3Mgb25seSB1c2VkIGlmIHJlZnJlc2g9ZmFsc2UsXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcmVmcmVzaD10cnVlIHRoZW4gaXQgYWx3YXlzIHRyaWVzIHRvIHJlc3RvcmUgZG93bmxvYWRzLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHN0YXR1cyAoU3RyaW5nKSBTdGF0dXMgb2YgdGhlIG1vZHVsZS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gdG90YWwgKE51bWJlcikgTnVtYmVyIG9mIG1vZHVsZXMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1tQ29yZU5vdERvd25sb2FkZWQgKE9iamVjdFtdKSBNb2R1bGVzIHdpdGggc3RhdGUgbW1Db3JlTm90RG93bmxvYWRlZC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbW1Db3JlRG93bmxvYWRlZCAoT2JqZWN0W10pIE1vZHVsZXMgd2l0aCBzdGF0ZSBtbUNvcmVEb3dubG9hZGVkLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtbUNvcmVEb3dubG9hZGluZyAoT2JqZWN0W10pIE1vZHVsZXMgd2l0aCBzdGF0ZSBtbUNvcmVEb3dubG9hZGluZy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbW1Db3JlT3V0ZGF0ZWQgKE9iamVjdFtdKSBNb2R1bGVzIHdpdGggc3RhdGUgbW1Db3JlT3V0ZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldE1vZHVsZXNTdGF0dXMgPSBmdW5jdGlvbihzZWN0aW9uaWQsIG1vZHVsZXMsIGNvdXJzZWlkLCByZWZyZXNoLCByZXN0b3JlRG93bmxvYWRzKSB7XG5cbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IG1tQ29yZU5vdERvd25sb2FkYWJsZSxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgICAgICAgLy8gSW5pdCByZXN1bHQuXG4gICAgICAgICAgICByZXN1bHRbbW1Db3JlTm90RG93bmxvYWRlZF0gPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdFttbUNvcmVEb3dubG9hZGVkXSA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0W21tQ29yZURvd25sb2FkaW5nXSA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0W21tQ29yZU91dGRhdGVkXSA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0LnRvdGFsID0gMDtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZHVsZXMsIGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBtb2R1bGUgaGFzIGEgcHJlZmV0Y2ggaGFuZGxlci5cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IGVuYWJsZWRIYW5kbGVyc1ttb2R1bGUubW9kbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2U7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBudWxsIGNvbnRlbnRzLlxuICAgICAgICAgICAgICAgIG1vZHVsZS5jb250ZW50cyA9IG1vZHVsZS5jb250ZW50cyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWNrYWdlSWQgPSAkbW1GaWxlcG9vbC5nZXRQYWNrYWdlSWQoaGFuZGxlci5jb21wb25lbnQsIG1vZHVsZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVmcmVzaCAmJiBzdGF0dXNDYWNoZVtwYWNrYWdlSWRdICYmIHN0YXR1c0NhY2hlW3BhY2thZ2VJZF0uc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihzZWxmLmRldGVybWluZU1vZHVsZVN0YXR1cyhtb2R1bGUsIHN0YXR1c0NhY2hlW3BhY2thZ2VJZF0uc3RhdHVzLCByZXN0b3JlRG93bmxvYWRzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gc2VsZi5nZXRNb2R1bGVTdGF0dXMobW9kdWxlLCBjb3Vyc2VpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UudGhlbihmdW5jdGlvbihtb2RzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDYWNoZVtwYWNrYWdlSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogbW9kc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25pZDogc2VjdGlvbmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gJG1tRmlsZXBvb2wuZGV0ZXJtaW5lUGFja2FnZXNTdGF0dXMoc3RhdHVzLCBtb2RzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W21vZHN0YXR1c10ucHVzaChtb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnRvdGFsKys7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgcHJlZmV0Y2ggaGFuZGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSNnZXRQcmVmZXRjaEhhbmRsZXJGb3JcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXMgVGhlIG1vZHVsZSB0byB3b3JrIG9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICBQcmVmZXRjaCBoYW5kbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRQcmVmZXRjaEhhbmRsZXJGb3IgPSBmdW5jdGlvbihoYW5kbGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5hYmxlZEhhbmRsZXJzW2hhbmRsZXNdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBhIGxpc3Qgb2YgbW9kdWxlcyBpcyBiZWluZyBkb3dubG9hZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlI2lzQmVpbmdEb3dubG9hZGVkXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gaWQgQW4gSUQgdG8gaWRlbnRpZnkgdGhlIGRvd25sb2FkLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgIFRydWUgaWYgaXQncyBiZWluZyBkb3dubG9hZGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzQmVpbmdEb3dubG9hZGVkID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZHNbJG1tU2l0ZS5nZXRJZCgpXSAmJiBkZWZlcnJlZHNbJG1tU2l0ZS5nZXRJZCgpXVtpZF07XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZWZldGNoZXMgYSBsaXN0IG9mIG1vZHVsZXMgdXNpbmcgdGhlaXIgcHJlZmV0Y2ggaGFuZGxlcnMuXG4gICAgICAgICAqIElmIGEgcHJlZmV0Y2ggYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgc2l0ZSBhbmQgaWQsIHJldHVybnMgdGhlIGN1cnJlbnQgcHJvbWlzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSNnZXRQcmVmZXRjaEhhbmRsZXJGb3JcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlaWQgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBpZCAgICAgICAgQW4gSUQgdG8gaWRlbnRpZnkgdGhlIGRvd25sb2FkLiBJdCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSB0aGUgZG93bmxvYWQgcHJvbWlzZS5cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0W119IG1vZHVsZXMgTGlzdCBvZiBtb2R1bGVzIHRvIHByZWZldGNoLlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZWlkICBDb3Vyc2UgSUQgdGhlIG1vZHVsZXMgYmVsb25nIHRvLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIG1vZHVsZXMgaGF2ZSBiZWVuIHByZWZldGNoZWQuIE5vdGlmeSBpcyBjYWxsZWQgZXZlcnl0aW1lXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgbW9kdWxlIGlzIHByZWZldGNoZWQsIHBhc3NpbmcgdGhlIG1vZHVsZSBpZCBhcyBwYXJhbS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYucHJlZmV0Y2hBbGwgPSBmdW5jdGlvbihpZCwgbW9kdWxlcywgY291cnNlaWQpIHtcblxuICAgICAgICAgICAgdmFyIHNpdGVpZCA9ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICAgICAgaWYgKGRlZmVycmVkc1tzaXRlaWRdICYmIGRlZmVycmVkc1tzaXRlaWRdW2lkXSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3MgYSBwcmVmZXRjaCBvbmdvaW5nLCByZXR1cm4gdGhlIGN1cnJlbnQgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWRzW3NpdGVpZF1baWRdLnByb21pc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGRlZmVycmVkLlxuICAgICAgICAgICAgaWYgKCFkZWZlcnJlZHNbc2l0ZWlkXSkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkc1tzaXRlaWRdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZHNbc2l0ZWlkXVtpZF0gPSBkZWZlcnJlZDtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZHVsZXMsIGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbnVsbCBjb250ZW50cy5cbiAgICAgICAgICAgICAgICBtb2R1bGUuY29udGVudHMgPSBtb2R1bGUuY29udGVudHMgfHwgW107XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbW9kdWxlIGhhcyBhIHByZWZldGNoIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBlbmFibGVkSGFuZGxlcnNbbW9kdWxlLm1vZG5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5wcmVmZXRjaChtb2R1bGUsIGNvdXJzZWlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KG1vZHVsZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWZlcnJlZHNbc2l0ZWlkXVtpZF07IC8vIFJlbW92ZSBmcm9tIGFycmF5IGJlZm9yZSByZXNvbHZpbmcuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRlZmVycmVkc1tzaXRlaWRdW2lkXTsgLy8gUmVtb3ZlIGZyb20gYXJyYXkgYmVmb3JlIHJlamVjdGluZy5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBlbmFibGVkIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlI3VwZGF0ZVByZWZldGNoSGFuZGxlclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlcyBUaGUgbW9kdWxlIHRoaXMgaGFuZGxlciBoYW5kbGVzLCBlLmcuIGZvcnVtLCBsYWJlbC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJJbmZvIFRoZSBoYW5kbGVyIGRldGFpbHMuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gZW5hYmxlZCwgcmVqZWN0ZWQgd2hlbiBub3QuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYudXBkYXRlUHJlZmV0Y2hIYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlcywgaGFuZGxlckluZm8pIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXJJbmZvLmluc3RhbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJJbmZvLmluc3RhbmNlID0gJG1tVXRpbC5yZXNvbHZlT2JqZWN0KGhhbmRsZXJJbmZvLmhhbmRsZXIsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihoYW5kbGVySW5mby5pbnN0YW5jZS5pc0VuYWJsZWQoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrcyBpZiB0aGUgcHJlZmV0Y2ggaXMgZW5hYmxlZC5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWRIYW5kbGVyc1toYW5kbGVzXSA9IGhhbmRsZXJJbmZvLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW5hYmxlZEhhbmRsZXJzW2hhbmRsZXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgaGFuZGxlcnMgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUjdXBkYXRlUHJlZmV0Y2hIYW5kbGVyc1xuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGRvbmUuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYudXBkYXRlUHJlZmV0Y2hIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1VwZGF0aW5nIHByZWZldGNoIGhhbmRsZXJzIGZvciBjdXJyZW50IHNpdGUuJyk7XG5cbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBhbGwgdGhlIHByZWZldGNoIGhhbmRsZXJzLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHByZWZldGNoSGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXJJbmZvLCBoYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLnVwZGF0ZVByZWZldGNoSGFuZGxlcihoYW5kbGVzLCBoYW5kbGVySW5mbykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXZlciByZWplY3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBzdGF0dXMgb2YgYSBtb2R1bGUgaW4gdGhlIFwiY2FjaGVcIi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSN1cGRhdGVTdGF0dXNDYWNoZVxuICAgICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNDYWNoZSA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHN0YXR1cykge1xuICAgICAgICAgICAgdmFyIG5vdGlmeSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhY2thZ2VpZCA9ICRtbUZpbGVwb29sLmdldFBhY2thZ2VJZChjb21wb25lbnQsIGNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgaWYgKHN0YXR1c0NhY2hlW3BhY2thZ2VpZF0pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3RhdHVzIGhhcyBjaGFuZ2VkLCBub3RpZnkgdGhhdCB0aGUgc2VjdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICBub3RpZnkgPSBzdGF0dXNDYWNoZVtwYWNrYWdlaWRdLnN0YXR1cyAhPT0gc3RhdHVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDYWNoZVtwYWNrYWdlaWRdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0dXNDYWNoZVtwYWNrYWdlaWRdLnN0YXR1cyA9IHN0YXR1cztcblxuICAgICAgICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50U2VjdGlvblN0YXR1c0NoYW5nZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbmlkOiBzdGF0dXNDYWNoZVtwYWNrYWdlaWRdLnNlY3Rpb25pZCxcbiAgICAgICAgICAgICAgICAgICAgc2l0ZWlkOiAkbW1TaXRlLmdldElkKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gc2VsZjtcbn0pXG5cbi5ydW4oZnVuY3Rpb24oJG1tRXZlbnRzLCBtbUNvcmVFdmVudExvZ2luLCBtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCBtbUNvcmVFdmVudExvZ291dCwgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSwgJG1tU2l0ZSxcbiAgICAgICAgICAgIG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQpIHtcbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRMb2dpbiwgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS51cGRhdGVQcmVmZXRjaEhhbmRsZXJzKTtcbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRTaXRlVXBkYXRlZCwgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS51cGRhdGVQcmVmZXRjaEhhbmRsZXJzKTtcbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRMb2dvdXQsICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUuY2xlYXJTdGF0dXNDYWNoZSk7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuc2l0ZWlkID09PSAkbW1TaXRlLmdldElkKCkpIHtcbiAgICAgICAgICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUudXBkYXRlU3RhdHVzQ2FjaGUoZGF0YS5jb21wb25lbnQsIGRhdGEuY29tcG9uZW50SWQsIGRhdGEuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlcycpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgdGhlIGNvdXJzZXMgbGlzdC5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tQ291cnNlc0xpc3RDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbUNvdXJzZXNMaXN0Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJG1tQ291cnNlcywgJG1tQ291cnNlc0RlbGVnYXRlLCAkbW1VdGlsLCAkbW1FdmVudHMsICRtbVNpdGUsXG4gICAgICAgICAgICBtbUNvdXJzZXNFdmVudE15Q291cnNlc1VwZGF0ZWQpIHtcblxuICAgICRzY29wZS5zZWFyY2hFbmFibGVkID0gJG1tQ291cnNlcy5pc1NlYXJjaENvdXJzZXNBdmFpbGFibGUoKTtcbiAgICAkc2NvcGUuYXJlTmF2SGFuZGxlcnNMb2FkZWRGb3IgPSAkbW1Db3Vyc2VzRGVsZWdhdGUuYXJlTmF2SGFuZGxlcnNMb2FkZWRGb3I7XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBmZXRjaCBjb3Vyc2VzLlxuICAgIGZ1bmN0aW9uIGZldGNoQ291cnNlcyhyZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2VzLmdldFVzZXJDb3Vyc2VzKCkudGhlbihmdW5jdGlvbihjb3Vyc2VzKSB7XG4gICAgICAgICAgICAkc2NvcGUuY291cnNlcyA9IGNvdXJzZXM7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY291cnNlcywgZnVuY3Rpb24oY291cnNlKSB7XG4gICAgICAgICAgICAgICAgY291cnNlLl9oYW5kbGVycyA9ICRtbUNvdXJzZXNEZWxlZ2F0ZS5nZXROYXZIYW5kbGVyc0Zvcihjb3Vyc2UuaWQsIHJlZnJlc2gpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuZmlsdGVyVGV4dCA9ICcnOyAvLyBGaWx0ZXIgdmFsdWUgTVVTVCBiZSBzZXQgYWZ0ZXIgY291cnNlcyBhcmUgc2hvd24uXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yICE9ICd1bmRlZmluZWQnICYmIGVycm9yICE9PSAnJykge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3Vyc2VzLmVycm9ybG9hZGNvdXJzZXMnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQ291cnNlcygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5jb3Vyc2VzTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgICRzY29wZS5yZWZyZXNoQ291cnNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1Db3Vyc2VzLmludmFsaWRhdGVVc2VyQ291cnNlcygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmZXRjaENvdXJzZXModHJ1ZSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkbW1FdmVudHMub24obW1Db3Vyc2VzRXZlbnRNeUNvdXJzZXNVcGRhdGVkLCBmdW5jdGlvbihzaXRlaWQpIHtcbiAgICAgICAgaWYgKHNpdGVpZCA9PSAkbW1TaXRlLmdldElkKCkpIHtcbiAgICAgICAgICAgIGZldGNoQ291cnNlcygpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2VzJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGhhbmRsZSBzZWFyY2ggY291cnNlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tQ291cnNlc1NlYXJjaEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tQ291cnNlc1NlYXJjaEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRtbUNvdXJzZXMsICRxLCAkbW1VdGlsKSB7XG5cbiAgICB2YXIgcGFnZSA9IDAsXG4gICAgXHRjdXJyZW50U2VhcmNoID0gJyc7XG5cbiAgICAkc2NvcGUuc2VhcmNoVGV4dCA9ICcnO1xuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2VhcmNoIGNvdXJzZXMuXG4gICAgZnVuY3Rpb24gc2VhcmNoQ291cnNlcyhyZWZyZXNoKSB7XG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICBwYWdlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2VzLnNlYXJjaChjdXJyZW50U2VhcmNoLCBwYWdlKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocGFnZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5jb3Vyc2VzID0gcmVzcG9uc2UuY291cnNlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNvdXJzZXMgPSAkc2NvcGUuY291cnNlcy5jb25jYXQocmVzcG9uc2UuY291cnNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUudG90YWwgPSByZXNwb25zZS50b3RhbDtcblxuICAgICAgICAgICAgcGFnZSsrO1xuICAgICAgICAgICAgJHNjb3BlLmNhbkxvYWRNb3JlID0gJHNjb3BlLmNvdXJzZXMubGVuZ3RoIDwgJHNjb3BlLnRvdGFsO1xuXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEuc2VhcmNoY291cnNlcy5lcnJvcnNlYXJjaGluZycsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkc2NvcGUuc2VhcmNoID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICBjdXJyZW50U2VhcmNoID0gdGV4dDtcbiAgICAgICAgJHNjb3BlLmNvdXJzZXMgPSB1bmRlZmluZWQ7XG5cbiAgICBcdHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW0uY29yZS5zZWFyY2hpbmcnLCB0cnVlKTtcbiAgICBcdHNlYXJjaENvdXJzZXModHJ1ZSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICBcdH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUubG9hZE1vcmVSZXN1bHRzID0gZnVuY3Rpb24oKSB7XG4gICAgXHRzZWFyY2hDb3Vyc2VzKCk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZXMnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIHZpZXcgYSBjb3Vyc2UgdGhhdCB3YXMgc2VhcmNoZWQuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbUNvdXJzZXNWaWV3UmVzdWx0Q3RybFxuICovXG4uY29udHJvbGxlcignbW1Db3Vyc2VzVmlld1Jlc3VsdEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tQ291cnNlcywgJG1tQ291cnNlc0RlbGVnYXRlLCAkbW1VdGlsLCAkdHJhbnNsYXRlLCAkcSxcbiAgICAgICAgICAgICRpb25pY01vZGFsLCAkbW1FdmVudHMsICRtbVNpdGUsIG1tQ291cnNlc1NlYXJjaENvbXBvbmVudCwgbW1Db3Vyc2VzRW5yb2xJbnZhbGlkS2V5LCBtbUNvdXJzZXNFdmVudE15Q291cnNlc1VwZGF0ZWQpIHtcblxuICAgIHZhciBjb3Vyc2UgPSAkc3RhdGVQYXJhbXMuY291cnNlIHx8IHt9LFxuICAgICAgICBzZWxmRW5yb2xXU0F2YWlsYWJsZSA9ICRtbUNvdXJzZXMuaXNTZWxmRW5yb2xtZW50RW5hYmxlZCgpLFxuICAgICAgICBndWVzdFdTQXZhaWxhYmxlID0gJG1tQ291cnNlcy5pc0d1ZXN0V1NBdmFpbGFibGUoKSxcbiAgICAgICAgaXNHdWVzdEVuYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgZ3Vlc3RJbnN0YW5jZUlkLFxuICAgICAgICBoYW5kbGVyc1Nob3VsZEJlU2hvd24gPSB0cnVlLFxuICAgICAgICBlbnJvbGxtZW50TWV0aG9kcztcblxuICAgICRzY29wZS5jb3Vyc2UgPSBjb3Vyc2U7XG4gICAgJHNjb3BlLnRpdGxlID0gY291cnNlLmZ1bGxuYW1lO1xuICAgICRzY29wZS5jb21wb25lbnQgPSBtbUNvdXJzZXNTZWFyY2hDb21wb25lbnQ7XG4gICAgJHNjb3BlLnNlbGZFbnJvbEluc3RhbmNlcyA9IFtdO1xuICAgICRzY29wZS5lbnJvbGRhdGEgPSB7XG4gICAgICAgIHBhc3N3b3JkOiAnJ1xuICAgIH07XG5cbiAgICAvLyBGdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgaGFuZGxlcnMgYXJlIGJlaW5nIGxvYWRlZC5cbiAgICAkc2NvcGUubG9hZGluZ0hhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyc1Nob3VsZEJlU2hvd24gJiYgISRtbUNvdXJzZXNEZWxlZ2F0ZS5hcmVOYXZIYW5kbGVyc0xvYWRlZEZvcihjb3Vyc2UuaWQpO1xuICAgIH07XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgY291cnNlLiBXZSB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgYSB1c2VyIGNhbiBzZWUgdGhlIGNvdXJzZSBvciBub3QuXG4gICAgZnVuY3Rpb24gZ2V0Q291cnNlKHJlZnJlc2gpIHtcbiAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgIGlmIChzZWxmRW5yb2xXU0F2YWlsYWJsZSB8fCBndWVzdFdTQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAvLyBHZXQgY291cnNlIGVucm9sbWVudCBtZXRob2RzLlxuICAgICAgICAgICAgJHNjb3BlLnNlbGZFbnJvbEluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgcHJvbWlzZSA9ICRtbUNvdXJzZXMuZ2V0Q291cnNlRW5yb2xtZW50TWV0aG9kcyhjb3Vyc2UuaWQpLnRoZW4oZnVuY3Rpb24obWV0aG9kcykge1xuICAgICAgICAgICAgICAgIGVucm9sbG1lbnRNZXRob2RzID0gbWV0aG9kcztcblxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbnJvbGxtZW50TWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmRW5yb2xXU0F2YWlsYWJsZSAmJiBtZXRob2QudHlwZSA9PT0gJ3NlbGYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2VsZkVucm9sSW5zdGFuY2VzLnB1c2gobWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChndWVzdFdTQXZhaWxhYmxlICYmIG1ldGhvZC50eXBlID09PSAnZ3Vlc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0d1ZXN0RW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oKTsgLy8gTm8gbmVlZCB0byBnZXQgZW5yb2xtZW50IG1ldGhvZHMuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBpcyBlbnJvbGxlZCBpbiB0aGUgY291cnNlLlxuICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZXMuZ2V0VXNlckNvdXJzZShjb3Vyc2UuaWQpLnRoZW4oZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgICRzY29wZS5pc0Vucm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGlzIG5vdCBlbnJvbGxlZCBpbiB0aGUgY291cnNlLiBVc2UgZ2V0Q291cnNlcyB0byBzZWUgaWYgaXQncyBhbiBhZG1pbi9tYW5hZ2VyIGFuZCBjYW4gc2VlIHRoZSBjb3Vyc2UuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmlzRW5yb2xsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ291cnNlcy5nZXRDb3Vyc2UoY291cnNlLmlkKTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MgcmV0cmlldmluZyB0aGUgY291cnNlLCB3ZSBjYW4gYXNzdW1lIHRoZSB1c2VyIGhhcyBwZXJtaXNzaW9ucyB0byB2aWV3IGl0LlxuICAgICAgICAgICAgICAgIGNvdXJzZS5mdWxsbmFtZSA9IGMuZnVsbG5hbWUgfHwgY291cnNlLmZ1bGxuYW1lO1xuICAgICAgICAgICAgICAgIGNvdXJzZS5zdW1tYXJ5ID0gYy5zdW1tYXJ5IHx8IGNvdXJzZS5zdW1tYXJ5O1xuICAgICAgICAgICAgICAgIGNvdXJzZS5faGFuZGxlcnMgPSAkbW1Db3Vyc2VzRGVsZWdhdGUuZ2V0TmF2SGFuZGxlcnNGb3IoY291cnNlLmlkLCByZWZyZXNoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGlzIG5vdCBhbiBhZG1pbi9tYW5hZ2VyLiBDaGVjayBpZiB3ZSBjYW4gcHJvdmlkZSBndWVzdCBhY2Nlc3MgdG8gdGhlIGNvdXJzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuQWNjZXNzQXNHdWVzdCgpLnRoZW4oZnVuY3Rpb24ocGFzc3dvcmRSZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhc3N3b3JkUmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdXJzZS5faGFuZGxlcnMgPSAkbW1Db3Vyc2VzRGVsZWdhdGUuZ2V0TmF2SGFuZGxlcnNGb3JHdWVzdChjb3Vyc2UuaWQsIHJlZnJlc2gpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291cnNlLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNTaG91bGRCZVNob3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY291cnNlLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1Nob3VsZEJlU2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgdXNlciBjYW4gYWNjZXNzIGFzIGd1ZXN0LlxuICAgIGZ1bmN0aW9uIGNhbkFjY2Vzc0FzR3Vlc3QoKSB7XG4gICAgICAgIGlmICghaXNHdWVzdEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZWFyY2ggaW5zdGFuY2UgSUQgb2YgZ3Vlc3QgZW5yb2xtZW50IG1ldGhvZC5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVucm9sbG1lbnRNZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QudHlwZSA9PSAnZ3Vlc3QnKSB7XG4gICAgICAgICAgICAgICAgZ3Vlc3RJbnN0YW5jZUlkID0gbWV0aG9kLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ3Vlc3RJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tQ291cnNlcy5nZXRDb3Vyc2VHdWVzdEVucm9sbWVudEluZm8oZ3Vlc3RJbnN0YW5jZUlkKS50aGVuKGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluZm8uc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhY3RpdmUsIHJlamVjdC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5mby5wYXNzd29yZHJlcXVpcmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hEYXRhKCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKCRtbUNvdXJzZXMuaW52YWxpZGF0ZVVzZXJDb3Vyc2VzKCkpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCRtbUNvdXJzZXMuaW52YWxpZGF0ZUNvdXJzZShjb3Vyc2UuaWQpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1Db3Vyc2VzLmludmFsaWRhdGVDb3Vyc2VFbnJvbG1lbnRNZXRob2RzKGNvdXJzZS5pZCkpO1xuICAgICAgICBpZiAoZ3Vlc3RJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbUNvdXJzZXMuaW52YWxpZGF0ZUNvdXJzZUd1ZXN0RW5yb2xtZW50SW5mbyhndWVzdEluc3RhbmNlSWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q291cnNlKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRDb3Vyc2UoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuY291cnNlTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgICRzY29wZS5kb1JlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVmcmVzaERhdGEoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChzZWxmRW5yb2xXU0F2YWlsYWJsZSAmJiBjb3Vyc2UuZW5yb2xsbWVudG1ldGhvZHMuaW5kZXhPZignc2VsZicpID4gLTEpIHtcbiAgICAgICAgLy8gU2V0dXAgcGFzc3dvcmQgbW9kYWwgZm9yIHNlbGYtZW5yb2xtZW50LlxuICAgICAgICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ2NvcmUvY29tcG9uZW50cy9jb3Vyc2VzL3RlbXBsYXRlcy9wYXNzd29yZC1tb2RhbC5odG1sJywge1xuICAgICAgICAgICAgc2NvcGU6ICRzY29wZSxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogJ3NsaWRlLWluLXVwJ1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgICAgICAgICAkc2NvcGUubW9kYWwgPSBtb2RhbDtcblxuICAgICAgICAgICAgJHNjb3BlLmNsb3NlTW9kYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZW5yb2xkYXRhLnBhc3N3b3JkID0gJyc7XG4gICAgICAgICAgICAgICAgZGVsZXRlICRzY29wZS5jdXJyZW50RW5yb2xJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBtb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzZWxmLWVucm9sIGEgdXNlciBpbiBhIGNvdXJzZS5cbiAgICAgICAgJHNjb3BlLmVucm9sID0gZnVuY3Rpb24oaW5zdGFuY2VJZCwgcGFzc3dvcmQpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgICAgICBpZiAoJHNjb3BlLm1vZGFsLmlzU2hvd24oKSkge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHNob3cgY29uZmlybSBpZiBwYXNzd29yZCBpcyBzaG93biwgd2UgYWxyZWFkeSBzaG93ZWQgaXQgYmVmb3JlLlxuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1VdGlsLnNob3dDb25maXJtKCR0cmFuc2xhdGUoJ21tLmNvdXJzZXMuY29uZmlybXNlbGZlbnJvbCcpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW0uY29yZS5sb2FkaW5nJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAkbW1Db3Vyc2VzLnNlbGZFbnJvbChjb3Vyc2UuaWQsIHBhc3N3b3JkLCBpbnN0YW5jZUlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBtb2RhbCBhbmQgcmVmcmVzaCBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VNb2RhbCgpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaXNFbnJvbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hEYXRhKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE15IGNvdXJzZXMgaGF2ZSBiZWVuIHVwZGF0ZWQsIHRyaWdnZXIgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbUNvdXJzZXNFdmVudE15Q291cnNlc1VwZGF0ZWQsICRtbVNpdGUuZ2V0SWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IG1tQ291cnNlc0Vucm9sSW52YWxpZEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgcGFzc3dvcmQuIElmIHBhc3N3b3JkIHdhcyBhbHJlYWR5IHNob3duLCBzaG93IGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5tb2RhbC5pc1Nob3duKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY3VycmVudEVucm9sSW5zdGFuY2UgPSBpbnN0YW5jZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubW9kYWwuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3Vyc2VzLmVycm9yc2VsZmVucm9sJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2VzJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGhhbmRsZSBzaXRlIGNvdXJzZXMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Db3Vyc2VzXG4gKi9cbi5mYWN0b3J5KCckbW1Db3Vyc2VzJywgZnVuY3Rpb24oJHEsICRtbVNpdGUsICRsb2csICRtbVNpdGVzTWFuYWdlciwgbW1Db3Vyc2VzU2VhcmNoUGVyUGFnZSwgbW1Db3Vyc2VzRW5yb2xJbnZhbGlkS2V5KSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tQ291cnNlcycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgY3VycmVudENvdXJzZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAgICogQ2xlYXIgY3VycmVudCBjb3Vyc2VzIGFycmF5LiBSZXNlcnZlZCBmb3IgY29yZSB1c2UuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLmNsZWFyQ3VycmVudENvdXJzZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY3VycmVudENvdXJzZXMgPSB7fTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNvdXJzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjZ2V0Q291cnNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkICAgICAgIElEIG9mIHRoZSBjb3Vyc2UgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZWlkXSBTaXRlIHRvIGdldCB0aGUgY291cnNlcyBmcm9tLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBjb3Vyc2VzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRDb3Vyc2UgPSBmdW5jdGlvbihpZCwgc2l0ZWlkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldENvdXJzZXMoW2lkXSwgc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKGNvdXJzZXMpIHtcbiAgICAgICAgICAgIGlmIChjb3Vyc2VzICYmIGNvdXJzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3Vyc2VzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlbnJvbG1lbnQgbWV0aG9kcyBmcm9tIGEgY291cnNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNnZXRDb3Vyc2VFbnJvbG1lbnRNZXRob2RzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIElEIG9mIHRoZSBjb3Vyc2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgbWV0aG9kcyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Q291cnNlRW5yb2xtZW50TWV0aG9kcyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY291cnNlaWQ6IGlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0Q291cnNlRW5yb2xtZW50TWV0aG9kc0NhY2hlS2V5KGlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdjb3JlX2Vucm9sX2dldF9jb3Vyc2VfZW5yb2xtZW50X21ldGhvZHMnLCBwYXJhbXMsIHByZVNldHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBnZXQgY291cnNlIGVucm9sbWVudCBtZXRob2RzIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb3Vyc2VFbnJvbG1lbnRNZXRob2RzQ2FjaGVLZXkoaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbUNvdXJzZXM6ZW5yb2xtZW50bWV0aG9kczonICsgaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGluZm8gZnJvbSBhIGNvdXJzZSBndWVzdCBlbnJvbG1lbnQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNnZXRDb3Vyc2VHdWVzdEVucm9sbWVudEluZm9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VJZCBHdWVzdCBpbnN0YW5jZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGluZm8gaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Q291cnNlR3Vlc3RFbnJvbG1lbnRJbmZvID0gZnVuY3Rpb24oaW5zdGFuY2VJZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlaWQ6IGluc3RhbmNlSWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRDb3Vyc2VHdWVzdEVucm9sbWVudEluZm9DYWNoZUtleShpbnN0YW5jZUlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdlbnJvbF9ndWVzdF9nZXRfaW5zdGFuY2VfaW5mbycsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmluc3RhbmNlaW5mbztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGdldCBjb3Vyc2UgZW5yb2xtZW50IG1ldGhvZHMgV1MgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZUlkIEd1ZXN0IGluc3RhbmNlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb3Vyc2VHdWVzdEVucm9sbWVudEluZm9DYWNoZUtleShpbnN0YW5jZUlkKSB7XG4gICAgICAgIHJldHVybiAnbW1Db3Vyc2VzOmd1ZXN0aW5mbzonICsgaW5zdGFuY2VJZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY291cnNlcy5cbiAgICAgKiBXYXJuaW5nOiBpZiB0aGUgdXNlciBkb2Vzbid0IGhhdmUgcGVybWlzc2lvbnMgdG8gdmlldyBzb21lIG9mIHRoZSBjb3Vyc2VzIHBhc3NlZCB0aGUgV1MgY2FsbCB3aWxsIGZhaWwuXG4gICAgICogVGhlIHVzZXIgbXVzdCBiZSBhYmxlIHRvIHZpZXcgQUxMIHRoZSBjb3Vyc2VzIHBhc3NlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjZ2V0Q291cnNlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGlkcyAgICBMaXN0IG9mIElEcyBvZiB0aGUgY291cnNlcyB0byBnZXQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlaWRdIFNpdGUgdG8gZ2V0IHRoZSBjb3Vyc2VzIGZyb20uIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGNvdXJzZXMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldENvdXJzZXMgPSBmdW5jdGlvbihpZHMsIHNpdGVpZCkge1xuICAgICAgICBzaXRlaWQgPSBzaXRlaWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIGlmICghYW5ndWxhci5pc0FycmF5KGlkcykpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkczogaWRzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRDb3Vyc2VzQ2FjaGVLZXkoaWRzKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBzaXRlLnJlYWQoJ2NvcmVfY291cnNlX2dldF9jb3Vyc2VzJywgZGF0YSwgcHJlU2V0cykudGhlbihmdW5jdGlvbihjb3Vyc2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb3Vyc2VzICE9ICdvYmplY3QnICYmICFhbmd1bGFyLmlzQXJyYXkoY291cnNlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZ2V0IGNvdXJzZXMgV1MgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcltdfSBpZHMgQ291cnNlcyBJRHMuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q291cnNlc0NhY2hlS2V5KGlkcykge1xuICAgICAgICByZXR1cm4gJ21tQ291cnNlczpjb3Vyc2U6JyArIEpTT04uc3RyaW5naWZ5KGlkcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogREVQUkVDQVRFRDogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gUGxlYXNlIHVzZSAkbW1Db3Vyc2VzI2dldFVzZXJDb3Vyc2UuXG4gICAgICogR2V0IGEgY291cnNlIHN0b3JlZCBpbiBtZW1vcnkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzI2dldFN0b3JlZENvdXJzZVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgSUQgb2YgdGhlIGNvdXJzZSB0byBnZXQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICBDb3Vyc2UuXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjVcbiAgICAgKi9cbiAgICBzZWxmLmdldFN0b3JlZENvdXJzZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICRsb2cud2FybignVGhlIGZ1bmN0aW9uIFxcJ2dldFN0b3JlZENvdXJzZVxcJyBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFxcJ2dldFVzZXJDb3Vyc2VcXCcgaW5zdGVhZCcpO1xuICAgICAgICByZXR1cm4gY3VycmVudENvdXJzZXNbaWRdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBjb3Vyc2UgdGhlIHVzZXIgaXMgZW5yb2xsZWQgaW4uIFRoaXMgZnVuY3Rpb24gcmVsaWVzIG9uICRtbUNvdXJzZXMjZ2V0VXNlckNvdXJzZXMuXG4gICAgICogcHJlZmVyQ2FjaGU9dHJ1ZSB3aWxsIHRyeSB0byBzcGVlZCB1cCB0aGUgcmVzcG9uc2UsIGJ1dCB0aGUgZGF0YSByZXR1cm5lZCBtaWdodCBub3QgYmUgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjZ2V0VXNlckNvdXJzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAgICAgICAgICAgICAgICAgICBJRCBvZiB0aGUgY291cnNlIHRvIGdldC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmVmZXJDYWNoZT1mYWxzZV0gVHJ1ZSBpZiBzaG91bGRuJ3QgY2FsbCBXUyBpZiBkYXRhIGlzIGNhY2hlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZWlkXSAgICAgICAgICAgICBTaXRlIHRvIGdldCB0aGUgY291cnNlcyBmcm9tLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBjb3Vyc2UuXG4gICAgICogQHNpbmNlIDIuNVxuICAgICAqL1xuICAgIHNlbGYuZ2V0VXNlckNvdXJzZSA9IGZ1bmN0aW9uKGlkLCBwcmVmZXJDYWNoZSwgc2l0ZWlkKSB7XG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmZXJDYWNoZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcHJlZmVyQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLmdldFVzZXJDb3Vyc2VzKHByZWZlckNhY2hlLCBzaXRlaWQpLnRoZW4oZnVuY3Rpb24oY291cnNlcykge1xuICAgICAgICAgICAgdmFyIGNvdXJzZTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb3Vyc2VzLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuaWQgPT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY291cnNlID0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3Vyc2UgPyBjb3Vyc2UgOiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGNvdXJzZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzI2dldFVzZXJDb3Vyc2VzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJlZmVyQ2FjaGU9ZmFsc2VdIFRydWUgaWYgc2hvdWxkbid0IGNhbGwgV1MgaWYgZGF0YSBpcyBjYWNoZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVpZF0gICAgICAgICAgICBTaXRlIHRvIGdldCB0aGUgY291cnNlcyBmcm9tLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGNvdXJzZXMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFVzZXJDb3Vyc2VzID0gZnVuY3Rpb24ocHJlZmVyQ2FjaGUsIHNpdGVpZCkge1xuICAgICAgICBzaXRlaWQgPSBzaXRlaWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICBpZiAodHlwZW9mIHByZWZlckNhY2hlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwcmVmZXJDYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG5cbiAgICAgICAgICAgIHZhciB1c2VyaWQgPSBzaXRlLmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgICAgIHByZXNldHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRVc2VyQ291cnNlc0NhY2hlS2V5KCksXG4gICAgICAgICAgICAgICAgICAgIG9taXRFeHBpcmVzOiBwcmVmZXJDYWNoZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGF0YSA9IHt1c2VyaWQ6IHVzZXJpZH07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcmlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNpdGUucmVhZCgnY29yZV9lbnJvbF9nZXRfdXNlcnNfY291cnNlcycsIGRhdGEsIHByZXNldHMpLnRoZW4oZnVuY3Rpb24oY291cnNlcykge1xuICAgICAgICAgICAgICAgIGlmIChzaXRlaWQgPT09ICRtbVNpdGUuZ2V0SWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN0b3JlIGNvdXJzZXMgaWYgd2UncmUgZ2V0dGluZyBjdXJyZW50IHNpdGUgY291cnNlcy4gVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlQ291cnNlc0luTWVtb3J5KGNvdXJzZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZ2V0IHVzZXIgY291cnNlcyBXUyBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VXNlckNvdXJzZXNDYWNoZUtleSgpIHtcbiAgICAgICAgcmV0dXJuICdtbUNvdXJzZXM6dXNlcmNvdXJzZXMnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIGdldCBjb3Vyc2UgV1MgY2FsbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjaW52YWxpZGF0ZUNvdXJzZVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUNvdXJzZSA9IGZ1bmN0aW9uKGlkLCBzaXRlaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW52YWxpZGF0ZUNvdXJzZXMoW2lkXSwgc2l0ZWlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgZ2V0IGNvdXJzZSBlbnJvbG1lbnQgbWV0aG9kcyBXUyBjYWxsLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNpbnZhbGlkYXRlVXNlckNvdXJzZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQ291cnNlRW5yb2xtZW50TWV0aG9kcyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldENvdXJzZUVucm9sbWVudE1ldGhvZHNDYWNoZUtleShpZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBnZXQgY291cnNlIGd1ZXN0IGVucm9sbWVudCBpbmZvIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzI2ludmFsaWRhdGVVc2VyQ291cnNlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZUlkIEd1ZXN0IGluc3RhbmNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDb3Vyc2VHdWVzdEVucm9sbWVudEluZm8gPSBmdW5jdGlvbihpbnN0YW5jZUlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldENvdXJzZUd1ZXN0RW5yb2xtZW50SW5mb0NhY2hlS2V5KGluc3RhbmNlSWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgZ2V0IGNvdXJzZXMgV1MgY2FsbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjaW52YWxpZGF0ZUNvdXJzZXNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJbXX0gaWRzICAgQ291cnNlcyBJRHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlaWRdIFNpdGUgSUQgdG8gaW52YWxpZGF0ZS4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDb3Vyc2VzID0gZnVuY3Rpb24oaWRzLCBzaXRlaWQpIHtcbiAgICAgICAgc2l0ZWlkID0gc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRDb3Vyc2VzQ2FjaGVLZXkoaWRzKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBnZXQgdXNlciBjb3Vyc2VzIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzI2ludmFsaWRhdGVVc2VyQ291cnNlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZWlkXSBTaXRlIElEIHRvIGludmFsaWRhdGUuIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlVXNlckNvdXJzZXMgPSBmdW5jdGlvbihzaXRlaWQpIHtcbiAgICAgICAgc2l0ZWlkID0gc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRVc2VyQ291cnNlc0NhY2hlS2V5KCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgV1MgdG8gcmV0cmlldmUgZ3Vlc3QgZW5yb2xtZW50IGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNpc0d1ZXN0V1NBdmFpbGFibGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGd1ZXN0IFdTIGlzIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNHdWVzdFdTQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdlbnJvbF9ndWVzdF9nZXRfaW5zdGFuY2VfaW5mbycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBzZWFyY2ggY291cnNlcyBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNpc1NlYXJjaENvdXJzZXNBdmFpbGFibGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGlzIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNTZWFyY2hDb3Vyc2VzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX2NvdXJzZV9zZWFyY2hfY291cnNlcycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBzZWxmIGVucm9sbWVudCBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzI2lzU2VsZkVucm9sbWVudEVuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHNlbGYgZW5yb2xtZW50IGlzIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNTZWxmRW5yb2xtZW50RW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53c0F2YWlsYWJsZSgnZW5yb2xfc2VsZl9lbnJvbF91c2VyJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBjb3Vyc2VzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNzZWFyY2hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAgICAgIFRleHQgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFnZV0gICAgUGFnZSB0byBnZXQuIERlZmF1bHRzIHRvIDAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwZXJwYWdlXSBOdW1iZXIgb2YgY291cnNlcyBwZXIgcGFnZS4gRGVmYXVsdHMgdG8gbW1Db3Vyc2VzU2VhcmNoUGVyUGFnZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgY291cnNlcyBhbmQgdGhlIHRvdGFsIG9mIG1hdGNoZXMuXG4gICAgICovXG4gICAgc2VsZi5zZWFyY2ggPSBmdW5jdGlvbih0ZXh0LCBwYWdlLCBwZXJwYWdlKSB7XG4gICAgICAgIHBhZ2UgPSBwYWdlIHx8IDA7XG4gICAgICAgIHBlcnBhZ2UgPSBwZXJwYWdlIHx8IG1tQ291cnNlc1NlYXJjaFBlclBhZ2U7XG5cbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjcml0ZXJpYW5hbWU6ICdzZWFyY2gnLFxuICAgICAgICAgICAgICAgIGNyaXRlcmlhdmFsdWU6IHRleHQsXG4gICAgICAgICAgICAgICAgcGFnZTogcGFnZSxcbiAgICAgICAgICAgICAgICBwZXJwYWdlOiBwZXJwYWdlXG4gICAgICAgICAgICB9LCBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGdldEZyb21DYWNoZTogZmFsc2VcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnY29yZV9jb3Vyc2Vfc2VhcmNoX2NvdXJzZXMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3RvdGFsOiByZXNwb25zZS50b3RhbCwgY291cnNlczogcmVzcG9uc2UuY291cnNlc307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZWxmIGVucm9sIGN1cnJlbnQgdXNlciBpbiBhIGNlcnRhaW4gY291cnNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNzZWxmRW5yb2xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY291cnNlaWQgICAgIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3Bhc3N3b3JkXSAgIFBhc3N3b3JkIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luc3RhbmNlSWRdIEVucm9sIGluc3RhbmNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCBpZiB0aGUgdXNlciBpcyBlbnJvbGxlZC4gSWYgdGhlIHBhc3N3b3JkIGlzIGludmFsaWQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIGFuIG9iamVjdCB3aXRoIGNvZGUgPSBtbUNvdXJzZXNFbnJvbEludmFsaWRLZXkuXG4gICAgICovXG4gICAgc2VsZi5zZWxmRW5yb2wgPSBmdW5jdGlvbihjb3Vyc2VpZCwgcGFzc3dvcmQsIGluc3RhbmNlSWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGFzc3dvcmQgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlaWQsXG4gICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluc3RhbmNlSWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5pbnN0YW5jZWlkID0gaW5zdGFuY2VJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdlbnJvbF9zZWxmX2Vucm9sX3VzZXInLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS53YXJuaW5ncyAmJiByZXNwb25zZS53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNwb25zZS53YXJuaW5ncywgZnVuY3Rpb24od2FybmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhcm5pbmcud2FybmluZ2NvZGUgPT0gJzInIHx8wqB3YXJuaW5nLndhcm5pbmdjb2RlID09ICc0JykgeyAvLyBJbnZhbGlkIHBhc3N3b3JkIHdhcm5pbmdzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB3YXJuaW5nLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KHtjb2RlOiBtbUNvdXJzZXNFbnJvbEludmFsaWRLZXksIG1lc3NhZ2U6IG1lc3NhZ2V9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAgICogU3RvcmVzIGEgbGlzdCBvZiBjb3Vyc2VzIGluIG1lbW9yeSBzbyB0aGV5IGNhbiBiZSByZXRyaWV2ZWQgbGF0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gY291cnNlcyBDb3Vyc2VzIHRvIHN0b3JlXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3JlQ291cnNlc0luTWVtb3J5KGNvdXJzZXMpIHtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvdXJzZXMsIGZ1bmN0aW9uKGNvdXJzZSkge1xuICAgICAgICAgICAgY3VycmVudENvdXJzZXNbY291cnNlLmlkXSA9IGFuZ3VsYXIuY29weShjb3Vyc2UpOyAvLyBTdG9yZSBhIGNvcHkgdG8gcHJldmVudCB1bndhbnRlZCBtb2RpZmljYXRpb25zLlxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZXMnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gaW50ZXJhY3Qgd2l0aCBjb3Vyc2VzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQ291cnNlc0RlbGVnYXRlXG4gKi9cbi5wcm92aWRlcignJG1tQ291cnNlc0RlbGVnYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hdkhhbmRsZXJzID0ge30sXG4gICAgICAgIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgbmF2aWdhdGlvbiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlc0RlbGVnYXRlI3JlZ2lzdGVyTmF2SGFuZGxlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRvbiBUaGUgYWRkb24ncyBuYW1lIChtbWFMYWJlbCwgbW1hRm9ydW0sIC4uLilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IGhhbmRsZXIgTXVzdCBiZSByZXNvbHZlZCB0byBhbiBvYmplY3QgZGVmaW5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMuIE9yIHRvIGEgZnVuY3Rpb25cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmluZyBhbiBvYmplY3QgZGVmaW5pbmcgdGhlc2UgZnVuY3Rpb25zLiBTZWUge0BsaW5rICRtbVV0aWwjcmVzb2x2ZU9iamVjdH0uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gaXNFbmFibGVkIChCb29sZWFufFByb21pc2UpIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgb24gYSBzaXRlIGxldmVsLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHVzaW5nIGEgcHJvbWlzZSwgaXQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gaXNFbmFibGVkRm9yQ291cnNlKGNvdXJzZWlkLCBhY2Nlc3NEYXRhKSAoQm9vbGVhbnxQcm9taXNlKSBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkIG9uIGEgY291cnNlIGxldmVsLiBXaGVuIHVzaW5nIGEgcHJvbWlzZSwgaXQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gZ2V0Q29udHJvbGxlcihjb3Vyc2VpZCkgKE9iamVjdCkgUmV0dXJucyB0aGUgb2JqZWN0IHRoYXQgd2lsbCBhY3QgYXMgY29udHJvbGxlci5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgY29yZS9jb21wb25lbnRzL2NvdXJzZXMvdGVtcGxhdGVzL2xpc3QuaHRtbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgbGlzdCBvZiBzY29wZSB2YXJpYWJsZXMgZXhwZWN0ZWQuXG4gICAgICovXG4gICAgc2VsZi5yZWdpc3Rlck5hdkhhbmRsZXIgPSBmdW5jdGlvbihhZGRvbiwgaGFuZGxlciwgcHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYXZIYW5kbGVyc1thZGRvbl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiRtbUNvdXJzZXNEZWxlZ2F0ZVByb3ZpZGVyOiBBZGRvbiAnXCIgKyBuYXZIYW5kbGVyc1thZGRvbl0uYWRkb24gKyBcIicgYWxyZWFkeSByZWdpc3RlcmVkIGFzIG5hdmlnYXRpb24gaGFuZGxlclwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIiRtbUNvdXJzZXNEZWxlZ2F0ZVByb3ZpZGVyOiBSZWdpc3RlcmVkIGFkZG9uICdcIiArIGFkZG9uICsgXCInIGFzIG5hdmlnYXRpb24gaGFuZGxlci5cIik7XG4gICAgICAgIG5hdkhhbmRsZXJzW2FkZG9uXSA9IHtcbiAgICAgICAgICAgIGFkZG9uOiBhZGRvbixcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICBpbnN0YW5jZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBzZWxmLiRnZXQgPSBmdW5jdGlvbigkbW1VdGlsLCAkcSwgJGxvZywgJG1tU2l0ZSwgbW1Db3Vyc2VzQWNjZXNzTWV0aG9kcykge1xuICAgICAgICB2YXIgZW5hYmxlZE5hdkhhbmRsZXJzID0ge30sXG4gICAgICAgICAgICBjb3Vyc2VzSGFuZGxlcnMgPSB7fSxcbiAgICAgICAgICAgIHNlbGYgPSB7fSxcbiAgICAgICAgICAgIGxvYWRlZCA9IHt9O1xuXG4gICAgICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Db3Vyc2VzRGVsZWdhdGUnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYWRkb25zIGFyZSBsb2FkZWQgZm9yIGEgY2VydGFpbiBjb3Vyc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlc0RlbGVnYXRlI2FyZU5hdkhhbmRsZXJzTG9hZGVkRm9yXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGFkZG9ucyBhcmUgbG9hZGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmFyZU5hdkhhbmRsZXJzTG9hZGVkRm9yID0gZnVuY3Rpb24oY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZWRbY291cnNlSWRdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhbGwgY291cnNlcyBoYW5kbGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzRGVsZWdhdGUjY2xlYXJDb3Vyc2VzSGFuZGxlcnNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5jbGVhckNvdXJzZXNIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY291cnNlc0hhbmRsZXJzID0ge307XG4gICAgICAgICAgICBsb2FkZWQgPSB7fTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBoYW5kbGVyIGZvciBhIGNvdXJzZSB1c2luZyBhIGNlcnRhaW4gYWNjZXNzIHR5cGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCAgICBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZnJlc2ggICAgVHJ1ZSBpZiBpdCBzaG91bGQgcmVmcmVzaCB0aGUgbGlzdC5cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBhY2Nlc3NEYXRhIEFjY2VzcyB0eXBlIGFuZCBkYXRhLiBEZWZhdWx0LCBndWVzdCwgLi4uXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICBBcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgJ3ByaW9yaXR5JyBhbmQgJ2NvbnRyb2xsZXInLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0TmF2SGFuZGxlcnNGb3JBY2Nlc3MoY291cnNlSWQsIHJlZnJlc2gsIGFjY2Vzc0RhdGEpIHtcbiAgICAgICAgICAgIGlmIChyZWZyZXNoIHx8wqAhY291cnNlc0hhbmRsZXJzW2NvdXJzZUlkXSB8fCBjb3Vyc2VzSGFuZGxlcnNbY291cnNlSWRdLmFjY2Vzcy50eXBlICE9IGFjY2Vzc0RhdGEudHlwZSkge1xuICAgICAgICAgICAgICAgIGNvdXJzZXNIYW5kbGVyc1tjb3Vyc2VJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VzczogYWNjZXNzRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZU5hdkhhbmRsZXJzRm9yQ291cnNlKGNvdXJzZUlkLCBhY2Nlc3NEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3Vyc2VzSGFuZGxlcnNbY291cnNlSWRdLmhhbmRsZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaGFuZGxlcnMgZm9yIGEgY291cnNlIHdoZXJlIHRoZSB1c2VyIGlzIGVucm9sbGVkIGluLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZXNEZWxlZ2F0ZSNnZXROYXZIYW5kbGVyc0ZvclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSByZWZyZXNoIFRydWUgaWYgaXQgc2hvdWxkIHJlZnJlc2ggdGhlIGxpc3QuXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBBcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgJ3ByaW9yaXR5JyBhbmQgJ2NvbnRyb2xsZXInLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXROYXZIYW5kbGVyc0ZvciA9IGZ1bmN0aW9uKGNvdXJzZUlkLCByZWZyZXNoKSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGFjY2Vzcy5cbiAgICAgICAgICAgIHZhciBhY2Nlc3NEYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG1tQ291cnNlc0FjY2Vzc01ldGhvZHMuZGVmYXVsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBnZXROYXZIYW5kbGVyc0ZvckFjY2Vzcyhjb3Vyc2VJZCwgcmVmcmVzaCwgYWNjZXNzRGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaGFuZGxlcnMgZm9yIGEgY291cnNlIGFzIGd1ZXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZXNEZWxlZ2F0ZSNnZXROYXZIYW5kbGVyc0Zvckd1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZnJlc2ggVHJ1ZSBpZiBpdCBzaG91bGQgcmVmcmVzaCB0aGUgbGlzdC5cbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIEFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyAncHJpb3JpdHknIGFuZCAnY29udHJvbGxlcicuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldE5hdkhhbmRsZXJzRm9yR3Vlc3QgPSBmdW5jdGlvbihjb3Vyc2VJZCwgcmVmcmVzaCkge1xuICAgICAgICAgICAgLy8gR3Vlc3QgYWNjZXNzLlxuICAgICAgICAgICAgdmFyIGFjY2Vzc0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbW1Db3Vyc2VzQWNjZXNzTWV0aG9kcy5ndWVzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBnZXROYXZIYW5kbGVyc0ZvckFjY2Vzcyhjb3Vyc2VJZCwgcmVmcmVzaCwgYWNjZXNzRGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgaGFuZGxlciBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzRGVsZWdhdGUjdXBkYXRlTmF2SGFuZGxlclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkb24gVGhlIGFkZG9uLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlckluZm8gVGhlIGhhbmRsZXIgZGV0YWlscy5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBlbmFibGVkLCByZWplY3RlZCB3aGVuIG5vdC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi51cGRhdGVOYXZIYW5kbGVyID0gZnVuY3Rpb24oYWRkb24sIGhhbmRsZXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVySW5mby5pbnN0YW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVySW5mby5pbnN0YW5jZSA9ICRtbVV0aWwucmVzb2x2ZU9iamVjdChoYW5kbGVySW5mby5oYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oaGFuZGxlckluZm8uaW5zdGFuY2UuaXNFbmFibGVkKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGNvbnRlbnQgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWROYXZIYW5kbGVyc1thZGRvbl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaGFuZGxlckluZm8uaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogaGFuZGxlckluZm8ucHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVuYWJsZWROYXZIYW5kbGVyc1thZGRvbl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBoYW5kbGVycyBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzRGVsZWdhdGUjdXBkYXRlTmF2SGFuZGxlcnNcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBkb25lLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnVwZGF0ZU5hdkhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVXBkYXRpbmcgbmF2aWdhdGlvbiBoYW5kbGVycyBmb3IgY3VycmVudCBzaXRlLicpO1xuXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgYWxsIHRoZSBjb250ZW50IGhhbmRsZXJzLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG5hdkhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVySW5mbywgYWRkb24pIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYudXBkYXRlTmF2SGFuZGxlcihhZGRvbiwgaGFuZGxlckluZm8pKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gTmV2ZXIgcmVqZWN0LlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgaGFuZGxlcnMgZm9yIGFsbCBjb3Vyc2VzLlxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb3Vyc2VzSGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlTmF2SGFuZGxlcnNGb3JDb3Vyc2UocGFyc2VJbnQoY291cnNlSWQpLCBoYW5kbGVyLmFjY2Vzcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBoYW5kbGVycyBmb3IgYSBjZXJ0YWluIGNvdXJzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzRGVsZWdhdGUjdXBkYXRlTmF2SGFuZGxlcnNGb3JDb3Vyc2VcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkICAgIFRoZSBjb3Vyc2UgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gYWNjZXNzRGF0YSBBY2Nlc3MgdHlwZSBhbmQgZGF0YS4gRGVmYXVsdCwgZ3Vlc3QsIC4uLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUmVzb2x2ZWQgd2hlbiB1cGRhdGVkLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnVwZGF0ZU5hdkhhbmRsZXJzRm9yQ291cnNlID0gZnVuY3Rpb24oY291cnNlSWQsIGFjY2Vzc0RhdGEpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGVuYWJsZWRGb3JDb3Vyc2UgPSBbXTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVuYWJsZWROYXZIYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrcyBpZiB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciB0aGUgdXNlci5cbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICRxLndoZW4oaGFuZGxlci5pbnN0YW5jZS5pc0VuYWJsZWRGb3JDb3Vyc2UoY291cnNlSWQsIGFjY2Vzc0RhdGEpKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWRGb3JDb3Vyc2UucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGhlcmUsIGl0IGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIHVzZXIuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gTmV2ZXIgZmFpbHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY291cnNlc0hhbmRsZXJzIGFycmF5IHdpdGggdGhlIG5ldyBlbmFibGVkIGFkZG9ucy5cbiAgICAgICAgICAgICAgICAkbW1VdGlsLmVtcHR5QXJyYXkoY291cnNlc0hhbmRsZXJzW2NvdXJzZUlkXS5oYW5kbGVycyk7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVuYWJsZWRGb3JDb3Vyc2UsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291cnNlc0hhbmRsZXJzW2NvdXJzZUlkXS5oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IGhhbmRsZXIuaW5zdGFuY2UuZ2V0Q29udHJvbGxlcihjb3Vyc2VJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogaGFuZGxlci5wcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2FkZWRbY291cnNlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlcycpXG5cbi8qKlxuICogQ291cnNlcyBoYW5kbGVycyBmYWN0b3J5LlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQ291cnNlc0hhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1Db3Vyc2VzSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1TaXRlLCAkc3RhdGUsICRtbUNvdXJzZXMsICRxLCAkbW1VdGlsLCAkdHJhbnNsYXRlLCAkdGltZW91dCwgJG1tQ29udGVudExpbmtzSGVscGVyLFxuICAgICAgICAgICAgbW1Db3Vyc2VzRW5yb2xJbnZhbGlkS2V5KSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlc0hhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWN0aW9uIHRvIHBlcmZvcm0gd2hlbiBhbiBlbnJvbCBsaW5rIGlzIGNsaWNrZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlSWQgQ291cnNlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybCAgICAgIFRyZWF0ZWQgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYWN0aW9uRW5yb2woY291cnNlSWQsIHVybCkge1xuICAgICAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgZW5yb2xsZWQgaW4gdGhlIGNvdXJzZS5cbiAgICAgICAgICAgICRtbUNvdXJzZXMuZ2V0VXNlckNvdXJzZShjb3Vyc2VJZCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlciBpcyBub3QgZW5yb2xsZWQgaW4gdGhlIGNvdXJzZS4gQ2hlY2sgaWYgY2FuIHNlbGYgZW5yb2wuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhblNlbGZFbnJvbChjb3Vyc2VJZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZkVucm9sKGNvdXJzZUlkKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3IuIFNob3cgZXJyb3IgbWVzc2FnZSBhbmQgYWxsb3cgdGhlIHVzZXIgdG8gb3BlbiB0aGUgbGluayBpbiBicm93c2VyLlxuICAgICAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3Vyc2VzLm5vdGVucm9sZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gJHRyYW5zbGF0ZSgnbW0uY29yZS50d29wYXJhZ3JhcGhzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtwMTogZXJyb3IsIHAyOiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUuY29uZmlybW9wZW5pbmJyb3dzZXInKX0pO1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dDb25maXJtKGJvZHkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLm9wZW5JbkJyb3dzZXIodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tbV9jb3Vyc2UnLCB7Y291cnNlaWQ6IHBhcnNlSW50KGNvdXJzZUlkKX0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYSB1c2VyIGNhbiBiZSBcImF1dG9tYXRpY2FsbHlcIiBzZWxmIGVucm9sbGVkIGluIGEgY291cnNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIGlmIHVzZXIgaXMgY2FuIGJlIGVucm9sbGVkIGluIGEgY291cnNlLCByZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjYW5TZWxmRW5yb2woY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHNlbGYgZW5yb2xtZW50IGlzIGVuYWJsZWQuXG4gICAgICAgICAgICBpZiAoISRtbUNvdXJzZXMuaXNTZWxmRW5yb2xtZW50RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBjb3Vyc2UgaGFzIHNlbGYgZW5yb2xtZW50IGVuYWJsZWQuXG4gICAgICAgICAgICByZXR1cm4gJG1tQ291cnNlcy5nZXRDb3Vyc2VFbnJvbG1lbnRNZXRob2RzKGNvdXJzZUlkKS50aGVuKGZ1bmN0aW9uKG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNTZWxmRW5yb2xFbmFibGVkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlcyA9IDA7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLnR5cGUgPT0gJ3NlbGYnICYmIG1ldGhvZC5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VsZkVucm9sRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc1NlbGZFbnJvbEVuYWJsZWQgfHwgaW5zdGFuY2VzICE9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZiBlbnJvbCBub3QgZW5hYmxlZCBvciBtb3JlIHRoYW4gb25lIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ5IHRvIHNlbGYgZW5yb2wgYSB1c2VyIGluIGEgY291cnNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlciBlc29sdmVkIHdoZW4gdGhlIHVzZXIgaXMgZW5yb2xsZWQsIHJlamVjdGVkIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNlbGZFbnJvbChjb3Vyc2VJZCwgcGFzc3dvcmQpIHtcbiAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygpO1xuICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZXMuc2VsZkVucm9sKGNvdXJzZUlkLCBwYXNzd29yZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzIHNlbGYgZW5yb2xsaW5nIHRoZSB1c2VyLCBpbnZhbGlkYXRlIHRoZSBjb3Vyc2VzIGxpc3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZXMuaW52YWxpZGF0ZVVzZXJDb3Vyc2VzKCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMuXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBpZiB3ZSBnZXQgdGhlIGNvdXJzZSBsaXN0IHJpZ2h0IGFmdGVyIHNlbGYgZW5yb2xsaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHdvbid0IHJldHJpZXZlIHRoZSBuZXcgY291cnNlLiBMZXQncyBkZWxheSBpdCBhIGJpdC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aW1lb3V0KGZ1bmN0aW9uKCkge30sIDQwMDApLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gbW1Db3Vyc2VzRW5yb2xJbnZhbGlkS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgcGFzc3dvcmQuIEFsbG93IHRoZSB1c2VyIHRvIGlucHV0IHBhc3N3b3JkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvdXJzZXMuc2VsZmVucm9sbWVudCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9ICcgJywgLy8gRW1wdHkgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3Vyc2VzLnBhc3N3b3JkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgYXR0ZW1wdGVkIGEgcGFzc3dvcmQuIFNob3cgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tVXRpbC5zaG93UHJvbXB0KGJvZHksIHRpdGxlLCBwbGFjZWhvbGRlcikudGhlbihmdW5jdGlvbihwYXNzd29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGZFbnJvbChjb3Vyc2VJZCwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0W119ICAgICAgICBMaXN0IG9mIGFjdGlvbnMuIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBjb3Vyc2UgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCdlbnJvbC9pbmRleC5waHAnKSA+IC0xwqB8fMKgdXJsLmluZGV4T2YoJ2NvdXJzZS9lbnJvbC5waHAnKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwuaW5kZXhPZignY291cnNlL3ZpZXcucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSAkbW1VdGlsLmV4dHJhY3RVcmxQYXJhbXModXJsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5pZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbW0uY29yZS52aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tZXllJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVzOiBzaXRlSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXRlSWQgPT0gJG1tU2l0ZS5nZXRJZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkVucm9sKHBhcnNlSW50KHBhcmFtcy5pZCwgMTApLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUNvbnRlbnRMaW5rc0hlbHBlci5nb0luU2l0ZSgnc2l0ZS5tbV9jb3Vyc2UnLCB7Y291cnNlaWQ6IHBhcnNlSW50KHBhcmFtcy5pZCwgMTApfSwgc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5sb2dpbicpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgaW5wdXQgb2YgdXNlciBjcmVkZW50aWFscy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUubG9naW5cbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbUxvZ2luQ3JlZGVudGlhbHNDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbUxvZ2luQ3JlZGVudGlhbHNDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsICRzdGF0ZVBhcmFtcywgJG1tU2l0ZXNNYW5hZ2VyLCAkbW1VdGlsLCAkaW9uaWNIaXN0b3J5LCAkbW1BcHAsXG4gICAgICAgICAgICAkcSwgJG1tTG9naW5IZWxwZXIsICR0cmFuc2xhdGUpIHtcblxuICAgICRzY29wZS5zaXRldXJsID0gJHN0YXRlUGFyYW1zLnNpdGV1cmw7XG4gICAgJHNjb3BlLmNyZWRlbnRpYWxzID0ge307XG5cbiAgICB2YXIgc2l0ZUNoZWNrZWQgPSBmYWxzZTtcblxuICAgIC8vIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIGEgc2l0ZSB1c2VzIGxvY2FsX21vYmlsZSwgcmVxdWlyZXMgU1NPIGxvZ2luLCBldGMuXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgdXNlZCBvbmx5IGlmIGEgZml4ZWQgVVJMIGlzIHNldCwgb3RoZXJ3aXNlIHRoaXMgY2hlY2sgaXMgYWxyZWFkeSBwZXJmb3JtZWQgaW4gbW1Mb2dpblNpdGVDdHJsLlxuICAgIGZ1bmN0aW9uIGNoZWNrU2l0ZShzaXRldXJsKSB7XG4gICAgICAgIHZhciBjaGVja21vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuY2hlY2tTaXRlKHNpdGV1cmwpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cbiAgICAgICAgICAgIHNpdGVDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICRzY29wZS5zaXRldXJsID0gcmVzdWx0LnNpdGV1cmw7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lndhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKHJlc3VsdC53YXJuaW5nLCB0cnVlLCA0MDAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCRtbUxvZ2luSGVscGVyLmlzU1NPTG9naW5OZWVkZWQocmVzdWx0LmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gU1NPLiBVc2VyIG5lZWRzIHRvIGF1dGhlbnRpY2F0ZSBpbiBhIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmlzQnJvd3NlclNTTyA9IHRydWU7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93Q29uZmlybSgkdHJhbnNsYXRlKCdtbS5sb2dpbi5sb2dpbmluc2l0ZXJlcXVpcmVkJykpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbUxvZ2luSGVscGVyLm9wZW5Ccm93c2VyRm9yU1NPTG9naW4ocmVzdWx0LnNpdGV1cmwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaXNCcm93c2VyU1NPID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2hlY2ttb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICgkbW1Mb2dpbkhlbHBlci5pc0ZpeGVkVXJsU2V0KCkpIHtcbiAgICAgICAgLy8gRml4ZWQgVVJMLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0IHVzZXMgYnJvd3NlciBTU08gbG9naW4uXG4gICAgICAgIGNoZWNrU2l0ZSgkc2NvcGUuc2l0ZXVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2l0ZUNoZWNrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgICRzY29wZS5sb2dpbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICRtbUFwcC5jbG9zZUtleWJvYXJkKCk7XG5cbiAgICAgICAgLy8gR2V0IGlucHV0IGRhdGEuXG4gICAgICAgIHZhciBzaXRldXJsID0gJHNjb3BlLnNpdGV1cmwsXG4gICAgICAgICAgICB1c2VybmFtZSA9ICRzY29wZS5jcmVkZW50aWFscy51c2VybmFtZSxcbiAgICAgICAgICAgIHBhc3N3b3JkID0gJHNjb3BlLmNyZWRlbnRpYWxzLnBhc3N3b3JkO1xuXG4gICAgICAgIGlmICghc2l0ZUNoZWNrZWQpIHtcbiAgICAgICAgICAgIC8vIFNpdGUgd2Fzbid0IGNoZWNrZWQgKGl0IGZhaWxlZCksIGxldCdzIGNoZWNrIGFnYWluLlxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrU2l0ZShzaXRldXJsKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLmlzQnJvd3NlclNTTykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaXRlIGRvZXNuJ3QgdXNlIGJyb3dzZXIgU1NPLCB0aHJvdyBhcHAncyBsb2dpbiBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRzY29wZS5sb2dpbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCRzY29wZS5pc0Jyb3dzZXJTU08pIHtcbiAgICAgICAgICAgIC8vIEEgcHJldmlvdXMgY2hlY2sgZGV0ZXJtaW5lZCB0aGF0IGJyb3dzZXIgU1NPIGlzIG5lZWRlZC4gTGV0J3MgY2hlY2sgYWdhaW4sIG1heWJlIHNpdGUgd2FzIHVwZGF0ZWQuXG4gICAgICAgICAgICByZXR1cm4gY2hlY2tTaXRlKHNpdGV1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1c2VybmFtZSkge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0ubG9naW4udXNlcm5hbWVyZXF1aXJlZCcsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFzc3dvcmQpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmxvZ2luLnBhc3N3b3JkcmVxdWlyZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygpO1xuXG4gICAgICAgIC8vIFN0YXJ0IHRoZSBhdXRoZW50aWNhdGlvbiBwcm9jZXNzLlxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFVzZXJUb2tlbihzaXRldXJsLCB1c2VybmFtZSwgcGFzc3dvcmQpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5uZXdTaXRlKGRhdGEuc2l0ZXVybCwgZGF0YS50b2tlbikudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmNyZWRlbnRpYWxzOyAvLyBEZWxldGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGZyb20gdGhlIHNjb3BlLlxuICAgICAgICAgICAgICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtkaXNhYmxlQmFjazogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tbV9jb3Vyc2VzJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5sb2dpbicpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgc3BsYXNoIHNjcmVlbiBhbmQgaW5pdGlhbGl6ZSB0aGUgYXBwIChyZXN0b3JlIHNlc3Npb24sIGRldGVybWluZSBmaXJzdCBzdGF0ZSwgZXRjLikuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmxvZ2luXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1Mb2dpbkluaXRDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbUxvZ2luSW5pdEN0cmwnLCBmdW5jdGlvbigkbG9nLCAkaW9uaWNIaXN0b3J5LCAkc3RhdGUsICRtbVNpdGVzTWFuYWdlciwgJG1tU2l0ZSwgJG1tQXBwLCAkbW1Mb2dpbkhlbHBlcikge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tTG9naW5Jbml0Q3RybCcpO1xuXG4gICAgJG1tQXBwLnJlYWR5KCkudGhlbihmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBEaXNhYmxlIGFuaW1hdGlvbiBhbmQgYmFjayBidXR0b24gZm9yIHRoZSBuZXh0IHRyYW5zaXRpb24uXG4gICAgICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtcbiAgICAgICAgICAgIGRpc2FibGVBbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZUJhY2s6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW1fY291cnNlcycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmhhc1NpdGVzKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHN0YXRlLmdvKCdtbV9sb2dpbi5zaXRlcycpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUxvZ2luSGVscGVyLmdvVG9BZGRTaXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5sb2dpbicpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgaW5wdXQgb2YgdXNlciBjcmVkZW50aWFscy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUubG9naW5cbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbUxvZ2luUmVjb25uZWN0Q3RybFxuICovXG4uY29udHJvbGxlcignbW1Mb2dpblJlY29ubmVjdEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgJHN0YXRlUGFyYW1zLCAkbW1TaXRlc01hbmFnZXIsICRtbUFwcCwgJG1tVXRpbCwgJGlvbmljSGlzdG9yeSkge1xuXG4gICAgdmFyIGluZm9zaXRldXJsID0gJHN0YXRlUGFyYW1zLmluZm9zaXRldXJsOyAvLyBTaXRldXJsIGluIHNpdGUgaW5mby4gSXQgbWlnaHQgYmUgZGlmZmVyZW50IHRoYW4gc2l0ZXVybCAoaHR0cC9odHRwcykuXG4gICAgJHNjb3BlLnNpdGV1cmwgPSAkc3RhdGVQYXJhbXMuc2l0ZXVybDtcbiAgICAkc2NvcGUuY3JlZGVudGlhbHMgPSB7XG4gICAgICAgIHVzZXJuYW1lOiAkc3RhdGVQYXJhbXMudXNlcm5hbWUsXG4gICAgICAgIHBhc3N3b3JkOiAnJ1xuICAgIH07XG5cbiAgICAkc2NvcGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbVNpdGVzTWFuYWdlci5sb2dvdXQoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGRpc2FibGVBbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVCYWNrOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzdGF0ZS5nbygnbW1fbG9naW4uc2l0ZXMnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5sb2dpbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICRtbUFwcC5jbG9zZUtleWJvYXJkKCk7XG5cbiAgICAgICAgLy8gR2V0IGlucHV0IGRhdGEuXG4gICAgICAgIHZhciBzaXRldXJsID0gJHNjb3BlLnNpdGV1cmwsXG4gICAgICAgICAgICB1c2VybmFtZSA9ICRzY29wZS5jcmVkZW50aWFscy51c2VybmFtZSxcbiAgICAgICAgICAgIHBhc3N3b3JkID0gJHNjb3BlLmNyZWRlbnRpYWxzLnBhc3N3b3JkO1xuXG4gICAgICAgIGlmICghcGFzc3dvcmQpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmxvZ2luLnBhc3N3b3JkcmVxdWlyZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygpO1xuXG4gICAgICAgIC8vIFN0YXJ0IHRoZSBhdXRoZW50aWNhdGlvbiBwcm9jZXNzLlxuICAgICAgICAkbW1TaXRlc01hbmFnZXIuZ2V0VXNlclRva2VuKHNpdGV1cmwsIHVzZXJuYW1lLCBwYXNzd29yZCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAkbW1TaXRlc01hbmFnZXIudXBkYXRlU2l0ZVRva2VuKGluZm9zaXRldXJsLCB1c2VybmFtZSwgZGF0YS50b2tlbikudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc2l0ZSBpbmZvIHRvbyBiZWNhdXNlIGZ1bmN0aW9ucyBtaWdodCBoYXZlIGNoYW5nZWQgKGUuZy4gdW5pc250YWxsIGxvY2FsX21vYmlsZSkuXG4gICAgICAgICAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLnVwZGF0ZVNpdGVJbmZvQnlVcmwoaW5mb3NpdGV1cmwsIHVzZXJuYW1lKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmNyZWRlbnRpYWxzOyAvLyBEZWxldGUgcGFzc3dvcmQgZnJvbSB0aGUgc2NvcGUuXG4gICAgICAgICAgICAgICAgICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtkaXNhYmxlQmFjazogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW1fY291cnNlcycpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBTaXRlIGRlbGV0ZWQ/IEdvIGJhY2sgdG8gbG9naW4gcGFnZS5cbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5sb2dpbi5lcnJvcnVwZGF0ZXNpdGUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuY2FuY2VsKCk7XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmxvZ2luJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGhhbmRsZSB0aGUgaW5wdXQgb2YgYSBzaXRlIFVSTCBhbmQgaXRzIHZhbGlkYXRpb24uXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmxvZ2luXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1Mb2dpblNpdGVDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbUxvZ2luU2l0ZUN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCAkbW1VdGlsLCAkdHJhbnNsYXRlLCAkaW9uaWNIaXN0b3J5LCAkbW1BcHAsXG4gICAgICAgICRpb25pY01vZGFsLCAkbW1Mb2dpbkhlbHBlcikge1xuXG4gICAgJHNjb3BlLnNpdGV1cmwgPSAnJztcbiAgICAkc2NvcGUuaXNJbnZhbGlkVXJsID0gdHJ1ZTtcblxuICAgICRzY29wZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgJHNjb3BlLmlzSW52YWxpZFVybCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJG1tU2l0ZXNNYW5hZ2VyLmdldERlbW9TaXRlRGF0YSh1cmwpKSB7XG4gICAgICAgICAgICAvLyBJcyBkZW1vIHNpdGUuXG4gICAgICAgICAgICAkc2NvcGUuaXNJbnZhbGlkVXJsID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3JtYXRVUkwgYWRkcyB0aGUgcHJvdG9jb2wgaWYgaXMgbWlzc2luZy5cbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWR1cmwgPSAkbW1VdGlsLmZvcm1hdFVSTCh1cmwpO1xuICAgICAgICAgICAgJHNjb3BlLmlzSW52YWxpZFVybCA9IGZvcm1hdHRlZHVybC5pbmRleE9mKCc6Ly9sb2NhbGhvc3QnKSA9PSAtMSAmJiAhJG1tVXRpbC5pc1ZhbGlkVVJMKGZvcm1hdHRlZHVybCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJHNjb3BlLmNvbm5lY3QgPSBmdW5jdGlvbih1cmwpIHtcblxuICAgICAgICAkbW1BcHAuY2xvc2VLZXlib2FyZCgpO1xuXG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5sb2dpbi5zaXRldXJscmVxdWlyZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygpLFxuICAgICAgICAgICAgc2l0ZWRhdGEgPSAkbW1TaXRlc01hbmFnZXIuZ2V0RGVtb1NpdGVEYXRhKHVybCk7XG5cbiAgICAgICAgaWYgKHNpdGVkYXRhKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGEgZGVtbyBzaXRlLlxuICAgICAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmdldFVzZXJUb2tlbihzaXRlZGF0YS51cmwsIHNpdGVkYXRhLnVzZXJuYW1lLCBzaXRlZGF0YS5wYXNzd29yZCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLm5ld1NpdGUoZGF0YS5zaXRldXJsLCBkYXRhLnRva2VuKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7ZGlzYWJsZUJhY2s6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1tX2NvdXJzZXMnKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3QgYSBkZW1vIHNpdGUuXG4gICAgICAgICAgICAkbW1TaXRlc01hbmFnZXIuY2hlY2tTaXRlKHVybCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQud2FybmluZykge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKHJlc3VsdC53YXJuaW5nLCB0cnVlLCA0MDAwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoJG1tTG9naW5IZWxwZXIuaXNTU09Mb2dpbk5lZWRlZChyZXN1bHQuY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU1NPLiBVc2VyIG5lZWRzIHRvIGF1dGhlbnRpY2F0ZSBpbiBhIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSgnbW0ubG9naW4ubG9naW5pbnNpdGVyZXF1aXJlZCcpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tTG9naW5IZWxwZXIub3BlbkJyb3dzZXJGb3JTU09Mb2dpbihyZXN1bHQuc2l0ZXVybCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnbW1fbG9naW4uY3JlZGVudGlhbHMnLCB7c2l0ZXVybDogcmVzdWx0LnNpdGV1cmx9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEdldCBkb2NzIFVSTCBmb3IgaGVscCBtb2RhbC5cbiAgICAkbW1VdGlsLmdldERvY3NVcmwoKS50aGVuKGZ1bmN0aW9uKGRvY3N1cmwpIHtcbiAgICAgICAgJHNjb3BlLmRvY3N1cmwgPSBkb2NzdXJsO1xuICAgIH0pO1xuXG4gICAgLy8gU2V0dXAgaGVscCBtb2RhbC5cbiAgICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ2NvcmUvY29tcG9uZW50cy9sb2dpbi90ZW1wbGF0ZXMvaGVscC1tb2RhbC5odG1sJywge1xuICAgICAgICBzY29wZTogJHNjb3BlLFxuICAgICAgICBhbmltYXRpb246ICdzbGlkZS1pbi11cCdcbiAgICB9KS50aGVuKGZ1bmN0aW9uKGhlbHBNb2RhbCkge1xuICAgICAgICAkc2NvcGUuc2hvd0hlbHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhlbHBNb2RhbC5zaG93KCk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5jbG9zZUhlbHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhlbHBNb2RhbC5oaWRlKCk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoZWxwTW9kYWwucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5sb2dpbicpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgdGhlIGxpc3Qgb2Ygc2l0ZXMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmxvZ2luXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1Mb2dpblNpdGVzQ3RybFxuICovXG4uY29udHJvbGxlcignbW1Mb2dpblNpdGVzQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlLCAkbW1TaXRlc01hbmFnZXIsICRsb2csICR0cmFuc2xhdGUsICRtbVV0aWwsICRpb25pY0hpc3RvcnksICRtbVRleHQsXG4gICAgICAgICAgICAkbW1Mb2dpbkhlbHBlcikge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tTG9naW5TaXRlc0N0cmwnKTtcblxuICAgICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlcygpLnRoZW4oZnVuY3Rpb24oc2l0ZXMpIHtcbiAgICAgICAgJHNjb3BlLnNpdGVzID0gc2l0ZXM7XG4gICAgICAgICRzY29wZS5kYXRhID0ge1xuICAgICAgICAgICAgaGFzU2l0ZXM6IHNpdGVzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICBzaG93RGVsZXRlOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLnRvZ2dsZURlbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuZGF0YS5zaG93RGVsZXRlID0gISRzY29wZS5kYXRhLnNob3dEZWxldGU7XG4gICAgfTtcblxuICAgICRzY29wZS5vbkl0ZW1EZWxldGUgPSBmdW5jdGlvbihlLCBpbmRleCkge1xuICAgICAgICAvLyBQcmV2ZW50IGxvZ2luKCkgZnJvbSBiZWluZyB0cmlnZ2VyZWQuIE5vIGlkZWEgd2h5IEkgY2Fubm90IHJlcGxpY2F0ZSB0aGlzXG4gICAgICAgIC8vIHByb2JsZW0gb24gaHR0cDovL2NvZGVwZW4uaW8vaW9uaWMvcGVuL0pzSGpmLlxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHZhciBzaXRlID0gJHNjb3BlLnNpdGVzW2luZGV4XSxcbiAgICAgICAgICAgIHNpdGVuYW1lID0gc2l0ZS5zaXRlbmFtZTtcblxuICAgICAgICAkbW1UZXh0LmZvcm1hdFRleHQoc2l0ZW5hbWUpLnRoZW4oZnVuY3Rpb24oc2l0ZW5hbWUpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSgnbW0ubG9naW4uY29uZmlybWRlbGV0ZXNpdGUnLCB7c2l0ZW5hbWU6IHNpdGVuYW1lfSkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmRlbGV0ZVNpdGUoc2l0ZS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNpdGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5oYXNOb1NpdGVzKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHNpdGVzIGxlZnQsIGdvIHRvIGFkZCBhIG5ldyBzaXRlIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe2Rpc2FibGVCYWNrOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1Mb2dpbkhlbHBlci5nb1RvQWRkU2l0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRGVsZXRlIHNpdGUgZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmxvZ2luLmVycm9yZGVsZXRlc2l0ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUubG9naW4gPSBmdW5jdGlvbihzaXRlaWQpIHtcbiAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCk7XG5cbiAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmxvYWRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtkaXNhYmxlQmFjazogdHJ1ZX0pO1xuICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1tX2NvdXJzZXMnKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2l0ZSAnK3NpdGVpZCk7XG4gICAgICAgICAgICBlcnJvciA9IGVycm9yIHx8ICdFcnJvciBsb2FkaW5nIHNpdGUuJztcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLmFkZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1Mb2dpbkhlbHBlci5nb1RvQWRkU2l0ZSgpO1xuICAgIH07XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmxvZ2luJylcblxuLmNvbnN0YW50KCdtbUxvZ2luU1NPQ29kZScsIDIpIC8vIFRoaXMgY29kZSBpcyByZXR1cm5lZCBieSBsb2NhbF9tb2JpbGUgTW9vZGxlIHBsdWdpbiBpZiBTU08gaW4gYnJvd3NlciBpcyByZXF1aXJlZC5cbi5jb25zdGFudCgnbW1Mb2dpbkxhdW5jaFNpdGVVUkwnLCAnbW1Mb2dpbkxhdW5jaFNpdGVVUkwnKVxuLmNvbnN0YW50KCdtbUxvZ2luTGF1bmNoUGFzc3BvcnQnLCAnbW1Mb2dpbkxhdW5jaFBhc3Nwb3J0JylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIHByb3ZpZGUgc29tZSBoZWxwZXIgZnVuY3Rpb25hbGl0aWVzIGZvciB0aGUgbG9naW4gY29tcG9uZW50LlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5sb2dpblxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUxvZ2luSGVscGVyXG4gKi9cbi5mYWN0b3J5KCckbW1Mb2dpbkhlbHBlcicsIGZ1bmN0aW9uKCRxLCAkbG9nLCAkbW1Db25maWcsIG1tTG9naW5TU09Db2RlLCBtbUxvZ2luTGF1bmNoU2l0ZVVSTCwgbW1Mb2dpbkxhdW5jaFBhc3Nwb3J0LFxuICAgICAgICAgICAgbWQ1LCAkbW1TaXRlLCAkbW1TaXRlc01hbmFnZXIsICRtbUxhbmcsICRtbVV0aWwsICRzdGF0ZSwgbW1Db3JlQ29uZmlnQ29uc3RhbnRzKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tTG9naW5IZWxwZXInKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHbyB0byB0aGUgdmlldyB0byBhZGQgYSBuZXcgc2l0ZS5cbiAgICAgKiBJZiBhIGZpeGVkIFVSTCBpcyBjb25maWd1cmVkLCBnbyB0byBjcmVkZW50aWFscyBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmxvZ2luXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvZ2luSGVscGVyI2dvVG9BZGRTaXRlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHNlbGYuZ29Ub0FkZFNpdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5zaXRldXJsKSB7XG4gICAgICAgICAgICAvLyBGaXhlZCBVUkwgaXMgc2V0LCBnbyB0byBjcmVkZW50aWFscyBwYWdlLlxuICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS5nbygnbW1fbG9naW4uY3JlZGVudGlhbHMnLCB7c2l0ZXVybDogbW1Db3JlQ29uZmlnQ29uc3RhbnRzLnNpdGV1cmx9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkc3RhdGUuZ28oJ21tX2xvZ2luLnNpdGUnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYXBwIGlzIGNvbmZpZ3VyZWQgdG8gdXNlIGEgZml4ZWQgVVJMLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmxvZ2luXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvZ2luSGVscGVyI2lzRml4ZWRVcmxTZXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHNldCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNGaXhlZFVybFNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5zaXRldXJsICE9ICd1bmRlZmluZWQnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBTU08gbG9naW4gaXMgbmVlZGVkIGJhc2VkIG9uIGNvZGUgcmV0dXJuZWQgYnkgdGhlIFdTLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmxvZ2luXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvZ2luSGVscGVyI2lzU1NPTG9naW5OZWVkZWRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBjb2RlIENvZGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICBUcnVlIGlmIFNTTyBsb2dpbiBpcyBuZWVkZWQsIGZhbHNlIG90aHdlcmlzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzU1NPTG9naW5OZWVkZWQgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgICAgIHJldHVybiBjb2RlID09IG1tTG9naW5TU09Db2RlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgYnJvd3NlciB0byBwZXJmb3JtIFNTTyBsb2dpbi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5sb2dpblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Mb2dpbkhlbHBlciNvcGVuQnJvd3NlckZvclNTT0xvZ2luXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGV1cmwgVVJMIG9mIHRoZSBzaXRlIHdoZXJlIHRoZSBTU08gbG9naW4gd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAgICovXG4gICAgc2VsZi5vcGVuQnJvd3NlckZvclNTT0xvZ2luID0gZnVuY3Rpb24oc2l0ZXVybCkge1xuICAgICAgICB2YXIgcGFzc3BvcnQgPSBNYXRoLnJhbmRvbSgpICogMTAwMDtcbiAgICAgICAgdmFyIGxvZ2ludXJsID0gc2l0ZXVybCArIFwiL2xvY2FsL21vYmlsZS9sYXVuY2gucGhwP3NlcnZpY2U9XCIgKyBtbUNvcmVDb25maWdDb25zdGFudHMud3NleHRzZXJ2aWNlO1xuICAgICAgICBsb2dpbnVybCArPSBcIiZwYXNzcG9ydD1cIiArIHBhc3Nwb3J0O1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaXRldXJsIGFuZCBwYXNzcG9ydCBpbiAkbW1Db25maWcgZm9yIHBlcnNpc3RlbmNlLiBXZSBhcmUgXCJjb25maWd1cmluZ1wiXG4gICAgICAgIC8vIHRoZSBhcHAgdG8gd2FpdCBmb3IgYW4gU1NPLiAkbW1Db25maWcgc2hvdWxkbid0IGJlIHVzZWQgYXMgYSB0ZW1wb3Jhcnkgc3RvcmFnZS5cbiAgICAgICAgJG1tQ29uZmlnLnNldChtbUxvZ2luTGF1bmNoU2l0ZVVSTCwgc2l0ZXVybCk7XG4gICAgICAgICRtbUNvbmZpZy5zZXQobW1Mb2dpbkxhdW5jaFBhc3Nwb3J0LCBwYXNzcG9ydCk7XG5cbiAgICAgICAgJG1tVXRpbC5vcGVuSW5Ccm93c2VyKGxvZ2ludXJsKTtcbiAgICAgICAgaWYgKG5hdmlnYXRvci5hcHApIHtcbiAgICAgICAgICAgIG5hdmlnYXRvci5hcHAuZXhpdEFwcCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbnQgaGVscGVyIHRvIHZhbGlkYXRlIGEgYnJvd3NlciBTU08gbG9naW4uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUubG9naW5cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTG9naW5IZWxwZXIjdmFsaWRhdGVCcm93c2VyU1NPTG9naW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCByZWNlaXZlZCwgdG8gYmUgdmFsaWRhdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgVGhlIHN1Y2Nlc3MgY29udGFpbnMgdGhlIHNpZ25hdHVyZSBhbmQgdG9rZW4uIFRoZSByZWplY3QgY29udGFpbnMgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgc2VsZi52YWxpZGF0ZUJyb3dzZXJTU09Mb2dpbiA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAvLyBTcGxpdCBzaWduYXR1cmU6Ojp0b2tlblxuICAgICAgICB2YXIgcGFyYW1zID0gdXJsLnNwbGl0KFwiOjo6XCIpO1xuXG4gICAgICAgIHJldHVybiAkbW1Db25maWcuZ2V0KG1tTG9naW5MYXVuY2hTaXRlVVJMKS50aGVuKGZ1bmN0aW9uKGxhdW5jaFNpdGVVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1Db25maWcuZ2V0KG1tTG9naW5MYXVuY2hQYXNzcG9ydCkudGhlbihmdW5jdGlvbihwYXNzcG9ydCkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGVtcG9yYXJ5IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAkbW1Db25maWcuZGVsZXRlKG1tTG9naW5MYXVuY2hTaXRlVVJMKTtcbiAgICAgICAgICAgICAgICAkbW1Db25maWcuZGVsZXRlKG1tTG9naW5MYXVuY2hQYXNzcG9ydCk7XG5cbiAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgc2lnbmF0dXJlLlxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYm90aCBodHRwIGFuZCBodHRwcy5cbiAgICAgICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gbWQ1LmNyZWF0ZUhhc2gobGF1bmNoU2l0ZVVSTCArIHBhc3Nwb3J0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmF0dXJlICE9IHBhcmFtc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGF1bmNoU2l0ZVVSTC5pbmRleE9mKFwiaHR0cHM6Ly9cIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdW5jaFNpdGVVUkwgPSBsYXVuY2hTaXRlVVJMLnJlcGxhY2UoXCJodHRwczovL1wiLCBcImh0dHA6Ly9cIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXVuY2hTaXRlVVJMID0gbGF1bmNoU2l0ZVVSTC5yZXBsYWNlKFwiaHR0cDovL1wiLCBcImh0dHBzOi8vXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IG1kNS5jcmVhdGVIYXNoKGxhdW5jaFNpdGVVUkwgKyBwYXNzcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSA9PSBwYXJhbXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnU2lnbmF0dXJlIHZhbGlkYXRlZCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzaXRldXJsOiBsYXVuY2hTaXRlVVJMLCB0b2tlbjogcGFyYW1zWzFdIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnSW5hbGlkIHNpZ25hdHVyZSBpbiB0aGUgVVJMIHJlcXVlc3QgeW91cnM6ICcgKyBwYXJhbXNbMF0gKyAnIG1pbmU6ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgc2lnbmF0dXJlICsgJyBmb3IgcGFzc3BvcnQgJyArIHBhc3Nwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5jb3JlLnVuZXhwZWN0ZWRlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW50IGhlbHBlciB0byBoYW5kbGUgYXV0aGVudGljYXRpb24gaW4gdGhlIGFwcCB1c2luZyBhIHRva2VuIHJlY2VpdmVkIGJ5IFNTTyBsb2dpbi4gSWYgaXQncyBhIG5ldyBhY2NvdW50LFxuICAgICAqIHRoZSBzaXRlIGlzIHN0b3JlZCBhbmQgdGhlIHVzZXIgaXMgYXV0aGVudGljYXRlZC4gSWYgdGhlIGFjY291bnQgYWxyZWFkeSBleGlzdHMsIHVwZGF0ZSBpdHMgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUubG9naW5cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTG9naW5IZWxwZXIjaGFuZGxlU1NPTG9naW5BdXRoZW50aWNhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRldXJsIFNpdGUncyBVUkwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuICAgVXNlcidzIHRva2VuLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgdXNlciBpcyBhdXRoZW50aWNhdGVkIHdpdGggdGhlIHRva2VuLiBSZWplY3QgcmV0dXJucyBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIHNlbGYuaGFuZGxlU1NPTG9naW5BdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uKHNpdGV1cmwsIHRva2VuKSB7XG4gICAgICAgIGlmICgkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgLy8gVXNlciBsb2dnZWQgaW4sIGhlIGlzIHJlY29ubmVjdGluZy5cbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHVzZXJuYW1lLlxuICAgICAgICAgICAgdmFyIGluZm8gPSAkbW1TaXRlLmdldEluZm8oKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoaW5mbykgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZihpbmZvLnVzZXJuYW1lKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAkbW1TaXRlc01hbmFnZXIudXBkYXRlU2l0ZVRva2VuKGluZm8uc2l0ZXVybCwgaW5mby51c2VybmFtZSwgdG9rZW4pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci51cGRhdGVTaXRlSW5mb0J5VXJsKGluZm8uc2l0ZXVybCwgaW5mby51c2VybmFtZSkuZmluYWxseShkZWZlcnJlZC5yZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3IgdXBkYXRpbmcgdG9rZW4sIHJldHVybiBwcm9wZXIgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgJ21tLmxvZ2luLmVycm9ydXBkYXRlc2l0ZScpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW0ubG9naW4uZXJyb3J1cGRhdGVzaXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIubmV3U2l0ZShzaXRldXJsLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5zZXR0aW5ncycpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgdGhlIGFwcCAnQWJvdXQnIHNlY3Rpb24gaW4gc2V0dGluZ3MuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLnNldHRpbmdzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1TZXR0aW5nc0Fib3V0Q3RybFxuICovXG4uY29udHJvbGxlcignbW1TZXR0aW5nc0Fib3V0Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHRyYW5zbGF0ZSwgJHdpbmRvdywgJG1tQXBwLCAkaW9uaWNQbGF0Zm9ybSwgJG1tTGFuZywgJG1tRlMsXG4gICAgICAgICAgICAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMsIG1tQ29yZUNvbmZpZ0NvbnN0YW50cykge1xuXG4gICAgJHNjb3BlLnZlcnNpb25uYW1lID0gbW1Db3JlQ29uZmlnQ29uc3RhbnRzLnZlcnNpb25uYW1lO1xuICAgICR0cmFuc2xhdGUoJ21tLnNldHRpbmdzLmFwcG5hbWUnLCB7dmVyc2lvbjogJHNjb3BlLnZlcnNpb25uYW1lfSkudGhlbihmdW5jdGlvbihhcHBOYW1lKSB7XG4gICAgICAgICRzY29wZS5hcHBuYW1lID0gYXBwTmFtZTtcbiAgICB9KTtcblxuICAgICRzY29wZS52ZXJzaW9uY29kZSA9IG1tQ29yZUNvbmZpZ0NvbnN0YW50cy52ZXJzaW9uY29kZTtcblxuICAgICRzY29wZS5uYXZpZ2F0b3IgPSAkd2luZG93Lm5hdmlnYXRvcjtcbiAgICBpZiAoJHdpbmRvdy5sb2NhdGlvbiAmJiAkd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICAgICAgdmFyIHVybCA9ICR3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgJHNjb3BlLmxvY2F0aW9uaHJlZiA9IHVybC5zdWJzdHIoMCwgdXJsLmluZGV4T2YoJyMvc2l0ZS8nKSk7XG4gICAgfVxuXG4gICAgJHNjb3BlLmFwcHJlYWR5ID0gJG1tQXBwLmlzUmVhZHkoKSA/ICdtbS5jb3JlLnllcycgOiAnbW0uY29yZS5ubyc7XG4gICAgJHNjb3BlLmRldmljZXR5cGUgPSAkaW9uaWNQbGF0Zm9ybS5pc1RhYmxldCgpID8gJ21tLmNvcmUudGFibGV0JyA6ICdtbS5jb3JlLnBob25lJztcblxuICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgICAkc2NvcGUuZGV2aWNlb3MgPSAnbW0uY29yZS5hbmRyb2lkJztcbiAgICB9IGVsc2UgaWYgKGlvbmljLlBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgICAgJHNjb3BlLmRldmljZW9zID0gJ21tLmNvcmUuaW9zJztcbiAgICB9IGVsc2UgaWYgKGlvbmljLlBsYXRmb3JtLmlzV2luZG93c1Bob25lKCkpIHtcbiAgICAgICAgJHNjb3BlLmRldmljZW9zID0gJ21tLmNvcmUud2luZG93c3Bob25lJztcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1xcKChbXlxcKV0qKVxcKS8pO1xuICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICRzY29wZS5kZXZpY2VvcyA9IG1hdGNoZXNbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUuZGV2aWNlb3MgPSAnbW0uY29yZS51bmtub3duJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgICRtbUxhbmcuZ2V0Q3VycmVudExhbmd1YWdlKCkudGhlbihmdW5jdGlvbihsYW5nKSB7XG4gICAgICAgICRzY29wZS5jdXJyZW50bGFuZ3VhZ2UgPSBsYW5nO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLm5ldHdvcmtzdGF0dXMgPSAkbW1BcHAuaXNPbmxpbmUoKSA/ICdtbS5jb3JlLm9ubGluZScgOiAnbW0uY29yZS5vZmZsaW5lJztcbiAgICAkc2NvcGUud2lmaWNvbm5lY3Rpb24gPSAkbW1BcHAuaXNOZXR3b3JrQWNjZXNzTGltaXRlZCgpID8gJ21tLmNvcmUubm8nIDogJ21tLmNvcmUueWVzJztcbiAgICAkc2NvcGUuZGV2aWNld2Vid29ya2VycyA9ICEhd2luZG93LldvcmtlciAmJiAhIXdpbmRvdy5VUkwgPyAnbW0uY29yZS55ZXMnIDogJ21tLmNvcmUubm8nO1xuICAgICRzY29wZS5kZXZpY2UgPSBpb25pYy5QbGF0Zm9ybS5kZXZpY2UoKTtcblxuICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICRtbUZTLmdldEJhc2VQYXRoKCkudGhlbihmdW5jdGlvbihiYXNlcGF0aCkge1xuICAgICAgICAgICAgJHNjb3BlLmZpbGVzeXN0ZW1yb290ID0gYmFzZXBhdGg7XG4gICAgICAgICAgICAkc2NvcGUuZnNjbGlja2FibGUgPSAkbW1GUy51c2VzSFRNTEFQSSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkc2NvcGUuc3RvcmFnZXR5cGUgPSAkbW1BcHAuZ2V0REIoKS5nZXRUeXBlKCk7XG4gICAgJHNjb3BlLmxvY2Fsbm90aWZhdmFpbGFibGUgPSAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMuaXNBdmFpbGFibGUoKSA/ICdtbS5jb3JlLnllcycgOiAnbW0uY29yZS5ubyc7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5zZXR0aW5ncycpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgdGhlIGFwcCAnR2VuZXJhbCcgc2VjdGlvbiBpbiBzZXR0aW5ncy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuc2V0dGluZ3NcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbVNldHRpbmdzR2VuZXJhbEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tU2V0dGluZ3NHZW5lcmFsQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJG1tTGFuZywgJGlvbmljSGlzdG9yeSwgJG1tRXZlbnRzLCAkbW1Db25maWcsIG1tQ29yZUV2ZW50TGFuZ3VhZ2VDaGFuZ2VkLFxuICAgICAgICAgICAgbW1Db3JlU2V0dGluZ3NSZXBvcnRJbkJhY2tncm91bmQsIG1tQ29yZUNvbmZpZ0NvbnN0YW50cywgbW1Db3JlU2V0dGluZ3NEb3dubG9hZFNlY3Rpb24pIHtcblxuICAgICRzY29wZS5sYW5ncyA9IG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5sYW5ndWFnZXM7XG5cbiAgICAkbW1MYW5nLmdldEN1cnJlbnRMYW5ndWFnZSgpLnRoZW4oZnVuY3Rpb24oY3VycmVudExhbmd1YWdlKSB7XG4gICAgICAgICRzY29wZS5zZWxlY3RlZExhbmd1YWdlID0gY3VycmVudExhbmd1YWdlO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLmxhbmd1YWdlQ2hhbmdlZCA9IGZ1bmN0aW9uKG5ld0xhbmcpIHtcbiAgICAgICAgJG1tTGFuZy5jaGFuZ2VDdXJyZW50TGFuZ3VhZ2UobmV3TGFuZykuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIGNhY2hlZCB2aWV3cy5cbiAgICAgICAgICAgICRpb25pY0hpc3RvcnkuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRMYW5ndWFnZUNoYW5nZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJG1tQ29uZmlnLmdldChtbUNvcmVTZXR0aW5nc0Rvd25sb2FkU2VjdGlvbiwgdHJ1ZSkudGhlbihmdW5jdGlvbihkb3dubG9hZFNlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICRzY29wZS5kb3dubG9hZFNlY3Rpb24gPSBkb3dubG9hZFNlY3Rpb25FbmFibGVkO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLmRvd25sb2FkU2VjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbihkb3dubG9hZFNlY3Rpb24pIHtcbiAgICAgICAgJG1tQ29uZmlnLnNldChtbUNvcmVTZXR0aW5nc0Rvd25sb2FkU2VjdGlvbiwgZG93bmxvYWRTZWN0aW9uKTtcbiAgICB9O1xuXG4gICAgaWYgKGxvY2FsU3RvcmFnZSAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSAmJiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSkge1xuICAgICAgICAkc2NvcGUuc2hvd1JlcG9ydCA9IHRydWU7XG4gICAgICAgICRzY29wZS5yZXBvcnRJbkJhY2tncm91bmQgPSBwYXJzZUludChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShtbUNvcmVTZXR0aW5nc1JlcG9ydEluQmFja2dyb3VuZCksIDEwKSA9PT0gMTtcblxuICAgICAgICAkc2NvcGUucmVwb3J0Q2hhbmdlZCA9IGZ1bmN0aW9uKGluQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obW1Db3JlU2V0dGluZ3NSZXBvcnRJbkJhY2tncm91bmQsIGluQmFja2dyb3VuZCA/ICcxJyA6ICcwJyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJHNjb3BlLnNob3dSZXBvcnQgPSBmYWxzZTtcbiAgICB9XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5zZXR0aW5ncycpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgdGhlIGFwcCAnU3BhY2UgVXNhZ2UnIHNlY3Rpb24gaW4gc2V0dGluZ3MuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLnNldHRpbmdzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1TZXR0aW5nc1NwYWNlVXNhZ2VDdHJsXG4gKiBAdG9kbyBXaGVuIFwibW9jayBzaXRlXCIgaXMgaW1wbGVtZW50ZWQgd2Ugc2hvdWxkIGhhdmUgZnVuY3Rpb25zIHRvIGNhbGN1bGF0ZSB0aGUgc2l0ZSB1c2FnZSBhbmQgZGVsZXRlIGl0cyBmaWxlcy5cbiAqL1xuLmNvbnRyb2xsZXIoJ21tU2V0dGluZ3NTcGFjZVVzYWdlQ3RybCcsIGZ1bmN0aW9uKCRsb2csICRzY29wZSwgJG1tU2l0ZXNNYW5hZ2VyLCAkbW1GUywgJHEsICRtbVV0aWwsICR0cmFuc2xhdGUsXG4gICAgICAgICAgICAkbW1UZXh0LCAkbW1GaWxlcG9vbCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbVNldHRpbmdzU3BhY2VVc2FnZUN0cmwnKTtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBlYWNoIHNpdGUncyB1c2FnZSwgYW5kIHRoZSB0b3RhbCB1c2FnZS5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVTaXplVXNhZ2UoKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZXMoKS50aGVuKGZ1bmN0aW9uKHNpdGVzKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICRzY29wZS5zaXRlcyA9IHNpdGVzO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2l0ZXMsIGZ1bmN0aW9uKHNpdGVFbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUVudHJ5LmlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpdGUuZ2V0U3BhY2VVc2FnZSgpLnRoZW4oZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZUVudHJ5LnNwYWNldXNhZ2UgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdG90YWwgdXNhZ2UuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlVG90YWxVc2FnZSgpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5zaXRlcywgZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgaWYgKHNpdGUuc3BhY2V1c2FnZSkge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IHBhcnNlSW50KHNpdGUuc3BhY2V1c2FnZSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgJHNjb3BlLnRvdGFsdXNhZ2UgPSB0b3RhbDtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBjYWxjdWxhdGUgZnJlZSBzcGFjZSBpbiB0aGUgZGV2aWNlLlxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUZyZWVTcGFjZSgpIHtcbiAgICAgICAgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1GUy5jYWxjdWxhdGVGcmVlU3BhY2UoKS50aGVuKGZ1bmN0aW9uKGZyZWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5mcmVlc3BhY2UgPSBmcmVlc3BhY2U7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZnJlZXNwYWNlID0gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLmZyZWVzcGFjZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBwcm9taXNlcy5wdXNoKGNhbGN1bGF0ZVNpemVVc2FnZSgpLnRoZW4oY2FsY3VsYXRlVG90YWxVc2FnZSkpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCRxLndoZW4oY2FsY3VsYXRlRnJlZVNwYWNlKCkpKTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgfVxuICAgIGZldGNoRGF0YSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5zaXplTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIFB1bGwgdG8gcmVmcmVzaC5cbiAgICAkc2NvcGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmZXRjaERhdGEoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHVwZGF0ZSBzaXRlIHNpemUsIGFsb25nIHdpdGggdG90YWwgdXNhZ2UgYW5kIGZyZWUgc3BhY2UuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2l0ZVVzYWdlKHNpdGUsIG5ld1VzYWdlKSB7XG4gICAgICAgIHZhciBvbGRVc2FnZSA9IHNpdGUuc3BhY2V1c2FnZTtcbiAgICAgICAgc2l0ZS5zcGFjZXVzYWdlID0gbmV3VXNhZ2U7XG4gICAgICAgICRzY29wZS50b3RhbHVzYWdlIC09IG9sZFVzYWdlIC0gbmV3VXNhZ2U7XG4gICAgICAgICRzY29wZS5mcmVlc3BhY2UgKz0gb2xkVXNhZ2UgLSBuZXdVc2FnZTtcbiAgICB9XG5cbiAgICAkc2NvcGUuZGVsZXRlU2l0ZUZpbGVzID0gZnVuY3Rpb24oc2l0ZURhdGEpIHtcbiAgICAgICAgaWYgKHNpdGVEYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2l0ZWlkID0gc2l0ZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgc2l0ZW5hbWUgPSBzaXRlRGF0YS5zaXRlbmFtZTtcblxuICAgICAgICAgICAgJG1tVGV4dC5mb3JtYXRUZXh0KHNpdGVuYW1lKS50aGVuKGZ1bmN0aW9uKHNpdGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgJHRyYW5zbGF0ZSgnbW0uc2V0dGluZ3MuZGVsZXRlc2l0ZWZpbGVzdGl0bGUnKS50aGVuKGZ1bmN0aW9uKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1VdGlsLnNob3dDb25maXJtKCR0cmFuc2xhdGUoJ21tLnNldHRpbmdzLmRlbGV0ZXNpdGVmaWxlcycsIHtzaXRlbmFtZTogc2l0ZW5hbWV9KSwgdGl0bGUpO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlaWQpO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l0ZS5kZWxldGVGb2xkZXIoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tRmlsZXBvb2wuY2xlYXJBbGxQYWNrYWdlc1N0YXR1cyhzaXRlaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tRmlsZXBvb2wuY2xlYXJGaWxlcG9vbChzaXRlaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2l0ZVVzYWdlKHNpdGVEYXRhLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBGaWxlRXJyb3IuTk9UX0ZPVU5EX0VSUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBmb3VuZCwgc2V0IHNpemUgMC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1GaWxlcG9vbC5jbGVhckFsbFBhY2thZ2VzU3RhdHVzKHNpdGVpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2l0ZVVzYWdlKHNpdGVEYXRhLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3IsIHJlY2FsY3VsYXRlIHRoZSBzaXRlIHVzYWdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLnNldHRpbmdzLmVycm9yZGVsZXRlc2l0ZWZpbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZS5nZXRTcGFjZVVzYWdlKCkudGhlbihmdW5jdGlvbihzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNpdGVVc2FnZShzaXRlRGF0YSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuc2V0dGluZ3MnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIHRoZSBhcHAgJ1N5bmNocm9uaXphdGlvbicgc2VjdGlvbiBpbiBzZXR0aW5ncy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuc2V0dGluZ3NcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbVNldHRpbmdzU3luY2hyb25pemF0aW9uQ3RybFxuICovXG4uY29udHJvbGxlcignbW1TZXR0aW5nc1N5bmNocm9uaXphdGlvbkN0cmwnLCBmdW5jdGlvbigkbG9nLCAkc2NvcGUsICRtbVNpdGVzTWFuYWdlciwgJG1tVXRpbCwgJG1tRmlsZXBvb2wsICRtbUV2ZW50cyxcbiAgICAgICAgICAgICRtbUxhbmcsICRtbUNvbmZpZywgbW1Db3JlRXZlbnRTZXNzaW9uRXhwaXJlZCwgbW1Db3JlU2V0dGluZ3NTeW5jT25seU9uV2lmaSkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbVNldHRpbmdzU3luY2hyb25pemF0aW9uQ3RybCcpO1xuXG4gICAgJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGVzKCkudGhlbihmdW5jdGlvbihzaXRlcykge1xuICAgICAgICAkc2NvcGUuc2l0ZXMgPSBzaXRlcztcbiAgICB9KTtcblxuICAgICRtbUNvbmZpZy5nZXQobW1Db3JlU2V0dGluZ3NTeW5jT25seU9uV2lmaSwgdHJ1ZSkudGhlbihmdW5jdGlvbihzeW5jT25seU9uV2lmaSkge1xuICAgICAgICAkc2NvcGUuc3luY09ubHlPbldpZmkgPSBzeW5jT25seU9uV2lmaTtcbiAgICB9KTtcblxuICAgICRzY29wZS5zeW5jV2lmaUNoYW5nZWQgPSBmdW5jdGlvbihzeW5jT25seU9uV2lmaSkge1xuICAgICAgICAkbW1Db25maWcuc2V0KG1tQ29yZVNldHRpbmdzU3luY09ubHlPbldpZmksIHN5bmNPbmx5T25XaWZpKTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLnN5bmNocm9uaXplID0gZnVuY3Rpb24oc2l0ZURhdGEpIHtcbiAgICAgICAgaWYgKHNpdGVEYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2l0ZWlkID0gc2l0ZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tLnNldHRpbmdzLnN5bmNocm9uaXppbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICRtbUZpbGVwb29sLmludmFsaWRhdGVBbGxGaWxlcyhzaXRlaWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpdGUuaW52YWxpZGF0ZVdzQ2FjaGUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbG9jYWxfbW9iaWxlIHdhcyBpbnN0YWxsZWQgdG8gTW9vZGxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpdGUuY2hlY2tJZkxvY2FsTW9iaWxlSW5zdGFsbGVkQW5kTm90VXNlZCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9jYWwgbW9iaWxlIHdhcyBhZGRlZC4gVGhyb3cgaW52YWxpZCBzZXNzaW9uIHRvIGZvcmNlIHJlY29ubmVjdCBhbmQgY3JlYXRlIGEgbmV3IHRva2VuLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50U2Vzc2lvbkV4cGlyZWQsIHNpdGVpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5jb3JlLmxvc3Rjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc2l0ZSBpbmZvLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIudXBkYXRlU2l0ZUluZm8oc2l0ZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZURhdGEuZnVsbG5hbWUgPSBzaXRlLmdldEluZm8oKS5mdWxsbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVEYXRhLnNpdGVuYW1lID0gc2l0ZS5nZXRJbmZvKCkuc2l0ZW5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dNb2RhbCgnbW0uY29yZS5zdWNjZXNzJywgJ21tLnNldHRpbmdzLnN5bmNzaXRlc3VjY2VzcycpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uc2V0dGluZ3MuZXJyb3JzeW5jc2l0ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuc2lkZW1lbnUnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIHRoZSBzaWRlIG1lbnUuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLnNpZGVtZW51XG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1TaWRlTWVudUN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tU2lkZU1lbnVDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsICRtbVNpZGVNZW51RGVsZWdhdGUsICRtbVNpdGVzTWFuYWdlciwgJG1tU2l0ZSwgJG1tRXZlbnRzLFxuICAgICAgICAgICAgJHRpbWVvdXQsIG1tQ29yZUV2ZW50TGFuZ3VhZ2VDaGFuZ2VkLCBtbUNvcmVFdmVudFNpdGVVcGRhdGVkKSB7XG5cbiAgICAkc2NvcGUuaGFuZGxlcnMgPSAkbW1TaWRlTWVudURlbGVnYXRlLmdldE5hdkhhbmRsZXJzKCk7XG4gICAgJHNjb3BlLmFyZU5hdkhhbmRsZXJzTG9hZGVkID0gJG1tU2lkZU1lbnVEZWxlZ2F0ZS5hcmVOYXZIYW5kbGVyc0xvYWRlZDtcbiAgICAkc2NvcGUuc2l0ZWluZm8gPSAkbW1TaXRlLmdldEluZm8oKTtcblxuICAgICRzY29wZS5sb2dvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmxvZ291dCgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc3RhdGUuZ28oJ21tX2xvZ2luLnNpdGVzJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkbW1TaXRlLmdldERvY3NVcmwoKS50aGVuKGZ1bmN0aW9uKGRvY3N1cmwpIHtcbiAgICAgICAgJHNjb3BlLmRvY3N1cmwgPSBkb2NzdXJsO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2l0ZUluZm8oKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlICR0aW1lb3V0IHRvIGZvcmNlIGEgJGRpZ2VzdCBhbmQgbWFrZSAkd2F0Y2ggbm90aWNlIHRoZSB2YXJpYWJsZSBjaGFuZ2UuXG4gICAgICAgICRzY29wZS5zaXRlaW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2l0ZWluZm8gPSAkbW1TaXRlLmdldEluZm8oKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGRvY3MgVVJMLCBtYXliZSB0aGUgTW9vZGxlIHJlbGVhc2UgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAkbW1TaXRlLmdldERvY3NVcmwoKS50aGVuKGZ1bmN0aW9uKGRvY3N1cmwpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZG9jc3VybCA9IGRvY3N1cmw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGxhbmdPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudExhbmd1YWdlQ2hhbmdlZCwgdXBkYXRlU2l0ZUluZm8pO1xuICAgIHZhciB1cGRhdGVTaXRlT2JzZXJ2ZXIgPSAkbW1FdmVudHMub24obW1Db3JlRXZlbnRTaXRlVXBkYXRlZCwgZnVuY3Rpb24oc2l0ZWlkKSB7XG4gICAgICAgIGlmICgkbW1TaXRlLmdldElkKCkgPT09IHNpdGVpZCkge1xuICAgICAgICAgICAgdXBkYXRlU2l0ZUluZm8oKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGxhbmdPYnNlcnZlciAmJiBsYW5nT2JzZXJ2ZXIub2ZmKSB7XG4gICAgICAgICAgICBsYW5nT2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZVNpdGVPYnNlcnZlciAmJiB1cGRhdGVTaXRlT2JzZXJ2ZXIub2ZmKSB7XG4gICAgICAgICAgICB1cGRhdGVTaXRlT2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLnNpZGVtZW51JylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGludGVyYWN0IHdpdGggcGx1Z2lucyB0byBiZSBzaG93biBpbiB0aGUgc2lkZSBtZW51LiBQcm92aWRlcyBmdW5jdGlvbnMgdG8gcmVnaXN0ZXIgYSBwbHVnaW5cbiAqIGFuZCBub3RpZnkgYW4gdXBkYXRlIGluIHRoZSBkYXRhLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5zaWRlbWVudVxuICogQG5nZG9jIHByb3ZpZGVyXG4gKiBAbmFtZSAkbW1TaWRlTWVudURlbGVnYXRlXG4gKi9cbi5wcm92aWRlcignJG1tU2lkZU1lbnVEZWxlZ2F0ZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYXZIYW5kbGVycyA9IHt9LFxuICAgICAgICBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIG5hdmlnYXRpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5zaWRlbWVudVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaWRlTWVudURlbGVnYXRlUHJvdmlkZXIjcmVnaXN0ZXJOYXZIYW5kbGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFkZG9uIFRoZSBhZGRvbidzIG5hbWUgKG1tYUZpbGVzLCBtbWFNZXNzYWdlcywgLi4uKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gaGFuZGxlciBNdXN0IGJlIHJlc29sdmVkIHRvIGFuIG9iamVjdCBkZWZpbmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucy4gT3IgdG8gYSBmdW5jdGlvblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuaW5nIGFuIG9iamVjdCBkZWZpbmluZyB0aGVzZSBmdW5jdGlvbnMuIFNlZSB7QGxpbmsgJG1tVXRpbCNyZXNvbHZlT2JqZWN0fS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBpc0VuYWJsZWQgKEJvb2xlYW58UHJvbWlzZSkgV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBvbiBhIHNpdGUgbGV2ZWwuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gdXNpbmcgYSBwcm9taXNlLCBpdCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBnZXRDb250cm9sbGVyIChPYmplY3QpIFJldHVybnMgdGhlIG9iamVjdCB0aGF0IHdpbGwgYWN0IGFzIGNvbnRyb2xsZXIuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGNvcmUvY29tcG9uZW50cy9zaWRlbWVudS90ZW1wbGF0ZXMvbWVudS5odG1sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRoZSBsaXN0IG9mIHNjb3BlIHZhcmlhYmxlcyBleHBlY3RlZC5cbiAgICAgKi9cbiAgICBzZWxmLnJlZ2lzdGVyTmF2SGFuZGxlciA9IGZ1bmN0aW9uKGFkZG9uLCBoYW5kbGVyLCBwcmlvcml0eSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hdkhhbmRsZXJzW2FkZG9uXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJG1tU2lkZU1lbnVEZWxlZ2F0ZVByb3ZpZGVyOiBBZGRvbiAnXCIgKyBuYXZIYW5kbGVyc1thZGRvbl0uYWRkb24gKyBcIicgYWxyZWFkeSByZWdpc3RlcmVkIGFzIG5hdmlnYXRpb24gaGFuZGxlclwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIiRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlcjogUmVnaXN0ZXJlZCBhZGRvbiAnXCIgKyBhZGRvbiArIFwiJyBhcyBuYXZpZ2F0aW9uIGhhbmRsZXIuXCIpO1xuICAgICAgICBuYXZIYW5kbGVyc1thZGRvbl0gPSB7XG4gICAgICAgICAgICBhZGRvbjogYWRkb24sXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2VsZi4kZ2V0ID0gZnVuY3Rpb24oJG1tVXRpbCwgJHEsICRsb2csICRtbVNpdGUpIHtcbiAgICAgICAgdmFyIGVuYWJsZWROYXZIYW5kbGVycyA9IHt9LFxuICAgICAgICAgICAgY3VycmVudFNpdGVIYW5kbGVycyA9IFtdLCAvLyBIYW5kbGVycyB0byByZXR1cm4uXG4gICAgICAgICAgICBzZWxmID0ge30sXG4gICAgICAgICAgICBsb2FkZWQgPSBmYWxzZTsgLy8gSWYgc2l0ZSBoYW5kbGVycyBoYXZlIGJlZW4gbG9hZGVkLlxuXG4gICAgICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1TaWRlTWVudURlbGVnYXRlJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGFkZG9ucyBhcmUgbG9hZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmUuc2lkZW1lbnVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1TaWRlTWVudURlbGVnYXRlI2FyZU5hdkhhbmRsZXJzTG9hZGVkXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgYWRkb25zIGFyZSBsb2FkZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuYXJlTmF2SGFuZGxlcnNMb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIGN1cnJlbnQgc2l0ZSBuYXYgaGFuZGxlcnMuIFJlc2VydmVkIGZvciBjb3JlIHVzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLnNpZGVtZW51XG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tU2lkZU1lbnVEZWxlZ2F0ZSNjbGVhclNpdGVIYW5kbGVyc1xuICAgICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5jbGVhclNpdGVIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAkbW1VdGlsLmVtcHR5QXJyYXkoY3VycmVudFNpdGVIYW5kbGVycyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaGFuZGxlcnMgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5zaWRlbWVudVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVNpZGVNZW51RGVsZWdhdGUjZ2V0TmF2SGFuZGxlcnNcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgJ3ByaW9yaXR5JyBhbmQgJ2NvbnRyb2xsZXInLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXROYXZIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTaXRlSGFuZGxlcnM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgaGFuZGxlciBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLnNpZGVtZW51XG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tU2lkZU1lbnVEZWxlZ2F0ZSN1cGRhdGVOYXZIYW5kbGVyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRvbiBUaGUgYWRkb24uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVySW5mbyBUaGUgaGFuZGxlciBkZXRhaWxzLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGVuYWJsZWQsIHJlamVjdGVkIHdoZW4gbm90LlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnVwZGF0ZU5hdkhhbmRsZXIgPSBmdW5jdGlvbihhZGRvbiwgaGFuZGxlckluZm8pIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXJJbmZvLmluc3RhbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJJbmZvLmluc3RhbmNlID0gJG1tVXRpbC5yZXNvbHZlT2JqZWN0KGhhbmRsZXJJbmZvLmhhbmRsZXIsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihoYW5kbGVySW5mby5pbnN0YW5jZS5pc0VuYWJsZWQoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrcyBpZiB0aGUgY29udGVudCBpcyBlbmFibGVkLlxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZE5hdkhhbmRsZXJzW2FkZG9uXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBoYW5kbGVySW5mby5pbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBoYW5kbGVySW5mby5wcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW5hYmxlZE5hdkhhbmRsZXJzW2FkZG9uXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmUuc2lkZW1lbnVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1TaWRlTWVudURlbGVnYXRlI3VwZGF0ZU5hdkhhbmRsZXJzXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gZG9uZS5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi51cGRhdGVOYXZIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1VwZGF0aW5nIG5hdmlnYXRpb24gaGFuZGxlcnMgZm9yIGN1cnJlbnQgc2l0ZS4nKTtcblxuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIGFsbCB0aGUgY29udGVudCBoYW5kbGVycy5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChuYXZIYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlckluZm8sIGFkZG9uKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLnVwZGF0ZU5hdkhhbmRsZXIoYWRkb24sIGhhbmRsZXJJbmZvKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE5ldmVyIHJlamVjdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAkbW1VdGlsLmVtcHR5QXJyYXkoY3VycmVudFNpdGVIYW5kbGVycyk7XG5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW5hYmxlZE5hdkhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXRlSGFuZGxlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBoYW5kbGVyLmluc3RhbmNlLmdldENvbnRyb2xsZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBoYW5kbGVyLnByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUudGV4dHZpZXdlcicpXG5cbi8qKlxuICogVGV4dCB2aWV3ZXIgIGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLnRleHR2aWV3ZXJcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbVRleHRWaWV3ZXJJbmRleEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tVGV4dFZpZXdlckluZGV4Q3RybCcsIGZ1bmN0aW9uKCRzdGF0ZVBhcmFtcywgJHNjb3BlKSB7XG4gICAgJHNjb3BlLnRpdGxlID0gJHN0YXRlUGFyYW1zLnRpdGxlO1xuICAgICRzY29wZS5jb250ZW50ID0gJHN0YXRlUGFyYW1zLmNvbnRlbnQ7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS51c2VyJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGhhbmRsZSBhIHVzZXIgcHJvZmlsZSBwYWdlLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hUGFydGljaXBhbnRzUHJvZmlsZUN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tVXNlclByb2ZpbGVDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbVV0aWwsICRtbVVzZXIsICRtbVVzZXJEZWxlZ2F0ZSwgJG1tU2l0ZSwgJHEsICR0cmFuc2xhdGUpIHtcblxuICAgIHZhciBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZCxcbiAgICAgICAgdXNlcmlkICAgPSAkc3RhdGVQYXJhbXMudXNlcmlkO1xuXG4gICAgJHNjb3BlLmlzQW5kcm9pZCA9IGlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpO1xuICAgICRzY29wZS5wbHVnaW5zID0gW107XG5cbiAgICBmdW5jdGlvbiBmZXRjaFVzZXJEYXRhKCkge1xuICAgICAgICByZXR1cm4gJG1tVXNlci5nZXRQcm9maWxlKHVzZXJpZCwgY291cnNlaWQpLnRoZW4oZnVuY3Rpb24odXNlcikge1xuXG4gICAgICAgICAgICB1c2VyLmFkZHJlc3MgPSAkbW1Vc2VyLmZvcm1hdEFkZHJlc3ModXNlci5hZGRyZXNzLCB1c2VyLmNpdHksIHVzZXIuY291bnRyeSk7XG4gICAgICAgICAgICBpZiAodXNlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdXNlci5lbmNvZGVkQWRkcmVzcyA9IGVuY29kZVVSSUNvbXBvbmVudCh1c2VyLmFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkbW1Vc2VyLmZvcm1hdFJvbGVMaXN0KHVzZXIucm9sZXMpLnRoZW4oZnVuY3Rpb24ocm9sZXMpIHtcbiAgICAgICAgICAgICAgICB1c2VyLnJvbGVzID0gcm9sZXM7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJHNjb3BlLnVzZXIgPSB1c2VyO1xuICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gdXNlci5mdWxsbmFtZTtcbiAgICAgICAgICAgICRzY29wZS5oYXNDb250YWN0ID0gdXNlci5lbWFpbCB8fCB1c2VyLnBob25lMSB8fCB1c2VyLnBob25lMiB8fCB1c2VyLmNpdHkgfHwgdXNlci5jb3VudHJ5IHx8IHVzZXIuYWRkcmVzcztcbiAgICAgICAgICAgICRzY29wZS5oYXNEZXRhaWxzID0gdXNlci51cmwgfHwgdXNlci5yb2xlcyB8fCB1c2VyLmludGVyZXN0cztcblxuICAgICAgICAgICAgJHNjb3BlLmlzTG9hZGluZ0hhbmRsZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICRtbVVzZXJEZWxlZ2F0ZS5nZXRQcm9maWxlSGFuZGxlcnNGb3IodXNlciwgY291cnNlaWQpLnRoZW4oZnVuY3Rpb24oaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUucHJvZmlsZUhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pc0xvYWRpbmdIYW5kbGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICRzY29wZS51c2VyID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmV0Y2hVc2VyRGF0YSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEFkZCBsb2cgaW4gTW9vZGxlLlxuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnY29yZV91c2VyX3ZpZXdfdXNlcl9wcm9maWxlJywge1xuICAgICAgICAgICAgdXNlcmlkOiB1c2VyaWQsXG4gICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlaWRcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICRzY29wZS5pc0RlbGV0ZWQgPSBlcnJvciA9PT0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLnVzZXJkZWxldGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS51c2VyTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgICRzY29wZS5yZWZyZXNoVXNlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1Vc2VyLmludmFsaWRhdGVVc2VyQ2FjaGUodXNlcmlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZmV0Y2hVc2VyRGF0YSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIGdvIHRvIHVzZXIgcHJvZmlsZSBvbiBjbGljay5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBwcm92aWRlclxuICogQG5hbWUgbW1Vc2VyTGlua1xuICovXG4uZGlyZWN0aXZlKCdtbVVzZXJMaW5rJywgZnVuY3Rpb24oJHN0YXRlLCBtbVVzZXJQcm9maWxlU3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICRzdGF0ZS5nbyhtbVVzZXJQcm9maWxlU3RhdGUsIHtjb3Vyc2VpZDogYXR0cnMuY291cnNlaWQsIHVzZXJpZDogYXR0cnMudXNlcmlkfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS51c2VyJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGludGVyYWN0IHdpdGggcGx1Z2lucyB0byBiZSBzaG93biBpbiB1c2VyIHByb2ZpbGUuIFByb3ZpZGVzIGZ1bmN0aW9ucyB0byByZWdpc3RlciBhIHBsdWdpblxuICogYW5kIG5vdGlmeSBhbiB1cGRhdGUgaW4gdGhlIGRhdGEuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLnVzZXJcbiAqIEBuZ2RvYyBwcm92aWRlclxuICogQG5hbWUgJG1tVXNlckRlbGVnYXRlXG4gKi9cbi5wcm92aWRlcignJG1tVXNlckRlbGVnYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb2ZpbGVIYW5kbGVycyA9IHt9LFxuICAgICAgICBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHByb2ZpbGUgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVVzZXJEZWxlZ2F0ZVByb3ZpZGVyI3JlZ2lzdGVyUHJvZmlsZUhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50IFRoZSBhZGRvbidzIG5hbWUsIG9yIGFkZG9uIGFuZCBzdWIgY29udGV4dCAobW1hTWVzc2FnZXMsIG1tYU1lc3NhZ2U6YmxvY2tDb250YWN0LCAuLi4pXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEZ1bmN0aW9ufSBoYW5kbGVyIE11c3QgYmUgcmVzb2x2ZWQgdG8gYW4gb2JqZWN0IGRlZmluaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zLiBPciB0byBhIGZ1bmN0aW9uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmluZyBhbiBvYmplY3QgZGVmaW5pbmcgdGhlc2UgZnVuY3Rpb25zLiBTZWUge0BsaW5rICRtbVV0aWwjcmVzb2x2ZU9iamVjdH0uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gaXNFbmFibGVkIChCb29sZWFufFByb21pc2UpIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgb24gYSBzaXRlIGxldmVsLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHVzaW5nIGEgcHJvbWlzZSwgaXQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gaXNFbmFibGVkRm9yVXNlciAoQm9vbGVhbnxQcm9taXNlKSBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIHVzZXIuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHVzaW5nIGEgcHJvbWlzZSwgaXQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gZ2V0Q29udHJvbGxlcih1c2VyaWQpIChGdW5jdGlvbikgUmV0dXJucyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGFjdCBhcyBjb250cm9sbGVyLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBjb3JlL2NvbXBvbmVudHMvdXNlci90ZW1wbGF0ZXMvcHJvZmlsZS5odG1sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRoZSBsaXN0IG9mIHNjb3BlIHZhcmlhYmxlcyBleHBlY3RlZC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBzdHJpbmcgY2FuIGVpdGhlciBiZSAnZmFjdG9yeU5hbWUnIG9yICdmYWN0b3J5TmFtZS5mdW5jdGlvblRvQ2FsbCcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eT0xMDBdIFBsdWdpbiBwcmlvcml0eS5cbiAgICAgKi9cbiAgICBzZWxmLnJlZ2lzdGVyUHJvZmlsZUhhbmRsZXIgPSBmdW5jdGlvbihjb21wb25lbnQsIGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvZmlsZUhhbmRsZXJzW2NvbXBvbmVudF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiRtbVVzZXJEZWxlZ2F0ZVByb3ZpZGVyOiBIYW5kbGVyICdcIiArIHByb2ZpbGVIYW5kbGVyc1tjb21wb25lbnRdLmNvbXBvbmVudCArIFwiJyBhbHJlYWR5IHJlZ2lzdGVyZWQgYXMgcHJvZmlsZSBoYW5kbGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiJG1tVXNlckRlbGVnYXRlUHJvdmlkZXI6IFJlZ2lzdGVyZWQgY29tcG9uZW50ICdcIiArIGNvbXBvbmVudCArIFwiJyBhcyBwcm9maWxlIGhhbmRsZXIuXCIpO1xuICAgICAgICBwcm9maWxlSGFuZGxlcnNbY29tcG9uZW50XSA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICAgIGluc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmlvcml0eTogdHlwZW9mIHByaW9yaXR5ID09PSAndW5kZWZpbmVkJyA/IDEwMCA6IHByaW9yaXR5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBzZWxmLiRnZXQgPSBmdW5jdGlvbigkcSwgJGxvZywgJG1tU2l0ZSwgJG1tVXRpbCkge1xuICAgICAgICB2YXIgZW5hYmxlZFByb2ZpbGVIYW5kbGVycyA9IHt9LFxuICAgICAgICAgICAgc2VsZiA9IHt9O1xuXG4gICAgICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Vc2VyRGVsZWdhdGUnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBwcm9maWxlIGhhbmRsZXJzIGZvciBhIHVzZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXNlckRlbGVnYXRlI2dldFByb2ZpbGVIYW5kbGVyc0ZvclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlciBUaGUgdXNlciBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyAncHJpb3JpdHknIGFuZCAnY29udHJvbGxlcicuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldFByb2ZpbGVIYW5kbGVyc0ZvciA9IGZ1bmN0aW9uKHVzZXIsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlcnMgPSBbXSxcbiAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW5hYmxlZFByb2ZpbGVIYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrcyBpZiB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciB0aGUgdXNlci5cbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICRxLndoZW4oaGFuZGxlci5pbnN0YW5jZS5pc0VuYWJsZWRGb3JVc2VyKHVzZXIsIGNvdXJzZUlkKSkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBoYW5kbGVyLmluc3RhbmNlLmdldENvbnRyb2xsZXIodXNlciwgY291cnNlSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBoYW5kbGVyLnByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGhlcmUsIGl0IGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIHVzZXIuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVycztcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE5ldmVyIGZhaWxzLlxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVycztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGVuYWJsZWQgcHJvZmlsZSBoYW5kbGVycyBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLnVzZXJcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Vc2VyRGVsZWdhdGUjdXBkYXRlUHJvZmlsZUhhbmRsZXJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVySW5mbyBUaGUgaGFuZGxlciBkZXRhaWxzLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGVuYWJsZWQsIHJlamVjdGVkIHdoZW4gbm90LlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnVwZGF0ZVByb2ZpbGVIYW5kbGVyID0gZnVuY3Rpb24oY29tcG9uZW50LCBoYW5kbGVySW5mbykge1xuICAgICAgICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlckluZm8uaW5zdGFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlckluZm8uaW5zdGFuY2UgPSAkbW1VdGlsLnJlc29sdmVPYmplY3QoaGFuZGxlckluZm8uaGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKGhhbmRsZXJJbmZvLmluc3RhbmNlLmlzRW5hYmxlZCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBjb250ZW50IGlzIGVuYWJsZWQuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkUHJvZmlsZUhhbmRsZXJzW2NvbXBvbmVudF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaGFuZGxlckluZm8uaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogaGFuZGxlckluZm8ucHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVuYWJsZWRQcm9maWxlSGFuZGxlcnNbY29tcG9uZW50XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIHByb2ZpbGUgaGFuZGxlcnMgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXNlckRlbGVnYXRlI3VwZGF0ZVByb2ZpbGVIYW5kbGVyc1xuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGRvbmUuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYudXBkYXRlUHJvZmlsZUhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVXBkYXRpbmcgcHJvZmlsZSBoYW5kbGVycyBmb3IgY3VycmVudCBzaXRlLicpO1xuXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgYWxsIHRoZSBwcm9maWxlIGhhbmRsZXJzLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHByb2ZpbGVIYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlckluZm8sIGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi51cGRhdGVQcm9maWxlSGFuZGxlcihjb21wb25lbnQsIGhhbmRsZXJJbmZvKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE5ldmVyIHJlamVjdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuXG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUudXNlcicpXG5cbi8qKlxuICogVXNlciBoYW5kbGVycyBmYWN0b3J5LlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tVXNlckhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1Vc2VySGFuZGxlcnMnLCBmdW5jdGlvbigkbW1VdGlsLCAkbW1Db250ZW50TGlua3NIZWxwZXIpIHtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Vc2VySGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0W119ICAgICAgICBMaXN0IG9mIGFjdGlvbnMuIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSB1c2VyIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignZ3JhZGUvcmVwb3J0L3VzZXInKSA9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAodXJsLmluZGV4T2YoJy91c2VyL3ZpZXcucGhwJykgPiAtMSB8fMKgdXJsLmluZGV4T2YoJy91c2VyL3Byb2ZpbGUucGhwJykgPiAtMSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gJG1tVXRpbC5leHRyYWN0VXJsUGFyYW1zKHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuaWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ21tLmNvcmUudmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWV5ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXRlczogc2l0ZUlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3Vyc2VpZDogcGFyYW1zLmNvdXJzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmlkOiBwYXJzZUludChwYXJhbXMuaWQsIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tQ29udGVudExpbmtzSGVscGVyLmdvSW5TaXRlKCdzaXRlLm1tX3VzZXItcHJvZmlsZScsIHN0YXRlUGFyYW1zLCBzaXRlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUudXNlcicpXG5cbi5jb25zdGFudCgnbW1Db3JlVXNlcnNTdG9yZScsICd1c2VycycpXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tU2l0ZXNGYWN0b3J5UHJvdmlkZXIsIG1tQ29yZVVzZXJzU3RvcmUpIHtcbiAgICB2YXIgc3RvcmVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBtbUNvcmVVc2Vyc1N0b3JlLFxuICAgICAgICAgICAga2V5UGF0aDogJ2lkJ1xuICAgICAgICB9XG4gICAgXTtcbiAgICAkbW1TaXRlc0ZhY3RvcnlQcm92aWRlci5yZWdpc3RlclN0b3JlcyhzdG9yZXMpO1xufSlcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIHByb3ZpZGUgdXNlciBmdW5jdGlvbmFsaXRpZXMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLnVzZXJcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Vc2VyXG4gKi9cbi5mYWN0b3J5KCckbW1Vc2VyJywgZnVuY3Rpb24oJGxvZywgJHEsICRtbVNpdGUsICRtbVV0aWwsICR0cmFuc2xhdGUsIG1tQ29yZVVzZXJzU3RvcmUpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Vc2VyJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgdXNlciBiYXNpYyBpbmZvcm1hdGlvbiBpbiBsb2NhbCBEQiB0byBiZSByZXRyaWV2ZWQgaWYgdGhlIFdTIGNhbGwgZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFVzZXIgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICBQcm9taXNlIHJlc29sdmUgd2hlbiB0aGUgdXNlciBpcyBkZWxldGVkLlxuICAgICAqL1xuICAgIHNlbGYuZGVsZXRlU3RvcmVkVXNlciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIC8vIE5vdCBsb2dnZWQgaW4sIHdlIGNhbid0IGdldCB0aGUgc2l0ZSBEQi4gVXNlciBsb2dnZWQgb3V0IG9yIHNlc3Npb24gZXhwaXJlZCB3aGlsZSBhbiBvcGVyYXRpb24gd2FzIG9uZ29pbmcuXG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmludmFsaWRhdGVVc2VyQ2FjaGUoaWQpOyAvLyBJbnZhbGlkYXRlIFdTIGNhbGxzLlxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5nZXREYigpLnJlbW92ZShtbUNvcmVVc2Vyc1N0b3JlLCBwYXJzZUludChpZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgdXNlciBhZGRyZXNzLCBjb25jYXRlbmF0aW5nIGFkZHJlc3MsIGNpdHkgYW5kIGNvdW50cnkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Vc2VyI2Zvcm1hdEFkZHJlc3NcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFkZHJlc3MgQWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNpdHkgICAgQ2l0eS4uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBjb3VudHJ5IENvdW50cnkuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIEZvcm1hdHRlZCBhZGRyZXNzLlxuICAgICAqL1xuICAgIHNlbGYuZm9ybWF0QWRkcmVzcyA9IGZ1bmN0aW9uKGFkZHJlc3MsIGNpdHksIGNvdW50cnkpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgKz0gY2l0eSA/ICcsICcgKyBjaXR5IDogJyc7XG4gICAgICAgICAgICBhZGRyZXNzICs9IGNvdW50cnkgPyAnLCAnICsgY291bnRyeSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgdXNlciByb2xlIGxpc3QsIHRyYW5zbGF0aW5nIGFuZCBjb25jYXRlbmF0aW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Vc2VyI2Zvcm1hdFJvbGVMaXN0XG4gICAgICogQHBhcmFtICB7QXJyYXl9IHJvbGVzIExpc3Qgb2YgdXNlciByb2xlcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBmb3JtYXR0ZWQgcm9sZXMgKHN0cmluZykuXG4gICAgICovXG4gICAgc2VsZi5mb3JtYXRSb2xlTGlzdCA9IGZ1bmN0aW9uKHJvbGVzKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgaWYgKHJvbGVzICYmIHJvbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICR0cmFuc2xhdGUoJ21tLmNvcmUuZWxlbWVudHNlcGFyYXRvcicpLnRoZW4oZnVuY3Rpb24oc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvbGVrZXlzID0gcm9sZXMubWFwKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbW0udXNlci4nK2VsLnNob3J0bmFtZTsgLy8gU2V0IHRoZSBzdHJpbmcga2V5IHRvIGJlIHRyYW5zbGF0ZWQuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAkdHJhbnNsYXRlKHJvbGVrZXlzKS50aGVuKGZ1bmN0aW9uKHJvbGVOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9sZXMgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcm9sZUtleSBpbiByb2xlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb2xlTmFtZSA9IHJvbGVOYW1lc1tyb2xlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb2xlTmFtZS5pbmRleE9mKCdtbS51c2VyLicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb2xlIG5hbWUgY291bGRuJ3QgYmUgdHJhbnNsYXRlZCwgbGVhdmUgaXQgbGlrZSBpdCB3YXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZU5hbWUgPSByb2xlTmFtZS5yZXBsYWNlKCdtbS51c2VyLicsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGVzICs9IChyb2xlcyAhPSAnJyA/IHNlcGFyYXRvcjogJycpICsgcm9sZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyb2xlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBwcm9maWxlLiBUaGUgdHlwZSBvZiBwcm9maWxlIHJldHJpZXZlZCBkZXBlbmRzIG9uIHRoZSBwYXJhbXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Vc2VyI2dldFByb2ZpbGVcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJpZCAgICAgIFVzZXIncyBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VpZF0gIENvdXJzZSBJRCB0byBnZXQgY291cnNlIHByb2ZpbGUsIHVuZGVmaW5lZCBvciAwIHRvIGdldCBzaXRlIHByb2ZpbGUuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gZm9yY2VMb2NhbCBUcnVlIHRvIHJldHJpZXZlIHRoZSB1c2VyIGRhdGEgZnJvbSBsb2NhbCBEQiwgZmFsc2UgdG8gcmV0cmlldmUgaXQgZnJvbSBXUy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgdXNlciBkYXRhLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UHJvZmlsZSA9IGZ1bmN0aW9uKHVzZXJpZCwgY291cnNlaWQsIGZvcmNlTG9jYWwpIHtcblxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIGlmIChmb3JjZUxvY2FsKSB7XG4gICAgICAgICAgICBzZWxmLmdldFVzZXJGcm9tTG9jYWwodXNlcmlkKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZ2V0VXNlckZyb21XUyh1c2VyaWQsIGNvdXJzZWlkKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZ2V0VXNlckZyb21XUyh1c2VyaWQsIGNvdXJzZWlkKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZ2V0VXNlckZyb21Mb2NhbCh1c2VyaWQpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHVzZXIgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJpZCBVc2VyIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRVc2VyQ2FjaGVLZXkodXNlcmlkKSB7XG4gICAgICAgIHJldHVybiAnbW1Vc2VyOmRhdGE6Jyt1c2VyaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgYmFzaWMgaW5mb3JtYXRpb24gZnJvbSBsb2NhbCBEQi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVVzZXIjZ2V0VXNlckZyb21Mb2NhbFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVXNlciBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgIFByb21pc2UgcmVzb2x2ZSB3aGVuIHRoZSB1c2VyIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFVzZXJGcm9tTG9jYWwgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICAvLyBOb3QgbG9nZ2VkIGluLCB3ZSBjYW4ndCBnZXQgdGhlIHNpdGUgREIuIFVzZXIgbG9nZ2VkIG91dCBvciBzZXNzaW9uIGV4cGlyZWQgd2hpbGUgYW4gb3BlcmF0aW9uIHdhcyBvbmdvaW5nLlxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmdldERiKCkuZ2V0KG1tQ29yZVVzZXJzU3RvcmUsIHBhcnNlSW50KGlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIHByb2ZpbGUgZnJvbSBXUy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVVzZXIjZ2V0VXNlckZyb21XU1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICAgICAgICBVc2VyIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZWlkXSBDb3Vyc2UgSUQgdG8gZ2V0IGNvdXJzZSBwcm9maWxlLCB1bmRlZmluZWQgb3IgMCB0byBnZXQgc2l0ZSBwcm9maWxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmUgd2hlbiB0aGUgdXNlciBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRVc2VyRnJvbVdTID0gZnVuY3Rpb24odXNlcmlkLCBjb3Vyc2VpZCkge1xuICAgICAgICB2YXIgd3NOYW1lLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHByZVNldHMgPXtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0VXNlckNhY2hlS2V5KHVzZXJpZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIFdTIGFuZCBkYXRhIHRvIHVzZS5cbiAgICAgICAgaWYgKGNvdXJzZWlkID4gMSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnR2V0IHBhcnRpY2lwYW50IHdpdGggSUQgJyArIHVzZXJpZCArICcgaW4gY291cnNlICcrY291cnNlaWQpO1xuICAgICAgICAgICAgd3NOYW1lID0gJ2NvcmVfdXNlcl9nZXRfY291cnNlX3VzZXJfcHJvZmlsZXMnO1xuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBcInVzZXJsaXN0WzBdW3VzZXJpZF1cIjogdXNlcmlkLFxuICAgICAgICAgICAgICAgIFwidXNlcmxpc3RbMF1bY291cnNlaWRdXCI6IGNvdXJzZWlkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnR2V0IHVzZXIgd2l0aCBJRCAnICsgdXNlcmlkKTtcbiAgICAgICAgICAgIGlmICgkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX3VzZXJfZ2V0X3VzZXJzX2J5X2ZpZWxkJykpIHtcbiAgICAgICAgICAgICAgICB3c05hbWUgPSAnY29yZV91c2VyX2dldF91c2Vyc19ieV9maWVsZCc7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZpZWxkJzogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlc1swXSc6IHVzZXJpZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdzTmFtZSA9ICdjb3JlX3VzZXJfZ2V0X3VzZXJzX2J5X2lkJztcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAndXNlcmlkc1swXSc6IHVzZXJpZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKHdzTmFtZSwgZGF0YSwgcHJlU2V0cykudGhlbihmdW5jdGlvbih1c2Vycykge1xuICAgICAgICAgICAgaWYgKHVzZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdXNlciA9IHVzZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodXNlci5jb3VudHJ5KSB7XG4gICAgICAgICAgICAgICAgdXNlci5jb3VudHJ5ID0gJG1tVXRpbC5nZXRDb3VudHJ5TmFtZSh1c2VyLmNvdW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5zdG9yZVVzZXIodXNlci5pZCwgdXNlci5mdWxsbmFtZSwgdXNlci5wcm9maWxlaW1hZ2V1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyB1c2VyIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLnVzZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVXNlciNpbnZhbGlkYXRlVXNlckNhY2hlXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VyaWQgVXNlciBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlVXNlckNhY2hlID0gZnVuY3Rpb24odXNlcmlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldFVzZXJDYWNoZUtleSh1c2VyaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgdXNlciBiYXNpYyBpbmZvcm1hdGlvbiBpbiBsb2NhbCBEQiB0byBiZSByZXRyaWV2ZWQgaWYgdGhlIFdTIGNhbGwgZmFpbHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Vc2VyI3N0b3JlVXNlclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICAgICAgVXNlciBJRC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZ1bGxuYW1lIFVzZXIgZnVsbCBuYW1lLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gYXZhdGFyICAgVXNlciBhdmF0YXIgVVJMLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlIHdoZW4gdGhlIHVzZXIgaXMgc3RvcmVkLlxuICAgICAqL1xuICAgIHNlbGYuc3RvcmVVc2VyID0gZnVuY3Rpb24oaWQsIGZ1bGxuYW1lLCBhdmF0YXIpIHtcbiAgICAgICAgaWYgKCEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgLy8gTm90IGxvZ2dlZCBpbiwgd2UgY2FuJ3QgZ2V0IHRoZSBzaXRlIERCLiBVc2VyIGxvZ2dlZCBvdXQgb3Igc2Vzc2lvbiBleHBpcmVkIHdoaWxlIGFuIG9wZXJhdGlvbiB3YXMgb25nb2luZy5cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLmdldERiKCkuaW5zZXJ0KG1tQ29yZVVzZXJzU3RvcmUsIHtcbiAgICAgICAgICAgIGlkOiBwYXJzZUludChpZCksXG4gICAgICAgICAgICBmdWxsbmFtZTogZnVsbG5hbWUsXG4gICAgICAgICAgICBwcm9maWxlaW1hZ2V1cmw6IGF2YXRhclxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgdXNlcnMgYmFzaWMgaW5mb3JtYXRpb24gaW4gbG9jYWwgREIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gdXNlcnMgVXNlcnMgdG8gc3RvcmUuIEZpZWxkcyBzdG9yZWQ6IGlkLCBmdWxsbmFtZSwgcHJvZmlsZWltYWdldXJsLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmUgd2hlbiB0aGUgdXNlciBpcyBzdG9yZWQuXG4gICAgICovXG4gICAgc2VsZi5zdG9yZVVzZXJzID0gZnVuY3Rpb24odXNlcnMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgICAgICB2YXIgdXNlcmlkID0gdXNlci5pZCB8fCB1c2VyLnVzZXJpZCxcbiAgICAgICAgICAgICAgICBpbWcgPSB1c2VyLnByb2ZpbGVpbWFnZXVybCB8fCB1c2VyLnByb2ZpbGVpbWd1cmw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJpZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5zdG9yZVVzZXIodXNlcmlkLCB1c2VyLmZ1bGxuYW1lLCBpbWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5jYWxlbmRhcicsIFtdKVxuXG4uY29uc3RhbnQoJ21tYUNhbGVuZGFyRGF5c0ludGVydmFsJywgMzApXG4uY29uc3RhbnQoJ21tYUNhbGVuZGFyRGVmYXVsdE5vdGlmVGltZScsIDYwKVxuLmNvbnN0YW50KCdtbWFDYWxlbmRhckNvbXBvbmVudCcsICdtbWFDYWxlbmRhckV2ZW50cycpXG4uY29uc3RhbnQoJ21tYUNhbGVuZGFyUHJpb3JpdHknLCA0MDApXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlciwgbW1hQ2FsZW5kYXJQcmlvcml0eSkge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcbiAgICAgICAgLnN0YXRlKCdzaXRlLmNhbGVuZGFyJywge1xuICAgICAgICAgICAgdXJsOiAnL2NhbGVuZGFyJyxcbiAgICAgICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFDYWxlbmRhckxpc3RDdHJsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvY2FsZW5kYXIvdGVtcGxhdGVzL2xpc3QuaHRtbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgZXZlbnRpZDogbnVsbCxcbiAgICAgICAgICAgICAgICBjbGVhcjogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAuc3RhdGUoJ3NpdGUuY2FsZW5kYXItZXZlbnQnLCB7XG4gICAgICAgICAgICB1cmw6ICcvY2FsZW5kYXItZXZlbnQvOmlkJywgLy8gV2UgbmVlZCB0byBhZGQgSUQgdG8gdGhlIFVSTCB0byBtYWtlIG5nLWhyZWYgd29yay5cbiAgICAgICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFDYWxlbmRhckV2ZW50Q3RybCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL2NhbGVuZGFyL3RlbXBsYXRlcy9ldmVudC5odG1sJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAvLyBSZWdpc3RlciBzaWRlIG1lbnUgYWRkb24uXG4gICAgLy8gRllJOiBDb21tZW50IHRoaXMgb3V0IHRvIGRpc2FibGUgZnJvbSBzaWRlIG1lbnVcbiAgICAkbW1TaWRlTWVudURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJOYXZIYW5kbGVyKCdtbWFDYWxlbmRhcicsICckbW1hQ2FsZW5kYXJIYW5kbGVycy5zaWRlTWVudU5hdicsIG1tYUNhbGVuZGFyUHJpb3JpdHkpO1xuXG59KVxuXG4ucnVuKGZ1bmN0aW9uKCRtbWFDYWxlbmRhciwgJG1tTG9jYWxOb3RpZmljYXRpb25zLCAkc3RhdGUsICRpb25pY1BsYXRmb3JtLCAkbW1BcHAsIG1tYUNhbGVuZGFyQ29tcG9uZW50KSB7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIG5vdGlmaWNhdGlvbiBjbGlja3MuXG4gICAgJG1tTG9jYWxOb3RpZmljYXRpb25zLnJlZ2lzdGVyQ2xpY2sobW1hQ2FsZW5kYXJDb21wb25lbnQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuZXZlbnRpZCkge1xuICAgICAgICAgICAgJG1tQXBwLnJlYWR5KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3JlZGlyZWN0Jywge3NpdGVpZDogZGF0YS5zaXRlaWQsIHN0YXRlOiAnc2l0ZS5jYWxlbmRhcicsIHBhcmFtczoge2V2ZW50aWQ6IGRhdGEuZXZlbnRpZH19KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkaW9uaWNQbGF0Zm9ybS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYUNhbGVuZGFyLnNjaGVkdWxlQWxsU2l0ZXNFdmVudHNOb3RpZmljYXRpb25zKCk7XG4gICAgfSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb24nLCBbXSlcblxuLmNvbnN0YW50KCdtbWFDb3Vyc2VDb21wbGV0aW9uUHJpb3JpdHknLCAyMDApXG4uY29uc3RhbnQoJ21tYUNvdXJzZUNvbXBsZXRpb25WaWV3Q29tcGxldGlvblByaW9yaXR5JywgMjAwKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkbW1Vc2VyRGVsZWdhdGVQcm92aWRlciwgJG1tQ291cnNlc0RlbGVnYXRlUHJvdmlkZXIsIG1tYUNvdXJzZUNvbXBsZXRpb25Qcmlvcml0eSxcbiAgICAgICAgICAgIG1tYUNvdXJzZUNvbXBsZXRpb25WaWV3Q29tcGxldGlvblByaW9yaXR5KSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLmNvdXJzZS1jb21wbGV0aW9uJywge1xuICAgICAgICB1cmw6ICcvY291cnNlLWNvbXBsZXRpb24nLFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvY291cnNlY29tcGxldGlvbi90ZW1wbGF0ZXMvcmVwb3J0Lmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFDb3Vyc2VDb21wbGV0aW9uUmVwb3J0Q3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBjb3Vyc2U6IG51bGwsXG4gICAgICAgICAgICB1c2VyaWQ6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgcGx1Z2luIG9uIHVzZXIgcHJvZmlsZS5cbiAgICAkbW1Vc2VyRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlclByb2ZpbGVIYW5kbGVyKCdtbWFDb3Vyc2VDb21wbGV0aW9uOnZpZXdDb21wbGV0aW9uJyxcbiAgICAgICAgICAgICckbW1hQ291cnNlQ29tcGxldGlvbkhhbmRsZXJzLnZpZXdDb21wbGV0aW9uJywgbW1hQ291cnNlQ29tcGxldGlvblZpZXdDb21wbGV0aW9uUHJpb3JpdHkpO1xuXG4gICAgLy8gUmVnaXN0ZXIgY291cnNlcyBoYW5kbGVyLlxuICAgICRtbUNvdXJzZXNEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTmF2SGFuZGxlcignbW1hQ291cnNlQ29tcGxldGlvbicsXG4gICAgICAgICAgICAnJG1tYUNvdXJzZUNvbXBsZXRpb25IYW5kbGVycy5jb3Vyc2VzTmF2JywgbW1hQ291cnNlQ29tcGxldGlvblByaW9yaXR5KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuZmlsZXMnLCBbJ21tLmNvcmUnXSlcblxuLmNvbnN0YW50KCdtbWFGaWxlc1VwbG9hZFN0YXRlTmFtZScsICdzaXRlLmZpbGVzLXVwbG9hZCcpXG4uY29uc3RhbnQoJ21tYUZpbGVzU2hhcmVkRmlsZXNTdG9yZScsICdzaGFyZWRfZmlsZXMnKVxuLmNvbnN0YW50KCdtbWFGaWxlc015Q29tcG9uZW50JywgJ21tYUZpbGVzTXknKVxuLmNvbnN0YW50KCdtbWFGaWxlc1NpdGVDb21wb25lbnQnLCAnbW1hRmlsZXNTaXRlJylcbi5jb25zdGFudCgnbW1hRmlsZXNQcmlvcml0eScsIDIwMClcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJG1tU2lkZU1lbnVEZWxlZ2F0ZVByb3ZpZGVyLCBtbWFGaWxlc1VwbG9hZFN0YXRlTmFtZSwgbW1hRmlsZXNQcmlvcml0eSkge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcbiAgICAgICAgLnN0YXRlKCdzaXRlLmZpbGVzJywge1xuICAgICAgICAgICAgdXJsOiAnL2ZpbGVzJyxcbiAgICAgICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFGaWxlc0luZGV4Q29udHJvbGxlcicsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL2ZpbGVzL3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAuc3RhdGUoJ3NpdGUuZmlsZXMtbGlzdCcsIHtcbiAgICAgICAgICAgIHVybDogJy9saXN0JyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHBhdGg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJvb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFGaWxlc0xpc3RDb250cm9sbGVyJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvZmlsZXMvdGVtcGxhdGVzL2xpc3QuaHRtbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLnN0YXRlKG1tYUZpbGVzVXBsb2FkU3RhdGVOYW1lLCB7XG4gICAgICAgICAgICB1cmw6ICcvdXBsb2FkJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHBhdGg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJvb3Q6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYUZpbGVzVXBsb2FkQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL2ZpbGVzL3RlbXBsYXRlcy91cGxvYWQuaHRtbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLnN0YXRlKCdzaXRlLmZpbGVzLWNob29zZS1zaXRlJywge1xuICAgICAgICAgICAgdXJsOiAnL2Nob29zZS1zaXRlJyxcbiAgICAgICAgICAgIHBhcmFtczrCoHtcbiAgICAgICAgICAgICAgICBmaWxlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYUZpbGVzQ2hvb3NlU2l0ZUN0cmwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9maWxlcy90ZW1wbGF0ZXMvY2hvb3Nlc2l0ZS5odG1sJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAvLyBSZWdpc3RlciBzaWRlIG1lbnUgYWRkb24uXG4gICAgJG1tU2lkZU1lbnVEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTmF2SGFuZGxlcignbW1hRmlsZXMnLCAnJG1tYUZpbGVzSGFuZGxlcnMuc2lkZU1lbnVOYXYnLCBtbWFGaWxlc1ByaW9yaXR5KTtcblxufSlcblxuLnJ1bihmdW5jdGlvbigkbW1hRmlsZXMsICRzdGF0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCAkbW1VdGlsLCAkbW1hRmlsZXNIZWxwZXIsICRpb25pY1BsYXRmb3JtLCAkbW1BcHApIHtcblxuICAgIC8vIFNlYXJjaCBmb3IgbmV3IGZpbGVzIHNoYXJlZCB3aXRoIHRoZSB1cGxvYWQgKHRvIHVwbG9hZCkuXG4gICAgaWYgKGlvbmljLlBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgICAgLy8gSW4gaU9TIHdlIG5lZWQgdG8gbWFudWFsbHkgY2hlY2sgaWYgdGhlcmUgYXJlIG5ldyBmaWxlcyBpbiB0aGUgYXBwIEluYm94IGZvbGRlci5cbiAgICAgICAgZnVuY3Rpb24gc2VhcmNoVG9VcGxvYWQoKSB7XG4gICAgICAgICAgICAkbW1BcHAucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRtbWFGaWxlcy5jaGVja0lPU05ld0ZpbGVzKCkudGhlbihmdW5jdGlvbihmaWxlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGVzKCkudGhlbihmdW5jdGlvbihzaXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpdGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLmZpbGVzLmVycm9ycmVjZWl2ZWZpbGVub3NpdGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpdGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tYUZpbGVzSGVscGVyLnNob3dDb25maXJtQW5kVXBsb2FkSW5TaXRlKGZpbGVFbnRyeSwgc2l0ZXNbMF0uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUuZmlsZXMtY2hvb3NlLXNpdGUnLCB7ZmlsZTogZmlsZUVudHJ5fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjaGVjayBpdCBhdCBhcHAgc3RhcnQgYW5kIHdoZW4gdGhlIGFwcCBpcyByZXN1bWVkLlxuICAgICAgICAkaW9uaWNQbGF0Zm9ybS5vbigncmVzdW1lJywgc2VhcmNoVG9VcGxvYWQpO1xuICAgICAgICBzZWFyY2hUb1VwbG9hZCgpO1xuICAgIH1cblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5mcm9udHBhZ2UnLCBbXSlcblxuLmNvbnN0YW50KCdtbWFGcm9udHBhZ2VQcmlvcml0eScsIDEwMDApXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tU2lkZU1lbnVEZWxlZ2F0ZVByb3ZpZGVyLCBtbWFGcm9udHBhZ2VQcmlvcml0eSkge1xuICAgIC8vIFJlZ2lzdGVyIHNpZGUgbWVudSBhZGRvbi5cbiAgICAvLyRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlci5yZWdpc3Rlck5hdkhhbmRsZXIoJ21tYUZyb250cGFnZScsICckbW1hRnJvbnRQYWdlSGFuZGxlcnMuc2lkZU1lbnVOYXYnLCBtbWFGcm9udHBhZ2VQcmlvcml0eSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmdyYWRlcycsIFtdKVxuXG4uY29uc3RhbnQoJ21tYUdyYWRlc1ByaW9yaXR5JywgNDAwKVxuLmNvbnN0YW50KCdtbWFHcmFkZXNWaWV3R3JhZGVzUHJpb3JpdHknLCA0MDApXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICRtbVVzZXJEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db3Vyc2VzRGVsZWdhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcixcbiAgICAgICAgICAgIG1tYUdyYWRlc1ByaW9yaXR5LCBtbWFHcmFkZXNWaWV3R3JhZGVzUHJpb3JpdHkpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUuZ3JhZGVzJywge1xuICAgICAgICB1cmw6ICcvZ3JhZGVzJyxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL2dyYWRlcy90ZW1wbGF0ZXMvdGFibGUuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYUdyYWRlc1RhYmxlQ3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBjb3Vyc2U6IG51bGwsXG4gICAgICAgICAgICB1c2VyaWQ6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvLyBSZWdpc3RlciBwbHVnaW4gb24gdXNlciBwcm9maWxlLlxuICAgICRtbVVzZXJEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJvZmlsZUhhbmRsZXIoJ21tYUdyYWRlczp2aWV3R3JhZGVzJywgJyRtbWFHcmFkZXNIYW5kbGVycy52aWV3R3JhZGVzJywgbW1hR3JhZGVzVmlld0dyYWRlc1ByaW9yaXR5KTtcblxuICAgIC8vIFJlZ2lzdGVyIGNvdXJzZXMgY29udGVudCBwbHVnaW4uXG4gICAgJG1tQ291cnNlc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJOYXZIYW5kbGVyKCdtbWFHcmFkZXMnLCAnJG1tYUdyYWRlc0hhbmRsZXJzLmNvdXJzZXNOYXYnLCBtbWFHcmFkZXNQcmlvcml0eSk7XG5cbiAgICAvLyBSZWdpc3RlciBjb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFHcmFkZXMnLCAnJG1tYUdyYWRlc0hhbmRsZXJzLmxpbmtzSGFuZGxlcicpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tZXNzYWdlcycsIFsnbW0uY29yZSddKVxuXG4uY29uc3RhbnQoJ21tYU1lc3NhZ2VzRGlzY3Vzc2lvbkxvYWRlZEV2ZW50JywgJ21tYV9tZXNzYWdlc19kaXNjdXNzaW9uX2xvYWRlZCcpXG4uY29uc3RhbnQoJ21tYU1lc3NhZ2VzRGlzY3Vzc2lvbkxlZnRFdmVudCcsICdtbWFfbWVzc2FnZXNfZGlzY3Vzc2lvbl9sZWZ0Jylcbi5jb25zdGFudCgnbW1hTWVzc2FnZXNQb2xsSW50ZXJ2YWwnLCA1MDAwKVxuLmNvbnN0YW50KCdtbWFNZXNzYWdlc1ByaW9yaXR5JywgNjAwKVxuLmNvbnN0YW50KCdtbWFNZXNzYWdlc1NlbmRNZXNzYWdlUHJpb3JpdHknLCAxMDAwKVxuLmNvbnN0YW50KCdtbWFNZXNzYWdlc0FkZENvbnRhY3RQcmlvcml0eScsIDgwMClcbi5jb25zdGFudCgnbW1hTWVzc2FnZXNCbG9ja0NvbnRhY3RQcmlvcml0eScsIDYwMClcbi5jb25zdGFudCgnbW1hTWVzc2FnZXNOZXdNZXNzYWdlRXZlbnQnLCAnbW1hLW1lc3NhZ2VzX25ld19tZXNzYWdlJylcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJG1tVXNlckRlbGVnYXRlUHJvdmlkZXIsICRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlciwgbW1hTWVzc2FnZXNTZW5kTWVzc2FnZVByaW9yaXR5LFxuICAgICAgICAgICAgbW1hTWVzc2FnZXNBZGRDb250YWN0UHJpb3JpdHksIG1tYU1lc3NhZ2VzQmxvY2tDb250YWN0UHJpb3JpdHksIG1tYU1lc3NhZ2VzUHJpb3JpdHksICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubWVzc2FnZXMnLCB7XG4gICAgICAgIHVybDogJy9tZXNzYWdlcycsXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tZXNzYWdlcy90ZW1wbGF0ZXMvaW5kZXguaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU1lc3NhZ2VzSW5kZXhDdHJsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tZXNzYWdlcy1kaXNjdXNzaW9uJywge1xuICAgICAgICB1cmw6ICcvbWVzc2FnZXMtZGlzY3Vzc2lvbicsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdXNlcklkOiBudWxsLFxuICAgICAgICAgICAgdXNlckZ1bGxuYW1lOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tZXNzYWdlcy90ZW1wbGF0ZXMvZGlzY3Vzc2lvbi5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTWVzc2FnZXNEaXNjdXNzaW9uQ3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgc2lkZSBtZW51IGFkZG9uLlxuICAgICRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlci5yZWdpc3Rlck5hdkhhbmRsZXIoJ21tYU1lc3NhZ2VzJywgJyRtbWFNZXNzYWdlc0hhbmRsZXJzLnNpZGVNZW51TmF2JywgbW1hTWVzc2FnZXNQcmlvcml0eSk7XG5cbiAgICAvLyBSZWdpc3RlciB1c2VyIHByb2ZpbGUgYWRkb25zLlxuICAgICRtbVVzZXJEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJvZmlsZUhhbmRsZXIoJ21tYU1lc3NhZ2VzOnNlbmRNZXNzYWdlJywgJyRtbWFNZXNzYWdlc0hhbmRsZXJzLnNlbmRNZXNzYWdlJywgbW1hTWVzc2FnZXNTZW5kTWVzc2FnZVByaW9yaXR5KTtcbiAgICAkbW1Vc2VyRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlclByb2ZpbGVIYW5kbGVyKCdtbWFNZXNzYWdlczphZGRDb250YWN0JywgJyRtbWFNZXNzYWdlc0hhbmRsZXJzLmFkZENvbnRhY3QnLCBtbWFNZXNzYWdlc0FkZENvbnRhY3RQcmlvcml0eSk7XG4gICAgJG1tVXNlckRlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcm9maWxlSGFuZGxlcignbW1hTWVzc2FnZXM6YmxvY2tDb250YWN0JywgJyRtbWFNZXNzYWdlc0hhbmRsZXJzLmJsb2NrQ29udGFjdCcsIG1tYU1lc3NhZ2VzQmxvY2tDb250YWN0UHJpb3JpdHkpO1xuXG4gICAgLy8gUmVnaXN0ZXIgY29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hTWVzc2FnZXMnLCAnJG1tYU1lc3NhZ2VzSGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KVxuXG4ucnVuKGZ1bmN0aW9uKCRtbWFNZXNzYWdlcywgJG1tRXZlbnRzLCAkc3RhdGUsICRtbUFkZG9uTWFuYWdlciwgJG1tVXRpbCwgbW1Db3JlRXZlbnRMb2dpbikge1xuXG4gICAgLy8gSW52YWxpZGF0ZSBtZXNzYWdpbmcgZW5hYmxlZCBXUyBjYWxscy5cbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRMb2dpbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNZXNzYWdlcy5pbnZhbGlkYXRlRW5hYmxlZENhY2hlKCk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWdpc3RlciBwdXNoIG5vdGlmaWNhdGlvbiBjbGlja3MuXG4gICAgdmFyICRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUgPSAkbW1BZGRvbk1hbmFnZXIuZ2V0KCckbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlJyk7XG4gICAgaWYgKCRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUpIHtcbiAgICAgICAgJG1tUHVzaE5vdGlmaWNhdGlvbnNEZWxlZ2F0ZS5yZWdpc3RlckhhbmRsZXIoJ21tYU1lc3NhZ2VzJywgZnVuY3Rpb24obm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAoJG1tVXRpbC5pc0ZhbHNlT3JaZXJvKG5vdGlmaWNhdGlvbi5ub3RpZikpIHtcbiAgICAgICAgICAgICAgICAkbW1hTWVzc2FnZXMuaXNNZXNzYWdpbmdFbmFibGVkRm9yU2l0ZShub3RpZmljYXRpb24uc2l0ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tYU1lc3NhZ2VzLmludmFsaWRhdGVEaXNjdXNzaW9uc0NhY2hlKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygncmVkaXJlY3QnLCB7c2l0ZWlkOiBub3RpZmljYXRpb24uc2l0ZSwgc3RhdGU6ICdzaXRlLm1lc3NhZ2VzJ30pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9hc3NpZ24nLCBbJ21tLmNvcmUnXSlcblxuLmNvbnN0YW50KCdtbWFNb2RBc3NpZ25Db21wb25lbnQnLCAnbW1hTW9kQXNzaWduJylcbi5jb25zdGFudCgnbW1hTW9kQXNzaWduU3VibWlzc2lvbkNvbXBvbmVudCcsICdtbWFNb2RBc3NpZ25TdWJtaXNzaW9uJylcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfYXNzaWduJywge1xuICAgICAgICB1cmw6ICcvbW9kX2Fzc2lnbicsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICAgICAgY291cnNlaWQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RBc3NpZ25JbmRleEN0cmwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9hc3NpZ24vdGVtcGxhdGVzL2luZGV4Lmh0bWwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9hc3NpZ24tc3VibWlzc2lvbicsIHtcbiAgICAgICAgdXJsOiAnL21vZF9hc3NpZ24tc3VibWlzc2lvbicsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgc3VibWlzc2lvbjogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZEFzc2lnblN1Ym1pc3Npb25DdHJsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfYXNzaWduL3RlbXBsYXRlcy9zdWJtaXNzaW9uLmh0bWwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RBc3NpZ24nLCAnYXNzaWduJywgJyRtbWFNb2RBc3NpZ25IYW5kbGVycy5jb3Vyc2VDb250ZW50Jyk7XG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFNb2RBc3NpZ24nLCAnJG1tYU1vZEFzc2lnbkhhbmRsZXJzLmxpbmtzSGFuZGxlcicpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfYm9vaycsIFsnbW0uY29yZSddKVxuXG4uY29uc3RhbnQoJ21tYU1vZEJvb2tDb21wb25lbnQnLCAnbW1hTW9kQm9vaycpXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX2Jvb2snLCB7XG4gICAgICB1cmw6ICcvbW9kX2Jvb2snLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1vZHVsZTogbnVsbCxcbiAgICAgICAgY291cnNlaWQ6IG51bGxcbiAgICAgIH0sXG4gICAgICB2aWV3czoge1xuICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kQm9va0luZGV4Q3RybCcsXG4gICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2Jvb2svdGVtcGxhdGVzL2luZGV4Lmh0bWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZEJvb2snLCAnYm9vaycsICckbW1hTW9kQm9va0hhbmRsZXJzLmNvdXJzZUNvbnRlbnRIYW5kbGVyJyk7XG4gICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJlZmV0Y2hIYW5kbGVyKCdtbWFNb2RCb29rJywgJ2Jvb2snLCAnJG1tYU1vZEJvb2tQcmVmZXRjaEhhbmRsZXInKTtcblxuICAgIC8vIFJlZ2lzdGVyIGNvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZEJvb2snLCAnJG1tYU1vZEJvb2tIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2NoYXQnLCBbXSlcblxuLmNvbnN0YW50KCdtbWFDaGF0UG9sbEludGVydmFsJywgNDAwMClcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfY2hhdCcsIHtcbiAgICAgICAgdXJsOiAnL21vZF9jaGF0JyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgICAgICBjb3Vyc2VpZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZENoYXRJbmRleEN0cmwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9jaGF0L3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfY2hhdC1jaGF0Jywge1xuICAgICAgICB1cmw6ICcvbW9kX2NoYXQtY2hhdCcsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgY2hhdGlkOiBudWxsLFxuICAgICAgICAgICAgY291cnNlaWQ6IG51bGwsXG4gICAgICAgICAgICB0aXRsZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZENoYXRDaGF0Q3RybCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2NoYXQvdGVtcGxhdGVzL2NoYXQuaHRtbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZENoYXQnLCAnY2hhdCcsICckbW1hTW9kQ2hhdEhhbmRsZXJzLmNvdXJzZUNvbnRlbnQnKTtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZENoYXQnLCAnJG1tYU1vZENoYXRIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pOyIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9jaG9pY2UnLCBbXSlcblxuLmNvbnN0YW50KCdtbWFNb2RDaG9pY2VSZXN1bHRzTm90JywgMClcbi5jb25zdGFudCgnbW1hTW9kQ2hvaWNlUmVzdWx0c0FmdGVyQW5zd2VyJywgMSlcbi5jb25zdGFudCgnbW1hTW9kQ2hvaWNlUmVzdWx0c0FmdGVyQ2xvc2UnLCAyKVxuLmNvbnN0YW50KCdtbWFNb2RDaG9pY2VSZXN1bHRzQWx3YXlzJywgMylcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfY2hvaWNlJywge1xuICAgICAgICB1cmw6ICcvbW9kX2Nob2ljZScsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICAgICAgY291cnNlaWQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RDaG9pY2VJbmRleEN0cmwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9jaG9pY2UvdGVtcGxhdGVzL2luZGV4Lmh0bWwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RDaG9pY2UnLCAnY2hvaWNlJywgJyRtbWFNb2RDaG9pY2VIYW5kbGVycy5jb3Vyc2VDb250ZW50Jyk7XG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFNb2RDaG9pY2UnLCAnJG1tYU1vZENob2ljZUhhbmRsZXJzLmxpbmtzSGFuZGxlcicpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZm9sZGVyJywgWydtbS5jb3JlJ10pXG5cbi5jb25zdGFudCgnbW1hTW9kRm9sZGVyQ29tcG9uZW50JywgJ21tYU1vZEZvbGRlcicpXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX2ZvbGRlcicsIHtcbiAgICAgIHVybDogJy9tb2RfZm9sZGVyJyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgIGNvdXJzZWlkOiBudWxsLFxuICAgICAgICBzZWN0aW9uaWQ6IG51bGwsXG4gICAgICAgIHBhdGg6IG51bGwgLy8gRm9yIHN1YmZvbGRlcnMuIFVzZSB0aGUgcGF0aCBpbnN0ZWFkIG9mIGEgYm9vbGVhbiBzbyBBbmd1bGFyIGRldGVjdHMgdGhlbSBhcyBkaWZmZXJlbnQgc3RhdGVzLlxuICAgICAgfSxcbiAgICAgIHZpZXdzOiB7XG4gICAgICAgICdzaXRlJzoge1xuICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RGb2xkZXJJbmRleEN0cmwnLFxuICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9mb2xkZXIvdGVtcGxhdGVzL2luZGV4Lmh0bWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZEZvbGRlcicsICdmb2xkZXInLCAnJG1tYU1vZEZvbGRlckhhbmRsZXJzLmNvdXJzZUNvbnRlbnQnKTtcbiAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcmVmZXRjaEhhbmRsZXIoJ21tYU1vZEZvbGRlcicsICdmb2xkZXInLCAnJG1tYU1vZEZvbGRlclByZWZldGNoSGFuZGxlcicpO1xuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hTW9kRm9sZGVyJywgJyRtbWFNb2RGb2xkZXJIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2ZvcnVtJywgW10pXG5cbi5jb25zdGFudCgnbW1hTW9kRm9ydW1EaXNjUGVyUGFnZScsIDEwKSAvLyBNYXggb2YgZGlzY3Vzc2lvbnMgcGVyIHBhZ2UuXG4uY29uc3RhbnQoJ21tYU1vZEZvcnVtQ29tcG9uZW50JywgJ21tYU1vZEZvcnVtJylcbi5jb25zdGFudCgnbW1hTW9kRm9ydW1OZXdEaXNjdXNzaW9uRXZlbnQnLCAnbW1hLW1vZF9mb3J1bV9uZXdfZGlzY3Vzc2lvbicpXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX2ZvcnVtJywge1xuICAgICAgICB1cmw6ICcvbW9kX2ZvcnVtJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgICAgICBjb3Vyc2VpZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZEZvcnVtRGlzY3Vzc2lvbnNDdHJsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfZm9ydW0vdGVtcGxhdGVzL2Rpc2N1c3Npb25zLmh0bWwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9mb3J1bS1kaXNjdXNzaW9uJywge1xuICAgICAgICB1cmw6ICcvbW9kX2ZvcnVtLWRpc2N1c3Npb24nLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGRpc2N1c3Npb25pZDogbnVsbCxcbiAgICAgICAgICAgIGNpZDogbnVsbCAvLyBOb3QgbmFtaW5nIGl0IGNvdXJzZWlkIGJlY2F1c2UgaXQgY29sbGlkZXMgd2l0aCAnc2l0ZS5tb2RfZm9ydW0nIHBhcmFtIGluIHNwbGl0LXZpZXcuXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kRm9ydW1EaXNjdXNzaW9uQ3RybCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2ZvcnVtL3RlbXBsYXRlcy9kaXNjdXNzaW9uLmh0bWwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9mb3J1bS1uZXdkaXNjdXNzaW9uJywge1xuICAgICAgICB1cmw6ICcvbW9kX2ZvcnVtLW5ld2Rpc2N1c3Npb24nLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGNpZDogbnVsbCwgLy8gTm90IG5hbWluZyBpdCBjb3Vyc2VpZCBiZWNhdXNlIGl0IGNvbGxpZGVzIHdpdGggJ3NpdGUubW9kX2ZvcnVtJyBwYXJhbSBpbiBzcGxpdC12aWV3LlxuICAgICAgICAgICAgZm9ydW1pZDogbnVsbCxcbiAgICAgICAgICAgIGNtaWQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RGb3J1bU5ld0Rpc2N1c3Npb25DdHJsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfZm9ydW0vdGVtcGxhdGVzL25ld2Rpc2N1c3Npb24uaHRtbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZEZvcnVtJywgJ2ZvcnVtJywgJyRtbWFNb2RGb3J1bUhhbmRsZXJzLmNvdXJzZUNvbnRlbnQnKTtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZEZvcnVtJywgJyRtbWFNb2RGb3J1bUhhbmRsZXJzLmxpbmtzSGFuZGxlcicpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZ2xvc3NhcnknLCBbJ21tLmNvcmUnXSlcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfZ2xvc3NhcnknLCB7XG4gICAgICB1cmw6ICcvbW9kX2dsb3NzYXJ5JyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgIGNvdXJzZWlkOiBudWxsXG4gICAgICB9LFxuICAgICAgdmlld3M6IHtcbiAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZEdsb3NzYXJ5SW5kZXhDdHJsJyxcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfZ2xvc3NhcnkvdGVtcGxhdGVzL2luZGV4Lmh0bWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9nbG9zc2FyeS1lbnRyeScsIHtcbiAgICAgIHVybDogJy9tb2RfZ2xvc3NhcnktZW50cnknLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGNpZDogbnVsbCwgLy8gTm90IG5hbWluZyBpdCBjb3Vyc2VpZCBiZWNhdXNlIGl0IGNvbGxpZGVzIHdpdGggJ3NpdGUubW9kX2dsb3NzYXJ5JyBwYXJhbSBpbiBzcGxpdC12aWV3LlxuICAgICAgICBlbnRyeTogbnVsbFxuICAgICAgfSxcbiAgICAgIHZpZXdzOiB7XG4gICAgICAgICdzaXRlJzoge1xuICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RHbG9zc2FyeUVudHJ5Q3RybCcsXG4gICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2dsb3NzYXJ5L3RlbXBsYXRlcy9lbnRyeS5odG1sJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuICAgICRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJDb250ZW50SGFuZGxlcignbW1hTW9kR2xvc3NhcnknLCAnZ2xvc3NhcnknLCAnJG1tYU1vZEdsb3NzYXJ5SGFuZGxlcnMuY291cnNlQ29udGVudCcpO1xuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hTW9kR2xvc3NhcnknLCAnJG1tYU1vZEdsb3NzYXJ5SGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9pbXNjcCcsIFsnbW0uY29yZSddKVxuXG4uY29uc3RhbnQoJ21tYU1vZEltc2NwQ29tcG9uZW50JywgJ21tYU1vZEltc2NwJylcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfaW1zY3AnLCB7XG4gICAgICB1cmw6ICcvbW9kX2ltc2NwJyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgIGNvdXJzZWlkOiBudWxsXG4gICAgICB9LFxuICAgICAgdmlld3M6IHtcbiAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZEltc2NwSW5kZXhDdHJsJyxcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfaW1zY3AvdGVtcGxhdGVzL2luZGV4Lmh0bWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZEltc2NwJywgJ2ltc2NwJywgJyRtbWFNb2RJbXNjcEhhbmRsZXJzLmNvdXJzZUNvbnRlbnQnKTtcbiAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcmVmZXRjaEhhbmRsZXIoJ21tYU1vZEltc2NwJywgJ2ltc2NwJywgJyRtbWFNb2RJbXNjcFByZWZldGNoSGFuZGxlcicpO1xuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hTW9kSW1zY3AnLCAnJG1tYU1vZEltc2NwSGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9sYWJlbCcsIFsnbW0uY29yZSddKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfbGFiZWwnLCB7XG4gICAgICAgIHVybDogJy9tb2RfbGFiZWwnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfbGFiZWwvdGVtcGxhdGVzL2luZGV4Lmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RMYWJlbEluZGV4Q3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZExhYmVsJywgJ2xhYmVsJywgJyRtbWFNb2RMYWJlbEhhbmRsZXJzLmNvdXJzZUNvbnRlbnQnKTtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZExhYmVsJywgJyRtbWFNb2RMYWJlbEhhbmRsZXJzLmxpbmtzSGFuZGxlcicpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfbHRpJywgW10pXG5cbi5jb25zdGFudCgnbW1hTW9kTHRpQ29tcG9uZW50JywgJ21tYU1vZEx0aScpXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX2x0aScsIHtcbiAgICAgICAgdXJsOiAnL21vZF9sdGknLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogbnVsbCxcbiAgICAgICAgICAgIGNvdXJzZWlkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kTHRpSW5kZXhDdHJsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfbHRpL3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuICAgICRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJDb250ZW50SGFuZGxlcignbW1hTW9kTHRpJywgJ2x0aScsICckbW1hTW9kTHRpSGFuZGxlcnMuY291cnNlQ29udGVudCcpO1xuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hTW9kTHRpJywgJyRtbWFNb2RMdGlIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3BhZ2UnLCBbJ21tLmNvcmUnXSlcblxuLmNvbnN0YW50KCdtbWFNb2RQYWdlQ29tcG9uZW50JywgJ21tYU1vZFBhZ2UnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9wYWdlJywge1xuICAgICAgdXJsOiAnL21vZF9wYWdlJyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgIGNvdXJzZWlkOiBudWxsXG4gICAgICB9LFxuICAgICAgdmlld3M6IHtcbiAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZFBhZ2VJbmRleEN0cmwnLFxuICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9wYWdlL3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RQYWdlJywgJ3BhZ2UnLCAnJG1tYU1vZFBhZ2VIYW5kbGVycy5jb3Vyc2VDb250ZW50Jyk7XG4gICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJlZmV0Y2hIYW5kbGVyKCdtbWFNb2RQYWdlJywgJ3BhZ2UnLCAnJG1tYU1vZFBhZ2VQcmVmZXRjaEhhbmRsZXInKTtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZFBhZ2UnLCAnJG1tYU1vZFBhZ2VIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3Jlc291cmNlJywgWydtbS5jb3JlJ10pXG5cbi5jb25zdGFudCgnbW1hTW9kUmVzb3VyY2VDb21wb25lbnQnLCAnbW1hTW9kUmVzb3VyY2UnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9yZXNvdXJjZScsIHtcbiAgICAgIHVybDogJy9tb2RfcmVzb3VyY2UnLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1vZHVsZTogbnVsbCxcbiAgICAgICAgY291cnNlaWQ6IG51bGxcbiAgICAgIH0sXG4gICAgICB2aWV3czoge1xuICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kUmVzb3VyY2VJbmRleEN0cmwnLFxuICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9yZXNvdXJjZS90ZW1wbGF0ZXMvaW5kZXguaHRtbCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIsICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuICAgICRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJDb250ZW50SGFuZGxlcignbW1hTW9kUmVzb3VyY2UnLCAncmVzb3VyY2UnLCAnJG1tYU1vZFJlc291cmNlSGFuZGxlcnMuY291cnNlQ29udGVudCcpO1xuICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlclByZWZldGNoSGFuZGxlcignbW1hTW9kUmVzb3VyY2UnLCAncmVzb3VyY2UnLCAnJG1tYU1vZFJlc291cmNlUHJlZmV0Y2hIYW5kbGVyJyk7XG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFNb2RSZXNvdXJjZScsICckbW1hTW9kUmVzb3VyY2VIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3Njb3JtJywgWydtbS5jb3JlJ10pXG5cbi5jb25zdGFudCgnbW1hTW9kU2Nvcm1Db21wb25lbnQnLCAnbW1hTW9kU2Nvcm0nKVxuLmNvbnN0YW50KCdtbWFNb2RTY29ybUV2ZW50TGF1bmNoTmV4dFNjbycsICdtbWFfbW9kX3Njb3JtX2xhdW5jaF9uZXh0X3NjbycpXG4uY29uc3RhbnQoJ21tYU1vZFNjb3JtRXZlbnRMYXVuY2hQcmV2U2NvJywgJ21tYV9tb2Rfc2Nvcm1fbGF1bmNoX3ByZXZfc2NvJylcbi5jb25zdGFudCgnbW1hTW9kU2Nvcm1FdmVudFVwZGF0ZVRvYycsICdtbWFfbW9kX3Njb3JtX3VwZGF0ZV90b2MnKVxuLmNvbnN0YW50KCdtbWFNb2RTY29ybUV2ZW50R29PZmZsaW5lJywgJ21tYV9tb2Rfc2Nvcm1fZ29fb2ZmbGluZScpXG4uY29uc3RhbnQoJ21tYU1vZFNjb3JtRXZlbnRBdXRvbVN5bmNlZCcsICdtbWFfbW9kX3Njb3JtX2F1dG9tX3N5bmNlZCcpXG4uY29uc3RhbnQoJ21tYU1vZFNjb3JtU3luY1RpbWUnLCAyMDAwMDApIC8vIEluIG1pbGxpc2Vjb25kcy5cblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2Rfc2Nvcm0nLCB7XG4gICAgICB1cmw6ICcvbW9kX3Njb3JtJyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgIGNvdXJzZWlkOiBudWxsXG4gICAgICB9LFxuICAgICAgdmlld3M6IHtcbiAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZFNjb3JtSW5kZXhDdHJsJyxcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2Rfc2Nvcm0vdGVtcGxhdGVzL2luZGV4Lmh0bWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9zY29ybS1wbGF5ZXInLCB7XG4gICAgICB1cmw6ICcvbW9kX3Njb3JtLXBsYXllcicsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgc2Nvcm06IG51bGwsXG4gICAgICAgIG1vZGU6IG51bGwsXG4gICAgICAgIG5ld0F0dGVtcHQ6IGZhbHNlLFxuICAgICAgICBvcmdhbml6YXRpb25JZDogbnVsbCxcbiAgICAgICAgc2NvSWQ6IG51bGxcbiAgICAgIH0sXG4gICAgICB2aWV3czoge1xuICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kU2Nvcm1QbGF5ZXJDdHJsJyxcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2Rfc2Nvcm0vdGVtcGxhdGVzL3BsYXllci5odG1sJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RTY29ybScsICdzY29ybScsICckbW1hTW9kU2Nvcm1IYW5kbGVycy5jb3Vyc2VDb250ZW50Jyk7XG4gICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJlZmV0Y2hIYW5kbGVyKCdtbWFNb2RTY29ybScsICdzY29ybScsICckbW1hTW9kU2Nvcm1QcmVmZXRjaEhhbmRsZXInKTtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZFNjb3JtJywgJyRtbWFNb2RTY29ybUhhbmRsZXJzLmxpbmtzSGFuZGxlcicpO1xufSlcblxuLnJ1bihmdW5jdGlvbigkdGltZW91dCwgJG1tYU1vZFNjb3JtU3luYywgJG1tQXBwLCAkbW1FdmVudHMsICRtbVNpdGUsIG1tQ29yZUV2ZW50TG9naW4pIHtcbiAgICB2YXIgbGFzdEV4ZWN1dGlvbiA9IDAsXG4gICAgICAgIGV4ZWN1dGluZyA9IGZhbHNlLFxuICAgICAgICBhbGxTaXRlc0NhbGxlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gc3luY1Njb3JtcyhhbGxTaXRlcykge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgaWYgKCFhbGxTaXRlcyAmJiAhJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXZlbnQgY29uc2VjdXRpdmUgYW5kIHNpbXVsdGFuZW91cyBleGVjdXRpb25zLiBBIHN5bmMgcHJvY2VzcyBzaG91bGRuJ3QgdGFrZSBtb3JlIHRoYW4gYSBmZXcgbWludXRlcyxcbiAgICAgICAgLy8gc28gaWYgaXQncyBiZWVuIG1vcmUgdGhhbiA1IG1pbnV0ZXMgc2luY2UgdGhlIGxhc3QgZXhlY3V0aW9uIHdlJ2xsIGlnbm9yZSB0aGUgZXhlY3V0aW5nIHZhbHVlLlxuICAgICAgICBpZiAobm93IC0gNTAwMCA+IGxhc3RFeGVjdXRpb24gJiYgKCFleGVjdXRpbmcgfHwgbm93IC0gMzAwMDAwID4gbGFzdEV4ZWN1dGlvbikpIHtcbiAgICAgICAgICAgIGxhc3RFeGVjdXRpb24gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGV4ZWN1dGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkgeyAvLyBNaW5vciBkZWxheSBqdXN0IHRvIG1ha2Ugc3VyZSBuZXR3b3JrIGlzIGZ1bGx5IGVzdGFibGlzaGVkLlxuICAgICAgICAgICAgICAgICRtbWFNb2RTY29ybVN5bmMuc3luY0FsbFNjb3JtcyhhbGxTaXRlcyA/IHVuZGVmaW5lZCA6ICRtbVNpdGUuZ2V0SWQoKSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICRtbUFwcC5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3luY1Njb3JtcyhmYWxzZSk7XG4gICAgICAgIH0sIGZhbHNlKTsgLy8gQ29yZG92YSBldmVudC5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3luY1Njb3JtcyhmYWxzZSk7XG4gICAgICAgIH0sIGZhbHNlKTsgLy8gSFRNTDUgZXZlbnQuXG5cbiAgICAgICAgaWYgKCEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgLy8gQXBwIHdhcyBzdGFydGVkIHdpdGhvdXQgYW55IHNpdGUgbG9nZ2VkIGluLiBUcnkgdG8gc3luYyBhbGwgc2l0ZXMuXG4gICAgICAgICAgICBhbGxTaXRlc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICBzeW5jU2Nvcm1zKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRMb2dpbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbGxTaXRlcyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWFsbFNpdGVzQ2FsbGVkKSB7XG4gICAgICAgICAgICAvLyBBcHAgc3RhcnRlZCB3aXRoIGEgc2l0ZSBsb2dnZWQgaW4uIFRyeSB0byBzeW5jIGFsbCBzaXRlcy5cbiAgICAgICAgICAgIGFsbFNpdGVzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGFsbFNpdGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgc3luY1Njb3JtcyhhbGxTaXRlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2Rfc3VydmV5JywgW10pXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX3N1cnZleScsIHtcbiAgICAgICAgdXJsOiAnL21vZF9zdXJ2ZXknLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogbnVsbCxcbiAgICAgICAgICAgIGNvdXJzZWlkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kU3VydmV5SW5kZXhDdHJsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2Rfc3VydmV5L3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuICAgICRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJDb250ZW50SGFuZGxlcignbW1hTW9kU3VydmV5JywgJ3N1cnZleScsICckbW1hTW9kU3VydmV5SGFuZGxlcnMuY291cnNlQ29udGVudCcpO1xuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hTW9kU3VydmV5JywgJyRtbWFNb2RTdXJ2ZXlIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3VybCcsIFsnbW0uY29yZSddKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF91cmwnLCB7XG4gICAgICB1cmw6ICcvbW9kX3VybCcsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICBjb3Vyc2VpZDogbnVsbFxuICAgICAgfSxcbiAgICAgIHZpZXdzOiB7XG4gICAgICAgICdzaXRlJzoge1xuICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RVcmxJbmRleEN0cmwnLFxuICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF91cmwvdGVtcGxhdGVzL2luZGV4Lmh0bWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RVcmwnLCAndXJsJywgJyRtbWFNb2RVcmxIYW5kbGVycy5jb3Vyc2VDb250ZW50SGFuZGxlcicpO1xuXG4gICAgLy8gUmVnaXN0ZXIgY29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hTW9kVXJsJywgJyRtbWFNb2RVcmxIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubm90ZXMnLCBbXSlcblxuLmNvbnN0YW50KCdtbWFOb3Rlc1ByaW9yaXR5JywgMjAwKVxuLmNvbnN0YW50KCdtbWFOb3Rlc0FkZE5vdGVQcmlvcml0eScsIDIwMClcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJG1tVXNlckRlbGVnYXRlUHJvdmlkZXIsICRtbUNvdXJzZXNEZWxlZ2F0ZVByb3ZpZGVyLCBtbWFOb3Rlc1ByaW9yaXR5LCBtbWFOb3Rlc0FkZE5vdGVQcmlvcml0eSkge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5ub3Rlcy10eXBlcycsIHtcbiAgICAgICAgdXJsOiAnL25vdGVzLXR5cGVzJyxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL25vdGVzL3RlbXBsYXRlcy90eXBlcy5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTm90ZXNUeXBlc0N0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgY291cnNlOiBudWxsXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm5vdGVzLWxpc3QnLCB7XG4gICAgICAgIHVybDogJy9ub3Rlcy1saXN0JyxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL25vdGVzL3RlbXBsYXRlcy9saXN0Lmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFOb3Rlc0xpc3RDdHJsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGNvdXJzZWlkOiBudWxsLFxuICAgICAgICAgICAgdHlwZTogbnVsbFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWdpc3RlciBwbHVnaW4gb24gdXNlciBwcm9maWxlLlxuICAgICRtbVVzZXJEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJvZmlsZUhhbmRsZXIoJ21tYU5vdGVzOmFkZE5vdGUnLCAnJG1tYU5vdGVzSGFuZGxlcnMuYWRkTm90ZScsIG1tYU5vdGVzQWRkTm90ZVByaW9yaXR5KTtcblxuICAgIC8vIFJlZ2lzdGVyIGNvdXJzZXMgaGFuZGxlci5cbiAgICAkbW1Db3Vyc2VzRGVsZWdhdGVQcm92aWRlci5yZWdpc3Rlck5hdkhhbmRsZXIoJ21tYU5vdGVzJywgJyRtbWFOb3Rlc0hhbmRsZXJzLmNvdXJzZXNOYXYnLCBtbWFOb3Rlc1ByaW9yaXR5KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubm90aWZpY2F0aW9ucycsIFtdKVxuXG4uY29uc3RhbnQoJ21tYU5vdGlmaWNhdGlvbnNMaXN0TGltaXQnLCAyMCkgLy8gTWF4IG9mIG5vdGlmaWNhdGlvbnMgdG8gcmV0cmlldmUgaW4gZWFjaCBXUyBjYWxsLlxuLmNvbnN0YW50KCdtbWFOb3RpZmljYXRpb25zUHJpb3JpdHknLCA4MDApXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlciwgbW1hTm90aWZpY2F0aW9uc1ByaW9yaXR5KSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm5vdGlmaWNhdGlvbnMnLCB7XG4gICAgICAgIHVybDogJy9ub3RpZmljYXRpb25zJyxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL25vdGlmaWNhdGlvbnMvdGVtcGxhdGVzL2xpc3QuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU5vdGlmaWNhdGlvbnNMaXN0Q3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgc2lkZSBtZW51IGFkZG9uLlxuICAgICRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlci5yZWdpc3Rlck5hdkhhbmRsZXIoJ21tYU5vdGlmaWNhdGlvbnMnLCAnJG1tYU5vdGlmaWNhdGlvbnNIYW5kbGVycy5zaWRlTWVudU5hdicsIG1tYU5vdGlmaWNhdGlvbnNQcmlvcml0eSk7XG59KVxuXG4ucnVuKGZ1bmN0aW9uKCRsb2csICRtbWFOb3RpZmljYXRpb25zLCAkbW1VdGlsLCAkc3RhdGUsICRtbUFkZG9uTWFuYWdlcikge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbWFOb3RpZmljYXRpb25zJyk7XG5cbiAgICAvLyBSZWdpc3RlciBwdXNoIG5vdGlmaWNhdGlvbiBjbGlja3MuXG4gICAgdmFyICRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUgPSAkbW1BZGRvbk1hbmFnZXIuZ2V0KCckbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlJyk7XG4gICAgaWYgKCRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUpIHtcbiAgICAgICAgJG1tUHVzaE5vdGlmaWNhdGlvbnNEZWxlZ2F0ZS5yZWdpc3RlckhhbmRsZXIoJ21tYU5vdGlmaWNhdGlvbnMnLCBmdW5jdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgIGlmICgkbW1VdGlsLmlzVHJ1ZU9yT25lKG5vdGlmaWNhdGlvbi5ub3RpZikpIHtcbiAgICAgICAgICAgICAgICAkbW1hTm90aWZpY2F0aW9ucy5pc1BsdWdpbkVuYWJsZWRGb3JTaXRlKG5vdGlmaWNhdGlvbi5zaXRlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkbW1hTm90aWZpY2F0aW9ucy5pbnZhbGlkYXRlTm90aWZpY2F0aW9uc0xpc3QoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdyZWRpcmVjdCcsIHtzaXRlaWQ6IG5vdGlmaWNhdGlvbi5zaXRlLCBzdGF0ZTogJ3NpdGUubm90aWZpY2F0aW9ucyd9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMucGFydGljaXBhbnRzJywgW10pXG5cbi5jb25zdGFudCgnbW1hUGFydGljaXBhbnRzTGlzdExpbWl0JywgNTApIC8vIE1heCBvZiBwYXJ0aWNpcGFudHMgdG8gcmV0cmlldmUgaW4gZWFjaCBXUyBjYWxsLlxuLmNvbnN0YW50KCdtbWFQYXJ0aWNpcGFudHNQcmlvcml0eScsIDYwMClcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJG1tQ291cnNlc0RlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIsIG1tYVBhcnRpY2lwYW50c1ByaW9yaXR5KSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuICAgICAgICAuc3RhdGUoJ3NpdGUucGFydGljaXBhbnRzJywge1xuICAgICAgICAgICAgdXJsOiAnL3BhcnRpY2lwYW50cycsXG4gICAgICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hUGFydGljaXBhbnRzTGlzdEN0cmwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9wYXJ0aWNpcGFudHMvdGVtcGxhdGVzL2xpc3QuaHRtbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgY291cnNlOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgJG1tQ291cnNlc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJOYXZIYW5kbGVyKCdtbWFQYXJ0aWNpcGFudHMnLCAnJG1tYVBhcnRpY2lwYW50c0hhbmRsZXJzLmNvdXJzZXNOYXZIYW5kbGVyJyxcbiAgICAgICAgICAgICAgICBtbWFQYXJ0aWNpcGFudHNQcmlvcml0eSk7XG5cbiAgICAvLyBSZWdpc3RlciBjb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFQYXJ0aWNpcGFudHMnLCAnJG1tYVBhcnRpY2lwYW50c0hhbmRsZXJzLmxpbmtzSGFuZGxlcicpO1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLnB1c2hub3RpZmljYXRpb25zJywgW10pXG5cbi5jb25zdGFudCgnbW1hUHVzaE5vdGlmaWNhdGlvbnNDb21wb25lbnQnLCAnbW1hUHVzaE5vdGlmaWNhdGlvbnMnKVxuXG4ucnVuKGZ1bmN0aW9uKCRtbWFQdXNoTm90aWZpY2F0aW9ucywgJGlvbmljUGxhdGZvcm0sICRyb290U2NvcGUsICRtbUV2ZW50cywgJG1tTG9jYWxOb3RpZmljYXRpb25zLCBtbUNvcmVFdmVudExvZ2luLFxuICAgICAgICAgICAgbW1hUHVzaE5vdGlmaWNhdGlvbnNDb21wb25lbnQsIG1tQ29yZUV2ZW50U2l0ZURlbGV0ZWQpIHtcblxuICAgIC8vIFJlZ2lzdGVyIGRldmljZSBvbiBHQ00gb3IgQVBOUyBzZXJ2ZXIuXG4gICAgJGlvbmljUGxhdGZvcm0ucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFQdXNoTm90aWZpY2F0aW9ucy5yZWdpc3RlckRldmljZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gTm90aWZpY2F0aW9uIHJlY2VpdmVkLlxuICAgICRyb290U2NvcGUuJG9uKCckY29yZG92YVB1c2g6bm90aWZpY2F0aW9uUmVjZWl2ZWQnLCBmdW5jdGlvbihlLCBub3RpZmljYXRpb24pIHtcbiAgICAgICAgaWYgKGlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpKSB7XG4gICAgICAgICAgICAkbW1hUHVzaE5vdGlmaWNhdGlvbnMub25HQ01SZWNlaXZlZChub3RpZmljYXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGlvbmljLlBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgICAgICAgICRtbWFQdXNoTm90aWZpY2F0aW9ucy5vbk1lc3NhZ2VSZWNlaXZlZChub3RpZmljYXRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWdpc3RlciBkZXZpY2Ugb24gTW9vZGxlIHNpdGUgd2hlbiBsb2dpbi5cbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRMb2dpbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFQdXNoTm90aWZpY2F0aW9ucy5yZWdpc3RlckRldmljZU9uTW9vZGxlKCk7XG4gICAgfSk7XG5cbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRTaXRlRGVsZXRlZCwgZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAkbW1hUHVzaE5vdGlmaWNhdGlvbnMudW5yZWdpc3RlckRldmljZU9uTW9vZGxlKHNpdGUpO1xuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuIGZvciBsb2NhbCBub3RpZmljYXRpb24gY2xpY2tzIChnZW5lcmF0ZWQgYnkgdGhlIGFwcCkuXG4gICAgJG1tTG9jYWxOb3RpZmljYXRpb25zLnJlZ2lzdGVyQ2xpY2sobW1hUHVzaE5vdGlmaWNhdGlvbnNDb21wb25lbnQsICRtbWFQdXNoTm90aWZpY2F0aW9ucy5ub3RpZmljYXRpb25DbGlja2VkKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMucmVtb3Rlc3R5bGVzJywgW10pXG5cbi5jb25zdGFudCgnbW1hUmVtb3RlU3R5bGVzQ29tcG9uZW50JywgJ21tYVJlbW90ZVN0eWxlcycpXG5cbi5ydW4oZnVuY3Rpb24oJG1tRXZlbnRzLCBtbUNvcmVFdmVudExvZ2luLCBtbUNvcmVFdmVudExvZ291dCwgbW1Db3JlRXZlbnRTaXRlQWRkZWQsIG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsICRtbWFSZW1vdGVTdHlsZXMsXG4gICAgICAgICAgICAkbW1TaXRlKSB7XG5cbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRTaXRlQWRkZWQsICRtbWFSZW1vdGVTdHlsZXMubG9hZCk7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsIGZ1bmN0aW9uKHNpdGVpZCkge1xuICAgICAgICAvLyBMb2FkIG9ubHkgaWYgY3VycmVudCBzaXRlIHdhcyB1cGRhdGVkLlxuICAgICAgICBpZiAoc2l0ZWlkID09PSAkbW1TaXRlLmdldElkKCkpIHtcbiAgICAgICAgICAgICRtbWFSZW1vdGVTdHlsZXMubG9hZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9naW4sICRtbWFSZW1vdGVTdHlsZXMubG9hZCk7XG5cbiAgICAvLyBSZW1vdmUgYWRkZWQgc3R5bGVzIG9uIGxvZ291dC5cbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRMb2dvdXQsICRtbWFSZW1vdGVTdHlsZXMuY2xlYXIpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5jYWxlbmRhcicpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgYW4gZXZlbnQuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFDYWxlbmRhckV2ZW50Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hQ2FsZW5kYXJFdmVudEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRsb2csICRzdGF0ZVBhcmFtcywgJG1tYUNhbGVuZGFyLCAkbW1VdGlsLCAkbW1Db3Vyc2UsICRtbUNvdXJzZXMsXG4gICAgICAgICRtbUxvY2FsTm90aWZpY2F0aW9ucykge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tYUNhbGVuZGFyRXZlbnRDdHJsJyk7XG5cbiAgICB2YXIgZXZlbnRpZCA9IHBhcnNlSW50KCRzdGF0ZVBhcmFtcy5pZCk7XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0aGF0IGZldGNoZXMgdGhlIGV2ZW50IGFuZCB1cGRhdGVzIHRoZSBzY29wZS5cbiAgICBmdW5jdGlvbiBmZXRjaEV2ZW50KHJlZnJlc2gpIHtcbiAgICAgICAgcmV0dXJuICRtbWFDYWxlbmRhci5nZXRFdmVudChldmVudGlkLCByZWZyZXNoKS50aGVuKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICRtbWFDYWxlbmRhci5mb3JtYXRFdmVudERhdGEoZSk7XG4gICAgICAgICAgICAkc2NvcGUuZXZlbnQgPSBlO1xuICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gZS5uYW1lO1xuXG4gICAgICAgICAgICBpZiAoZS5tb2R1bGVpY29uKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIG1vZHVsZSBldmVudCwgdHJhbnNsYXRlIHRoZSBtb2R1bGUgbmFtZSB0byB0aGUgY3VycmVudCBsYW5ndWFnZS5cbiAgICAgICAgICAgICAgICAkbW1Db3Vyc2UudHJhbnNsYXRlTW9kdWxlTmFtZShlLm1vZHVsZW5hbWUpLnRoZW4oZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdtbS5jb3JlLm1vZCcpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tb2R1bGVuYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZS5jb3Vyc2VpZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgY291cnNlIGV2ZW50LCByZXRyaWV2ZSB0aGUgY291cnNlIG5hbWUuXG4gICAgICAgICAgICAgICAgJG1tQ291cnNlcy5nZXRVc2VyQ291cnNlKGUuY291cnNlaWQsIHRydWUpLnRoZW4oZnVuY3Rpb24oY291cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jb3Vyc2VuYW1lID0gY291cnNlLmZ1bGxuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLmNhbGVuZGFyLmVycm9ybG9hZGV2ZW50JywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdldCBldmVudC5cbiAgICBmZXRjaEV2ZW50KCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmV2ZW50TG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIFB1bGwgdG8gcmVmcmVzaC5cbiAgICAkc2NvcGUucmVmcmVzaEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZldGNoRXZlbnQodHJ1ZSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUubm90aWZpY2F0aW9uc0VuYWJsZWQgPSAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMuaXNBdmFpbGFibGUoKTtcbiAgICBpZiAoJHNjb3BlLm5vdGlmaWNhdGlvbnNFbmFibGVkKSB7XG5cbiAgICAgICAgJG1tYUNhbGVuZGFyLmdldEV2ZW50Tm90aWZpY2F0aW9uVGltZShldmVudGlkKS50aGVuKGZ1bmN0aW9uKG5vdGlmaWNhdGlvbnRpbWUpIHtcbiAgICAgICAgICAgICRzY29wZS5ub3RpZmljYXRpb24gPSB7IC8vIFVzZSBhbiBvYmplY3QsIG90aGVyd2lzZSBjaGFuZ2VzIGFyZSBub3QgcmVmbGVjdGVkLlxuICAgICAgICAgICAgICAgIHRpbWU6IFN0cmluZyhub3RpZmljYXRpb250aW1lKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHNjb3BlLnVwZGF0ZU5vdGlmaWNhdGlvblRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gcGFyc2VJbnQoJHNjb3BlLm5vdGlmaWNhdGlvbi50aW1lKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4odGltZSkgJiYgJHNjb3BlLmV2ZW50ICYmICRzY29wZS5ldmVudC5pZCkge1xuICAgICAgICAgICAgICAgICRtbWFDYWxlbmRhci51cGRhdGVOb3RpZmljYXRpb25UaW1lKCRzY29wZS5ldmVudCwgdGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5jYWxlbmRhcicpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgY2FsZW5kYXIgZXZlbnRzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLmNhbGVuZGFyXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hQ2FsZW5kYXJMaXN0Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hQ2FsZW5kYXJMaXN0Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbG9nLCAkc3RhdGUsICRtbWFDYWxlbmRhciwgJG1tVXRpbCwgJGlvbmljSGlzdG9yeSxcbiAgICAgICAgbW1hQ2FsZW5kYXJEYXlzSW50ZXJ2YWwpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbWFDYWxlbmRhckxpc3RDdHJsJyk7XG5cbiAgICB2YXIgZGF5c0xvYWRlZCxcbiAgICAgICAgZW1wdHlFdmVudHNUaW1lczsgLy8gVmFyaWFibGUgdG8gaWRlbnRpZnkgY29uc2VjdXRpdmUgY2FsbHMgcmV0dXJuaW5nIDAgZXZlbnRzLlxuXG4gICAgaWYgKCRzdGF0ZVBhcmFtcy5ldmVudGlkKSB7XG4gICAgICAgIC8vIFdlIGFycml2ZWQgaGVyZSB2aWEgbm90aWZpY2F0aW9uIGNsaWNrLCBsZXQncyBjbGVhciBoaXN0b3J5IGFuZCByZWRpcmVjdCB0byBldmVudCBkZXRhaWxzLlxuICAgICAgICAkaW9uaWNIaXN0b3J5LmNsZWFySGlzdG9yeSgpO1xuICAgICAgICAkc3RhdGUuZ28oJ3NpdGUuY2FsZW5kYXItZXZlbnQnLCB7aWQ6ICRzdGF0ZVBhcmFtcy5ldmVudGlkfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSB2YXJpYWJsZXMuXG4gICAgZnVuY3Rpb24gaW5pdFZhcnMoKSB7XG4gICAgICAgIGRheXNMb2FkZWQgPSAwO1xuICAgICAgICBlbXB0eUV2ZW50c1RpbWVzID0gMDtcbiAgICAgICAgJHNjb3BlLmV2ZW50cyA9IFtdO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyB0aGUgZXZlbnRzIGFuZCB1cGRhdGVzIHRoZSBzY29wZS5cbiAgICBmdW5jdGlvbiBmZXRjaEV2ZW50cyhyZWZyZXNoKSB7XG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICBpbml0VmFycygpO1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IGZhbHNlOyAvLyBTZXQgaXQgdG8gZmFsc2UgdG8gcHJldmVudCBjb25zZWN1dGl2ZSBjYWxscy5cblxuICAgICAgICByZXR1cm4gJG1tYUNhbGVuZGFyLmdldEV2ZW50cyhkYXlzTG9hZGVkLCBtbWFDYWxlbmRhckRheXNJbnRlcnZhbCwgcmVmcmVzaCkudGhlbihmdW5jdGlvbihldmVudHMpIHtcbiAgICAgICAgICAgIGRheXNMb2FkZWQgKz0gbW1hQ2FsZW5kYXJEYXlzSW50ZXJ2YWw7XG5cbiAgICAgICAgICAgIGlmIChldmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZW1wdHlFdmVudHNUaW1lcysrO1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eUV2ZW50c1RpbWVzID4gNSkgeyAvLyBTdG9wIGV4ZWN1dGlvbiBpZiB3ZSByZXRyaWV2ZSBlbXB0eSBsaXN0IDYgY29uc2VjdXRpdmUgdGltZXMuXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZXZlbnRzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBldmVudHMgcmV0dXJuZWQsIGxvYWQgbmV4dCBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaEV2ZW50cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGV2ZW50cywgJG1tYUNhbGVuZGFyLmZvcm1hdEV2ZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmV2ZW50cyA9IGV2ZW50cztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZXZlbnRzID0gJHNjb3BlLmV2ZW50cy5jb25jYXQoZXZlbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNvdW50ID0gJHNjb3BlLmV2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmV2ZW50c0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNhbkxvYWRNb3JlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSBldmVudHMgcmV0cmlldmVkIChtaWdodCBoYXZlIG5ldyBldmVudHMpLlxuICAgICAgICAgICAgICAgICRtbWFDYWxlbmRhci5zY2hlZHVsZUV2ZW50c05vdGlmaWNhdGlvbnMoZXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEuY2FsZW5kYXIuZXJyb3Jsb2FkZXZlbnRzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuZXZlbnRzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW5pdFZhcnMoKTtcbiAgICAkc2NvcGUuY291bnQgPSAwO1xuXG4gICAgLy8gR2V0IGZpcnN0IGV2ZW50cy5cbiAgICBmZXRjaEV2ZW50cygpO1xuXG4gICAgLy8gTG9hZCBtb3JlIGV2ZW50cy5cbiAgICAkc2NvcGUubG9hZE1vcmVFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmV0Y2hFdmVudHMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5pbmZpbml0ZVNjcm9sbENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBQdWxsIHRvIHJlZnJlc2guXG4gICAgJHNjb3BlLnJlZnJlc2hFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYUNhbGVuZGFyLmludmFsaWRhdGVFdmVudHNMaXN0KCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZldGNoRXZlbnRzKHRydWUpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5jYWxlbmRhcicpXG5cbi5jb25zdGFudCgnbW1hQ2FsZW5kYXJFdmVudHNTdG9yZScsICdjYWxlbmRhcl9ldmVudHMnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbVNpdGVzRmFjdG9yeVByb3ZpZGVyLCBtbWFDYWxlbmRhckV2ZW50c1N0b3JlKSB7XG4gICAgdmFyIHN0b3JlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogbW1hQ2FsZW5kYXJFdmVudHNTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCcsXG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbm90aWZpY2F0aW9udGltZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICBdO1xuICAgICRtbVNpdGVzRmFjdG9yeVByb3ZpZGVyLnJlZ2lzdGVyU3RvcmVzKHN0b3Jlcyk7XG59KVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gaGFuZGxlIGNhbGVuZGFyIGV2ZW50cy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFDYWxlbmRhclxuICovXG4uZmFjdG9yeSgnJG1tYUNhbGVuZGFyJywgZnVuY3Rpb24oJGxvZywgJHEsICRtbVNpdGUsICRtbVV0aWwsICRtbUNvdXJzZXMsICRtbUdyb3VwcywgJG1tQ291cnNlLCAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICRtbVNpdGVzTWFuYWdlciwgbW1Db3JlU2Vjb25kc0RheSwgbW1hQ2FsZW5kYXJEYXlzSW50ZXJ2YWwsIG1tYUNhbGVuZGFyRXZlbnRzU3RvcmUsIG1tYUNhbGVuZGFyRGVmYXVsdE5vdGlmVGltZSxcbiAgICAgICAgbW1hQ2FsZW5kYXJDb21wb25lbnQpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hQ2FsZW5kYXInKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGNhbGVuZGFySW1nUGF0aCA9ICdhZGRvbnMvY2FsZW5kYXIvaW1nLycsXG4gICAgICAgIGV2ZW50aWNvbnMgPSB7XG4gICAgICAgICAgICAnY291cnNlJzogY2FsZW5kYXJJbWdQYXRoICsgJ2NvdXJzZWV2ZW50LnN2ZycsXG4gICAgICAgICAgICAnZ3JvdXAnOiBjYWxlbmRhckltZ1BhdGggKyAnZ3JvdXBldmVudC5zdmcnLFxuICAgICAgICAgICAgJ3NpdGUnOiBjYWxlbmRhckltZ1BhdGggKyAnc2l0ZWV2ZW50LnN2ZycsXG4gICAgICAgICAgICAndXNlcic6IGNhbGVuZGFySW1nUGF0aCArICd1c2VyZXZlbnQuc3ZnJ1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZXZlbnRzIGxpc3QgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF5c1RvU3RhcnQgIE51bWJlciBvZiBkYXlzIGZyb20gbm93IHRvIHN0YXJ0IGdldHRpbmcgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXlzSW50ZXJ2YWwgTnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aW1lc3RhcnQgYW5kIHRpbWVlbmQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRzTGlzdENhY2hlS2V5KGRheXNUb1N0YXJ0LCBkYXlzSW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuICdtbWFDYWxlbmRhcjpldmVudHM6JyArIGRheXNUb1N0YXJ0ICsgJzonICsgZGF5c0ludGVydmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGEgc2luZ2xlIGV2ZW50IFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgRXZlbnQgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRDYWNoZUtleShpZCkge1xuICAgICAgICByZXR1cm4gJ21tYUNhbGVuZGFyOmV2ZW50czonICsgaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb21tb24gcGFydCBvZiB0aGUgY2FjaGUga2V5cyBmb3IgZXZlbnRzIFdTIGNhbGxzLiBJbnZhbGlkYXRlIHRoZSB3aG9sZSBsaXN0IGFsc28gaW52YWxpZGF0ZXMgYWxsIHRoZVxuICAgICAqIHNpbmdsZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFdmVudHNDb21tb25DYWNoZUtleSgpIHtcbiAgICAgICAgcmV0dXJuICdtbWFDYWxlbmRhcjpldmVudHM6JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSBldmVudHMgaW4gbG9jYWwgREIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBldmVudHMgIEV2ZW50cyB0byBzdG9yZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlaWRdIElEIG9mIHRoZSBzaXRlIHRoZSBldmVudCBiZWxvbmdzIHRvLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZXZlbnRzIGFyZSBzdG9yZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmVFdmVudHNJbkxvY2FsREIoZXZlbnRzLCBzaXRlaWQpIHtcbiAgICAgICAgc2l0ZWlkID0gc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGRiID0gc2l0ZS5nZXREYigpO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZXZlbnQgbm90aWZpY2F0aW9uIHRpbWUgdG8gcHJldmVudCBvdmVycmlkaW5nIGl0IGluIERCLlxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gc2VsZi5nZXRFdmVudE5vdGlmaWNhdGlvblRpbWUoZXZlbnQuaWQsIHNpdGVpZCkudGhlbihmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lm5vdGlmaWNhdGlvbnRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KG1tYUNhbGVuZGFyRXZlbnRzU3RvcmUsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBmb3JtYXQgc29tZSBldmVudCBkYXRhIHRvIGJlIHJlbmRlcmVkLiBBZGRzIHByb3BlcnRpZXMgJ3N0YXJ0JywgJ2VuZCcsICdpY29uJ1xuICAgICAqIGFuZCAoaWYgaXQncyBhIG1vZHVsZSBldmVudCkgJ21vZHVsZWljb24nLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFyI2Zvcm1hdEV2ZW50RGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIEV2ZW50IHRvIGZvcm1hdC5cbiAgICAgKi9cbiAgICBzZWxmLmZvcm1hdEV2ZW50RGF0YSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGljb24gPSBzZWxmLmdldEV2ZW50SWNvbihlLmV2ZW50dHlwZSk7XG4gICAgICAgIGlmIChpY29uID09PSAnJykge1xuICAgICAgICAgICAgLy8gSXQncyBhIG1vZHVsZSBldmVudC5cbiAgICAgICAgICAgIGljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYyhlLm1vZHVsZW5hbWUpO1xuICAgICAgICAgICAgZS5tb2R1bGVpY29uID0gaWNvbjtcbiAgICAgICAgfVxuICAgICAgICBlLmljb24gPSBpY29uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBjYWxlbmRhciBldmVudCBmcm9tIHNlcnZlciBvciBjYWNoZS4gSWYgdGhlIHNlcnZlciByZXF1ZXN0IGZhaWxzIGFuZCBkYXRhIGlzIG5vdCBjYWNoZWQsXG4gICAgICogdHJ5IHRvIGdldCBpdCBmcm9tIGxvY2FsIERCLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFyI2dldEV2ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICBpZCAgICAgICAgRXZlbnQgSUQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVmcmVzaF0gVHJ1ZSB3aGVuIHdlIHNob3VsZCB1cGRhdGUgdGhlIGV2ZW50IGRhdGEuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBldmVudCBkYXRhIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEV2ZW50ID0gZnVuY3Rpb24oaWQsIHJlZnJlc2gpIHtcbiAgICAgICAgdmFyIHByZXNldHMgPSB7fSxcbiAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgXCJvcHRpb25zW3VzZXJldmVudHNdXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zW3NpdGVldmVudHNdXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJldmVudHNbZXZlbnRpZHNdWzBdXCI6IGlkXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHByZXNldHMuY2FjaGVLZXkgPSBnZXRFdmVudENhY2hlS2V5KGlkKTtcbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgIHByZXNldHMuZ2V0RnJvbUNhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnY29yZV9jYWxlbmRhcl9nZXRfY2FsZW5kYXJfZXZlbnRzJywgZGF0YSwgcHJlc2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGUgPSByZXNwb25zZS5ldmVudHNbMF07XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRFdmVudEZyb21Mb2NhbERiKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRFdmVudEZyb21Mb2NhbERiKGlkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGNhbGVuZGFyIGV2ZW50IGZyb20gbG9jYWwgRGIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ2FsZW5kYXIjZ2V0RXZlbnRGcm9tTG9jYWxEYlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgaWQgRXZlbnQgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGV2ZW50IGRhdGEgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RXZlbnRGcm9tTG9jYWxEYiA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIC8vIE5vdCBsb2dnZWQgaW4sIHdlIGNhbid0IGdldCB0aGUgc2l0ZSBEQi4gVXNlciBsb2dnZWQgb3V0IG9yIHNlc3Npb24gZXhwaXJlZCB3aGlsZSBhbiBvcGVyYXRpb24gd2FzIG9uZ29pbmcuXG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRtbVNpdGUuZ2V0RGIoKS5nZXQobW1hQ2FsZW5kYXJFdmVudHNTdG9yZSwgaWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXZlbnQgaWNvbiBuYW1lIGJhc2VkIG9uIGV2ZW50IHR5cGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ2FsZW5kYXIjZ2V0RXZlbnRJY29uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgIEV2ZW50IGljb24gbmFtZS4gSWYgdHlwZSBub3QgdmFsaWQsIHJldHVybiBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgc2VsZi5nZXRFdmVudEljb24gPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiBldmVudGljb25zW3R5cGVdIHx8ICcnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXZlbnQgbm90aWZpY2F0aW9uIHRpbWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ2FsZW5kYXIjZ2V0RXZlbnROb3RpZmljYXRpb25UaW1lXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAgICAgICBFdmVudCBJRC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlaWRdIElEIG9mIHRoZSBzaXRlIHRoZSBldmVudCBiZWxvbmdzIHRvLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIEV2ZW50IGljb24gbmFtZS4gSWYgdHlwZSBub3QgdmFsaWQsIHJldHVybiBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgc2VsZi5nZXRFdmVudE5vdGlmaWNhdGlvblRpbWUgPSBmdW5jdGlvbihpZCwgc2l0ZWlkKSB7XG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBzaXRlLmdldERiKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBkYi5nZXQobW1hQ2FsZW5kYXJFdmVudHNTdG9yZSwgaWQpLnRoZW4oZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5ub3RpZmljYXRpb250aW1lICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLm5vdGlmaWNhdGlvbnRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtbWFDYWxlbmRhckRlZmF1bHROb3RpZlRpbWU7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW1hQ2FsZW5kYXJEZWZhdWx0Tm90aWZUaW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FsZW5kYXIgZXZlbnRzIGluIGEgY2VydGFpbiBwZXJpb2QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ2FsZW5kYXIjZ2V0RXZlbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXlzVG9TdGFydD0wXSAgIE51bWJlciBvZiBkYXlzIGZyb20gbm93IHRvIHN0YXJ0IGdldHRpbmcgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF5c0ludGVydmFsPTMwXSBOdW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRpbWVzdGFydCBhbmQgdGltZWVuZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWZyZXNoXSAgICAgICAgVHJ1ZSB3aGVuIHdlIHNob3VsZCBub3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVpZF0gICAgICAgICAgU2l0ZSB0byBnZXQgdGhlIGV2ZW50cyBmcm9tLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBwYXJ0aWNpcGFudHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBHZXQgdGhlIGV2ZW50cyBpbiBhIGNlcnRhaW4gcGVyaW9kLiBUaGUgcGVyaW9kIGlzIGNhbGN1bGF0ZWQgbGlrZSB0aGlzOlxuICAgICAqICAgICBzdGFydCB0aW1lOiBub3cgKyBkYXlzVG9TdGFydFxuICAgICAqICAgICBlbmQgdGltZTogc3RhcnQgdGltZSArIGRheXNJbnRlcnZhbFxuICAgICAqIEUuZy4gdXNpbmcgJG1tYUNhbGVuZGFyLmdldEV2ZW50cygzMCwgMzApIGlzIGdvaW5nIHRvIGdldCB0aGUgZXZlbnRzIHN0YXJ0aW5nIGFmdGVyIDMwIGRheXMgZnJvbSBub3dcbiAgICAgKiBhbmQgZW5kaW5nIGJlZm9yZSA2MCBkYXlzIGZyb20gbm93LlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RXZlbnRzID0gZnVuY3Rpb24oZGF5c1RvU3RhcnQsIGRheXNJbnRlcnZhbCwgcmVmcmVzaCwgc2l0ZWlkKSB7XG4gICAgICAgIGRheXNUb1N0YXJ0ID0gZGF5c1RvU3RhcnQgfHwgMDtcbiAgICAgICAgZGF5c0ludGVydmFsID0gZGF5c0ludGVydmFsIHx8IG1tYUNhbGVuZGFyRGF5c0ludGVydmFsO1xuICAgICAgICBzaXRlaWQgPSBzaXRlaWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgICB2YXIgbm93ID0gJG1tVXRpbC50aW1lc3RhbXAoKSxcbiAgICAgICAgICAgIHN0YXJ0ID0gbm93ICsgKG1tQ29yZVNlY29uZHNEYXkgKiBkYXlzVG9TdGFydCksXG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIChtbUNvcmVTZWNvbmRzRGF5ICogZGF5c0ludGVydmFsKTtcblxuICAgICAgICAvLyBUaGUgY29yZV9jYWxlbmRhcl9nZXRfY2FsZW5kYXJfZXZlbnRzIG5lZWRzIGFsbCB0aGUgY3VycmVudCB1c2VyIGNvdXJzZXMgYW5kIGdyb3Vwcy5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBcIm9wdGlvbnNbdXNlcmV2ZW50c11cIjogMSxcbiAgICAgICAgICAgIFwib3B0aW9uc1tzaXRlZXZlbnRzXVwiOiAxLFxuICAgICAgICAgICAgXCJvcHRpb25zW3RpbWVzdGFydF1cIjogc3RhcnQsXG4gICAgICAgICAgICBcIm9wdGlvbnNbdGltZWVuZF1cIjogZW5kXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbUNvdXJzZXMuZ2V0VXNlckNvdXJzZXMoZmFsc2UsIHNpdGVpZCkudGhlbihmdW5jdGlvbihjb3Vyc2VzKSB7XG4gICAgICAgICAgICBjb3Vyc2VzLnB1c2goe2lkOiAxfSk7IC8vIEFkZCBmcm9udCBwYWdlLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvdXJzZXMsIGZ1bmN0aW9uKGNvdXJzZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBkYXRhW1wiZXZlbnRzW2NvdXJzZWlkc11bXCIgKyBpbmRleCArIFwiXVwiXSA9IGNvdXJzZS5pZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJG1tR3JvdXBzLmdldFVzZXJHcm91cHMoY291cnNlcywgcmVmcmVzaCwgc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKGdyb3Vwcykge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChncm91cHMsIGZ1bmN0aW9uKGdyb3VwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW1wiZXZlbnRzW2dyb3VwaWRzXVtcIiArIGluZGV4ICsgXCJdXCJdID0gZ3JvdXAuaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJldHJpZXZlIGNhY2hlZCBkYXRhIHVzaW5nIGNhY2hlIGtleSBiZWNhdXNlIHdlIGhhdmUgdGltZXN0YW1wIGluIHRoZSBwYXJhbXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldEV2ZW50c0xpc3RDYWNoZUtleShkYXlzVG9TdGFydCwgZGF5c0ludGVydmFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENhY2hlVXNpbmdDYWNoZUtleTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l0ZS5yZWFkKCdjb3JlX2NhbGVuZGFyX2dldF9jYWxlbmRhcl9ldmVudHMnLCBkYXRhLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZUV2ZW50c0luTG9jYWxEQihyZXNwb25zZS5ldmVudHMsIHNpdGVpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBldmVudHMgbGlzdCBhbmQgYWxsIHRoZSBzaW5nbGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFyI2ludmFsaWRhdGVFdmVudHNMaXN0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBsaXN0IGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUV2ZW50c0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAxID0gJG1tQ291cnNlcy5pbnZhbGlkYXRlVXNlckNvdXJzZXMoKSxcbiAgICAgICAgICAgIHAyID0gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleVN0YXJ0aW5nV2l0aChnZXRFdmVudHNDb21tb25DYWNoZUtleSgpKTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChbcDEsIHAyXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNhbGVuZGFyIGV2ZW50cyBXUyBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ2FsZW5kYXIjaXNBdmFpbGFibGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGNhbGVuZGFyIGV2ZW50cyBXUyBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX2NhbGVuZGFyX2dldF9jYWxlbmRhcl9ldmVudHMnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IGV2ZW50cyBmb3IgYWxsIHRoZSBzaXRlcyBhbmQgc2NoZWR1bGVzIHRoZWlyIG5vdGlmaWNhdGlvbnMuXG4gICAgICogSWYgYW4gZXZlbnQgbm90aWZpY2F0aW9uIHRpbWUgaXMgMCwgY2FuY2VsIGl0cyBzY2hlZHVsZWQgbm90aWZpY2F0aW9uIChpZiBhbnkpLlxuICAgICAqIElmIGxvY2FsIG5vdGlmaWNhdGlvbiBwbHVnaW4gaXMgbm90IGVuYWJsZWQsIHJlc29sdmUgdGhlIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ2FsZW5kYXIjc2NoZWR1bGVBbGxTaXRlc0V2ZW50c05vdGlmaWNhdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gZXZlbnRzIEV2ZW50cyB0byBzY2hlZHVsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgdGhlIG5vdGlmaWNhdGlvbnMgaGF2ZSBiZWVuIHNjaGVkdWxlZC5cbiAgICAgKi9cbiAgICBzZWxmLnNjaGVkdWxlQWxsU2l0ZXNFdmVudHNOb3RpZmljYXRpb25zID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCRtbUxvY2FsTm90aWZpY2F0aW9ucy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGVzSWRzKCkudGhlbihmdW5jdGlvbihzaXRlaWRzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2l0ZWlkcywgZnVuY3Rpb24oc2l0ZWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBmaXJzdCBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gc2VsZi5nZXRFdmVudHModW5kZWZpbmVkLCB1bmRlZmluZWQsIGZhbHNlLCBzaXRlaWQpLnRoZW4oZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zY2hlZHVsZUV2ZW50c05vdGlmaWNhdGlvbnMoZXZlbnRzLCBzaXRlaWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGV2ZW50IG5vdGlmaWNhdGlvbi4gSWYgdGltZSBpcyAwLCBjYW5jZWwgc2NoZWR1bGVkIG5vdGlmaWNhdGlvbiBpZiBhbnkuXG4gICAgICogSWYgbG9jYWwgbm90aWZpY2F0aW9uIHBsdWdpbiBpcyBub3QgZW5hYmxlZCwgcmVzb2x2ZSB0aGUgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNhbGVuZGFyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDYWxlbmRhciNzY2hlZHVsZUV2ZW50Tm90aWZpY2F0aW9uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBldmVudCAgICBFdmVudCB0byBzY2hlZHVsZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgICAgIE5vdGlmaWNhdGlvbiBzZXR0aW5nIHRpbWUgKGluIG1pbnV0ZXMpLiBFLmcuIDEwIG1lYW5zIFwibm90aWZpY2F0ZSAxMCBtaW51dGVzIGJlZm9yZSBzdGFydFwiLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVpZF0gU2l0ZSBJRCB0aGUgZXZlbnQgYmVsb25ncyB0by4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBub3RpZmljYXRpb24gaXMgc2NoZWR1bGVkLlxuICAgICAqL1xuICAgIHNlbGYuc2NoZWR1bGVFdmVudE5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCB0aW1lLCBzaXRlaWQpIHtcbiAgICAgICAgc2l0ZWlkID0gc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICBpZiAoJG1tTG9jYWxOb3RpZmljYXRpb25zLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIGlmICh0aW1lID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUxvY2FsTm90aWZpY2F0aW9ucy5jYW5jZWwoZXZlbnQuaWQsIG1tYUNhbGVuZGFyQ29tcG9uZW50LCBzaXRlaWQpOyAvLyBDYW5jZWwgaWYgaXQgd2FzIHNjaGVkdWxlZC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVlbmQgPSAoZXZlbnQudGltZXN0YXJ0ICsgZXZlbnQudGltZWR1cmF0aW9uKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVlbmQgPD0gbmV3IERhdGUoKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV2ZW50IGhhcyBmaW5pc2hlZCBhbHJlYWR5LCBkb24ndCBzY2hlZHVsZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGF0ZVRyaWdnZXJlZCA9IG5ldyBEYXRlKChldmVudC50aW1lc3RhcnQgLSAodGltZSAqIDYwKSkgKiAxMDAwKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlID0gbmV3IERhdGUoZXZlbnQudGltZXN0YXJ0ICogMTAwMCksXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBldmVudC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc3RhcnREYXRlLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdDogZGF0ZVRyaWdnZXJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtYWxsSWNvbjogJ3JlczovL2ljb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50aWQ6IGV2ZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVpZDogc2l0ZWlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tTG9jYWxOb3RpZmljYXRpb25zLnNjaGVkdWxlKG5vdGlmaWNhdGlvbiwgbW1hQ2FsZW5kYXJDb21wb25lbnQsIHNpdGVpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyB0aGUgbm90aWZpY2F0aW9ucyBmb3IgYSBsaXN0IG9mIGV2ZW50cy5cbiAgICAgKiBJZiBhbiBldmVudCBub3RpZmljYXRpb24gdGltZSBpcyAwLCBjYW5jZWwgaXRzIHNjaGVkdWxlZCBub3RpZmljYXRpb24gKGlmIGFueSkuXG4gICAgICogSWYgbG9jYWwgbm90aWZpY2F0aW9uIHBsdWdpbiBpcyBub3QgZW5hYmxlZCwgcmVzb2x2ZSB0aGUgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNhbGVuZGFyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDYWxlbmRhciNzY2hlZHVsZUV2ZW50c05vdGlmaWNhdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gZXZlbnRzIEV2ZW50cyB0byBzY2hlZHVsZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlaWRdIElEIG9mIHRoZSBzaXRlIHRoZSBldmVudHMgYmVsb25nIHRvLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgdGhlIG5vdGlmaWNhdGlvbnMgaGF2ZSBiZWVuIHNjaGVkdWxlZC5cbiAgICAgKi9cbiAgICBzZWxmLnNjaGVkdWxlRXZlbnRzTm90aWZpY2F0aW9ucyA9IGZ1bmN0aW9uKGV2ZW50cywgc2l0ZWlkKSB7XG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGlmICgkbW1Mb2NhbE5vdGlmaWNhdGlvbnMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gc2VsZi5nZXRFdmVudE5vdGlmaWNhdGlvblRpbWUoZS5pZCwgc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2NoZWR1bGVFdmVudE5vdGlmaWNhdGlvbihlLCB0aW1lLCBzaXRlaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFuIGV2ZW50IG5vdGlmaWNhdGlvbiB0aW1lIGFuZCBzY2hlZHVsZSBhIG5ldyBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ2FsZW5kYXIjdXBkYXRlTm90aWZpY2F0aW9uVGltZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnQgRXZlbnQgdG8gdXBkYXRlIGl0cyBub3RpZmljYXRpb24gdGltZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgIE5ldyBub3RpZmljYXRpb24gc2V0dGluZyB0aW1lIChpbiBtaW51dGVzKS4gRS5nLiAxMCBtZWFucyBcIm5vdGlmaWNhdGUgMTAgbWludXRlcyBiZWZvcmUgc3RhcnRcIi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbm90aWZpY2F0aW9uIGlzIHVwZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi51cGRhdGVOb3RpZmljYXRpb25UaW1lID0gZnVuY3Rpb24oZXZlbnQsIHRpbWUpIHtcbiAgICAgICAgaWYgKCEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgLy8gTm90IGxvZ2dlZCBpbiwgd2UgY2FuJ3QgZ2V0IHRoZSBzaXRlIERCLiBVc2VyIGxvZ2dlZCBvdXQgb3Igc2Vzc2lvbiBleHBpcmVkIHdoaWxlIGFuIG9wZXJhdGlvbiB3YXMgb25nb2luZy5cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYiA9ICRtbVNpdGUuZ2V0RGIoKTtcblxuICAgICAgICBldmVudC5ub3RpZmljYXRpb250aW1lID0gdGltZTtcblxuICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KG1tYUNhbGVuZGFyRXZlbnRzU3RvcmUsIGV2ZW50KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2NoZWR1bGVFdmVudE5vdGlmaWNhdGlvbihldmVudCwgdGltZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuY2FsZW5kYXInKVxuXG4vKipcbiAqIENhbGVuZGFyIGhhbmRsZXJzIGZhY3RvcnkuXG4gKlxuICogVGhpcyBmYWN0b3J5IGhvbGRzIHRoZSBkaWZmZXJlbnQgaGFuZGxlcnMgdXNlZCBmb3IgZGVsZWdhdGVzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLmNhbGVuZGFyXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYUNhbGVuZGFySGFuZGxlcnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFDYWxlbmRhckhhbmRsZXJzJywgZnVuY3Rpb24oJGxvZywgJG1tYUNhbGVuZGFyKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFDYWxlbmRhckhhbmRsZXJzJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogU2lkZSBtZW51IG5hdiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFySGFuZGxlcnMjc2lkZU1lbnVOYXZcbiAgICAgKi9cbiAgICBzZWxmLnNpZGVNZW51TmF2ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hQ2FsZW5kYXIuaXNBdmFpbGFibGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbnRyb2xsZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTaWRlIG1lbnUgbmF2IGhhbmRsZXIgY29udHJvbGxlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFDYWxlbmRhckhhbmRsZXJzI3NpZGVNZW51TmF2OmNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJ2lvbi1jYWxlbmRhcic7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5jYWxlbmRhci5jYWxlbmRhcmV2ZW50cyc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnN0YXRlID0gJ3NpdGUuY2FsZW5kYXInO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb24nKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIGNvdXJzZSBjb21wbGV0aW9uIHJlcG9ydC5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hQ291cnNlQ29tcGxldGlvblJlcG9ydEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYUNvdXJzZUNvbXBsZXRpb25SZXBvcnRDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbVV0aWwsICRtbWFDb3Vyc2VDb21wbGV0aW9uLCAkbW1TaXRlLFxuICAgICAgICAgICAgJGlvbmljUGxhdGZvcm0pIHtcblxuICAgIHZhciBjb3Vyc2UgPSAkc3RhdGVQYXJhbXMuY291cnNlLFxuICAgICAgICB1c2VyaWQgPSAkc3RhdGVQYXJhbXMudXNlcmlkIHx8ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAkc2NvcGUuaXNUYWJsZXQgPSAkaW9uaWNQbGF0Zm9ybS5pc1RhYmxldCgpO1xuXG4gICAgZnVuY3Rpb24gZmV0Y2hDb21wbGV0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tYUNvdXJzZUNvbXBsZXRpb24uZ2V0Q29tcGxldGlvbihjb3Vyc2UuaWQsIHVzZXJpZCkudGhlbihmdW5jdGlvbihjb21wbGV0aW9uKSB7XG5cbiAgICAgICAgICAgIGNvbXBsZXRpb24uc3RhdHVzVGV4dCA9ICRtbWFDb3Vyc2VDb21wbGV0aW9uLmdldENvbXBsZXRlZFN0YXR1c1RleHQoY29tcGxldGlvbik7XG5cbiAgICAgICAgICAgICRzY29wZS5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcbiAgICAgICAgICAgICRzY29wZS5zaG93U2VsZkNvbXBsZXRlID0gJG1tYUNvdXJzZUNvbXBsZXRpb24uaXNTZWxmQ29tcGxldGlvbkF2YWlsYWJsZSgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tYUNvdXJzZUNvbXBsZXRpb24uY2FuTWFya1NlbGZDb21wbGV0ZWQodXNlcmlkLCBjb21wbGV0aW9uKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEuY291cnNlY29tcGxldGlvbi5jb3VsZG5vdGxvYWRyZXBvcnQnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmV0Y2hDb21wbGV0aW9uKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmNvbXBsZXRpb25Mb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gQ29udmVuaWVudmUgZnVuY3Rpb24gdG8gcmVmcmVzaCBjb21wbGV0aW9uIGRhdGEuXG4gICAgZnVuY3Rpb24gcmVmcmVzaENvbXBsZXRpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1hQ291cnNlQ29tcGxldGlvbi5pbnZhbGlkYXRlQ291cnNlQ29tcGxldGlvbihjb3Vyc2UuaWQsIHVzZXJpZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaENvbXBsZXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgJHNjb3BlLnJlZnJlc2hDb21wbGV0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZnJlc2hDb21wbGV0aW9uKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUuY29tcGxldGVDb3Vyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbS5jb3JlLnNlbmRpbmcnLCB0cnVlKTtcbiAgICAgICAgJG1tYUNvdXJzZUNvbXBsZXRpb24ubWFya0NvdXJzZUFzU2VsZkNvbXBsZXRlZChjb3Vyc2UuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmcmVzaENvbXBsZXRpb24oKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuY291cnNlY29tcGxldGlvbicpXG5cbi8qKlxuICogQ291cnNlIGNvbXBsZXRpb24gZmFjdG9yeS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYUNvdXJzZUNvbXBsZXRpb25cbiAqL1xuLmZhY3RvcnkoJyRtbWFDb3Vyc2VDb21wbGV0aW9uJywgZnVuY3Rpb24oJG1tU2l0ZSwgJGxvZywgJHEsICRtbUNvdXJzZXMpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYUNvdXJzZUNvbXBsZXRpb24nKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGNhbiBtYXJrIGEgY291cnNlIGFzIHNlbGYgY29tcGxldGVkLlxuICAgICAqIEl0IGNhbiBpZiBpdCdzIGNvbmZpZ3VyZWQgaW4gdGhlIGNvdXJzZSBhbmQgaXQgaGFzbid0IGJlZW4gY29tcGxldGVkIHlldC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb25cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNvdXJzZUNvbXBsZXRpb24jY2FuTWFya1NlbGZDb21wbGV0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdXNlcmlkICAgICBVc2VyIElELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wbGV0aW9uIENvdXJzZSBjb21wbGV0aW9uLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUgaWYgdXNlciBjYW4gbWFyayBjb3Vyc2UgYXMgc2VsZiBjb21wbGV0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmNhbk1hcmtTZWxmQ29tcGxldGVkID0gZnVuY3Rpb24odXNlcmlkLCBjb21wbGV0aW9uKSB7XG4gICAgICAgIHZhciBzZWxmQ29tcGxldGlvbkFjdGl2ZSA9IGZhbHNlLFxuICAgICAgICAgICAgYWxyZWFkeU1hcmtlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICgkbW1TaXRlLmdldFVzZXJJZCgpICE9IHVzZXJpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbXBsZXRpb24uY29tcGxldGlvbnMsIGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gICAgICAgICAgICBpZiAoY3JpdGVyaWEudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFNlbGYgY29tcGxldGlvbiBjcml0ZXJpYSBmb3VuZC5cbiAgICAgICAgICAgICAgICBzZWxmQ29tcGxldGlvbkFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWxyZWFkeU1hcmtlZCA9IGNyaXRlcmlhLmNvbXBsZXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZkNvbXBsZXRpb25BY3RpdmUgJiYgIWFscmVhZHlNYXJrZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjb21wbGV0ZWQgc3RhdHVzIHRleHQuIFRoZSBsYW5ndWFnZSBjb2RlIHJldHVybmVkIGlzIG1lYW50IHRvIGJlIHRyYW5zbGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uI2dldENvbXBsZXRlZFN0YXR1c1RleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcGxldGlvbiBDb3Vyc2UgY29tcGxldGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBMYW5ndWFnZSBjb2RlIG9mIHRoZSB0ZXh0IHRvIHNob3cuXG4gICAgICovXG4gICAgc2VsZi5nZXRDb21wbGV0ZWRTdGF0dXNUZXh0ID0gZnVuY3Rpb24oY29tcGxldGlvbikge1xuICAgICAgICBpZiAoY29tcGxldGlvbi5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW1hLmNvdXJzZWNvbXBsZXRpb24uY29tcGxldGVkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIExldCdzIGNhbGN1bGF0ZSBzdGF0dXMuXG4gICAgICAgICAgICB2YXIgaGFzU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbXBsZXRpb24uY29tcGxldGlvbnMsIGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNyaXRlcmlhLnRpbWVjb21wbGV0ZWQgfHwgY3JpdGVyaWEuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbW1hLmNvdXJzZWNvbXBsZXRpb24uaW5wcm9ncmVzcyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbW1hLmNvdXJzZWNvbXBsZXRpb24ubm90eWV0c3RhcnRlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNvdXJzZSBjb21wbGV0aW9uIHN0YXR1cyBmb3IgYSBjZXJ0YWluIGNvdXJzZSBhbmQgdXNlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb25cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNvdXJzZUNvbXBsZXRpb24jZ2V0Q29tcGxldGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VyaWRdIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCB1c2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGNvbXBsZXRpb24gaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Q29tcGxldGlvbiA9IGZ1bmN0aW9uKGNvdXJzZWlkLCB1c2VyaWQpIHtcbiAgICAgICAgdXNlcmlkID0gdXNlcmlkIHx8ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAgICAgJGxvZy5kZWJ1ZygnR2V0IGNvbXBsZXRpb24gZm9yIGNvdXJzZSAnICsgY291cnNlaWQgKyAnIGFuZCB1c2VyICcgKyB1c2VyaWQpO1xuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkIDogY291cnNlaWQsXG4gICAgICAgICAgICAgICAgdXNlcmlkOiB1c2VyaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRDb21wbGV0aW9uQ2FjaGVLZXkoY291cnNlaWQsIHVzZXJpZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnY29yZV9jb21wbGV0aW9uX2dldF9jb3Vyc2VfY29tcGxldGlvbl9zdGF0dXMnLCBkYXRhLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmNvbXBsZXRpb25zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5jb21wbGV0aW9uc3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZ2V0IGNvbXBsZXRpb24gV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1c2VyaWQgICBVc2VyIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q29tcGxldGlvbkNhY2hlS2V5KGNvdXJzZWlkLCB1c2VyaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFDb3Vyc2VDb21wbGV0aW9uOnZpZXc6JyArIGNvdXJzZWlkICsgJzonICsgdXNlcmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHZpZXcgY291cnNlIGNvbXBsZXRpb24gV1MgY2FsbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb25cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNvdXJzZUNvbXBsZXRpb24jaW52YWxpZGF0ZUNvdXJzZUNvbXBsZXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcmlkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGxpc3QgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQ291cnNlQ29tcGxldGlvbiA9IGZ1bmN0aW9uKGNvdXJzZWlkLCB1c2VyaWQpIHtcbiAgICAgICAgdXNlcmlkID0gdXNlcmlkIHx8ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldENvbXBsZXRpb25DYWNoZUtleShjb3Vyc2VpZCwgdXNlcmlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZpZXcgY291cnNlIGNvbXBsZXRpb24gcGx1Z2luIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgcXVpdGUgb2Z0ZW4gYW5kIHRodXMgc2hvdWxkIG9ubHkgcGVyZm9ybSBhIHF1aWNrXG4gICAgICogY2hlY2ssIHdlIHNob3VsZCBub3QgYmUgY2FsbGluZyBXUyBmcm9tIGhlcmUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uI2lzUGx1Z2luVmlld0VuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBsdWdpbiBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpblZpZXdFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghJG1tU2l0ZS53c0F2YWlsYWJsZSgnY29yZV9jb21wbGV0aW9uX2dldF9jb3Vyc2VfY29tcGxldGlvbl9zdGF0dXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZpZXcgY291cnNlIGNvbXBsZXRpb24gcGx1Z2luIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBjb3Vyc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uI2lzUGx1Z2luVmlld0VuYWJsZWRGb3JDb3Vyc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpblZpZXdFbmFibGVkRm9yQ291cnNlID0gZnVuY3Rpb24oY291cnNlSWQpIHtcbiAgICAgICAgaWYgKCFjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbUNvdXJzZXMuZ2V0VXNlckNvdXJzZShjb3Vyc2VJZCwgdHJ1ZSkudGhlbihmdW5jdGlvbihjb3Vyc2UpIHtcbiAgICAgICAgICAgIGlmIChjb3Vyc2UgJiYgdHlwZW9mIGNvdXJzZS5lbmFibGVjb21wbGV0aW9uICE9ICd1bmRlZmluZWQnICYmICFjb3Vyc2UuZW5hYmxlY29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZiBjb21wbGV0aW9uIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uI2lzU2VsZkNvbXBsZXRpb25BdmFpbGFibGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHNlbGYgY29tcGxldGlvbiBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzU2VsZkNvbXBsZXRpb25BdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3NBdmFpbGFibGUoJ2NvcmVfY29tcGxldGlvbl9tYXJrX2NvdXJzZV9zZWxmX2NvbXBsZXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNYXJrIGEgY291cnNlIGFzIHNlbGYgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ291cnNlQ29tcGxldGlvbiNtYXJrQ291cnNlQXNTZWxmQ29tcGxldGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUmVzb2x2ZWQgb24gc3VjY2Vzcy5cbiAgICAgKi9cbiAgICBzZWxmLm1hcmtDb3Vyc2VBc1NlbGZDb21wbGV0ZWQgPSBmdW5jdGlvbihjb3Vyc2VpZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgY291cnNlaWQ6IGNvdXJzZWlkXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ2NvcmVfY29tcGxldGlvbl9tYXJrX2NvdXJzZV9zZWxmX2NvbXBsZXRlZCcsIHBhcmFtcykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuY291cnNlY29tcGxldGlvbicpXG5cbi8qKlxuICogQ291cnNlIGNvbXBsZXRpb24gaGFuZGxlcnMgZmFjdG9yeS5cbiAqXG4gKiBUaGlzIGZhY3RvcnkgaG9sZHMgdGhlIGRpZmZlcmVudCBoYW5kbGVycyB1c2VkIGZvciBkZWxlZ2F0ZXMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uSGFuZGxlcnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFDb3Vyc2VDb21wbGV0aW9uSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1hQ291cnNlQ29tcGxldGlvbiwgJHN0YXRlLCBtbUNvdXJzZXNBY2Nlc3NNZXRob2RzKSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVmlldyB1c2VyIGNvbXBsZXRpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb25cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNvdXJzZUNvbXBsZXRpb25IYW5kbGVycyN2aWV3Q29tcGxldGlvblxuICAgICAqL1xuICAgIHNlbGYudmlld0NvbXBsZXRpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFDb3Vyc2VDb21wbGV0aW9uLmlzUGx1Z2luVmlld0VuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkIGZvciB0aGlzIHVzZXIgaW4gdGhpcyBjb250ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlciAgICAgVXNlciB0byBjaGVjay5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZEZvclVzZXIgPSBmdW5jdGlvbih1c2VyLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFDb3Vyc2VDb21wbGV0aW9uLmlzUGx1Z2luVmlld0VuYWJsZWRGb3JDb3Vyc2UoY291cnNlSWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyICAgICBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBDb250cm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24odXNlciwgY291cnNlSWQpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBWaWV3IGNvdXJzZSBjb21wbGV0aW9uIGhhbmRsZXIgY29udHJvbGxlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gICAgICAgICAgICAgKiBAbmdkb2MgY29udHJvbGxlclxuICAgICAgICAgICAgICogQG5hbWUgJG1tYUNvdXJzZUNvbXBsZXRpb25IYW5kbGVycyN2aWV3Q29tcGxldGlvbjpjb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIEJ1dHRvbiB0aXRsZS5cbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLmNvdXJzZWNvbXBsZXRpb24udmlld2NvdXJzZXJlcG9ydCc7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5jb3Vyc2UtY29tcGxldGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJpZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdXJzZToge2lkOiBjb3Vyc2VJZH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgbmF2IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uSGFuZGxlcnMjY291cnNlc05hdlxuICAgICAqL1xuICAgIHNlbGYuY291cnNlc05hdiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYUNvdXJzZUNvbXBsZXRpb24uaXNQbHVnaW5WaWV3RW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIHRoaXMgY291cnNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgICBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2Nlc3NEYXRhIFR5cGUgb2YgYWNjZXNzIHRvIHRoZSBjb3Vyc2U6IGRlZmF1bHQsIGd1ZXN0LCAuLi5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgVHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkRm9yQ291cnNlID0gZnVuY3Rpb24oY291cnNlSWQsIGFjY2Vzc0RhdGEpIHtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NEYXRhICYmIGFjY2Vzc0RhdGEudHlwZSA9PSBtbUNvdXJzZXNBY2Nlc3NNZXRob2RzLmd1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBOb3QgZW5hYmxlZCBmb3IgZ3Vlc3RzLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRtbWFDb3Vyc2VDb21wbGV0aW9uLmlzUGx1Z2luVmlld0VuYWJsZWRGb3JDb3Vyc2UoY291cnNlSWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBDb250cm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24oY291cnNlSWQpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb3Vyc2VzIG5hdiBoYW5kbGVyIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uSGFuZGxlcnMjY291cnNlc05hdjpjb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJ2lvbi1hbmRyb2lkLWNoZWNrYm94LW91dGxpbmUnO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEuY291cnNlY29tcGxldGlvbi5jb3Vyc2Vjb21wbGV0aW9uJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oJGV2ZW50LCBjb3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLmNvdXJzZS1jb21wbGV0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291cnNlOiBjb3Vyc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5maWxlcycpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byB1cGxvYWQgYW55IGtpbmQgb2YgZmlsZSBvbiBpT1MuIExldHMgdGhlIHVzZXIgY2hvb3NlIHRoZSBzaXRlIGhlIHdhbnRzIHRvIHVwbG9hZCB0aGUgZmlsZSB0by5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYUZpbGVzQ2hvb3NlU2l0ZUN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYUZpbGVzQ2hvb3NlU2l0ZUN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgJHN0YXRlUGFyYW1zLCAkbW1TaXRlc01hbmFnZXIsICRtbWFGaWxlc0hlbHBlciwgJGlvbmljSGlzdG9yeSkge1xuXG4gICAgdmFyIGZpbGVFbnRyeSA9ICRzdGF0ZVBhcmFtcy5maWxlIHx8wqB7fTtcbiAgICAkc2NvcGUuZmlsZW5hbWUgPSBmaWxlRW50cnkubmFtZTtcblxuICAgICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlcygpLnRoZW4oZnVuY3Rpb24oc2l0ZXMpIHtcbiAgICAgICAgJHNjb3BlLnNpdGVzID0gc2l0ZXM7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUudXBsb2FkSW5TaXRlID0gZnVuY3Rpb24oc2l0ZWlkKSB7XG4gICAgICAgICRtbWFGaWxlc0hlbHBlci5zaG93Q29uZmlybUFuZFVwbG9hZEluU2l0ZShmaWxlRW50cnksIHNpdGVpZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlQmFjazogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW1fY291cnNlcycpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5maWxlcycpXG5cbi5jb250cm9sbGVyKCdtbWFGaWxlc0luZGV4Q29udHJvbGxlcicsIGZ1bmN0aW9uKCRzY29wZSwgJG1tYUZpbGVzLCAkbW1TaXRlLCAkbW1VdGlsLCAkbW1BcHAsICRzdGF0ZSkge1xuXG4gICAgJHNjb3BlLmNhbkFjY2Vzc0ZpbGVzID0gJG1tYUZpbGVzLmNhbkFjY2Vzc0ZpbGVzO1xuICAgICRzY29wZS5zaG93UHJpdmF0ZUZpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1hRmlsZXMuY2FuQWNjZXNzRmlsZXMoKSAmJiAkbW1TaXRlLmNhbkFjY2Vzc015RmlsZXMoKTtcbiAgICB9O1xuICAgICRzY29wZS5zaG93VXBsb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFNob3cgdXBsb2FkIGluIHRoaXMgcGFnZSBpZiB1c2VyIGNhbiB1cGxvYWQgYnV0IGhlIGNhbid0IHNlZSB0aGUgTXkgRmlsZXMgb3B0aW9uLlxuICAgICAgICByZXR1cm4gISRtbWFGaWxlcy5jYW5BY2Nlc3NGaWxlcygpICYmICRtbVNpdGUuY2FuQWNjZXNzTXlGaWxlcygpICYmICRtbVNpdGUuY2FuVXBsb2FkRmlsZXMoKTtcbiAgICB9O1xuICAgICRzY29wZS5jYW5Eb3dubG9hZCA9ICRtbVNpdGUuY2FuRG93bmxvYWRGaWxlcztcblxuICAgICRzY29wZS5hZGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLmZpbGVzLmVycm9ybXVzdGJlb25saW5ldG91cGxvYWQnLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5maWxlcy11cGxvYWQnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuZmlsZXMnKVxuXG4uY29udHJvbGxlcignbW1hRmlsZXNMaXN0Q29udHJvbGxlcicsIGZ1bmN0aW9uKCRxLCAkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tYUZpbGVzLCAkbW1TaXRlLCAkdHJhbnNsYXRlLCAkbW1VdGlsLFxuICAgICAgICAkaW9uaWNIaXN0b3J5LCBtbWFGaWxlc1VwbG9hZFN0YXRlTmFtZSwgJHN0YXRlLCAkbW1BcHAsIG1tYUZpbGVzTXlDb21wb25lbnQsIG1tYUZpbGVzU2l0ZUNvbXBvbmVudCkge1xuXG4gICAgdmFyIHBhdGggPSAkc3RhdGVQYXJhbXMucGF0aCxcbiAgICAgICAgcm9vdCA9ICRzdGF0ZVBhcmFtcy5yb290LFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgcHJvbWlzZTtcblxuICAgIC8vIFdlJ3JlIGxvYWRpbmcgdGhlIGZpbGVzLlxuICAgICRzY29wZS5jb3VudCA9IC0xO1xuICAgICRzY29wZS5jb21wb25lbnQgPSByb290ID09PSAnbXknID8gbW1hRmlsZXNNeUNvbXBvbmVudCA6IG1tYUZpbGVzU2l0ZUNvbXBvbmVudDtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyB0aGUgZmlsZXMgYW5kIHVwZGF0ZXMgdGhlIHNjb3BlLlxuICAgIGZ1bmN0aW9uIGZldGNoRmlsZXMocm9vdCwgcGF0aCkge1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwYXRoIGlzIHVua25vd24sIHRoZSB1c2VyIG11c3QgYmUgcmVxdWVzdGluZyBhIHJvb3QuXG4gICAgICAgICAgICBpZiAocm9vdCA9PT0gJ3NpdGUnKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRtbWFGaWxlcy5nZXRTaXRlRmlsZXMoKTtcbiAgICAgICAgICAgICAgICB0aXRsZSA9ICR0cmFuc2xhdGUoJ21tYS5maWxlcy5zaXRlZmlsZXMnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gJ215Jykge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1hRmlsZXMuZ2V0TXlGaWxlcygpO1xuICAgICAgICAgICAgICAgIHRpdGxlID0gJHRyYW5zbGF0ZSgnbW1hLmZpbGVzLm15cHJpdmF0ZWZpbGVzJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVwb24gZXJyb3Igd2UgY3JlYXRlIGEgZmFrZSBwcm9taXNlIHRoYXQgaXMgcmVqZWN0ZWQuXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIHRpdGxlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHEucmVzb2x2ZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxLnByb21pc2U7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlcnZlIHRoZSBmaWxlcyB0aGUgdXNlciByZXF1ZXN0ZWQuXG4gICAgICAgICAgICBwYXRoZGF0YSA9IEpTT04ucGFyc2UocGF0aCk7XG4gICAgICAgICAgICBwcm9taXNlID0gJG1tYUZpbGVzLmdldEZpbGVzKHBhdGhkYXRhKTtcblxuICAgICAgICAgICAgLy8gUHV0IHRoZSB0aXRsZSBpbiBhIHByb21pc2UgdG8gYWN0IGxpa2UgdHJhbnNsYXRlIGRvZXMuXG4gICAgICAgICAgICB0aXRsZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcSA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICAgICAgcS5yZXNvbHZlKCRzdGF0ZVBhcmFtcy50aXRsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEucHJvbWlzZTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJHEuYWxsKFtwcm9taXNlLCB0aXRsZV0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGZpbGVzID0gZGF0YVswXSxcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGRhdGFbMV07XG5cbiAgICAgICAgICAgICRzY29wZS5maWxlcyA9IGZpbGVzLmVudHJpZXM7XG4gICAgICAgICAgICAkc2NvcGUuY291bnQgPSBmaWxlcy5jb3VudDtcbiAgICAgICAgICAgICRzY29wZS50aXRsZSA9IHRpdGxlO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5maWxlcy5jb3VsZG5vdGxvYWRmaWxlcycsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmZXRjaEZpbGVzKHJvb3QsIHBhdGgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5maWxlc0xvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUucmVmcmVzaEZpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFGaWxlcy5pbnZhbGlkYXRlRGlyZWN0b3J5KHJvb3QsIHBhdGgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmZXRjaEZpbGVzKHJvb3QsIHBhdGgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIGxpc3QgaWYgd2UgY29tZSBmcm9tIHVwbG9hZCBwYWdlICh3ZSBkb24ndCBrbm93IGlmIHVzZXIgdXBvYWRlZCBhIGZpbGUgb3Igbm90KS5cbiAgICAvLyBMaXN0IGlzIGludmFsaWRhdGVkIGluIHVwbG9hZCBzdGF0ZSBhZnRlciB1cGxvYWRpbmcgYSBmaWxlLlxuICAgICRzY29wZS4kb24oJyRpb25pY1ZpZXcuZW50ZXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBmb3J3YXJkVmlldyA9ICRpb25pY0hpc3RvcnkuZm9yd2FyZFZpZXcoKTtcbiAgICAgICAgaWYgKGZvcndhcmRWaWV3ICYmIGZvcndhcmRWaWV3LnN0YXRlTmFtZSA9PT0gbW1hRmlsZXNVcGxvYWRTdGF0ZU5hbWUpIHtcbiAgICAgICAgICAgICRzY29wZS5maWxlc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZmV0Y2hGaWxlcyhyb290LCBwYXRoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5maWxlc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJHNjb3BlLnNob3dVcGxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChyb290ID09PSAnbXknICYmICFwYXRoICYmICRtbVNpdGUuY2FuVXBsb2FkRmlsZXMoKSk7XG4gICAgfTtcblxuICAgIC8vIFdoZW4gd2UgYXJlIGluIHRoZSByb290IG9mIHRoZSBwcml2YXRlIGZpbGVzIHdlIGNhbiBhZGQgbW9yZSBmaWxlcy5cbiAgICAkc2NvcGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5maWxlcy5lcnJvcm11c3RiZW9ubGluZXRvdXBsb2FkJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUuZmlsZXMtdXBsb2FkJywge3Jvb3Q6IHJvb3QsIHBhdGg6IHBhdGh9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmZpbGVzJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIHVwbG9hZCBhbnkga2luZCBvZiBmaWxlLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hRmlsZXNVcGxvYWRDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFGaWxlc1VwbG9hZEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tVXRpbCwgJG1tYUZpbGVzSGVscGVyLCAkaW9uaWNIaXN0b3J5LCAkbW1hRmlsZXMsICRtbUFwcCkge1xuXG4gICAgdmFyIHVwbG9hZE1ldGhvZHMgPSB7XG4gICAgICAgICAgICBhbGJ1bTogJG1tYUZpbGVzSGVscGVyLnVwbG9hZEltYWdlRnJvbUFsYnVtLFxuICAgICAgICAgICAgY2FtZXJhOiAkbW1hRmlsZXNIZWxwZXIudXBsb2FkSW1hZ2VGcm9tQ2FtZXJhLFxuICAgICAgICAgICAgYXVkaW86ICRtbWFGaWxlc0hlbHBlci51cGxvYWRBdWRpbyxcbiAgICAgICAgICAgIHZpZGVvOiAkbW1hRmlsZXNIZWxwZXIudXBsb2FkVmlkZW9cbiAgICAgICAgfSxcbiAgICAgICAgcGF0aCA9ICRzdGF0ZVBhcmFtcy5wYXRoLFxuICAgICAgICByb290ID0gJHN0YXRlUGFyYW1zLnJvb3Q7XG5cbiAgICAkc2NvcGUuaXNBbmRyb2lkID0gaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCk7XG5cbiAgICAvLyBGdW5jdGlvbiBjYWxsZWQgd2hlbiBhIGZpbGUgaXMgdXBsb2FkZWQuXG4gICAgZnVuY3Rpb24gc3VjY2Vzc1VwbG9hZGluZygpIHtcbiAgICAgICAgJG1tYUZpbGVzLmludmFsaWRhdGVEaXJlY3Rvcnkocm9vdCwgcGF0aCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd01vZGFsKCdtbS5jb3JlLnN1Y2Nlc3MnLCAnbW1hLmZpbGVzLmZpbGV1cGxvYWRlZCcpO1xuICAgICAgICAgICAgJGlvbmljSGlzdG9yeS5nb0JhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb24gY2FsbGVkIHdoZW4gYSBmaWxlIHVwbG9hZCBmYWlscy5cbiAgICBmdW5jdGlvbiBlcnJvclVwbG9hZGluZyhlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJHNjb3BlLnVwbG9hZCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgaWYgKCEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLmZpbGVzLmVycm9ybXVzdGJlb25saW5ldG91cGxvYWQnLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YodXBsb2FkTWV0aG9kc1t0eXBlXSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdXBsb2FkTWV0aG9kc1t0eXBlXSgpLnRoZW4oc3VjY2Vzc1VwbG9hZGluZywgZXJyb3JVcGxvYWRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgICRzY29wZS51cGxvYWRGaWxlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGV2dC5zcmNFbGVtZW50O1xuICAgICAgICB2YXIgZmlsZSA9IGlucHV0LmZpbGVzWzBdO1xuICAgICAgICBpbnB1dC52YWx1ZSA9ICcnOyAvLyBVbnNldCBpbnB1dC5cbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICRtbWFGaWxlc0hlbHBlci5jb25maXJtVXBsb2FkRmlsZShmaWxlLnNpemUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZGF0YSBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZCwgYnV0IG5vdCBpdHMgVVJMIChuZWVkZWQpLiBDcmVhdGUgYSBjb3B5IG9mIHRoZSBmaWxlIHRvIHVwbG9hZCBpdC5cbiAgICAgICAgICAgICAgICAkbW1hRmlsZXNIZWxwZXIuY29weUFuZFVwbG9hZEZpbGUoZmlsZSkudGhlbihzdWNjZXNzVXBsb2FkaW5nLCBlcnJvclVwbG9hZGluZyk7XG4gICAgICAgICAgICB9LCBlcnJvclVwbG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmZpbGVzJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gZGV0ZWN0IGNoYW5lZ3Mgb24gZmlsZSBpbnB1dHMgKG5nLUNoYW5nZSBkb2Vzbid0IHdvcmsgaW4gdGhhdCB0eXBlIG9mIGlucHV0KS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1hRmlsZXNPbkNoYW5nZVxuICovXG4uZGlyZWN0aXZlKCdtbWFGaWxlc09uQ2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICB2YXIgb25DaGFuZ2VIYW5kbGVyID0gc2NvcGUuJGV2YWwoYXR0cnMubW1hRmlsZXNPbkNoYW5nZSk7XG4gICAgICBlbGVtZW50LmJpbmQoJ2NoYW5nZScsIG9uQ2hhbmdlSGFuZGxlcik7XG4gICAgfVxuICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5maWxlcycpXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQXBwUHJvdmlkZXIsIG1tYUZpbGVzU2hhcmVkRmlsZXNTdG9yZSkge1xuICAgIHZhciBzdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1tYUZpbGVzU2hhcmVkRmlsZXNTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCdcbiAgICAgICAgfVxuICAgIF07XG4gICAgJG1tQXBwUHJvdmlkZXIucmVnaXN0ZXJTdG9yZXMoc3RvcmVzKTtcbn0pXG5cbi5mYWN0b3J5KCckbW1hRmlsZXMnLCBmdW5jdGlvbigkbW1TaXRlLCAkbW1GUywgJHEsICR0aW1lb3V0LCAkbG9nLCAkbW1TaXRlc01hbmFnZXIsICRtbUFwcCwgbWQ1LFxuICAgICAgICAgICAgbW1hRmlsZXNTaGFyZWRGaWxlc1N0b3JlKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYUZpbGVzJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBkZWZhdWx0UGFyYW1zID0ge1xuICAgICAgICAgICAgXCJjb250ZXh0aWRcIjogMCxcbiAgICAgICAgICAgIFwiY29tcG9uZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImZpbGVhcmVhXCI6IFwiXCIsXG4gICAgICAgICAgICBcIml0ZW1pZFwiOiAwLFxuICAgICAgICAgICAgXCJmaWxlcGF0aFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJmaWxlbmFtZVwiOiBcIlwiXG4gICAgICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjb3JlX2ZpbGVzX2dldF9maWxlcyBXUyBjYWxsIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlcyNjYW5BY2Nlc3NGaWxlc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgV1MgaXMgYXZhaWxhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5jYW5BY2Nlc3NGaWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53c0F2YWlsYWJsZSgnY29yZV9maWxlc19nZXRfZmlsZXMnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlIGlzIGEgbmV3IGZpbGUgcmVjZWl2ZWQgaW4gaU9TLiBJZiBtb3JlIHRoYW4gb25lIGZpbGUgaXMgZm91bmQsIHRyZWF0IG9ubHkgdGhlIGZpcnN0IG9uZS5cbiAgICAgKiBUaGUgZmlsZSByZXR1cm5lZCBpcyBtYXJrZWQgYXMgXCJ0cmVhdGVkXCIgYW5kIHdpbGwgYmUgZGVsZXRlZCBpbiB0aGUgbmV4dCBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXMjY2hlY2tJT1NOZXdGaWxlc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIG5ldyBmaWxlIHRvIGJlIHRyZWF0ZWQuIElmIG5vIG5ldyBmaWxlcyBmb3VuZCwgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICAgKi9cbiAgICBzZWxmLmNoZWNrSU9TTmV3RmlsZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgICRsb2cuZGVidWcoJ1NlYXJjaCBmb3IgbmV3IGZpbGVzIG9uIGlPUycpO1xuICAgICAgICAkbW1GUy5nZXREaXJlY3RvcnlDb250ZW50cygnSW5ib3gnKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcblxuICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVEZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlSWQgPSBtZDUuY3JlYXRlSGFzaChlbnRyeS5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlIHdhcyBhbHJlYWR5IHRyZWF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICRtbUFwcC5nZXREQigpLmdldChtbWFGaWxlc1NoYXJlZEZpbGVzU3RvcmUsIGZpbGVJZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbGUgYWxyZWFkeSB0cmVhdGVkLiBEZWxldGUgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdEZWxldGUgYWxyZWFkeSB0cmVhdGVkIGZpbGU6ICcgKyBlbnRyeS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVEZWZlcnJlZC5yZXNvbHZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlbW92ZShmdW5jdGlvbigpwqB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRmlsZSBkZWxldGVkOiAnICsgZW50cnkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tQXBwLmdldERCKCkucmVtb3ZlKG1tYUZpbGVzU2hhcmVkRmlsZXNTdG9yZSwgZmlsZUlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdcIlRyZWF0ZWRcIiBtYXJrIHJlbW92ZWQgZnJvbSBmaWxlOiAnICsgZW50cnkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0Vycm9yIGRlbGV0aW5nIFwidHJlYXRlZFwiIG1hcmsgZnJvbSBmaWxlOiAnICsgZW50cnkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdFcnJvciBkZWxldGluZyBmaWxlIGluIEluYm94OiAnICsgZW50cnkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbGUgbm90IHRyZWF0ZWQgYmVmb3JlLCBzZW5kIGl0IHRvIHJlc29sdmUgc28gaXQncyBhIGNhbmRpZGF0ZSB0byBiZSBub3RpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0ZvdW5kIG5ldyBmaWxlICcgKyBlbnRyeS5uYW1lICsgJyBzaGFyZWQgd2l0aCB0aGUgYXBwLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZURlZmVycmVkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGZpbGVEZWZlcnJlZC5wcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihyZXNwb25zZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVUb1JldHVybixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVJZDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNwb25zZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocmVzcG9uc2VzW2ldKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBuZXcgZW50cnkgdG8gdHJlYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVRvUmV0dXJuID0gcmVzcG9uc2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlVG9SZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVJZCA9IG1kNS5jcmVhdGVIYXNoKGZpbGVUb1JldHVybi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgaXQgYXMgXCJ0cmVhdGVkXCIuXG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1BcHAuZ2V0REIoKS5pbnNlcnQobW1hRmlsZXNTaGFyZWRGaWxlc1N0b3JlLCB7aWQ6IGZpbGVJZH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRmlsZSBtYXJrZWQgYXMgXCJ0cmVhdGVkXCI6ICcgKyBmaWxlVG9SZXR1cm4ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShmaWxlVG9SZXR1cm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRXJyb3IgbWFya2luZyBmaWxlIGFzIFwidHJlYXRlZFwiOiAnICsgZmlsZVRvUmV0dXJuLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGZpbGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI2dldEZpbGVzXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwYXJhbXMgQSBsaXN0IG9mIHBhcmFtZXRlcnMgYWNjZXB0ZWQgYnkgdGhlIFdlYiBzZXJ2aWNlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyBpbiB0aGUga2V5ICdlbnRyaWVzJywgYW5kICdjb3VudCcuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgQWRkaXRpb25hbCBwcm9wZXJ0aWVzIGlzIGFkZGVkIHRvIHRoZSBlbnRyaWVzLCBzdWNoIGFzOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAtIGltZ3BhdGg6IFRoZSBwYXRoIHRvIHRoZSBpY29uLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAtIGxpbms6IFRoZSBKU09OIHN0cmluZyBvZiBwYXJhbXMgdG8gZ2V0IHRvIHRoZSBmaWxlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAtIGxpbmtJZDogQSBoYXNoIG9mIHRoZSBmaWxlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgc2VsZi5nZXRGaWxlcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIG9wdGlvbnMuY2FjaGVLZXkgPSBnZXRGaWxlc0xpc3RDYWNoZUtleShwYXJhbXMpO1xuXG4gICAgICAgICRtbVNpdGUucmVhZCgnY29yZV9maWxlc19nZXRfZmlsZXMnLCBwYXJhbXMsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBlbnRyaWVzOiBbXSxcbiAgICAgICAgICAgICAgICBjb3VudDogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQuZmlsZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXN1bHQuZmlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgZW50cnkubGluayA9IHt9O1xuICAgICAgICAgICAgICAgIGVudHJ5LmxpbmsuY29udGV4dGlkID0gKGVudHJ5LmNvbnRleHRpZCkgPyBlbnRyeS5jb250ZXh0aWQgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGVudHJ5LmxpbmsuY29tcG9uZW50ID0gKGVudHJ5LmNvbXBvbmVudCkgPyBlbnRyeS5jb21wb25lbnQgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGVudHJ5LmxpbmsuZmlsZWFyZWEgPSAoZW50cnkuZmlsZWFyZWEpID8gZW50cnkuZmlsZWFyZWEgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGVudHJ5LmxpbmsuaXRlbWlkID0gKGVudHJ5Lml0ZW1pZCkgPyBlbnRyeS5pdGVtaWQgOiAwO1xuICAgICAgICAgICAgICAgIGVudHJ5LmxpbmsuZmlsZXBhdGggPSAoZW50cnkuZmlsZXBhdGgpID8gZW50cnkuZmlsZXBhdGggOiBcIlwiO1xuICAgICAgICAgICAgICAgIGVudHJ5LmxpbmsuZmlsZW5hbWUgPSAoZW50cnkuZmlsZW5hbWUpID8gZW50cnkuZmlsZW5hbWUgOiBcIlwiO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmNvbXBvbmVudCAmJiBlbnRyeS5pc2Rpcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgdW51c2VkIGVsZW1lbnRzIHRoYXQgbWF5IGJyZWFrIHRoZSByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5saW5rLmZpbGVuYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuaW1ncGF0aCA9ICRtbUZTLmdldEZvbGRlckljb24oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5pbWdwYXRoID0gJG1tRlMuZ2V0RmlsZUljb24oZW50cnkuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVudHJ5LmxpbmsgPSBKU09OLnN0cmluZ2lmeShlbnRyeS5saW5rKTtcbiAgICAgICAgICAgICAgICBlbnRyeS5saW5rSWQgPSBtZDUuY3JlYXRlSGFzaChlbnRyeS5saW5rKTtcbiAgICAgICAgICAgICAgICAvLyBlbnRyeS5sb2NhbHBhdGggPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgKCFlbnRyeS5pc2RpciAmJiBlbnRyeS51cmwpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gVE9ETyBDaGVjayAkbW1TaXRlLlxuICAgICAgICAgICAgICAgIC8vICAgICB2YXIgdW5pcXVlSWQgPSAkbW1TaXRlLmlkICsgXCItXCIgKyBtZDUuY3JlYXRlSGFzaChlbnRyeS51cmwpO1xuICAgICAgICAgICAgICAgIC8vICAgICB2YXIgcGF0aCA9IE1NLmRiLmdldChcImZpbGVzXCIsIHVuaXF1ZUlkKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGVudHJ5LmxvY2FscGF0aCA9IHBhdGguZ2V0KFwibG9jYWxwYXRoXCIpO1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgZGF0YS5jb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIGRhdGEuZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGRhdGEpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZmlsZSBsaXN0IFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwYXJhbXMgUGFyYW1zIG9mIHRoZSBkaXJlY3RvcnkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGaWxlc0xpc3RDYWNoZUtleShwYXJhbXMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBwYXJhbXMuY29tcG9uZW50ID09PSAnJyA/ICdzaXRlJyA6ICdteSc7XG4gICAgICAgIHJldHVybiAnbW1hRmlsZXM6bGlzdDonICsgcm9vdCArICc6JyArIHBhcmFtcy5jb250ZXh0aWQgKyAnOicgKyBwYXJhbXMuZmlsZXBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwcml2YXRlIGZpbGVzIG9mIHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXMjZ2V0TXlGaWxlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gU2VlICRtbWFGaWxlcyNnZXRGaWxlc1xuICAgICAqL1xuICAgIHNlbGYuZ2V0TXlGaWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0gZ2V0TXlGaWxlc1Jvb3RQYXJhbXMoKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RmlsZXMocGFyYW1zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb21tb24gcGFydCBvZiB0aGUgY2FjaGUga2V5cyBmb3IgcHJpdmF0ZSBmaWxlcyBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE15RmlsZXNMaXN0Q29tbW9uQ2FjaGVLZXkoKSB7XG4gICAgICAgIHJldHVybiAnbW1hRmlsZXM6bGlzdDpteSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHBhcmFtcyB0byBnZXQgcm9vdCBwcml2YXRlIGZpbGVzIGRpcmVjdG9yeS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUGFyYW1zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE15RmlsZXNSb290UGFyYW1zKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0gYW5ndWxhci5jb3B5KGRlZmF1bHRQYXJhbXMsIHt9KTtcbiAgICAgICAgcGFyYW1zLmNvbXBvbmVudCA9IFwidXNlclwiO1xuICAgICAgICBwYXJhbXMuZmlsZWFyZWEgPSBcInByaXZhdGVcIjtcbiAgICAgICAgcGFyYW1zLmNvbnRleHRpZCA9IC0xO1xuICAgICAgICBwYXJhbXMuY29udGV4dGxldmVsID0gXCJ1c2VyXCI7XG4gICAgICAgIHBhcmFtcy5pbnN0YW5jZWlkID0gJG1tU2l0ZS5nZXRVc2VySWQoKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNpdGUgZmlsZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXMjZ2V0U2l0ZUZpbGVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBTZWUgJG1tYUZpbGVzI2dldEZpbGVzXG4gICAgICovXG4gICAgc2VsZi5nZXRTaXRlRmlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGFuZ3VsYXIuY29weShkZWZhdWx0UGFyYW1zLCB7fSk7XG4gICAgICAgIHJldHVybiBzZWxmLmdldEZpbGVzKHBhcmFtcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29tbW9uIHBhcnQgb2YgdGhlIGNhY2hlIGtleXMgZm9yIHNpdGUgZmlsZXMgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaXRlRmlsZXNMaXN0Q29tbW9uQ2FjaGVLZXkoKSB7XG4gICAgICAgIHJldHVybiAnbW1hRmlsZXM6bGlzdDpzaXRlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBsaXN0IG9mIGZpbGVzIGluIGEgY2VydGFpbiBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXMjaW52YWxpZGF0ZURpcmVjdG9yeVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcm9vdCAgICAgUm9vdCBvZiB0aGUgZGlyZWN0b3J5ICgnbXknIGZvciBwcml2YXRlIGZpbGVzLCAnc2l0ZScgZm9yIHNpdGUgZmlsZXMpLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCAgICAgUGF0aCB0byB0aGUgZGlyZWN0b3J5LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVpZF0gSWQgb2YgdGhlIHNpdGUgdG8gaW52YWxpZGF0ZS4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGxpc3QgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlRGlyZWN0b3J5ID0gZnVuY3Rpb24ocm9vdCwgcGF0aCwgc2l0ZWlkKSB7XG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIGlmIChyb290ID09PSAnc2l0ZScpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBhbmd1bGFyLmNvcHkoZGVmYXVsdFBhcmFtcywge30pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSAnbXknKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gZ2V0TXlGaWxlc1Jvb3RQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IEpTT04ucGFyc2UocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0RmlsZXNMaXN0Q2FjaGVLZXkocGFyYW1zKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBsaXN0IG9mIHByaXZhdGUgZmlsZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXMjaW52YWxpZGF0ZU15RmlsZXNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGxpc3QgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlTXlGaWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleVN0YXJ0aW5nV2l0aChnZXRNeUZpbGVzTGlzdENvbW1vbkNhY2hlS2V5KCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBsaXN0IG9mIHNpdGUgZmlsZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXMjaW52YWxpZGF0ZVNpdGVGaWxlc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbGlzdCBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVTaXRlRmlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXlTdGFydGluZ1dpdGgoZ2V0U2l0ZUZpbGVzTGlzdENvbW1vbkNhY2hlS2V5KCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBpcyBlbmFibGVkLiBQbHVnaW4gaXMgZW5hYmxlZCBpZjpcbiAgICAgKiAgICAgLSBTaXRlIHN1cHBvcnRzIGNvcmVfZmlsZXNfZ2V0X2ZpbGVzXG4gICAgICogICAgIG9yXG4gICAgICogICAgIC0gVXNlciBoYXMgY2FwYWJpbGl0eSBtb29kbGUvdXNlcjptYW5hZ2Vvd25maWxlcyBhbmQgV1MgYWxsb3dzIHVwbG9hZGluZyBmaWxlcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlcyNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW5BY2Nlc3NGaWxlcyA9IHNlbGYuY2FuQWNjZXNzRmlsZXMoKSxcbiAgICAgICAgICAgIGNhbkFjY2Vzc015RmlsZXMgPSAkbW1TaXRlLmNhbkFjY2Vzc015RmlsZXMoKSxcbiAgICAgICAgICAgIGNhblVwbG9hZEZpbGVzID0gJG1tU2l0ZS5jYW5VcGxvYWRGaWxlcygpO1xuXG4gICAgICAgIHJldHVybiBjYW5BY2Nlc3NGaWxlcyB8fCAoY2FuVXBsb2FkRmlsZXMgJiYgY2FuQWNjZXNzTXlGaWxlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwbG9hZCBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXMjdXBsb2FkRmlsZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdXJpICAgICAgRmlsZSBVUkkuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zICBPcHRpb25zIGZvciB0aGUgdXBsb2FkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZGVsZXRlQWZ0ZXJVcGxvYWQgV2hldGhlciBvciBub3QgdG8gZGVsZXRlIHRoZSBvcmlnaW5hbCBhZnRlciB1cGxvYWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGZpbGVLZXlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gZmlsZU5hbWVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gbWltZVR5cGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlaWRdIElkIG9mIHRoZSBzaXRlIHRvIHVwbG9hZCB0aGUgZmlsZSB0by4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLnVwbG9hZEZpbGUgPSBmdW5jdGlvbih1cmksIG9wdGlvbnMsIHNpdGVpZCkge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgc2l0ZWlkID0gc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICB2YXIgZGVsZXRlQWZ0ZXJVcGxvYWQgPSBvcHRpb25zLmRlbGV0ZUFmdGVyVXBsb2FkLFxuICAgICAgICAgICAgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgZnRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGZpbGVLZXk6IG9wdGlvbnMuZmlsZUtleSxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogb3B0aW9ucy5maWxlTmFtZSxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogb3B0aW9ucy5taW1lVHlwZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBkZWxldGVGaWxlKCkge1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHNldCB0aW1lb3V0LCBvdGhlcndpc2UgaW4gTm9kZS1XZWJraXQgdGhlIHVwbG9hZCB0aHJldyBhbiBlcnJvciBzb21ldGltZXMuXG4gICAgICAgICAgICAgICAgJG1tRlMucmVtb3ZlRXh0ZXJuYWxGaWxlKHVyaSk7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9XG5cbiAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHNpdGUudXBsb2FkRmlsZSh1cmksIGZ0T3B0aW9ucykudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlQWZ0ZXJVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlRmlsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChkZWxldGVBZnRlclVwbG9hZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgaW1hZ2UuXG4gICAgICogQHRvZG8gSGFuZGxlIE5vZGUgV2Via2l0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI3VwbG9hZEltYWdlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgdXJpICAgICAgICAgRmlsZSBVUkkuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXNGcm9tQWxidW0gVHJ1ZSBpZiB0aGUgaW1hZ2Ugd2FzIHRha2VuIGZyb20gYWxidW0sIGZhbHNlIGlmIGl0J3MgYSBuZXcgaW1hZ2UgdGFrZW4gd2l0aCBjYW1lcmEuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLnVwbG9hZEltYWdlID0gZnVuY3Rpb24odXJpLCBpc0Zyb21BbGJ1bSkge1xuICAgICAgICAkbG9nLmRlYnVnKCdVcGxvYWRpbmcgYW4gaW1hZ2UnKTtcbiAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YodXJpKSA9PT0gJ3VuZGVmaW5lZCcgfHwgdXJpID09PSAnJyl7XG4gICAgICAgICAgICAvLyBJbiBOb2RlLVdlYmtpdCwgaWYgeW91IHN1Y2Nlc3NmdWxseSB1cGxvYWQgYSBwaWN0dXJlIGFuZCB0aGVuIHlvdSBvcGVuIHRoZSBmaWxlIHBpY2tlciBhZ2FpblxuICAgICAgICAgICAgLy8gYW5kIGNhbmNlbCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhbiBlbXB0eSB1cmkuIExldCdzIGZpbHRlciBpdC5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1JlY2VpdmVkIGludmFsaWQgVVJJIGluICRtbWFGaWxlcy51cGxvYWRJbWFnZSgpJyk7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLmRlbGV0ZUFmdGVyVXBsb2FkID0gIWlzRnJvbUFsYnVtO1xuICAgICAgICBvcHRpb25zLmZpbGVLZXkgPSBcImZpbGVcIjtcbiAgICAgICAgb3B0aW9ucy5maWxlTmFtZSA9IFwiaW1hZ2VfXCIgKyBkLmdldFRpbWUoKSArIFwiLmpwZ1wiO1xuICAgICAgICBvcHRpb25zLm1pbWVUeXBlID0gXCJpbWFnZS9qcGVnXCI7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYudXBsb2FkRmlsZSh1cmksIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgbWVkaWEuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXMjdXBsb2FkTWVkaWFcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbWVkaWFGaWxlcyBBcnJheSBvZiBmaWxlIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIHByb21pc2VzLlxuICAgICAqL1xuICAgIHNlbGYudXBsb2FkTWVkaWEgPSBmdW5jdGlvbihtZWRpYUZpbGVzKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ1VwbG9hZGluZyBtZWRpYScpO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1lZGlhRmlsZXMsIGZ1bmN0aW9uKG1lZGlhRmlsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgICBvcHRpb25zLmZpbGVLZXkgPSBudWxsO1xuICAgICAgICAgICAgb3B0aW9ucy5maWxlTmFtZSA9IG1lZGlhRmlsZS5uYW1lO1xuICAgICAgICAgICAgb3B0aW9ucy5taW1lVHlwZSA9IG51bGw7XG4gICAgICAgICAgICBvcHRpb25zLmRlbGV0ZUFmdGVyVXBsb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi51cGxvYWRGaWxlKG1lZGlhRmlsZS5mdWxsUGF0aCwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBmaWxlIG9mIGFueSB0eXBlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI3VwbG9hZEdlbmVyaWNGaWxlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmkgICAgICBGaWxlIFVSSS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgICAgIEZpbGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgICAgIEZpbGUgdHlwZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlaWRdIElkIG9mIHRoZSBzaXRlIHRvIHVwbG9hZCB0aGUgZmlsZSB0by4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZSBpcyB1cGxvYWRlZC5cbiAgICAgKi9cbiAgICBzZWxmLnVwbG9hZEdlbmVyaWNGaWxlID0gZnVuY3Rpb24odXJpLCBuYW1lLCB0eXBlLCBzaXRlaWQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5maWxlS2V5ID0gbnVsbDtcbiAgICAgICAgb3B0aW9ucy5maWxlTmFtZSA9IG5hbWU7XG4gICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSB0eXBlO1xuICAgICAgICAvLyBEb24ndCBkZWxldGUgdGhlIGZpbGUgb24gaU9TLCBpdCdzIGdvaW5nIHRvIGJlIGRlbGV0ZWQgb24gJG1tYUZpbGVzI2NoZWNrSU9TTmV3RmlsZXMuXG4gICAgICAgIG9wdGlvbnMuZGVsZXRlQWZ0ZXJVcGxvYWQgPSAhaW9uaWMuUGxhdGZvcm0uaXNJT1MoKTtcblxuICAgICAgICByZXR1cm4gc2VsZi51cGxvYWRGaWxlKHVyaSwgb3B0aW9ucywgc2l0ZWlkKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmZpbGVzJylcblxuLyoqXG4gKiBGaWxlcyBoYW5kbGVycyBmYWN0b3J5LlxuICpcbiAqIFRoaXMgZmFjdG9yeSBob2xkcyB0aGUgZGlmZmVyZW50IGhhbmRsZXJzIHVzZWQgZm9yIGRlbGVnYXRlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFGaWxlc0hhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hRmlsZXNIYW5kbGVycycsIGZ1bmN0aW9uKCRsb2csICRtbWFGaWxlcykge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hRmlsZXNIYW5kbGVycycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFNpZGUgbWVudSBuYXYgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlc0hhbmRsZXJzI3NpZGVNZW51TmF2XG4gICAgICovXG4gICAgc2VsZi5zaWRlTWVudU5hdiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYUZpbGVzLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29udHJvbGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNpZGUgbWVudSBuYXYgaGFuZGxlciBjb250cm9sbGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICAgICAgICAgKiBAbmdkb2MgY29udHJvbGxlclxuICAgICAgICAgICAgICogQG5hbWUgJG1tYUZpbGVzSGFuZGxlcnMjc2lkZU1lbnVOYXY6Y29udHJvbGxlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAnaW9uLWZvbGRlcic7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5maWxlcy5teWZpbGVzJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3RhdGUgPSAnc2l0ZS5maWxlcyc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuZmlsZXMnKVxuXG4uY29uc3RhbnQoJ21tYUZpbGVzRmlsZVNpemVXYXJuaW5nJywgNTI0Mjg4MClcblxuLmZhY3RvcnkoJyRtbWFGaWxlc0hlbHBlcicsIGZ1bmN0aW9uKCRxLCAkbW1VdGlsLCAkbW1BcHAsICRsb2csICR0cmFuc2xhdGUsICR3aW5kb3csXG4gICAgICAgICRtbWFGaWxlcywgJGNvcmRvdmFDYW1lcmEsICRjb3Jkb3ZhQ2FwdHVyZSwgJG1tTGFuZywgJG1tRlMsICRtbVRleHQsIG1tYUZpbGVzRmlsZVNpemVXYXJuaW5nKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYUZpbGVzSGVscGVyJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVudCBoZWxwZXIgZm9yIHRoZSB1c2VyIHRvIHVwbG9hZCBhbiBpbWFnZSBmcm9tIGFuIGFsYnVtLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzSGVscGVyI3VwbG9hZEltYWdlRnJvbUFsYnVtXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHJlamVjdCBjb250YWlucyB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgdGhlcmUgaXMgbm8gZXJyb3IgbWVzc2FnZVxuICAgICAqICAgICAgICAgICAgICAgICAgIHRoZW4gd2UgY2FuIGNvbnNpZGVyIHRoYXQgdGhpcyBpcyBhIHNpbGVudCBmYWlsLlxuICAgICAqL1xuICAgIHNlbGYudXBsb2FkSW1hZ2VGcm9tQWxidW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnVHJ5aW5nIHRvIGdldCBhIGltYWdlIGZyb20gYWxidW1zJyk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgdmFyIHdpZHRoICA9ICAkd2luZG93LmlubmVyV2lkdGggIC0gMjAwO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gICR3aW5kb3cuaW5uZXJIZWlnaHQgLSAyMDA7XG5cbiAgICAgICAgLy8gaVBhZCBwb3BPdmVyLCBzZWUgaHR0cHM6Ly90cmFja2VyLm1vb2RsZS5vcmcvYnJvd3NlL01PQklMRS0yMDhcbiAgICAgICAgdmFyIHBvcG92ZXIgPSBuZXcgQ2FtZXJhUG9wb3Zlck9wdGlvbnMoMTAsIDEwLCB3aWR0aCwgaGVpZ2h0LCBDYW1lcmEuUG9wb3ZlckFycm93RGlyZWN0aW9uLkFSUk9XX0FOWSk7XG4gICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmdldFBpY3R1cmUoe1xuICAgICAgICAgICAgcXVhbGl0eTogNTAsXG4gICAgICAgICAgICBkZXN0aW5hdGlvblR5cGU6IG5hdmlnYXRvci5jYW1lcmEuRGVzdGluYXRpb25UeXBlLkZJTEVfVVJJLFxuICAgICAgICAgICAgc291cmNlVHlwZTogbmF2aWdhdG9yLmNhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5QSE9UT0xJQlJBUlksXG4gICAgICAgICAgICBwb3BvdmVyT3B0aW9ucyA6IHBvcG92ZXJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW1hLmZpbGVzLnVwbG9hZGluZycsIHRydWUpO1xuICAgICAgICAgICAgJG1tYUZpbGVzLnVwbG9hZEltYWdlKGltZywgdHJ1ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzLlxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsICdtbWEuZmlsZXMuZXJyb3J3aGlsZXVwbG9hZGluZycpO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgdHJlYXRJbWFnZUVycm9yKGVycm9yLCBkZWZlcnJlZCwgJ21tYS5maWxlcy5lcnJvcmdldHRpbmdpbWFnZWFsYnVtJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW50IGhlbHBlciBmb3IgdGhlIHVzZXIgdG8gdGFrZSBhbiBpbWFnZSB3aXRoIHRoZSBjYW1lcmEgYW5kIHVwbG9hZCBpdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlc0hlbHBlciN1cGxvYWRJbWFnZUZyb21DYW1lcmFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcmVqZWN0IGNvbnRhaW5zIHRoZSBlcnJvciBtZXNzYWdlLCBpZiB0aGVyZSBpcyBubyBlcnJvciBtZXNzYWdlXG4gICAgICogICAgICAgICAgICAgICAgICAgdGhlbiB3ZSBjYW4gY29uc2lkZXIgdGhhdCB0aGlzIGlzIGEgc2lsZW50IGZhaWwuXG4gICAgICovXG4gICAgc2VsZi51cGxvYWRJbWFnZUZyb21DYW1lcmEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnVHJ5aW5nIHRvIGNhcHR1cmUgYW4gaW1hZ2Ugd2l0aCBjYW1lcmEnKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICAkY29yZG92YUNhbWVyYS5nZXRQaWN0dXJlKHtcbiAgICAgICAgICAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgICAgZGVzdGluYXRpb25UeXBlOiBuYXZpZ2F0b3IuY2FtZXJhLkRlc3RpbmF0aW9uVHlwZS5GSUxFX1VSSVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbWEuZmlsZXMudXBsb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAkbW1hRmlsZXMudXBsb2FkSW1hZ2UoaW1nLCBmYWxzZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzLlxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsICdtbWEuZmlsZXMuZXJyb3J3aGlsZXVwbG9hZGluZycpO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgdHJlYXRJbWFnZUVycm9yKGVycm9yLCBkZWZlcnJlZCwgJ21tYS5maWxlcy5lcnJvcmNhcHR1cmluZ2ltYWdlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW50IGhlbHBlciBmb3IgdGhlIHVzZXIgdG8gcmVjb3JkIGFuZCB1cGxvYWQgYW4gYXVkaW8uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXNIZWxwZXIjdXBsb2FkQXVkaW9cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcmVqZWN0IGNvbnRhaW5zIHRoZSBlcnJvciBtZXNzYWdlLCBpZiB0aGVyZSBpcyBubyBlcnJvciBtZXNzYWdlXG4gICAgICogICAgICAgICAgICAgICAgICAgdGhlbiB3ZSBjYW4gY29uc2lkZXIgdGhhdCB0aGlzIGlzIGEgc2lsZW50IGZhaWwuXG4gICAgICovXG4gICAgc2VsZi51cGxvYWRBdWRpbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbG9nLmRlYnVnKCdUcnlpbmcgdG8gcmVjb3JkIGFuIGF1ZGlvIGZpbGUnKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICAkY29yZG92YUNhcHR1cmUuY2FwdHVyZUF1ZGlvKHtsaW1pdDogMX0pLnRoZW4oZnVuY3Rpb24obWVkaWFzKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tYS5maWxlcy51cGxvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICRxLmFsbCgkbW1hRmlsZXMudXBsb2FkTWVkaWEobWVkaWFzKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzLlxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsICdtbWEuZmlsZXMuZXJyb3J3aGlsZXVwbG9hZGluZycpO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgdHJlYXRDYXB0dXJlRXJyb3IoZXJyb3IsIGRlZmVycmVkLCAnbW1hLmZpbGVzLmVycm9yY2FwdHVyaW5nYXVkaW8nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbnQgaGVscGVyIGZvciB0aGUgdXNlciB0byByZWNvcmQgYW5kIHVwbG9hZCBhIHZpZGVvLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzSGVscGVyI3VwbG9hZFZpZGVvXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHJlamVjdCBjb250YWlucyB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgdGhlcmUgaXMgbm8gZXJyb3IgbWVzc2FnZVxuICAgICAqICAgICAgICAgICAgICAgICAgIHRoZW4gd2UgY2FuIGNvbnNpZGVyIHRoYXQgdGhpcyBpcyBhIHNpbGVudCBmYWlsLlxuICAgICAqL1xuICAgIHNlbGYudXBsb2FkVmlkZW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnVHJ5aW5nIHRvIHJlY29yZCBhIHZpZGVvIGZpbGUnKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICAkY29yZG92YUNhcHR1cmUuY2FwdHVyZVZpZGVvKHtsaW1pdDogMX0pLnRoZW4oZnVuY3Rpb24obWVkaWFzKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tYS5maWxlcy51cGxvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICRxLmFsbCgkbW1hRmlsZXMudXBsb2FkTWVkaWEobWVkaWFzKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzLlxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsICdtbWEuZmlsZXMuZXJyb3J3aGlsZXVwbG9hZGluZycpO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgdHJlYXRDYXB0dXJlRXJyb3IoZXJyb3IsIGRlZmVycmVkLCAnbW1hLmZpbGVzLmVycm9yY2FwdHVyaW5ndmlkZW8nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3cgYSBjb25maXJtYXRpb24gbW9kYWwgdG8gdGhlIHVzZXIgaWYgaGUgaXMgdXNpbmcgYSBsaW1pdGVkIGNvbm5lY3Rpb24gb3IgdGhlIGZpbGUgc2l6ZSBpcyBoaWdoZXIgdGhhbiA1TUIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXNIZWxwZXIjY29uZmlybVVwbG9hZEZpbGVcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNpemUgRmlsZSdzIHNpemUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgdXNlciBjb25maXJtcyBvciBpZiB0aGVyZSdzIG5vIG5lZWQgdG8gc2hvdyBhIG1vZGFsLlxuICAgICAqL1xuICAgIHNlbGYuY29uZmlybVVwbG9hZEZpbGUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW1hLmZpbGVzLmVycm9ybXVzdGJlb25saW5ldG91cGxvYWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkbW1BcHAuaXNOZXR3b3JrQWNjZXNzTGltaXRlZCgpIHx8IHNpemUgPj0gbW1hRmlsZXNGaWxlU2l6ZVdhcm5pbmcpIHtcbiAgICAgICAgICAgICB2YXIgc2l6ZSA9ICRtbVRleHQuYnl0ZXNUb1NpemUoc2l6ZSwgMik7XG4gICAgICAgICAgICByZXR1cm4gJG1tVXRpbC5zaG93Q29uZmlybSgkdHJhbnNsYXRlKCdtbWEuZmlsZXMuY29uZmlybXVwbG9hZGZpbGUnLCB7c2l6ZTogc2l6ZX0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0ZW1wb3JhcnkgY29weSBvZiBhIGZpbGUgYW5kIHVwbG9hZCBpdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlc0hlbHBlciNjb3B5QW5kVXBsb2FkRmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlIEZpbGUgdG8gY29weSBhbmQgdXBsb2FkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZSBpcyB1cGxvYWRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmNvcHlBbmRVcGxvYWRGaWxlID0gZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW1hLmZpbGVzLnJlYWRpbmdmaWxlJywgdHJ1ZSk7XG5cbiAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZGF0YSBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZCwgYnV0IG5vdCBpdHMgVVJMIChuZWVkZWQpLiBDcmVhdGUgYSBjb3B5IG9mIHRoZSBmaWxlIHRvIHVwbG9hZCBpdC5cbiAgICAgICAgJG1tRlMucmVhZEZpbGVEYXRhKGZpbGUsICRtbUZTLkZPUk1BVEFSUkFZQlVGRkVSKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICAgICAgdmFyIGZpbGVwYXRoID0gJG1tRlMuZ2V0VG1wRm9sZGVyKCkgKyAnLycgKyBmaWxlLm5hbWU7XG5cbiAgICAgICAgICAgICRtbUZTLndyaXRlRmlsZShmaWxlcGF0aCwgZGF0YSkudGhlbihmdW5jdGlvbihmaWxlRW50cnkpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgc2VsZi51cGxvYWRHZW5lcmljRmlsZShmaWxlRW50cnkudG9VUkwoKSwgZmlsZS5uYW1lLCBmaWxlLnR5cGUpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3Igd3JpdGluZyBmaWxlIHRvIHVwbG9hZDogJytKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsICdtbWEuZmlsZXMuZXJyb3JyZWFkaW5nZmlsZScpO1xuICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciByZWFkaW5nIGZpbGUgdG8gdXBsb2FkOiAnK0pTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW1hLmZpbGVzLmVycm9ycmVhZGluZ2ZpbGUnKTtcbiAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIG9mIGFueSB0eXBlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzSGVscGVyI3VwbG9hZEdlbmVyaWNGaWxlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmkgICAgICBGaWxlIFVSSS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgICAgIEZpbGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgICAgIEZpbGUgdHlwZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlaWRdIElkIG9mIHRoZSBzaXRlIHRvIHVwbG9hZCB0aGUgZmlsZSB0by4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGZpbGUgaXMgdXBsb2FkZWQuXG4gICAgICovXG4gICAgc2VsZi51cGxvYWRHZW5lcmljRmlsZSA9IGZ1bmN0aW9uKHVyaSwgbmFtZSwgdHlwZSwgc2l0ZWlkKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgaWYgKCEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgJ21tYS5maWxlcy5lcnJvcm11c3RiZW9ubGluZXRvdXBsb2FkJyk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW1hLmZpbGVzLnVwbG9hZGluZycsIHRydWUpO1xuXG4gICAgICAgICRtbWFGaWxlcy51cGxvYWRHZW5lcmljRmlsZSh1cmksIG5hbWUsIHR5cGUsIHNpdGVpZCkudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgdXBsb2FkaW5nIGZpbGU6ICcrSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsICdtbWEuZmlsZXMuZXJyb3J3aGlsZXVwbG9hZGluZycpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gdXBsb2FkIGEgZmlsZSBvbiBhIGNlcnRhaW4gc2l0ZSwgc2hvd2luZyBhIGNvbmZpcm0gaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzSGVscGVyI3Nob3dDb25maXJtQW5kVXBsb2FkSW5TaXRlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBmaWxlRW50cnkgRmlsZUVudHJ5IG9mIHRoZSBmaWxlIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlaWRdICBJZCBvZiB0aGUgc2l0ZSB0byB1cGxvYWQgdGhlIGZpbGUgdG8uIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZSBpcyB1cGxvYWRlZC5cbiAgICAgKi9cbiAgICBzZWxmLnNob3dDb25maXJtQW5kVXBsb2FkSW5TaXRlID0gZnVuY3Rpb24oZmlsZUVudHJ5LCBzaXRlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUZTLmdldEZpbGVPYmplY3RGcm9tRmlsZUVudHJ5KGZpbGVFbnRyeSkudGhlbihmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jb25maXJtVXBsb2FkRmlsZShmaWxlLnNpemUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYudXBsb2FkR2VuZXJpY0ZpbGUoZmlsZUVudHJ5LnRvVVJMKCksIGZpbGUubmFtZSwgZmlsZS50eXBlLCBzaXRlaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgbXkgZmlsZXMgcm9vdCBkaXIgc28gdGhlIGxpc3QgaXMgcmVmcmVzaGVkIHdoZW4gdGhlIHVzZXIgZ29lcyBpbi5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFGaWxlcy5pbnZhbGlkYXRlRGlyZWN0b3J5KCdteScsIHVuZGVmaW5lZCwgc2l0ZWlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93TW9kYWwoJ21tLmNvcmUuc3VjY2VzcycsICdtbWEuZmlsZXMuZmlsZXVwbG9hZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5maWxlcy5lcnJvcnJlYWRpbmdmaWxlJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyZWF0IGEgY2FwdHVyZSBpbWFnZSBvciBicm93c2UgYWxidW0gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVycm9yICAgICAgICAgIEVycm9yIHJldHVybmVkIGJ5IHRoZSBDb3Jkb3ZhIHBsdWdpbi5cbiAgICAgKiBAcGFyYW0gIHtQcm9taXNlfSBkZWZlcnJlZCAgICAgIFByb21pc2UgdG8gcmVqZWN0LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZGVmYXVsdE1lc3NhZ2UgS2V5IG9mIHRoZSBkZWZhdWx0IG1lc3NhZ2UgdG8gc2hvdy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmVhdEltYWdlRXJyb3IoZXJyb3IsIGRlZmVycmVkLCBkZWZhdWx0TWVzc2FnZSkge1xuICAgICAgICAvLyBDYW5jZWxsZWQsIG9yIGVycm9yLiBJZiBjYW5jZWxsZWQsIGVycm9yIGlzIGEgc3RyaW5nIHdpdGggXCJTZWxlY3Rpb24gY2FuY2VsbGVkLlwiIG9yIFwiQ2FtZXJhIGNhbmNlbGxlZC5cIi5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGVycm9yKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiZXJyb3JcIikgPiAtMSB8fCBlcnJvci50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ1bmFibGVcIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciBnZXR0aW5nIGltYWdlOiAnICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0NhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsIGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJlYXQgYSBjYXB0dXJlIGF1ZGlvL3ZpZGVvIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TWl4ZWR9IGVycm9yICAgICAgICAgICBFcnJvciByZXR1cm5lZCBieSB0aGUgQ29yZG92YSBwbHVnaW4uIENhbiBiZSBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gICAgICogQHBhcmFtICB7UHJvbWlzZX0gZGVmZXJyZWQgICAgICBQcm9taXNlIHRvIHJlamVjdC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRlZmF1bHRNZXNzYWdlIEtleSBvZiB0aGUgZGVmYXVsdCBtZXNzYWdlIHRvIHNob3cuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJlYXRDYXB0dXJlRXJyb3IoZXJyb3IsIGRlZmVycmVkLCBkZWZhdWx0TWVzc2FnZSkge1xuICAgICAgICAvLyBDYW5jZWxsZWQsIG9yIGVycm9yLiBJZiBjYW5jZWxsZWQsIGVycm9yIGlzIGFuIG9iamVjdCB3aXRoIGNvZGUgPSAzLlxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZXJyb3IpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIHdoaWxlIHJlY29yZGluZyBhdWRpby92aWRlbzogJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuaW5kZXhPZignTm8gQWN0aXZpdHkgZm91bmQnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgZG9lc24ndCBoYXZlIGFuIGFwcCB0byBkbyB0aGlzLlxuICAgICAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW1hLmZpbGVzLmVycm9ybm9hcHAnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCBkZWZhdWx0TWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yLCBub3QgY2FuY2VsbGVkLlxuICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciB3aGlsZSByZWNvcmRpbmcgYXVkaW8vdmlkZW86ICcgKyBKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCBkZWZhdWx0TWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ2FuY2VsbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmZyb250cGFnZScpXG5cbi8qKlxuICogRnJvbnRwYWdlIGZhY3RvcnkuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuZnJvbnRwYWdlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYUZyb250cGFnZVxuICovXG4uZmFjdG9yeSgnJG1tYUZyb250cGFnZScsIGZ1bmN0aW9uKCRtbVNpdGUsICRsb2csICRxLCAkbW1Db3Vyc2UpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYUZyb250cGFnZScpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBpcyBlbmFibGVkIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHF1aXRlIG9mdGVuIGFuZCB0aHVzIHNob3VsZCBvbmx5IHBlcmZvcm0gYSBxdWlja1xuICAgICAqIGNoZWNrLCB3ZSBzaG91bGQgbm90IGJlIGNhbGxpbmcgV1MgZnJvbSBoZXJlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZnJvbnRwYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGcm9udHBhZ2UjaXNQbHVnaW5FbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBmcm9udHBhZ2UgaXMgYXZhaWxhYmxlIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAqXG4gICAgICogVGhpcyBjb3VsZCBjYWxsIGEgV1Mgc28gZG8gbm90IGFidXNlIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZnJvbnRwYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGcm9udHBhZ2UjaXNGcm9udHBhZ2VBdmFpbGFibGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGVuYWJsZWQsIG90aGVyd2lzZSByZWplY3RlZC5cbiAgICAgKi9cbiAgICBzZWxmLmlzRnJvbnRwYWdlQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gT24gb2xkZXIgdmVyc2lvbiB3ZSBjYW5ub3QgY2hlY2sgb3RoZXIgdGhhbiBjYWxsaW5nIGEgV1MuIElmIHRoZSByZXF1ZXN0XG4gICAgICAgIC8vIGZhaWxzIHRoZXJlIGlzIGEgdmVyeSBoaWdoIGNoYW5jZSB0aGF0IGZyb250cGFnZSBpcyBub3QgYXZhaWxhYmxlLlxuICAgICAgICAkbG9nLmRlYnVnKCdVc2luZyBXUyBjYWxsIHRvIGNoZWNrIGlmIGZyb250cGFnZSBpcyBhdmFpbGFibGUuJyk7XG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2UuZ2V0U2VjdGlvbnMoMSwge2VtZXJnZW5jeUNhY2hlOiBmYWxzZX0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFhbmd1bGFyLmlzQXJyYXkoZGF0YSkgfHwgZGF0YS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5mcm9udHBhZ2UnKVxuXG4vKipcbiAqIEZyb250IHBhZ2UgaGFuZGxlcnMgZmFjdG9yeS5cbiAqXG4gKiBUaGlzIGZhY3RvcnkgaG9sZHMgdGhlIGRpZmZlcmVudCBoYW5kbGVycyB1c2VkIGZvciBkZWxlZ2F0ZXMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuZnJvbnRwYWdlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYUZyb250UGFnZUhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hRnJvbnRQYWdlSGFuZGxlcnMnLCBmdW5jdGlvbigkbG9nLCAkbW1hRnJvbnRwYWdlKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFGcm9udFBhZ2VIYW5kbGVycycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFNpZGUgbWVudSBuYXYgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZyb250cGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRnJvbnRQYWdlSGFuZGxlcnMjc2lkZU1lbnVOYXZcbiAgICAgKi9cbiAgICBzZWxmLnNpZGVNZW51TmF2ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfEJvb2xlYW59IElmIGhhbmRsZXIgaXMgZW5hYmxlZCByZXR1cm5zIGEgcmVzb2x2ZWQgcHJvbWlzZS4gSWYgaXQncyBub3QgaXQgY2FuIHJldHVybiBhXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWQgcHJvbWlzZSBvciBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJG1tYUZyb250cGFnZS5pc1BsdWdpbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hRnJvbnRwYWdlLmlzRnJvbnRwYWdlQXZhaWxhYmxlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBDb250cm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2lkZSBtZW51IG5hdiBoYW5kbGVyIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZnJvbnRwYWdlXG4gICAgICAgICAgICAgKiBAbmdkb2MgY29udHJvbGxlclxuICAgICAgICAgICAgICogQG5hbWUgJG1tYUZyb250UGFnZUhhbmRsZXJzI3NpZGVNZW51TmF2OmNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJ2lvbi1ob21lJztcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLmZyb250cGFnZS5zaXRlaG9tZSc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnN0YXRlID0gJ3NpdGUubW1fY291cnNlLXNlY3Rpb24nO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmdyYWRlcycpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgY291cnNlIGdyYWRlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5ncmFkZXNcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFHcmFkZXNUYWJsZUN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYUdyYWRlc1RhYmxlQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1VdGlsLCAkbW1hR3JhZGVzLCAkbW1TaXRlKSB7XG5cbiAgICB2YXIgY291cnNlID0gJHN0YXRlUGFyYW1zLmNvdXJzZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSBjb3Vyc2UuaWQsXG4gICAgICAgIHVzZXJpZCA9ICRzdGF0ZVBhcmFtcy51c2VyaWQgfHwgJG1tU2l0ZS5nZXRVc2VySWQoKTtcblxuICAgIGZ1bmN0aW9uIGZldGNoR3JhZGVzKHJlZnJlc2gpIHtcbiAgICAgICAgcmV0dXJuICRtbWFHcmFkZXMuZ2V0R3JhZGVzVGFibGUoY291cnNlaWQsIHVzZXJpZCwgcmVmcmVzaCkudGhlbihmdW5jdGlvbih0YWJsZSkge1xuICAgICAgICAgICAgJHNjb3BlLmdyYWRlc1RhYmxlID0gdGFibGU7XG4gICAgICAgIH0sIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICAkc2NvcGUuZXJyb3JtZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoR3JhZGVzKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQWRkIGxvZyBpbiBNb29kbGUuXG4gICAgICAgICRtbVNpdGUud3JpdGUoJ2dyYWRlcmVwb3J0X3VzZXJfdmlld19ncmFkZV9yZXBvcnQnLCB7XG4gICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlaWQsXG4gICAgICAgICAgICB1c2VyaWQ6IHVzZXJpZFxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuZ3JhZGVzTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgICRzY29wZS5yZWZyZXNoR3JhZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZldGNoR3JhZGVzKHRydWUpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5ncmFkZXMnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gaGFuZGxlIGdyYWRlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5ncmFkZXNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hR3JhZGVzXG4gKi9cbi5mYWN0b3J5KCckbW1hR3JhZGVzJywgZnVuY3Rpb24oJHEsICRsb2csICRtbVNpdGUsICRtbVRleHQsICRpb25pY1BsYXRmb3JtLCAkdHJhbnNsYXRlLCAkbW1Db3Vyc2UsICRtbUNvdXJzZXMsICRtbVNpdGVzTWFuYWdlcikge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFHcmFkZXMnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIHRoZSByZXNwb25zZSBvZiBncmFkZXJlcG9ydF91c2VyX2dldF9ncmFkZXNfdGFibGUgdG8gYmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICB0YWJsZSAgICAgIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyBhIHRhYmxlIHdpdGggZGF0YS5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBzaG93U2ltcGxlIFRydWUgaWYgc2ltcGxlIHRhYmxlIHNob3VsZCBiZSBzaG93biwgZmFsc2UgZm9yIGZ1bGwgdGFibGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICBGb3JtYXR0ZWQgSFRNTCB0YWJsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXRHcmFkZXNUYWJsZSh0YWJsZSwgc2hvd1NpbXBsZSkge1xuICAgICAgICB2YXIgZm9ybWF0dGVkID0ge1xuICAgICAgICAgICAgY29sdW1uczogW10sXG4gICAgICAgICAgICByb3dzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghdGFibGUgfHwgIXRhYmxlLnRhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbHVtbnMsIGJ5IG9yZGVyLlxuICAgICAgICB2YXIgY29sdW1ucyA9IFsgXCJpdGVtbmFtZVwiLCBcIndlaWdodFwiLCBcImdyYWRlXCIsIFwicmFuZ2VcIiwgXCJwZXJjZW50YWdlXCIsIFwibGV0dGVyZ3JhZGVcIiwgXCJyYW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImF2ZXJhZ2VcIiwgXCJmZWVkYmFja1wiLCBcImNvbnRyaWJ1dGlvbnRvY291cnNldG90YWxcIl07XG4gICAgICAgIHZhciByZXR1cm5lZENvbHVtbnMgPSBbXTtcblxuICAgICAgICB2YXIgdGFibGVkYXRhID0gW107XG4gICAgICAgIHZhciBtYXhEZXB0aCA9IDA7XG4gICAgICAgIC8vIENoZWNrIGNvbHVtbnMgcmV0dXJuZWQgKG1heWJlIHNvbWUgb2YgdGhlIGFib3ZlKS5cbiAgICAgICAgaWYgKHRhYmxlLnRhYmxlcyAmJiB0YWJsZS50YWJsZXNbMF0gJiYgdGFibGUudGFibGVzWzBdWyd0YWJsZWRhdGEnXSkge1xuICAgICAgICAgICAgdGFibGVkYXRhID0gdGFibGUudGFibGVzWzBdWyd0YWJsZWRhdGEnXTtcbiAgICAgICAgICAgIG1heERlcHRoID0gdGFibGUudGFibGVzWzBdWydtYXhkZXB0aCddO1xuICAgICAgICAgICAgZm9yICh2YXIgZWwgaW4gdGFibGVkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHR5cGljYWwgcm93LlxuICAgICAgICAgICAgICAgIGlmICghYW5ndWxhci5pc0FycmF5KHRhYmxlZGF0YVtlbF0pICYmIHR5cGVvZih0YWJsZWRhdGFbZWxdW1wibGVhZGVyXCJdKSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgaW4gdGFibGVkYXRhW2VsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWRDb2x1bW5zLnB1c2goY29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0dXJuZWRDb2x1bW5zLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgLy8gUmVkdWNlIHRoZSByZXR1cm5lZCBjb2x1bW5zIGZvciBwaG9uZSB2ZXJzaW9uLlxuICAgICAgICAgICAgaWYgKHNob3dTaW1wbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5lZENvbHVtbnMgPSBbXCJpdGVtbmFtZVwiLCBcImdyYWRlXCJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBlbCBpbiBjb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbE5hbWUgPSBjb2x1bW5zW2VsXTtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWRDb2x1bW5zLmluZGV4T2YoY29sTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBjb2xOYW1lID09IFwiaXRlbW5hbWVcIiA/IG1heERlcHRoIDogMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWQuY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmFtZSwgcm93c3BhbiwgdGNsYXNzLCBjb2xzcGFuLCBjb250ZW50LCBjZWxsdHlwZSwgaWQsIGhlYWRlcnMsaiwgaW1nLCBjb2xzcGFuVmFsO1xuXG4gICAgICAgICAgICB2YXIgbGVuID0gdGFibGVkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZih0YWJsZWRhdGFbaV1bJ2xlYWRlciddKSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd3NwYW4gPSB0YWJsZWRhdGFbaV1bJ2xlYWRlciddWydyb3dzcGFuJ107XG4gICAgICAgICAgICAgICAgICAgIHRjbGFzcyA9IHRhYmxlZGF0YVtpXVsnbGVhZGVyJ11bJ2NsYXNzJ107XG4gICAgICAgICAgICAgICAgICAgIHJvdyArPSAnPHRkIGNsYXNzPVwiJyArIHRjbGFzcyArICdcIiByb3dzcGFuPVwiJyArIHJvd3NwYW4gKyAnXCI+PC90ZD4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGVsIGluIHJldHVybmVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gcmV0dXJuZWRDb2x1bW5zW2VsXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHRhYmxlZGF0YVtpXVtuYW1lXSkgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGNsYXNzID0gKHR5cGVvZih0YWJsZWRhdGFbaV1bbmFtZV1bJ2NsYXNzJ10pICE9IFwidW5kZWZpbmVkXCIpPyB0YWJsZWRhdGFbaV1bbmFtZV1bJ2NsYXNzJ10gOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHNwYW4gPSAodHlwZW9mKHRhYmxlZGF0YVtpXVtuYW1lXVsnY29sc3BhbiddKSAhPSBcInVuZGVmaW5lZFwiKT8gXCJjb2xzcGFuPSdcIit0YWJsZWRhdGFbaV1bbmFtZV1bJ2NvbHNwYW4nXStcIidcIiA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9ICh0eXBlb2YodGFibGVkYXRhW2ldW25hbWVdWydjb250ZW50J10pICE9IFwidW5kZWZpbmVkXCIpPyB0YWJsZWRhdGFbaV1bbmFtZV1bJ2NvbnRlbnQnXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsdHlwZSA9ICh0eXBlb2YodGFibGVkYXRhW2ldW25hbWVdWydjZWxsdHlwZSddKSAhPSBcInVuZGVmaW5lZFwiKT8gdGFibGVkYXRhW2ldW25hbWVdWydjZWxsdHlwZSddIDogJ3RkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gKHR5cGVvZih0YWJsZWRhdGFbaV1bbmFtZV1bJ2lkJ10pICE9IFwidW5kZWZpbmVkXCIpPyBcImlkPSdcIiArIHRhYmxlZGF0YVtpXVtuYW1lXVsnaWQnXSArXCInXCIgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgPSAodHlwZW9mKHRhYmxlZGF0YVtpXVtuYW1lXVsnaGVhZGVycyddKSAhPSBcInVuZGVmaW5lZFwiKT8gXCJoZWFkZXJzPSdcIiArIHRhYmxlZGF0YVtpXVtuYW1lXVsnaGVhZGVycyddICsgXCInXCIgOiAnJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjb250ZW50KSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nID0gZ2V0SW1nSFRNTChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC88XFwvc3Bhbj4vZ2ksIFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSAkbW1UZXh0LmNsZWFuVGFncyhjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKFwiXFxuXCIsIFwiPGJyIC8+XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBpbWcgKyBcIiBcIiArIGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgKz0gXCI8XCIgKyBjZWxsdHlwZSArIFwiIFwiICsgaWQgKyBcIiBcIiArIGhlYWRlcnMgKyBcIiBcIiArIFwiY2xhc3M9J1wiKyB0Y2xhc3MgK1wiJyBcIiArIGNvbHNwYW4gK1wiPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyArPSBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyArPSBcIjwvXCIgKyBjZWxsdHlwZSArIFwiPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZC5yb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgSFRNTCBjb2RlIHRvIHJlbmRlciB0aGUgY29udGVudHMgaW1nLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0IEhUTUwgd2hlcmUgdGhlIGltYWdlIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgIEhUTUwgY29kZSB0byByZW5kZXIgdGhlIGltYWdlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEltZ0hUTUwodGV4dCkge1xuICAgICAgICB2YXIgaW1nID0gJyc7XG5cbiAgICAgICAgaWYgKHRleHQuaW5kZXhPZihcIi9hZ2dfbWVhblwiKSA+IC0xKSB7XG4gICAgICAgICAgICBpbWcgPSAnPGltZyBzcmM9XCJhZGRvbnMvZ3JhZGVzL2ltZy9hZ2dfbWVhbi5wbmdcIiB3aWR0aD1cIjE2XCI+JztcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0LmluZGV4T2YoXCIvYWdnX3N1bVwiKSA+IC0xKSB7XG4gICAgICAgICAgICBpbWcgPSAnPGltZyBzcmM9XCJhZGRvbnMvZ3JhZGVzL2ltZy9hZ2dfc3VtLnBuZ1wiIHdpZHRoPVwiMTZcIj4nO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQuaW5kZXhPZihcIi9vdXRjb21lc1wiKSA+IC0xKSB7XG4gICAgICAgICAgICBpbWcgPSAnPGltZyBzcmM9XCJhZGRvbnMvZ3JhZGVzL2ltZy9vdXRjb21lcy5wbmdcIiB3aWR0aD1cIjE2XCI+JztcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0LmluZGV4T2YoXCJpL2ZvbGRlclwiKSA+IC0xKSB7XG4gICAgICAgICAgICBpbWcgPSAnPGltZyBzcmM9XCJhZGRvbnMvZ3JhZGVzL2ltZy9mb2xkZXIucG5nXCIgd2lkdGg9XCIxNlwiPic7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dC5pbmRleE9mKFwiL21hbnVhbF9pdGVtXCIpID4gLTEpIHtcbiAgICAgICAgICAgIGltZyA9ICc8aW1nIHNyYz1cImFkZG9ucy9ncmFkZXMvaW1nL21hbnVhbF9pdGVtLnBuZ1wiIHdpZHRoPVwiMTZcIj4nO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQuaW5kZXhPZihcIi9tb2QvXCIpID4gLTEpIHtcbiAgICAgICAgICAgIHZhciBtb2R1bGUgPSB0ZXh0Lm1hdGNoKC9tb2RcXC8oW15cXC9dKilcXC8vKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW9kdWxlWzFdICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlU3JjID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMobW9kdWxlWzFdKTtcbiAgICAgICAgICAgICAgICBpbWcgPSAnPGltZyBzcmM9XCInICsgbW9kdWxlU3JjICsgJ1wiIHdpZHRoPVwiMTZcIj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbWcpIHtcbiAgICAgICAgICAgIGltZyA9ICc8c3BhbiBjbGFzcz1cImFwcC1pY29cIj4nICsgaW1nICsgJzwvc3Bhbj4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgbmFtZXMgb2YgdGhlIGdyYWRlcyB0YWJsZSBjb2x1bW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB0YWJsZSBHcmFkZXMgdGFibGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdpdGggdGhlIHRyYW5zbGF0ZWQgdGFibGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlR3JhZGVzVGFibGUodGFibGUpIHtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBhbmd1bGFyLmNvcHkodGFibGUuY29sdW1ucyksXG4gICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gJHRyYW5zbGF0ZSgnbW1hLmdyYWRlcy4nK2NvbHVtbi5uYW1lKS50aGVuKGZ1bmN0aW9uKHRyYW5zbGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4ubmFtZSA9IHRyYW5zbGF0ZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICAgICAgICAgICAgcm93czogdGFibGUucm93c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmdyYWRlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hR3JhZGVzI2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgIFRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUud3NBdmFpbGFibGUoJ2dyYWRlcmVwb3J0X3VzZXJfZ2V0X2dyYWRlc190YWJsZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZ3JhZGUgYWRkb24gaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIGNvdXJzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmdyYWRlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hR3JhZGVzI2lzUGx1Z2luRW5hYmxlZEZvckNvdXJzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCAgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIHBsdWdpbiBpcyBlbmFibGVkLCByZWplY3RlZCBvciByZXNvbHZlZCB3aXRoIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZEZvckNvdXJzZSA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBzaXRlSWQpIHtcbiAgICAgICAgaWYgKCFjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbUNvdXJzZXMuZ2V0VXNlckNvdXJzZShjb3Vyc2VJZCwgdHJ1ZSwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGNvdXJzZSkge1xuICAgICAgICAgICAgaWYgKGNvdXJzZSAmJiB0eXBlb2YgY291cnNlLnNob3dncmFkZXMgIT0gJ3VuZGVmaW5lZCcgJiYgIWNvdXJzZS5zaG93Z3JhZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGdyYWRlcyBmb3IgYSBjZXJ0YWluIGNvdXJzZS5cbiAgICAgKiBGb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBncmFkZXJlcG9ydF91c2VyX2dldF9ncmFkZXNfdGFibGUuIEl0IHJldHVybnMgdGhlIGNvbXBsZXRlIGdyYWRlcyB0YWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmdyYWRlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hR3JhZGVzI2dldEdyYWRlc1RhYmxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIElEIG9mIHRoZSBjb3Vyc2UgdG8gZ2V0IHRoZSBncmFkZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdXNlcmlkICAgSUQgb2YgdGhlIHVzZXIgdG8gZ2V0IHRoZSBncmFkZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZnJlc2ggVHJ1ZSB3aGVuIHdlIHNob3VsZCBub3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBncmFkZXMgdGFibGUgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0R3JhZGVzVGFibGUgPSBmdW5jdGlvbihjb3Vyc2VpZCwgdXNlcmlkLCByZWZyZXNoKSB7XG5cbiAgICAgICAgJGxvZy5kZWJ1ZygnR2V0IGdyYWRlcyBmb3IgY291cnNlICcgKyBjb3Vyc2VpZCArICcgYW5kIHVzZXIgJyArIHVzZXJpZCk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgY291cnNlaWQgOiBjb3Vyc2VpZCxcbiAgICAgICAgICAgICAgICB1c2VyaWQgICA6IHVzZXJpZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXNldHMgPSB7fTtcbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgIHByZXNldHMuZ2V0RnJvbUNhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdncmFkZXJlcG9ydF91c2VyX2dldF9ncmFkZXNfdGFibGUnLCBkYXRhLCBwcmVzZXRzKS50aGVuKGZ1bmN0aW9uKHRhYmxlKSB7XG4gICAgICAgICAgICB0YWJsZSA9IGZvcm1hdEdyYWRlc1RhYmxlKHRhYmxlLCAhJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlR3JhZGVzVGFibGUodGFibGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmdyYWRlcycpXG5cbi8qKlxuICogR3JhZGVzIGhhbmRsZXJzIGZhY3RvcnkuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuZ3JhZGVzXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYUdyYWRlc0hhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hR3JhZGVzSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1hR3JhZGVzLCAkc3RhdGUsICRtbVV0aWwsICRtbUNvbnRlbnRMaW5rc0hlbHBlciwgbW1Db3Vyc2VzQWNjZXNzTWV0aG9kcykge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvdXJzZSBuYXYgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmdyYWRlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hR3JhZGVzSGFuZGxlcnMjY291cnNlc05hdlxuICAgICAqL1xuICAgIHNlbGYuY291cnNlc05hdiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFHcmFkZXMuaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgdGhpcyBjb3Vyc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCAgIENvdXJzZSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFjY2Vzc0RhdGEgVHlwZSBvZiBhY2Nlc3MgdG8gdGhlIGNvdXJzZTogZGVmYXVsdCwgZ3Vlc3QsIC4uLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZEZvckNvdXJzZSA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBhY2Nlc3NEYXRhKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXNzRGF0YSAmJiBhY2Nlc3NEYXRhLnR5cGUgPT0gbW1Db3Vyc2VzQWNjZXNzTWV0aG9kcy5ndWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm90IGVuYWJsZWQgZm9yIGd1ZXN0cy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkbW1hR3JhZGVzLmlzUGx1Z2luRW5hYmxlZEZvckNvdXJzZShjb3Vyc2VJZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIENvbnRyb2xsZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb3Vyc2VzIG5hdiBoYW5kbGVyIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZ3JhZGVzXG4gICAgICAgICAgICAgKiBAbmdkb2MgY29udHJvbGxlclxuICAgICAgICAgICAgICogQG5hbWUgJG1tYUdyYWRlc0hhbmRsZXJzI2NvdXJzZXNOYXY6Y29udHJvbGxlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICdpb24tc3RhdHMtYmFycyc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5ncmFkZXMuZ3JhZGVzJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oJGV2ZW50LCBjb3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLmdyYWRlcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdXJzZTogY291cnNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWaWV3IGdyYWRlcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZ3JhZGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFHcmFkZXNIYW5kbGVycyN2aWV3R3JhZGVzXG4gICAgICovXG4gICAgc2VsZi52aWV3R3JhZGVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYUdyYWRlcy5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkIGZvciB0aGlzIHVzZXIgaW4gdGhpcyBjb250ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlciAgICAgVXNlciB0byBjaGVjay5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIHBsdWdpbiBpcyBlbmFibGVkLCByZWplY3RlZCBvciByZXNvbHZlZCB3aXRoIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkRm9yVXNlciA9IGZ1bmN0aW9uKHVzZXIsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYUdyYWRlcy5pc1BsdWdpbkVuYWJsZWRGb3JDb3Vyc2UoY291cnNlSWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIHRoaXMgdXNlciBpbiB0aGlzIGNvbnRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyICAgICBVc2VyLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgQ291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgQ29udHJvbGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKHVzZXIsIGNvdXJzZUlkKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmlldyBncmFkZXMgaGFuZGxlciBjb250cm9sbGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmdyYWRlc1xuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFHcmFkZXNIYW5kbGVycyN2aWV3R3JhZGVzOmNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEuZ3JhZGVzLnZpZXdncmFkZXMnO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUuZ3JhZGVzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmlkOiB1c2VyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY291cnNlOiB7aWQ6IGNvdXJzZUlkfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ncmFkZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUdyYWRlc0hhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUgYW5kIGNvdXJzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICBTaXRlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hR3JhZGVzLmlzUGx1Z2luRW5hYmxlZChzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hR3JhZGVzLmlzUGx1Z2luRW5hYmxlZEZvckNvdXJzZShjb3Vyc2VJZCwgc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0W119ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgZ3JhZGUgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvZ3JhZGUvcmVwb3J0L3VzZXIvaW5kZXgucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSAkbW1VdGlsLmV4dHJhY3RVcmxQYXJhbXModXJsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5pZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291cnNlSWQgPSBwYXJzZUludChwYXJhbXMuaWQsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBmYWxzZSBiZWNhdXNlIGFsbCBzaXRlcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaXRldXJsLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLmZpbHRlclN1cHBvcnRlZFNpdGVzKHNpdGVJZHMsIGlzRW5hYmxlZCwgZmFsc2UsIGNvdXJzZUlkKS50aGVuKGZ1bmN0aW9uKGlkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ21tLmNvcmUudmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tZXllJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZXM6IGlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3Vyc2U6IHtpZDogY291cnNlSWR9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJpZDogcGFyc2VJbnQocGFyYW1zLnVzZXJpZCwgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tQ29udGVudExpbmtzSGVscGVyLmdvSW5TaXRlKCdzaXRlLmdyYWRlcycsIHN0YXRlUGFyYW1zLCBzaXRlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1lc3NhZ2VzJylcblxuLyoqXG4gKiBDb250YWN0cyBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTWVzc2FnZXNDb250YWN0c0N0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1lc3NhZ2VzQ29udGFjdHNDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkbW1hTWVzc2FnZXMsICRtbVNpdGUsICRtbVV0aWwsICRtbUFwcCwgbW1Vc2VyUHJvZmlsZVN0YXRlKSB7XG5cbiAgICB2YXIgY3VycmVudFVzZXJJZCA9ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAkc2NvcGUubG9hZGVkID0gZmFsc2U7XG4gICAgJHNjb3BlLmNvbnRhY3RUeXBlcyA9IFsnb25saW5lJywgJ29mZmxpbmUnLCAnYmxvY2tlZCcsICdzdHJhbmdlcnMnLCAnc2VhcmNoJ107XG4gICAgJHNjb3BlLnNlYXJjaFR5cGUgPSAnc2VhcmNoJztcbiAgICAkc2NvcGUuaGFzQ29udGFjdHMgPSBmYWxzZTtcbiAgICAkc2NvcGUuY2FuU2VhcmNoID0gJG1tYU1lc3NhZ2VzLmlzU2VhcmNoRW5hYmxlZDtcbiAgICAkc2NvcGUuZm9ybURhdGEgPSB7XG4gICAgICAgIHNlYXJjaFN0cmluZzogJydcbiAgICB9O1xuICAgICRzY29wZS51c2VyU3RhdGVOYW1lID0gbW1Vc2VyUHJvZmlsZVN0YXRlO1xuXG4gICAgJHNjb3BlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYU1lc3NhZ2VzLmludmFsaWRhdGVBbGxDb250YWN0c0NhY2hlKGN1cnJlbnRVc2VySWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hDb250YWN0cyh0cnVlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5mb3JtRGF0YS5zZWFyY2hTdHJpbmcgPSAnJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5zZWFyY2ggPSBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICBpZiAocXVlcnkubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgLy8gVGhlIHZpZXcgc2hvdWxkIGhhbmRsZSB0aGlzIGNhc2UsIGJ1dCBhZGRpbmcgdGhpcyBjaGVjayBoZXJlIHRvIGRvY3VtZW50IHRoYXRcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHVzZXJzIHRvIHF1ZXJ5IG9uIGxlc3MgdGhhbiAzIGNoYXJhY3RlcnMgYXMgdGhleSBjb3VsZCByZXRyaWV2ZVxuICAgICAgICAgICAgLy8gdG9vIG1hbnkgdXNlcnMhXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAkbW1BcHAuY2xvc2VLZXlib2FyZCgpO1xuXG4gICAgICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICRtbWFNZXNzYWdlcy5zZWFyY2hDb250YWN0cyhxdWVyeSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICRzY29wZS5oYXNDb250YWN0cyA9IHJlc3VsdC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgJHNjb3BlLmNvbnRhY3RzID0ge1xuICAgICAgICAgICAgICAgIHNlYXJjaDogcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1lc3NhZ2VzLmVycm9yd2hpbGVyZXRyaWV2aW5nY29udGFjdHMnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLmNsZWFyU2VhcmNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgZmV0Y2hDb250YWN0cygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZldGNoQ29udGFjdHMoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMuZ2V0QWxsQ29udGFjdHMoKS50aGVuKGZ1bmN0aW9uKGNvbnRhY3RzKSB7XG4gICAgICAgICAgICAkc2NvcGUuY29udGFjdHMgPSBjb250YWN0cztcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbnRhY3RzLCBmdW5jdGlvbihjb250YWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaGFzQ29udGFjdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1lc3NhZ2VzLmVycm9yd2hpbGVyZXRyaWV2aW5nY29udGFjdHMnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQ29udGFjdHMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcbn0pO1xuXG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tZXNzYWdlcycpXG5cbi8qKlxuICogRGlzY3Vzc2lvbiBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTWVzc2FnZXNEaXNjdXNzaW9uQ3RybFxuICovXG4uY29udHJvbGxlcignbW1hTWVzc2FnZXNEaXNjdXNzaW9uQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1BcHAsICRtbWFNZXNzYWdlcywgJG1tU2l0ZSwgJHRpbWVvdXQsICRtbUV2ZW50cywgJHdpbmRvdyxcbiAgICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUsIG1tVXNlclByb2ZpbGVTdGF0ZSwgJG1tVXRpbCwgbW1hTWVzc2FnZXNQb2xsSW50ZXJ2YWwsICRpbnRlcnZhbCwgJGxvZywgJGlvbmljSGlzdG9yeSwgJGlvbmljUGxhdGZvcm0sXG4gICAgICAgIG1tQ29yZUV2ZW50S2V5Ym9hcmRTaG93LCBtbUNvcmVFdmVudEtleWJvYXJkSGlkZSwgbW1hTWVzc2FnZXNEaXNjdXNzaW9uTG9hZGVkRXZlbnQsIG1tYU1lc3NhZ2VzRGlzY3Vzc2lvbkxlZnRFdmVudCxcbiAgICAgICAgJG1tVXNlcikge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tYU1lc3NhZ2VzRGlzY3Vzc2lvbkN0cmwnKTtcblxuICAgIHZhciB1c2VySWQgPSAkc3RhdGVQYXJhbXMudXNlcklkLFxuICAgICAgICB1c2VyRnVsbG5hbWUgPSAkc3RhdGVQYXJhbXMudXNlckZ1bGxuYW1lLFxuICAgICAgICBtZXNzYWdlc0JlaW5nU2VudCA9IDAsXG4gICAgICAgIHBvbGxpbmcsXG4gICAgICAgIGJhY2tWaWV3ID0gJGlvbmljSGlzdG9yeS5iYWNrVmlldygpLFxuICAgICAgICBsYXN0TWVzc2FnZSxcbiAgICAgICAgc2Nyb2xsVmlldyA9ICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnbW1hTWVzc2FnZXNTY3JvbGwnKTtcblxuICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAkc2NvcGUubWVzc2FnZXMgPSBbXTtcbiAgICAkc2NvcGUudXNlcklkID0gdXNlcklkO1xuICAgICRzY29wZS5jdXJyZW50VXNlcklkID0gJG1tU2l0ZS5nZXRVc2VySWQoKTtcbiAgICAkc2NvcGUucHJvZmlsZUxpbmsgPSB0cnVlO1xuXG4gICAgaWYgKHVzZXJGdWxsbmFtZSkge1xuICAgICAgICAkc2NvcGUudGl0bGUgPSB1c2VyRnVsbG5hbWU7XG4gICAgfSBlbHNlIGlmICh1c2VySWQpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0aGUgZnVsbG5hbWUsIHRyeSB0byBnZXQgaXQuXG4gICAgICAgICRtbVVzZXIuZ2V0UHJvZmlsZSh1c2VySWQpLnRoZW4oZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUudGl0bGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSB1c2VyLmZ1bGxuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIHRoZSBwcm9maWxlIGJ1dHRvbiBpZiB3ZSdyZSBjb21pbmcgZnJvbSBhIHByb2ZpbGUuIEl0IGlzIHNhZmVyIHRvIHByZXZlbnQgZm9yYmlkIHRoZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZnVsbCBwcm9maWxlICh3ZSBkbyBub3Qga25vdyB0aGUgY291cnNlIElEIHRoZXkgY2FtZSBmcm9tKSBhcyBzb21lIHVzZXJzIGNhbm5vdCB2aWV3IHRoZSBmdWxsXG4gICAgLy8gcHJvZmlsZSBvZiBvdGhlciB1c2Vycy5cbiAgICBpZiAoYmFja1ZpZXcgJiYgYmFja1ZpZXcuc3RhdGVOYW1lID09PSBtbVVzZXJQcm9maWxlU3RhdGUpIHtcbiAgICAgICAgJHNjb3BlLnByb2ZpbGVMaW5rID0gZmFsc2U7XG4gICAgfVxuXG4gICAgJHNjb3BlLmlzQXBwT2ZmbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISRtbUFwcC5pc09ubGluZSgpO1xuICAgIH07XG5cbiAgICAkc2NvcGUuc2hvd0RhdGUgPSBmdW5jdGlvbihtZXNzYWdlLCBwcmV2TWVzc2FnZSkge1xuICAgICAgICBpZiAoIXByZXZNZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGRheSBoYXMgY2hhbmdlZC5cbiAgICAgICAgcmV0dXJuICFtb21lbnQobWVzc2FnZS50aW1lY3JlYXRlZCAqIDEwMDApLmlzU2FtZShwcmV2TWVzc2FnZS50aW1lY3JlYXRlZCAqIDEwMDAsICdkYXknKTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgaWYgKCEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgLy8gU2lsZW50IGVycm9yLCB0aGUgdmlldyBzaG91bGQgcHJldmVudCB0aGlzLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKCF0ZXh0LnRyaW0oKSkge1xuICAgICAgICAgICAgLy8gU2lsZW50IGVycm9yLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvKD86XFxyXFxufFxccnxcXG4pL2csICc8YnIgLz4nKTtcbiAgICAgICAgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHNlbmRpbmc6IHRydWUsXG4gICAgICAgICAgICB1c2VyaWRmcm9tOiAkc2NvcGUuY3VycmVudFVzZXJJZCxcbiAgICAgICAgICAgIHNtYWxsbWVzc2FnZTogdGV4dCxcbiAgICAgICAgICAgIHRpbWVjcmVhdGVkOiAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDEwMDApXG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuXG4gICAgICAgIG1lc3NhZ2VzQmVpbmdTZW50Kys7XG4gICAgICAgICRtbWFNZXNzYWdlcy5zZW5kTWVzc2FnZSh1c2VySWQsIHRleHQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIG5vdGlmeU5ld01lc3NhZ2UoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcblxuICAgICAgICAgICAgLy8gT25seSBjbG9zZSB0aGUga2V5Ym9hcmQgaWYgYW4gZXJyb3IgaGFwcGVucywgd2Ugd2FudCB0aGUgdXNlciB0byBiZSBhYmxlIHRvIHNlbmQgbXVsdGlwbGVcbiAgICAgICAgICAgIC8vIG1lc3NhZ2VzIHdpdGhvdXR0aGUga2V5Ym9hcmQgYmVpbmcgY2xvc2VkLlxuICAgICAgICAgICAgJG1tQXBwLmNsb3NlS2V5Ym9hcmQoKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1lc3NhZ2VzLm1lc3NhZ2Vub3RzZW50JywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUubWVzc2FnZXMuc3BsaWNlKCRzY29wZS5tZXNzYWdlcy5pbmRleE9mKG1lc3NhZ2UpLCAxKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzQmVpbmdTZW50LS07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBGZXRjaCB0aGUgbWVzc2FnZXMgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgICRtbWFNZXNzYWdlcy5nZXREaXNjdXNzaW9uKHVzZXJJZCkudGhlbihmdW5jdGlvbihtZXNzYWdlcykge1xuICAgICAgICAkc2NvcGUubWVzc2FnZXMgPSAkbW1hTWVzc2FnZXMuc29ydE1lc3NhZ2VzKG1lc3NhZ2VzKTtcbiAgICAgICAgaWYgKCF1c2VyRnVsbG5hbWUgJiYgbWVzc2FnZXMgJiYgbWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBkaWQgbm90IHJlY2VpdmUgdGhlIGZ1bGxuYW1lIHZpYSBhcmd1bWVudC4gQWxzbyBpdCBpcyBwb3NzaWJsZSB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBjYW5ub3QgcmVzb2x2ZSB0aGUgbmFtZSB3aGVuIG5vIG1lc3NhZ2VzIHdlcmUgeWV0IGV4Y2hhbmdlZC5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlc1swXS51c2VyaWR0byAhPSAkc2NvcGUuY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1lc3NhZ2VzWzBdLnVzZXJ0b2Z1bGxuYW1lIHx8ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtZXNzYWdlc1swXS51c2VyZnJvbWZ1bGxuYW1lIHx8ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vdGlmeU5ld01lc3NhZ2UoKTtcbiAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubWVzc2FnZXMuZXJyb3J3aGlsZXJldHJpZXZpbmdtZXNzYWdlcycsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuc2Nyb2xsQWZ0ZXJSZW5kZXIgPSBmdW5jdGlvbihzY29wZSkge1xuICAgICAgICBpZiAoc2NvcGUuJGxhc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgYSB0aW1lb3V0IHRvIGxlYXZlIHRpbWUgdG8gdGhlIHZpZXcgdG8gYmUgcmVuZGVyZWQuXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxWaWV3LnNjcm9sbEJvdHRvbSgpO1xuICAgICAgICAgICAgICAgIHNldFNjcm9sbFdpdGhLZXlib2FyZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gU2V0IGEgcG9sbGluZyB0byBnZXQgbmV3IG1lc3NhZ2VzIGV2ZXJ5IGNlcnRhaW4gdGltZS5cbiAgICBmdW5jdGlvbiBzZXRQb2xsaW5nKCkge1xuICAgICAgICBpZiAocG9sbGluZykge1xuICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSBwb2xsaW5nIGluIHBsYWNlLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgcG9sbGluZy5cbiAgICAgICAgcG9sbGluZyA9ICRpbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1BvbGxpbmcgbmV3IG1lc3NhZ2VzIGZvciBkaXNjdXNzaW9uIHdpdGggdXNlciAnICsgdXNlcklkKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlc0JlaW5nU2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3QgcG9sbCB3aGlsZSBhIG1lc3NhZ2UgaXMgYmVpbmcgc2VudCBvciB3ZSBjb3VsZCBjb25mdXNlIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgLy8gYXMgaGlzIG1lc3NhZ2Ugd291bGQgZGlzYXBwZWFyIGZyb20gdGhlIGxpc3QsIGFuZCBoZSdkIGhhdmUgdG8gd2FpdCBmb3IgdGhlXG4gICAgICAgICAgICAgICAgLy8gaW50ZXJ2YWwgdG8gY2hlY2sgZm9yIG5ldyBtZXNzYWdlcy5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgICAgIC8vIE9idmlvdXNseSB3ZSBjYW5ub3QgY2hlY2sgZm9yIG5ldyBtZXNzYWdlcyB3aGVuIHRoZSBhcHAgaXMgb2ZmbGluZS5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgdGhlIGNhY2hlIGJlZm9yZSBmZXRjaGluZy5cbiAgICAgICAgICAgICRtbWFNZXNzYWdlcy5pbnZhbGlkYXRlRGlzY3Vzc2lvbkNhY2hlKHVzZXJJZCk7XG4gICAgICAgICAgICAkbW1hTWVzc2FnZXMuZ2V0RGlzY3Vzc2lvbih1c2VySWQpLnRoZW4oZnVuY3Rpb24obWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNCZWluZ1NlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBwb2xsaW5nIGlmIGR1ZSB0byBhIHJhY2UgY29uZGl0aW9uLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRzY29wZS5tZXNzYWdlcyA9ICRtbWFNZXNzYWdlcy5zb3J0TWVzc2FnZXMobWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIG5vdGlmeU5ld01lc3NhZ2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBtbWFNZXNzYWdlc1BvbGxJbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgLy8gVW5zZXQgcG9sbGluZy5cbiAgICBmdW5jdGlvbiB1bnNldFBvbGxpbmcoKSB7XG4gICAgICAgIGlmIChwb2xsaW5nKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdDYW5jZWxsaW5nIHBvbGxpbmcgZm9yIGNvbnZlcnNhdGlvbiB3aXRoIHVzZXIgJyArIHVzZXJJZCk7XG4gICAgICAgICAgICAkaW50ZXJ2YWwuY2FuY2VsKHBvbGxpbmcpO1xuICAgICAgICAgICAgcG9sbGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkaW9uaWNQbGF0Zm9ybS5pc1RhYmxldCgpKSB7XG4gICAgICAgIC8vIExpc3RlbiBmb3IgZXZlbnRzIHRvIHNldC91bnNldCB0aGUgcG9sbGluZyBpbiB0YWJsZXQuIFdlIHVzZSBhbmd1bGFyIGV2ZW50cyBiZWNhdXNlIHdlIGNhbm5vdCB1c2UgaW9uaWMgZXZlbnRzXG4gICAgICAgIC8vICh3ZSB1c2UgdWktdmlldykuIFRoZSBiZWhhdmlvciBpcyB0aGUgc2FtZSwgc2luY2Ugc2NvcGUgaXMgZGVzdHJveWVkIG9uIHRhYmxldCB2aWV3IHdoZW4gbmF2aWdhdGluZyB0byBzdWJ2aWV3cy5cbiAgICAgICAgJHNjb3BlLiRvbignJHZpZXdDb250ZW50TG9hZGVkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNldFBvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHVuc2V0UG9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMaXN0ZW4gZm9yIGV2ZW50cyB0byBzZXQvdW5zZXQgdGhlIHBvbGxpbmcgaW4gcGhvbmVzLiBXZSBjYW4gdXNlIGlvbmljIGV2ZW50cy5cbiAgICAgICAgJHNjb3BlLiRvbignJGlvbmljVmlldy5lbnRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2V0UG9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICAgICAgJHNjb3BlLiRvbignJGlvbmljVmlldy5sZWF2ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHVuc2V0UG9sbGluZygpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8vIE5vdGlmeSB0aGUgbGFzdCBtZXNzYWdlIGZvdW5kIHNvIGRpc2N1c3Npb25zIGxpc3QgY29udHJvbGxlciBjYW4gdGVsbCBpZiBsYXN0IG1lc3NhZ2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXG4gICAgZnVuY3Rpb24gbm90aWZ5TmV3TWVzc2FnZSgpIHtcbiAgICAgICAgdmFyIGxhc3QgPSAkc2NvcGUubWVzc2FnZXNbJHNjb3BlLm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnNtYWxsbWVzc2FnZSAhPT0gbGFzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlID0gbGFzdC5zbWFsbG1lc3NhZ2U7XG4gICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcigkbW1hTWVzc2FnZXMuZ2V0RGlzY3Vzc2lvbkV2ZW50TmFtZSh1c2VySWQpLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbGFzdE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgdGltZWNyZWF0ZWQ6IGxhc3QudGltZWNyZWF0ZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2Nyb2xsIHdoZW4ga2V5Ym9hcmQgaXMgaGlkZS9zaG93biB0byBrZWVwIHRoZSB1c2VyIHNjcm9sbC4gVGhpcyBpcyBvbmx5IG5lZWRlZCBmb3IgQW5kcm9pZC5cbiAgICBmdW5jdGlvbiBzZXRTY3JvbGxXaXRoS2V5Ym9hcmQoKSB7XG4gICAgICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7IC8vIFVzZSBhICR0aW1lb3V0IHRvIHdhaXQgZm9yIHNjcm9sbCB0byBjb3JyZWN0bHkgbWVhc3VyZSBoZWlnaHQuXG4gICAgICAgICAgICAgICAgdmFyIG9ic1Nob3csXG4gICAgICAgICAgICAgICAgICAgIG9ic0hpZGUsXG4gICAgICAgICAgICAgICAgICAgIGtleWJvYXJkSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBtYXhJbml0aWFsU2Nyb2xsID0gc2Nyb2xsVmlldy5nZXRTY3JvbGxWaWV3KCkuX19jb250ZW50SGVpZ2h0IC0gc2Nyb2xsVmlldy5nZXRTY3JvbGxWaWV3KCkuX19jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxIZWlnaHQgPSAkd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgb2JzU2hvdyA9ICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudEtleWJvYXJkU2hvdywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBjYWxjdWxhdGUga2V5Ym9hcmQgaGVpZ2h0IG91cnNlbHZlcyBzaW5jZSBlLmtleWJvYXJkSGVpZ2h0IGlzIG5vdCByZWxpYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHREaWZmZXJlbmNlID0gaW5pdGlhbEhlaWdodCAtICR3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3S2V5Ym9hcmRIZWlnaHQgPSBoZWlnaHREaWZmZXJlbmNlID4gNTAgPyBoZWlnaHREaWZmZXJlbmNlIDogZS5rZXlib2FyZEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdLZXlib2FyZEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleWJvYXJkSGVpZ2h0ID0gbmV3S2V5Ym9hcmRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVmlldy5zY3JvbGxCeSgwLCBuZXdLZXlib2FyZEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgb2JzSGlkZSA9ICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudEtleWJvYXJkSGlkZSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjcm9sbFZpZXcgfHzCoCFzY3JvbGxWaWV3LmdldFNjcm9sbFBvc2l0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gQ2FuJ3QgZ2V0IHNjcm9sbCBwb3NpdGlvbiwgc3RvcC5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxWaWV3LmdldFNjcm9sbFBvc2l0aW9uKCkudG9wID49IG1heEluaXRpYWxTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjcm9sbEJ5KDAsMCkgd291bGQgYXV0b21hdGljYWxseSByZXNldCBhdCBtYXhJbml0aWFsU2Nyb2xsLiBXZSBuZWVkIHRvIGFwcGx5IHRoZSBkaWZmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZXJlIHRvIHNjcm9sbCB0byB0aGUgcmlnaHQgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxWaWV3LnNjcm9sbEJ5KDAsIHNjcm9sbFZpZXcuZ2V0U2Nyb2xsUG9zaXRpb24oKS50b3AgLSBrZXlib2FyZEhlaWdodCAtIG1heEluaXRpYWxTY3JvbGwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVmlldy5zY3JvbGxCeSgwLCAtIGtleWJvYXJkSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzU2hvdyAmJiBvYnNTaG93Lm9mZiAmJiBvYnNTaG93Lm9mZigpO1xuICAgICAgICAgICAgICAgICAgICBvYnNIaWRlICYmIG9ic0hpZGUub2ZmICYmIG9ic0hpZGUub2ZmKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkaW9uaWNQbGF0Zm9ybS5pc1RhYmxldCgpKSB7XG4gICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tYU1lc3NhZ2VzRGlzY3Vzc2lvbkxvYWRlZEV2ZW50LCB1c2VySWQpO1xuICAgIH1cbiAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSkge1xuICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1hTWVzc2FnZXNEaXNjdXNzaW9uTGVmdEV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG59KTtcblxuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubWVzc2FnZXMnKVxuXG4vKipcbiAqIERpc2N1c3Npb25zIGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNZXNzYWdlc0Rpc2N1c3Npb25zQ3RybFxuICovXG4uY29udHJvbGxlcignbW1hTWVzc2FnZXNEaXNjdXNzaW9uc0N0cmwnLCBmdW5jdGlvbigkcSwgJHN0YXRlLCAkc2NvcGUsICRtbVV0aWwsICRtbWFNZXNzYWdlcywgJHJvb3RTY29wZSwgJG1tRXZlbnRzLFxuICAgICAgICAgICAgbW1Db3JlU3BsaXRWaWV3TG9hZCkge1xuICAgIHZhciBvYnNlcnZlcnMgPSBbXTtcblxuICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcblxuICAgIC8vIFNldCBvYnNlcnZlcnMgdG8gd2F0Y2ggZm9yIG5ldyBtZXNzYWdlcyBvbiBkaXNjdXNzaW9ucy4gSWYgYSB1c2VyIHNlZXMgYSBuZXcgbWVzc2FnZSBpbiBhIGRpc2N1c3Npb24sIHdlJ2xsIHVwZGF0ZVxuICAgIC8vIHRoZSBkaXNjdXNzaW9uJ3MgbGFzdCBtZXNzYWdlIGluIGRpc2N1c3Npb25zIGxpc3QuXG4gICAgZnVuY3Rpb24gc2V0T2JzZXJ2ZXJzKGRpc2N1c3Npb25zKSB7XG4gICAgICAgIGNsZWFyT2JzZXJ2ZXJzKCk7XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRpc2N1c3Npb25zLCBmdW5jdGlvbihkaXNjdXNzaW9uKSB7XG4gICAgICAgICAgICBvYnNlcnZlcnMucHVzaCgkbW1FdmVudHMub24oJG1tYU1lc3NhZ2VzLmdldERpc2N1c3Npb25FdmVudE5hbWUoZGlzY3Vzc2lvbi5tZXNzYWdlLnVzZXIpLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS50aW1lY3JlYXRlZCA+IGRpc2N1c3Npb24ubWVzc2FnZS50aW1lY3JlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uLm1lc3NhZ2UubWVzc2FnZSA9IGRhdGEubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgZGlzY3Vzc2lvbi5tZXNzYWdlLnRpbWVjcmVhdGVkID0gZGF0YS50aW1lY3JlYXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENsZWFyIG9ic2VydmVycy5cbiAgICBmdW5jdGlvbiBjbGVhck9ic2VydmVycygpIHtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG9ic2VydmVycywgZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlciAmJiBvYnNlcnZlci5vZmYpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmV0Y2hEaXNjdXNzaW9ucygpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNZXNzYWdlcy5nZXREaXNjdXNzaW9ucygpLnRoZW4oZnVuY3Rpb24oZGlzY3Vzc2lvbnMpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gYW4gYXJyYXkgZm9yIHNvcnRpbmcuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkaXNjdXNzaW9ucywgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2godik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5kaXNjdXNzaW9ucyA9IGFycmF5O1xuICAgICAgICAgICAgc2V0T2JzZXJ2ZXJzKGFycmF5KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tZXNzYWdlcy5lcnJvcndoaWxlcmV0cmlldmluZ2Rpc2N1c3Npb25zJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICRzY29wZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNZXNzYWdlcy5pbnZhbGlkYXRlRGlzY3Vzc2lvbnNDYWNoZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hEaXNjdXNzaW9ucygpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZldGNoRGlzY3Vzc2lvbnMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gVGVsbCBtbS1zcGxpdC12aWV3IHRoYXQgaXQgY2FuIGxvYWQgdGhlIGZpcnN0IGxpbmsgbm93IGluIHRhYmxldHMuIFdlIG5lZWQgdG8gZG8gaXRcbiAgICAgICAgLy8gbGlrZSB0aGlzIGJlY2F1c2UgdGhlIGRpcmVjdGl2ZSBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvICRzY29wZS5sb2FkZWQgdmFyaWFibGUgKGJlY2F1c2Ugb2YgdGFicykuXG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChtbUNvcmVTcGxpdFZpZXdMb2FkKTtcbiAgICB9KTtcblxuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyT2JzZXJ2ZXJzKCk7XG4gICAgfSk7XG59KTtcblxuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubWVzc2FnZXMnKVxuXG4vKipcbiAqIE1lc3NhZ2VzIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNZXNzYWdlc0luZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTWVzc2FnZXNJbmRleEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRtbUV2ZW50cywgJGlvbmljUGxhdGZvcm0sICRpb25pY1RhYnNEZWxlZ2F0ZSxcbiAgICAgICAgICAgIG1tYU1lc3NhZ2VzRGlzY3Vzc2lvbkxvYWRlZEV2ZW50LCBtbWFNZXNzYWdlc0Rpc2N1c3Npb25MZWZ0RXZlbnQpIHtcbiAgICAvLyBMaXN0ZW4gZm9yIGRpc2N1c3Npb24gbG9hZGVkIGV2ZW50IHRvIHNob3cgdXNlciBwcm9maWxlIGxpbmsgaW4gdGFibGV0IHZpZXcuXG4gICAgdmFyIG9ic0xvYWRlZCA9ICRtbUV2ZW50cy5vbihtbWFNZXNzYWdlc0Rpc2N1c3Npb25Mb2FkZWRFdmVudCwgZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgICRzY29wZS5wcm9maWxlTGluayA9ICRpb25pY1BsYXRmb3JtLmlzVGFibGV0KCkgJiYgJGlvbmljVGFic0RlbGVnYXRlLnNlbGVjdGVkSW5kZXgoKSA9PSAwO1xuICAgICAgICAkc2NvcGUudXNlcklkID0gdXNlcklkO1xuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuIGZvciBkaXNjdXNzaW9uIGxvYWRlZCBldmVudCB0byBzaG93IHVzZXIgcHJvZmlsZSBsaW5rIGluIHRhYmxldCB2aWV3LlxuICAgIHZhciBvYnNMZWZ0ID0gJG1tRXZlbnRzLm9uKG1tYU1lc3NhZ2VzRGlzY3Vzc2lvbkxlZnRFdmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5wcm9maWxlTGluayA9IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG9ic0xvYWRlZCAmJiBvYnNMb2FkZWQub2ZmKSB7XG4gICAgICAgICAgICBvYnNMb2FkZWQub2ZmKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ic0xlZnQgJiYgb2JzTGVmdC5vZmYpIHtcbiAgICAgICAgICAgIG9ic0xlZnQub2ZmKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tZXNzYWdlcycpXG5cbi8qKlxuICogRmlsdGVyIHRvIGZvcm1hdCBhIG1lc3NhZ2UuXG4gKlxuICogQG1vZHVsZSBtbWEubWVzc2FnZXNcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIG1tYU1lc3NhZ2VzRm9ybWF0XG4gKi9cbi5maWx0ZXIoJ21tYU1lc3NhZ2VzRm9ybWF0JywgZnVuY3Rpb24oJG1tVGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLy17NCx9L2lnLCAnJyk7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvPGJyIFxcLz48YnIgXFwvPi9pZywgXCI8YnIgLz5cIik7XG4gICAgdGV4dCA9ICRtbVRleHQucmVwbGFjZU5ld0xpbmVzKHRleHQsICc8YnIgLz4nKTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubWVzc2FnZXMnKVxuXG4vKipcbiAqIE1lc3NhZ2VzIGhhbmRsZXJzIGZhY3RvcnkuXG4gKlxuICogVGhpcyBmYWN0b3J5IGhvbGRzIHRoZSBkaWZmZXJlbnQgaGFuZGxlcnMgdXNlZCBmb3IgZGVsZWdhdGVzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1lc3NhZ2VzSGFuZGxlcnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFNZXNzYWdlc0hhbmRsZXJzJywgZnVuY3Rpb24oJGxvZywgJG1tYU1lc3NhZ2VzLCAkbW1TaXRlLCAkc3RhdGUsICRtbVV0aWwsICRtbUNvbnRlbnRMaW5rc0hlbHBlcikge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hTWVzc2FnZXNIYW5kbGVycycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBjb250YWN0IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXNIYW5kbGVycyNhZGRDb250YWN0XG4gICAgICovXG4gICAgc2VsZi5hZGRDb250YWN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNZXNzYWdlcy5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLmlzRW5hYmxlZEZvclVzZXIgPSBmdW5jdGlvbih1c2VyLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXIuaWQgIT0gJG1tU2l0ZS5nZXRVc2VySWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGNvbnRhY3QgaGFuZGxlciBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAgICAgKiBAbmdkb2MgY29udHJvbGxlclxuICAgICAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXNIYW5kbGVycyNibG9ja0NvbnRhY3Q6Y29udHJvbGxlclxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24odXNlciwgY291cnNlaWQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSwgJHJvb3RTY29wZSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGl0bGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMuaXNDb250YWN0KHVzZXIuaWQpLnRoZW4oZnVuY3Rpb24oaXNDb250YWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb250YWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5tZXNzYWdlcy5yZW1vdmVjb250YWN0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5tZXNzYWdlcy5hZGRjb250YWN0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGZhaWxzIGZvciBzb21lIHJlYXNvbiwgbGV0J3MganVzdCBoaWRlIHRoZSBidXR0b24uXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJyc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAkbW1hTWVzc2FnZXMuaXNDb250YWN0KHVzZXIuaWQpLnRoZW4oZnVuY3Rpb24oaXNDb250YWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb250YWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNZXNzYWdlcy5yZW1vdmVDb250YWN0KHVzZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1lc3NhZ2VzLmFkZENvbnRhY3QodXNlci5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnbW1hTWVzc2FnZXNIYW5kbGVyczphZGRVcGRhdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaXRsZSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCdtbWFNZXNzYWdlc0hhbmRsZXJzOmJsb2NrVXBkYXRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaXRsZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdXBkYXRlVGl0bGUoKTtcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBCbG9jayBjb250YWN0IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXNIYW5kbGVycyNibG9ja0NvbnRhY3RcbiAgICAgKi9cbiAgICBzZWxmLmJsb2NrQ29udGFjdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMuaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5pc0VuYWJsZWRGb3JVc2VyID0gZnVuY3Rpb24odXNlciwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VyLmlkICE9ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24odXNlciwgY291cnNlaWQpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCbG9jayBjb250YWN0IGhhbmRsZXIgY29udHJvbGxlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFNZXNzYWdlc0hhbmRsZXJzI2Jsb2NrQ29udGFjdDpjb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUsICRyb290U2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRpdGxlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1lc3NhZ2VzLmlzQmxvY2tlZCh1c2VyLmlkKS50aGVuKGZ1bmN0aW9uKGlzQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEubWVzc2FnZXMudW5ibG9ja2NvbnRhY3QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLm1lc3NhZ2VzLmJsb2NrY29udGFjdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBmYWlscyBmb3Igc29tZSByZWFzb24sIGxldCdzIGp1c3QgaGlkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICcnO1xuICAgICAgICAgICAgICAgICRzY29wZS5zcGlubmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zcGlubmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgJG1tYU1lc3NhZ2VzLmlzQmxvY2tlZCh1c2VyLmlkKS50aGVuKGZ1bmN0aW9uKGlzQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMudW5ibG9ja0NvbnRhY3QodXNlci5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMuYmxvY2tDb250YWN0KHVzZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ21tYU1lc3NhZ2VzSGFuZGxlcnM6YmxvY2tVcGRhdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaXRsZSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCdtbWFNZXNzYWdlc0hhbmRsZXJzOmFkZFVwZGF0ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGl0bGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZVRpdGxlKCk7XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2VuZCBtZXNzYWdlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXNIYW5kbGVycyNibG9ja0NvbnRhY3RcbiAgICAgKi9cbiAgICBzZWxmLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNZXNzYWdlcy5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLmlzRW5hYmxlZEZvclVzZXIgPSBmdW5jdGlvbih1c2VyLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXIuaWQgIT0gJG1tU2l0ZS5nZXRVc2VySWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbih1c2VyLCBjb3Vyc2VpZCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlbmQgbWVzc2FnZSBoYW5kbGVyIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgICAgICAgICAqIEBuZ2RvYyBjb250cm9sbGVyXG4gICAgICAgICAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXNIYW5kbGVycyNzZW5kTWVzc2FnZTpjb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLm1lc3NhZ2VzLnNlbmRtZXNzYWdlJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tZXNzYWdlcy1kaXNjdXNzaW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckZ1bGxuYW1lOiB1c2VyLmZ1bGxuYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNpZGUgbWVudSBuYXYgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlc0hhbmRsZXJzI3NpZGVNZW51TmF2XG4gICAgICovXG4gICAgc2VsZi5zaWRlTWVudU5hdiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1lc3NhZ2VzLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29udHJvbGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNpZGUgbWVudSBuYXYgaGFuZGxlciBjb250cm9sbGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICAgICAgICAgKiBAbmdkb2MgY29udHJvbGxlclxuICAgICAgICAgICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzSGFuZGxlcnMjc2lkZU1lbnVOYXY6Y29udHJvbGxlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAnaW9uLWNoYXRib3gnO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEubWVzc2FnZXMubWVzc2FnZXMnO1xuICAgICAgICAgICAgICAgICRzY29wZS5zdGF0ZSA9ICdzaXRlLm1lc3NhZ2VzJztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlc0hhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkIFNpdGUgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWRGb3JTaXRlKHNpdGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNZXNzYWdlcy5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0W119ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgbWVzc2FnZXMgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbWVzc2FnZS9pbmRleC5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBmYWxzZSBiZWNhdXNlIGFsbCBzaXRlcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaXRldXJsLlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIuZmlsdGVyU3VwcG9ydGVkU2l0ZXMoc2l0ZUlkcywgaXNFbmFibGVkRm9yU2l0ZSwgZmFsc2UpLnRoZW4oZnVuY3Rpb24oaWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gJG1tVXRpbC5leHRyYWN0VXJsUGFyYW1zKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbW0uY29yZS52aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWV5ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZXM6IGlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXJhbXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMudXNlcjEgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBhcmFtcy51c2VyMiAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdXNlciBpcyBpbiB0aGUgY29udmVyc2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRtbVNpdGUuZ2V0VXNlcklkKCkgPT0gcGFyYW1zLnVzZXIxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVOYW1lID0gJ3NpdGUubWVzc2FnZXMtZGlzY3Vzc2lvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXJhbXMgPSB7dXNlcklkOiBwYXJzZUludChwYXJhbXMudXNlcjIsIDEwKX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCRtbVNpdGUuZ2V0VXNlcklkKCkgPT0gcGFyYW1zLnVzZXIyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVOYW1lID0gJ3NpdGUubWVzc2FnZXMtZGlzY3Vzc2lvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXJhbXMgPSB7dXNlcklkOiBwYXJzZUludChwYXJhbXMudXNlcjEsIDEwKX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlIGlzbid0LCBvcGVuIGluIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5vcGVuSW5Ccm93c2VyKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMuaWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTmFtZSA9ICdzaXRlLm1lc3NhZ2VzLWRpc2N1c3Npb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXJhbXMgPSB7dXNlcklkOiBwYXJzZUludChwYXJhbXMuaWQsIDEwKX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR28gdG8gbWVzc2FnaW5nIGluZGV4IHBhZ2UuIFdlIHVzZSByZWRpcmVjdCBzdGF0ZSB0byB2aWV3IHRoZSBzaWRlIG1lbnUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3JlZGlyZWN0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVpZDogc2l0ZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiAnc2l0ZS5tZXNzYWdlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db250ZW50TGlua3NIZWxwZXIuZ29JblNpdGUoc3RhdGVOYW1lLCBzdGF0ZVBhcmFtcywgc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tZXNzYWdlcycpXG5cbi8qKlxuICogTWVzc2FnZXMgZmFjdG9yeS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNZXNzYWdlc1xuICovXG4uZmFjdG9yeSgnJG1tYU1lc3NhZ2VzJywgZnVuY3Rpb24oJG1tU2l0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCAkbG9nLCAkcSwgJG1tVXNlciwgbW1hTWVzc2FnZXNOZXdNZXNzYWdlRXZlbnQpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU1lc3NhZ2VzJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29udGFjdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNhZGRDb250YWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvIFVzZXIgSUQgb2YgdGhlIHBlcnNvbiB0byBhZGQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmFkZENvbnRhY3QgPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ2NvcmVfbWVzc2FnZV9jcmVhdGVfY29udGFjdHMnLCB7XG4gICAgICAgICAgICB1c2VyaWRzOiBbIHVzZXJJZCBdXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbnZhbGlkYXRlQWxsQ29udGFjdHNDYWNoZSgkbW1TaXRlLmdldFVzZXJJZCgpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEJsb2NrIGEgY29udGFjdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNibG9ja0NvbnRhY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG8gVXNlciBJRCBvZiB0aGUgcGVyc29uIHRvIGJsb2NrLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5ibG9ja0NvbnRhY3QgPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ2NvcmVfbWVzc2FnZV9ibG9ja19jb250YWN0cycsIHtcbiAgICAgICAgICAgIHVzZXJpZHM6IFsgdXNlcklkIF1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmludmFsaWRhdGVBbGxDb250YWN0c0NhY2hlKCRtbVNpdGUuZ2V0VXNlcklkKCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgY29udGFjdHMgb2YgdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNnZXRBbGxDb250YWN0c1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggdGhlIFdTIGRhdGEuXG4gICAgICovXG4gICAgc2VsZi5nZXRBbGxDb250YWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRDb250YWN0cygpLnRoZW4oZnVuY3Rpb24oY29udGFjdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmdldEJsb2NrZWRDb250YWN0cygpLnRoZW4oZnVuY3Rpb24oYmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhY3RzLmJsb2NrZWQgPSBibG9ja2VkLnVzZXJzO1xuICAgICAgICAgICAgICAgIHN0b3JlVXNlcnNGcm9tQWxsQ29udGFjdHMoY29udGFjdHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWN0cztcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBXUyBmb3IgYmxvY2tlZCBjb250YWN0cyBtaWdodCBub3QgYmUgYXZhaWxhYmxlIHlldCwgYnV0IHdlIHN0aWxsIHdhbnQgdGhlIGNvbnRhY3RzLlxuICAgICAgICAgICAgICAgIGNvbnRhY3RzLmJsb2NrZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBzdG9yZVVzZXJzRnJvbUFsbENvbnRhY3RzKGNvbnRhY3RzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFjdHM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIGJsb2NrZWQgY29udGFjdHMgb2YgdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNnZXRCbG9ja2VkQ29udGFjdHNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIHRoZSBXUyBkYXRhLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QmxvY2tlZENvbnRhY3RzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcmlkOiAkbW1TaXRlLmdldFVzZXJJZCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlc2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogc2VsZi5fZ2V0Q2FjaGVLZXlGb3JCbG9ja2VkQ29udGFjdHMoJG1tU2l0ZS5nZXRVc2VySWQoKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZlcnJlZDtcblxuICAgICAgICBpZiAoISRtbVNpdGUud3NBdmFpbGFibGUoJ2NvcmVfbWVzc2FnZV9nZXRfYmxvY2tlZF91c2VycycpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgV1MgaXMgbm90IGF2YWlsYWJsZSwgd2UgbW9jayBhbiBlbXB0eSByZXNwb25zZS5cbiAgICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoe3VzZXJzOiBbXSwgd2FybmluZ3M6IFtdfSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ2NvcmVfbWVzc2FnZV9nZXRfYmxvY2tlZF91c2VycycsIHBhcmFtcywgcHJlc2V0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2FjaGUga2V5IGZvciBjb250YWN0cy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNfZ2V0Q2FjaGVLZXlGb3JDb250YWN0c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0Q2FjaGVLZXlGb3JDb250YWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBOb3RlOiB0aGUgY29udGFjdHMgV1MgZG9lcyBub3QgdGFrZSBhcmd1bWVudHMsIHNvIHdlIGRvIG5vdCBuZWVkIGFueSBoZXJlLlxuICAgICAgICByZXR1cm4gJ21tYU1lc3NhZ2VzOmNvbnRhY3RzJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjYWNoZSBrZXkgZm9yIGJsb2NrZWQgY29udGFjdHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjX2dldENhY2hlS2V5Rm9yQmxvY2tlZENvbnRhY3RzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJJZCBUaGUgdXNlciB3aG8ncyBjb250YWN0cyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2dldENhY2hlS2V5Rm9yQmxvY2tlZENvbnRhY3RzID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTWVzc2FnZXM6YmxvY2tlZENvbnRhY3RzOicgKyB1c2VySWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2FjaGUga2V5IGZvciBhIGRpc2N1c3Npb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjX2dldENhY2hlS2V5Rm9yRGlzY3Vzc2lvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1c2VySWQgVGhlIG90aGVyIHBlcnNvbiB3aXRoIHdob20gdGhlIGN1cnJlbnQgdXNlciBpcyBoYXZpbmcgdGhlIGRpc2N1c3Npb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRDYWNoZUtleUZvckRpc2N1c3Npb24gPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNZXNzYWdlczpkaXNjdXNzaW9uOicgKyB1c2VySWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2FjaGUga2V5IGZvciB0aGUgbGlzdCBvZiBkaXNjdXNzaW9ucy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNfZ2V0Q2FjaGVLZXlGb3JEaXNjdXNzaW9uc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0Q2FjaGVLZXlGb3JEaXNjdXNzaW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ21tYU1lc3NhZ2VzOmRpc2N1c3Npb25zJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjYWNoZSBrZXkgZm9yIHRoZSBtZXNzYWdpbmcgZW5hYmxlZCBjYWxsLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI19nZXRDYWNoZUtleUZvckVuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2dldENhY2hlS2V5Rm9yRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ21tYU1lc3NhZ2VzOmVuYWJsZWQnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbnRhY3RzIG9mIHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIGV4Y2x1ZGVzIHRoZSBibG9ja2VkIHVzZXJzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2dldENvbnRhY3RzXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCB0aGUgV1MgZGF0YS5cbiAgICAgKi9cbiAgICBzZWxmLmdldENvbnRhY3RzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcmVzZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBzZWxmLl9nZXRDYWNoZUtleUZvckNvbnRhY3RzKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ2NvcmVfbWVzc2FnZV9nZXRfY29udGFjdHMnLCB1bmRlZmluZWQsIHByZXNldHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50cyBvZiBhIGRpc2N1c3Npb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJpZCBVc2VyIElEIG9mIHRoZSBkaXNjdXNzaW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIE5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RGlzY3Vzc2lvbkV2ZW50TmFtZSA9IGZ1bmN0aW9uKHVzZXJpZCkge1xuICAgICAgICByZXR1cm4gbW1hTWVzc2FnZXNOZXdNZXNzYWdlRXZlbnQgKyAnXycgKyAkbW1TaXRlLmdldFVzZXJJZCgpICsgJ18nICsgdXNlcmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY3VycmVudCB1c2VyJ3MgZGlzY3Vzc2lvbiB3aXRoIGFub3RoZXIgdXNlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNnZXREaXNjdXNzaW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJJZCBUaGUgSUQgb2YgdGhlIG90aGVyIHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmdldERpc2N1c3Npb24gPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VzLFxuICAgICAgICAgICAgcHJlc2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogc2VsZi5fZ2V0Q2FjaGVLZXlGb3JEaXNjdXNzaW9uKHVzZXJJZClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcmlkdG86ICRtbVNpdGUuZ2V0VXNlcklkKCksXG4gICAgICAgICAgICAgICAgdXNlcmlkZnJvbTogdXNlcklkLFxuICAgICAgICAgICAgICAgIGxpbWl0ZnJvbTogMCxcbiAgICAgICAgICAgICAgICBsaW1pdG51bTogNTBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2dldFJlY2VudE1lc3NhZ2VzKHBhcmFtcywgcHJlc2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgbWVzc2FnZXMgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHBhcmFtcy51c2VyaWR0byA9IHVzZXJJZDtcbiAgICAgICAgICAgIHBhcmFtcy51c2VyaWRmcm9tID0gJG1tU2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldFJlY2VudE1lc3NhZ2VzKHBhcmFtcywgcHJlc2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlcy5jb25jYXQocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRpc2N1c3Npb25zIG9mIHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjZ2V0RGlzY3Vzc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIHVzZXIgSUQgb2YgdGhlIG90aGVyIHVzZXIuXG4gICAgICovXG4gICAgc2VsZi5nZXREaXNjdXNzaW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlzY3Vzc2lvbnMgPSB7fSxcbiAgICAgICAgICAgIHByZXNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IHNlbGYuX2dldENhY2hlS2V5Rm9yRGlzY3Vzc2lvbnMoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2dldFJlY2VudE1lc3NhZ2VzKHtcbiAgICAgICAgICAgIHVzZXJpZHRvOiAkbW1TaXRlLmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgdXNlcmlkZnJvbTogMCxcbiAgICAgICAgICAgIGxpbWl0ZnJvbTogMCxcbiAgICAgICAgICAgIGxpbWl0bnVtOiA1MFxuICAgICAgICB9LCBwcmVzZXRzKS50aGVuKGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGRpc2N1c3Npb25zIGJ5IGZpbHRlcmluZyBzYW1lIHNlbmRlcnMuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobWVzc2FnZXMsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRpc2N1c3Npb25zW21lc3NhZ2UudXNlcmlkZnJvbV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2N1c3Npb25zW21lc3NhZ2UudXNlcmlkZnJvbV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsbmFtZTogbWVzc2FnZS51c2VyZnJvbWZ1bGxuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZWltYWdldXJsOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLnRpbWVyZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uc1ttZXNzYWdlLnVzZXJpZGZyb21dLnVucmVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBtb3N0IHJlY2VudCBtZXNzYWdlLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGlzY3Vzc2lvbnNbbWVzc2FnZS51c2VyaWRmcm9tXS5tZXNzYWdlID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzY3Vzc2lvbnNbbWVzc2FnZS51c2VyaWRmcm9tXS5tZXNzYWdlLnRpbWVjcmVhdGVkIDwgbWVzc2FnZS50aW1lY3JlYXRlZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc2N1c3Npb25zW21lc3NhZ2UudXNlcmlkZnJvbV0ubWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IG1lc3NhZ2UudXNlcmlkZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2Uuc21hbGxtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWNyZWF0ZWQ6IG1lc3NhZ2UudGltZWNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTm93IGdldCB0aGUgbGFzdCBtZXNzYWdlcyBzZW50IGZyb20gd2hpY2ggd2UgbWlnaHQgbm90IGhhdmUgcmVjZWl2ZWQgYSByZXBseSB5ZXQuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0UmVjZW50TWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgIHVzZXJpZGZyb206ICRtbVNpdGUuZ2V0VXNlcklkKCksXG4gICAgICAgICAgICAgICAgdXNlcmlkdG86IDAsXG4gICAgICAgICAgICAgICAgbGltaXRmcm9tOiAwLFxuICAgICAgICAgICAgICAgIGxpbWl0bnVtOiA1MFxuICAgICAgICAgICAgfSwgcHJlc2V0cykudGhlbihmdW5jdGlvbihtZXNzYWdlcykge1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgZGlzY3Vzc2lvbnMgYnkgZmlsdGVyaW5nIHNhbWUgc2VuZGVycy5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobWVzc2FnZXMsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXNjdXNzaW9uc1ttZXNzYWdlLnVzZXJpZHRvXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2N1c3Npb25zW21lc3NhZ2UudXNlcmlkdG9dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxuYW1lOiBtZXNzYWdlLnVzZXJ0b2Z1bGxuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVpbWFnZXVybDogXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLnRpbWVyZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY3Vzc2lvbnNbbWVzc2FnZS51c2VyaWR0b10udW5yZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIG1vc3QgcmVjZW50IG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGlzY3Vzc2lvbnNbbWVzc2FnZS51c2VyaWR0b10ubWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uc1ttZXNzYWdlLnVzZXJpZHRvXS5tZXNzYWdlLnRpbWVjcmVhdGVkIDwgbWVzc2FnZS50aW1lY3JlYXRlZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uc1ttZXNzYWdlLnVzZXJpZHRvXS5tZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IG1lc3NhZ2UudXNlcmlkdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZS5zbWFsbG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWNyZWF0ZWQ6IG1lc3NhZ2UudGltZWNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIE5vdyBnZXQgdGhlIGNvbnRhY3RzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Q29udGFjdHMoKS50aGVuKGZ1bmN0aW9uKGNvbnRhY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlcyA9IFsnb25saW5lJywgJ29mZmxpbmUnLCAnc3RyYW5nZXJzJ107XG5cbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdHNbdHlwZV0gJiYgY29udGFjdHNbdHlwZV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250YWN0c1t0eXBlXSwgZnVuY3Rpb24oY29udGFjdCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGlzY3Vzc2lvbnNbY29udGFjdC5pZF0gPT09ICd1bmRlZmluZWQnICYmIGNvbnRhY3QudW5yZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIGEgY29udGFjdCB3aXRoIHVucmVhZCBtZXNzYWdlcy4gQ29udGFjdHMgd2l0aG91dCB1bnJlYWQgbWVzc2FnZXMgYXJlIG5vdCB1c2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY3Vzc2lvbnNbY29udGFjdC5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbG5hbWU6IGNvbnRhY3QuZnVsbG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZWltYWdldXJsOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogY29udGFjdC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCIuLi5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWNyZWF0ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGlzY3Vzc2lvbnNbY29udGFjdC5pZF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29udGFjdCBpcyB1c2VkIGluIGEgZGlzY3Vzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0LnByb2ZpbGVpbWFnZXVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2N1c3Npb25zW2NvbnRhY3QuaWRdLnByb2ZpbGVpbWFnZXVybCA9IGNvbnRhY3QucHJvZmlsZWltYWdldXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250YWN0LnVucmVhZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uc1tjb250YWN0LmlkXS51bnJlYWQgPSBjb250YWN0LnVucmVhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXREaXNjdXNzaW9uc1VzZXJJbWcoZGlzY3Vzc2lvbnMpLnRoZW4oZnVuY3Rpb24oZGlzY3Vzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlVXNlcnNGcm9tRGlzY3Vzc2lvbnMoZGlzY3Vzc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpc2N1c3Npb25zO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgaW1hZ2VzIGZvciBhbGwgdGhlIGRpc2N1c3Npb25zIHRoYXQgZG9uJ3QgaGF2ZSBvbmUgYWxyZWFkeS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNnZXREaXNjdXNzaW9uc1VzZXJJbWdcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkaXNjdXNzaW9ucyBMaXN0IG9mIGRpc2N1c3Npb25zLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgIFByb21pc2UgYWx3YXlzIHJlc29sdmVkLiBSZXNvbHZlIHBhcmFtIGlzIHRoZSBmb3JtYXR0ZWQgZGlzY3Vzc2lvbnMuXG4gICAgICovXG4gICAgc2VsZi5nZXREaXNjdXNzaW9uc1VzZXJJbWcgPSBmdW5jdGlvbihkaXNjdXNzaW9ucykge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goZGlzY3Vzc2lvbnMsIGZ1bmN0aW9uKGRpc2N1c3Npb24pIHtcbiAgICAgICAgICAgIGlmICghZGlzY3Vzc2lvbi5wcm9maWxlaW1hZ2V1cmwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHRoZSB1c2VyIGltYWdlLiBUcnkgdG8gcmV0cmlldmUgaXQuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSAkbW1Vc2VyLmdldFByb2ZpbGUoZGlzY3Vzc2lvbi5tZXNzYWdlLnVzZXIsIDEsIHRydWUpLnRoZW4oZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uLnByb2ZpbGVpbWFnZXVybCA9IHVzZXIucHJvZmlsZWltYWdldXJsO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciBnZXR0aW5nIHByb2ZpbGUsIHJlc29sdmUgcHJvbWlzZSB3aXRob3V0IGFkZGluZyBhbnkgZXh0cmEgZGF0YS5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNjdXNzaW9ucztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBtZXNzYWdlcyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNfZ2V0TWVzc2FnZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgV1MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXNldHMgU2V0IG9mIHByZXNldHMgZm9yIHRoZSBXUy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRNZXNzYWdlcyA9IGZ1bmN0aW9uKHBhcmFtcywgcHJlc2V0cykge1xuICAgICAgICBwYXJhbXMgPSBhbmd1bGFyLmV4dGVuZChwYXJhbXMsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjb252ZXJzYXRpb25zJyxcbiAgICAgICAgICAgIG5ld2VzdGZpcnN0OiAxLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdjb3JlX21lc3NhZ2VfZ2V0X21lc3NhZ2VzJywgcGFyYW1zLCBwcmVzZXRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNfZ2V0UmVjZW50TWVzc2FnZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgV1MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXNldHMgU2V0IG9mIHByZXNldHMgZm9yIHRoZSBXUy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRSZWNlbnRNZXNzYWdlcyA9IGZ1bmN0aW9uKHBhcmFtcywgcHJlc2V0cykge1xuICAgICAgICBwYXJhbXMgPSBhbmd1bGFyLmV4dGVuZChwYXJhbXMsIHtcbiAgICAgICAgICAgIHJlYWQ6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2dldE1lc3NhZ2VzKHBhcmFtcywgcHJlc2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gcmVzcG9uc2UubWVzc2FnZXM7XG4gICAgICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID49IHBhcmFtcy5saW1pdG51bSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBmZXRjaCBtb3JlIG1lc3NhZ2VzLlxuICAgICAgICAgICAgICAgIHBhcmFtcy5saW1pdG51bSA9IHBhcmFtcy5saW1pdG51bSAtIG1lc3NhZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwYXJhbXMucmVhZCA9IDE7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0TWVzc2FnZXMocGFyYW1zLCBwcmVzZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5tZXNzYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5jb25jYXQocmVzcG9uc2UubWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgYWxsIGNvbnRhY3RzIGNhY2hlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2ludmFsaWRhdGVBbGxDb250YWN0c0NhY2hlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJJZCBUaGUgdXNlciBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUFsbENvbnRhY3RzQ2FjaGUgPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW52YWxpZGF0ZUNvbnRhY3RzQ2FjaGUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW52YWxpZGF0ZUJsb2NrZWRDb250YWN0c0NhY2hlKHVzZXJJZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGJsb2NrZWQgY29udGFjdHMgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjaW52YWxpZGF0ZUJsb2NrZWRDb250YWN0c0NhY2hlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJJZCBUaGUgdXNlciBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUJsb2NrZWRDb250YWN0c0NhY2hlID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KHNlbGYuX2dldENhY2hlS2V5Rm9yQmxvY2tlZENvbnRhY3RzKHVzZXJJZCkpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgY29udGFjdHMgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjaW52YWxpZGF0ZUNvbnRhY3RzQ2FjaGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUNvbnRhY3RzQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoc2VsZi5fZ2V0Q2FjaGVLZXlGb3JDb250YWN0cygpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBkaXNjdXNzaW9uIGNhY2hlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2ludmFsaWRhdGVEaXNjdXNzaW9uQ2FjaGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdXNlcklkIFRoZSB1c2VyIElEIHdpdGggd2hvbSB0aGUgY3VycmVudCB1c2VyIGlzIGhhdmluZyB0aGUgZGlzY3Vzc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZURpc2N1c3Npb25DYWNoZSA9IGZ1bmN0aW9uKHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShzZWxmLl9nZXRDYWNoZUtleUZvckRpc2N1c3Npb24odXNlcklkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgZGlzY3Vzc2lvbnMgY2FjaGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQge0BsaW5rICRtbWFNZXNzYWdlcyNnZXREaXNjdXNzaW9uc30gdXNlcyB0aGUgY29udGFjdHMsIHNvIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSBjb250YWN0cyB0b28uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjaW52YWxpZGF0ZURpc2N1c3Npb25zQ2FjaGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZURpc2N1c3Npb25zQ2FjaGUgPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoc2VsZi5fZ2V0Q2FjaGVLZXlGb3JEaXNjdXNzaW9ucygpKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbnZhbGlkYXRlQ29udGFjdHNDYWNoZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBtZXNzYWdpbmcgZW5hYmxlZCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNpbnZhbGlkYXRlRW5hYmxlZENhY2hlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVFbmFibGVkQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoc2VsZi5fZ2V0Q2FjaGVLZXlGb3JFbmFibGVkKCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGEgdXNlciBpcyBibG9ja2VkIGJ5IHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjaXNCbG9ja2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJJZCBUaGUgdXNlciBJRCB0byBjaGVjayBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggYm9vbGVhbiwgcmVqZWN0ZWQgd2hlbiB3ZSBkbyBub3Qga25vdy5cbiAgICAgKi9cbiAgICBzZWxmLmlzQmxvY2tlZCA9IGZ1bmN0aW9uKHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRCbG9ja2VkQ29udGFjdHMoKS50aGVuKGZ1bmN0aW9uKGJsb2NrZWRDb250YWN0cykge1xuICAgICAgICAgICAgdmFyIGJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghYmxvY2tlZENvbnRhY3RzLnVzZXJzIHx8IGJsb2NrZWRDb250YWN0cy51c2Vycy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goYmxvY2tlZENvbnRhY3RzLnVzZXJzLCBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJJZCA9PSB1c2VyLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrZWQ7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGEgdXNlciBpcyBhIGNvbnRhY3Qgb2YgdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNpc0NvbnRhY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdXNlcklkIFRoZSB1c2VyIElEIHRvIGNoZWNrIGFnYWluc3QuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCBib29sZWFuLCByZWplY3RlZCB3aGVuIHdlIGRvIG5vdCBrbm93LlxuICAgICAqL1xuICAgIHNlbGYuaXNDb250YWN0ID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldENvbnRhY3RzKCkudGhlbihmdW5jdGlvbihjb250YWN0cykge1xuICAgICAgICAgICAgdmFyIGlzQ29udGFjdCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGVzID0gWydvbmxpbmUnLCAnb2ZmbGluZSddO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdHNbdHlwZV0gJiYgY29udGFjdHNbdHlwZV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGFjdHNbdHlwZV0sIGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VySWQgPT0gdXNlci5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29udGFjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gaXNDb250YWN0O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBtZXNzYWdpbmcgaXMgZW5hYmxlZCBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY291bGQgY2FsbCBhIFdTIHNvIGRvIG5vdCBhYnVzZSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNfaXNNZXNzYWdpbmdFbmFibGVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBlbmFibGVkLCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2lzTWVzc2FnaW5nRW5hYmxlZCA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdmFyIGVuYWJsZWQgPSBzaXRlLmNhblVzZUFkdmFuY2VkRmVhdHVyZSgnbWVzc2FnaW5nJywgJ3Vua25vd24nKTtcblxuICAgICAgICAgICAgaWYgKGVuYWJsZWQgPT09ICd1bmtub3duJykge1xuICAgICAgICAgICAgICAgIC8vIE9uIG9sZGVyIHZlcnNpb24gd2UgY2Fubm90IGNoZWNrIG90aGVyIHRoYW4gY2FsbGluZyBhIFdTLiBJZiB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICAgIC8vIGZhaWxzIHRoZXJlIGlzIGEgdmVyeSBoaWdoIGNoYW5jZSB0aGF0IG1lc3NhZ2luZyBpcyBkaXNhYmxlZC5cbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdVc2luZyBXUyBjYWxsIHRvIGNoZWNrIGlmIG1lc3NhZ2luZyBpcyBlbmFibGVkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXRlLnJlYWQoJ2NvcmVfbWVzc2FnZV9zZWFyY2hfY29udGFjdHMnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaHRleHQ6ICdDaGVja2luZ0lmTWVzc2FnaW5nSXNFbmFibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgb25seW15Y291cnNlczogMFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgZW1lcmdlbmN5Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogc2VsZi5fZ2V0Q2FjaGVLZXlGb3JFbmFibGVkKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBtZXNzYWdpbmcgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvdWxkIGNhbGwgYSBXUyBzbyBkbyBub3QgYWJ1c2UgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjaXNNZXNzYWdpbmdFbmFibGVkRm9yU2l0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlaWQgU2l0ZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFJlc29sdmVkIHdoZW4gZW5hYmxlZCwgb3RoZXJ3aXNlIHJlamVjdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaXNNZXNzYWdpbmdFbmFibGVkRm9yU2l0ZSA9IGZ1bmN0aW9uKHNpdGVpZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIGlmICghc2l0ZS5jYW5Vc2VBZHZhbmNlZEZlYXR1cmUoJ21lc3NhZ2luZycpIHx8ICFzaXRlLndzQXZhaWxhYmxlKCdjb3JlX21lc3NhZ2VfZ2V0X21lc3NhZ2VzJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9uIG9sZGVyIHZlcnNpb24gd2UgY2Fubm90IGNoZWNrIG90aGVyIHRoYW4gY2FsbGluZyBhIFdTLiBJZiB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgLy8gZmFpbHMgdGhlcmUgaXMgYSB2ZXJ5IGhpZ2ggY2hhbmNlIHRoYXQgbWVzc2FnaW5nIGlzIGRpc2FibGVkLlxuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVXNpbmcgV1MgY2FsbCB0byBjaGVjayBpZiBtZXNzYWdpbmcgaXMgZW5hYmxlZC4nKTtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLnJlYWQoJ2NvcmVfbWVzc2FnZV9zZWFyY2hfY29udGFjdHMnLCB7XG4gICAgICAgICAgICAgICAgc2VhcmNodGV4dDogJ0NoZWNraW5nSWZNZXNzYWdpbmdJc0VuYWJsZWQnLFxuICAgICAgICAgICAgICAgIG9ubHlteWNvdXJzZXM6IDBcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBlbWVyZ2VuY3lDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IHNlbGYuX2dldENhY2hlS2V5Rm9yRW5hYmxlZCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBpcyBlbmFibGVkIGluIGEgY2VydGFpbiBzaXRlLlxuICAgICAqXG4gICAgICogRG8gbm90IGFidXNlIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICBpZiAoIXNpdGUuY2FuVXNlQWR2YW5jZWRGZWF0dXJlKCdtZXNzYWdpbmcnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNpdGUud3NBdmFpbGFibGUoJ2NvcmVfbWVzc2FnZV9nZXRfbWVzc2FnZXMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2lzTWVzc2FnaW5nRW5hYmxlZChzaXRlSWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB3ZSBjYW4gc2VhcmNoIGNvbnRhY3RzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2lzU2VhcmNoRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2VsZi5pc1NlYXJjaEVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3NBdmFpbGFibGUoJ2NvcmVfbWVzc2FnZV9zZWFyY2hfY29udGFjdHMnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY29udGFjdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNyZW1vdmVDb250YWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvIFVzZXIgSUQgb2YgdGhlIHBlcnNvbiB0byByZW1vdmUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLnJlbW92ZUNvbnRhY3QgPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ2NvcmVfbWVzc2FnZV9kZWxldGVfY29udGFjdHMnLCB7XG4gICAgICAgICAgICB1c2VyaWRzOiBbIHVzZXJJZCBdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHJlc3BvbnNlRXhwZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbnZhbGlkYXRlQ29udGFjdHNDYWNoZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBjb250YWN0cy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQgdGhpcyBvbmx5IHJldHVybnMgdGhlIGZpcnN0IDEwMCBjb250YWN0cywgYnV0IG5vdGUgdGhhdCB0aGUgV1MgY2FuIHJldHVybiB0aG91c2FuZHNcbiAgICAgKiBvZiByZXN1bHRzIHdoaWNoIHdvdWxkIHRha2UgYSB3aGlsZSB0byBwcm9jZXNzLiBUaGUgbGltaXQgaGVyZSBpcyBqdXN0IGEgY29udmVuaWVuY2UgdG9cbiAgICAgKiBwcmV2ZW50IHZpZXdlZCB0byBjcmFzaCBiZWNhdXNlIHRvbyBtYW55IERPTSBlbGVtZW50cyBhcmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNzZWFyY2hDb250YWN0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXQ9MTAwXSBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuLCAwIGZvciBub25lLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5zZWFyY2hDb250YWN0cyA9IGZ1bmN0aW9uKHF1ZXJ5LCBsaW1pdCkge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBzZWFyY2h0ZXh0OiBxdWVyeSxcbiAgICAgICAgICAgICAgICBvbmx5bXljb3Vyc2VzOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICBsaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgPyAxMDAgOiBsaW1pdDtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnY29yZV9tZXNzYWdlX3NlYXJjaF9jb250YWN0cycsIGRhdGEpLnRoZW4oZnVuY3Rpb24oY29udGFjdHMpIHtcbiAgICAgICAgICAgIGlmIChsaW1pdCAmJiBjb250YWN0cy5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGNvbnRhY3RzID0gY29udGFjdHMuc3BsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRtbVVzZXIuc3RvcmVVc2Vycyhjb250YWN0cyk7XG4gICAgICAgICAgICByZXR1cm4gY29udGFjdHM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byBzb21lb25lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI3NlbmRNZXNzYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvIFVzZXIgSUQgdG8gc2VuZCB0aGUgbWVzc2FnZSB0by5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24odG8sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ2NvcmVfbWVzc2FnZV9zZW5kX2luc3RhbnRfbWVzc2FnZXMnLCB7XG4gICAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG91c2VyaWQ6IHRvLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Zm9ybWF0OiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2VbMF0gJiYgcmVzcG9uc2VbMF0ubXNnaWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgd2FzIGFuIGVycm9yLCBhbmQgaXQgc2hvdWxkIGJlIHRyYW5zbGF0ZWQgYWxyZWFkeS5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KHJlc3BvbnNlWzBdLmVycm9ybWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbnZhbGlkYXRlRGlzY3Vzc2lvbkNhY2hlKHRvKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gc29ydCBtZXNzYWdlcyBieSB0aW1lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI3NvcnRNZXNzYWdlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG1lc3NhZ2VzIEFycmF5IG9mIG1lc3NhZ2VzIGNvbnRhaW5pbmcgdGhlIGtleSAndGltZWNyZWF0ZWQnLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSBNZXNzYWdlcyBzb3J0ZWQgd2l0aCBtb3N0IHJlY2VudCBsYXN0LlxuICAgICAqL1xuICAgIHNlbGYuc29ydE1lc3NhZ2VzID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGEgPSBwYXJzZUludChhLnRpbWVjcmVhdGVkLCAxMCk7XG4gICAgICAgICAgICBiID0gcGFyc2VJbnQoYi50aW1lY3JlYXRlZCwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIGEgPj0gYiA/IDEgOiAtMTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIHVzZXIgZGF0YSBmcm9tIGNvbnRhY3RzIGluIGxvY2FsIERCLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gY29udGFjdFR5cGVzIExpc3Qgb2YgY29udGFjdHMgZ3JvdXBlZCBpbiB0eXBlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yZVVzZXJzRnJvbUFsbENvbnRhY3RzKGNvbnRhY3RUeXBlcykge1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGFjdFR5cGVzLCBmdW5jdGlvbihjb250YWN0cykge1xuICAgICAgICAgICAgJG1tVXNlci5zdG9yZVVzZXJzKGNvbnRhY3RzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcmUgdXNlciBkYXRhIGZyb20gZGlzY3Vzc2lvbnMgaW4gbG9jYWwgREIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkaXNjdXNzaW9ucyBMaXN0IG9mIGRpc2N1c3Npb25zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3JlVXNlcnNGcm9tRGlzY3Vzc2lvbnMoZGlzY3Vzc2lvbnMpIHtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRpc2N1c3Npb25zLCBmdW5jdGlvbihkaXNjdXNzaW9uLCB1c2VyaWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcmlkICE9ICd1bmRlZmluZWQnICYmICFpc05hTihwYXJzZUludCh1c2VyaWQpKSkge1xuICAgICAgICAgICAgICAgICRtbVVzZXIuc3RvcmVVc2VyKHVzZXJpZCwgZGlzY3Vzc2lvbi5mdWxsbmFtZSwgZGlzY3Vzc2lvbi5wcm9maWxlaW1hZ2V1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmJsb2NrIGEgdXNlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyN1bmJsb2NrQ29udGFjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0byBVc2VyIElEIG9mIHRoZSBwZXJzb24gdG8gdW5ibG9jay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYudW5ibG9ja0NvbnRhY3QgPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ2NvcmVfbWVzc2FnZV91bmJsb2NrX2NvbnRhY3RzJywge1xuICAgICAgICAgICAgdXNlcmlkczogWyB1c2VySWQgXVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW52YWxpZGF0ZUFsbENvbnRhY3RzQ2FjaGUoJG1tU2l0ZS5nZXRVc2VySWQoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2Fzc2lnbicpXG5cbi8qKlxuICogQXNzaWduIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZEFzc2lnbkluZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kQXNzaWduSW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbWFNb2RBc3NpZ24sICRtbVV0aWwsICR0cmFuc2xhdGUsXG4gICAgICAgIG1tYU1vZEFzc2lnbkNvbXBvbmVudCwgbW1hTW9kQXNzaWduU3VibWlzc2lvbkNvbXBvbmVudCkge1xuICAgIHZhciBtb2R1bGUgPSAkc3RhdGVQYXJhbXMubW9kdWxlIHx8IHt9LFxuICAgICAgICBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZDtcblxuICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAkc2NvcGUuYXNzaWduY29tcG9uZW50ID0gbW1hTW9kQXNzaWduQ29tcG9uZW50O1xuICAgICRzY29wZS5zdWJtaXNzaW9uY29tcG9uZW50ID0gbW1hTW9kQXNzaWduU3VibWlzc2lvbkNvbXBvbmVudDtcbiAgICAkc2NvcGUuYXNzaWdudXJsID0gbW9kdWxlLnVybDtcbiAgICAkc2NvcGUuY291cnNlaWQgPSBjb3Vyc2VpZDtcblxuICAgIGZ1bmN0aW9uIGZldGNoQXNzaWdubWVudChyZWZyZXNoKSB7XG4gICAgICAgIC8vIEdldCBhc3NpZ25tZW50IGRhdGEuXG4gICAgICAgIHJldHVybiAkbW1hTW9kQXNzaWduLmdldEFzc2lnbm1lbnQoY291cnNlaWQsIG1vZHVsZS5pZCwgcmVmcmVzaCkudGhlbihmdW5jdGlvbihhc3NpZ24pIHtcbiAgICAgICAgICAgICRzY29wZS50aXRsZSA9IGFzc2lnbi5uYW1lIHx8ICRzY29wZS50aXRsZTtcbiAgICAgICAgICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IGFzc2lnbi5pbnRybyB8fMKgJHNjb3BlLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgJHNjb3BlLmFzc2lnbiA9IGFzc2lnbjtcblxuICAgICAgICAgICAgLy8gR2V0IGFzc2lnbm1lbnQgc3VibWlzc2lvbnMuXG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEFzc2lnbi5nZXRTdWJtaXNzaW9ucyhhc3NpZ24uaWQsIHJlZnJlc2gpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5jYW52aWV3c3VibWlzc2lvbnMgPSBkYXRhLmNhbnZpZXdzdWJtaXNzaW9ucztcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmNhbnZpZXdzdWJtaXNzaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIHNob3cgdGhlIHVzZXIgZGF0YSBvbiBlYWNoIHN1Ym1pc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kQXNzaWduLmdldFN1Ym1pc3Npb25zVXNlckRhdGEoZGF0YS5zdWJtaXNzaW9ucywgY291cnNlaWQpLnRoZW4oZnVuY3Rpb24oc3VibWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzdWJtaXNzaW9ucywgZnVuY3Rpb24oc3VibWlzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb24udGV4dCA9ICRtbWFNb2RBc3NpZ24uZ2V0U3VibWlzc2lvblRleHQoc3VibWlzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWlzc2lvbi5hdHRhY2htZW50cyA9ICRtbWFNb2RBc3NpZ24uZ2V0U3VibWlzc2lvbkF0dGFjaG1lbnRzKHN1Ym1pc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3VibWlzc2lvbnMgPSBzdWJtaXNzaW9ucztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICR0cmFuc2xhdGUoJ21tLmNvcmUuZXJyb3InKS50aGVuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yICsgJzogZ2V0X2Fzc2lnbm1lbnRfc3VibWlzc2lvbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHRyYW5zbGF0ZSgnbW0uY29yZS5lcnJvcicpLnRoZW4oZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvciArICc6IGdldF9hc3NpZ25tZW50Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZldGNoQXNzaWdubWVudCgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5hc3NpZ25tZW50TG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgICRzY29wZS5yZWZyZXNoQXNzaWdubWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmZXRjaEFzc2lnbm1lbnQodHJ1ZSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9hc3NpZ24nKVxuXG4vKipcbiAqIEFzc2lnbiBzdWJtaXNzaW9uIGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZEFzc2lnblN1Ym1pc3Npb25DdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RBc3NpZ25TdWJtaXNzaW9uQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCBtbWFNb2RBc3NpZ25TdWJtaXNzaW9uQ29tcG9uZW50KSB7XG4gICAgdmFyIHN1Ym1pc3Npb24gPSAkc3RhdGVQYXJhbXMuc3VibWlzc2lvbiB8fCB7fTtcblxuICAgICRzY29wZS50aXRsZSA9IHN1Ym1pc3Npb24udXNlcmZ1bGxuYW1lO1xuICAgICRzY29wZS5zdWJtaXNzaW9uID0gc3VibWlzc2lvbjtcbiAgICAkc2NvcGUuY29tcG9uZW50ID0gbW1hTW9kQXNzaWduU3VibWlzc2lvbkNvbXBvbmVudDtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2Fzc2lnbicpXG5cbi8qKlxuICogQXNzaWdubWVudHMgc2VydmljZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYXNzaWduXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgJG1tYU1vZEFzc2lnblxuICovXG4uZmFjdG9yeSgnJG1tYU1vZEFzc2lnbicsIGZ1bmN0aW9uKCRtbVNpdGUsICRxLCAkbW1Vc2VyLCAkbW1TaXRlc01hbmFnZXIpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIGFzc2lnbm1lbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYXNzaWduXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RBc3NpZ24jZ2V0QXNzaWdubWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCAgIENvdXJzZSBJRCB0aGUgYXNzaWdubWVudCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbWlkICAgICAgIEFzc2lnbm1lbnQgbW9kdWxlIElELlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlZnJlc2hdIFRydWUgd2hlbiB3ZSBzaG91bGQgbm90IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBhc3NpZ25tZW50LlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QXNzaWdubWVudCA9IGZ1bmN0aW9uKGNvdXJzZWlkLCBjbWlkLCByZWZyZXNoKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgXCJjb3Vyc2VpZHNcIjogW2NvdXJzZWlkXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7fTtcblxuICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgcHJlU2V0cy5nZXRGcm9tQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9hc3NpZ25fZ2V0X2Fzc2lnbm1lbnRzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuY291cnNlcyAmJiByZXNwb25zZS5jb3Vyc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBhc3NpZ25tZW50cyA9IHJlc3BvbnNlLmNvdXJzZXNbMF0uYXNzaWdubWVudHM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3NpZ25tZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXNzaWdubWVudHNbaV0uY21pZCA9PSBjbWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXNzaWdubWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYXR0YWNobWVudHMgb2YgYSBzdWJtaXNzaW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQXNzaWduI2dldFN1Ym1pc3Npb25BdHRhY2htZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJtaXNzaW9uIFN1Ym1pc3Npb24uXG4gICAgICogQHJldHVybiB7T2JqZWN0W119ICAgICAgICAgU3VibWlzc2lvbiBhdHRhY2htZW50cy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFN1Ym1pc3Npb25BdHRhY2htZW50cyA9IGZ1bmN0aW9uKHN1Ym1pc3Npb24pIHtcbiAgICAgICAgdmFyIGZpbGVzID0gW107XG4gICAgICAgIGlmIChzdWJtaXNzaW9uLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIHN1Ym1pc3Npb24ucGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4udHlwZSA9PT0gJ2ZpbGUnICYmIHBsdWdpbi5maWxlYXJlYXMgJiYgcGx1Z2luLmZpbGVhcmVhc1swXSAmJiBwbHVnaW4uZmlsZWFyZWFzWzBdLmZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVzID0gcGx1Z2luLmZpbGVhcmVhc1swXS5maWxlcztcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZpbGVzLCBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lID0gZmlsZS5maWxlcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGV4dCBvZiBhIHN1Ym1pc3Npb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYXNzaWduXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RBc3NpZ24jZ2V0U3VibWlzc2lvblRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3VibWlzc2lvbiBTdWJtaXNzaW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFN1Ym1pc3Npb24gdGV4dC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFN1Ym1pc3Npb25UZXh0ID0gZnVuY3Rpb24oc3VibWlzc2lvbikge1xuICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICBpZiAoc3VibWlzc2lvbi5wbHVnaW5zKSB7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc3VibWlzc2lvbi5wbHVnaW5zLCBmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnR5cGUgPT09ICdvbmxpbmV0ZXh0JyAmJiBwbHVnaW4uZWRpdG9yZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBwbHVnaW4uZWRpdG9yZmllbGRzWzBdLnRleHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25saW5lIHRleHQgY29udGFpbnMgJ0BAUExVR0lORklMRUBAJyBmb3IgZWFjaCBlbWJlZGRlZCBmaWxlLiBSZXBsYWNlIHRob3NlIHdpdGggdGhlIHJpZ2h0IFVSTC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5maWxlYXJlYXMgJiYgcGx1Z2luLmZpbGVhcmVhc1swXSAmJiBwbHVnaW4uZmlsZWFyZWFzWzBdLmZpbGVzICYmIHBsdWdpbi5maWxlYXJlYXNbMF0uZmlsZXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlVVJMID0gIHBsdWdpbi5maWxlYXJlYXNbMF0uZmlsZXNbMF0uZmlsZXVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVVUkwgPSBmaWxlVVJMLnN1YnN0cigwLCBmaWxlVVJMLmxhc3RJbmRleE9mKCcvJykpLnJlcGxhY2UoJ3BsdWdpbmZpbGUucGhwLycsICdwbHVnaW5maWxlLnBocD9maWxlPS8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL0BAUExVR0lORklMRUBAL2csIGZpbGVVUkwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBhc3NpZ25tZW50IHN1Ym1pc3Npb25zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQXNzaWduI2dldFN1Ym1pc3Npb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICBpZCAgICAgICAgQXNzaWdubWVudCBpZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWZyZXNoXSBUcnVlIHdoZW4gd2Ugc2hvdWxkIG5vdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIGNhY2hlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aDpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gY2Fudmlld3N1Ym1pc3Npb25zOiBUcnVlIGlmIHVzZXIgY2FuIHZpZXcgc3VibWlzc2lvbnMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gc3VibWlzc2lvbnM6IEFycmF5IG9mIHN1Ym1pc3Npb25zLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U3VibWlzc2lvbnMgPSBmdW5jdGlvbihpZCwgcmVmcmVzaCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIFwiYXNzaWdubWVudGlkc1wiOiBbaWRdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHt9O1xuXG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICBwcmVTZXRzLmdldEZyb21DYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX2Fzc2lnbl9nZXRfc3VibWlzc2lvbnMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiB2aWV3IHN1Ym1pc3Npb25zLCB3aXRoIGVub3VnaCBwZXJtaXNzaW9ucy5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS53YXJuaW5ncy5sZW5ndGggPiAwICYmIHJlc3BvbnNlLndhcm5pbmdzWzBdLndhcm5pbmdjb2RlID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2NhbnZpZXdzdWJtaXNzaW9uczogZmFsc2V9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuYXNzaWdubWVudHMgJiYgcmVzcG9uc2UuYXNzaWdubWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52aWV3c3VibWlzc2lvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uczogcmVzcG9uc2UuYXNzaWdubWVudHNbMF0uc3VibWlzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgZGF0YSBmb3Igc3VibWlzc2lvbnMgc2luY2UgdGhleSBvbmx5IGhhdmUgdXNlcmlkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQXNzaWduI2dldFN1Ym1pc3Npb25zVXNlckRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBzdWJtaXNzaW9ucyBTdWJtaXNzaW9ucyB0byBnZXQgdGhlIGRhdGEgZm9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIGNvdXJzZWlkICAgIElEIG9mIHRoZSBjb3Vyc2UgdGhlIHN1Ym1pc3Npb25zIGJlbG9uZyB0by5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBQcm9taXNlIGFsd2F5cyByZXNvbHZlZC4gUmVzb2x2ZSBwYXJhbSBpcyB0aGUgZm9ybWF0dGVkIHN1Ym1pc3Npb25zLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U3VibWlzc2lvbnNVc2VyRGF0YSA9IGZ1bmN0aW9uKHN1Ym1pc3Npb25zLCBjb3Vyc2VpZCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goc3VibWlzc2lvbnMsIGZ1bmN0aW9uKHN1Ym1pc3Npb24pIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gJG1tVXNlci5nZXRQcm9maWxlKHN1Ym1pc3Npb24udXNlcmlkLCBjb3Vyc2VpZCwgdHJ1ZSkudGhlbihmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgICAgICAgICAgc3VibWlzc2lvbi51c2VyZnVsbG5hbWUgPSB1c2VyLmZ1bGxuYW1lO1xuICAgICAgICAgICAgICAgIHN1Ym1pc3Npb24udXNlcnByb2ZpbGVpbWFnZXVybCA9IHVzZXIucHJvZmlsZWltYWdldXJsO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gRXJyb3IgZ2V0dGluZyBwcm9maWxlLCByZXNvbHZlIHByb21pc2Ugd2l0aG91dCBhZGRpbmcgYW55IGV4dHJhIGRhdGEuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1Ym1pc3Npb25zO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYXNzaWdubWVudHMgcGx1Z2luIGlzIGVuYWJsZWQgaW4gYSBjZXJ0YWluIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYXNzaWduXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RBc3NpZ24jaXNQbHVnaW5FbmFibGVkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2Fzc2lnbl9nZXRfYXNzaWdubWVudHMnKSAmJiBzaXRlLndzQXZhaWxhYmxlKCdtb2RfYXNzaWduX2dldF9zdWJtaXNzaW9ucycpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9hc3NpZ24nKVxuXG4vKipcbiAqIE1vZCBhc3NpZ24gaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RBc3NpZ25IYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZEFzc2lnbkhhbmRsZXJzJywgZnVuY3Rpb24oJG1tQ291cnNlLCAkbW1hTW9kQXNzaWduLCAkc3RhdGUsICRxLCAkbW1Db250ZW50TGlua3NIZWxwZXIpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9hc3NpZ25cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEFzc2lnbkhhbmRsZXJzI2NvdXJzZUNvbnRlbnRcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEFzc2lnbi5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgaW5mby5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIFRoZSBjb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ2Fzc2lnbicpO1xuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2RfYXNzaWduJywge21vZHVsZTogbW9kdWxlLCBjb3Vyc2VpZDogY291cnNlaWR9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQXNzaWduSGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRW5hYmxlZChzaXRlSWQsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEFzc2lnbi5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlSWQgfHwgJG1tQ291cnNlLmNhbkdldE1vZHVsZVdpdGhvdXRDb3Vyc2VJZChzaXRlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGFuIGFzc2lnbiBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy9tb2QvYXNzaWduL3ZpZXcucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIudHJlYXRNb2R1bGVJbmRleFVybChzaXRlSWRzLCB1cmwsIGlzRW5hYmxlZCwgY291cnNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2Jvb2snKVxuXG4vKipcbiAqIEJvb2sgaW5kZXggY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZEJvb2tJbmRleEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZEJvb2tJbmRleEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tVXRpbCwgJG1tYU1vZEJvb2ssICRsb2csIG1tYU1vZEJvb2tDb21wb25lbnQsXG4gICAgICAgICAgICAkaW9uaWNQb3BvdmVyLCAkbW1BcHAsICRxLCAkbW1Db3Vyc2UsICRpb25pY1Njcm9sbERlbGVnYXRlKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tYU1vZEJvb2tJbmRleEN0cmwnKTtcblxuICAgIHZhciBtb2R1bGUgPSAkc3RhdGVQYXJhbXMubW9kdWxlIHx8IHt9LFxuICAgICAgICBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZCxcbiAgICAgICAgY3VycmVudENoYXB0ZXI7XG5cbiAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBtb2R1bGUuZGVzY3JpcHRpb247XG4gICAgJHNjb3BlLmNvbXBvbmVudCA9IG1tYU1vZEJvb2tDb21wb25lbnQ7XG4gICAgJHNjb3BlLmNvbXBvbmVudElkID0gbW9kdWxlLmlkO1xuICAgICRzY29wZS5leHRlcm5hbFVybCA9IG1vZHVsZS51cmw7XG4gICAgJHNjb3BlLmxvYWRlZCA9IGZhbHNlO1xuXG4gICAgdmFyIGNoYXB0ZXJzID0gJG1tYU1vZEJvb2suZ2V0VG9jTGlzdChtb2R1bGUuY29udGVudHMpO1xuICAgIGN1cnJlbnRDaGFwdGVyID0gJG1tYU1vZEJvb2suZ2V0Rmlyc3RDaGFwdGVyKGNoYXB0ZXJzKTtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGxvYWQgYSBib29rIGNoYXB0ZXIuXG4gICAgZnVuY3Rpb24gbG9hZENoYXB0ZXIoY2hhcHRlcklkKSB7XG4gICAgICAgIGN1cnJlbnRDaGFwdGVyID0gY2hhcHRlcklkO1xuICAgICAgICAkaW9uaWNTY3JvbGxEZWxlZ2F0ZS5zY3JvbGxUb3AoKTtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RCb29rLmdldENoYXB0ZXJDb250ZW50KG1vZHVsZS5jb250ZW50cywgY2hhcHRlcklkLCBtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgJHNjb3BlLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgJHNjb3BlLnByZXZpb3VzQ2hhcHRlciA9ICRtbWFNb2RCb29rLmdldFByZXZpb3VzQ2hhcHRlcihjaGFwdGVycywgY2hhcHRlcklkKTtcbiAgICAgICAgICAgICRzY29wZS5uZXh0Q2hhcHRlciA9ICRtbWFNb2RCb29rLmdldE5leHRDaGFwdGVyKGNoYXB0ZXJzLCBjaGFwdGVySWQpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfYm9vay5lcnJvcmNoYXB0ZXInLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUucmVzaXplKCk7IC8vIENhbGwgcmVzaXplIHRvIHJlY2FsY3VsYXRlIHNjcm9sbCBhcmVhLlxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBkb3dubG9hZCBib29rIGNvbnRlbnRzIGFuZCBsb2FkIHRoZSBjdXJyZW50IGNoYXB0ZXIuXG4gICAgZnVuY3Rpb24gZmV0Y2hDb250ZW50KGNoYXB0ZXJJZCkge1xuICAgICAgICB2YXIgZG93bmxvYWRGYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RCb29rLmRvd25sb2FkQWxsQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gTWFyayBkb3dubG9hZCBhcyBmYWlsZWQgYnV0IGdvIG9uIHNpbmNlIHRoZSBtYWluIGZpbGVzIGNvdWxkIGhhdmUgYmVlbiBkb3dubG9hZGVkLlxuICAgICAgICAgICAgZG93bmxvYWRGYWlsZWQgPSB0cnVlO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gU2hvdyBjaGFwdGVyLlxuICAgICAgICAgICAgcmV0dXJuIGxvYWRDaGFwdGVyKGNoYXB0ZXJJZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRGYWlsZWQgJiYgJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY291bGQgbG9hZCB0aGUgbWFpbiBmaWxlIGJ1dCB0aGUgZG93bmxvYWQgZmFpbGVkLiBTaG93IGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZ3NvbWVmaWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkc2NvcGUuZG9SZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNb2RCb29rLmludmFsaWRhdGVDb250ZW50KG1vZHVsZS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaENvbnRlbnQoY3VycmVudENoYXB0ZXIpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEZ1bmN0aW9uIHRvIGxvYWQgYSBjaGFwdGVyLlxuICAgICRzY29wZS5sb2FkQ2hhcHRlciA9IGZ1bmN0aW9uKGNoYXB0ZXJJZCkge1xuICAgICAgICAkc2NvcGUucG9wb3Zlci5oaWRlKCk7XG4gICAgICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgbG9hZENoYXB0ZXIoY2hhcHRlcklkKTtcbiAgICB9O1xuXG4gICAgLy8gTWVudSBwb3BvdmVyLlxuICAgICRzY29wZS50b2MgPSBjaGFwdGVycztcbiAgICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgnYWRkb25zL21vZF9ib29rL3RlbXBsYXRlcy90b2MuaHRtbCcsIHtcbiAgICAgICAgc2NvcGU6ICRzY29wZSxcbiAgICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICAgJHNjb3BlLnBvcG92ZXIgPSBwb3BvdmVyO1xuICAgIH0pO1xuXG5cbiAgICBmZXRjaENvbnRlbnQoY3VycmVudENoYXB0ZXIpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNb2RCb29rLmxvZ1ZpZXcobW9kdWxlLmluc3RhbmNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2Jvb2snKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBuYXZpZ2F0ZSB0byBwcmV2aW91cy9uZXh0IGNoYXB0ZXIgaW4gYSBib29rLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbWFNb2RCb29rQXJyb3dzXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgZGlyZWN0aXZlIHdpbGwgc2hvdyB0d28gYXJyb3dzIGF0IHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgc2NyZWVuIHRvIG5hdmlnYXRlIHRvIHByZXZpb3VzL25leHQgYm9vayBjaGFwdGVyIHdoZW5cbiAqIGNsaWNrZWQuIElmIG5vIHByZXZpb3VzL25leHQgY2hhcHRlciBpcyBkZWZpbmVkLCB0aGF0IGFycm93IHdvbid0IGJlIHNob3duLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSAgIHByZXZpb3VzIElEIG9mIHRoZSBwcmV2aW91cyBjaGFwdGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgbmV4dCAgICAgSUQgb2YgdGhlIG5leHQgY2hhcHRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiAgIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhbiBhcnJvdyBpcyBjbGlja2VkLiBXaWxsIHJlY2VpdmUgYXMgYSBwYXJhbSB0aGUgY2hhcHRlcklkIHRvIGxvYWQuXG4gKi9cbi5kaXJlY3RpdmUoJ21tYU1vZEJvb2tBcnJvd3MnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgcHJldmlvdXM6ICc9PycsXG4gICAgICAgICAgICBuZXh0OiAnPT8nLFxuICAgICAgICAgICAgYWN0aW9uOiAnPT8nXG4gICAgICAgIH0sXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9ib29rL3RlbXBsYXRlcy9hcnJvd3MuaHRtbCdcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfYm9vaycpXG5cbi8qKlxuICogQm9vayBmYWN0b3J5LlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEJvb2tcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RCb29rJywgZnVuY3Rpb24oJG1tRmlsZXBvb2wsICRtbVNpdGUsICRtbUZTLCAkaHR0cCwgJGxvZywgJHEsICRtbVNpdGVzTWFuYWdlciwgbW1hTW9kQm9va0NvbXBvbmVudCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hTW9kQm9vaycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGFsbCB0aGUgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2Rvd25sb2FkQWxsQ29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGNvbnRlbnQgaXMgZG93bmxvYWRlZC4gRGF0YSByZXR1cm5lZCBpcyBub3QgcmVsaWFibGUuXG4gICAgICovXG4gICAgc2VsZi5kb3dubG9hZEFsbENvbnRlbnQgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyhtb2R1bGUpLFxuICAgICAgICAgICAgcmV2aXNpb24gPSAkbW1GaWxlcG9vbC5nZXRSZXZpc2lvbkZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpLFxuICAgICAgICAgICAgdGltZW1vZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZG93bmxvYWRQYWNrYWdlKCRtbVNpdGUuZ2V0SWQoKSwgZmlsZXMsIG1tYU1vZEJvb2tDb21wb25lbnQsIG1vZHVsZS5pZCwgcmV2aXNpb24sIHRpbWVtb2QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXZlbnQgbmFtZXMgb2YgZmlsZXMgYmVpbmcgZG93bmxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2dldERvd25sb2FkaW5nRmlsZXNFdmVudE5hbWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIGV2ZW50IG5hbWVzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RG93bmxvYWRpbmdGaWxlc0V2ZW50TmFtZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW10sXG4gICAgICAgICAgICBldmVudE5hbWVzID0gW10sXG4gICAgICAgICAgICBzaXRlaWQgPSAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZHVsZS5jb250ZW50cywgZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgdmFyIHVybCA9IGNvbnRlbnQuZmlsZXVybDtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbUZpbGVwb29sLmlzRmlsZURvd25sb2FkaW5nQnlVcmwoc2l0ZWlkLCB1cmwpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmdldEZpbGVFdmVudE5hbWVCeVVybChzaXRlaWQsIHVybCkudGhlbihmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lcy5wdXNoKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZmFpbHMuXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnROYW1lcztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGZpbGUgZXZlbnQgbmFtZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9vayNnZXRGaWxlRXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIGFycmF5IG9mICRtbUV2ZW50IG5hbWVzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZUV2ZW50TmFtZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBjb250ZW50LmZpbGV1cmw7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GaWxlcG9vbC5nZXRGaWxlRXZlbnROYW1lQnlVcmwoJG1tU2l0ZS5nZXRJZCgpLCB1cmwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oZXZlbnROYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlcyB0aGF0IGNhbiBiZSBkb3dubG9hZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2sjZ2V0RG93bmxvYWRhYmxlRmlsZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgTGlzdCBvZiBmaWxlcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkYWJsZUZpbGVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IFtdO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzRmlsZURvd25sb2FkYWJsZShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmaWxlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBib29rIHRvYyBhcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2dldFRvY1xuICAgICAqIEBwYXJhbSAge2FycmF5fSBjb250ZW50cyBUaGUgbW9kdWxlIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBUaGUgdG9jLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLmdldFRvYyA9IGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgICAgIGlmICghY29udGVudHMgfHzCoCFjb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50c1swXS5jb250ZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBib29rIHRvYyBhcyBhbiBhcnJheSBvZiBjaGFwdGVycyAobm8gbmVzdGVkKS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2dldFRvY0xpc3RcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gY29udGVudHMgVGhlIG1vZHVsZSBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgVGhlIHRvYyBhcyBhIGxpc3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuZ2V0VG9jTGlzdCA9IGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgICAgIHZhciBjaGFwdGVycyA9IFtdO1xuICAgICAgICB2YXIgdG9jID0gc2VsZi5nZXRUb2MoY29udGVudHMpO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2godG9jLCBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIGNoYXB0ZXJJZCA9IGVsLmhyZWYucmVwbGFjZSgnL2luZGV4Lmh0bWwnLCAnJyk7XG4gICAgICAgICAgICBjaGFwdGVycy5wdXNoKHtpZDogY2hhcHRlcklkLCB0aXRsZTogZWwudGl0bGUsIGxldmVsOiBlbC5sZXZlbH0pO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVsLnN1Yml0ZW1zLCBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgICAgICBjaGFwdGVySWQgPSBzZWwuaHJlZi5yZXBsYWNlKCcvaW5kZXguaHRtbCcsICcnKTtcbiAgICAgICAgICAgICAgICBjaGFwdGVycy5wdXNoKHtpZDogY2hhcHRlcklkLCB0aXRsZTogc2VsLnRpdGxlLCBsZXZlbDogc2VsLmxldmVsfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFwdGVycztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmaXJzdCBjaGFwdGVyIG9mIGEgYm9vay5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2dldEZpcnN0Q2hhcHRlclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBjaGFwdGVycyAgVGhlIGNoYXB0ZXJzIGxpc3QuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICBUaGUgY2hhcHRlciBpZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5nZXRGaXJzdENoYXB0ZXIgPSBmdW5jdGlvbihjaGFwdGVycykge1xuICAgICAgICBpZiAoIWNoYXB0ZXJzIHx8ICFjaGFwdGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhcHRlcnNbMF0uaWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJldmlvdXMgY2hhcHRlciB0byB0aGUgZ2l2ZW4gb25lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2sjZ2V0UHJldmlvdXNDaGFwdGVyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IGNoYXB0ZXJzICAgICBUaGUgY2hhcHRlcnMgbGlzdC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNoYXB0ZXJJZCAgIFRoZSBjdXJyZW50IGNoYXB0ZXIuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICBUaGUgcHJldmlvdXMgY2hhcHRlciBpZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5nZXRQcmV2aW91c0NoYXB0ZXIgPSBmdW5jdGlvbihjaGFwdGVycywgY2hhcHRlcklkKSB7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoYXB0ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2hhcHRlcnNbaV0uaWQgPT0gY2hhcHRlcklkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91cyA9IGNoYXB0ZXJzW2ldLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgY2hhcHRlciB0byB0aGUgZ2l2ZW4gb25lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2sjZ2V0TmV4dENoYXB0ZXJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gY2hhcHRlcnMgICAgIFRoZSBjaGFwdGVycyBsaXN0LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gY2hhcHRlcklkICAgVGhlIGN1cnJlbnQgY2hhcHRlci5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgIFRoZSBuZXh0IGNoYXB0ZXIgaWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuZ2V0TmV4dENoYXB0ZXIgPSBmdW5jdGlvbihjaGFwdGVycywgY2hhcHRlcklkKSB7XG4gICAgICAgIHZhciBuZXh0ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hhcHRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaGFwdGVyc1tpXS5pZCA9PSBjaGFwdGVySWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoYXB0ZXJzW2kgKyAxXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY2hhcHRlcnNbaSArIDFdLmlkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjaGFwdGVyIGNvbnRlbnRzIGZyb20gdGhlIGJvb2suXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9vayNnZXRDaGFwdGVyQ29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZW50cyAgICAgVGhlIG1vZHVsZSBjb250ZW50cy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhcHRlcklkICAgIENoYXB0ZXIgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBtb2R1bGVJZCAgICBUaGUgbW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5nZXRDaGFwdGVyQ29udGVudCA9IGZ1bmN0aW9uKGNvbnRlbnRzLCBjaGFwdGVySWQsIG1vZHVsZUlkKSB7XG4gICAgICAgIHZhciBpbmRleFVybCxcbiAgICAgICAgICAgIHBhdGhzID0ge30sXG4gICAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIGluZm9ybWF0aW9uIGFib3V0IHBhdGhzIGZyb20gdGhlIG1vZHVsZSBjb250ZW50cy5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBjb250ZW50LmZpbGV1cmw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluZGV4VXJsICYmIGNvbnRlbnQuZmlsZW5hbWUgPT0gJ2luZGV4Lmh0bWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGNoYXB0ZXIsIHdlIGRvbid0IGhhdmUgYSBjaGFwdGVyIGlkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC5maWxlcGF0aCA9PSBcIi9cIiArIGNoYXB0ZXJJZCArIFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFVybCA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGNvbnRlbnQuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhzW2tleV0gPSB1cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQcm9taXNlIGhhbmRsaW5nIHdoZW4gd2UgYXJlIGluIGEgYnJvd3Nlci5cbiAgICAgICAgcHJvbWlzZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZDtcbiAgICAgICAgICAgIGlmICghaW5kZXhVcmwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBldmVyIHRoYXQgaGFwcGVucy5cbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdDb3VsZCBub3QgbG9jYXRlIHRoZSBpbmRleCBjaGFwdGVyJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpbGUgc3lzdGVtIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZG93bmxvYWRVcmwoJG1tU2l0ZS5nZXRJZCgpLCBpbmRleFVybCwgZmFsc2UsIG1tYU1vZEJvb2tDb21wb25lbnQsIG1vZHVsZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgcmV0dXJuIHRoZSBsaXZlIFVSTC5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgkbW1TaXRlLmZpeFBsdWdpbmZpbGVVUkwoaW5kZXhVcmwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIFVSTCBjb250ZW50LlxuICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldCh1cmwpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBjb250ZW50LCB3ZSB1cGRhdGUgdGhlIFNSQyB0byBwb2ludCBiYWNrIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBleHRlcm5hbCByZXNvdXJjZS4gVGhhdCB3aWxsIGJlIGNhdWdodCBieSBtbS1mb3JtYXQtdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwuaHRtbChyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGh0bWwuZmluZCgnaW1nJyksIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyYyA9IHBhdGhzW2RlY29kZVVSSUNvbXBvbmVudChpbWcuZ2V0QXR0cmlidXRlKCdzcmMnKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnc3JjJywgc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoZSBzYW1lIGZvciBsaW5rcy5cbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGh0bWwuZmluZCgnYScpLCBmdW5jdGlvbihhbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBocmVmID0gcGF0aHNbZGVjb2RlVVJJQ29tcG9uZW50KGFuY2hvci5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBocmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBodG1sLmh0bWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgdGhlIHByZWZldGNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2ludmFsaWRhdGVDb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZUlkIFRoZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmludmFsaWRhdGVGaWxlc0J5Q29tcG9uZW50KCRtbVNpdGUuZ2V0SWQoKSwgbW1hTW9kQm9va0NvbXBvbmVudCwgbW9kdWxlSWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGZpbGUgaXMgZG93bmxvYWRhYmxlLiBUaGUgZmlsZSBwYXJhbSBtdXN0IGhhdmUgYSAndHlwZScgYXR0cmlidXRlIGxpa2UgaW4gY29yZV9jb3Vyc2VfZ2V0X2NvbnRlbnRzIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2sjaXNGaWxlRG93bmxvYWRhYmxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGUgRmlsZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICBUcnVlIGlmIGRvd25sb2FkYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNGaWxlRG93bmxvYWRhYmxlID0gZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICByZXR1cm4gZmlsZS50eXBlID09PSAnZmlsZSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGlzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9vayNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gc2l0ZS5nZXRJbmZvKCkudmVyc2lvbjtcbiAgICAgICAgICAgIC8vIFJlcXVpcmUgTW9vZGxlIDIuOS5cbiAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uICYmIChwYXJzZUludCh2ZXJzaW9uKSA+PSAyMDE1MDUxMTAwKSAmJiBzaXRlLmNhbkRvd25sb2FkRmlsZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCBhIGJvb2sgYXMgYmVpbmcgdmlld2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2sjbG9nVmlld1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBNb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgY2FsbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHNlbGYubG9nVmlldyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBib29raWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9ib29rX3ZpZXdfYm9vaycsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCB0aGUgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI3ByZWZldGNoQ29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGNvbnRlbnQgaXMgZG93bmxvYWRlZC4gRGF0YSByZXR1cm5lZCBpcyBub3QgcmVsaWFibGUuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaENvbnRlbnQgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyhtb2R1bGUpLFxuICAgICAgICAgICAgcmV2aXNpb24gPSAkbW1GaWxlcG9vbC5nZXRSZXZpc2lvbkZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpLFxuICAgICAgICAgICAgdGltZW1vZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wucHJlZmV0Y2hQYWNrYWdlKCRtbVNpdGUuZ2V0SWQoKSwgZmlsZXMsIG1tYU1vZEJvb2tDb21wb25lbnQsIG1vZHVsZS5pZCwgcmV2aXNpb24sIHRpbWVtb2QpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2Jvb2snKVxuXG4vKipcbiAqIE1vZCBib29rIGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEJvb2tIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZEJvb2tIYW5kbGVycycsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tYU1vZEJvb2ssICRtbUV2ZW50cywgJHN0YXRlLCAkbW1TaXRlLCAkbW1VdGlsLCAkbW1GaWxlcG9vbCxcbiAgICAgICAgICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUsIG1tQ29yZURvd25sb2FkaW5nLCBtbUNvcmVOb3REb3dubG9hZGVkLCBtbUNvcmVPdXRkYXRlZCwgbW1Db3JlRG93bmxvYWRlZCxcbiAgICAgICAgICAgIG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsIG1tYU1vZEJvb2tDb21wb25lbnQsICRtbUNvbnRlbnRMaW5rc0hlbHBlciwgJHEpIHtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2tIYW5kbGVycyNjb3Vyc2VDb250ZW50SGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYuY291cnNlQ29udGVudEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEJvb2suaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyk7XG5cbiAgICAgICAgICAgICAgICBkb3dubG9hZEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWlvcy1jbG91ZC1kb3dubG9hZC1vdXRsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLmRvd25sb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZEJvb2sucHJlZmV0Y2hDb250ZW50KG1vZHVsZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRkZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1hbmRyb2lkLXJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ21tLmNvcmUucmVmcmVzaCcsXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kQm9vay5pbnZhbGlkYXRlQ29udGVudChtb2R1bGUuaWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZEJvb2sucHJlZmV0Y2hDb250ZW50KG1vZHVsZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3JlLmVycm9yZG93bmxvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYygnYm9vaycpO1xuICAgICAgICAgICAgICAgICRzY29wZS5idXR0b25zID0gW2Rvd25sb2FkQnRuLCByZWZyZXNoQnRuXTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1vZF9ib29rJywge21vZHVsZTogbW9kdWxlLCBjb3Vyc2VpZDogY291cnNlaWR9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gU2hvdyBidXR0b25zIGFjY29yZGluZyB0byBtb2R1bGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zcGlubmVyID0gc3RhdHVzID09PSBtbUNvcmVEb3dubG9hZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkQnRuLmhpZGRlbiA9IHN0YXR1cyAhPT0gbW1Db3JlTm90RG93bmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBzaG93IHJlZnJlc2ggYnV0dG9uIGlmIGEgYm9vayBpcyBkb3dubG9hZGVkIGJlY2F1c2UgcmV2aXNpb24gYW5kIHRpbWVtb2RpZmllZCBhcmVuJ3QgcmVsaWFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoQnRuLmhpZGRlbiA9IHN0YXR1cyAhPT0gbW1Db3JlT3V0ZGF0ZWQgJibCoHN0YXR1cyAhPT0gbW1Db3JlRG93bmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgY2hhbmdlcyBvbiB0aGlzIG1vZHVsZSBzdGF0dXMuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c09ic2VydmVyID0gJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2l0ZWlkID09PSAkbW1TaXRlLmdldElkKCkgJiYgZGF0YS5jb21wb25lbnRJZCA9PT0gbW9kdWxlLmlkICYmIGRhdGEuY29tcG9uZW50ID09PSBtbWFNb2RCb29rQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93U3RhdHVzKGRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgc3RhdHVzIHRvIGRlY2lkZSB3aGljaCBpY29uIHNob3VsZCBiZSBzaG93bi5cbiAgICAgICAgICAgICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLmdldE1vZHVsZVN0YXR1cyhtb2R1bGUsIGNvdXJzZWlkLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKS50aGVuKHNob3dTdGF0dXMpO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzT2JzZXJ2ZXIgJiYgc3RhdHVzT2JzZXJ2ZXIub2ZmICYmIHN0YXR1c09ic2VydmVyLm9mZigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2tIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kQm9vay5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlSWQgfHwgJG1tQ291cnNlLmNhbkdldE1vZHVsZVdpdGhvdXRDb3Vyc2VJZChzaXRlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgYm9vayBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy9tb2QvYm9vay92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9ib29rJylcblxuLyoqXG4gKiBNb2QgYm9vayBwcmVmZXRjaCBoYW5kbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEJvb2tQcmVmZXRjaEhhbmRsZXJcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RCb29rUHJlZmV0Y2hIYW5kbGVyJywgZnVuY3Rpb24oJG1tYU1vZEJvb2ssIG1tQ29yZURvd25sb2FkZWQsIG1tQ29yZU91dGRhdGVkLCBtbWFNb2RCb29rQ29tcG9uZW50KSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgc2VsZi5jb21wb25lbnQgPSBtbWFNb2RCb29rQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBzdGF0dXMgb2YgYSBtb2R1bGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdHVzIGRldGVjdGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2tQcmVmZXRjaEhhbmRsZXIjZGV0ZXJtaW5lU3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXR1cyBDdXJyZW50IHN0YXR1cy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFN0YXR1cyB0byBzaG93LlxuICAgICAqL1xuICAgIHNlbGYuZGV0ZXJtaW5lU3RhdHVzID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IG1tQ29yZURvd25sb2FkZWQpIHtcbiAgICAgICAgICAgIC8vIEJvb2tzIGFyZSBhbHdheXMgdHJlYXRlZCBhcyBvdXRkYXRlZCBzaW5jZSByZXZpc2lvbiBhbmQgdGltZW1vZGlmaWVkIGFyZW4ndCByZWxpYWJsZS5cbiAgICAgICAgICAgIHJldHVybiBtbUNvcmVPdXRkYXRlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkb3dubG9hZCBzaXplIG9mIGEgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2tQcmVmZXRjaEhhbmRsZXIjZ2V0RG93bmxvYWRTaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBNb2R1bGUgdG8gZ2V0IHRoZSBzaXplLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgU2l6ZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkU2l6ZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICgkbW1hTW9kQm9vay5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkgJiYgY29udGVudC5maWxlc2l6ZSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBzaXplICsgY29udGVudC5maWxlc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2tQcmVmZXRjaEhhbmRsZXIjaXNFbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZEJvb2suaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIHRoZSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9va1ByZWZldGNoSGFuZGxlciNwcmVmZXRjaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGZpbGVzIGhhdmUgYmVlbiBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kQm9vay5wcmVmZXRjaENvbnRlbnQobW9kdWxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9jaGF0JylcblxuLyoqXG4gKiBDaGF0IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2NoYXRcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RDaGF0Q2hhdEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZENoYXRDaGF0Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1BcHAsICRtbWFNb2RDaGF0LCAkbG9nLCAkaW9uaWNNb2RhbCwgJG1tVXRpbCwgJGlvbmljSGlzdG9yeSxcbiAgICAgICAgICAgICRpb25pY1Njcm9sbERlbGVnYXRlLCAkdGltZW91dCwgJG1tU2l0ZSwgJGludGVydmFsLCBtbWFDaGF0UG9sbEludGVydmFsKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1hTW9kQ2hhdENoYXRDdHJsJyk7XG5cbiAgICB2YXIgY2hhdElkID0gJHN0YXRlUGFyYW1zLmNoYXRpZCxcbiAgICAgICAgY291cnNlSWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIHRpdGxlID0gJHN0YXRlUGFyYW1zLnRpdGxlLFxuICAgICAgICBwb2xsaW5nO1xuXG4gICAgJHNjb3BlLmxvYWRlZCA9IGZhbHNlO1xuICAgICRzY29wZS50aXRsZSA9IHRpdGxlO1xuICAgICRzY29wZS5jdXJyZW50VXNlcklkID0gJG1tU2l0ZS5nZXRVc2VySWQoKTtcbiAgICAkc2NvcGUuY3VycmVudFVzZXJCZWVwID0gJ2JlZXAgJyArICRzY29wZS5jdXJyZW50VXNlcklkO1xuICAgICRzY29wZS5tZXNzYWdlcyA9IFtdO1xuICAgICRzY29wZS5jaGF0VXNlcnMgPSBbXTtcblxuICAgIC8vIFdlIHVzZSBhbiBvYmplY3QgYmVjYXVzZSBpdCB3b3JrcyBiZXR0ZXIgd2l0aCBmb3Jtcy5cbiAgICAkc2NvcGUubmV3TWVzc2FnZSA9IHtcbiAgICAgICAgdGV4dDogJydcbiAgICB9O1xuICAgIGNoYXRMYXN0VGltZSA9IDA7XG5cbiAgICAvLyBDaGF0IHVzZXJzIG1vZGFsLlxuICAgICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgnYWRkb25zL21vZF9jaGF0L3RlbXBsYXRlcy91c2Vycy5odG1sJywge1xuICAgICAgICBzY29wZTogJHNjb3BlLFxuICAgICAgICBhbmltYXRpb246ICdzbGlkZS1pbi11cCdcbiAgICB9KS50aGVuKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgJHNjb3BlLm1vZGFsID0gbTtcbiAgICB9KTtcblxuICAgIC8vIENsb3NlIHRoZSBjaGF0IHVzZXJzIG1vZGFsLlxuICAgICRzY29wZS5jbG9zZU1vZGFsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgJHNjb3BlLm1vZGFsLmhpZGUoKTtcbiAgICB9O1xuXG4gICAgLy8gRGlzcGxheSB0aGUgY2hhdCB1c2VycyBtb2RhbC5cbiAgICAkc2NvcGUuc2hvd0NoYXRVc2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUudXNlcnNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgJHNjb3BlLm1vZGFsLnNob3coKTtcbiAgICAgICAgJG1tYU1vZENoYXQuZ2V0Q2hhdFVzZXJzKCRzY29wZS5jaGF0c2lkKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICRzY29wZS5jaGF0VXNlcnMgPSBkYXRhLnVzZXJzO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgc2hvd0Vycm9yKGVycm9yLCAnbW1hLm1vZF9jaGF0LmVycm9yd2hpbGVnZXR0aW5nY2hhdHVzZXJzJyk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUudXNlcnNMb2FkZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIFRvIFwidXNlclwiOlxuICAgICRzY29wZS50YWxrVG8gPSBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgICRzY29wZS5uZXdNZXNzYWdlLnRleHQgPSBcIlRvIFwiICsgdXNlciArIFwiOiBcIjtcbiAgICAgICAgJHNjb3BlLm1vZGFsLmhpZGUoKTtcbiAgICB9O1xuXG4gICAgLy8gQmVlcCBhIHVzZXIuXG4gICAgJHNjb3BlLmJlZXBUbyA9IGZ1bmN0aW9uKHVzZXJJZCkge1xuICAgICAgICAkc2NvcGUuc2VuZE1lc3NhZ2UoJycsIHVzZXJJZCk7XG4gICAgICAgICRzY29wZS5tb2RhbC5oaWRlKCk7XG4gICAgfTtcblxuICAgIC8vIENoZWNrIGlzIHRoZSBhcHAgaXMgb2ZmbGluZS5cbiAgICAkc2NvcGUuaXNBcHBPZmZsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhJG1tQXBwLmlzT25saW5lKCk7XG4gICAgfTtcblxuICAgIC8vIFNob3cgZXJyb3IgbW9kYWwuXG4gICAgZnVuY3Rpb24gc2hvd0Vycm9yKGVycm9yLCBkZWZhdWx0TWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGRlZmF1bHRNZXNzYWdlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBkYXRlIHNob3VsZCBiZSBkaXNwbGF5ZWQgYmV0d2VlbiBtZXNzYWdlcyAod2hlbiB0aGUgZGF5IGNoYW5nZXMgYXQgbWlkbmlnaHQgZm9yIGV4YW1wbGUpLlxuICAgICRzY29wZS5zaG93RGF0ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHByZXZNZXNzYWdlKSB7XG4gICAgICAgIGlmICghcHJldk1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZGF5IGhhcyBjaGFuZ2VkLlxuICAgICAgICByZXR1cm4gIW1vbWVudChtZXNzYWdlLnRpbWVzdGFtcCAqIDEwMDApLmlzU2FtZShwcmV2TWVzc2FnZS50aW1lc3RhbXAgKiAxMDAwLCAnZGF5Jyk7XG4gICAgfTtcblxuICAgIC8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjaGF0LlxuICAgICRzY29wZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKHRleHQsIGJlZXApIHtcbiAgICAgICAgYmVlcCA9IGJlZXAgfHwgJyc7XG5cbiAgICAgICAgaWYgKCEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgLy8gU2lsZW50IGVycm9yLCB0aGUgdmlldyBzaG91bGQgcHJldmVudCB0aGlzLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGJlZXAgPT09ICcnICYmICF0ZXh0LnRyaW0oKSkge1xuICAgICAgICAgICAgLy8gU2lsZW50IGVycm9yLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyg/OlxcclxcbnxcXHJ8XFxuKS9nLCAnPGJyIC8+Jyk7XG5cbiAgICAgICAgJG1tYU1vZENoYXQuc2VuZE1lc3NhZ2UoJHNjb3BlLmNoYXRzaWQsIHRleHQsIGJlZXApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoYmVlcCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubmV3TWVzc2FnZS50ZXh0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGNsb3NlIHRoZSBrZXlib2FyZCBpZiBhbiBlcnJvciBoYXBwZW5zLCB3ZSB3YW50IHRoZSB1c2VyIHRvIGJlIGFibGUgdG8gc2VuZCBtdWx0aXBsZVxuICAgICAgICAgICAgLy8gbWVzc2FnZXMgd2l0aG91dHRoZSBrZXlib2FyZCBiZWluZyBjbG9zZWQuXG4gICAgICAgICAgICAkbW1BcHAuY2xvc2VLZXlib2FyZCgpO1xuXG4gICAgICAgICAgICBzaG93RXJyb3IoZXJyb3IsICdtbWEubW9kX2NoYXQuZXJyb3J3aGlsZXNlbmRpbmdtZXNzYWdlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBMb2dpbiB0aGUgdXNlci5cbiAgICAkbW1hTW9kQ2hhdC5sb2dpblVzZXIoY2hhdElkKS50aGVuKGZ1bmN0aW9uKGNoYXRzaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RDaGF0LmdldExhdGVzdE1lc3NhZ2VzKGNoYXRzaWQsIDApLnRoZW4oZnVuY3Rpb24obWVzc2FnZXNJbmZvKSB7XG4gICAgICAgICAgICAkc2NvcGUuY2hhdHNpZCA9IGNoYXRzaWQ7XG4gICAgICAgICAgICBjaGF0TGFzdFRpbWUgPSBtZXNzYWdlc0luZm8uY2hhdG5ld2xhc3R0aW1lO1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RDaGF0LmdldE1lc3NhZ2VzVXNlckRhdGEobWVzc2FnZXNJbmZvLm1lc3NhZ2VzLCBjb3Vyc2VJZCkudGhlbihmdW5jdGlvbihtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgICRzY29wZS5tZXNzYWdlcyA9ICRzY29wZS5tZXNzYWdlcy5jb25jYXQobWVzc2FnZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHNob3dFcnJvcihtZXNzYWdlLCAnbW1hLm1vZF9jaGF0LmVycm9yd2hpbGVyZXRyaWV2aW5nbWVzc2FnZXMnKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgc2hvd0Vycm9yKGVycm9yLCAnbW1hLm1vZF9jaGF0LmVycm9yd2hpbGVjb25uZWN0aW5nJyk7XG4gICAgICAgICRpb25pY0hpc3RvcnkuZ29CYWNrKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBTY3JvbGwgdG8gdGhlIGJvdHRvbS5cbiAgICAkc2NvcGUuc2Nyb2xsQWZ0ZXJSZW5kZXIgPSBmdW5jdGlvbihzY29wZSkge1xuICAgICAgICBpZiAoc2NvcGUuJGxhc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgYSB0aW1lb3V0IHRvIGxlYXZlIHRpbWUgdG8gdGhlIHZpZXcgdG8gYmUgcmVuZGVyZWQuXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVmlldyA9ICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnbW1hQ2hhdFNjcm9sbCcpO1xuICAgICAgICAgICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsQm90dG9tKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTZXQgdXAgdGhlIHBvbGxpbmcgb24gYSB2aWV3IGVudGVyLCB0aGlzIGFsbG93cyBmb3IgdGhlIHVzZXIgdG8gZ28gYmFjayBhbmQgcmVzdW1lIHRoZSBwb2xsaW5nLlxuICAgICRzY29wZS4kb24oJyRpb25pY1ZpZXcuZW50ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gU3RyYW5nZSBjYXNlLCB3ZSBhbHJlYWR5IGhhdmUgdGhlIHBvbGxpbmcgaW4gcGxhY2UuXG4gICAgICAgIGlmIChwb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCBwb2xsaW5nLlxuICAgICAgICBwb2xsaW5nID0gJGludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnUG9sbGluZyBmb3IgbWVzc2FnZXMnKTtcbiAgICAgICAgICAgIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPYnZpb3VzbHkgd2UgY2Fubm90IGNoZWNrIGZvciBuZXcgbWVzc2FnZXMgd2hlbiB0aGUgYXBwIGlzIG9mZmxpbmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkbW1hTW9kQ2hhdC5nZXRMYXRlc3RNZXNzYWdlcygkc2NvcGUuY2hhdHNpZCwgY2hhdExhc3RUaW1lKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjaGF0TGFzdFRpbWUgPSBkYXRhLmNoYXRuZXdsYXN0dGltZTtcbiAgICAgICAgICAgICAgICAkbW1hTW9kQ2hhdC5nZXRNZXNzYWdlc1VzZXJEYXRhKGRhdGEubWVzc2FnZXMsIGNvdXJzZUlkKS50aGVuKGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5tZXNzYWdlcyA9ICRzY29wZS5tZXNzYWdlcy5jb25jYXQobWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkaW50ZXJ2YWwuY2FuY2VsKHBvbGxpbmcpO1xuICAgICAgICAgICAgICAgIHNob3dFcnJvcihlcnJvciwgJ21tYS5tb2RfY2hhdC5lcnJvcndoaWxlcmV0cmlldmluZ21lc3NhZ2VzJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBtbWFDaGF0UG9sbEludGVydmFsKTtcbiAgICB9KTtcblxuICAgIC8vIFJlbW92aW5nIHRoZSBwb2xsaW5nIGFzIHdlIGxlYXZlIHRoZSBwYWdlLlxuICAgICRzY29wZS4kb24oJyRpb25pY1ZpZXcubGVhdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChwb2xsaW5nKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdDYW5jZWxsaW5nIHBvbGxpbmcgZm9yIGNvbnZlcnNhdGlvbicpO1xuICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbChwb2xsaW5nKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9jaGF0JylcblxuLyoqXG4gKiBDaGF0IGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2NoYXRcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RDaGF0SW5kZXhDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RDaGF0SW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbWFNb2RDaGF0LCAkbW1VdGlsLCAkcSwgJG1tQ291cnNlKSB7XG4gICAgdmFyIG1vZHVsZSA9ICRzdGF0ZVBhcmFtcy5tb2R1bGUgfHwge30sXG4gICAgICAgIGNvdXJzZWlkID0gJHN0YXRlUGFyYW1zLmNvdXJzZWlkLFxuICAgICAgICBjaGF0O1xuXG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbW9kdWxlLmRlc2NyaXB0aW9uO1xuICAgICRzY29wZS5tb2R1bGV1cmwgPSBtb2R1bGUudXJsO1xuICAgICRzY29wZS5jb3Vyc2VpZCA9IGNvdXJzZWlkO1xuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IGNoYXQgZGF0YS5cbiAgICBmdW5jdGlvbiBmZXRjaENoYXREYXRhKHJlZnJlc2gpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RDaGF0LmdldENoYXQoY291cnNlaWQsIG1vZHVsZS5pZCwgcmVmcmVzaCkudGhlbihmdW5jdGlvbihjaGF0ZGF0YSkge1xuICAgICAgICAgICAgY2hhdCA9IGNoYXRkYXRhO1xuICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gY2hhdC5uYW1lIHx8ICRzY29wZS50aXRsZTtcbiAgICAgICAgICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IGNoYXQuaW50cm8gfHzCoCRzY29wZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICRzY29wZS5jaGF0SWQgPSBjaGF0LmlkO1xuICAgICAgICAgICAgJHNjb3BlLmNoYXRTY2hlZHVsZWQgPSAnJztcblxuICAgICAgICAgICAgdmFyIG5vdyA9ICRtbVV0aWwudGltZXN0YW1wKCk7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGNoYXQuY2hhdHRpbWUgLSBub3c7XG5cbiAgICAgICAgICAgIGlmIChjaGF0LmNoYXR0aW1lICYmIGNoYXQuc2NoZWR1bGUgPiAwICYmIHNwYW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5mb3JtYXRUaW1lKHNwYW4pLnRoZW4oZnVuY3Rpb24odGltZSkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2hhdFNjaGVkdWxlZCA9IHRpbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghcmVmcmVzaCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBjaGF0IGZhaWxlZCwgcmV0cnkgd2l0aG91dCB1c2luZyBjYWNoZSBzaW5jZSBpdCBtaWdodCBiZSBhIG5ldyBhY3Rpdml0eS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hDaGF0RGF0YSh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfY2hhdC5lcnJvcndoaWxlZ2V0dGluZ2NoYXRkYXRhJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZldGNoQ2hhdERhdGEoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTW9kQ2hhdC5sb2dWaWV3KGNoYXQuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5jaGF0TG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIFB1bGwgdG8gcmVmcmVzaC5cbiAgICAkc2NvcGUucmVmcmVzaENoYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmV0Y2hDaGF0RGF0YSh0cnVlKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pOyIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9jaGF0JylcblxuLyoqXG4gKiBDaGF0IHNlcnZpY2UuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2NoYXRcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kQ2hhdFxuICovXG4uZmFjdG9yeSgnJG1tYU1vZENoYXQnLCBmdW5jdGlvbigkcSwgJG1tU2l0ZSwgJG1tVXNlciwgJG1tU2l0ZXNNYW5hZ2VyKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaXMgZW5hYmxlZCBpbiBhIGNlcnRhaW4gc2l0ZS4gUGx1Z2luIGlzIGVuYWJsZWQgaWYgdGhlIGNoYXQgV1MgYXJlIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaGF0XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaGF0I2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIHBsdWdpbiBpcyBlbmFibGVkLCByZWplY3RlZCBvciByZXNvbHZlZCB3aXRoIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICBzaXRlLndzQXZhaWxhYmxlKCdtb2RfY2hhdF9nZXRfY2hhdHNfYnlfY291cnNlcycpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9jaGF0X2xvZ2luX3VzZXInKSAmJlxuICAgICAgICAgICAgICAgICAgICBzaXRlLndzQXZhaWxhYmxlKCdtb2RfY2hhdF9nZXRfY2hhdF91c2VycycpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9jaGF0X3NlbmRfY2hhdF9tZXNzYWdlJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2NoYXRfZ2V0X2NoYXRfbGF0ZXN0X21lc3NhZ2VzJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBjaGF0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2NoYXRcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENoYXQjZ2V0Q2hhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNtaWQgICAgIENvdXJzZSBtb2R1bGUgSUQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVmcmVzaF0gVHJ1ZSB3aGVuIHdlIHNob3VsZCBub3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjaGF0IGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldENoYXQgPSBmdW5jdGlvbihjb3Vyc2VpZCwgY21pZCwgcmVmcmVzaCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgY291cnNlaWRzOiBbY291cnNlaWRdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHt9O1xuXG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICBwcmVTZXRzLmdldEZyb21DYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX2NoYXRfZ2V0X2NoYXRzX2J5X2NvdXJzZXMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5jaGF0cykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2hhdDtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzcG9uc2UuY2hhdHMsIGZ1bmN0aW9uKGNoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXQuY291cnNlbW9kdWxlID09IGNtaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGF0ID0gY2hhdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudENoYXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgY2hhdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaGF0XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaGF0I2xvZ2luVXNlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGF0SWQgICBDaGF0IGluc3RhbmNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGlzIGV4ZWN1dGVkLlxuICAgICAqL1xuICAgIHNlbGYubG9naW5Vc2VyID0gZnVuY3Rpb24oY2hhdElkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBjaGF0aWQ6IGNoYXRJZFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfY2hhdF9sb2dpbl91c2VyJywgcGFyYW1zKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuY2hhdHNpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5jaGF0c2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IGEgY2hhdCBhcyBiZWluZyB2aWV3ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hhdFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hhdCNsb2dWaWV3XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIE1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sb2dWaWV3ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNoYXRpZDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2NoYXRfdmlld19jaGF0JywgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIGEgY2hhdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaGF0XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaGF0I3NlbmRNZXNzYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXRzaWQgIENoYXQgc2Vzc2lvbmQgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgIE1lc3NhZ2UgdGV4dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYmVlcCAgICAgQmVlcCB1c2VyIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGlzIGV4ZWN1dGVkLlxuICAgICAqL1xuICAgIHNlbGYuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbihjaGF0c2lkLCBtZXNzYWdlLCBiZWVwKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBjaGF0c2lkOiBjaGF0c2lkLFxuICAgICAgICAgICAgbWVzc2FnZXRleHQ6IG1lc3NhZ2UsXG4gICAgICAgICAgICBiZWVwaWQ6IGJlZXBcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2NoYXRfc2VuZF9jaGF0X21lc3NhZ2UnLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5tZXNzYWdlaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UubWVzc2FnZWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYXRlc3QgbWVzc2FnZXMgZnJvbSBhIGNoYXQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hhdFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hhdCNnZXRMYXRlc3RNZXNzYWdlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGF0c2lkICBDaGF0IHNlc3Npb25kIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsYXN0dGltZSBMYXN0IHRpbWUgd2hlbiBtZXNzYWdlcyB3ZXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBpcyBleGVjdXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldExhdGVzdE1lc3NhZ2VzID0gZnVuY3Rpb24oY2hhdHNpZCwgbGFzdHRpbWUpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNoYXRzaWQ6IGNoYXRzaWQsXG4gICAgICAgICAgICBjaGF0bGFzdHRpbWU6IGxhc3R0aW1lXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwcmVTZXRzID0ge1xuICAgICAgICAgICAgZ2V0RnJvbUNhY2hlOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9jaGF0X2dldF9jaGF0X2xhdGVzdF9tZXNzYWdlcycsIHBhcmFtcywgcHJlU2V0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGRhdGEgZm9yIG1lc3NhZ2VzIHNpbmNlIHRoZXkgb25seSBoYXZlIHVzZXJpZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaGF0I2dldE1lc3NhZ2VzVXNlckRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBtZXNzYWdlcyAgICBNZXNzYWdlcyB0byBnZXQgdGhlIGRhdGEgZm9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIGNvdXJzZWlkICAgIElEIG9mIHRoZSBjb3Vyc2UgdGhlIG1lc3NhZ2VzIGJlbG9uZyB0by5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBQcm9taXNlIGFsd2F5cyByZXNvbHZlZC4gUmVzb2x2ZSBwYXJhbSBpcyB0aGUgZm9ybWF0dGVkIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0TWVzc2FnZXNVc2VyRGF0YSA9IGZ1bmN0aW9uKG1lc3NhZ2VzLCBjb3Vyc2VpZCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2gobWVzc2FnZXMsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gJG1tVXNlci5nZXRQcm9maWxlKG1lc3NhZ2UudXNlcmlkLCBjb3Vyc2VpZCwgdHJ1ZSkudGhlbihmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS51c2VyZnVsbG5hbWUgPSB1c2VyLmZ1bGxuYW1lO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcnByb2ZpbGVpbWFnZXVybCA9IHVzZXIucHJvZmlsZWltYWdldXJsO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gRXJyb3IgZ2V0dGluZyBwcm9maWxlLiBTZXQgZGVmYXVsdCBkYXRhLlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcmZ1bGxuYW1lID0gbWVzc2FnZS51c2VyaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhY3RpdmVzIHVzZXJzIG9mIGEgY3VycmVudCBjaGF0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2NoYXRcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENoYXQjZ2V0Q2hhdFVzZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXRzaWQgIENoYXQgc2Vzc2lvbmQgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgaXMgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRDaGF0VXNlcnMgPSBmdW5jdGlvbihjaGF0c2lkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBjaGF0c2lkOiBjaGF0c2lkXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwcmVTZXRzID0ge1xuICAgICAgICAgICAgZ2V0RnJvbUNhY2hlOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9jaGF0X2dldF9jaGF0X3VzZXJzJywgcGFyYW1zLCBwcmVTZXRzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTsiLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfY2hhdCcpXG5cbi8qKlxuICogTW9kIGNoYXQgaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2NoYXRcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kQ2hhdEhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kQ2hhdEhhbmRsZXJzJywgZnVuY3Rpb24oJG1tQ291cnNlLCAkbW1hTW9kQ2hhdCwgJHN0YXRlLCAkbW1Db250ZW50TGlua3NIZWxwZXIsICRxKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvdXJzZSBjb250ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hhdFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hhdEhhbmRsZXJzI2NvdXJzZUNvbnRlbnRcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZENoYXQuaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKCdjaGF0Jyk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1vZF9jaGF0Jywge21vZHVsZTogbW9kdWxlLCBjb3Vyc2VpZDogY291cnNlaWR9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2NoYXRcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENoYXRIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kQ2hhdC5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlSWQgfHwgJG1tQ291cnNlLmNhbkdldE1vZHVsZVdpdGhvdXRDb3Vyc2VJZChzaXRlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgY2hhdCBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy9tb2QvY2hhdC92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTsiLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfY2hvaWNlJylcblxuLyoqXG4gKiBDaG9pY2UgaW5kZXggY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hvaWNlXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kQ2hvaWNlSW5kZXhDdHJsXG4gKiBAdG9kbyBEZWxldGUgYW5zd2VyIGlmIHVzZXIgY2FuIHVwZGF0ZSB0aGUgYW5zd2VyLCBzaG93IHNlbGVjdGVkIGlmIGNob2ljZSBpcyBjbG9zZWQgKFdTIHJldHVybnMgZW1wdHkgb3B0aW9ucykuXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RDaG9pY2VJbmRleEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICR0aW1lb3V0LCAkc3RhdGVQYXJhbXMsICRtbWFNb2RDaG9pY2UsICRtbVV0aWwsICRxLCAkbW1Db3Vyc2UsICR0cmFuc2xhdGUpIHtcbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIGNob2ljZSxcbiAgICAgICAgaGFzQW5zd2VyZWQgPSBmYWxzZTtcblxuICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAkc2NvcGUubW9kdWxldXJsID0gbW9kdWxlLnVybDtcbiAgICAkc2NvcGUuY291cnNlaWQgPSBjb3Vyc2VpZDtcblxuICAgICRzY29wZS5kM19vcHRpb25zID0ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgICAgdHlwZTogJ2Rpc2NyZXRlQmFyQ2hhcnQnLFxuICAgICAgICAgICAgeDogZnVuY3Rpb24oZCl7IHJldHVybiBkLmxhYmVsOyB9LFxuICAgICAgICAgICAgeTogZnVuY3Rpb24oZCl7IHJldHVybiBkLnZhbHVlOyB9LFxuICAgICAgICAgICAgc2hvd1ZhbHVlczogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlRm9ybWF0OiBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDMuZm9ybWF0KCcnKShkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IDUwMCxcbiAgICAgICAgICAgIHhBeGlzOiB7fSxcbiAgICAgICAgICAgIHlBeGlzOiB7XG4gICAgICAgICAgICAgICAgdGlja0Zvcm1hdDogZnVuY3Rpb24oZCl7IHJldHVybiBkMy5mb3JtYXQoJyxmJykoZCkgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbnZkMy1jb21tdW5pdHkuZ2l0aHViLmlvL252ZDMvZXhhbXBsZXMvZG9jdW1lbnRhdGlvbi5odG1sI3Rvb2x0aXBcbiAgICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50R2VuZXJhdG9yOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQzLmZvcm1hdCgnLjElJykob2JqLmRhdGEucGVyY2VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlzcG8vYW5ndWxhci1udmQzL2lzc3Vlcy8zNlxuICAgICAgICAgICAgZGlzY3JldGViYXI6IHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaDoge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJFbmQ6IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKFwiLnRpY2sgdGV4dFwiKS5jYWxsKHdyYXAsX2NoYXJ0LnhBeGlzLnJhbmdlQmFuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KXtcbiAgICAgICAgICAgICAgICBfY2hhcnQgPSBjaGFydDsgLy9nbG9iYWwgdmFyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmUtd3JhcCB4LWF4aXMgbGFiZWxzIGFmdGVyIChzd2lwZSBkb3duKSByZWZyZXNoXG4gICAgJHNjb3BlLmQzX2V2ZW50cyA9IHtcbiAgICAgICAgJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnOiBmdW5jdGlvbihlLCBzY29wZSkge1xuICAgICAgICAgICAgLy8gVGhlIG1pcmt5IGRlcHRocyBvZiBBbmd1bGFyIHJlcXVpcmUgd3JhcHBpbmcgdGhpcyBldmVudCBoYW5kbGVyIGluICR0aW1lb3V0KClcbiAgICAgICAgICAgIC8vIGZvciB0aGUgdGV4dCB3cmFwcGluZyB0byBwZXJzaXN0IGluIHRoZSBET00uXG4gICAgICAgICAgICAvLyBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va3Jpc3BvL2FuZ3VsYXItbnZkMy9pc3N1ZXMvMzZcbiAgICAgICAgICAgIC8vIGJhY2tncm91bmQ6IGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2Vycm9yLyRyb290U2NvcGUvaW5wcm9nXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtkMy5zZWxlY3RBbGwoXCIudGljayB0ZXh0XCIpLmNhbGwod3JhcCxfY2hhcnQueEF4aXMucmFuZ2VCYW5kKCkpO30sIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGh0dHA6Ly9ibC5vY2tzLm9yZy9tYm9zdG9jay83NTU1MzIxXG4gICAgZnVuY3Rpb24gd3JhcCh0ZXh0LCB3aWR0aCkge1xuICAgICAgdGV4dC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGV4dCA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgIHdvcmRzID0gdGV4dC50ZXh0KCkuc3BsaXQoL1xccysvKS5yZXZlcnNlKCksXG4gICAgICAgICAgICB3b3JkLFxuICAgICAgICAgICAgbGluZSA9IFtdLFxuICAgICAgICAgICAgbGluZU51bWJlciA9IDAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gMS4xLCAvLyBlbXNcbiAgICAgICAgICAgIHkgPSB0ZXh0LmF0dHIoXCJ5XCIpLFxuICAgICAgICAgICAgZHkgPSBwYXJzZUZsb2F0KHRleHQuYXR0cihcImR5XCIpKSxcbiAgICAgICAgICAgIHRzcGFuID0gdGV4dC50ZXh0KG51bGwpLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJ5XCIsIHkpLmF0dHIoXCJkeVwiLCBkeSArIFwiZW1cIik7XG4gICAgICAgIHdoaWxlICh3b3JkID0gd29yZHMucG9wKCkpIHtcbiAgICAgICAgICBsaW5lLnB1c2god29yZCk7XG4gICAgICAgICAgdHNwYW4udGV4dChsaW5lLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICBpZiAodHNwYW4ubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpID4gd2lkdGgpIHtcbiAgICAgICAgICAgIGxpbmUucG9wKCk7XG4gICAgICAgICAgICB0c3Bhbi50ZXh0KGxpbmUuam9pbihcIiBcIikpO1xuICAgICAgICAgICAgbGluZSA9IFt3b3JkXTtcbiAgICAgICAgICAgIHRzcGFuID0gdGV4dC5hcHBlbmQoXCJ0c3BhblwiKS5hdHRyKFwieFwiLCAwKS5hdHRyKFwieVwiLCB5KS5hdHRyKFwiZHlcIiwgKytsaW5lTnVtYmVyICogbGluZUhlaWdodCArIGR5ICsgXCJlbVwiKS50ZXh0KHdvcmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IGNob2ljZSBkYXRhLlxuICAgIGZ1bmN0aW9uIGZldGNoQ2hvaWNlRGF0YShyZWZyZXNoKSB7XG4gICAgICAgICRzY29wZS5ub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RDaG9pY2UuZ2V0Q2hvaWNlKGNvdXJzZWlkLCBtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24oY2hvaWNlZGF0YSkge1xuICAgICAgICAgICAgY2hvaWNlID0gY2hvaWNlZGF0YTtcbiAgICAgICAgICAgIGNob2ljZS50aW1lb3BlbiA9IHBhcnNlSW50KGNob2ljZS50aW1lb3BlbikgKiAxMDAwO1xuICAgICAgICAgICAgY2hvaWNlLm9wZW5UaW1lUmVhZGFibGUgPSBtb21lbnQoY2hvaWNlLnRpbWVvcGVuKS5mb3JtYXQoJ0xMTCcpO1xuICAgICAgICAgICAgY2hvaWNlLnRpbWVjbG9zZSA9IHBhcnNlSW50KGNob2ljZS50aW1lY2xvc2UpICogMTAwMDtcbiAgICAgICAgICAgIGNob2ljZS5jbG9zZVRpbWVSZWFkYWJsZSA9IG1vbWVudChjaG9pY2UudGltZWNsb3NlKS5mb3JtYXQoJ0xMTCcpO1xuXG4gICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBjaG9pY2UubmFtZSB8fCAkc2NvcGUudGl0bGU7XG4gICAgICAgICAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBjaG9pY2UuaW50cm8gfHzCoCRzY29wZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICRzY29wZS5jaG9pY2UgPSBjaG9pY2U7XG5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgZmV0Y2hPcHRpb25zIHRvIGZpbmlzaCBiZWZvcmUgY2FsbGluZyBmZXRjaFJlc3VsdHMgYmVjYXVzZSBpdCBuZWVkcyBoYXNBbnN3ZXJlZCB2YXJpYWJsZS5cbiAgICAgICAgICAgIHJldHVybiBmZXRjaE9wdGlvbnMoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFJlc3VsdHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoIXJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21lIGNhbGwgZmFpbGVkLCByZXRyeSB3aXRob3V0IHVzaW5nIGNhY2hlIHNpbmNlIGl0IG1pZ2h0IGJlIGEgbmV3IGFjdGl2aXR5LlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZyZXNoQWxsRGF0YSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfY2hvaWNlLmVycm9yZ2V0Y2hvaWNlJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBjaG9pY2Ugb3B0aW9ucy5cbiAgICBmdW5jdGlvbiBmZXRjaE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kQ2hvaWNlLmdldE9wdGlvbnMoY2hvaWNlLmlkKS50aGVuKGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBpc09wZW4gPSBpc0Nob2ljZU9wZW4oKTtcbiAgICAgICAgICAgIGhhc0Fuc3dlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAkc2NvcGUuc2VsZWN0ZWRPcHRpb24gPSB7aWQ6IC0xfTsgLy8gU2luZ2xlIGNob2ljZSBtb2RlbC5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChvcHRpb25zLCBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQW5zd2VyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNob2ljZS5hbGxvd211bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2VsZWN0ZWRPcHRpb24uaWQgPSBvcHRpb24uaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5jYW5FZGl0ID0gaXNPcGVuICYmIChjaG9pY2UuYWxsb3d1cGRhdGUgfHzCoCFoYXNBbnN3ZXJlZCk7XG4gICAgICAgICAgICAkc2NvcGUuY2FuRGVsZXRlID0gJG1tYU1vZENob2ljZS5pc0RlbGV0ZVJlc3BvbnNlc0VuYWJsZWQoKSAmJiBpc09wZW4gJiYgY2hvaWNlLmFsbG93dXBkYXRlICYmIGhhc0Fuc3dlcmVkO1xuICAgICAgICAgICAgJHNjb3BlLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgY2hvaWNlIHJlc3VsdHMuXG4gICAgZnVuY3Rpb24gZmV0Y2hSZXN1bHRzKCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZENob2ljZS5nZXRSZXN1bHRzKGNob2ljZS5pZCkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgICAgICB2YXIgaGFzVm90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBkYXRhICAgICA9IFtdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc3VsdHMsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubnVtYmVyb2Z1c2VyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNWb3RlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wZXJjZW50YWdlYW1vdW50ID0gcGFyc2VGbG9hdChyZXN1bHQucGVyY2VudGFnZWFtb3VudCkudG9GaXhlZCgxKTtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAnbGFiZWwnOiByZXN1bHQudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogcmVzdWx0Lm51bWJlcm9mdXNlcixcbiAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnQnOiByZXN1bHQucGVyY2VudGFnZWFtb3VudCAvIDEwMCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHNjb3BlLmNhblNlZVJlc3VsdHMgPSBoYXNWb3RlcyB8fCAkbW1hTW9kQ2hvaWNlLmNhblN0dWRlbnRTZWVSZXN1bHRzKGNob2ljZSwgaGFzQW5zd2VyZWQpO1xuICAgICAgICAgICAgJHNjb3BlLnJlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgICAgICAgJHNjb3BlLmRhdGEgPSBbe1xuICAgICAgICAgICAgICAgIC8va2V5OiBcIlNvbWUga2V5IHRvIHRoZSBkYXRhP1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgY2hvaWNlIGlzIG9wZW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGNob2ljZSBpcyBvcGVuLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNDaG9pY2VPcGVuKCkge1xuICAgICAgICByZXR1cm4gKGNob2ljZS50aW1lb3BlbiA9PT0gMCB8fCBjaG9pY2UudGltZW9wZW4gPD0gJHNjb3BlLm5vdykgJiZcbiAgICAgICAgICAgICAgICAoY2hvaWNlLnRpbWVjbG9zZSA9PT0gMCB8fMKgY2hvaWNlLnRpbWVjbG9zZSA+ICRzY29wZS5ub3cpO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHJlZnJlc2ggYWxsIHRoZSBkYXRhLlxuICAgIGZ1bmN0aW9uIHJlZnJlc2hBbGxEYXRhKCkge1xuICAgICAgICB2YXIgcDEgPSAkbW1hTW9kQ2hvaWNlLmludmFsaWRhdGVDaG9pY2VEYXRhKGNvdXJzZWlkKSxcbiAgICAgICAgICAgIHAyID0gY2hvaWNlID8gJG1tYU1vZENob2ljZS5pbnZhbGlkYXRlT3B0aW9ucyhjaG9pY2UuaWQpIDogJHEud2hlbigpLFxuICAgICAgICAgICAgcDMgPSBjaG9pY2UgPyAkbW1hTW9kQ2hvaWNlLmludmFsaWRhdGVSZXN1bHRzKGNob2ljZS5pZCkgOiAkcS53aGVuKCk7XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChbcDEsIHAyLCBwM10pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hDaG9pY2VEYXRhKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmZXRjaENob2ljZURhdGEoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTW9kQ2hvaWNlLmxvZ1ZpZXcoY2hvaWNlLmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuY2hvaWNlTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIFNhdmUgb3B0aW9ucyBzZWxlY3RlZC5cbiAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBPbmx5IHNob3cgY29uZmlybSBpZiBjaG9pY2UgZG9lc24ndCBhbGxvdyB1cGRhdGUuXG4gICAgICAgIHZhciBwcm9taXNlID0gY2hvaWNlLmFsbG93dXBkYXRlID8gJHEud2hlbigpIDogJG1tVXRpbC5zaG93Q29uZmlybSgkdHJhbnNsYXRlKCdtbS5jb3JlLmFyZXlvdXN1cmUnKSk7XG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjaG9pY2UuYWxsb3dtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUub3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24uY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzLnB1c2gob3B0aW9uLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZXMucHVzaCgkc2NvcGUuc2VsZWN0ZWRPcHRpb24uaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tLmNvcmUuc2VuZGluZycsIHRydWUpO1xuICAgICAgICAgICAgJG1tYU1vZENob2ljZS5zdWJtaXRSZXNwb25zZShjaG9pY2UuaWQsIHJlc3BvbnNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzISBMZXQncyByZWZyZXNoIHRoZSBkYXRhLlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZyZXNoQWxsRGF0YSgpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9jaG9pY2UuY2Fubm90c3VibWl0JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIERlbGV0ZSBvcHRpb25zIHNlbGVjdGVkLlxuICAgICRzY29wZS5kZWxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tVXRpbC5zaG93Q29uZmlybSgkdHJhbnNsYXRlKCdtbS5jb3JlLmFyZXlvdXN1cmUnKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW0uY29yZS5zZW5kaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAkbW1hTW9kQ2hvaWNlLmRlbGV0ZVJlc3BvbnNlcyhjaG9pY2UuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2VzcyEgTGV0J3MgcmVmcmVzaCB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmcmVzaEFsbERhdGEoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfY2hvaWNlLmNhbm5vdHN1Ym1pdCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBQdWxsIHRvIHJlZnJlc2guXG4gICAgJHNjb3BlLnJlZnJlc2hDaG9pY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVmcmVzaEFsbERhdGEoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2Nob2ljZScpXG5cbi8qKlxuICogQ2hvaWNlIHNlcnZpY2UuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RDaG9pY2VcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RDaG9pY2UnLCBmdW5jdGlvbigkcSwgJG1tU2l0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCBtbWFNb2RDaG9pY2VSZXN1bHRzQWZ0ZXJBbnN3ZXIsIG1tYU1vZENob2ljZVJlc3VsdHNBZnRlckNsb3NlLFxuICAgICAgICAgICAgbW1hTW9kQ2hvaWNlUmVzdWx0c0Fsd2F5cykge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiByZXN1bHRzIGNhbiBiZSBzZWVuIGJ5IGEgc3R1ZGVudC4gVGhlIHN0dWRlbnQgY2FuIHNlZSB0aGUgcmVzdWx0cyBpZjpcbiAgICAgKiAgICAgLSB0aGV5J3JlIGFsd2F5cyBwdWJsaXNoZWQsIE9SXG4gICAgICogICAgIC0gdGhleSdyZSBwdWJsaXNoZWQgYWZ0ZXIgdGhlIGNob2ljZSBpcyBjbG9zZWQgYW5kIGl0J3MgY2xvc2VkLCBPUlxuICAgICAqICAgICAtIHRoZXkncmUgcHVibGlzaGVkIGFmdGVyIGFuc3dlcmluZyBhbmQgdGhlIHVzZXIgaGFzIGFuc3dlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBjaG9pY2UgICAgICBDaG9pY2UgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBoYXNBbnN3ZXJlZCBUcnVlIGlmIHVzZXIgaGFzIGFuc3dlcmVkIHRoZSBjaG9pY2UsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgc2VsZi5jYW5TdHVkZW50U2VlUmVzdWx0cyA9IGZ1bmN0aW9uKGNob2ljZSwgaGFzQW5zd2VyZWQpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gIGNob2ljZS5zaG93cmVzdWx0cyA9PT0gbW1hTW9kQ2hvaWNlUmVzdWx0c0Fsd2F5cyB8fFxuICAgICAgICAgICAgICAgIGNob2ljZS5zaG93cmVzdWx0cyA9PT0gbW1hTW9kQ2hvaWNlUmVzdWx0c0FmdGVyQ2xvc2UgJiYgY2hvaWNlLnRpbWVjbG9zZSAhPT0gMCAmJiBjaG9pY2UudGltZWNsb3NlIDw9IG5vdyB8fFxuICAgICAgICAgICAgICAgIGNob2ljZS5zaG93cmVzdWx0cyA9PT0gbW1hTW9kQ2hvaWNlUmVzdWx0c0FmdGVyQW5zd2VyICYmIGhhc0Fuc3dlcmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgcmVzcG9uc2VzIGZyb20gYSBjaG9pY2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hvaWNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaG9pY2UjZGVsZXRlUmVzcG9uc2VzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNob2ljZWlkICAgICAgQ2hvaWNlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFtyZXNwb25zZXNdIElEcyBvZiB0aGUgYW5zd2Vycy4gSWYgbm90IGRlZmluZWQsIGRlbGV0ZSBhbGwgdGhlIGFuc3dlcnMgb2YgdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIG9wdGlvbnMgYXJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgc2VsZi5kZWxldGVSZXNwb25zZXMgPSBmdW5jdGlvbihjaG9pY2VpZCwgcmVzcG9uc2VzKSB7XG4gICAgICAgIHJlc3BvbnNlcyA9IHJlc3BvbnNlcyB8fCBbXTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNob2ljZWlkOiBjaG9pY2VpZCxcbiAgICAgICAgICAgIHJlc3BvbnNlczogcmVzcG9uc2VzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfY2hvaWNlX2RlbGV0ZV9jaG9pY2VfcmVzcG9uc2VzJywgcGFyYW1zKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBjaG9pY2UgZGF0YSBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDaG9pY2VEYXRhQ2FjaGVLZXkoY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RDaG9pY2U6Y2hvaWNlOicgKyBjb3Vyc2VpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBjaG9pY2Ugb3B0aW9ucyBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaG9pY2VpZCBDaG9pY2UgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENob2ljZU9wdGlvbnNDYWNoZUtleShjaG9pY2VpZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZENob2ljZTpvcHRpb25zOicgKyBjaG9pY2VpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBjaG9pY2UgcmVzdWx0cyBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaG9pY2VpZCBDaG9pY2UgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENob2ljZVJlc3VsdHNDYWNoZUtleShjaG9pY2VpZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZENob2ljZTpyZXN1bHRzOicgKyBjaG9pY2VpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIGN1cnJlbnQgc2l0ZSBzdXBwb3J0cyBkZWxldGluZyBjaG9pY2UgcmVzcG9uc2VzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hvaWNlI2lzRGVsZXRlUmVzcG9uc2VzRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgc3VwcG9ydGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc0RlbGV0ZVJlc3BvbnNlc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3NBdmFpbGFibGUoJ21vZF9jaG9pY2VfZGVsZXRlX2Nob2ljZV9yZXNwb25zZXMnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaXMgZW5hYmxlZCBpbiBhIGNlcnRhaW4gc2l0ZS4gUGx1Z2luIGlzIGVuYWJsZWQgaWYgdGhlIGNob2ljZSBXUyBhcmUgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hvaWNlI2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIHBsdWdpbiBpcyBlbmFibGVkLCByZWplY3RlZCBvciByZXNvbHZlZCB3aXRoIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICBzaXRlLndzQXZhaWxhYmxlKCdtb2RfY2hvaWNlX2dldF9jaG9pY2Vfb3B0aW9ucycpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9jaG9pY2VfZ2V0X2Nob2ljZV9yZXN1bHRzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2Nob2ljZV9nZXRfY2hvaWNlc19ieV9jb3Vyc2VzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2Nob2ljZV9zdWJtaXRfY2hvaWNlX3Jlc3BvbnNlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBjaG9pY2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hvaWNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaG9pY2UjZ2V0Q2hvaWNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY21pZCAgICAgQ291cnNlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjaG9pY2UgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Q2hvaWNlID0gZnVuY3Rpb24oY291cnNlaWQsIGNtaWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VpZHM6IFtjb3Vyc2VpZF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRDaG9pY2VEYXRhQ2FjaGVLZXkoY291cnNlaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9jaG9pY2VfZ2V0X2Nob2ljZXNfYnlfY291cnNlcycsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmNob2ljZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENob2ljZTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzcG9uc2UuY2hvaWNlcywgZnVuY3Rpb24oY2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaG9pY2UuY291cnNlbW9kdWxlID09IGNtaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaG9pY2UgPSBjaG9pY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENob2ljZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudENob2ljZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBjaG9pY2Ugb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaG9pY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENob2ljZSNnZXRPcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNob2ljZWlkIENob2ljZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGNob2ljZSBvcHRpb25zLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKGNob2ljZWlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY2hvaWNlaWQ6IGNob2ljZWlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0Q2hvaWNlT3B0aW9uc0NhY2hlS2V5KGNob2ljZWlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfY2hvaWNlX2dldF9jaG9pY2Vfb3B0aW9ucycsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uub3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGNob2ljZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hvaWNlI2dldFJlc3VsdHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hvaWNlaWQgQ2hvaWNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggY2hvaWNlIHJlc3VsdHMuXG4gICAgICovXG4gICAgc2VsZi5nZXRSZXN1bHRzID0gZnVuY3Rpb24oY2hvaWNlaWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjaG9pY2VpZDogY2hvaWNlaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRDaG9pY2VSZXN1bHRzQ2FjaGVLZXkoY2hvaWNlaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9jaG9pY2VfZ2V0X2Nob2ljZV9yZXN1bHRzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgY2hvaWNlIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hvaWNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaG9pY2UjaW52YWxpZGF0ZUNob2ljZURhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQ2hvaWNlRGF0YSA9IGZ1bmN0aW9uKGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldENob2ljZURhdGFDYWNoZUtleShjb3Vyc2VpZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBvcHRpb25zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hvaWNlI2ludmFsaWRhdGVPcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNob2ljZWlkIENob2ljZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbihjaG9pY2VpZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRDaG9pY2VPcHRpb25zQ2FjaGVLZXkoY2hvaWNlaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaG9pY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENob2ljZSNpbnZhbGlkYXRlUmVzdWx0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaG9pY2VpZCBDaG9pY2UgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVSZXN1bHRzID0gZnVuY3Rpb24oY2hvaWNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0Q2hvaWNlUmVzdWx0c0NhY2hlS2V5KGNob2ljZWlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCB0aGUgY2hvaWNlIGFzIGJlaW5nIHZpZXdlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaG9pY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENob2ljZSNsb2dWaWV3XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIENob2ljZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sb2dWaWV3ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNob2ljZWlkOiBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfY2hvaWNlX3ZpZXdfY2hvaWNlJywgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbmQgYSByZXNwb25zZSB0byBhIGNob2ljZSB0byBNb29kbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hvaWNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaG9pY2Ujc3VibWl0UmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hvaWNlaWQgICAgQ2hvaWNlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHJlc3BvbnNlcyBJRHMgb2Ygc2VsZWN0ZWQgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHJlc3VsdHMgYXJlIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQuXG4gICAgICovXG4gICAgc2VsZi5zdWJtaXRSZXNwb25zZSA9IGZ1bmN0aW9uKGNob2ljZWlkLCByZXNwb25zZXMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNob2ljZWlkOiBjaG9pY2VpZCxcbiAgICAgICAgICAgIHJlc3BvbnNlczogcmVzcG9uc2VzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfY2hvaWNlX3N1Ym1pdF9jaG9pY2VfcmVzcG9uc2UnLCBwYXJhbXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2Nob2ljZScpXG5cbi8qKlxuICogTW9kIGNob2ljZSBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hvaWNlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZENob2ljZUhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kQ2hvaWNlSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbWFNb2RDaG9pY2UsICRzdGF0ZSwgJG1tQ29udGVudExpbmtzSGVscGVyLCAkcSkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hvaWNlSGFuZGxlcnMjY291cnNlQ29udGVudFxuICAgICAqL1xuICAgIHNlbGYuY291cnNlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RDaG9pY2UuaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKCdjaG9pY2UnKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW9kX2Nob2ljZScsIHttb2R1bGU6IG1vZHVsZSwgY291cnNlaWQ6IGNvdXJzZWlkfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaG9pY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENob2ljZUhhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICBTaXRlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoc2l0ZUlkLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RDaG9pY2UuaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhY3Rpb25zIHRvIHBlcmZvcm0gd2l0aCB0aGUgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhIGNob2ljZSBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy9tb2QvY2hvaWNlL3ZpZXcucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIudHJlYXRNb2R1bGVJbmRleFVybChzaXRlSWRzLCB1cmwsIGlzRW5hYmxlZCwgY291cnNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2ZvbGRlcicpXG5cbi8qKlxuICogRm9sZGVyIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZEZvbGRlckluZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kRm9sZGVySW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbWFNb2RGb2xkZXIsICRtbUNvdXJzZSwgJG1tVXRpbCwgJHEpIHtcbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIHNlY3Rpb25pZCA9ICRzdGF0ZVBhcmFtcy5zZWN0aW9uaWQsXG4gICAgICAgIHBhdGggPSAkc3RhdGVQYXJhbXMucGF0aDtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNldCBzY29wZSBkYXRhIHVzaW5nIG1vZHVsZS5cbiAgICBmdW5jdGlvbiBzaG93TW9kdWxlRGF0YShtb2R1bGUpIHtcbiAgICAgICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIC8vIFN1YmZvbGRlci5cbiAgICAgICAgICAgICRzY29wZS5jb250ZW50cyA9IG1vZHVsZS5jb250ZW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5jb250ZW50cyA9ICRtbWFNb2RGb2xkZXIuZm9ybWF0Q29udGVudHMobW9kdWxlLmNvbnRlbnRzKTtcbiAgICAgICAgICAgICRzY29wZS5tb2R1bGV1cmwgPSBtb2R1bGUudXJsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZmV0Y2ggZm9sZGVyIGRhdGEgZnJvbSBNb29kbGUuXG4gICAgZnVuY3Rpb24gZmV0Y2hGb2xkZXIoKSB7XG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2UuZ2V0TW9kdWxlKG1vZHVsZS5pZCwgY291cnNlaWQsIHNlY3Rpb25pZCkudGhlbihmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgIHNob3dNb2R1bGVEYXRhKG1vZHVsZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9mb2xkZXIuZXJyb3J3aGlsZWdldHRpbmdmb2xkZXInLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEkc2NvcGUudGl0bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBnZXR0aW5nIGRhdGEgZnJvbSBzZXJ2ZXIuIFVzZSBtb2R1bGUgcGFyYW0uXG4gICAgICAgICAgICAgICAgc2hvd01vZHVsZURhdGEobW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgICAgLy8gU3ViZm9sZGVyLiBVc2UgbW9kdWxlIHBhcmFtLlxuICAgICAgICBzaG93TW9kdWxlRGF0YShtb2R1bGUpO1xuICAgICAgICAkc2NvcGUuZm9sZGVyTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgJHNjb3BlLmNhblJlbG9hZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoRm9sZGVyKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbWFNb2RGb2xkZXIubG9nVmlldyhtb2R1bGUuaW5zdGFuY2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuZm9sZGVyTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICRzY29wZS5jYW5SZWxvYWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkc2NvcGUucmVmcmVzaEZvbGRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1Db3Vyc2UuaW52YWxpZGF0ZU1vZHVsZShtb2R1bGUuaWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmZXRjaEZvbGRlcigpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZm9sZGVyJylcblxuLyoqXG4gKiBGb2xkZXIgc2VydmljZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEZvbGRlclxuICogQHRvZG8gQWRkaW5nIGEgbmV3IGZpbGUgaW4gYSBmb2xkZXIgdXBkYXRlcyB0aGUgcmV2aXNpb24gb2YgYWxsIHRoZSBmaWxlcywgc28gdGhleSdyZSBhbGwgc2hvd24gYXMgb3V0ZGF0ZWQuXG4gKiAgICAgICBUbyBpZ25vcmUgcmV2aXNpb24gaW4gZm9sZGVycyB3ZSdsbCBoYXZlIHRvIG1vZGlmeSAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLCBtbS1maWxlIGFuZCAkbW1GaWxlcG9vbC5cbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RGb2xkZXInLCBmdW5jdGlvbigkbW1TaXRlLCAkbW1Db3Vyc2UsICRxLCAkbW1GaWxlcG9vbCwgbW1hTW9kRm9sZGVyQ29tcG9uZW50KSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGFsbCB0aGUgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb2xkZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvbGRlciNkb3dubG9hZEFsbENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBjb250ZW50IGlzIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYuZG93bmxvYWRBbGxDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMobW9kdWxlKSxcbiAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgIHRpbWVtb2QgPSAkbW1GaWxlcG9vbC5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKTtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmRvd25sb2FkUGFja2FnZSgkbW1TaXRlLmdldElkKCksIGZpbGVzLCBtbWFNb2RGb2xkZXJDb21wb25lbnQsIG1vZHVsZS5pZCwgcmV2aXNpb24sIHRpbWVtb2QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgZm9sZGVyIGNvbnRlbnRzLCBjcmVhdGluZyBkaXJlY3Rvcnkgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9sZGVyI2Zvcm1hdENvbnRlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gY29udGVudHMgRm9sZGVyIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgIEZvcm1hdHRlZCBjb250ZW50cy5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBGb3JtYXQgZm9sZGVyIGNvbnRlbnRzLCBjcmVhdGluZyBkaXJlY3Rvcnkgc3RydWN0dXJlLlxuICAgICAqIEZvbGRlcnMgZm91bmQgaW4gZmlsZXBhdGhzIGFyZSBhZGRlZCB0byB0aGUgYXJyYXkuIEVhY2ggZm9sZGVyIGhhcyB0aGUgcHJvcGVydGllczogbmFtZSwgZmlsZWljb24sXG4gICAgICogdHlwZSAoZm9sZGVyKSwgZmlsZXBhdGggYW5kIGNvbnRlbnRzIChhcnJheSB3aXRoIGZpbGVzIGFuZCBzdWJmb2xkZXJzKS5cbiAgICAgKi9cbiAgICBzZWxmLmZvcm1hdENvbnRlbnRzID0gZnVuY3Rpb24oY29udGVudHMpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gW10sXG4gICAgICAgICAgICBmb2xkZXJzID0gW10sXG4gICAgICAgICAgICBmb2xkZXJpY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ2ZvbGRlcicpO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250ZW50cywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5maWxlcGF0aCAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIGZpbGUgaW4gYSBzdWJmb2xkZXIuIExldHMgdHJlYXQgdGhlIHBhdGggdG8gYWRkIHRoZSBzdWJmb2xkZXJzIHRvIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0b3JpZXMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaXN0ID0gZm9sZGVycywgLy8gU3RhcnQgYXQgcm9vdCBsZXZlbC5cbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGVudHJ5LmZpbGVwYXRoLFxuICAgICAgICAgICAgICAgICAgICBzdWJwYXRoID0gJyc7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZmlyc3QgYW5kIGxhc3Qgc2xhc2ggaWYgbmVlZGVkLlxuICAgICAgICAgICAgICAgIGlmIChwYXRoLnN1YnN0cigwLCAxKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhdGguc3Vic3RyKHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGlyZWN0b3JpZXMgPSBwYXRoLnNwbGl0KCcvJyk7XG5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZGlyZWN0b3JpZXMsIGZ1bmN0aW9uKGRpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJwYXRoID0gc3VicGF0aCArICcvJyArIGRpcmVjdG9yeTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIGlmIHRoZSBkaXJlY3RvcnkgaXMgYWxyZWFkeSBzdG9yZWQgaW4gZm9sZGVycyBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGlzdFtpXS5uYW1lID09PSBkaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGlzdCA9IGN1cnJlbnRMaXN0W2ldLmNvbnRlbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEaXJlY3Rvcnkgbm90IGZvdW5kLiBBZGQgaXQgdG8gdGhlIGFycmF5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Rm9sZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGRpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlaWNvbjogZm9sZGVyaWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGg6IHN1YnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ZvbGRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGlzdC5wdXNoKG5ld0ZvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGlzdCA9IG5ld0ZvbGRlci5jb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudExpc3QucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm9sZGVycy5jb25jYXQoZmlsZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlcyB0aGF0IGNhbiBiZSBkb3dubG9hZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9sZGVyI2dldERvd25sb2FkYWJsZUZpbGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gICAgIExpc3Qgb2YgZmlsZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBbXTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgZmlsZSBpcyBkb3dubG9hZGFibGUuIFRoZSBmaWxlIHBhcmFtIG11c3QgaGF2ZSBhICd0eXBlJyBhdHRyaWJ1dGUgbGlrZSBpbiBjb3JlX2NvdXJzZV9nZXRfY29udGVudHMgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb2xkZXIjaXNGaWxlRG93bmxvYWRhYmxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGUgRmlsZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICBUcnVlIGlmIGRvd25sb2FkYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNGaWxlRG93bmxvYWRhYmxlID0gZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICByZXR1cm4gZmlsZS50eXBlID09PSAnZmlsZSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCBhIGZvbGRlciBhcyBiZWluZyB2aWV3ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb2xkZXIjbG9nVmlld1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBNb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgY2FsbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHNlbGYubG9nVmlldyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBmb2xkZXJpZDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2ZvbGRlcl92aWV3X2ZvbGRlcicsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCB0aGUgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb2xkZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvbGRlciNwcmVmZXRjaENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBjb250ZW50IGlzIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYucHJlZmV0Y2hDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMobW9kdWxlKSxcbiAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgIHRpbWVtb2QgPSAkbW1GaWxlcG9vbC5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKTtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLnByZWZldGNoUGFja2FnZSgkbW1TaXRlLmdldElkKCksIGZpbGVzLCBtbWFNb2RGb2xkZXJDb21wb25lbnQsIG1vZHVsZS5pZCwgcmV2aXNpb24sIHRpbWVtb2QpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2ZvbGRlcicpXG5cbi8qKlxuICogTW9kIEZvbGRlciBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEZvbGRlckhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kRm9sZGVySGFuZGxlcnMnLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbWFNb2RGb2xkZXIsICRtbUV2ZW50cywgJHN0YXRlLCAkbW1TaXRlLCAkbW1VdGlsLCAkbW1GaWxlcG9vbCxcbiAgICAgICAgICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUsIG1tQ29yZURvd25sb2FkaW5nLCBtbUNvcmVOb3REb3dubG9hZGVkLCBtbUNvcmVPdXRkYXRlZCwgbW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCxcbiAgICAgICAgICAgIG1tYU1vZEZvbGRlckNvbXBvbmVudCwgJG1tQ29udGVudExpbmtzSGVscGVyLCAkcSkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9sZGVySGFuZGxlcnMjY291cnNlQ29udGVudFxuICAgICAqL1xuICAgIHNlbGYuY291cnNlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tYU1vZEZvbGRlckNvdXJzZUNvbnRlbnRIYW5kbGVyI2lzRW5hYmxlZFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb2xkZXJcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1hTW9kRm9sZGVyQ291cnNlQ29udGVudEhhbmRsZXIjZ2V0Q29udHJvbGxlclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlICAgIFRoZSBtb2R1bGUgaW5mby5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkICBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWN0aW9uaWQgU2VjdGlvbiBJRC5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkLCBzZWN0aW9uaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcmVmZXRjaCBmb2xkZXIgY29udGVudHMuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJlZmV0Y2hGb2xkZXIoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICRtbWFNb2RGb2xkZXIucHJlZmV0Y2hDb250ZW50KG1vZHVsZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJGRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb3dubG9hZEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWlvcy1jbG91ZC1kb3dubG9hZC1vdXRsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLmRvd25sb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBwcmVmZXRjaEZvbGRlclxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZWZyZXNoQnRuID0ge1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tYW5kcm9pZC1yZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLnJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHByZWZldGNoRm9sZGVyXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ2ZvbGRlcicpO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICRzY29wZS5idXR0b25zID0gW2Rvd25sb2FkQnRuLCByZWZyZXNoQnRuXTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1vZF9mb2xkZXInLCB7bW9kdWxlOiBtb2R1bGUsIGNvdXJzZWlkOiBjb3Vyc2VpZCwgc2VjdGlvbmlkOiBzZWN0aW9uaWR9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gU2hvdyBidXR0b25zIGFjY29yZGluZyB0byBtb2R1bGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zcGlubmVyID0gc3RhdHVzID09PSBtbUNvcmVEb3dubG9hZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkQnRuLmhpZGRlbiA9IHN0YXR1cyAhPT0gbW1Db3JlTm90RG93bmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4uaGlkZGVuID0gc3RhdHVzICE9PSBtbUNvcmVPdXRkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgY2hhbmdlcyBvbiB0aGlzIG1vZHVsZSBzdGF0dXMuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c09ic2VydmVyID0gJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2l0ZWlkID09PSAkbW1TaXRlLmdldElkKCkgJiYgZGF0YS5jb21wb25lbnRJZCA9PT0gbW9kdWxlLmlkICYmIGRhdGEuY29tcG9uZW50ID09PSBtbWFNb2RGb2xkZXJDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dTdGF0dXMoZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY3VycmVudCBzdGF0dXMgdG8gZGVjaWRlIHdoaWNoIGljb24gc2hvdWxkIGJlIHNob3duLlxuICAgICAgICAgICAgICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUuZ2V0TW9kdWxlU3RhdHVzKG1vZHVsZSwgY291cnNlaWQsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQpLnRoZW4oc2hvd1N0YXR1cyk7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNPYnNlcnZlciAmJiBzdGF0dXNPYnNlcnZlci5vZmYgJiYgc3RhdHVzT2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb2xkZXJIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIGlmIChjb3Vyc2VJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSBmb2xkZXIgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL2ZvbGRlci92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9mb2xkZXInKVxuXG4vKipcbiAqIE1vZCBmb2xkZXIgcHJlZmV0Y2ggaGFuZGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEZvbGRlclByZWZldGNoSGFuZGxlclxuICovXG4uZmFjdG9yeSgnJG1tYU1vZEZvbGRlclByZWZldGNoSGFuZGxlcicsIGZ1bmN0aW9uKCRtbWFNb2RGb2xkZXIsICRtbVNpdGUsIG1tYU1vZEZvbGRlckNvbXBvbmVudCkge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIHNlbGYuY29tcG9uZW50ID0gbW1hTW9kRm9sZGVyQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkb3dubG9hZCBzaXplIG9mIGEgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9sZGVyUHJlZmV0Y2hIYW5kbGVyI2dldERvd25sb2FkU2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgTW9kdWxlIHRvIGdldCB0aGUgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIFNpemUuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZFNpemUgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoJG1tYU1vZEZvbGRlci5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkgJiYgY29udGVudC5maWxlc2l6ZSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBzaXplICsgY29udGVudC5maWxlc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9sZGVyUHJlZmV0Y2hIYW5kbGVyI2lzRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIHRoZSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb2xkZXJQcmVmZXRjaEhhbmRsZXIjcHJlZmV0Y2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBmaWxlcyBoYXZlIGJlZW4gZG93bmxvYWRlZC4gRGF0YSByZXR1cm5lZCBpcyBub3QgcmVsaWFibGUuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaCA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZEZvbGRlci5wcmVmZXRjaENvbnRlbnQobW9kdWxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9nbG9zc2FyeScpXG5cbi8qKlxuICogR2xvc3NhcnkgZW50cnkgY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RHbG9zc2FyeUVudHJ5Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kR2xvc3NhcnlFbnRyeUN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tYU1vZEdsb3NzYXJ5LCAkdHJhbnNsYXRlLFxuICAgICAgICBtbVVzZXJQcm9maWxlU3RhdGUpIHtcbiAgICB2YXIgZW50cnkgPSAkc3RhdGVQYXJhbXMuZW50cnkgfHwge30sXG4gICAgICAgIGNvdXJzZWlkID0gJHN0YXRlUGFyYW1zLmNpZCB8fCAwLFxuICAgICAgICBnbG9zc2FyeTtcblxuICAgIC8vIFRoaXMgaXMgYSBjb2RpbmcgZXJyb3IsIGZvciBub3cgdGhlIGNvdXJzZSBJRCBpcyByZXF1aXJlZCBoZXJlIGFzIHdlIG5lZWQgaXQgZm9yIHRoZSBhdXRob3IgbGluay5cbiAgICBpZiAoIWNvdXJzZWlkKSB7XG4gICAgICAgIG5vdGlmeUVycm9yT2NjdXJlZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJHNjb3BlLnJlZnJlc2hFbnRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWZyZXNoRW50cnkoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIExvYWQgdGhlIGdsb3NzYXJ5IGZpcnN0LlxuICAgICRtbWFNb2RHbG9zc2FyeS5nZXRHbG9zc2FyeUJ5SWQoY291cnNlaWQsIGVudHJ5Lmdsb3NzYXJ5aWQpLnRoZW4oZnVuY3Rpb24oZ2xvc3MpIHtcbiAgICAgICAgZ2xvc3NhcnkgPSBnbG9zcztcbiAgICAgICAgdmFyIGRpc3BsYXlGb3JtYXQgPSBnbG9zc2FyeS5kaXNwbGF5Zm9ybWF0O1xuXG4gICAgICAgICRzY29wZS50aXRsZSA9IGVudHJ5LmNvbmNlcHQ7XG4gICAgICAgICRzY29wZS5lbnRyeSA9IGVudHJ5O1xuICAgICAgICAkc2NvcGUuY291cnNlaWQgPSBjb3Vyc2VpZDtcbiAgICAgICAgJHNjb3BlLnVzZXJTdGF0ZU5hbWUgPSBtbVVzZXJQcm9maWxlU3RhdGU7XG5cbiAgICAgICAgaWYgKGRpc3BsYXlGb3JtYXQgPT0gJ2Z1bGx3aXRoYXV0aG9yJyB8fCBkaXNwbGF5Rm9ybWF0ID09ICdlbmN5Y2xvcGVkaWEnKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0F1dGhvciA9IHRydWU7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0RhdGUgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGlzcGxheUZvcm1hdCA9PSAnZnVsbHdpdGhvdXRhdXRob3InKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0F1dGhvciA9IGZhbHNlO1xuICAgICAgICAgICAgJHNjb3BlLnNob3dEYXRlID0gdHJ1ZTtcblxuICAgICAgICAvLyBEZWZhdWx0LCBhbmQgZmFxLCBzaW1wbGUsIGVudHJ5bGlzdCwgY29udGludW91cy5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5zaG93QXV0aG9yID0gZmFsc2U7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0RhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIExvZyB0aGF0IHRoZSBlbnRyeSB3YXMgdmlld2VkLlxuICAgICAgICAkbW1hTW9kR2xvc3NhcnkubG9nRW50cnlWaWV3KGVudHJ5LmlkKTtcblxuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBub3RpZnlFcnJvck9jY3VyZWQoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZldGNoRW50cnkoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kR2xvc3NhcnkuZ2V0RW50cnkoZW50cnkuaWQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAkc2NvcGUuZW50cnkgPSByZXN1bHQuZW50cnk7XG4gICAgICAgICAgICAkc2NvcGUudGl0bGUgPSByZXN1bHQuZW50cnkuY29uY2VwdDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmcmVzaEVudHJ5KCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZEdsb3NzYXJ5LmludmFsaWRhdGVFbnRyeShlbnRyeS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaEVudHJ5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vdGlmeUVycm9yT2NjdXJlZCgpIHtcbiAgICAgICAgJHNjb3BlLnRpdGxlID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLmVycm9yJyk7XG4gICAgICAgICRzY29wZS5lbnRyeSA9IGZhbHNlO1xuICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICB9XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2dsb3NzYXJ5JylcblxuLyoqXG4gKiBHbG9zc2FyeSBpbmRleCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZEdsb3NzYXJ5SW5kZXhDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RHbG9zc2FyeUluZGV4Q3RybCcsIGZ1bmN0aW9uKCRxLCAkc2NvcGUsICRzdGF0ZVBhcmFtcywgJGlvbmljUG9wb3ZlciwgJG1tVXRpbCwgJG1tYU1vZEdsb3NzYXJ5LFxuICAgICAgICAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSkge1xuXG4gICAgdmFyIG1vZHVsZSA9ICRzdGF0ZVBhcmFtcy5tb2R1bGUgfHwge30sXG4gICAgICAgIGNvdXJzZUlkID0gJHN0YXRlUGFyYW1zLmNvdXJzZWlkLFxuICAgICAgICBnbG9zc2FyeSxcbiAgICAgICAgbm9vcCA9IGZ1bmN0aW9uKCl7fSxcbiAgICAgICAgbGltaXRGcm9tID0gMCxcbiAgICAgICAgbGltaXROdW0gPSAyNSxcbiAgICAgICAgcG9wb3ZlcixcbiAgICAgICAgdmlld01vZGUsICAgLy8gVGhlIGFyY2hldHlwZSBvZiB2aWV3IChsZXR0ZXIsIGRhdGUsIGF1dGhvciwgY2F0KS5cbiAgICAgICAgZmV0Y2hNb2RlID0gJ2xldHRlcl9hbGwnLCAgICAgICAvLyBEZWZhdWx0LlxuICAgICAgICBmZXRjaEZ1bmN0aW9uLFxuICAgICAgICBmZXRjaEludmFsaWRhdGUsXG4gICAgICAgIGZldGNoQXJndW1lbnRzLFxuICAgICAgICBwb3BvdmVyU2NvcGUgPSAkc2NvcGUuJG5ldyh0cnVlKSxcbiAgICAgICAgYnJvd3NlTW9kZXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5OiAnbGV0dGVyX2FsbCcsXG4gICAgICAgICAgICAgICAgbGFuZ2tleTogJ21tYS5tb2RfZ2xvc3NhcnkuYnlhbHBoYWJldCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5OiAnc2VhcmNoJyxcbiAgICAgICAgICAgICAgICBsYW5na2V5OiAnbW1hLm1vZF9nbG9zc2FyeS5ieXNlYXJjaCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAkc2NvcGUuZXh0ZXJuYWxVcmwgPSBtb2R1bGUudXJsO1xuICAgICRzY29wZS5jb3Vyc2VpZCA9IGNvdXJzZUlkO1xuICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAkc2NvcGUuZW50cmllcyA9IFtdO1xuICAgICRzY29wZS5nZXREaXZpZGVyID0gbm9vcDtcbiAgICAkc2NvcGUuc2hvd0RpdmlkZXIgPSBub29wO1xuICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IGZhbHNlO1xuICAgICRzY29wZS5zZWFyY2hEYXRhID0ge1xuICAgICAgICBzZWFyY2hRdWVyeTogJydcbiAgICB9O1xuXG4gICAgJHNjb3BlLmxvYWRNb3JlRW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkTW9yZUVudHJpZXMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5pbmZpbml0ZVNjcm9sbENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgJHNjb3BlLnJlZnJlc2hFbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZnJlc2hFbnRyaWVzKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUucGlja01vZGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHBvcG92ZXJTY29wZS5kYXRhLnNlbGVjdGVkTW9kZSA9IGZldGNoTW9kZTtcbiAgICAgICAgcG9wb3Zlci5zaG93KGUpO1xuICAgIH07XG5cbiAgICAkc2NvcGUuc2VhcmNoID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgZmV0Y2hBcmd1bWVudHMgPSBbZ2xvc3NhcnkuaWQsIHF1ZXJ5LCAxLCAnQ09OQ0VQVCcsICdBU0MnXTtcbiAgICAgICAgZmV0Y2hFbnRyaWVzKCk7XG4gICAgfTtcblxuICAgICRzY29wZS50cmFja0J5ID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoTW9kZSArICc6JyArIGVudHJ5LmlkO1xuICAgIH07XG5cbiAgICAvLyBDb250cm9sbGVyIHJ1bi5cbiAgICAkbW1hTW9kR2xvc3NhcnkuZ2V0R2xvc3NhcnkoY291cnNlSWQsIG1vZHVsZS5pZCkudGhlbihmdW5jdGlvbihtb2QpIHtcbiAgICAgICAgZ2xvc3NhcnkgPSBtb2Q7XG5cbiAgICAgICAgLy8gUHJlcGFyaW5nIGJyb3dzZSBtb2Rlcy5cbiAgICAgICAgaWYgKGdsb3NzYXJ5LmJyb3dzZW1vZGVzLmluZGV4T2YoJ2RhdGUnKSA+PSAwKSB7XG4gICAgICAgICAgICBicm93c2VNb2Rlcy5wdXNoKHtrZXk6ICduZXdlc3RfZmlyc3QnLCBsYW5na2V5OiAnbW1hLm1vZF9nbG9zc2FyeS5ieW5ld2VzdGZpcnN0J30pO1xuICAgICAgICAgICAgYnJvd3NlTW9kZXMucHVzaCh7a2V5OiAncmVjZW50bHlfdXBkYXRlZCcsIGxhbmdrZXk6ICdtbWEubW9kX2dsb3NzYXJ5LmJ5cmVjZW50bHl1cGRhdGVkJ30pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbG9zc2FyeS5icm93c2Vtb2Rlcy5pbmRleE9mKCdhdXRob3InKSA+PSAwKSB7XG4gICAgICAgICAgICBicm93c2VNb2Rlcy5wdXNoKHtrZXk6ICdhdXRob3JfYWxsJywgbGFuZ2tleTogJ21tYS5tb2RfZ2xvc3NhcnkuYnlhdXRob3InfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVwYXJpbmcgdGhlIHBvcG92ZXIuXG4gICAgICAgIHBvcG92ZXJTY29wZS5tb2RlcyA9IGJyb3dzZU1vZGVzO1xuICAgICAgICBwb3BvdmVyU2NvcGUubW9kZVBpY2tlZCA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgICAgICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnbW1hTW9kR2xvc3NhcnlJbmRleCcpLnNjcm9sbFRvcChmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3dpdGNoTW9kZShtb2RlKSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmZXRjaEVudHJpZXMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBub3QgYW4gaW5zdGFudCBzZWFyY2gsIHRoZW4gd2UgcmVzZXQgdGhlIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICRzY29wZS5zaG93Tm9FbnRyaWVzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3BvdmVyLmhpZGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcG9wb3ZlclNjb3BlLmRhdGEgPSB7IHNlbGVjdGVkTW9kZTogJycgfTtcbiAgICAgICAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ2FkZG9ucy9tb2RfZ2xvc3NhcnkvdGVtcGxhdGVzL21vZGVfcGlja2VyLmh0bWwnLCB7XG4gICAgICAgICAgICBzY29wZTogcG9wb3ZlclNjb3BlXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocG8pIHtcbiAgICAgICAgICAgIHBvcG92ZXIgPSBwbztcbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwb3BvdmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgcG9wb3ZlclNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFByZXBhcmluZyB0aGUgaW5pdGlhbCBtb2RlLlxuICAgICAgICBzd2l0Y2hNb2RlKCk7XG5cbiAgICAgICAgLy8gRG8gbm90IHJldHVybiB0aGUgcHJvbWlzZSBoZXJlLCB0aGUgZXJyb3IgbW9kYWwgaXMgYWxyZWFkeSBoYW5kbGVkLlxuICAgICAgICBmZXRjaEVudHJpZXMoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQWZ0ZXIgYSBzdWNjZXNzZnVsIGZldGNoLCB0aGUgZ2xvc3NhcnkgY2FuIGJlIGNvbnNpZGVyZWQgYXMgJ3ZpZXdlZCcuXG4gICAgICAgICAgICAkbW1hTW9kR2xvc3NhcnkubG9nVmlldyhnbG9zc2FyeS5pZCwgdmlld01vZGUpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2dsb3NzYXJ5LmVycm9ybG9hZGluZ2dsb3NzYXJ5JywgdHJ1ZSk7XG4gICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gQ29udHJvbGxlciBsaWJyYXJ5LlxuICAgIGZ1bmN0aW9uIGZldGNoRW50cmllcyhhcHBlbmQpIHtcbiAgICAgICAgaWYgKCFhcHBlbmQpIHtcbiAgICAgICAgICAgIGxpbWl0RnJvbSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSBhbmd1bGFyLmV4dGVuZChbXSwgZmV0Y2hBcmd1bWVudHMpO1xuICAgICAgICBhcmdzLnB1c2gobGltaXRGcm9tKTtcbiAgICAgICAgYXJncy5wdXNoKGxpbWl0TnVtKTtcblxuICAgICAgICByZXR1cm4gZmV0Y2hGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmdzKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGFwcGVuZCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5lbnRyaWVzID0gJHNjb3BlLmVudHJpZXMuY29uY2F0KHJlc3VsdC5lbnRyaWVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmVudHJpZXMgPSByZXN1bHQuZW50cmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IChsaW1pdEZyb20gKyBsaW1pdE51bSkgPCByZXN1bHQuY291bnQ7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd05vRW50cmllcyA9IHJlc3VsdC5jb3VudCA8PSAwO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfZ2xvc3NhcnkuZXJyb3Jsb2FkaW5nZW50cmllcycsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoRW50cmllcygpIHtcbiAgICAgICAgaWYgKGZldGNoTW9kZSA9PSAnc2VhcmNoJyAmJiAhJHNjb3BlLnNlYXJjaFF1ZXJ5KSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgc2VhcmNoIG1vZGUgdGhhdCBpcyBub3Qgc2V0IHlldC5cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSBhbmd1bGFyLmV4dGVuZChbXSwgZmV0Y2hBcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gZmV0Y2hJbnZhbGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3MpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsaW1pdEZyb20gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoRW50cmllcygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTW9yZUVudHJpZXMoKSB7XG4gICAgICAgIGxpbWl0RnJvbSArPSBsaW1pdE51bTtcbiAgICAgICAgcmV0dXJuIGZldGNoRW50cmllcyh0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hNb2RlKG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgPT0gZmV0Y2hNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5zdGFudEZldGNoID0gdHJ1ZTtcbiAgICAgICAgZmV0Y2hNb2RlID0gbW9kZTtcbiAgICAgICAgJHNjb3BlLmlzU2VhcmNoID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQnJvd3NlIGJ5IGF1dGhvci5cbiAgICAgICAgaWYgKG1vZGUgPT0gJ2F1dGhvcl9hbGwnKSB7XG4gICAgICAgICAgICB2aWV3TW9kZSA9ICdhdXRob3InO1xuICAgICAgICAgICAgZmV0Y2hGdW5jdGlvbiA9ICRtbWFNb2RHbG9zc2FyeS5nZXRFbnRyaWVzQnlBdXRob3I7XG4gICAgICAgICAgICBmZXRjaEludmFsaWRhdGUgPSAkbW1hTW9kR2xvc3NhcnkuaW52YWxpZGF0ZUVudHJpZXNCeUF1dGhvcjtcbiAgICAgICAgICAgIGZldGNoQXJndW1lbnRzID0gW2dsb3NzYXJ5LmlkLCAnQUxMJywgJ0xBU1ROQU1FJywgJ0FTQyddO1xuICAgICAgICAgICAgJHNjb3BlLmdldERpdmlkZXIgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS51c2VyZnVsbG5hbWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJHNjb3BlLnNob3dEaXZpZGVyID0gZnVuY3Rpb24oZW50cnksIHByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2aW91cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS51c2VyaWQgIT0gcHJldmlvdXMudXNlcmlkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBOZXdlc3QgZmlyc3QuXG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnbmV3ZXN0X2ZpcnN0Jykge1xuICAgICAgICAgICAgdmlld01vZGUgPSAnZGF0ZSc7XG4gICAgICAgICAgICBmZXRjaEZ1bmN0aW9uID0gJG1tYU1vZEdsb3NzYXJ5LmdldEVudHJpZXNCeURhdGU7XG4gICAgICAgICAgICBmZXRjaEludmFsaWRhdGUgPSAkbW1hTW9kR2xvc3NhcnkuaW52YWxpZGF0ZUVudHJpZXNCeURhdGU7XG4gICAgICAgICAgICBmZXRjaEFyZ3VtZW50cyA9IFtnbG9zc2FyeS5pZCwgJ0NSRUFUSU9OJywgJ0RFU0MnXTtcbiAgICAgICAgICAgICRzY29wZS5nZXREaXZpZGVyID0gbm9vcDtcbiAgICAgICAgICAgICRzY29wZS5zaG93RGl2aWRlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbiAgICAgICAgLy8gUmVjZW50bHkgdXBkYXRlZC5cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09ICdyZWNlbnRseV91cGRhdGVkJykge1xuICAgICAgICAgICAgdmlld01vZGUgPSAnZGF0ZSc7XG4gICAgICAgICAgICBmZXRjaEZ1bmN0aW9uID0gJG1tYU1vZEdsb3NzYXJ5LmdldEVudHJpZXNCeURhdGU7XG4gICAgICAgICAgICBmZXRjaEludmFsaWRhdGUgPSAkbW1hTW9kR2xvc3NhcnkuaW52YWxpZGF0ZUVudHJpZXNCeURhdGU7XG4gICAgICAgICAgICBmZXRjaEFyZ3VtZW50cyA9IFtnbG9zc2FyeS5pZCwgJ1VQREFURScsICdERVNDJ107XG4gICAgICAgICAgICAkc2NvcGUuZ2V0RGl2aWRlciA9IG5vb3A7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0RpdmlkZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4gICAgICAgIC8vIFNlYXJjaCBmb3IgZW50cmllcy5cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09ICdzZWFyY2gnKSB7XG4gICAgICAgICAgICB2aWV3TW9kZSA9ICdzZWFyY2gnO1xuICAgICAgICAgICAgZmV0Y2hGdW5jdGlvbiA9ICRtbWFNb2RHbG9zc2FyeS5nZXRFbnRyaWVzQnlTZWFyY2g7XG4gICAgICAgICAgICBmZXRjaEludmFsaWRhdGUgPSAkbW1hTW9kR2xvc3NhcnkuaW52YWxpZGF0ZUVudHJpZXNCeVNlYXJjaDtcbiAgICAgICAgICAgIGZldGNoQXJndW1lbnRzID0gZmFsc2U7IC8vIER5bmFtaWNhbGx5IHNldCBsYXRlci5cbiAgICAgICAgICAgICRzY29wZS5pc1NlYXJjaCA9IHRydWU7XG4gICAgICAgICAgICAkc2NvcGUuZ2V0RGl2aWRlciA9IG5vb3A7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0RpdmlkZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICAgICAgaW5zdGFudEZldGNoID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ29uc2lkZXIgaXQgaXMgJ2xldHRlcl9hbGwnLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlld01vZGUgPSAnbGV0dGVyJztcbiAgICAgICAgICAgIGZldGNoTW9kZSA9ICdsZXR0ZXJfYWxsJztcbiAgICAgICAgICAgIGZldGNoRnVuY3Rpb24gPSAkbW1hTW9kR2xvc3NhcnkuZ2V0RW50cmllc0J5TGV0dGVyO1xuICAgICAgICAgICAgZmV0Y2hJbnZhbGlkYXRlID0gJG1tYU1vZEdsb3NzYXJ5LmludmFsaWRhdGVFbnRyaWVzQnlMZXR0ZXI7XG4gICAgICAgICAgICBmZXRjaEFyZ3VtZW50cyA9IFtnbG9zc2FyeS5pZCwgJ0FMTCddO1xuICAgICAgICAgICAgJHNjb3BlLmdldERpdmlkZXIgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5jb25jZXB0LnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICRzY29wZS5zaG93RGl2aWRlciA9IGZ1bmN0aW9uKGVudHJ5LCBwcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldmlvdXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHNjb3BlLmdldERpdmlkZXIoZW50cnkpICE9ICRzY29wZS5nZXREaXZpZGVyKHByZXZpb3VzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFudEZldGNoO1xuICAgIH1cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2dsb3NzYXJ5JylcblxuLyoqXG4gKiBHbG9zc2FyeSBzZXJ2aWNlLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RHbG9zc2FyeVxuICovXG4uZmFjdG9yeSgnJG1tYU1vZEdsb3NzYXJ5JywgZnVuY3Rpb24oJG1tU2l0ZSwgJHEsICRtbVNpdGVzTWFuYWdlcikge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvdXJzZSBnbG9zc2FyeSBjYWNoZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZUlkXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I19nZXRDb3Vyc2VHbG9zc2FyaWVzQ2FjaGVLZXlcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRDb3Vyc2VHbG9zc2FyaWVzQ2FjaGVLZXkgPSBmdW5jdGlvbihjb3Vyc2VJZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZEdsb3NzYXJ5OmNvdXJzZUdsb3NzYXJpZXM6JyArIGNvdXJzZUlkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBnbG9zc2FyaWVzIGluIGEgY291cnNlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VJZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmVkIHdpdGggdGhlIGdsb3NzYXJpZXNcbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2dldENvdXJzZUdsb3NzYXJpZXNcbiAgICAgKi9cbiAgICBzZWxmLmdldENvdXJzZUdsb3NzYXJpZXMgPSBmdW5jdGlvbihjb3Vyc2VJZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkczogW2NvdXJzZUlkXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IHNlbGYuX2dldENvdXJzZUdsb3NzYXJpZXNDYWNoZUtleShjb3Vyc2VJZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9nbG9zc2FyeV9nZXRfZ2xvc3Nhcmllc19ieV9jb3Vyc2VzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5nbG9zc2FyaWVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb3Vyc2UgZ2xvc3NhcnkgY2FjaGUga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VJZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjaW52YWxpZGF0ZUNvdXJzZUdsb3NzYXJpZXNcbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDb3Vyc2VHbG9zc2FyaWVzID0gZnVuY3Rpb24oY291cnNlSWQpIHtcbiAgICAgICAgdmFyIGtleSA9IHNlbGYuX2dldENvdXJzZUdsb3NzYXJpZXNDYWNoZUtleShjb3Vyc2VJZCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZW50cmllcyBieSBhdXRob3IgY2FjaGUga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBnbG9zc2FyeUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBsZXR0ZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpZWxkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzb3J0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I19nZXRFbnRyaWVzQnlBdXRob3JDYWNoZUtleVxuICAgICAqL1xuICAgIHNlbGYuX2dldEVudHJpZXNCeUF1dGhvckNhY2hlS2V5ID0gZnVuY3Rpb24oZ2xvc3NhcnlJZCwgbGV0dGVyLCBmaWVsZCwgc29ydCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZEdsb3NzYXJ5OmVudHJpZXNCeUF1dGhvcjonICsgZ2xvc3NhcnlJZCArIFwiOlwiICsgbGV0dGVyICsgXCI6XCIgKyBmaWVsZCArIFwiOlwiICsgc29ydDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGVudHJpZXMgYnkgYXV0aG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBnbG9zc2FyeUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBsZXR0ZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpZWxkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzb3J0XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcm9tXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsaW1pdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQG5nZG9jICBtZXRob2RcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmFtZSAgICRtbWFNb2RHbG9zc2FyeSNnZXRFbnRyaWVzQnlBdXRob3JcbiAgICAgKi9cbiAgICBzZWxmLmdldEVudHJpZXNCeUF1dGhvciA9IGZ1bmN0aW9uKGdsb3NzYXJ5SWQsIGxldHRlciwgZmllbGQsIHNvcnQsIGZyb20sIGxpbWl0KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGdsb3NzYXJ5SWQsXG4gICAgICAgICAgICAgICAgbGV0dGVyOiBsZXR0ZXIsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICBsaW1pdDogbGltaXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBzZWxmLl9nZXRFbnRyaWVzQnlBdXRob3JDYWNoZUtleShnbG9zc2FyeUlkLCBsZXR0ZXIsIGZpZWxkLCBzb3J0KVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfZ2xvc3NhcnlfZ2V0X2VudHJpZXNfYnlfYXV0aG9yJywgcGFyYW1zLCBwcmVTZXRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBjYWNoZSBvZiBlbnRyaWVzIGJ5IGF1dGhvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZ2xvc3NhcnlJZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbGV0dGVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBmaWVsZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc29ydFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQG5nZG9jICBtZXRob2RcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmFtZSAgICRtbWFNb2RHbG9zc2FyeSNpbnZhbGlkYXRlRW50cmllc0J5QXV0aG9yXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlRW50cmllc0J5QXV0aG9yID0gZnVuY3Rpb24oZ2xvc3NhcnlJZCwgbGV0dGVyLCBmaWVsZCwgc29ydCkge1xuICAgICAgICB2YXIga2V5ID0gc2VsZi5fZ2V0RW50cmllc0J5QXV0aG9yQ2FjaGVLZXkoZ2xvc3NhcnlJZCwgbGV0dGVyLCBmaWVsZCwgc29ydCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZW50cmllcyBieSBkYXRlIGNhY2hlIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZ2xvc3NhcnlJZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gb3JkZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNvcnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjX2dldEVudHJpZXNCeURhdGVDYWNoZUtleVxuICAgICAqL1xuICAgIHNlbGYuX2dldEVudHJpZXNCeURhdGVDYWNoZUtleSA9IGZ1bmN0aW9uKGdsb3NzYXJ5SWQsIG9yZGVyLCBzb3J0KSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kR2xvc3Nhcnk6ZW50cmllc0J5RGF0ZTonICsgZ2xvc3NhcnlJZCArIFwiOlwiICsgb3JkZXIgKyBcIjpcIiArIHNvcnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBlbnRyaWVzIGJ5IGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdsb3NzYXJ5SWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG9yZGVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzb3J0XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcm9tXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsaW1pdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQG5nZG9jICBtZXRob2RcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmFtZSAgICRtbWFNb2RHbG9zc2FyeSNnZXRFbnRyaWVzQnlEYXRlXG4gICAgICovXG4gICAgc2VsZi5nZXRFbnRyaWVzQnlEYXRlID0gZnVuY3Rpb24oZ2xvc3NhcnlJZCwgb3JkZXIsIHNvcnQsIGZyb20sIGxpbWl0KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGdsb3NzYXJ5SWQsXG4gICAgICAgICAgICAgICAgb3JkZXI6IG9yZGVyLFxuICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICBsaW1pdDogbGltaXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBzZWxmLl9nZXRFbnRyaWVzQnlEYXRlQ2FjaGVLZXkoZ2xvc3NhcnlJZCwgb3JkZXIsIHNvcnQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9nbG9zc2FyeV9nZXRfZW50cmllc19ieV9kYXRlJywgcGFyYW1zLCBwcmVTZXRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBjYWNoZSBvZiBlbnRyaWVzIGJ5IGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdsb3NzYXJ5SWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGxldHRlclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmllbGRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjaW52YWxpZGF0ZUVudHJpZXNCeURhdGVcbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVFbnRyaWVzQnlEYXRlID0gZnVuY3Rpb24oZ2xvc3NhcnlJZCwgb3JkZXIsIHNvcnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHNlbGYuX2dldEVudHJpZXNCeURhdGVDYWNoZUtleShnbG9zc2FyeUlkLCBvcmRlciwgc29ydCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZW50cmllcyBieSBsZXR0ZXIgY2FjaGUga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBnbG9zc2FyeUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBsZXR0ZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjX2dldEVudHJpZXNCeUxldHRlckNhY2hlS2V5XG4gICAgICovXG4gICAgc2VsZi5fZ2V0RW50cmllc0J5TGV0dGVyQ2FjaGVLZXkgPSBmdW5jdGlvbihnbG9zc2FyeUlkLCBsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RHbG9zc2FyeTplbnRyaWVzQnlMZXR0ZXI6JyArIGdsb3NzYXJ5SWQgKyBcIjpcIiArIGxldHRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGVudHJpZXMgYnkgbGV0dGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBnbG9zc2FyeUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBsZXR0ZXJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZyb21cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbWl0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2dldEVudHJpZXNCeUxldHRlclxuICAgICAqL1xuICAgIHNlbGYuZ2V0RW50cmllc0J5TGV0dGVyID0gZnVuY3Rpb24oZ2xvc3NhcnlJZCwgbGV0dGVyLCBmcm9tLCBsaW1pdCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGlkOiBnbG9zc2FyeUlkLFxuICAgICAgICAgICAgICAgIGxldHRlcjogbGV0dGVyLFxuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogc2VsZi5fZ2V0RW50cmllc0J5TGV0dGVyQ2FjaGVLZXkoZ2xvc3NhcnlJZCwgbGV0dGVyKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfZ2xvc3NhcnlfZ2V0X2VudHJpZXNfYnlfbGV0dGVyJywgcGFyYW1zLCBwcmVTZXRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBjYWNoZSBvZiBlbnRyaWVzIGJ5IGxldHRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZ2xvc3NhcnlJZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbGV0dGVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2ludmFsaWRhdGVFbnRyaWVzQnlMZXR0ZXJcbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVFbnRyaWVzQnlMZXR0ZXIgPSBmdW5jdGlvbihnbG9zc2FyeUlkLCBsZXR0ZXIpIHtcbiAgICAgICAgdmFyIGtleSA9IHNlbGYuX2dldEVudHJpZXNCeUxldHRlckNhY2hlS2V5KGdsb3NzYXJ5SWQsIGxldHRlcik7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZW50cmllcyBieSBzZWFyY2ggY2FjaGUga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBnbG9zc2FyeUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBxdWVyeVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGZ1bGxzZWFyY2hcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG9yZGVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzb3J0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I19nZXRFbnRyaWVzQnlTZWFyY2hDYWNoZUtleVxuICAgICAqL1xuICAgIHNlbGYuX2dldEVudHJpZXNCeVNlYXJjaENhY2hlS2V5ID0gZnVuY3Rpb24oZ2xvc3NhcnlJZCwgcXVlcnksIGZ1bGxzZWFyY2gsIG9yZGVyLCBzb3J0KSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kR2xvc3Nhcnk6ZW50cmllc0J5U2VhcmNoOicgKyBnbG9zc2FyeUlkICsgXCI6XCIgKyBmdWxsc2VhcmNoICsgXCI6XCIgKyBvcmRlciArIFwiOlwiICsgc29ydCArIFwiOlwiICsgcXVlcnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBlbnRyaWVzIGJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZ2xvc3NhcnlJZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcXVlcnlcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBmdWxsc2VhcmNoXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBvcmRlclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc29ydFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZnJvbVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGltaXRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjZ2V0RW50cmllc0J5U2VhcmNoXG4gICAgICovXG4gICAgc2VsZi5nZXRFbnRyaWVzQnlTZWFyY2ggPSBmdW5jdGlvbihnbG9zc2FyeUlkLCBxdWVyeSwgZnVsbHNlYXJjaCwgb3JkZXIsIHNvcnQsIGZyb20sIGxpbWl0KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGdsb3NzYXJ5SWQsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGZ1bGxzZWFyY2g6IGZ1bGxzZWFyY2gsXG4gICAgICAgICAgICAgICAgb3JkZXI6IG9yZGVyLFxuICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICBsaW1pdDogbGltaXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBzZWxmLl9nZXRFbnRyaWVzQnlTZWFyY2hDYWNoZUtleShnbG9zc2FyeUlkLCBxdWVyeSwgZnVsbHNlYXJjaCwgb3JkZXIsIHNvcnQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9nbG9zc2FyeV9nZXRfZW50cmllc19ieV9zZWFyY2gnLCBwYXJhbXMsIHByZVNldHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGNhY2hlIG9mIGVudHJpZXMgYnkgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBnbG9zc2FyeUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBxdWVyeVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGZ1bGxzZWFyY2hcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG9yZGVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzb3J0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2ludmFsaWRhdGVFbnRyaWVzQnlTZWFyY2hcbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVFbnRyaWVzQnlTZWFyY2ggPSBmdW5jdGlvbihnbG9zc2FyeUlkLCBxdWVyeSwgZnVsbHNlYXJjaCwgb3JkZXIsIHNvcnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHNlbGYuX2dldEVudHJpZXNCeVNlYXJjaENhY2hlS2V5KGdsb3NzYXJ5SWQsIHF1ZXJ5LCBmdWxsc2VhcmNoLCBvcmRlciwgc29ydCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBlbnRyeSBieSBJRCBjYWNoZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I19nZXRFbnRyeUNhY2hlS2V5XG4gICAgICovXG4gICAgc2VsZi5fZ2V0RW50cnlDYWNoZUtleSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kR2xvc3Nhcnk6Z2V0RW50cnk6JyArIGlkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb25lIGVudHJ5IGJ5IElELlxuICAgICAqXG4gICAgICogQG5nZG9jICBtZXRob2RcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmFtZSAgICRtbWFNb2RHbG9zc2FyeSNnZXRFbnRyeVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICAgICAgRW50cnkgSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBlbnRyeS5cbiAgICAgKi9cbiAgICBzZWxmLmdldEVudHJ5ID0gZnVuY3Rpb24oaWQsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogc2VsZi5fZ2V0RW50cnlDYWNoZUtleShpZClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5yZWFkKCdtb2RfZ2xvc3NhcnlfZ2V0X2VudHJ5X2J5X2lkJywgcGFyYW1zLCBwcmVTZXRzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgY2FjaGUgb2YgZW50cnkgYnkgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2ludmFsaWRhdGVFbnRyeVxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUVudHJ5ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGtleSA9IHNlbGYuX2dldEVudHJ5Q2FjaGVLZXkoaWQpO1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShrZXkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb25lIGdsb3NzYXJ5IGJ5IGNtSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZUlkXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjbWlkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2dldEdsb3NzYXJ5XG4gICAgICovXG4gICAgc2VsZi5nZXRHbG9zc2FyeSA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBjbWlkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldENvdXJzZUdsb3NzYXJpZXMoY291cnNlSWQpLnRoZW4oZnVuY3Rpb24oZ2xvc3Nhcmllcykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGdsb3NzYXJpZXMsIGZ1bmN0aW9uKGdsb3NzYXJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGdsb3NzYXJ5LmNvdXJzZW1vZHVsZSA9PSBjbWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdsb3NzYXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBvbmUgZ2xvc3NhcnkgYnkgZ2xvc3NhcnkgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZUlkXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQG5nZG9jICBtZXRob2RcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmFtZSAgICRtbWFNb2RHbG9zc2FyeSNnZXRHbG9zc2FyeUJ5SWRcbiAgICAgKi9cbiAgICBzZWxmLmdldEdsb3NzYXJ5QnlJZCA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBpZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRDb3Vyc2VHbG9zc2FyaWVzKGNvdXJzZUlkKS50aGVuKGZ1bmN0aW9uKGdsb3NzYXJpZXMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChnbG9zc2FyaWVzLCBmdW5jdGlvbihnbG9zc2FyeSkge1xuICAgICAgICAgICAgICAgIGlmIChnbG9zc2FyeS5pZCA9PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnbG9zc2FyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBnbG9zc2FyeSBwbHVnaW4gaXMgZW5hYmxlZCBpbiBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kR2xvc3NhcnkjaXNQbHVnaW5FbmFibGVkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHdhcyBpbnRyb2R1Y2VkIGFsb25nIHdpdGggYWxsIHRoZSBvdGhlciByZXF1aXJlZCBvbmVzLlxuICAgICAgICAgICAgcmV0dXJuIHNpdGUud3NBdmFpbGFibGUoJ21vZF9nbG9zc2FyeV9nZXRfZ2xvc3Nhcmllc19ieV9jb3Vyc2VzJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgYSBnbG9zc2FyeSBhcyBiZWluZyB2aWV3ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEdsb3NzYXJ5I2xvZ1ZpZXdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgR2xvc3NhcnkgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgVGhlIG1vZGUgaW4gd2hpY2ggdGhlIGdsb3NzYXJ5IHdhcyB2aWV3ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sb2dWaWV3ID0gZnVuY3Rpb24oaWQsIG1vZGUpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIG1vZGU6IG1vZGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9nbG9zc2FyeV92aWV3X2dsb3NzYXJ5JywgcGFyYW1zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IGEgZ2xvc3NhcnkgZW50cnkgYXMgYmVpbmcgdmlld2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RHbG9zc2FyeSNsb2dFbnRyeVZpZXdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgRW50cnkgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sb2dFbnRyeVZpZXcgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfZ2xvc3Nhcnlfdmlld19lbnRyeScsIHBhcmFtcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZ2xvc3NhcnknKVxuXG4vKipcbiAqIE1vZCBnbG9zc2FyeSBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kR2xvc3NhcnlIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZEdsb3NzYXJ5SGFuZGxlcnMnLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbWFNb2RHbG9zc2FyeSwgJHN0YXRlLCAkcSwgJG1tQ29udGVudExpbmtzSGVscGVyLCAkbW1VdGlsLFxuICAgICAgICAgICAgJG1tQ291cnNlSGVscGVyKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvdXJzZSBjb250ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEdsb3NzYXJ5SGFuZGxlcnMjY291cnNlQ29udGVudFxuICAgICAqL1xuICAgIHNlbGYuY291cnNlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RHbG9zc2FyeS5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgaW5mby5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIFRoZSBjb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ2dsb3NzYXJ5Jyk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1vZF9nbG9zc2FyeScsIHttb2R1bGU6IG1vZHVsZSwgY291cnNlaWQ6IGNvdXJzZWlkfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kR2xvc3NhcnlIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgdG8gc2VlIGdsb3NzYXJ5IGluZGV4IGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzSW5kZXhFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kR2xvc3NhcnkuaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgdG8gc2VlIGdsb3NzYXJ5IGVudHJ5IGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRW50cnlFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kR2xvc3NhcnkuaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVCeUluc3RhbmNlKHNpdGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEVudHJ5KGVudHJ5SWQsIHNpdGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RHbG9zc2FyeS5nZXRFbnRyeShlbnRyeUlkLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5lbnRyeTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfZ2xvc3NhcnkuZXJyb3Jsb2FkaW5nZW50cnknLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJlYXQgYSBnbG9zc2FyeSBlbnRyeSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0cmVhdEVudHJ5TGluayhzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gJG1tVXRpbC5leHRyYWN0VXJsUGFyYW1zKHVybCk7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmVpZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgZmFsc2UgYmVjYXVzZSBhbGwgc2l0ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2l0ZXVybC5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLmZpbHRlclN1cHBvcnRlZFNpdGVzKHNpdGVJZHMsIGlzRW50cnlFbmFibGVkLCBmYWxzZSwgY291cnNlSWQpLnRoZW4oZnVuY3Rpb24oaWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ21tLmNvcmUudmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWV5ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXRlczogaWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cnkocGFyc2VJbnQocGFyYW1zLmVpZCwgMTApLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3Vyc2VJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oY291cnNlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRtbUNvdXJzZUhlbHBlci5nZXRNb2R1bGVDb3Vyc2VJZEJ5SW5zdGFuY2UoZW50cnkuZ2xvc3NhcnlpZCwgJ2dsb3NzYXJ5Jywgc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnk6IGVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpZDogY291cnNlSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db250ZW50TGlua3NIZWxwZXIuZ29JblNpdGUoJ3NpdGUubW9kX2dsb3NzYXJ5LWVudHJ5Jywgc3RhdGVQYXJhbXMsIHNpdGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgZ2xvc3NhcnkgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL2dsb3NzYXJ5L3ZpZXcucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIEdsb3NzYXJ5IGluZGV4LlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIudHJlYXRNb2R1bGVJbmRleFVybChzaXRlSWRzLCB1cmwsIGlzSW5kZXhFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC5pbmRleE9mKCcvbW9kL2dsb3NzYXJ5L3Nob3dlbnRyeS5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gR2xvc3NhcnkgZW50cnkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyZWF0RW50cnlMaW5rKHNpdGVJZHMsIHVybCwgY291cnNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2ZvcnVtJylcblxuLyoqXG4gKiBGb3J1bSBkaXNjdXNzaW9uIGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kRm9ydW1EaXNjdXNzaW9uQ3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kRm9ydW1EaXNjdXNzaW9uQ3RybCcsIGZ1bmN0aW9uKCRxLCAkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tYU1vZEZvcnVtLCAkbW1TaXRlLCAkbW1VdGlsLCAkdHJhbnNsYXRlLFxuICAgICAgICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUsIG1tYU1vZEZvcnVtQ29tcG9uZW50KSB7XG5cbiAgICB2YXIgZGlzY3Vzc2lvbmlkID0gJHN0YXRlUGFyYW1zLmRpc2N1c3Npb25pZCxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY2lkLFxuICAgICAgICBzY3JvbGxWaWV3O1xuXG4gICAgJHNjb3BlLmNvbXBvbmVudCA9IG1tYU1vZEZvcnVtQ29tcG9uZW50O1xuICAgICRzY29wZS5jb3Vyc2VpZCA9IGNvdXJzZWlkO1xuICAgICRzY29wZS5uZXdwb3N0ID0ge1xuICAgICAgICByZXBseWluZ3RvOiB1bmRlZmluZWQsXG4gICAgICAgIHN1YmplY3Q6ICcnLFxuICAgICAgICBtZXNzYWdlOiAnJ1xuICAgIH07XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgZm9ydW0gZGlzY3Vzc2lvbnMuXG4gICAgZnVuY3Rpb24gZmV0Y2hQb3N0cygpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RGb3J1bS5nZXREaXNjdXNzaW9uUG9zdHMoZGlzY3Vzc2lvbmlkKS50aGVuKGZ1bmN0aW9uKHBvc3RzKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGlzY3Vzc2lvbiA9ICRtbWFNb2RGb3J1bS5leHRyYWN0U3RhcnRpbmdQb3N0KHBvc3RzKTtcbiAgICAgICAgICAgICRzY29wZS5wb3N0cyA9IHBvc3RzO1xuXG4gICAgICAgICAgICAvLyBTZXQgZGVmYXVsdCByZXBseSBzdWJqZWN0LlxuICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUoJ21tYS5tb2RfZm9ydW0ucmUnKS50aGVuKGZ1bmN0aW9uKHN0clJlcGx5UHJlZml4KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRTdWJqZWN0ID0gc3RyUmVwbHlQcmVmaXggKyAnICcgKyAkc2NvcGUuZGlzY3Vzc2lvbi5zdWJqZWN0O1xuICAgICAgICAgICAgICAgICRzY29wZS5uZXdwb3N0LnN1YmplY3QgPSAkc2NvcGUuZGVmYXVsdFN1YmplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVmcmVzaCBwb3N0cy5cbiAgICBmdW5jdGlvbiByZWZyZXNoUG9zdHMoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kRm9ydW0uaW52YWxpZGF0ZURpc2N1c3Npb25Qb3N0cyhkaXNjdXNzaW9uaWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hQb3N0cygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmZXRjaFBvc3RzKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQWRkIGxvZyBpbiBNb29kbGUuXG4gICAgICAgICRtbVNpdGUud3JpdGUoJ21vZF9mb3J1bV92aWV3X2ZvcnVtX2Rpc2N1c3Npb24nLCB7XG4gICAgICAgICAgICBkaXNjdXNzaW9uaWQ6IGRpc2N1c3Npb25pZFxuICAgICAgICB9KTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuZGlzY3Vzc2lvbkxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBQdWxsIHRvIHJlZnJlc2guXG4gICAgJHNjb3BlLnJlZnJlc2hQb3N0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWZyZXNoUG9zdHMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIE5ldyBwb3N0IGFkZGVkLlxuICAgICRzY29wZS5uZXdQb3N0QWRkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzY3JvbGxWaWV3KSB7XG4gICAgICAgICAgICBzY3JvbGxWaWV3ID0gJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKCdtbWFNb2RGb3J1bVBvc3RzU2Nyb2xsJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nyb2xsVmlldyAmJiBzY3JvbGxWaWV3LnNjcm9sbFRvcCAmJiBzY3JvbGxWaWV3LnNjcm9sbFRvcCgpO1xuXG4gICAgICAgICRzY29wZS5uZXdwb3N0LnJlcGx5aW5ndG8gPSB1bmRlZmluZWQ7XG4gICAgICAgICRzY29wZS5uZXdwb3N0LnN1YmplY3QgPSAkc2NvcGUuZGVmYXVsdFN1YmplY3Q7XG4gICAgICAgICRzY29wZS5uZXdwb3N0Lm1lc3NhZ2UgPSAnJztcblxuICAgICAgICAkc2NvcGUuZGlzY3Vzc2lvbkxvYWRlZCA9IGZhbHNlO1xuICAgICAgICByZWZyZXNoUG9zdHMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmRpc2N1c3Npb25Mb2FkZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZm9ydW0nKVxuXG4vKipcbiAqIEZvcnVtIGRpc2N1c3Npb24gbGlzdCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb3J1bVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZEZvcnVtRGlzY3Vzc2lvbnNDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RGb3J1bURpc2N1c3Npb25zQ3RybCcsIGZ1bmN0aW9uKCRxLCAkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tYU1vZEZvcnVtLCAkbW1Db3Vyc2UsICRtbVV0aWwsICRtbUdyb3VwcyxcbiAgICAgICAgICAgICRtbUV2ZW50cywgJGlvbmljU2Nyb2xsRGVsZWdhdGUsICRpb25pY1BsYXRmb3JtLCBtbVVzZXJQcm9maWxlU3RhdGUsIG1tYU1vZEZvcnVtTmV3RGlzY3Vzc2lvbkV2ZW50KSB7XG4gICAgdmFyIG1vZHVsZSA9ICRzdGF0ZVBhcmFtcy5tb2R1bGUgfHwge30sXG4gICAgICAgIGNvdXJzZWlkID0gJHN0YXRlUGFyYW1zLmNvdXJzZWlkLFxuICAgICAgICBmb3J1bSxcbiAgICAgICAgcGFnZSA9IDAsXG4gICAgICAgIHNjcm9sbFZpZXcgPSAkaW9uaWNTY3JvbGxEZWxlZ2F0ZS4kZ2V0QnlIYW5kbGUoJ21tYU1vZEZvcnVtRGlzY3Vzc2lvbnNTY3JvbGwnKSxcbiAgICAgICAgc2hvdWxkU2Nyb2xsVG9wID0gZmFsc2UsXG4gICAgICAgIHVzZXNHcm91cHMgPSBmYWxzZTtcblxuICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAkc2NvcGUubW9kdWxldXJsID0gbW9kdWxlLnVybDtcbiAgICAkc2NvcGUuY291cnNlaWQgPSBjb3Vyc2VpZDtcbiAgICAkc2NvcGUudXNlclN0YXRlTmFtZSA9IG1tVXNlclByb2ZpbGVTdGF0ZTtcbiAgICAkc2NvcGUuaXNDcmVhdGVFbmFibGVkID0gJG1tYU1vZEZvcnVtLmlzQ3JlYXRlRGlzY3Vzc2lvbkVuYWJsZWQoKTtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBmb3J1bSBkYXRhIGFuZCBkaXNjdXNzaW9ucy5cbiAgICBmdW5jdGlvbiBmZXRjaEZvcnVtRGF0YUFuZERpc2N1c3Npb25zKHJlZnJlc2gpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RGb3J1bS5nZXRGb3J1bShjb3Vyc2VpZCwgbW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKGZvcnVtZGF0YSkge1xuICAgICAgICAgICAgZm9ydW0gPSBmb3J1bWRhdGE7XG5cbiAgICAgICAgICAgICRzY29wZS50aXRsZSA9IGZvcnVtLm5hbWUgfHwgJHNjb3BlLnRpdGxlO1xuICAgICAgICAgICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gZm9ydW0uaW50cm8gfHzCoCRzY29wZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICRzY29wZS5mb3J1bSA9IGZvcnVtO1xuXG4gICAgICAgICAgICByZXR1cm4gJG1tR3JvdXBzLmdldEFjdGl2aXR5R3JvdXBNb2RlKGZvcnVtLmNtaWQpLnRoZW4oZnVuY3Rpb24obW9kZSkge1xuICAgICAgICAgICAgICAgIHVzZXNHcm91cHMgPSBtb2RlID09PSAkbW1Hcm91cHMuU0VQQVJBVEVHUk9VUFMgfHwgbW9kZSA9PT0gJG1tR3JvdXBzLlZJU0lCTEVHUk9VUFM7XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaERpc2N1c3Npb25zKHJlZnJlc2gpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICghcmVmcmVzaCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBmb3J1bSBmYWlsZWQsIHJldHJ5IHdpdGhvdXQgdXNpbmcgY2FjaGUgc2luY2UgaXQgbWlnaHQgYmUgYSBuZXcgYWN0aXZpdHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZnJlc2hEYXRhKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9mb3J1bS5lcnJvcmdldGZvcnVtJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuY2FuTG9hZE1vcmUgPSBmYWxzZTsgLy8gU2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgaW5maW5pdGUgY2FsbHMgd2l0aCBpbmZpbml0ZS1sb2FkaW5nLlxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgZm9ydW0gZGlzY3Vzc2lvbnMuXG4gICAgZnVuY3Rpb24gZmV0Y2hEaXNjdXNzaW9ucyhyZWZyZXNoKSB7XG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICBwYWdlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1hTW9kRm9ydW0uZ2V0RGlzY3Vzc2lvbnMoZm9ydW0uaWQsIHBhZ2UpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gdXNlc0dyb3VwcyA/XG4gICAgICAgICAgICAgICAgICAgICRtbWFNb2RGb3J1bS5mb3JtYXREaXNjdXNzaW9uc0dyb3Vwcyhmb3J1bS5jbWlkLCByZXNwb25zZS5kaXNjdXNzaW9ucykgOiAkcS53aGVuKHJlc3BvbnNlLmRpc2N1c3Npb25zKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGlzY3Vzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFnZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5kaXNjdXNzaW9ucyA9IGRpc2N1c3Npb25zO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5kaXNjdXNzaW9ucyA9ICRzY29wZS5kaXNjdXNzaW9ucy5jb25jYXQoZGlzY3Vzc2lvbnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRzY29wZS5jb3VudCA9ICRzY29wZS5kaXNjdXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNhbkxvYWRNb3JlID0gcmVzcG9uc2UuY2FuTG9hZE1vcmU7XG4gICAgICAgICAgICAgICAgcGFnZSsrO1xuXG4gICAgICAgICAgICAgICAgcHJlRmV0Y2hEaXNjdXNzaW9uc1Bvc3RzKGRpc2N1c3Npb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgJHNjb3BlLmNhbkxvYWRNb3JlID0gZmFsc2U7IC8vIFNldCB0byBmYWxzZSB0byBwcmV2ZW50IGluZmluaXRlIGNhbGxzIHdpdGggaW5maW5pdGUtbG9hZGluZy5cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gcHJlZmV0Y2ggdGhlIHBvc3RzIG9mIGVhY2ggZGlzY3Vzc2lvbiwgc28gdGhleSdyZSBhdmFpbGFibGUgaW4gb2ZmbGluZSBtb2RlLlxuICAgIGZ1bmN0aW9uIHByZUZldGNoRGlzY3Vzc2lvbnNQb3N0cyhkaXNjdXNzaW9ucykge1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goZGlzY3Vzc2lvbnMsIGZ1bmN0aW9uKGRpc2N1c3Npb24pIHtcbiAgICAgICAgICAgIHZhciBkaXNjdXNzaW9uaWQgPSBkaXNjdXNzaW9uLmRpc2N1c3Npb247XG4gICAgICAgICAgICAkbW1hTW9kRm9ydW0uZ2V0RGlzY3Vzc2lvblBvc3RzKGRpc2N1c3Npb25pZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlZnJlc2ggZm9ydW0gZGF0YSBhbmQgZGlzY3Vzc2lvbnMgbGlzdC5cbiAgICBmdW5jdGlvbiByZWZyZXNoRGF0YSgpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZEZvcnVtLmludmFsaWRhdGVGb3J1bURhdGEoY291cnNlaWQpKTtcbiAgICAgICAgaWYgKGZvcnVtKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RGb3J1bS5pbnZhbGlkYXRlRGlzY3Vzc2lvbnNMaXN0KGZvcnVtLmlkKSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbUdyb3Vwcy5pbnZhbGlkYXRlQWN0aXZpdHlHcm91cE1vZGUoZm9ydW0uY21pZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hGb3J1bURhdGFBbmREaXNjdXNzaW9ucyh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmV0Y2hGb3J1bURhdGFBbmREaXNjdXNzaW9ucygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNb2RGb3J1bS5sb2dWaWV3KGZvcnVtLmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuZGlzY3Vzc2lvbnNMb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gTG9hZCBtb3JlIGRpc2N1c3Npb25zLlxuICAgICRzY29wZS5sb2FkTW9yZURpc2N1c3Npb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZldGNoRGlzY3Vzc2lvbnMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5pbmZpbml0ZVNjcm9sbENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBQdWxsIHRvIHJlZnJlc2guXG4gICAgJHNjb3BlLnJlZnJlc2hEaXNjdXNzaW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWZyZXNoRGF0YSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gTGlzdGVuIGZvciBkaXNjdXNzaW9ucyBhZGRlZC4gV2hlbiBhIGRpc2N1c3Npb24gaXMgYWRkZWQsIHdlIHJlbG9hZCB0aGUgZGF0YS5cbiAgICB2YXIgb2JzTmV3RGlzYyA9ICRtbUV2ZW50cy5vbihtbWFNb2RGb3J1bU5ld0Rpc2N1c3Npb25FdmVudCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoKGZvcnVtICYmIGZvcnVtLmlkID09PSBkYXRhLmZvcnVtaWQpIHx8IGRhdGEuY21pZCA9PT0gbW9kdWxlLmlkKSB7XG4gICAgICAgICAgICBpZiAoJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHNjcm9sbCB0b3AgaW5tZWRpYXRlbHkgYmVjYXVzZSB0aGUgc2Nyb2xsIGlzIG5vdCBzZWVuLlxuICAgICAgICAgICAgICAgIHNob3VsZFNjcm9sbFRvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuZGlzY3Vzc2lvbnNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlZnJlc2hEYXRhKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZGlzY3Vzc2lvbnNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNjcm9sbCB0b3AgaWYgbmVlZGVkLlxuICAgICRzY29wZS4kb24oJyRpb25pY1ZpZXcuZW50ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgc2hvdWxkU2Nyb2xsVG9wID0gZmFsc2U7XG4gICAgICAgICAgICBzY3JvbGxWaWV3LnNjcm9sbFRvcCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmIChvYnNOZXdEaXNjICYmIG9ic05ld0Rpc2Mub2ZmKSB7XG4gICAgICAgICAgICBvYnNOZXdEaXNjLm9mZigpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9mb3J1bScpXG5cbi8qKlxuICogQWRkIG5ldyBkaXNjdXNzaW9uIGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kRm9ydW1OZXdEaXNjdXNzaW9uQ3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kRm9ydW1OZXdEaXNjdXNzaW9uQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1Hcm91cHMsICRxLCAkbW1hTW9kRm9ydW0sICRtbUV2ZW50cywgJGlvbmljUGxhdGZvcm0sXG4gICAgICAgICAgICAkbW1VdGlsLCAkaW9uaWNIaXN0b3J5LCAkdHJhbnNsYXRlLCBtbWFNb2RGb3J1bU5ld0Rpc2N1c3Npb25FdmVudCkge1xuXG4gICAgdmFyIGNvdXJzZWlkID0gJHN0YXRlUGFyYW1zLmNpZCxcbiAgICAgICAgZm9ydW1pZCA9ICRzdGF0ZVBhcmFtcy5mb3J1bWlkLFxuICAgICAgICBjbWlkID0gJHN0YXRlUGFyYW1zLmNtaWQ7XG5cbiAgICAkc2NvcGUubmV3ZGlzY3Vzc2lvbiA9IHtcbiAgICAgICAgc3ViamVjdDogJycsXG4gICAgICAgIG1lc3NhZ2U6ICcnLFxuICAgICAgICBzdWJzY3JpYmU6IHRydWVcbiAgICB9O1xuXG4gICAgLy8gRmV0Y2ggaWYgZm9ydW0gdXNlcyBncm91cHMgYW5kIHRoZSBncm91cHMgaXQgdXNlcy5cbiAgICBmdW5jdGlvbiBmZXRjaEdyb3VwcyhyZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiAkbW1Hcm91cHMuZ2V0QWN0aXZpdHlHcm91cE1vZGUoY21pZCkudGhlbihmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJG1tR3JvdXBzLlNFUEFSQVRFR1JPVVBTIHx8IG1vZGUgPT09ICRtbUdyb3Vwcy5WSVNJQkxFR1JPVVBTKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUdyb3Vwcy5nZXRBY3Rpdml0eUFsbG93ZWRHcm91cHMoY21pZCkudGhlbihmdW5jdGlvbihmb3J1bWdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICRtbUdyb3Vwcy5WSVNJQkxFR1JPVVBTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIHdoaWNoIG9mIHRoZSByZXR1cm5lZCBncm91cHMgdGhlIHVzZXIgY2FuIHBvc3QgdG8uXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gdmFsaWRhdGVWaXNpYmxlR3JvdXBzKGZvcnVtZ3JvdXBzLCByZWZyZXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdTIGFscmVhZHkgZmlsdGVycyBncm91cHMsIG5vIG5lZWQgdG8gZG8gaXQgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oZm9ydW1ncm91cHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihmb3J1bWdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcnVtZ3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZ3JvdXBzID0gZm9ydW1ncm91cHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm5ld2Rpc2N1c3Npb24uZ3JvdXBpZCA9IGZvcnVtZ3JvdXBzWzBdLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zaG93R3JvdXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2hvd0Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1vZGUgPT09ICRtbUdyb3Vwcy5TRVBBUkFURUdST1VQUyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbW1hLm1vZF9mb3J1bS5jYW5ub3RhZGRkaXNjdXNzaW9uYWxsJyA6ICdtbWEubW9kX2ZvcnVtLmNhbm5vdGFkZGRpc2N1c3Npb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoJHRyYW5zbGF0ZS5pbnN0YW50KG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5zaG93R3JvdXBzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNob3dGb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2ZvcnVtLmVycm9yZ2V0Z3JvdXBzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgd2hpY2ggb2YgdGhlIGdyb3VwcyByZXR1cm5lZCBieSBnZXRBY3Rpdml0eUFsbG93ZWRHcm91cHMgaW4gdmlzaWJsZSBncm91cHMgc2hvdWxkIGJlIHNob3duIHRvIHBvc3QgdG8uXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVWaXNpYmxlR3JvdXBzKGZvcnVtZ3JvdXBzLCByZWZyZXNoKSB7XG4gICAgICAgIGlmICgkbW1hTW9kRm9ydW0uaXNDYW5BZGREaXNjdXNzaW9uQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgY2FuQWRkRGlzY3Vzc2lvbiBmdW5jdGlvbiB0byBmaWx0ZXIgdGhlIGdyb3Vwcy5cbiAgICAgICAgICAgIC8vIFdlIGZpcnN0IGNoZWNrIGlmIHRoZSB1c2VyIGNhbiBwb3N0IHRvIGFsbCB0aGUgZ3JvdXBzLlxuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RGb3J1bS5jYW5BZGREaXNjdXNzaW9uVG9BbGwoZm9ydW1pZCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNhbGwgZmFpbGVkLCBsZXQncyBhc3N1bWUgaGUgY2FuJ3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihjYW5BZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGNhbiBwb3N0IHRvIGFsbCBncm91cHMsIHJldHVybiB0aGVtIGFsbC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcnVtZ3JvdXBzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGNhbid0IHBvc3QgdG8gYWxsIGdyb3VwcywgbGV0J3MgY2hlY2sgd2hpY2ggZ3JvdXBzIGhlIGNhbiBwb3N0IHRvLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZvcnVtZ3JvdXBzLCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kRm9ydW0uY2FuQWRkRGlzY3Vzc2lvbihmb3J1bWlkLCBncm91cC5pZCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNhbGwgZmFpbGVkLCBsZXQncyByZXR1cm4gdHJ1ZSBzbyB0aGUgZ3JvdXAgaXMgc2hvd24uIElmIHRoZSB1c2VyIGNhbid0IHBvc3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBhbiBlcnJvciB3aWxsIGJlIHNob3duIHdoZW4gaGUgdHJpZXMgdG8gYWRkIHRoZSBkaXNjdXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihjYW5BZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4ndCBjaGVjayBpdCB1c2luZyBXUy4gV2UnbGwgZ2V0IHRoZSBncm91cHMgdGhlIHVzZXIgYmVsb25ncyB0byBhbmQgdXNlIHRoZW0gdG9cbiAgICAgICAgICAgIC8vIGZpbHRlciB0aGUgZ3JvdXBzIHRvIHBvc3QuXG4gICAgICAgICAgICByZXR1cm4gJG1tR3JvdXBzLmdldFVzZXJHcm91cHNJbkNvdXJzZShjb3Vyc2VpZCwgcmVmcmVzaCkudGhlbihmdW5jdGlvbih1c2VyZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJncm91cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgZG9lc24ndCBiZWxvbmcgdG8gYW55IGdyb3VwLCBwcm9iYWJseSBhIHRlYWNoZXIuIExldCdzIHJldHVybiBhbGwgZ3JvdXBzLFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdXNlciBjYW4ndCBwb3N0IHRvIHNvbWUgb2YgdGhlbSBpdCB3aWxsIGJlIGZpbHRlcmVkIGJ5IGFkZCBkaXNjdXNzaW9uIFdTLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ydW1ncm91cHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJHcm91cHMoZm9ydW1ncm91cHMsIHVzZXJncm91cHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgZm9ydW1ncm91cHMsIHJldHVybmluZyBvbmx5IHRob3NlIHRoYXQgYXJlIGluc2lkZSB1c2VyZ3JvdXBzLlxuICAgIGZ1bmN0aW9uIGZpbHRlckdyb3Vwcyhmb3J1bWdyb3VwcywgdXNlcmdyb3Vwcykge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSBbXSxcbiAgICAgICAgICAgIHVzZXJncm91cHNpZHMgPSB1c2VyZ3JvdXBzLm1hcChmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGcuaWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goZm9ydW1ncm91cHMsIGZ1bmN0aW9uKGZnKSB7XG4gICAgICAgICAgICBpZiAodXNlcmdyb3Vwc2lkcy5pbmRleE9mKGZnLmlkKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChmZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICB9XG5cbiAgICBmZXRjaEdyb3VwcygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5ncm91cHNMb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gUHVsbCB0byByZWZyZXNoLlxuICAgICRzY29wZS5yZWZyZXNoR3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwMSA9ICRtbUdyb3Vwcy5pbnZhbGlkYXRlQWN0aXZpdHlHcm91cE1vZGUoY21pZCksXG4gICAgICAgICAgICBwMiA9ICRtbUdyb3Vwcy5pbnZhbGlkYXRlQWN0aXZpdHlBbGxvd2VkR3JvdXBzKGNtaWQpLFxuICAgICAgICAgICAgcDMgPSAkbW1hTW9kRm9ydW0uaW52YWxpZGF0ZUNhbkFkZERpc2N1c3Npb24oZm9ydW1pZCk7XG5cbiAgICAgICAgJHEuYWxsKFtwMSwgcDJdKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZmV0Y2hHcm91cHModHJ1ZSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYSBuZXcgZGlzY3Vzc2lvbi5cbiAgICAkc2NvcGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gJHNjb3BlLm5ld2Rpc2N1c3Npb24uc3ViamVjdCxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAkc2NvcGUubmV3ZGlzY3Vzc2lvbi5tZXNzYWdlLFxuICAgICAgICAgICAgc3Vic2NyaWJlID0gJHNjb3BlLm5ld2Rpc2N1c3Npb24uc3Vic2NyaWJlLFxuICAgICAgICAgICAgZ3JvdXBpZCA9ICRzY29wZS5uZXdkaXNjdXNzaW9uLmdyb3VwaWQ7XG5cbiAgICAgICAgaWYgKCFzdWJqZWN0KSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2ZvcnVtLmVycm9yZW1wdHlzdWJqZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2ZvcnVtLmVycm9yZW1wdHltZXNzYWdlJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSA9ICc8cD4nICsgbWVzc2FnZSArICc8cD4nO1xuXG4gICAgICAgICRtbWFNb2RGb3J1bS5hZGROZXdEaXNjdXNzaW9uKGZvcnVtaWQsIHN1YmplY3QsIG1lc3NhZ2UsIHN1YnNjcmliZSwgZ3JvdXBpZCkudGhlbihmdW5jdGlvbihkaXNjdXNzaW9uaWQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGZvcnVtaWQ6IGZvcnVtaWQsXG4gICAgICAgICAgICAgICAgZGlzY3Vzc2lvbmlkOiBkaXNjdXNzaW9uaWQsXG4gICAgICAgICAgICAgICAgY21pZDogY21pZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tYU1vZEZvcnVtTmV3RGlzY3Vzc2lvbkV2ZW50LCBkYXRhKTtcblxuICAgICAgICAgICAgaWYgKCRpb25pY1BsYXRmb3JtLmlzVGFibGV0KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBFbXB0eSBmb3JtLlxuICAgICAgICAgICAgICAgICRzY29wZS5uZXdkaXNjdXNzaW9uLnN1YmplY3QgPSAnJztcbiAgICAgICAgICAgICAgICAkc2NvcGUubmV3ZGlzY3Vzc2lvbi5tZXNzYWdlID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEdvIGJhY2sgdG8gZGlzY3Vzc2lvbnMgbGlzdC5cbiAgICAgICAgICAgICAgICAkaW9uaWNIaXN0b3J5LmdvQmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfZm9ydW0uY2Fubm90Y3JlYXRlZGlzY3Vzc2lvbicsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZm9ydW0nKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBzaG93IGEgZGlzY3Vzc2lvbiBwb3N0LCBpdHMgYXR0YWNobWVudHMgYW5kIHRoZSBhY3Rpb24gYnV0dG9ucyBhbGxvd2VkIChyZXBseSwgZXRjLikuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbWFGb3J1bURpc2N1c3Npb25Qb3N0XG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgZGlyZWN0aXZlIHdpbGwgc2hvdyBhIGZvcnVtIHBvc3QgaWYgdGhlIHJpZ2h0IGRhdGEgaXMgc3VwcGxpZWQuIEF0dHJpYnV0ZXM6XG4gKlxuICogQHBhcmFtwqB7T2JqZWN0fSBwb3N0ICAgICAgICAgICAgIFBvc3QuXG4gKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgICAgICAgICBQb3N0J3MgY291cnNlIElELlxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlICAgICAgICAgICAgUG9zdCdzIHRpdGxlLlxuICogQHBhcmFtIHtTdHJpbmd9IHN1YmplY3QgICAgICAgICAgUG9zdCdzIHN1YmplY3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgICAgICBDb21wb25lbnQgdGhpcyBwb3N0IGJlbG9uZyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdwb3N0ICAgICAgICAgIE9iamVjdCB3aXRoIHRoZSBuZXcgcG9zdCBkYXRhLiBVc3VhbGx5IHNoYXJlZCBiZXR3ZWVuIHBvc3RzLlxuICogQHBhcmFtIHtCb29sZWFufSBzaG93ZGl2aWRlciAgICAgVHJ1ZSBpZiBpdCBzaG91bGQgaGF2ZSBhIGxpc3QgZGl2aWRlciBiZWZvcmUgdGhlIHBvc3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRpdGxlaW1wb3J0YW50ICBUcnVlIGlmIHRpdGxlIHNob3VsZCBiZSBcImltcG9ydGFudFwiIChib2xkKS5cbiAqIEBvYXJhbSB7RnVuY3Rpb259IFtwb3N0YWRkZWRdICAgIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIG5ldyBwb3N0IGlzIGFkZGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWZhdWx0c3ViamVjdF0gRGVmYXVsdCBzdWJqZWN0IHRvIHNldCB0byBuZXcgcG9zdHMuXG4gKi9cbi5kaXJlY3RpdmUoJ21tYU1vZEZvcnVtRGlzY3Vzc2lvblBvc3QnLCBmdW5jdGlvbigkbW1hTW9kRm9ydW0sICRtbVV0aWwsICR0cmFuc2xhdGUsICRxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgIHBvc3Q6ICc9JyxcbiAgICAgICAgICAgIGNvdXJzZWlkOiAnPScsXG4gICAgICAgICAgICB0aXRsZTogJz0nLFxuICAgICAgICAgICAgc3ViamVjdDogJz0nLFxuICAgICAgICAgICAgY29tcG9uZW50OiAnPScsXG4gICAgICAgICAgICBuZXdwb3N0OiAnPScsXG4gICAgICAgICAgICBzaG93ZGl2aWRlcjogJz0/JyxcbiAgICAgICAgICAgIHRpdGxlaW1wb3J0YW50OiAnPT8nLFxuICAgICAgICAgICAgcG9zdGFkZGVkOiAnJj8nLFxuICAgICAgICAgICAgZGVmYXVsdHN1YmplY3Q6ICc9PydcbiAgICAgICAgfSxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2ZvcnVtL3RlbXBsYXRlcy9kaXNjdXNzaW9ucG9zdC5odG1sJyxcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgICAgIHNjb3BlLmlzUmVwbHlFbmFibGVkID0gJG1tYU1vZEZvcnVtLmlzUmVwbHlQb3N0RW5hYmxlZCgpO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhpcyBwb3N0IGFzIGJlaW5nIHJlcGxpZWQgdG8uXG4gICAgICAgICAgICBzY29wZS5zaG93UmVwbHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5uZXdwb3N0LnJlcGx5aW5ndG8gPSBzY29wZS5wb3N0LmlkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gUmVwbHkgdG8gdGhpcyBwb3N0LlxuICAgICAgICAgICAgc2NvcGUucmVwbHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLm5ld3Bvc3Quc3ViamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2ZvcnVtLmVycm9yZW1wdHlzdWJqZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZS5uZXdwb3N0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9mb3J1bS5lcnJvcmVtcHR5bWVzc2FnZScsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnPHA+JyArIHNjb3BlLm5ld3Bvc3QubWVzc2FnZS5yZXBsYWNlKC9cXG4vZywgJzxicj4nKSArICc8L3A+JyxcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tLmNvcmUuc2VuZGluZycsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgJG1tYU1vZEZvcnVtLnJlcGx5UG9zdChzY29wZS5uZXdwb3N0LnJlcGx5aW5ndG8sIHNjb3BlLm5ld3Bvc3Quc3ViamVjdCwgbWVzc2FnZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLnBvc3RhZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucG9zdGFkZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9mb3J1bS5jb3VsZG5vdGFkZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQ2FuY2VsIHJlcGx5LlxuICAgICAgICAgICAgc2NvcGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZS5uZXdwb3N0LnN1YmplY3QgJiYgIXNjb3BlLm5ld3Bvc3QubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbigpOyAvLyBOb3RoaW5nIHdyaXR0ZW4sIGNhbmNlbCByaWdodCBhd2F5LlxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1VdGlsLnNob3dDb25maXJtKCR0cmFuc2xhdGUoJ21tLmNvcmUuYXJleW91c3VyZScpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm5ld3Bvc3QucmVwbHlpbmd0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUubmV3cG9zdC5zdWJqZWN0ID0gc2NvcGUuZGVmYXVsdHN1YmplY3TCoHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5uZXdwb3N0Lm1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZm9ydW0nKVxuXG4vKipcbiAqIEZvcnVtIHNlcnZpY2UuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgJG1tYU1vZEZvcnVtXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kRm9ydW0nLCBmdW5jdGlvbigkcSwgJG1tU2l0ZSwgJG1tVXNlciwgJG1tR3JvdXBzLCAkdHJhbnNsYXRlLCAkbW1TaXRlc01hbmFnZXIsIG1tYU1vZEZvcnVtRGlzY1BlclBhZ2UpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgY2FuIGFkZCBkaXNjdXNzaW9uIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmb3J1bWlkIEZvcnVtIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZ3JvdXBpZCBHcm91cCBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENhbkFkZERpc2N1c3Npb25DYWNoZUtleShmb3J1bWlkLCBncm91cGlkKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21tb25DYW5BZGREaXNjdXNzaW9uQ2FjaGVLZXkoZm9ydW1pZCkgKyAnOicgKyBncm91cGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjb21tb24gcGFydCBvZiBjYWNoZSBrZXkgZm9yIGNhbiBhZGQgZGlzY3Vzc2lvbiBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZm9ydW1pZCBGb3J1bSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENvbW1vbkNhbkFkZERpc2N1c3Npb25DYWNoZUtleShmb3J1bWlkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kRm9ydW06Y2FuYWRkZGlzY3Vzc2lvbjonICsgZm9ydW1pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBmb3J1bSBkYXRhIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZvcnVtRGF0YUNhY2hlS2V5KGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kRm9ydW06Zm9ydW06JyArIGNvdXJzZWlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGZvcnVtIGRpc2N1c3Npb24gcG9zdHMgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRpc2N1c3Npb25pZCBEaXNjdXNzaW9uIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXREaXNjdXNzaW9uUG9zdHNDYWNoZUtleShkaXNjdXNzaW9uaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RGb3J1bTpkaXNjdXNzaW9uOicgKyBkaXNjdXNzaW9uaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZm9ydW0gZGlzY3Vzc2lvbnMgbGlzdCBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZm9ydW1pZCBGb3J1bSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldERpc2N1c3Npb25zTGlzdENhY2hlS2V5KGZvcnVtaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RGb3J1bTpkaXNjdXNzaW9uczonICsgZm9ydW1pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgZGlzY3Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb3J1bVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9ydW0jYWRkTmV3RGlzY3Vzc2lvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb3J1bWlkICAgRm9ydW0gSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN1YmplY3QgICBOZXcgZGlzY3Vzc2lvbidzIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgICBOZXcgZGlzY3Vzc2lvbidzIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN1YnNjcmliZSBUcnVlIGlmIHNob3VsZCBzdWJzY3JpYmUgdG8gdGhlIGRpc2N1c3Npb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2dyb3VwaWRdIEdyb3VwIHRoaXMgZGlzY3Vzc2lvbiBiZWxvbmdzIHRvLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkaXNjdXNzaW9uIGlzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5hZGROZXdEaXNjdXNzaW9uID0gZnVuY3Rpb24oZm9ydW1pZCwgc3ViamVjdCwgbWVzc2FnZSwgc3Vic2NyaWJlLCBncm91cGlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBmb3J1bWlkOiBmb3J1bWlkLFxuICAgICAgICAgICAgc3ViamVjdDogc3ViamVjdCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZGlzY3Vzc2lvbnN1YnNjcmliZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhIXN1YnNjcmliZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGdyb3VwaWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5ncm91cGlkID0gZ3JvdXBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfZm9ydW1fYWRkX2Rpc2N1c3Npb24nLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UgfHzCoCFyZXNwb25zZS5kaXNjdXNzaW9uaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kaXNjdXNzaW9uaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHVzZXIgY2FuIHBvc3QgdG8gYSBjZXJ0YWluIGdyb3VwLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNjYW5BZGREaXNjdXNzaW9uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmb3J1bWlkIEZvcnVtIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZ3JvdXBpZCBHcm91cCBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgYm9vbGVhbjogdHJ1ZSBpZiBjYW4gYWRkIGRpc2N1c3Npb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmNhbkFkZERpc2N1c3Npb24gPSBmdW5jdGlvbihmb3J1bWlkLCBncm91cGlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZm9ydW1pZDogZm9ydW1pZCxcbiAgICAgICAgICAgICAgICBncm91cGlkOiBncm91cGlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0Q2FuQWRkRGlzY3Vzc2lvbkNhY2hlS2V5KGZvcnVtaWQsIGdyb3VwaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9mb3J1bV9jYW5fYWRkX2Rpc2N1c3Npb24nLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhcmVzdWx0LnN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdXNlciBjYW4gcG9zdCB0byBhbGwgZ3JvdXBzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNjYW5BZGREaXNjdXNzaW9uVG9BbGxcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZvcnVtaWQgRm9ydW0gSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIGJvb2xlYW46IHRydWUgaWYgY2FuIGFkZCBkaXNjdXNzaW9uIHRvIGFsbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuY2FuQWRkRGlzY3Vzc2lvblRvQWxsID0gZnVuY3Rpb24oZm9ydW1pZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5jYW5BZGREaXNjdXNzaW9uKGZvcnVtaWQsIC0xKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgc3RhcnRpbmcgcG9zdCBvZiBhIGRpc2N1c3Npb24gZnJvbSBhIGxpc3Qgb2YgcG9zdHMuIFRoZSBwb3N0IGlzIHJlbW92ZWQgZnJvbSB0aGUgYXJyYXkgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNnZXRTdGFydGluZ1Bvc3RcbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gcG9zdHMgUG9zdHMgdG8gc2VhcmNoLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBTdGFydGluZyBwb3N0LlxuICAgICAqL1xuICAgIHNlbGYuZXh0cmFjdFN0YXJ0aW5nUG9zdCA9IGZ1bmN0aW9uKHBvc3RzKSB7XG4gICAgICAgIC8vIENoZWNrIHRoZSBsYXN0IHBvc3QgZmlyc3QsIHNpbmNlIHRoZXknbGwgdXN1YWxseSBiZSBvcmRlcmVkIGJ5IGNyZWF0ZSB0aW1lLlxuICAgICAgICB2YXIgbGFzdFBvc3QgPSBwb3N0c1twb3N0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RQb3N0LnBhcmVudCA9PSAwKSB7XG4gICAgICAgICAgICBwb3N0cy5wb3AoKTsgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIGFycmF5LlxuICAgICAgICAgICAgcmV0dXJuIGxhc3RQb3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGFzdCBwb3N0IHdhc24ndCB0aGUgc3RhcnRpbmcgb25lLiBMZXQncyBzZWFyY2ggYWxsIHRoZSBwb3N0cyB1bnRpbCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwb3N0c1tpXS5wYXJlbnQgPT0gMCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTsgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIGFycmF5LlxuICAgICAgICAgICAgICAgIHJldHVybiBwb3N0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNhbkFkZERpc2N1c3Npb24gaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNpc0NhbkFkZERpc2N1c3Npb25BdmFpbGFibGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNDYW5BZGREaXNjdXNzaW9uQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdtb2RfZm9ydW1fY2FuX2FkZF9kaXNjdXNzaW9uJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGlzIGVuYWJsZWQgaW4gYSBjZXJ0YWluIHNpdGUuIFBsdWdpbiBpcyBlbmFibGVkIGlmIHRoZSBmb3J1bSBXUyBhcmUgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2ZvcnVtX2dldF9mb3J1bXNfYnlfY291cnNlcycpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9mb3J1bV9nZXRfZm9ydW1fZGlzY3Vzc2lvbnNfcGFnaW5hdGVkJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2ZvcnVtX2dldF9mb3J1bV9kaXNjdXNzaW9uX3Bvc3RzJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgZGlzY3Vzc2lvbnMsIHNldHRpbmcgZ3JvdXBuYW1lIGlmIHRoZSBkaXNjdXNzaW9uIGdyb3VwIGlzIHZhbGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjbWlkICAgICAgICAgIEZvcnVtIGNtaWQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IGRpc2N1c3Npb25zIExpc3Qgb2YgZGlzY3Vzc2lvbnMgdG8gZm9ybWF0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGZvcm1hdHRlZCBkaXNjdXNzaW9ucy5cbiAgICAgKi9cbiAgICBzZWxmLmZvcm1hdERpc2N1c3Npb25zR3JvdXBzID0gZnVuY3Rpb24oY21pZCwgZGlzY3Vzc2lvbnMpIHtcbiAgICAgICAgZGlzY3Vzc2lvbnMgPSBhbmd1bGFyLmNvcHkoZGlzY3Vzc2lvbnMpO1xuICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZSgnbW0uY29yZS5hbGxwYXJ0aWNpcGFudHMnKS50aGVuKGZ1bmN0aW9uKHN0ckFsbFBhcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tR3JvdXBzLmdldEFjdGl2aXR5QWxsb3dlZEdyb3VwcyhjbWlkKS50aGVuKGZ1bmN0aW9uKGZvcnVtZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVybiBncm91cHMgaW50byBhbiBvYmplY3Qgd2hlcmUgZWFjaCBncm91cCBpcyBpZGVudGlmaWVkIGJ5IGlkLlxuICAgICAgICAgICAgICAgIHZhciBncm91cHMgPSB7fTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZm9ydW1ncm91cHMsIGZ1bmN0aW9uKGZnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tmZy5pZF0gPSBmZztcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBkaXNjdXNzaW9ucy5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZGlzY3Vzc2lvbnMsIGZ1bmN0aW9uKGRpc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2MuZ3JvdXBpZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2MuZ3JvdXBuYW1lID0gc3RyQWxsUGFydHM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbZGlzYy5ncm91cGlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2MuZ3JvdXBuYW1lID0gZ3JvdXAubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXNjdXNzaW9ucztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNjdXNzaW9ucztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGZvcnVtLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNnZXRGb3J1bVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNtaWQgICAgIENvdXJzZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZm9ydW0gaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Rm9ydW0gPSBmdW5jdGlvbihjb3Vyc2VpZCwgY21pZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkczogW2NvdXJzZWlkXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldEZvcnVtRGF0YUNhY2hlS2V5KGNvdXJzZWlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfZm9ydW1fZ2V0X2ZvcnVtc19ieV9jb3Vyc2VzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKGZvcnVtcykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRGb3J1bTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChmb3J1bXMsIGZ1bmN0aW9uKGZvcnVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcnVtLmNtaWQgPT0gY21pZCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rm9ydW0gPSBmb3J1bTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Rm9ydW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEZvcnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGZvcnVtIGRpc2N1c3Npb24gcG9zdHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2dldERpc2N1c3Npb25Qb3N0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXNjdXNzaW9uaWQgRGlzY3Vzc2lvbiBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBmb3J1bSBkaXNjdXNzaW9ucy5cbiAgICAgKi9cbiAgICBzZWxmLmdldERpc2N1c3Npb25Qb3N0cyA9IGZ1bmN0aW9uKGRpc2N1c3Npb25pZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRpc2N1c3Npb25pZDogZGlzY3Vzc2lvbmlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0RGlzY3Vzc2lvblBvc3RzQ2FjaGVLZXkoZGlzY3Vzc2lvbmlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfZm9ydW1fZ2V0X2ZvcnVtX2Rpc2N1c3Npb25fcG9zdHMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHN0b3JlVXNlckRhdGEocmVzcG9uc2UucG9zdHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5wb3N0cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGZvcnVtIGRpc2N1c3Npb25zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNnZXREaXNjdXNzaW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb3J1bWlkIEZvcnVtIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlICAgIFBhZ2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGZvcnVtIGRpc2N1c3Npb25zLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RGlzY3Vzc2lvbnMgPSBmdW5jdGlvbihmb3J1bWlkLCBwYWdlKSB7XG4gICAgICAgIHBhZ2UgPSBwYWdlIHx8IDA7XG5cbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBmb3J1bWlkOiBmb3J1bWlkLFxuICAgICAgICAgICAgICAgIHNvcnRieTogICd0aW1lbW9kaWZpZWQnLFxuICAgICAgICAgICAgICAgIHNvcnRkaXJlY3Rpb246ICAnREVTQycsXG4gICAgICAgICAgICAgICAgcGFnZTogcGFnZSxcbiAgICAgICAgICAgICAgICBwZXJwYWdlOiBtbWFNb2RGb3J1bURpc2NQZXJQYWdlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0RGlzY3Vzc2lvbnNMaXN0Q2FjaGVLZXkoZm9ydW1pZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX2ZvcnVtX2dldF9mb3J1bV9kaXNjdXNzaW9uc19wYWdpbmF0ZWQnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciBjYW5Mb2FkTW9yZSA9IHJlc3BvbnNlLmRpc2N1c3Npb25zLmxlbmd0aCA+PSBtbWFNb2RGb3J1bURpc2NQZXJQYWdlO1xuICAgICAgICAgICAgICAgIHN0b3JlVXNlckRhdGEocmVzcG9uc2UuZGlzY3Vzc2lvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7ZGlzY3Vzc2lvbnM6IHJlc3BvbnNlLmRpc2N1c3Npb25zLCBjYW5Mb2FkTW9yZTogY2FuTG9hZE1vcmV9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBjYW4gYWRkIGRpc2N1c3Npb24gV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2ludmFsaWRhdGVDYW5BZGREaXNjdXNzaW9uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmb3J1bWlkIEZvcnVtIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQ2FuQWRkRGlzY3Vzc2lvbiA9IGZ1bmN0aW9uKGZvcnVtaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXlTdGFydGluZ1dpdGgoZ2V0Q29tbW9uQ2FuQWRkRGlzY3Vzc2lvbkNhY2hlS2V5KGZvcnVtaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgZm9ydW0gZGlzY3Vzc2lvbiBwb3N0cy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb3J1bVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9ydW0jaW52YWxpZGF0ZURpc2N1c3Npb25Qb3N0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXNjdXNzaW9uaWQgRGlzY3Vzc2lvbiBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVEaXNjdXNzaW9uUG9zdHMgPSBmdW5jdGlvbihkaXNjdXNzaW9uaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0RGlzY3Vzc2lvblBvc3RzQ2FjaGVLZXkoZGlzY3Vzc2lvbmlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIGRpc2N1c3Npb24gbGlzdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb3J1bVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9ydW0jaW52YWxpZGF0ZURpc2N1c3Npb25zTGlzdFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZm9ydW1pZCBGb3J1bSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZURpc2N1c3Npb25zTGlzdCA9IGZ1bmN0aW9uKGZvcnVtaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0RGlzY3Vzc2lvbnNMaXN0Q2FjaGVLZXkoZm9ydW1pZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBmb3J1bSBkYXRhLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNpbnZhbGlkYXRlRm9ydW1EYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUZvcnVtRGF0YSA9IGZ1bmN0aW9uKGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldEZvcnVtRGF0YUNhY2hlS2V5KGNvdXJzZWlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBjdXJyZW50IHNpdGUgYWxsb3dzIGNyZWF0aW5nIG5ldyBkaXNjdXNzaW9ucy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb3J1bVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9ydW0jaXNDcmVhdGVEaXNjdXNzaW9uRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNDcmVhdGVEaXNjdXNzaW9uRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53c0F2YWlsYWJsZSgnY29yZV9ncm91cF9nZXRfYWN0aXZpdHlfZ3JvdXBtb2RlJykgJiZcbiAgICAgICAgICAgICAgICAkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX2dyb3VwX2dldF9hY3Rpdml0eV9hbGxvd2VkX2dyb3VwcycpICYmXG4gICAgICAgICAgICAgICAgJG1tU2l0ZS53c0F2YWlsYWJsZSgnbW9kX2ZvcnVtX2FkZF9kaXNjdXNzaW9uJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBjdXJyZW50IHNpdGUgYWxsb3dzIHJlcGx5aW5nIHRvIHBvc3RzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNpc1JlcGx5UG9zdEVuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUmVwbHlQb3N0RW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53c0F2YWlsYWJsZSgnbW9kX2ZvcnVtX2FkZF9kaXNjdXNzaW9uX3Bvc3QnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IGEgZm9ydW0gYXMgYmVpbmcgdmlld2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNsb2dWaWV3XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIE1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sb2dWaWV3ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGZvcnVtaWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9mb3J1bV92aWV3X2ZvcnVtJywgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcGx5IHRvIGEgY2VydGFpbiBwb3N0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNyZXBseVBvc3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zdGlkICBJRCBvZiB0aGUgcG9zdCBiZWluZyByZXBsaWVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdWJqZWN0IE5ldyBwb3N0J3Mgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBOZXcgcG9zdCdzIG1lc3NhZ2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBwb3N0IGlzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5yZXBseVBvc3QgPSBmdW5jdGlvbihwb3N0aWQsIHN1YmplY3QsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHBvc3RpZDogcG9zdGlkLFxuICAgICAgICAgICAgc3ViamVjdDogc3ViamVjdCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2ZvcnVtX2FkZF9kaXNjdXNzaW9uX3Bvc3QnLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UgfHzCoCFyZXNwb25zZS5wb3N0aWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5wb3N0aWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSB0aGUgdXNlcnMgZGF0YSBmcm9tIGEgZGlzY3Vzc2lvbnMvcG9zdHMgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGxpc3QgQXJyYXkgb2YgcG9zdHMgb3IgZGlzY3Vzc2lvbnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmVVc2VyRGF0YShsaXN0KSB7XG4gICAgICAgIHZhciBpZHMgPSBbXTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGxpc3QsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBwYXJzZUludChlbnRyeS51c2VyaWQpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihpZCkgJiYgaWRzLmluZGV4T2YoaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICAkbW1Vc2VyLnN0b3JlVXNlcihpZCwgZW50cnkudXNlcmZ1bGxuYW1lLCBlbnRyeS51c2VycGljdHVyZXVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5LnVzZXJtb2RpZmllZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGlkID0gcGFyc2VJbnQoZW50cnkudXNlcm1vZGlmaWVkKTtcbiAgICAgICAgICAgICAgICBpZighaXNOYU4oaWQpICYmIGlkcy5pbmRleE9mKGlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICAkbW1Vc2VyLnN0b3JlVXNlcihpZCwgZW50cnkudXNlcm1vZGlmaWVkZnVsbG5hbWUsIGVudHJ5LnVzZXJtb2RpZmllZHBpY3R1cmV1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9mb3J1bScpXG5cbi8qKlxuICogTW9kIGZvcnVtIGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb3J1bVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RGb3J1bUhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kRm9ydW1IYW5kbGVycycsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tYU1vZEZvcnVtLCAkc3RhdGUsICRtbVV0aWwsICRtbUNvbnRlbnRMaW5rc0hlbHBlciwgJHEpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb3J1bVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9ydW1IYW5kbGVycyNjb3Vyc2VDb250ZW50XG4gICAgICovXG4gICAgc2VsZi5jb3Vyc2VDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb3J1bVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bUNvdXJzZUNvbnRlbnRIYW5kbGVyI2lzRW5hYmxlZFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kRm9ydW0uaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tYU1vZEZvcnVtQ291cnNlQ29udGVudEhhbmRsZXIjaXNFbmFibGVkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBpbmZvLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYygnZm9ydW0nKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW9kX2ZvcnVtJywge21vZHVsZTogbW9kdWxlLCBjb3Vyc2VpZDogY291cnNlaWR9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bUhhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICBTaXRlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc0luZGV4RW5hYmxlZChzaXRlSWQsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEZvcnVtLmlzUGx1Z2luRW5hYmxlZChzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb3Vyc2VJZCB8fCAkbW1Db3Vyc2UuY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkKHNpdGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgU2l0ZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRGlzY0VuYWJsZWQoc2l0ZUlkKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBjaGVjayBjb3Vyc2VJZCBiZWNhdXNlIGl0J3Mgb25seSBuZWVkZWQgZm9yIHVzZXIgcHJvZmlsZSBsaW5rcywgd2UgY2FuIGFmZm9yZCBub3QgcGFzc2luZyBpdC5cbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kRm9ydW0uaXNQbHVnaW5FbmFibGVkKHNpdGVJZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgZm9ydW0gVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL2ZvcnVtL3ZpZXcucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIEZvcnVtIGluZGV4LlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIudHJlYXRNb2R1bGVJbmRleFVybChzaXRlSWRzLCB1cmwsIGlzSW5kZXhFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC5pbmRleE9mKCcvbW9kL2ZvcnVtL2Rpc2N1c3MucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIEZvcnVtIGRpc2N1c3Npb24uXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9ICRtbVV0aWwuZXh0cmFjdFVybFBhcmFtcyh1cmwpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIGZhbHNlIGJlY2F1c2UgYWxsIHNpdGVzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNpdGV1cmwuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIuZmlsdGVyU3VwcG9ydGVkU2l0ZXMoc2l0ZUlkcywgaXNEaXNjRW5hYmxlZCwgZmFsc2UsIGNvdXJzZUlkKS50aGVuKGZ1bmN0aW9uKGlkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ21tLmNvcmUudmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tZXllJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZXM6IGlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uaWQ6IHBhcnNlSW50KHBhcmFtcy5kLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lkOiBjb3Vyc2VJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUNvbnRlbnRMaW5rc0hlbHBlci5nb0luU2l0ZSgnc2l0ZS5tb2RfZm9ydW0tZGlzY3Vzc2lvbicsIHN0YXRlUGFyYW1zLCBzaXRlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9pbXNjcCcpXG5cbi8qKlxuICogSU1TQ1AgaW5kZXggY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RJbXNjcEluZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kSW1zY3BJbmRleEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tVXRpbCwgJG1tYU1vZEltc2NwLCAkbG9nLCBtbWFNb2RJbXNjcENvbXBvbmVudCxcbiAgICAgICAgICAgICRpb25pY1BvcG92ZXIsICR0aW1lb3V0LCAkcSwgJG1tQ291cnNlLCAkbW1BcHApIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1hTW9kSW1zY3BJbmRleEN0cmwnKTtcblxuICAgIHZhciBtb2R1bGUgPSAkc3RhdGVQYXJhbXMubW9kdWxlIHx8IHt9LFxuICAgICAgICBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZCxcbiAgICAgICAgY3VycmVudEl0ZW07XG5cbiAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBtb2R1bGUuZGVzY3JpcHRpb247XG4gICAgJHNjb3BlLmNvbXBvbmVudCA9IG1tYU1vZEltc2NwQ29tcG9uZW50O1xuICAgICRzY29wZS5jb21wb25lbnRJZCA9IG1vZHVsZS5pZDtcbiAgICAkc2NvcGUuZXh0ZXJuYWxVcmwgPSBtb2R1bGUudXJsO1xuICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcblxuICAgIC8vIEluaXRpYWxpemUgZW1wdHkgcHJldmlvdXMvbmV4dCB0byBwcmV2ZW50IHNob3dpbmcgYXJyb3dzIGZvciBhbiBpbnN0YW50IGJlZm9yZSB0aGV5J3JlIGhpZGRlbi5cbiAgICAkc2NvcGUucHJldmlvdXNJdGVtID0gJyc7XG4gICAgJHNjb3BlLm5leHRJdGVtID0gJyc7XG5cbiAgICAkc2NvcGUuaXRlbXMgPSAkbW1hTW9kSW1zY3AuY3JlYXRlSXRlbUxpc3QobW9kdWxlLmNvbnRlbnRzKTtcbiAgICBpZiAoJHNjb3BlLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICBjdXJyZW50SXRlbSA9ICRzY29wZS5pdGVtc1swXS5ocmVmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRJdGVtKGl0ZW1JZCkge1xuICAgICAgICBjdXJyZW50SXRlbSA9IGl0ZW1JZDtcbiAgICAgICAgJHNjb3BlLnByZXZpb3VzSXRlbSA9ICRtbWFNb2RJbXNjcC5nZXRQcmV2aW91c0l0ZW0oJHNjb3BlLml0ZW1zLCBpdGVtSWQpO1xuICAgICAgICAkc2NvcGUubmV4dEl0ZW0gPSAkbW1hTW9kSW1zY3AuZ2V0TmV4dEl0ZW0oJHNjb3BlLml0ZW1zLCBpdGVtSWQpO1xuICAgICAgICB2YXIgc3JjID0gJG1tYU1vZEltc2NwLmdldEZpbGVTcmMobW9kdWxlLCBpdGVtSWQpO1xuICAgICAgICBpZiAoJHNjb3BlLnNyYyAmJiBzcmMudG9TdHJpbmcoKSA9PSAkc2NvcGUuc3JjLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIC8vIFJlLWxvYWRpbmcgc2FtZSBwYWdlLiBTZXQgaXQgdG8gZW1wdHkgYW5kIHRoZW4gcmUtc2V0IHRoZSBzcmMgaW4gdGhlIG5leHQgZGlnZXN0IHNvIGl0IGRldGVjdHMgaXQgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAkc2NvcGUuc3JjID0gJyc7XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3JjID0gc3JjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUuc3JjID0gc3JjO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmV0Y2hDb250ZW50KCkge1xuICAgICAgICBpZiAobW9kdWxlLmNvbnRlbnRzICYmIG1vZHVsZS5jb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBkb3dubG9hZEZhaWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RJbXNjcC5kb3dubG9hZEFsbENvbnRlbnQobW9kdWxlKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGRvd25sb2FkIGFzIGZhaWxlZCBidXQgZ28gb24gc2luY2UgdGhlIG1haW4gZmlsZXMgY291bGQgaGF2ZSBiZWVuIGRvd25sb2FkZWQuXG4gICAgICAgICAgICAgICAgZG93bmxvYWRGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZEltc2NwLmdldElmcmFtZVNyYyhtb2R1bGUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRJdGVtKGN1cnJlbnRJdGVtKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRGYWlsZWQgJiYgJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIGxvYWQgdGhlIG1haW4gZmlsZSBidXQgdGhlIGRvd25sb2FkIGZhaWxlZC4gU2hvdyBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nc29tZWZpbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9pbXNjcC5kZXBsb3ltZW50ZXJyb3InLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2ltc2NwLmRlcGxveW1lbnRlcnJvcicsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJHNjb3BlLmRvUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTW9kSW1zY3AuaW52YWxpZGF0ZUNvbnRlbnQobW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoQ29udGVudCgpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5sb2FkSXRlbSA9IGZ1bmN0aW9uKGl0ZW1JZCkge1xuICAgICAgICAkc2NvcGUucG9wb3Zlci5oaWRlKCk7XG4gICAgICAgIGxvYWRJdGVtKGl0ZW1JZCk7XG4gICAgfTtcblxuICAgICRzY29wZS5nZXROdW1iZXJGb3JQYWRkaW5nID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5KG4pO1xuICAgIH07XG5cbiAgICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgnYWRkb25zL21vZF9pbXNjcC90ZW1wbGF0ZXMvdG9jLmh0bWwnLCB7XG4gICAgICAgIHNjb3BlOiAkc2NvcGUsXG4gICAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgICAgICRzY29wZS5wb3BvdmVyID0gcG9wb3ZlcjtcbiAgICB9KTtcblxuICAgIGZldGNoQ29udGVudCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNb2RJbXNjcC5sb2dWaWV3KG1vZHVsZS5pbnN0YW5jZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbUNvdXJzZS5jaGVja01vZHVsZUNvbXBsZXRpb24oY291cnNlaWQsIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9pbXNjcCcpXG5cbi8qKlxuICogTW9kIElNU0NQIGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RJbXNjcEhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kSW1zY3BIYW5kbGVycycsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tYU1vZEltc2NwLCAkbW1FdmVudHMsICRzdGF0ZSwgJG1tU2l0ZSwgJG1tVXRpbCwgJG1tRmlsZXBvb2wsXG4gICAgICAgICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLCBtbUNvcmVEb3dubG9hZGluZywgbW1Db3JlTm90RG93bmxvYWRlZCwgbW1Db3JlT3V0ZGF0ZWQsIG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsXG4gICAgICAgICAgICBtbWFNb2RJbXNjcENvbXBvbmVudCwgJG1tQ29udGVudExpbmtzSGVscGVyLCAkcSkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcEhhbmRsZXJzI2NvdXJzZUNvbnRlbnRcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3BDb3Vyc2VDb250ZW50SGFuZGxlciNpc0VuYWJsZWRcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEltc2NwLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcENvdXJzZUNvbnRlbnRIYW5kbGVyI2dldENvbnRyb2xsZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSAgIFRoZSBtb2R1bGUgaW5mby5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIFRoZSBjb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgIHZhciBkb3dubG9hZEJ0bixcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEJ0bixcbiAgICAgICAgICAgICAgICAgICAgcmV2aXNpb24gPSAkbW1GaWxlcG9vbC5nZXRSZXZpc2lvbkZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpLFxuICAgICAgICAgICAgICAgICAgICB0aW1lbW9kaWZpZWQgPSAkbW1GaWxlcG9vbC5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKTtcblxuICAgICAgICAgICAgICAgIGRvd25sb2FkQnRuID0ge1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGljb246ICdpb24taW9zLWNsb3VkLWRvd25sb2FkLW91dGxpbmUnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ21tLmNvcmUuZG93bmxvYWQnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kSW1zY3AucHJlZmV0Y2hDb250ZW50KG1vZHVsZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRkZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1hbmRyb2lkLXJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ21tLmNvcmUucmVmcmVzaCcsXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZEltc2NwLmludmFsaWRhdGVDb250ZW50KG1vZHVsZS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kSW1zY3AucHJlZmV0Y2hDb250ZW50KG1vZHVsZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3JlLmVycm9yZG93bmxvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYygnaW1zY3AnKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYnV0dG9ucyA9IFtkb3dubG9hZEJ0biwgcmVmcmVzaEJ0bl07XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2RfaW1zY3AnLCB7bW9kdWxlOiBtb2R1bGUsIGNvdXJzZWlkOiBjb3Vyc2VpZH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBTaG93IGJ1dHRvbnMgYWNjb3JkaW5nIHRvIG1vZHVsZSBzdGF0dXMuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2hvd1N0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBzdGF0dXMgPT09IG1tQ29yZURvd25sb2FkaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRCdG4uaGlkZGVuID0gc3RhdHVzICE9PSBtbUNvcmVOb3REb3dubG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEJ0bi5oaWRkZW4gPSBzdGF0dXMgIT09IG1tQ29yZU91dGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoaXMgbW9kdWxlIHN0YXR1cy5cbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzT2JzZXJ2ZXIgPSAkbW1FdmVudHMub24obW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zaXRlaWQgPT09ICRtbVNpdGUuZ2V0SWQoKSAmJiBkYXRhLmNvbXBvbmVudElkID09PSBtb2R1bGUuaWQgJiYgZGF0YS5jb21wb25lbnQgPT09IG1tYU1vZEltc2NwQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93U3RhdHVzKGRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgc3RhdHVzIHRvIGRlY2lkZSB3aGljaCBpY29uIHNob3VsZCBiZSBzaG93bi5cbiAgICAgICAgICAgICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLmdldE1vZHVsZVN0YXR1cyhtb2R1bGUsIGNvdXJzZWlkLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKS50aGVuKHNob3dTdGF0dXMpO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzT2JzZXJ2ZXIgJiYgc3RhdHVzT2JzZXJ2ZXIub2ZmICYmIHN0YXR1c09ic2VydmVyLm9mZigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcEhhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICBTaXRlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoc2l0ZUlkLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RJbXNjcC5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlSWQgfHwgJG1tQ291cnNlLmNhbkdldE1vZHVsZVdpdGhvdXRDb3Vyc2VJZChzaXRlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGFuIElNU0NQIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignL21vZC9pbXNjcC92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9pbXNjcCcpXG5cbi8qKlxuICogSU1TQ1AgZmFjdG9yeS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kSW1zY3BcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RJbXNjcCcsIGZ1bmN0aW9uKCRtbUZpbGVwb29sLCAkbW1TaXRlLCAkbW1GUywgJGxvZywgJHEsICRzY2UsICRtbUFwcCwgJG1tU2l0ZXNNYW5hZ2VyLCBtbWFNb2RJbXNjcENvbXBvbmVudCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hTW9kSW1zY3AnKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGN1cnJlbnREaXJQYXRoOyAvLyBEaXJlY3RvcnkgcGF0aCBvZiB0aGUgY3VycmVudCBJTVNDUC5cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSU1TQ1AgdG9jIGFzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNnZXRUb2NcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gY29udGVudHMgVGhlIG1vZHVsZSBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgVGhlIHRvYy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5nZXRUb2MgPSBmdW5jdGlvbihjb250ZW50cykge1xuICAgICAgICBpZiAoIWNvbnRlbnRzIHx8ICFjb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50c1swXS5jb250ZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbXNjcCB0b2MgYXMgYW4gYXJyYXkgb2YgaXRlbXMgKG5vIG5lc3RlZCkgdG8gYnVpbGQgdGhlIG5hdmlnYXRpb24gdHJlZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3AjY3JlYXRlSXRlbUxpc3RcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gY29udGVudHMgVGhlIG1vZHVsZSBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgVGhlIHRvYyBhcyBhIGxpc3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuY3JlYXRlSXRlbUxpc3QgPSBmdW5jdGlvbihjb250ZW50cykge1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIHRvYyA9IHNlbGYuZ2V0VG9jKGNvbnRlbnRzKTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHRvYywgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe2hyZWY6IGVsLmhyZWYsIHRpdGxlOiBlbC50aXRsZSwgbGV2ZWw6IGVsLmxldmVsfSk7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZWwuc3ViaXRlbXMsIGZ1bmN0aW9uKHNlbCkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe2hyZWY6IHNlbC5ocmVmLCB0aXRsZTogc2VsLnRpdGxlLCBsZXZlbDogc2VsLmxldmVsfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwcmV2aW91cyBpdGVtIHRvIHRoZSBnaXZlbiBvbmUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwI2dldFByZXZpb3VzSXRlbVxuICAgICAqIEBwYXJhbSAge2FycmF5fSBpdGVtcyAgICAgVGhlIGl0ZW1zIGxpc3QuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBpdGVtSWQgICBUaGUgY3VycmVudCBpdGVtLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgVGhlIHByZXZpb3VzIGl0ZW0gaWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuZ2V0UHJldmlvdXNJdGVtID0gZnVuY3Rpb24oaXRlbXMsIGl0ZW1JZCkge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSAnJztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpdGVtc1tpXS5ocmVmID09IGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBpdGVtc1tpXS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgaXRlbSB0byB0aGUgZ2l2ZW4gb25lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNnZXROZXh0SXRlbVxuICAgICAqIEBwYXJhbSAge2FycmF5fSBpdGVtcyAgICAgVGhlIGl0ZW1zIGxpc3QuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBpdGVtSWQgICBUaGUgY3VycmVudCBpdGVtLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBuZXh0IGl0ZW0gaWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuZ2V0TmV4dEl0ZW0gPSBmdW5jdGlvbihpdGVtcywgaXRlbUlkKSB7XG4gICAgICAgIHZhciBuZXh0ID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXNbaV0uaHJlZiA9PSBpdGVtSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1zW2kgKyAxXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gaXRlbXNbaSArIDFdLmhyZWY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB3ZSBzaG91bGQgb21taXQgdGhlIGZpbGUgZG93bmxvYWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwI2NoZWNrU3BlY2lhbEZpbGVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVOYW1lIFRoZSBmaWxlIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgVHJ1ZSBpZiB3ZSBzaG91bGQgb21taXQgdGhlIGZpbGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5jaGVja1NwZWNpYWxGaWxlcyA9IGZ1bmN0aW9uKGZpbGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBmaWxlTmFtZSA9PSAnaW1zbWFuaWZlc3QueG1sJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgYWxsIHRoZSBjb250ZW50LiBBbGwgdGhlIGZpbGVzIGFyZSBkb3dubG9hZGVkIGluc2lkZSBhIGZvbGRlciBpbiBmaWxlcG9vbCwga2VlcGluZyB0aGVpciBmb2xkZXIgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNkb3dubG9hZEFsbENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGNvbnRlbnQgaXMgZG93bmxvYWRlZC4gRGF0YSByZXR1cm5lZCBpcyBub3QgcmVsaWFibGUuXG4gICAgICovXG4gICAgc2VsZi5kb3dubG9hZEFsbENvbnRlbnQgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyhtb2R1bGUpLFxuICAgICAgICAgICAgcmV2aXNpb24gPSAkbW1GaWxlcG9vbC5nZXRSZXZpc2lvbkZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpLFxuICAgICAgICAgICAgdGltZW1vZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuXG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXRGaWxlUGF0aEJ5VXJsKCRtbVNpdGUuZ2V0SWQoKSwgbW9kdWxlLnVybCkudGhlbihmdW5jdGlvbihkaXJQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZG93bmxvYWRQYWNrYWdlKCRtbVNpdGUuZ2V0SWQoKSwgZmlsZXMsIG1tYU1vZEltc2NwQ29tcG9uZW50LCBtb2R1bGUuaWQsIHJldmlzaW9uLCB0aW1lbW9kLCBkaXJQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGZpbGVzIHRoYXQgY2FuIGJlIGRvd25sb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwI2dldERvd25sb2FkYWJsZUZpbGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gICAgIExpc3Qgb2YgZmlsZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBbXTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBldmVudCBuYW1lcyBvZiBmaWxlcyBiZWluZyBkb3dubG9hZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNnZXREb3dubG9hZGluZ0ZpbGVzRXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkaW5nRmlsZXNFdmVudE5hbWVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgZXZlbnROYW1lcyA9IFtdLFxuICAgICAgICAgICAgc2l0ZWlkID0gJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBjb250ZW50LmZpbGV1cmw7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GaWxlcG9vbC5pc0ZpbGVEb3dubG9hZGluZ0J5VXJsKHNpdGVpZCwgdXJsKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXRGaWxlRXZlbnROYW1lQnlVcmwoc2l0ZWlkLCB1cmwpLnRoZW4oZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZXMucHVzaChldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGZhaWxzLlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlIGV2ZW50IG5hbWVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNnZXRGaWxlRXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIGFycmF5IG9mICRtbUV2ZW50IG5hbWVzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZUV2ZW50TmFtZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBjb250ZW50LmZpbGV1cmw7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbUZpbGVwb29sLmdldEZpbGVFdmVudE5hbWVCeVVybCgkbW1TaXRlLmdldElkKCksIHVybCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihldmVudE5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnROYW1lcztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgZmlsZXBhdGgsIGdldCBhIGNlcnRhaW4gZmlsZXVybCBmcm9tIG1vZHVsZSBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbnRlbnRzICAgICBNb2R1bGUgY29udGVudHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldEZpbGVwYXRoIEZpbGVwYXRoIG9mIHRoZSBzZWFyY2hlZCBmaWxlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgICBGaWxldXJsLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRGaWxlVXJsRnJvbUNvbnRlbnRzID0gZnVuY3Rpb24oY29udGVudHMsIHRhcmdldEZpbGVwYXRoKSB7XG4gICAgICAgIHZhciBpbmRleFVybDtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09ICdmaWxlJyAmJiAhaW5kZXhVcmwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXBhdGggPSAkbW1GUy5jb25jYXRlbmF0ZVBhdGhzKGNvbnRlbnQuZmlsZXBhdGgsIGNvbnRlbnQuZmlsZW5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBmaWxlcGF0aGFsdCA9IGZpbGVwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gZmlsZXBhdGguc3Vic3RyKDEpIDogJy8nICsgZmlsZXBhdGg7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBtYWluIGZpbGUuXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVwYXRoID09PSB0YXJnZXRGaWxlcGF0aCB8fCBmaWxlcGF0aGFsdCA9PT0gdGFyZ2V0RmlsZXBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhVcmwgPSBjb250ZW50LmZpbGV1cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGluZGV4VXJsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbGwgdGhlIGZpbGVzIG5lZWRlZCBhbmQgcmV0dXJucyB0aGUgc3JjIG9mIHRoZSBpZnJhbWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwI2dldElmcmFtZVNyY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGlmcmFtZSBzcmMuXG4gICAgICovXG4gICAgc2VsZi5nZXRJZnJhbWVTcmMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIHRvYyA9IHNlbGYuZ2V0VG9jKG1vZHVsZS5jb250ZW50cyksXG4gICAgICAgICAgICBtYWluRmlsZVBhdGg7XG4gICAgICAgIGlmICghdG9jLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIG1haW5GaWxlUGF0aCA9IHRvY1swXS5ocmVmO1xuXG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXREaXJlY3RvcnlVcmxCeVVybCgkbW1TaXRlLmdldElkKCksIG1vZHVsZS51cmwpLnRoZW4oZnVuY3Rpb24oZGlyUGF0aCkge1xuICAgICAgICAgICAgY3VycmVudERpclBhdGggPSBkaXJQYXRoO1xuICAgICAgICAgICAgLy8gVGhpcyBVUkwgaXMgZ29pbmcgdG8gYmUgaW5qZWN0ZWQgaW4gYW4gaWZyYW1lLCB3ZSBuZWVkIHRydXN0QXNSZXNvdXJjZVVybCB0byBtYWtlIGl0IHdvcmsgaW4gYSBicm93c2VyLlxuICAgICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKCRtbUZTLmNvbmNhdGVuYXRlUGF0aHMoZGlyUGF0aCwgbWFpbkZpbGVQYXRoKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gRXJyb3IgZ2V0dGluZyBkaXJlY3RvcnksIHRoZXJlIHdhcyBhbiBlcnJvciBkb3dubG9hZGluZyBvciB3ZSdyZSBpbiBicm93c2VyLiBSZXR1cm4gb25saW5lIFVSTCBpZiBjb25uZWN0ZWQuXG4gICAgICAgICAgICBpZiAoJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhVcmwgPSBzZWxmLl9nZXRGaWxlVXJsRnJvbUNvbnRlbnRzKG1vZHVsZS5jb250ZW50cywgbWFpbkZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBVUkwgaXMgZ29pbmcgdG8gYmUgaW5qZWN0ZWQgaW4gYW4gaWZyYW1lLCB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBpdCB3b3JrLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzUmVzb3VyY2VVcmwoJG1tU2l0ZS5maXhQbHVnaW5maWxlVVJMKGluZGV4VXJsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHNyYyBvZiBhIGltc2NwIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwI2dldEZpbGVTcmNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlICAgIFRoZSBtb2R1bGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWQgICAgSXRlbSB0byBnZXQgdGhlIHNyYy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIEl0ZW0gc3JjLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZVNyYyA9IGZ1bmN0aW9uKG1vZHVsZSwgaXRlbUlkKSB7XG4gICAgICAgIGlmIChjdXJyZW50RGlyUGF0aCkge1xuICAgICAgICAgICAgLy8gSU1TQ1Agc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgVVJMIGlzIGdvaW5nIHRvIGJlIGluamVjdGVkIGluIGFuIGlmcmFtZSwgd2UgbmVlZCB0cnVzdEFzUmVzb3VyY2VVcmwgdG8gbWFrZSBpdCB3b3JrIGluIGEgYnJvd3Nlci5cbiAgICAgICAgICAgIHJldHVybiAkc2NlLnRydXN0QXNSZXNvdXJjZVVybCgkbW1GUy5jb25jYXRlbmF0ZVBhdGhzKGN1cnJlbnREaXJQYXRoLCBpdGVtSWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVycm9yIGxvYWRpbmcgSU1TQ1AuIExldCdzIGdldCBvbmxpbmUgVVJMLlxuICAgICAgICAgICAgaWYgKCRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4VXJsID0gc2VsZi5fZ2V0RmlsZVVybEZyb21Db250ZW50cyhtb2R1bGUuY29udGVudHMsIGl0ZW1JZCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgVVJMIGlzIGdvaW5nIHRvIGJlIGluamVjdGVkIGluIGFuIGlmcmFtZSwgd2UgbmVlZCB0aGlzIHRvIG1ha2UgaXQgd29yay5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKCRtbVNpdGUuZml4UGx1Z2luZmlsZVVSTChpbmRleFVybCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIHRoZSBwcmVmZXRjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwI2ludmFsaWRhdGVDb250ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vZHVsZUlkIFRoZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmludmFsaWRhdGVGaWxlc0J5Q29tcG9uZW50KCRtbVNpdGUuZ2V0SWQoKSwgbW1hTW9kSW1zY3BDb21wb25lbnQsIG1vZHVsZUlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBmaWxlIGlzIGRvd25sb2FkYWJsZS4gVGhlIGZpbGUgcGFyYW0gbXVzdCBoYXZlICd0eXBlJyBhbmQgJ2ZpbGVuYW1lJyBhdHRyaWJ1dGVzXG4gICAgICogbGlrZSBpbiBjb3JlX2NvdXJzZV9nZXRfY29udGVudHMgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwI2lzRmlsZURvd25sb2FkYWJsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlIEZpbGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgVHJ1ZSBpZiBkb3dubG9hZGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzRmlsZURvd25sb2FkYWJsZSA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGUudHlwZSA9PT0gJ2ZpbGUnICYmICFzZWxmLmNoZWNrU3BlY2lhbEZpbGVzKGZpbGUuZmlsZW5hbWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBpcyBlbmFibGVkIGluIGEgY2VydGFpbiBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gc2l0ZS5nZXRJbmZvKCkudmVyc2lvbjtcbiAgICAgICAgICAgIC8vIFJlcXVpcmUgTW9vZGxlIDIuOS5cbiAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uICYmIChwYXJzZUludCh2ZXJzaW9uKSA+PSAyMDE1MDUxMTAwKSAmJiBzaXRlLmNhbkRvd25sb2FkRmlsZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCBhIElNU0NQIGFzIGJlaW5nIHZpZXdlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3AjbG9nVmlld1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBNb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgY2FsbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHNlbGYubG9nVmlldyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBpbXNjcGlkOiBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfaW1zY3Bfdmlld19pbXNjcCcsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCB0aGUgY29udGVudC4gQWxsIHRoZSBmaWxlcyBhcmUgZG93bmxvYWRlZCBpbnNpZGUgYSBmb2xkZXIgaW4gZmlsZXBvb2wsIGtlZXBpbmcgdGhlaXIgZm9sZGVyIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3AjcHJlZmV0Y2hDb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBjb250ZW50IGlzIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYucHJlZmV0Y2hDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMobW9kdWxlKSxcbiAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgIHRpbWVtb2QgPSAkbW1GaWxlcG9vbC5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKTtcblxuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZ2V0RmlsZVBhdGhCeVVybCgkbW1TaXRlLmdldElkKCksIG1vZHVsZS51cmwpLnRoZW4oZnVuY3Rpb24oZGlyUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLnByZWZldGNoUGFja2FnZSgkbW1TaXRlLmdldElkKCksIGZpbGVzLCBtbWFNb2RJbXNjcENvbXBvbmVudCwgbW9kdWxlLmlkLCByZXZpc2lvbiwgdGltZW1vZCwgZGlyUGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2ltc2NwJylcblxuLyoqXG4gKiBNb2QgaW1zY3AgcHJlZmV0Y2ggaGFuZGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kSW1zY3BQcmVmZXRjaEhhbmRsZXJcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RJbXNjcFByZWZldGNoSGFuZGxlcicsIGZ1bmN0aW9uKCRtbWFNb2RJbXNjcCwgbW1hTW9kSW1zY3BDb21wb25lbnQpIHtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICBzZWxmLmNvbXBvbmVudCA9IG1tYU1vZEltc2NwQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkb3dubG9hZCBzaXplIG9mIGEgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcFByZWZldGNoSGFuZGxlciNnZXREb3dubG9hZFNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIE1vZHVsZSB0byBnZXQgdGhlIHNpemUuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICBTaXplLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RG93bmxvYWRTaXplID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBzaXplID0gMDtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZHVsZS5jb250ZW50cywgZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgaWYgKCRtbWFNb2RJbXNjcC5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkgJiYgY29udGVudC5maWxlc2l6ZSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBzaXplICsgY29udGVudC5maWxlc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcFByZWZldGNoSGFuZGxlciNpc0VuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kSW1zY3AuaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIHRoZSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwUHJlZmV0Y2hIYW5kbGVyI3ByZWZldGNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgZmlsZXMgaGF2ZSBiZWVuIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYucHJlZmV0Y2ggPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RJbXNjcC5wcmVmZXRjaENvbnRlbnQobW9kdWxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2UnKVxuXG4vKipcbiAqIExhYmVsIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2xhYmVsXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kTGFiZWxJbmRleEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZExhYmVsSW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRsb2cpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1hTW9kTGFiZWxJbmRleEN0cmwnKTtcbiAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSAkc3RhdGVQYXJhbXMuZGVzY3JpcHRpb247XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9sYWJlbCcpXG5cbi8qKlxuICogTW9kIGxhYmVsIGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sYWJlbFxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RMYWJlbEhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kTGFiZWxIYW5kbGVycycsIGZ1bmN0aW9uKCRtbVRleHQsICR0cmFuc2xhdGUsICRzdGF0ZSwgJG1tQ29udGVudExpbmtzSGVscGVyLCAkcSwgJG1tQ291cnNlKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvdXJzZSBjb250ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbGFiZWxcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZExhYmVsSGFuZGxlcnMjY291cnNlQ29udGVudFxuICAgICAqL1xuICAgIHNlbGYuY291cnNlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gJG1tVGV4dC5zaG9ydGVuVGV4dCgkbW1UZXh0LmNsZWFuVGFncyhtb2R1bGUuZGVzY3JpcHRpb24pLnRyaW0oKSwgMTI4KTtcbiAgICAgICAgICAgICAgICBpZiAodGl0bGUubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgJHRyYW5zbGF0ZSgnbW1hLm1vZF9sYWJlbC50YXB0b3ZpZXcnKS50aGVuKGZ1bmN0aW9uKHRhcHRvdmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJzxzcGFuIGNsYXNzPVwibW1hLW1vZF9sYWJlbC1lbXB0eVwiPicgKyB0YXB0b3ZpZXcgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IHRpdGxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1vZF9sYWJlbCcsIHtkZXNjcmlwdGlvbjogbW9kdWxlLmRlc2NyaXB0aW9ufSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sYWJlbFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kTGFiZWxIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIGlmIChjb3Vyc2VJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSBsYWJlbCBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy9tb2QvbGFiZWwvdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfbHRpJylcblxuLyoqXG4gKiBMVEkgaW5kZXggY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbHRpXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kTHRpSW5kZXhDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RMdGlJbmRleEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tYU1vZEx0aSwgJG1tVXRpbCwgJHEsICRtbUNvdXJzZSkge1xuICAgIHZhciBtb2R1bGUgPSAkc3RhdGVQYXJhbXMubW9kdWxlIHx8IHt9LFxuICAgICAgICBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZCxcbiAgICAgICAgbHRpO1xuXG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbW9kdWxlLmRlc2NyaXB0aW9uO1xuICAgICRzY29wZS5jb3Vyc2VpZCA9IGNvdXJzZWlkO1xuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IExUSSBkYXRhLlxuICAgIGZ1bmN0aW9uIGZldGNoTFRJKHJlZnJlc2gpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RMdGkuZ2V0THRpKGNvdXJzZWlkLCBtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24obHRpZGF0YSkge1xuICAgICAgICAgICAgbHRpID0gbHRpZGF0YTtcblxuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RMdGkuZ2V0THRpTGF1bmNoRGF0YShsdGkuaWQpLnRoZW4oZnVuY3Rpb24obGF1bmNoZGF0YSkge1xuICAgICAgICAgICAgICAgIGx0aS5sYXVuY2hkYXRhID0gbGF1bmNoZGF0YTtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBsdGkubmFtZSB8fCAkc2NvcGUudGl0bGU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbHRpLmludHJvIHx8wqAkc2NvcGUuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgJHNjb3BlLmlzVmFsaWRVcmwgPSAkbW1VdGlsLmlzVmFsaWRVUkwobGF1bmNoZGF0YS5lbmRwb2ludCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKCFyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZSBjYWxsIGZhaWxlZCwgcmV0cnkgd2l0aG91dCB1c2luZyBjYWNoZSBzaW5jZSBpdCBtaWdodCBiZSBhIG5ldyBhY3Rpdml0eS5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmcmVzaEFsbERhdGEoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2x0aS5lcnJvcmdldGx0aScsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byByZWZyZXNoIGFsbCB0aGUgZGF0YS5cbiAgICBmdW5jdGlvbiByZWZyZXNoQWxsRGF0YSgpIHtcbiAgICAgICAgdmFyIHAxID0gJG1tYU1vZEx0aS5pbnZhbGlkYXRlTHRpKGNvdXJzZWlkKSxcbiAgICAgICAgICAgIHAyID0gbHRpID8gJG1tYU1vZEx0aS5pbnZhbGlkYXRlTHRpTGF1bmNoRGF0YShsdGkuaWQpIDogJHEud2hlbigpO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwoW3AxLCBwMl0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hMVEkodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZldGNoTFRJKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmx0aUxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBQdWxsIHRvIHJlZnJlc2guXG4gICAgJHNjb3BlLmRvUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWZyZXNoQWxsRGF0YSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gTGF1bmNoIHRoZSBMVEkuXG4gICAgJHNjb3BlLmxhdW5jaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBcIlZpZXdcIiBMVEkuXG4gICAgICAgICRtbWFNb2RMdGkubG9nVmlldyhsdGkuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExhdW5jaCBMVEkuXG4gICAgICAgICRtbWFNb2RMdGkubGF1bmNoKGx0aS5sYXVuY2hkYXRhLmVuZHBvaW50LCBsdGkubGF1bmNoZGF0YS5wYXJhbWV0ZXJzKS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9sdGknKVxuXG4vKipcbiAqIE1vZCBMVEkgaGFuZGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbHRpXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEx0aUhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kTHRpSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbWFNb2RMdGksICRzdGF0ZSwgJG1tU2l0ZSwgJG1tRmlsZXBvb2wsICRtbUFwcCwgJG1tVXRpbCxcbiAgICAgICAgICAgIG1tYU1vZEx0aUNvbXBvbmVudCwgJG1tQ29udGVudExpbmtzSGVscGVyLCAkcSkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2x0aVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kTHRpSGFuZGxlcnMjY291cnNlQ29udGVudFxuICAgICAqL1xuICAgIHNlbGYuY291cnNlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kTHRpLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBpbmZvLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYygnbHRpJyk7IC8vIEdldCBMVEkgZGVmYXVsdCBpY29uIGZvciBub3cuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW9kX2x0aScsIHttb2R1bGU6IG1vZHVsZSwgY291cnNlaWQ6IGNvdXJzZWlkfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBMVEkgZGF0YS5cbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICRtbWFNb2RMdGkuZ2V0THRpKGNvdXJzZWlkLCBtb2R1bGUuaWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGN1c3RvbSBpY29ucy5cbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24obHRpZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWNvbiA9IGx0aWRhdGEuc2VjdXJlaWNvbiB8fCBsdGlkYXRhLmljb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpY29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1GaWxlcG9vbC5kb3dubG9hZFVybCgkbW1TaXRlLmdldElkKCksIGljb24sIGZhbHNlLCBtbWFNb2RMdGlDb21wb25lbnQsIG1vZHVsZS5pZCkudGhlbihmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIGRvd25sb2FkaW5nLiBJZiB3ZSdyZSBvbmxpbmUgd2UnbGwgc2V0IHRoZSBvbmxpbmUgdXJsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9IGljb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEJ1dHRvbiB0byBsYXVuY2ggdGhlIExUSS5cbiAgICAgICAgICAgICAgICAkc2NvcGUuYnV0dG9ucyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tbGluaycsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnbW1hLm1vZF9sdGkubGF1bmNoYWN0aXZpdHknLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW0uY29yZS5sb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgTFRJIGFuZCBsYXVuY2ggZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbihsdGlkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RMdGkuZ2V0THRpTGF1bmNoRGF0YShsdGlkYXRhLmlkKS50aGVuKGZ1bmN0aW9uKGxhdW5jaGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJWaWV3XCIgTFRJLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kTHRpLmxvZ1ZpZXcobHRpZGF0YS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUNvdXJzZS5jaGVja01vZHVsZUNvbXBsZXRpb24oY291cnNlaWQsIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGF1bmNoIExUSS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RMdGkubGF1bmNoKGxhdW5jaGRhdGEuZW5kcG9pbnQsIGxhdW5jaGRhdGEucGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2x0aS5lcnJvcmdldGx0aScsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEx0aUhhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICBTaXRlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoc2l0ZUlkLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RMdGkuaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhY3Rpb25zIHRvIHBlcmZvcm0gd2l0aCB0aGUgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhIExUSSBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy9tb2QvbHRpL3ZpZXcucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIudHJlYXRNb2R1bGVJbmRleFVybChzaXRlSWRzLCB1cmwsIGlzRW5hYmxlZCwgY291cnNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2x0aScpXG5cbi8qKlxuICogTFRJIHNlcnZpY2UuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2x0aVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RMdGlcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RMdGknLCBmdW5jdGlvbigkcSwgJG1tU2l0ZSwgJG1tRlMsICRtbVRleHQsICRtbVV0aWwsICRtbUxhbmcsICRtbVNpdGVzTWFuYWdlcikge1xuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGxhdW5jaGVyRmlsZU5hbWUgPSAnbHRpX2xhdW5jaGVyLmh0bWwnO1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGxhdW5jaGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2x0aVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kTHRpI2RlbGV0ZUxhdW5jaGVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBsYXVuY2hlciBmaWxlIGlzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgc2VsZi5kZWxldGVMYXVuY2hlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tRlMucmVtb3ZlRmlsZShsYXVuY2hlckZpbGVOYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbGF1bmNoZXIgZmlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEx0aSNnZW5lcmF0ZUxhdW5jaGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgIExhdW5jaCBVUkwuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcGFyYW1zIExhdW5jaCBwYXJhbXMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZmlsZSBVUkwuXG4gICAgICovXG4gICAgc2VsZi5nZW5lcmF0ZUxhdW5jaGVyID0gZnVuY3Rpb24odXJsLCBwYXJhbXMpIHtcblxuICAgICAgICBpZiAoISRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBhIGZvcm0gd2l0aCB0aGUgcGFyYW1zLlxuICAgICAgICB2YXIgdGV4dCA9ICc8Zm9ybSBhY3Rpb249XCInICsgdXJsICsgJ1wiIG5hbWU9XCJsdGlMYXVuY2hGb3JtXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdtZXRob2Q9XCJwb3N0XCIgZW5jVHlwZT1cImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiPlxcbic7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT0gJ2V4dF9zdWJtaXQnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSAnICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9ICcgICAgPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwiJyArICRtbVRleHQuZXNjYXBlSFRNTChwLm5hbWUpICsgJ1wiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgKz0gJyB2YWx1ZT1cIicgKyAkbW1UZXh0LmVzY2FwZUhUTUwocC52YWx1ZSkgKyAnXCIvPlxcbic7XG4gICAgICAgIH0pO1xuICAgICAgICB0ZXh0ICs9ICc8L2Zvcm0+XFxuJztcblxuICAgICAgICAvLyBBZGQgYW4gaW4tbGluZSBzY3JpcHQgdG8gYXV0b21hdGljYWxseSBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICAgIHRleHQgKz0gJzxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPiBcXG4nICtcbiAgICAgICAgICAgICcgICAgZG9jdW1lbnQubHRpTGF1bmNoRm9ybS5zdWJtaXQoKTsgXFxuJyArXG4gICAgICAgICAgICAnPC9zY3JpcHQ+IFxcbic7XG5cbiAgICAgICAgcmV0dXJuICRtbUZTLndyaXRlRmlsZShsYXVuY2hlckZpbGVOYW1lLCB0ZXh0KS50aGVuKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkudG9VUkwoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIExUSS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEx0aSNnZXRMdGlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbWlkICAgICBDb3Vyc2UgbW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIExUSSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRMdGkgPSBmdW5jdGlvbihjb3Vyc2VpZCwgY21pZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkczogW2NvdXJzZWlkXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldEx0aUNhY2hlS2V5KGNvdXJzZWlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfbHRpX2dldF9sdGlzX2J5X2NvdXJzZXMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5sdGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRMdGk7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc3BvbnNlLmx0aXMsIGZ1bmN0aW9uKGx0aSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobHRpLmNvdXJzZW1vZHVsZSA9PSBjbWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50THRpID0gbHRpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMdGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRMdGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgTFRJIGRhdGEgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0THRpQ2FjaGVLZXkoY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RMdGk6bHRpOicgKyBjb3Vyc2VpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBMVEkgbGF1bmNoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbHRpXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RMdGkjZ2V0THRpTGF1bmNoRGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBMVEkgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbGF1bmNoIGRhdGEgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0THRpTGF1bmNoRGF0YSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdG9vbGlkOiBpZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldEx0aUxhdW5jaERhdGFDYWNoZUtleShpZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX2x0aV9nZXRfdG9vbF9sYXVuY2hfZGF0YScsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgTFRJIGxhdW5jaCBkYXRhIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIExUSSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEx0aUxhdW5jaERhdGFDYWNoZUtleShpZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZEx0aTpsYXVuY2g6JyArIGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIExUSSBkYXRhLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2x0aVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kTHRpI2ludmFsaWRhdGVMdGlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlTHRpID0gZnVuY3Rpb24oY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0THRpQ2FjaGVLZXkoY291cnNlaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEx0aSNpbnZhbGlkYXRlTHRpTGF1bmNoRGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBMVEkgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVMdGlMYXVuY2hEYXRhID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0THRpTGF1bmNoRGF0YUNhY2hlS2V5KGlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGlzIGVuYWJsZWQgaW4gYSBjZXJ0YWluIHNpdGUuIFBsdWdpbiBpcyBlbmFibGVkIGlmIHRoZSBsdGkgV1MgYXJlIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEx0aSNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2x0aV9nZXRfbHRpc19ieV9jb3Vyc2VzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2x0aV9nZXRfdG9vbF9sYXVuY2hfZGF0YScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGF1bmNoIExUSS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEx0aSNsYXVuY2hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgTGF1bmNoIFVSTC5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBwYXJhbXMgTGF1bmNoIHBhcmFtcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sYXVuY2ggPSBmdW5jdGlvbih1cmwsIHBhcmFtcykge1xuICAgICAgICBpZiAoISRtbVV0aWwuaXNWYWxpZFVSTCh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tYS5tb2RfbHRpLmVycm9yaW52YWxpZGxhdW5jaHVybCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgbGF1bmNoZXIgYW5kIG9wZW4gaXQuXG4gICAgICAgIHJldHVybiBzZWxmLmdlbmVyYXRlTGF1bmNoZXIodXJsLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAkbW1VdGlsLm9wZW5JbkFwcCh1cmwpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IHRoZSBMVEkgYXMgYmVpbmcgdmlld2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2x0aVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kTHRpI2xvZ1ZpZXdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgTFRJIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ1ZpZXcgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgbHRpaWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9sdGlfdmlld19sdGknLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9wYWdlJylcblxuLyoqXG4gKiBQYWdlIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RQYWdlSW5kZXhDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RQYWdlSW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbVV0aWwsICRtbWFNb2RQYWdlLCAkbW1Db3Vyc2UsICRxLCAkbG9nLCAkbW1BcHAsXG4gICAgICAgICAgICBtbWFNb2RQYWdlQ29tcG9uZW50KSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tYU1vZFBhZ2VJbmRleEN0cmwnKTtcblxuICAgIHZhciBtb2R1bGUgPSAkc3RhdGVQYXJhbXMubW9kdWxlIHx8IHt9LFxuICAgICAgICBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZDtcblxuICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAkc2NvcGUuY29tcG9uZW50ID0gbW1hTW9kUGFnZUNvbXBvbmVudDtcbiAgICAkc2NvcGUuY29tcG9uZW50SWQgPSBtb2R1bGUuaWQ7XG4gICAgJHNjb3BlLmV4dGVybmFsVXJsID0gbW9kdWxlLnVybDtcbiAgICAkc2NvcGUubG9hZGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBmZXRjaENvbnRlbnQoKSB7XG4gICAgICAgIHZhciBkb3dubG9hZEZhaWxlZCA9IGZhbHNlO1xuICAgICAgICAvLyBQcmVmZXRjaCB0aGUgY29udGVudCBzbyBBTEwgZmlsZXMgYXJlIGRvd25sb2FkZWQsIG5vdCBqdXN0IHRoZSBvbmVzIHNob3duIGluIHRoZSBwYWdlLlxuICAgICAgICByZXR1cm4gJG1tYU1vZFBhZ2UuZG93bmxvYWRBbGxDb250ZW50KG1vZHVsZSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAvLyBNYXJrIGRvd25sb2FkIGFzIGZhaWxlZCBidXQgZ28gb24gc2luY2UgdGhlIG1haW4gZmlsZXMgY291bGQgaGF2ZSBiZWVuIGRvd25sb2FkZWQuXG4gICAgICAgICAgICBkb3dubG9hZEZhaWxlZCA9IHRydWU7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFBhZ2UuZ2V0UGFnZUh0bWwobW9kdWxlLmNvbnRlbnRzLCBtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5jb250ZW50ID0gY29udGVudDtcblxuICAgICAgICAgICAgICAgIGlmIChkb3dubG9hZEZhaWxlZCAmJiAkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCBsb2FkIHRoZSBtYWluIGZpbGUgYnV0IHRoZSBkb3dubG9hZCBmYWlsZWQuIFNob3cgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nc29tZWZpbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9wYWdlLmVycm9yd2hpbGVsb2FkaW5ndGhlcGFnZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgJHNjb3BlLmRvUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTW9kUGFnZS5pbnZhbGlkYXRlQ29udGVudChtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hDb250ZW50KCk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZmV0Y2hDb250ZW50KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYU1vZFBhZ2UubG9nVmlldyhtb2R1bGUuaW5zdGFuY2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfcGFnZScpXG5cbi8qKlxuICogTW9kIHBhZ2UgaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kUGFnZUhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kUGFnZUhhbmRsZXJzJywgZnVuY3Rpb24oJG1tQ291cnNlLCAkbW1hTW9kUGFnZSwgJG1tRXZlbnRzLCAkc3RhdGUsICRtbVNpdGUsICRtbVV0aWwsICRtbUZpbGVwb29sLFxuICAgICAgICAgICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSwgbW1Db3JlRG93bmxvYWRpbmcsIG1tQ29yZU5vdERvd25sb2FkZWQsIG1tQ29yZU91dGRhdGVkLCBtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLFxuICAgICAgICAgICAgbW1hTW9kUGFnZUNvbXBvbmVudCwgJG1tQ29udGVudExpbmtzSGVscGVyLCAkcSkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2VIYW5kbGVycyNjb3Vyc2VDb250ZW50XG4gICAgICovXG4gICAgc2VsZi5jb3Vyc2VDb250ZW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFBhZ2UuaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyk7XG5cbiAgICAgICAgICAgICAgICBkb3dubG9hZEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWlvcy1jbG91ZC1kb3dubG9hZC1vdXRsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLmRvd25sb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFBhZ2UucHJlZmV0Y2hDb250ZW50KG1vZHVsZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRkZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1hbmRyb2lkLXJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ21tLmNvcmUucmVmcmVzaCcsXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFBhZ2UuaW52YWxpZGF0ZUNvbnRlbnQobW9kdWxlLmlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RQYWdlLnByZWZldGNoQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJGRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ3BhZ2UnKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYnV0dG9ucyA9IFtkb3dubG9hZEJ0biwgcmVmcmVzaEJ0bl07XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2RfcGFnZScsIHttb2R1bGU6IG1vZHVsZSwgY291cnNlaWQ6IGNvdXJzZWlkfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3cgYnV0dG9ucyBhY2NvcmRpbmcgdG8gbW9kdWxlIHN0YXR1cy5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG93U3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IHN0YXR1cyA9PT0gbW1Db3JlRG93bmxvYWRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEJ0bi5oaWRkZW4gPSBzdGF0dXMgIT09IG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoQnRuLmhpZGRlbiA9IHN0YXR1cyAhPT0gbW1Db3JlT3V0ZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhpcyBtb2R1bGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNpdGVpZCA9PT0gJG1tU2l0ZS5nZXRJZCgpICYmIGRhdGEuY29tcG9uZW50SWQgPT09IG1vZHVsZS5pZCAmJiBkYXRhLmNvbXBvbmVudCA9PT0gbW1hTW9kUGFnZUNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1N0YXR1cyhkYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IHN0YXR1cyB0byBkZWNpZGUgd2hpY2ggaWNvbiBzaG91bGQgYmUgc2hvd24uXG4gICAgICAgICAgICAgICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5nZXRNb2R1bGVTdGF0dXMobW9kdWxlLCBjb3Vyc2VpZCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCkudGhlbihzaG93U3RhdHVzKTtcblxuICAgICAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c09ic2VydmVyICYmIHN0YXR1c09ic2VydmVyLm9mZiAmJiBzdGF0dXNPYnNlcnZlci5vZmYoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlSGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRW5hYmxlZChzaXRlSWQsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFBhZ2UuaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhY3Rpb25zIHRvIHBlcmZvcm0gd2l0aCB0aGUgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhIHBhZ2UgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL3BhZ2Uvdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfcGFnZScpXG5cbi8qKlxuICogUGFnZSBmYWN0b3J5LlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZFBhZ2VcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RQYWdlJywgZnVuY3Rpb24oJG1tRmlsZXBvb2wsICRtbVNpdGUsICRtbUZTLCAkaHR0cCwgJGxvZywgJHEsICRtbVNpdGVzTWFuYWdlciwgbW1hTW9kUGFnZUNvbXBvbmVudCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hTW9kUGFnZScpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGFsbCB0aGUgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlI2Rvd25sb2FkQWxsQ29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGNvbnRlbnQgaXMgZG93bmxvYWRlZC4gRGF0YSByZXR1cm5lZCBpcyBub3QgcmVsaWFibGUuXG4gICAgICovXG4gICAgc2VsZi5kb3dubG9hZEFsbENvbnRlbnQgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyhtb2R1bGUpLFxuICAgICAgICAgICAgcmV2aXNpb24gPSAkbW1GaWxlcG9vbC5nZXRSZXZpc2lvbkZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpLFxuICAgICAgICAgICAgdGltZW1vZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZG93bmxvYWRQYWNrYWdlKCRtbVNpdGUuZ2V0SWQoKSwgZmlsZXMsIG1tYU1vZFBhZ2VDb21wb25lbnQsIG1vZHVsZS5pZCwgcmV2aXNpb24sIHRpbWVtb2QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlcyB0aGF0IGNhbiBiZSBkb3dubG9hZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2UjZ2V0RG93bmxvYWRhYmxlRmlsZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgTGlzdCBvZiBmaWxlcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkYWJsZUZpbGVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IFtdO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzRmlsZURvd25sb2FkYWJsZShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmaWxlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGV2ZW50IG5hbWVzIG9mIGZpbGVzIGJlaW5nIGRvd25sb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUGFnZSNnZXREb3dubG9hZGluZ0ZpbGVzRXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkaW5nRmlsZXNFdmVudE5hbWVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgZXZlbnROYW1lcyA9IFtdLFxuICAgICAgICAgICAgc2l0ZWlkID0gJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBjb250ZW50LmZpbGV1cmw7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GaWxlcG9vbC5pc0ZpbGVEb3dubG9hZGluZ0J5VXJsKHNpdGVpZCwgdXJsKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXRGaWxlRXZlbnROYW1lQnlVcmwoc2l0ZWlkLCB1cmwpLnRoZW4oZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZXMucHVzaChldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGZhaWxzLlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlIGV2ZW50IG5hbWVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2UjZ2V0RmlsZUV2ZW50TmFtZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhcnJheSBvZiAkbW1FdmVudCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVFdmVudE5hbWVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gY29udGVudC5maWxldXJsO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzRmlsZURvd25sb2FkYWJsZShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tRmlsZXBvb2wuZ2V0RmlsZUV2ZW50TmFtZUJ5VXJsKCRtbVNpdGUuZ2V0SWQoKSwgdXJsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE5hbWVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFnZSBIVE1MLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2UjZ2V0UGFnZUh0bWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGVudHMgVGhlIG1vZHVsZSBjb250ZW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlSWQgVGhlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuZ2V0UGFnZUh0bWwgPSBmdW5jdGlvbihjb250ZW50cywgbW9kdWxlSWQpIHtcbiAgICAgICAgdmFyIGluZGV4VXJsLFxuICAgICAgICAgICAgcGF0aHMgPSB7fSxcbiAgICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgaW5mb3JtYXRpb24gYWJvdXQgcGF0aHMgZnJvbSB0aGUgbW9kdWxlIGNvbnRlbnRzLlxuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICAgICAgdXJsID0gY29udGVudC5maWxldXJsO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5faXNNYWluUGFnZShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgd2F5IHRvIHNwb3QgdGhlIGluZGV4IHBhZ2UuXG4gICAgICAgICAgICAgICAgaW5kZXhVcmwgPSB1cmw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleSA9IGNvbnRlbnQuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQuZmlsZXBhdGggIT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGZvbGRlcnMgd2l0aG91dCB0aGUgbGVhZGluZyBzbGFzaC5cbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY29udGVudC5maWxlcGF0aC5zdWJzdHIoMSkgKyBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGhzW2tleV0gPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFByb21pc2UgaGFuZGxpbmcgd2hlbiB3ZSBhcmUgaW4gYSBicm93c2VyLlxuICAgICAgICBwcm9taXNlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkO1xuICAgICAgICAgICAgaWYgKCFpbmRleFVybCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGV2ZXIgdGhhdCBoYXBwZW5zLlxuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0NvdWxkIG5vdCBsb2NhdGUgdGhlIGluZGV4IHBhZ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSBzeXN0ZW0gaXMgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5kb3dubG9hZFVybCgkbW1TaXRlLmdldElkKCksIGluZGV4VXJsLCBmYWxzZSwgbW1hTW9kUGFnZUNvbXBvbmVudCwgbW9kdWxlSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSByZXR1cm4gdGhlIGxpdmUgVVJMLlxuICAgICAgICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCRtbVNpdGUuZml4UGx1Z2luZmlsZVVSTChpbmRleFVybCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgVVJMIGNvbnRlbnQuXG4gICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KHVybCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgdGhlIGNvbnRlbnQsIHdlIHVwZGF0ZSB0aGUgU1JDIHRvIHBvaW50IGJhY2sgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGV4dGVybmFsIHJlc291cmNlLiBUaGF0IHdpbGwgYmUgY2F1Z2h0IGJ5IG1tLWZvcm1hdC10ZXh0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdj4nKTtcbiAgICAgICAgICAgICAgICAgICAgaHRtbC5odG1sKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaHRtbC5maW5kKCdpbWcnKSwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjID0gcGF0aHNbZGVjb2RlVVJJQ29tcG9uZW50KGltZy5nZXRBdHRyaWJ1dGUoJ3NyYycpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhlIHNhbWUgZm9yIGxpbmtzLlxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaHRtbC5maW5kKCdhJyksIGZ1bmN0aW9uKGFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBwYXRoc1tkZWNvZGVVUklDb21wb25lbnQoYW5jaG9yLmdldEF0dHJpYnV0ZSgnaHJlZicpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhyZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGh0bWwuaHRtbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSB0aGUgcHJlZmV0Y2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2UjaW52YWxpZGF0ZUNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlSWQgVGhlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbihtb2R1bGVJZCkge1xuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuaW52YWxpZGF0ZUZpbGVzQnlDb21wb25lbnQoJG1tU2l0ZS5nZXRJZCgpLCBtbWFNb2RQYWdlQ29tcG9uZW50LCBtb2R1bGVJZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgZmlsZSBpcyBkb3dubG9hZGFibGUuIFRoZSBmaWxlIHBhcmFtIG11c3QgaGF2ZSBhICd0eXBlJyBhdHRyaWJ1dGUgbGlrZSBpbiBjb3JlX2NvdXJzZV9nZXRfY29udGVudHMgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUGFnZSNpc0ZpbGVEb3dubG9hZGFibGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZSBGaWxlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIFRydWUgaWYgZG93bmxvYWRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgIHJldHVybiBmaWxlLnR5cGUgPT09ICdmaWxlJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBmaWxlIGlzIHRoZSBtYWluIHBhZ2Ugb2YgdGhlIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlI19pc01haW5QYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGUgQW4gb2JqZWN0IHJldHVybmVkIGZyb20gV1MgY29udGFpbmluZyBmaWxlIGluZm8uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5faXNNYWluUGFnZSA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZmlsZS5maWxlbmFtZSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBmaWxldXJsID0gZmlsZS5maWxldXJsIHx8ICcnLFxuICAgICAgICAgICAgdXJsID0gJy9tb2RfcGFnZS9jb250ZW50L2luZGV4Lmh0bWwnLFxuICAgICAgICAgICAgZW5jb2RlZFVybCA9IGVuY29kZVVSSUNvbXBvbmVudCh1cmwpO1xuXG4gICAgICAgIHJldHVybiAoZmlsZW5hbWUgPT09ICdpbmRleC5odG1sJyAmJiAoZmlsZXVybC5pbmRleE9mKHVybCkgPiAwIHx8IGZpbGV1cmwuaW5kZXhPZihlbmNvZGVkVXJsKSA+IDAgKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHBhZ2UgcGx1Z2luIGlzIGVuYWJsZWQgaW4gYSBjZXJ0YWluIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUGFnZSNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLmNhbkRvd25sb2FkRmlsZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCBhIHBhZ2UgYXMgYmVpbmcgdmlld2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2UjbG9nVmlld1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBNb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgY2FsbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHNlbGYubG9nVmlldyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBwYWdlaWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9wYWdlX3ZpZXdfcGFnZScsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCB0aGUgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlI3ByZWZldGNoQ29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGZpbGVzIGhhdmUgYmVlbiBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoQ29udGVudCA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBzZWxmLmdldERvd25sb2FkYWJsZUZpbGVzKG1vZHVsZSksXG4gICAgICAgICAgICByZXZpc2lvbiA9ICRtbUZpbGVwb29sLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyksXG4gICAgICAgICAgICB0aW1lbW9kID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyk7XG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5wcmVmZXRjaFBhY2thZ2UoJG1tU2l0ZS5nZXRJZCgpLCBmaWxlcywgbW1hTW9kUGFnZUNvbXBvbmVudCwgbW9kdWxlLmlkLCByZXZpc2lvbiwgdGltZW1vZCk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfcGFnZScpXG5cbi8qKlxuICogTW9kIHBhZ2UgcHJlZmV0Y2ggaGFuZGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcGFnZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RQYWdlUHJlZmV0Y2hIYW5kbGVyXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kUGFnZVByZWZldGNoSGFuZGxlcicsIGZ1bmN0aW9uKCRtbWFNb2RQYWdlLCAkbW1TaXRlLCBtbWFNb2RQYWdlQ29tcG9uZW50KSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgc2VsZi5jb21wb25lbnQgPSBtbWFNb2RQYWdlQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkb3dubG9hZCBzaXplIG9mIGEgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2VQcmVmZXRjaEhhbmRsZXIjZ2V0RG93bmxvYWRTaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBNb2R1bGUgdG8gZ2V0IHRoZSBzaXplLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgU2l6ZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkU2l6ZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICgkbW1hTW9kUGFnZS5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkgJiYgY29udGVudC5maWxlc2l6ZSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBzaXplICsgY29udGVudC5maWxlc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2VQcmVmZXRjaEhhbmRsZXIjaXNFbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5jYW5Eb3dubG9hZEZpbGVzKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIHRoZSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUGFnZVByZWZldGNoSGFuZGxlciNwcmVmZXRjaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGZpbGVzIGhhdmUgYmVlbiBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kUGFnZS5wcmVmZXRjaENvbnRlbnQobW9kdWxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9yZXNvdXJjZScpXG5cbi8qKlxuICogUmVzb3VyY2UgaW5kZXggY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RSZXNvdXJjZUluZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kUmVzb3VyY2VJbmRleEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tVXRpbCwgJG1tYU1vZFJlc291cmNlLCAkbG9nLCAkbW1BcHAsICRtbUNvdXJzZSwgJHRpbWVvdXQsXG4gICAgICAgICAgICBtbWFNb2RSZXNvdXJjZUNvbXBvbmVudCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbWFNb2RSZXNvdXJjZUluZGV4Q3RybCcpO1xuXG4gICAgdmFyIG1vZHVsZSA9ICRzdGF0ZVBhcmFtcy5tb2R1bGUgfHwge30sXG4gICAgICAgIGNvdXJzZWlkID0gJHN0YXRlUGFyYW1zLmNvdXJzZWlkO1xuXG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbW9kdWxlLmRlc2NyaXB0aW9uO1xuICAgICRzY29wZS5jb21wb25lbnQgPSBtbWFNb2RSZXNvdXJjZUNvbXBvbmVudDtcbiAgICAkc2NvcGUuY29tcG9uZW50SWQgPSBtb2R1bGUuaWQ7XG4gICAgJHNjb3BlLmV4dGVybmFsVXJsID0gbW9kdWxlLnVybDtcbiAgICAkc2NvcGUubW9kZSA9IGZhbHNlO1xuICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGZldGNoQ29udGVudCgpIHtcbiAgICAgICAgaWYgKG1vZHVsZS5jb250ZW50cyAmJiBtb2R1bGUuY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoJG1tYU1vZFJlc291cmNlLmlzRGlzcGxheWVkSW5JZnJhbWUobW9kdWxlKSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5tb2RlID0gJ2lmcmFtZSc7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25sb2FkRmFpbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RSZXNvdXJjZS5kb3dubG9hZEFsbENvbnRlbnQobW9kdWxlKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFyayBkb3dubG9hZCBhcyBmYWlsZWQgYnV0IGdvIG9uIHNpbmNlIHRoZSBtYWluIGZpbGVzIGNvdWxkIGhhdmUgYmVlbiBkb3dubG9hZGVkLlxuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFJlc291cmNlLmdldElmcmFtZVNyYyhtb2R1bGUpLnRoZW4oZnVuY3Rpb24oc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLnNyYyAmJiBzcmMudG9TdHJpbmcoKSA9PSAkc2NvcGUuc3JjLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS1sb2FkaW5nIHNhbWUgcGFnZS4gU2V0IGl0IHRvIGVtcHR5IGFuZCB0aGVuIHJlLXNldCB0aGUgc3JjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG5leHQgZGlnZXN0IHNvIGl0IGRldGVjdHMgaXQgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNyYyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFJlc291cmNlLmxvZ1ZpZXcobW9kdWxlLmluc3RhbmNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUNvdXJzZS5jaGVja01vZHVsZUNvbXBsZXRpb24oY291cnNlaWQsIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkRmFpbGVkICYmICRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY291bGQgbG9hZCB0aGUgbWFpbiBmaWxlIGJ1dCB0aGUgZG93bmxvYWQgZmFpbGVkLiBTaG93IGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nc29tZWZpbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9yZXNvdXJjZS5lcnJvcndoaWxlbG9hZGluZ3RoZWNvbnRlbnQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJG1tYU1vZFJlc291cmNlLmlzRGlzcGxheWVkSW5saW5lKG1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRGYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkbW1hTW9kUmVzb3VyY2UuZG93bmxvYWRBbGxDb250ZW50KG1vZHVsZSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgZG93bmxvYWQgYXMgZmFpbGVkIGJ1dCBnbyBvbiBzaW5jZSB0aGUgbWFpbiBmaWxlcyBjb3VsZCBoYXZlIGJlZW4gZG93bmxvYWRlZC5cbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbWFNb2RSZXNvdXJjZS5nZXRSZXNvdXJjZUh0bWwobW9kdWxlLmNvbnRlbnRzLCBtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm1vZGUgPSAnaW5saW5lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RSZXNvdXJjZS5sb2dWaWV3KG1vZHVsZS5pbnN0YW5jZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkRmFpbGVkICYmICRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY291bGQgbG9hZCB0aGUgbWFpbiBmaWxlIGJ1dCB0aGUgZG93bmxvYWQgZmFpbGVkLiBTaG93IGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nc29tZWZpbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9yZXNvdXJjZS5lcnJvcndoaWxlbG9hZGluZ3RoZWNvbnRlbnQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm1vZGUgPSAnZXh0ZXJuYWwnO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbS5jb3JlLmRvd25sb2FkaW5nJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFJlc291cmNlLm9wZW5GaWxlKG1vZHVsZS5jb250ZW50cywgbW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFJlc291cmNlLmxvZ1ZpZXcobW9kdWxlLmluc3RhbmNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUNvdXJzZS5jaGVja01vZHVsZUNvbXBsZXRpb24oY291cnNlaWQsIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfcmVzb3VyY2UuZXJyb3J3aGlsZWxvYWRpbmd0aGVjb250ZW50JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX3Jlc291cmNlLmVycm9yd2hpbGVsb2FkaW5ndGhlY29udGVudCcsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXZlbnQgc2VudCBieSB0aGUgZGlyZWN0aXZlIG1tYU1vZFJlc291cmNlSHRtbExpbmsgd2hlbiB3ZSBjbGljayBhbiBIVE1MIGxpbmsuXG4gICAgJHNjb3BlLiRvbignbW1hTW9kUmVzb3VyY2VIdG1sTGlua0NsaWNrZWQnLCBmdW5jdGlvbihlLCB0YXJnZXQpIHtcbiAgICAgICAgJHNjb3BlLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAkbW1hTW9kUmVzb3VyY2UuZ2V0UmVzb3VyY2VIdG1sKG1vZHVsZS5jb250ZW50cywgbW9kdWxlLmlkLCB0YXJnZXQpLnRoZW4oZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgJHNjb3BlLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfcmVzb3VyY2UuZXJyb3J3aGlsZWxvYWRpbmd0aGVjb250ZW50JywgdHJ1ZSk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuZG9SZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNb2RSZXNvdXJjZS5pbnZhbGlkYXRlQ29udGVudChtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hDb250ZW50KCk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZmV0Y2hDb250ZW50KCk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9yZXNvdXJjZScpXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIG9wZW4gYSBsaW5rIGluIGV4dGVybmFsIGJyb3dzZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbWFNb2RSZXNvdXJjZUh0bWxMaW5rXG4gKi9cbi5kaXJlY3RpdmUoJ21tYU1vZFJlc291cmNlSHRtbExpbmsnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICBwcmlvcml0eTogOTksICAgLy8gTXVzdCBiZSBsb3dlciB0aGFuIG1tLWJyb3dzZXIsIG9yIGFueXRoaW5nIGxpc3RlbmluZyBmb3IgYSBjbGljayBldmVudC5cbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICBlbGVtZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBlbGVtZW50WzBdLmdldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGFueSBvdGhlciBkaXJlY3RpdmUgZnJvbSBjYXRjaGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSB0aGUgc2NvcGUgd2hpY2ggbXVzdCBoYW5kbGUgdGhpcyBjbGljaywgd2UgZG8gbm90IHN1cHBvcnQgYnViYmxpbmcuXG4gICAgICAgICAgICAgICAgc2NvcGUuJGVtaXQoJ21tYU1vZFJlc291cmNlSHRtbExpbmtDbGlja2VkJywgaHJlZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9yZXNvdXJjZScpXG5cbi8qKlxuICogTW9kIHJlc291cmNlIGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZUhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kUmVzb3VyY2VIYW5kbGVycycsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tYU1vZFJlc291cmNlLCAkbW1FdmVudHMsICRzdGF0ZSwgJG1tU2l0ZSwgJG1tVXRpbCxcbiAgICAgICAgICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUsICRtbUZpbGVwb29sLCAkbW1GUywgbW1Db3JlRG93bmxvYWRpbmcsIG1tQ29yZU5vdERvd25sb2FkZWQsIG1tQ29yZU91dGRhdGVkLFxuICAgICAgICAgICAgbW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCwgbW1hTW9kUmVzb3VyY2VDb21wb25lbnQsICRxLCAkbW1Db250ZW50TGlua3NIZWxwZXIpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2VIYW5kbGVycyNjb3Vyc2VDb250ZW50XG4gICAgICovXG4gICAgc2VsZi5jb3Vyc2VDb250ZW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFJlc291cmNlLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgICBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyk7XG5cbiAgICAgICAgICAgICAgICBkb3dubG9hZEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWlvcy1jbG91ZC1kb3dubG9hZC1vdXRsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLmRvd25sb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFJlc291cmNlLnByZWZldGNoQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tYW5kcm9pZC1yZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLnJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RSZXNvdXJjZS5pbnZhbGlkYXRlQ29udGVudChtb2R1bGUuaWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFJlc291cmNlLnByZWZldGNoQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJGRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5jb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gbW9kdWxlLmNvbnRlbnRzWzBdLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gJG1tRlMuZ2V0RmlsZUV4dGVuc2lvbihmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuY29udGVudHMubGVuZ3RoID09IDEgfHwgKGV4dGVuc2lvbiAhPSBcImh0bWxcIiAmJiBleHRlbnNpb24gIT0gXCJodG1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tRlMuZ2V0RmlsZUljb24oZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYygncmVzb3VyY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ3Jlc291cmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRzY29wZS5idXR0b25zID0gW2Rvd25sb2FkQnRuLCByZWZyZXNoQnRuXTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1vZF9yZXNvdXJjZScsIHttb2R1bGU6IG1vZHVsZSwgY291cnNlaWQ6IGNvdXJzZWlkfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3cgYnV0dG9ucyBhY2NvcmRpbmcgdG8gbW9kdWxlIHN0YXR1cy5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG93U3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IHN0YXR1cyA9PT0gbW1Db3JlRG93bmxvYWRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEJ0bi5oaWRkZW4gPSBzdGF0dXMgIT09IG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoQnRuLmhpZGRlbiA9IHN0YXR1cyAhPT0gbW1Db3JlT3V0ZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhpcyBtb2R1bGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNpdGVpZCA9PT0gJG1tU2l0ZS5nZXRJZCgpICYmIGRhdGEuY29tcG9uZW50SWQgPT09IG1vZHVsZS5pZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY29tcG9uZW50ID09PSBtbWFNb2RSZXNvdXJjZUNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1N0YXR1cyhkYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IHN0YXR1cyB0byBkZWNpZGUgd2hpY2ggaWNvbiBzaG91bGQgYmUgc2hvd24uXG4gICAgICAgICAgICAgICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5nZXRNb2R1bGVTdGF0dXMobW9kdWxlLCBjb3Vyc2VpZCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCkudGhlbihzaG93U3RhdHVzKTtcblxuICAgICAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c09ic2VydmVyICYmIHN0YXR1c09ic2VydmVyLm9mZiAmJiBzdGF0dXNPYnNlcnZlci5vZmYoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2VIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kUmVzb3VyY2UuaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhY3Rpb25zIHRvIHBlcmZvcm0gd2l0aCB0aGUgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhIHJlc291cmNlIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignL21vZC9yZXNvdXJjZS92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9yZXNvdXJjZScpXG5cbi8qKlxuICogTW9kIHJlc291cmNlIHByZWZldGNoIGhhbmRsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZFJlc291cmNlUHJlZmV0Y2hIYW5kbGVyXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kUmVzb3VyY2VQcmVmZXRjaEhhbmRsZXInLCBmdW5jdGlvbigkbW1hTW9kUmVzb3VyY2UsICRtbVNpdGUsIG1tYU1vZFJlc291cmNlQ29tcG9uZW50KSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgc2VsZi5jb21wb25lbnQgPSBtbWFNb2RSZXNvdXJjZUNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG93bmxvYWQgc2l6ZSBvZiBhIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2VQcmVmZXRjaEhhbmRsZXIjZ2V0RG93bmxvYWRTaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBNb2R1bGUgdG8gZ2V0IHRoZSBzaXplLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgU2l6ZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkU2l6ZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICgkbW1hTW9kUmVzb3VyY2UuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpICYmIGNvbnRlbnQuZmlsZXNpemUpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gc2l6ZSArIGNvbnRlbnQuZmlsZXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2VQcmVmZXRjaEhhbmRsZXIjaXNFbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5jYW5Eb3dubG9hZEZpbGVzKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIHRoZSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlUHJlZmV0Y2hIYW5kbGVyI3ByZWZldGNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgZmlsZXMgaGF2ZSBiZWVuIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYucHJlZmV0Y2ggPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RSZXNvdXJjZS5wcmVmZXRjaENvbnRlbnQobW9kdWxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9yZXNvdXJjZScpXG5cbi8qKlxuICogUmVzb3VyY2UgZmFjdG9yeS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2VcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RSZXNvdXJjZScsIGZ1bmN0aW9uKCRtbUZpbGVwb29sLCAkbW1TaXRlLCAkbW1VdGlsLCAkbW1GUywgJGh0dHAsICRsb2csICRxLCAkc2NlLCAkbW1BcHAsICRtbVNpdGVzTWFuYWdlcixcbiAgICAgICAgICAgIG1tYU1vZFJlc291cmNlQ29tcG9uZW50KSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFNb2RSZXNvdXJjZScpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGFsbCB0aGUgY29udGVudC4gQWxsIHRoZSBmaWxlcyBhcmUgZG93bmxvYWRlZCBpbnNpZGUgYSBmb2xkZXIgaW4gZmlsZXBvb2wsIGtlZXBpbmcgdGhlaXIgZm9sZGVyIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2UjZG93bmxvYWRBbGxDb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBjb250ZW50IGlzIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYuZG93bmxvYWRBbGxDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMobW9kdWxlKSxcbiAgICAgICAgICAgIHNpdGVpZCA9ICRtbVNpdGUuZ2V0SWQoKSxcbiAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICByZXZpc2lvbiA9ICRtbUZpbGVwb29sLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyksXG4gICAgICAgICAgICB0aW1lbW9kID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyk7XG5cbiAgICAgICAgaWYgKHNlbGYuaXNEaXNwbGF5ZWRJbklmcmFtZShtb2R1bGUpKSB7XG4gICAgICAgICAgICAvLyBHZXQgcGF0aCBvZiB0aGUgbW9kdWxlIGZvbGRlciBpbiBmaWxlcG9vbC5cbiAgICAgICAgICAgIHByb21pc2UgPSAkbW1GaWxlcG9vbC5nZXRGaWxlUGF0aEJ5VXJsKHNpdGVpZCwgbW9kdWxlLnVybCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihkaXJQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZG93bmxvYWRQYWNrYWdlKHNpdGVpZCwgZmlsZXMsIG1tYU1vZFJlc291cmNlQ29tcG9uZW50LCBtb2R1bGUuaWQsIHJldmlzaW9uLCB0aW1lbW9kLCBkaXJQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGZpbGVzIHRoYXQgY2FuIGJlIGRvd25sb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZHJlc291cmNlI2dldERvd25sb2FkYWJsZUZpbGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gICAgIExpc3Qgb2YgZmlsZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBbXTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBldmVudCBuYW1lcyBvZiBmaWxlcyBiZWluZyBkb3dubG9hZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZSNnZXREb3dubG9hZGluZ0ZpbGVzRXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkaW5nRmlsZXNFdmVudE5hbWVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgZXZlbnROYW1lcyA9IFtdLFxuICAgICAgICAgICAgc2l0ZWlkID0gJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBjb250ZW50LmZpbGV1cmw7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GaWxlcG9vbC5pc0ZpbGVEb3dubG9hZGluZ0J5VXJsKHNpdGVpZCwgdXJsKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXRGaWxlRXZlbnROYW1lQnlVcmwoc2l0ZWlkLCB1cmwpLnRoZW4oZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZXMucHVzaChldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGZhaWxzLlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlIGV2ZW50IG5hbWVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZSNnZXRGaWxlRXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIGFycmF5IG9mICRtbUV2ZW50IG5hbWVzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZUV2ZW50TmFtZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBjb250ZW50LmZpbGV1cmw7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GaWxlcG9vbC5nZXRGaWxlRXZlbnROYW1lQnlVcmwoJG1tU2l0ZS5nZXRJZCgpLCB1cmwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oZXZlbnROYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbGwgdGhlIGZpbGVzIG5lZWRlZCBhbmQgcmV0dXJucyB0aGUgc3JjIG9mIHRoZSBpZnJhbWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlI2dldElmcmFtZVNyY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGlmcmFtZSBzcmMuXG4gICAgICovXG4gICAgc2VsZi5nZXRJZnJhbWVTcmMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgaWYgKCFtb2R1bGUuY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFpbkZpbGUgPSBtb2R1bGUuY29udGVudHNbMF0sXG4gICAgICAgICAgICBtYWluRmlsZVBhdGggPSBtYWluRmlsZS5maWxlbmFtZTtcblxuICAgICAgICBpZiAobWFpbkZpbGUuZmlsZXBhdGggIT09ICcvJykge1xuICAgICAgICAgICAgbWFpbkZpbGVQYXRoID0gbWFpbkZpbGUuZmlsZXBhdGguc3Vic3RyKDEpICsgbWFpbkZpbGVQYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmdldERpcmVjdG9yeVVybEJ5VXJsKCRtbVNpdGUuZ2V0SWQoKSwgbW9kdWxlLnVybCkudGhlbihmdW5jdGlvbihkaXJQYXRoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIFVSTCBpcyBnb2luZyB0byBiZSBpbmplY3RlZCBpbiBhbiBpZnJhbWUsIHdlIG5lZWQgdHJ1c3RBc1Jlc291cmNlVXJsIHRvIG1ha2UgaXQgd29yayBpbiBhIGJyb3dzZXIuXG4gICAgICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzUmVzb3VyY2VVcmwoJG1tRlMuY29uY2F0ZW5hdGVQYXRocyhkaXJQYXRoLCBtYWluRmlsZVBhdGgpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBFcnJvciBnZXR0aW5nIGRpcmVjdG9yeSwgdGhlcmUgd2FzIGFuIGVycm9yIGRvd25sb2FkaW5nIG9yIHdlJ3JlIGluIGJyb3dzZXIuIFJldHVybiBvbmxpbmUgVVJMLlxuICAgICAgICAgICAgaWYgKCRtbUFwcC5pc09ubGluZSgpICYmIG1haW5GaWxlLmZpbGV1cmwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIFVSTCBpcyBnb2luZyB0byBiZSBpbmplY3RlZCBpbiBhbiBpZnJhbWUsIHdlIG5lZWQgdGhpcyB0byBtYWtlIGl0IHdvcmsuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKCRtbVNpdGUuZml4UGx1Z2luZmlsZVVSTChtYWluRmlsZS5maWxldXJsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZXNvdXJjZSBIVE1MLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZSNnZXRSZXNvdXJjZUh0bWxcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBjb250ZW50cyBBcnJheSBvZiBjb250ZW50IG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vZHVsZUlkIFRoZSBtb2R1bGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFt0YXJnZXRdIFRoZSBIVE1MIGZpbGUgdGhhdCB0aGUgdXNlciB3YW50cyB0byBvcGVuLCBpZiBub3QgZGVmaW5lZCB1c2VzIHRoZSBtYWluIGZpbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmdldFJlc291cmNlSHRtbCA9IGZ1bmN0aW9uKGNvbnRlbnRzLCBtb2R1bGVJZCwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBpbmRleFVybCxcbiAgICAgICAgICAgIHBhdGhzID0ge30sXG4gICAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIGluZm9ybWF0aW9uIGFib3V0IHBhdGhzIGZyb20gdGhlIG1vZHVsZSBjb250ZW50cy5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHVybCA9IGNvbnRlbnQuZmlsZXVybCxcbiAgICAgICAgICAgICAgICBmdWxscGF0aCA9IGNvbnRlbnQuZmlsZW5hbWU7XG5cbiAgICAgICAgICAgIGlmIChjb250ZW50LmZpbGVwYXRoICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICBmdWxscGF0aCA9IGNvbnRlbnQuZmlsZXBhdGguc3Vic3RyKDEpICsgZnVsbHBhdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAndW5kZWZpbmVkJyAmJiB0YXJnZXQgPT0gZnVsbHBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYW5vdGhlciBpbmRleC5cbiAgICAgICAgICAgICAgICBpbmRleFVybCA9IHVybDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhlIG1haW4gcGFnZSwgaXQgc2hvdWxkIGFsd2F5cyBiZSB0aGUgZmlyc3Qgb25lLlxuICAgICAgICAgICAgICAgIGluZGV4VXJsID0gdXJsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBbnkgb3RoZXIgZmlsZSBpbiB0aGUgcmVzb3VyY2UuXG4gICAgICAgICAgICAgICAgcGF0aHNbZnVsbHBhdGhdID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQcm9taXNlIGhhbmRsaW5nIHdoZW4gd2UgYXJlIGluIGEgYnJvd3Nlci5cbiAgICAgICAgcHJvbWlzZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghaW5kZXhVcmwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBldmVyIHRoYXQgaGFwcGVucy5cbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdDb3VsZCBub3QgbG9jYXRlIHRoZSBpbmRleCBwYWdlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSBzeXN0ZW0gaXMgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5kb3dubG9hZFVybCgkbW1TaXRlLmdldElkKCksIGluZGV4VXJsLCBmYWxzZSwgbW1hTW9kUmVzb3VyY2VDb21wb25lbnQsIG1vZHVsZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgcmV0dXJuIHRoZSBsaXZlIFVSTC5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbigkbW1TaXRlLmZpeFBsdWdpbmZpbGVVUkwoaW5kZXhVcmwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIFVSTCBjb250ZW50LlxuICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldCh1cmwpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBjb250ZW50LCB3ZSB1cGRhdGUgdGhlIFNSQyB0byBwb2ludCBiYWNrIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBleHRlcm5hbCByZXNvdXJjZS4gVGhhdCB3aWxsIGJlIGNhdWdodCBieSBtbS1mb3JtYXQtdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sLmFwcGVuZChyZXNwb25zZS5kYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaHRtbC5maW5kKCdpbWcnKSwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjID0gcGF0aHNbZGVjb2RlVVJJQ29tcG9uZW50KGltZy5nZXRBdHRyaWJ1dGUoJ3NyYycpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhlIHNhbWUgZm9yIGxpbmtzLlxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaHRtbC5maW5kKCdhJyksIGZ1bmN0aW9uKGFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBkZWNvZGVVUklDb21wb25lbnQoYW5jaG9yLmdldEF0dHJpYnV0ZSgnaHJlZicpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBwYXRoc1tocmVmXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHQgPSAkbW1GUy5nZXRGaWxlRXh0ZW5zaW9uKGhyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dCA9PSAnaHRtbCcgfHwgZXh0ID09ICdodG1sJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdtbWEtbW9kLXJlc291cmNlLWh0bWwtbGluaycsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdkYXRhLWhyZWYnLCBocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBodG1sLmh0bWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgdGhlIHByZWZldGNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2UjaW52YWxpZGF0ZUNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9kdWxlSWQgVGhlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbihtb2R1bGVJZCkge1xuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuaW52YWxpZGF0ZUZpbGVzQnlDb21wb25lbnQoJG1tU2l0ZS5nZXRJZCgpLCBtbWFNb2RSZXNvdXJjZUNvbXBvbmVudCwgbW9kdWxlSWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZXNvdXJjZSBoYXMgdG8gYmUgZGlzcGxheWVkIGluIGFuIGlmcmFtZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2UjaXNEaXNwbGF5ZWRJbklmcmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzRGlzcGxheWVkSW5JZnJhbWUgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGlubGluZSA9IHNlbGYuaXNEaXNwbGF5ZWRJbmxpbmUobW9kdWxlKTtcblxuICAgICAgICBpZiAoaW5saW5lICYmICRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlLmNvbnRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4dCA9ICRtbUZTLmdldEZpbGVFeHRlbnNpb24obW9kdWxlLmNvbnRlbnRzW2ldLmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ID09ICdqcycgfHwgZXh0ID09ICdzd2YnIHx8IGV4dCA9PSAnY3NzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlc291cmNlIGlzIHRvIGJlIGRpc3BsYXllZCBpbmxpbmUgKEhUTUwpLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZSNpc0Rpc3BsYXllZElubGluZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzRGlzcGxheWVkSW5saW5lID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIGlmICghbW9kdWxlLmNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHQgPSAkbW1GUy5nZXRGaWxlRXh0ZW5zaW9uKG1vZHVsZS5jb250ZW50c1swXS5maWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBleHQgPT09ICdodG0nIHx8IGV4dCA9PT0gJ2h0bWwnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGZpbGUgaXMgZG93bmxvYWRhYmxlLiBUaGUgZmlsZSBwYXJhbSBtdXN0IGhhdmUgYSAndHlwZScgYXR0cmlidXRlIGxpa2UgaW4gY29yZV9jb3Vyc2VfZ2V0X2NvbnRlbnRzIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZSNpc0ZpbGVEb3dubG9hZGFibGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZSBGaWxlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIFRydWUgaWYgZG93bmxvYWRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgIHJldHVybiBmaWxlLnR5cGUgPT09ICdmaWxlJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgcmVzb3VyY2UgcGx1Z2luIGlzIGVuYWJsZWQgaW4gYSBjZXJ0YWluIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlI2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIHBsdWdpbiBpcyBlbmFibGVkLCByZWplY3RlZCBvciByZXNvbHZlZCB3aXRoIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUuY2FuRG93bmxvYWRGaWxlcygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IHRoZSByZXNvdXJjZSBhcyBiZWluZyB2aWV3ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlI2xvZ1ZpZXdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgTW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ1ZpZXcgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2VpZDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX3Jlc291cmNlX3ZpZXdfcmVzb3VyY2UnLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgYW5kIG9wZW4gdGhlIGZpbGUgZnJvbSB0aGUgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlI29wZW5GaWxlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gY29udGVudHMgQXJyYXkgb2YgY29udGVudCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb2R1bGVJZCBUaGUgbW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5vcGVuRmlsZSA9IGZ1bmN0aW9uKGNvbnRlbnRzLCBtb2R1bGVJZCkge1xuICAgICAgICBpZiAoIWNvbnRlbnRzIHx8ICFjb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cmwgPSBjb250ZW50c1swXS5maWxldXJsLFxuICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgLy8gVGhlIGZpbGUgc3lzdGVtIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIHByb21pc2UgPSAkbW1GaWxlcG9vbC5kb3dubG9hZFVybCgkbW1TaXRlLmdldElkKCksIHVybCwgZmFsc2UsIG1tYU1vZFJlc291cmNlQ29tcG9uZW50LCBtb2R1bGVJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIGxpdmUgVVJMLlxuICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oJG1tU2l0ZS5maXhQbHVnaW5maWxlVVJMKHVybCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihsb2NhbFVybCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbVV0aWwub3BlbkZpbGUobG9jYWxVcmwpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlZmV0Y2ggdGhlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlI3ByZWZldGNoQ29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gY29udGVudCBpcyBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoQ29udGVudCA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBzZWxmLmdldERvd25sb2FkYWJsZUZpbGVzKG1vZHVsZSksXG4gICAgICAgICAgICBzaXRlaWQgPSAkbW1TaXRlLmdldElkKCksXG4gICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgcmV2aXNpb24gPSAkbW1GaWxlcG9vbC5nZXRSZXZpc2lvbkZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpLFxuICAgICAgICAgICAgdGltZW1vZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuXG4gICAgICAgIGlmIChzZWxmLmlzRGlzcGxheWVkSW5JZnJhbWUobW9kdWxlKSkge1xuICAgICAgICAgICAgLy8gR2V0IHBhdGggb2YgdGhlIG1vZHVsZSBmb2xkZXIgaW4gZmlsZXBvb2wuXG4gICAgICAgICAgICBwcm9taXNlID0gJG1tRmlsZXBvb2wuZ2V0RmlsZVBhdGhCeVVybChzaXRlaWQsIG1vZHVsZS51cmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGlyUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLnByZWZldGNoUGFja2FnZShzaXRlaWQsIGZpbGVzLCBtbWFNb2RSZXNvdXJjZUNvbXBvbmVudCwgbW9kdWxlLmlkLCByZXZpc2lvbiwgdGltZW1vZCwgZGlyUGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3Njb3JtJylcblxuLyoqXG4gKiBTQ09STSBpbmRleCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZFNjb3JtSW5kZXhDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RTY29ybUluZGV4Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1hTW9kU2Nvcm0sICRtbVV0aWwsICRxLCAkbW1Db3Vyc2UsICRpb25pY1Njcm9sbERlbGVnYXRlLFxuICAgICAgICAgICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSwgJG1tYU1vZFNjb3JtSGVscGVyLCAkbW1FdmVudHMsICRtbVNpdGUsICRzdGF0ZSwgbW1Db3JlT3V0ZGF0ZWQsIG1tQ29yZU5vdERvd25sb2FkZWQsXG4gICAgICAgICAgICBtbUNvcmVEb3dubG9hZGluZywgbW1hTW9kU2Nvcm1Db21wb25lbnQsIG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsICRpb25pY0hpc3RvcnksIG1tYU1vZFNjb3JtRXZlbnRBdXRvbVN5bmNlZCxcbiAgICAgICAgICAgICRtbWFNb2RTY29ybVN5bmMsICR0aW1lb3V0KSB7XG5cbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIHNjb3JtLFxuICAgICAgICBzdGF0dXNPYnNlcnZlcixcbiAgICAgICAgY3VycmVudFN0YXR1cyxcbiAgICAgICAgbGFzdEF0dGVtcHQsXG4gICAgICAgIGxhc3RPZmZsaW5lID0gZmFsc2UsXG4gICAgICAgIGF0dGVtcHRzLFxuICAgICAgICBzY3JvbGxWaWV3ID0gJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKCdtbWFNb2RTY29ybUluZGV4U2Nyb2xsJyk7XG5cbiAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBtb2R1bGUuZGVzY3JpcHRpb247XG4gICAgJHNjb3BlLm1vZHVsZVVybCA9IG1vZHVsZS51cmw7XG4gICAgJHNjb3BlLmN1cnJlbnRPcmdhbml6YXRpb24gPSB7fTtcbiAgICAkc2NvcGUuc2Nvcm1PcHRpb25zID0ge1xuICAgICAgICBtb2RlOiAkbW1hTW9kU2Nvcm0uTU9ERU5PUk1BTFxuICAgIH07XG5cbiAgICAkc2NvcGUubW9kZW5vcm1hbCA9ICRtbWFNb2RTY29ybS5NT0RFTk9STUFMO1xuICAgICRzY29wZS5tb2RlYnJvd3NlID0gJG1tYU1vZFNjb3JtLk1PREVCUk9XU0U7XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgU0NPUk0gZGF0YS5cbiAgICBmdW5jdGlvbiBmZXRjaFNjb3JtRGF0YShyZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm0oY291cnNlaWQsIG1vZHVsZS5pZCwgbW9kdWxlLnVybCkudGhlbihmdW5jdGlvbihzY29ybURhdGEpIHtcbiAgICAgICAgICAgIHNjb3JtID0gc2Nvcm1EYXRhO1xuXG4gICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBzY29ybS5uYW1lIHx8ICRzY29wZS50aXRsZTtcbiAgICAgICAgICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IHNjb3JtLmludHJvIHx8wqAkc2NvcGUuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAkc2NvcGUuc2Nvcm0gPSBzY29ybTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICRtbWFNb2RTY29ybS5pc1Njb3JtU3VwcG9ydGVkKHNjb3JtKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5lcnJvck1lc3NhZ2UgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY29ybS53YXJuaW5nbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gU0NPUk0gaXMgY2xvc2VkIG9yIG5vdCBvcGVuIHlldCwgd2UgY2FuJ3QgZ2V0IG1vcmUgZGF0YS5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN5bmNTY29ybSghcmVmcmVzaCwgZmFsc2UpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMsIGtlZXAgZ2V0dGluZyBkYXRhIGV2ZW4gaWYgc3luYyBmYWlscy5cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHJldHVybiB0aGlzIHByb21pc2UsIGl0IHNob3VsZCBiZSBmYXN0ZXIgdGhhbiB0aGUgcmVzdC5cbiAgICAgICAgICAgICAgICAkbW1hTW9kU2Nvcm1IZWxwZXIuZ2V0U2Nvcm1SZWFkYWJsZVN5bmNUaW1lKHNjb3JtLmlkKS50aGVuKGZ1bmN0aW9uKHN5bmNUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zeW5jVGltZSA9IHN5bmNUaW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgYW5kIGNoZWNrIGlmIFNDT1JNIGlzIGluY29tcGxldGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRBdHRlbXB0Q291bnQoc2Nvcm0uaWQpLnRoZW4oZnVuY3Rpb24oYXR0ZW1wdHNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzID0gYXR0ZW1wdHNEYXRhO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2hvd1N5bmNCdXR0b24gPSBhdHRlbXB0cy5vZmZsaW5lLmxlbmd0aDsgLy8gU2hvdyBzeW5jIGJ1dHRvbiBvbmx5IGlmIHRoZXJlIGFyZSBvZmZsaW5lIGF0dGVtcHRzLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgYXR0ZW1wdCB0aGF0IHdpbGwgYmUgY29udGludWVkIG9yIHJldmlld2VkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtSGVscGVyLmRldGVybWluZUF0dGVtcHRUb0NvbnRpbnVlKHNjb3JtLCBhdHRlbXB0cykudGhlbihmdW5jdGlvbihhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0QXR0ZW1wdCA9IGF0dGVtcHQubnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE9mZmxpbmUgPSBhdHRlbXB0Lm9mZmxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEF0dGVtcHQgIT0gYXR0ZW1wdHMubGFzdEF0dGVtcHQubnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmF0dGVtcHRUb0NvbnRpbnVlID0gbGFzdEF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSAkc2NvcGUuYXR0ZW1wdFRvQ29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uaXNBdHRlbXB0SW5jb21wbGV0ZShzY29ybS5pZCwgbGFzdEF0dGVtcHQsIGxhc3RPZmZsaW5lKS50aGVuKGZ1bmN0aW9uKGluY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JtLmluY29tcGxldGUgPSBpbmNvbXBsZXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JtLm51bUF0dGVtcHRzID0gYXR0ZW1wdHMudG90YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nvcm0uZ3JhZGVtZXRob2RSZWFkYWJsZSA9ICRtbWFNb2RTY29ybS5nZXRTY29ybUdyYWRlTWV0aG9kKHNjb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29ybS5hdHRlbXB0c0xlZnQgPSAkbW1hTW9kU2Nvcm0uY291bnRBdHRlbXB0c0xlZnQoc2Nvcm0sIGF0dGVtcHRzLmxhc3RBdHRlbXB0Lm51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3JtLmZvcmNlYXR0ZW1wdCAmJiBzY29ybS5pbmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zY29ybU9wdGlvbnMubmV3QXR0ZW1wdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChnZXRSZXBvcnRlZEdyYWRlcygpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZmV0Y2hTdHJ1Y3R1cmUoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3JtLnBhY2thZ2VzaXplICYmICRzY29wZS5lcnJvck1lc3NhZ2UgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNDT1JNIGlzIHN1cHBvcnRlZCBidXQgd2UgZG9uJ3QgaGF2ZSBwYWNrYWdlIHNpemUuIFRyeSB0byBjYWxjdWxhdGUgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtLmNhbGN1bGF0ZVNjb3JtU2l6ZShzY29ybSkudGhlbihmdW5jdGlvbihzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29ybS5wYWNrYWdlc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgc3RhdHVzLiBXZSBkb24ndCBhZGQgZ2V0U3RhdHVzIHRvIHByb21pc2VzIGJlY2F1c2UgaXQgc2hvdWxkIGJlIGZhc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGF0dXMoKS50aGVuKHNob3dTdGF0dXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvd0Vycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoIXJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgc2Nvcm0gZmFpbGVkLCByZXRyeSB3aXRob3V0IHVzaW5nIGNhY2hlIHNpbmNlIGl0IG1pZ2h0IGJlIGEgbmV3IGFjdGl2aXR5LlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZyZXNoRGF0YSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNob3dFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2hvdyBlcnJvciBtZXNzYWdlIGFuZCByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlLlxuICAgIGZ1bmN0aW9uIHNob3dFcnJvcihtZXNzYWdlLCBkZWZhdWx0TWVzc2FnZSkge1xuICAgICAgICBkZWZhdWx0TWVzc2FnZSA9IGRlZmF1bHRNZXNzYWdlIHx8wqAnbW1hLm1vZF9zY29ybS5lcnJvcmdldHNjb3JtJztcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGRlZmF1bHRNZXNzYWdlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBncmFkZXMgb2YgZWFjaCBhdHRlbXB0IGFuZCB0aGUgZ3JhZGUgb2YgdGhlIFNDT1JNLlxuICAgIGZ1bmN0aW9uIGdldFJlcG9ydGVkR3JhZGVzKCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgc2Nvcm0ub25saW5lQXR0ZW1wdHMgPSB7fTtcbiAgICAgICAgc2Nvcm0ub2ZmbGluZUF0dGVtcHRzID0ge307XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZ3JhZGUgZm9yIGVhY2ggYXR0ZW1wdC5cbiAgICAgICAgYXR0ZW1wdHMub25saW5lLmZvckVhY2goZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBhdHRlbXB0IGlzbid0IGluIG9mZmxpbmUgdG8gcHJldmVudCBzaG93aW5nIHRoZSBzYW1lIGF0dGVtcHQgdHdpY2UuIE9mZmxpbmUgc2hvdWxkIGJlIG1vcmUgcmVjZW50LlxuICAgICAgICAgICAgaWYgKGF0dGVtcHRzLm9mZmxpbmUuaW5kZXhPZihhdHRlbXB0KSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZ2V0QXR0ZW1wdEdyYWRlKHNjb3JtLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhdHRlbXB0cy5vZmZsaW5lLmZvckVhY2goZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChnZXRBdHRlbXB0R3JhZGUoc2Nvcm0sIGF0dGVtcHQsIHRydWUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBncmFkZSBvZiB0aGUgd2hvbGUgU0NPUk0uIFdlIG9ubHkgdXNlIG9ubGluZSBhdHRlbXB0cyB0byBjYWxjdWxhdGUgdGhpcyBkYXRhLlxuICAgICAgICAgICAgc2Nvcm0uZ3JhZGUgPSAkbW1hTW9kU2Nvcm0uY2FsY3VsYXRlU2Nvcm1HcmFkZShzY29ybSwgc2Nvcm0ub25saW5lQXR0ZW1wdHMpO1xuXG4gICAgICAgICAgICAvLyBOb3cgZm9ybWF0IHRoZSBncmFkZXMuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2Nvcm0ub25saW5lQXR0ZW1wdHMsIGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0LmdyYWRlID0gJG1tYU1vZFNjb3JtLmZvcm1hdEdyYWRlKHNjb3JtLCBhdHRlbXB0LmdyYWRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjb3JtLm9mZmxpbmVBdHRlbXB0cywgZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIGF0dGVtcHQuZ3JhZGUgPSAkbW1hTW9kU2Nvcm0uZm9ybWF0R3JhZGUoc2Nvcm0sIGF0dGVtcHQuZ3JhZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY29ybS5ncmFkZSA9ICRtbWFNb2RTY29ybS5mb3JtYXRHcmFkZShzY29ybSwgc2Nvcm0uZ3JhZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIGdyYWRlIG9mIGFuIGF0dGVtcHQgYW5kIGFkZCBpdCB0byB0aGUgc2Nvcm0gYXR0ZW1wdHMgbGlzdC5cbiAgICBmdW5jdGlvbiBnZXRBdHRlbXB0R3JhZGUoc2Nvcm0sIGF0dGVtcHQsIG9mZmxpbmUpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRBdHRlbXB0R3JhZGUoc2Nvcm0sIGF0dGVtcHQsIG9mZmxpbmUpLnRoZW4oZnVuY3Rpb24oZ3JhZGUpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IGF0dGVtcHQsXG4gICAgICAgICAgICAgICAgZ3JhZGU6IGdyYWRlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICBzY29ybS5vZmZsaW5lQXR0ZW1wdHNbYXR0ZW1wdF0gPSBlbnRyeTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nvcm0ub25saW5lQXR0ZW1wdHNbYXR0ZW1wdF0gPSBlbnRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggdGhlIHN0cnVjdHVyZSBvZiB0aGUgU0NPUk0gKFRPQykuXG4gICAgZnVuY3Rpb24gZmV0Y2hTdHJ1Y3R1cmUoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0T3JnYW5pemF0aW9ucyhzY29ybS5pZCkudGhlbihmdW5jdGlvbihvcmdhbml6YXRpb25zKSB7XG4gICAgICAgICAgICAkc2NvcGUub3JnYW5pemF0aW9ucyA9IG9yZ2FuaXphdGlvbnM7XG5cbiAgICAgICAgICAgIGlmICghJHNjb3BlLmN1cnJlbnRPcmdhbml6YXRpb24uaWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIC8vIExvYWQgZmlyc3Qgb3JnYW5pemF0aW9uIChpZiBhbnkpLlxuICAgICAgICAgICAgICAgIGlmIChvcmdhbml6YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY3VycmVudE9yZ2FuaXphdGlvbi5pZGVudGlmaWVyID0gb3JnYW5pemF0aW9uc1swXS5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jdXJyZW50T3JnYW5pemF0aW9uLmlkZW50aWZpZXIgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsb2FkT3JnYW5pemF0aW9uVG9jKCRzY29wZS5jdXJyZW50T3JnYW5pemF0aW9uLmlkZW50aWZpZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBMb2FkIHRoZSBUT0Mgb2YgYSBjZXJ0YWluIG9yZ2FuaXphdGlvbi5cbiAgICBmdW5jdGlvbiBsb2FkT3JnYW5pemF0aW9uVG9jKG9yZ2FuaXphdGlvbklkKSB7XG4gICAgICAgIGlmICghc2Nvcm0uZGlzcGxheWNvdXJzZXN0cnVjdHVyZSkge1xuICAgICAgICAgICAgLy8gVE9DIGlzIG5vdCBkaXNwbGF5ZWQsIG5vIG5lZWQgdG8gbG9hZCBpdC5cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAkc2NvcGUubG9hZGluZ1RvYyA9IHRydWU7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0T3JnYW5pemF0aW9uVG9jKHNjb3JtLmlkLCBvcmdhbml6YXRpb25JZCwgbGFzdEF0dGVtcHQsIGxhc3RPZmZsaW5lKS50aGVuKGZ1bmN0aW9uKHRvYykge1xuICAgICAgICAgICAgJHNjb3BlLnRvYyA9ICRtbWFNb2RTY29ybS5mb3JtYXRUb2NUb0FycmF5KHRvYyk7XG4gICAgICAgICAgICAvLyBHZXQgaW1hZ2VzIGZvciBlYWNoIFNDTy5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUudG9jLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICBzY28uaW1hZ2UgPSAkbW1hTW9kU2Nvcm0uZ2V0U2NvU3RhdHVzSWNvbihzY28sIHNjb3JtLmluY29tcGxldGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTZWFyY2ggb3JnYW5pemF0aW9uIHRpdGxlLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5vcmdhbml6YXRpb25zLCBmdW5jdGlvbihvcmcpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JnLmlkZW50aWZpZXIgPT0gb3JnYW5pemF0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmN1cnJlbnRPcmdhbml6YXRpb24udGl0bGUgPSBvcmcudGl0bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBSZXNpemUgc2Nyb2xsIHRvIHByZXZlbnQgZW1wdHkgc3BhY2VzIGlmIG5ldyBUT0MgaXMgc2hvcnRlciB0aGFuIHByZXZpb3VzIFRPQy5cbiAgICAgICAgICAgICRpb25pY1Njcm9sbERlbGVnYXRlLnJlc2l6ZSgpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmxvYWRpbmdUb2MgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHN0YXR1cyBvZiB0aGUgU0NPUk0uXG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5nZXRNb2R1bGVTdGF0dXMobW9kdWxlLCBjb3Vyc2VpZCwgc2Nvcm0uc2hhMWhhc2gsIDApO1xuICAgIH1cblxuICAgIC8vIFNldCBhIGxpc3RlbmVyIHRvIG1vbml0b3IgY2hhbmdlcyBvbiB0aGlzIFNDT1JNIHN0YXR1cyB0byBzaG93IGEgbWVzc2FnZSB0byB0aGUgdXNlci5cbiAgICBmdW5jdGlvbiBzZXRTdGF0dXNMaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0dXNPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gQWxyZWFkeSBzZXQuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhpcyBtb2R1bGUgc3RhdHVzIHRvIHNob3cgYSBtZXNzYWdlIHRvIHRoZSB1c2VyLlxuICAgICAgICBzdGF0dXNPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5zaXRlaWQgPT09ICRtbVNpdGUuZ2V0SWQoKSAmJiBkYXRhLmNvbXBvbmVudElkID09PSBzY29ybS5jb3Vyc2Vtb2R1bGUgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jb21wb25lbnQgPT09IG1tYU1vZFNjb3JtQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgc2hvd1N0YXR1cyhkYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNob3dpbmcgb3IgaGlkZSBhIHN0YXR1cyBtZXNzYWdlIGRlcGVuZGluZyBvbiB0aGUgU0NPUk0gc3RhdHVzLlxuICAgIGZ1bmN0aW9uIHNob3dTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGN1cnJlbnRTdGF0dXMgPSBzdGF0dXM7XG5cbiAgICAgICAgaWYgKHN0YXR1cyA9PSBtbUNvcmVPdXRkYXRlZCkge1xuICAgICAgICAgICAgJHNjb3BlLnN0YXR1c01lc3NhZ2UgPSAnbW1hLm1vZF9zY29ybS5zY29ybXN0YXR1c291dGRhdGVkJztcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gbW1Db3JlTm90RG93bmxvYWRlZCkge1xuICAgICAgICAgICAgJHNjb3BlLnN0YXR1c01lc3NhZ2UgPSAnbW1hLm1vZF9zY29ybS5zY29ybXN0YXR1c25vdGRvd25sb2FkZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PSBtbUNvcmVEb3dubG9hZGluZykge1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuZG93bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGJlaW5nIGRvd25sb2FkZWQgcmlnaHQgbm93IGJ1dCB0aGUgdmlldyBpc24ndCB0cmFja2luZyBpdC4gXCJSZXN0b3JlXCIgdGhlIGRvd25sb2FkLlxuICAgICAgICAgICAgICAgIGRvd25sb2FkU2Nvcm1QYWNrYWdlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnN0YXR1c01lc3NhZ2UgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlZnJlc2hlcyBkYXRhLlxuICAgIGZ1bmN0aW9uIHJlZnJlc2hEYXRhKGRvbnRGb3JjZVN5bmMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtLmludmFsaWRhdGVTY29ybURhdGEoY291cnNlaWQpKTtcbiAgICAgICAgaWYgKHNjb3JtKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RTY29ybS5pbnZhbGlkYXRlQWxsU2Nvcm1EYXRhKHNjb3JtLmlkKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoU2Nvcm1EYXRhKCFkb250Rm9yY2VTeW5jKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRG93bmxvYWQgYSBTQ09STSBwYWNrYWdlIG9yIHJlc3RvcmVzIGFuIG9uZ29pbmcgZG93bmxvYWQuXG4gICAgZnVuY3Rpb24gZG93bmxvYWRTY29ybVBhY2thZ2UoKSB7XG4gICAgICAgICRzY29wZS5kb3dubG9hZGluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZG93bmxvYWQoc2Nvcm0pLnRoZW4odW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG5cbiAgICAgICAgICAgIGlmICghcHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcy5wYWNrYWdlRG93bmxvYWQpIHsgLy8gRG93bmxvYWRpbmcgcGFja2FnZS5cbiAgICAgICAgICAgICAgICBpZiAoc2Nvcm0ucGFja2FnZXNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnBlcmNlbnRhZ2UgPSAocGFyc2VGbG9hdChwcm9ncmVzcy5sb2FkZWQgLyBzY29ybS5wYWNrYWdlc2l6ZSkgKiAxMDApLnRvRml4ZWQoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcy5tZXNzYWdlKSB7IC8vIFNob3cgYSBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICRzY29wZS5wcm9ncmVzc01lc3NhZ2UgPSBwcm9ncmVzcy5tZXNzYWdlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcy5sb2FkZWQgJiYgcHJvZ3Jlc3MudG90YWwpIHsgLy8gVW56aXBwaW5nIHBhY2thZ2UuXG4gICAgICAgICAgICAgICAgJHNjb3BlLnBlcmNlbnRhZ2UgPSAocGFyc2VGbG9hdChwcm9ncmVzcy5sb2FkZWQgLyBwcm9ncmVzcy50b3RhbCkgKiAxMDApLnRvRml4ZWQoMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5wZXJjZW50YWdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUucHJvZ3Jlc3NNZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgJHNjb3BlLnBlcmNlbnRhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAkc2NvcGUuZG93bmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3BlbiBhIFNDT1JNIHBhY2thZ2UuXG4gICAgZnVuY3Rpb24gb3BlblNjb3JtKHNjb0lkKSB7XG4gICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2Rfc2Nvcm0tcGxheWVyJywge1xuICAgICAgICAgICAgc2Nvcm06IHNjb3JtLFxuICAgICAgICAgICAgbW9kZTogJHNjb3BlLnNjb3JtT3B0aW9ucy5tb2RlLFxuICAgICAgICAgICAgbmV3QXR0ZW1wdDogISEkc2NvcGUuc2Nvcm1PcHRpb25zLm5ld0F0dGVtcHQsXG4gICAgICAgICAgICBvcmdhbml6YXRpb25JZDogJHNjb3BlLmN1cnJlbnRPcmdhbml6YXRpb24uaWRlbnRpZmllcixcbiAgICAgICAgICAgIHNjb0lkOiBzY29JZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUcmllcyB0byBzeW5jaHJvbml6ZSB0aGUgY3VycmVudCBTQ09STS5cbiAgICBmdW5jdGlvbiBzeW5jU2Nvcm0oY2hlY2tUaW1lLCBzaG93RXJyb3JzKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gY2hlY2tUaW1lID8gJG1tYU1vZFNjb3JtU3luYy5zeW5jU2Nvcm1JZk5lZWRlZChzY29ybSkgOiAkbW1hTW9kU2Nvcm1TeW5jLnN5bmNTY29ybShzY29ybSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24od2FybmluZ3MpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gJG1tYU1vZFNjb3JtSGVscGVyLmJ1aWxkV2FybmluZ3NNZXNzYWdlKHdhcm5pbmdzKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZiAoc2hvd0Vycm9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaG93RXJyb3IoZXJyLCAnbW1hLm1vZF9zY29ybS5lcnJvcnN5bmNzY29ybScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGZXRjaCB0aGUgU0NPUk0gZGF0YS5cbiAgICBmZXRjaFNjb3JtRGF0YSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNb2RTY29ybS5sb2dWaWV3KHNjb3JtLmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuc2Nvcm1Mb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gTG9hZCBhIG9yZ2FuaXphdGlvbidzIFRPQy5cbiAgICAkc2NvcGUubG9hZE9yZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkT3JnYW5pemF0aW9uVG9jKCRzY29wZS5jdXJyZW50T3JnYW5pemF0aW9uLmlkZW50aWZpZXIpLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG93RXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUucmVmcmVzaFNjb3JtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZnJlc2hEYXRhKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBPcGVuIGEgU0NPUk0uIEl0IHdpbGwgZG93bmxvYWQgdGhlIFNDT1JNIHBhY2thZ2UgaWYgaXQncyBub3QgZG93bmxvYWRlZCBvciBpdCBoYXMgY2hhbmdlZC5cbiAgICAvLyBUaGUgc2NvSWQgcGFyYW0gaW5kaWNhdGVzIHRoZSBTQ08gdGhhdCBuZWVkcyB0byBiZSBsb2FkZWQgd2hlbiB0aGUgU0NPUk0gaXMgb3BlbmVkLiBJZiBub3QgZGVmaW5lZCwgbG9hZCBmaXJzdCBTQ08uXG4gICAgJHNjb3BlLm9wZW4gPSBmdW5jdGlvbihlLCBzY29JZCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKCRzY29wZS5kb3dubG9hZGluZykge1xuICAgICAgICAgICAgLy8gU2NvcGUgaXMgYmVpbmcgZG93bmxvYWRlZCwgYWJvcnQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudFN0YXR1cyA9PSBtbUNvcmVPdXRkYXRlZCB8fCBjdXJyZW50U3RhdHVzID09IG1tQ29yZU5vdERvd25sb2FkZWQpIHtcbiAgICAgICAgICAgIC8vIFNDT1JNIG5lZWRzIHRvIGJlIGRvd25sb2FkZWQuXG4gICAgICAgICAgICAkbW1hTW9kU2Nvcm1IZWxwZXIuY29uZmlybURvd25sb2FkKHNjb3JtKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgZmlsZSBpZiBTQ09STSBpcyBvdXRkYXRlZC5cbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGN1cnJlbnRTdGF0dXMgPT0gbW1Db3JlT3V0ZGF0ZWQgPyAkbW1hTW9kU2Nvcm0uaW52YWxpZGF0ZUNvbnRlbnQoc2Nvcm0uY291cnNlbW9kdWxlKSA6ICRxLndoZW4oKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkU2Nvcm1QYWNrYWdlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MgZG93bmxvYWRpbmcsIG9wZW4gc2Nvcm0gaWYgdXNlciBoYXNuJ3QgbGVmdCB0aGUgdmlldy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlblNjb3JtKHNjb0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJGRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RTY29ybUhlbHBlci5zaG93RG93bmxvYWRFcnJvcihzY29ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcGVuU2Nvcm0oc2NvSWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFN5bmNocm9uaXplIHRoZSBTQ09STS5cbiAgICAkc2NvcGUuc3luYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tLnNldHRpbmdzLnN5bmNocm9uaXppbmcnLCB0cnVlKTtcbiAgICAgICAgc3luY1Njb3JtKGZhbHNlLCB0cnVlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmVmcmVzaCB0aGUgZGF0YS5cbiAgICAgICAgICAgICRzY29wZS5zY29ybUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2Nyb2xsVmlldy5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIHJlZnJlc2hEYXRhKHRydWUpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNjb3JtTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIGRhdGEgd2hlbiB3ZSBjb21lIGJhY2sgZnJvbSB0aGUgcGxheWVyIHNpbmNlIGl0J3MgcHJvYmFibGUgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbiAgICAvLyBXZSB3YW50IHRvIHNraXAgdGhlIGZpcnN0ICRpb25pY1ZpZXcuZW50ZXIgZXZlbnQgYmVjYXVzZSBpdCdzIHdoZW4gdGhlIHZpZXcgaXMgY3JlYXRlZC5cbiAgICB2YXIgc2tpcCA9IHRydWU7XG4gICAgJHNjb3BlLiRvbignJGlvbmljVmlldy5lbnRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJHNjb3BlLnNjb3JtT3B0aW9ucy5uZXdBdHRlbXB0ID0gZmFsc2U7IC8vIFVuY2hlY2sgbmV3IGF0dGVtcHQuXG5cbiAgICAgICAgdmFyIGZvcndhcmRWaWV3ID0gJGlvbmljSGlzdG9yeS5mb3J3YXJkVmlldygpO1xuICAgICAgICBpZiAoZm9yd2FyZFZpZXcgJiYgZm9yd2FyZFZpZXcuc3RhdGVOYW1lID09PSAnc2l0ZS5tb2Rfc2Nvcm0tcGxheWVyJykge1xuICAgICAgICAgICAgJHNjb3BlLnNjb3JtTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzY3JvbGxWaWV3LnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgLy8gQWRkIGEgZGVsYXkgdG8gbWFrZSBzdXJlIHRoZSBwbGF5ZXIgaGFzIHN0YXJ0ZWQgdGhlIGxhc3Qgd3JpdGluZyBjYWxscyBzbyB3ZSBjYW4gZGV0ZWN0IGNvbmZsaWN0cy5cbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJlZnJlc2hEYXRhKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNjb3JtTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlZnJlc2ggZGF0YSBpZiB0aGlzIFNDT1JNIGlzIHN5bmNocm9uaXplZCBhdXRvbWF0aWNhbGx5LlxuICAgIHZhciBzeW5jT2JzZXJ2ZXIgPSAkbW1FdmVudHMub24obW1hTW9kU2Nvcm1FdmVudEF1dG9tU3luY2VkLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEuc2l0ZWlkID09ICRtbVNpdGUuZ2V0SWQoKSAmJiBkYXRhLnNjb3JtaWQgPT0gc2Nvcm0uaWQpIHtcbiAgICAgICAgICAgICRzY29wZS5zY29ybUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2Nyb2xsVmlldy5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIGZldGNoU2Nvcm1EYXRhKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2Nvcm1Mb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0YXR1c09ic2VydmVyICYmIHN0YXR1c09ic2VydmVyLm9mZiAmJiBzdGF0dXNPYnNlcnZlci5vZmYoKTtcbiAgICAgICAgc3luY09ic2VydmVyICYmIHN5bmNPYnNlcnZlci5vZmYgJiYgc3luY09ic2VydmVyLm9mZigpO1xuICAgIH0pO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2Rfc2Nvcm0nKVxuXG4vKipcbiAqIFNDT1JNIHBsYXllciBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZFNjb3JtUGxheWVyQ3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kU2Nvcm1QbGF5ZXJDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbWFNb2RTY29ybSwgJG1tVXRpbCwgJGlvbmljUG9wb3ZlciwgJG1tYU1vZFNjb3JtSGVscGVyLFxuICAgICAgICAgICAgJG1tRXZlbnRzLCAkdGltZW91dCwgJHEsIG1tYU1vZFNjb3JtRXZlbnRVcGRhdGVUb2MsIG1tYU1vZFNjb3JtRXZlbnRMYXVuY2hOZXh0U2NvLCBtbWFNb2RTY29ybUV2ZW50TGF1bmNoUHJldlNjbyxcbiAgICAgICAgICAgICRtbWFNb2RTY29ybURhdGFNb2RlbDEyLCBtbWFNb2RTY29ybUV2ZW50R29PZmZsaW5lLCAkbW1hTW9kU2Nvcm1TeW5jKSB7XG5cbiAgICB2YXIgc2Nvcm0gPSAkc3RhdGVQYXJhbXMuc2Nvcm0gfHwge30sXG4gICAgICAgIG1vZGUgPSAkc3RhdGVQYXJhbXMubW9kZSB8fCAkbW1hTW9kU2Nvcm0uTU9ERU5PUk1BTCxcbiAgICAgICAgbmV3QXR0ZW1wdCA9ICRzdGF0ZVBhcmFtcy5uZXdBdHRlbXB0LFxuICAgICAgICBvcmdhbml6YXRpb25JZCA9ICRzdGF0ZVBhcmFtcy5vcmdhbml6YXRpb25JZCxcbiAgICAgICAgY3VycmVudFNjbyxcbiAgICAgICAgYXR0ZW1wdCxcbiAgICAgICAgdXNlckRhdGEsXG4gICAgICAgIGFwaUluaXRpYWxpemVkID0gZmFsc2UsXG4gICAgICAgIG9mZmxpbmUgPSBmYWxzZTtcblxuICAgICRzY29wZS50aXRsZSA9IHNjb3JtLm5hbWU7IC8vIFdlIHVzZSBTQ09STSBuYW1lIGF0IHN0YXJ0LCBsYXRlciB3ZSdsbCB1c2UgdGhlIFNDTyB0aXRsZS5cbiAgICAkc2NvcGUuc2Nvcm0gPSBzY29ybTtcbiAgICAkc2NvcGUubG9hZGluZ1RvYyA9IHRydWU7XG5cbiAgICBpZiAoc2Nvcm0ucG9wdXApIHtcbiAgICAgICAgLy8gSWYgd2UgcmVjZWl2ZSBhIHZhbHVlIDw9IDEwMCB3ZSBuZWVkIHRvIGFzc3VtZSBpdCdzIGEgcGVyY2VudGFnZS5cbiAgICAgICAgaWYgKHNjb3JtLndpZHRoIDw9IDEwMCkge1xuICAgICAgICAgICAgc2Nvcm0ud2lkdGggPSBzY29ybS53aWR0aCArICclJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nvcm0uaGVpZ2h0IDw9IDEwMCkge1xuICAgICAgICAgICAgc2Nvcm0uaGVpZ2h0ID0gc2Nvcm0uaGVpZ2h0ICsgJyUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggZGF0YSBuZWVkZWQgdG8gcGxheSB0aGUgU0NPUk0uXG4gICAgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xuICAgICAgICAvLyBXYWl0IGZvciBhbnkgb25nb2luZyBzeW5jIHRvIGZpbmlzaC4gV2Ugd29uJ3Qgc3luYyBhIFNDT1JNIHdoaWxlIGl0J3MgYmVpbmcgcGxheWVkLlxuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtU3luYy53YWl0Rm9yU3luYyhzY29ybS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEdldCBhdHRlbXB0cyBkYXRhLlxuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRBdHRlbXB0Q291bnQoc2Nvcm0uaWQpLnRoZW4oZnVuY3Rpb24oYXR0ZW1wdHNEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRldGVybWluZUF0dGVtcHRBbmRNb2RlKGF0dGVtcHRzRGF0YSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggVE9DIGFuZCBnZXQgdXNlciBkYXRhLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChmZXRjaFRvYygpKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm1Vc2VyRGF0YShzY29ybS5pZCwgYXR0ZW1wdCwgb2ZmbGluZSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKHNob3dFcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSB0aGUgYXR0ZW1wdCB0byB1c2UsIHRoZSBtb2RlIChub3JtYWwvcHJldmlldykgYW5kIGlmIGl0J3Mgb2ZmbGluZSBvciBvbmxpbmUuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lQXR0ZW1wdEFuZE1vZGUoYXR0ZW1wdHNEYXRhKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1IZWxwZXIuZGV0ZXJtaW5lQXR0ZW1wdFRvQ29udGludWUoc2Nvcm0sIGF0dGVtcHRzRGF0YSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBhdHRlbXB0ID0gZGF0YS5udW1iZXI7XG4gICAgICAgICAgICBvZmZsaW5lID0gZGF0YS5vZmZsaW5lO1xuICAgICAgICAgICAgaWYgKGF0dGVtcHQgIT0gYXR0ZW1wdHNEYXRhLmxhc3RBdHRlbXB0Lm51bWJlcikge1xuICAgICAgICAgICAgICAgICRzY29wZS5hdHRlbXB0VG9Db250aW51ZSA9IGF0dGVtcHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgYXR0ZW1wdCBpcyBpbmNvbXBsZXRlLlxuICAgICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJG1tYU1vZFNjb3JtLmlzQXR0ZW1wdEluY29tcGxldGUoc2Nvcm0uaWQsIGF0dGVtcHQsIG9mZmxpbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIGRvZXNuJ3QgaGF2ZSBhdHRlbXB0cy4gTGFzdCBhdHRlbXB0IGlzIG5vdCBpbmNvbXBsZXRlIChzaW5jZSBoZSBkb2Vzbid0IGhhdmUgYW55KS5cbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBtb2RlIGFuZCBhdHRlbXB0IHRvIHVzZS5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gJG1tYU1vZFNjb3JtLmRldGVybWluZUF0dGVtcHRBbmRNb2RlKHNjb3JtLCBtb2RlLCBhdHRlbXB0LCBuZXdBdHRlbXB0LCBpbmNvbXBsZXRlKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuYXR0ZW1wdCA+IGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgY3JlYXRpbmcgYSBuZXcgYXR0ZW1wdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhc3QgYXR0ZW1wdCB3YXMgb2ZmbGluZSwgc28gd2UnbGwgY3JlYXRlIGEgbmV3IG9mZmxpbmUgYXR0ZW1wdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1hTW9kU2Nvcm1IZWxwZXIuY3JlYXRlT2ZmbGluZUF0dGVtcHQoc2Nvcm0sIHJlc3VsdC5hdHRlbXB0LCBhdHRlbXB0c0RhdGEub25saW5lLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXN0IGF0dGVtcHQgd2FzIG9ubGluZSwgdmVyaWZ5IHRoYXQgd2UgY2FuIGNyZWF0ZSBhIG5ldyBvbmxpbmUgYXR0ZW1wdC4gV2UgaWdub3JlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRtbWFNb2RTY29ybS5nZXRTY29ybVVzZXJEYXRhKHNjb3JtLmlkLCByZXN1bHQuYXR0ZW1wdCwgZmFsc2UsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbm5vdCBjb21tdW5pY2F0ZSB3aXRoIHRoZSBzZXJ2ZXIsIGNyZWF0ZSBhbiBvZmZsaW5lIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybUhlbHBlci5jcmVhdGVPZmZsaW5lQXR0ZW1wdChzY29ybSwgcmVzdWx0LmF0dGVtcHQsIGF0dGVtcHRzRGF0YS5vbmxpbmUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gcmVzdWx0Lm1vZGU7XG4gICAgICAgICAgICAgICAgICAgIG5ld0F0dGVtcHQgPSByZXN1bHQubmV3QXR0ZW1wdDtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCA9IHJlc3VsdC5hdHRlbXB0O1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaXNCcm93c2UgPSBtb2RlID09PSAkbW1hTW9kU2Nvcm0uTU9ERUJST1dTRTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmlzUmV2aWV3ID0gbW9kZSA9PT0gJG1tYU1vZFNjb3JtLk1PREVSRVZJRVc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2hvdyBlcnJvciBhbmQgcmVqZWN0LlxuICAgIGZ1bmN0aW9uIHNob3dFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9zY29ybS5lcnJvcmdldHNjb3JtJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH1cblxuICAgIC8vIEZldGNoIFRPQy5cbiAgICBmdW5jdGlvbiBmZXRjaFRvYygpIHtcbiAgICAgICAgJHNjb3BlLmxvYWRpbmdUb2MgPSB0cnVlO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGluY29tcGxldGUgYWdhaW46IGF0dGVtcHQgbnVtYmVyIG1pZ2h0IGhhdmUgY2hhbmdlZCBpbiBkZXRlcm1pbmVBdHRlbXB0QW5kTW9kZSxcbiAgICAgICAgLy8gb3IgYXR0ZW1wdCBzdGF0dXMgbWlnaHQgaGF2ZSBjaGFuZ2VkIGR1ZSB0byBhbiBhY3Rpb24gaW4gdGhlIGN1cnJlbnQgU0NPLlxuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmlzQXR0ZW1wdEluY29tcGxldGUoc2Nvcm0uaWQsIGF0dGVtcHQsIG9mZmxpbmUpLnRoZW4oZnVuY3Rpb24oaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgc2Nvcm0uaW5jb21wbGV0ZSA9IGluY29tcGxldGU7XG5cbiAgICAgICAgICAgIC8vIEdldCBUT0MuXG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldE9yZ2FuaXphdGlvblRvYyhzY29ybS5pZCwgb3JnYW5pemF0aW9uSWQsIGF0dGVtcHQsIG9mZmxpbmUpLnRoZW4oZnVuY3Rpb24odG9jKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRvYyA9ICRtbWFNb2RTY29ybS5mb3JtYXRUb2NUb0FycmF5KHRvYyk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGltYWdlcyBmb3IgZWFjaCBTQ08uXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS50b2MsIGZ1bmN0aW9uKHNjbykge1xuICAgICAgICAgICAgICAgICAgICBzY28uaW1hZ2UgPSAkbW1hTW9kU2Nvcm0uZ2V0U2NvU3RhdHVzSWNvbihzY28sIHNjb3JtLmluY29tcGxldGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBjdXJyZW50IFNDTyBpZiBwYXJhbSBpcyBzZXQuXG4gICAgICAgICAgICAgICAgaWYgKCRzdGF0ZVBhcmFtcy5zY29JZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU0NPIHNldCBieSBwYXJhbWV0ZXIsIGdldCBpdCBmcm9tIFRPQy5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjbyA9ICRtbWFNb2RTY29ybUhlbHBlci5nZXRTY29Gcm9tVG9jKCRzY29wZS50b2MsICRzdGF0ZVBhcmFtcy5zY29JZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50U2NvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIFNDTyBkZWZpbmVkLiBHZXQgdGhlIGZpcnN0IHZhbGlkIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybUhlbHBlci5nZXRGaXJzdFNjbyhzY29ybS5pZCwgJHNjb3BlLnRvYywgb3JnYW5pemF0aW9uSWQsIGF0dGVtcHQsIG9mZmxpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjbyA9IHNjbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY291bGRuJ3QgZmluZCBhIFNDTyB0byBsb2FkOiB0aGV5J3JlIGFsbCBpbmFjdGl2ZSBvciB3aXRob3V0IGxhdW5jaCBVUkwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVycm9yTWVzc2FnZSA9ICdtbWEubW9kX3Njb3JtLmVycm9ybm92YWxpZHNjbyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmxvYWRpbmdUb2MgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXh0IGFuZCBwcmV2aW91cyBTQ08uXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlTmV4dEFuZFByZXZpb3VzU2NvKHNjb0lkKSB7XG4gICAgICAgICRzY29wZS5wcmV2aW91c1NjbyA9ICRtbWFNb2RTY29ybUhlbHBlci5nZXRQcmV2aW91c1Njb0Zyb21Ub2MoJHNjb3BlLnRvYywgc2NvSWQpO1xuICAgICAgICAkc2NvcGUubmV4dFNjbyA9ICRtbWFNb2RTY29ybUhlbHBlci5nZXROZXh0U2NvRnJvbVRvYygkc2NvcGUudG9jLCBzY29JZCk7XG4gICAgfVxuXG4gICAgLy8gTG9hZCBhIFNDTy5cbiAgICBmdW5jdGlvbiBsb2FkU2NvKHNjbykge1xuICAgICAgICAvLyBTZXR1cCBBUEkuXG4gICAgICAgIGlmICghYXBpSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICRtbWFNb2RTY29ybURhdGFNb2RlbDEyLmluaXRBUEkoc2Nvcm0sIHNjby5pZCwgYXR0ZW1wdCwgdXNlckRhdGEsIG1vZGUsIG9mZmxpbmUpO1xuICAgICAgICAgICAgYXBpSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJG1tYU1vZFNjb3JtRGF0YU1vZGVsMTIubG9hZFNjbyhzY28uaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFNjbyA9IHNjbztcbiAgICAgICAgJHNjb3BlLnRpdGxlID0gc2NvLnRpdGxlIHx8IHNjb3JtLm5hbWU7IC8vIFRyeSB0byB1c2UgU0NPIHRpdGxlLlxuICAgICAgICBjYWxjdWxhdGVOZXh0QW5kUHJldmlvdXNTY28oc2NvLmlkKTtcbiAgICAgICAgJG1tYU1vZFNjb3JtLmdldFNjb1NyYyhzY29ybSwgc2NvKS50aGVuKGZ1bmN0aW9uKHNyYykge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5zcmMgJiYgc3JjLnRvU3RyaW5nKCkgPT0gJHNjb3BlLnNyYy50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmUtbG9hZGluZyBzYW1lIHBhZ2UuIFNldCBpdCB0byBlbXB0eSBhbmQgdGhlbiByZS1zZXQgdGhlIHNyYyBpbiB0aGUgbmV4dCBkaWdlc3Qgc28gaXQgZGV0ZWN0cyBpdCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAkc2NvcGUuc3JjID0gJyc7XG4gICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zcmMgPSBzcmM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5zcmMgPSBzcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzY28uc2Nvcm10eXBlID09ICdhc3NldCcpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgdGhlIGFzc2V0IGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICAgIHZhciB0cmFja3MgPSBbe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICdjbWkuY29yZS5sZXNzb25fc3RhdHVzJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ2NvbXBsZXRlZCdcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgJG1tYU1vZFNjb3JtLnNhdmVUcmFja3Moc2NvLmlkLCBhdHRlbXB0LCB0cmFja3MsIG9mZmxpbmUsIHNjb3JtKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBzYXZpbmcgZGF0YS4gV2UnbGwgZ28gb2ZmbGluZSBpZiB3ZSdyZSBvbmxpbmUgYW5kIHRoZSBhc3NldCBpcyBub3QgbWFya2VkIGFzIGNvbXBsZXRlZCBhbHJlYWR5LlxuICAgICAgICAgICAgICAgIGlmICghb2ZmbGluZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldFNjb3JtVXNlckRhdGEoc2Nvcm0uaWQsIGF0dGVtcHQsIG9mZmxpbmUpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhW3Njby5pZF0gfHzCoGRhdGFbc2NvLmlkXS51c2VyZGF0YVsnY21pLmNvcmUubGVzc29uX3N0YXR1cyddICE9ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR28gb2ZmbGluZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtSGVscGVyLmNvbnZlcnRBdHRlbXB0VG9PZmZsaW5lKHNjb3JtLCBhdHRlbXB0KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFNjb3JtRGF0YU1vZGVsMTIuc2V0T2ZmbGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5zYXZlVHJhY2tzKHNjby5pZCwgYXR0ZW1wdCwgdHJhY2tzLCBvZmZsaW5lLCBzY29ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goc2hvd0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWZyZXNoIFRPQywgc29tZSBwcmVyZXF1aXNpdGVzIG1pZ2h0IGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICByZWZyZXNoVG9jKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaWdnZXIgU0NPIGxhdW5jaCBldmVudC5cbiAgICAgICAgJG1tYU1vZFNjb3JtLmxvZ0xhdW5jaFNjbyhzY29ybS5pZCwgc2NvLmlkKTtcbiAgICB9XG5cbiAgICAvLyBSZWZyZXNoIHRoZSBUT0MuXG4gICAgZnVuY3Rpb24gcmVmcmVzaFRvYygpIHtcbiAgICAgICAgJG1tYU1vZFNjb3JtLmludmFsaWRhdGVBbGxTY29ybURhdGEoc2Nvcm0uaWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmZXRjaFRvYygpLmNhdGNoKHNob3dFcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNldCBTQ09STSBzdGFydCB0aW1lLlxuICAgIGZ1bmN0aW9uIHNldFN0YXJ0VGltZShzY29JZCkge1xuICAgICAgICB2YXIgdHJhY2tzID0gW3tcbiAgICAgICAgICAgIGVsZW1lbnQ6ICd4LnN0YXJ0LnRpbWUnLFxuICAgICAgICAgICAgdmFsdWU6ICRtbVV0aWwudGltZXN0YW1wKClcbiAgICAgICAgfV07XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uc2F2ZVRyYWNrcyhzY29JZCwgYXR0ZW1wdCwgdHJhY2tzLCBvZmZsaW5lLCBzY29ybSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghb2ZmbGluZSkge1xuICAgICAgICAgICAgICAgIC8vIE5ldyBvbmxpbmUgYXR0ZW1wdCBjcmVhdGVkLCB1cGRhdGUgY2FjaGVkIGRhdGEgYWJvdXQgb25saW5lIGF0dGVtcHRzLlxuICAgICAgICAgICAgICAgICRtbWFNb2RTY29ybS5nZXRBdHRlbXB0Q291bnQoc2Nvcm0uaWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICRzY29wZS5zaG93VG9jID0gJG1tYU1vZFNjb3JtLmRpc3BsYXlUb2NJblBsYXllcihzY29ybSk7XG4gICAgaWYgKCRzY29wZS5zaG93VG9jKSB7XG4gICAgICAgIC8vIFNldHVwIFRPQyBwb3BvdmVyLlxuICAgICAgICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgnYWRkb25zL21vZF9zY29ybS90ZW1wbGF0ZXMvdG9jLmh0bWwnLCB7XG4gICAgICAgICAgICBzY29wZTogJHNjb3BlLFxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICAgICAgICRzY29wZS5wb3BvdmVyID0gcG9wb3ZlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggdGhlIFNDT1JNIGRhdGEuXG4gICAgZmV0Y2hEYXRhKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRTY28pIHtcbiAgICAgICAgICAgIC8vIFNldCBzdGFydCB0aW1lIGlmIGl0J3MgYSBuZXcgYXR0ZW1wdC5cbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3QXR0ZW1wdCA/IHNldFN0YXJ0VGltZShjdXJyZW50U2NvLmlkKSA6ICRxLndoZW4oKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhdGNoKHNob3dFcnJvcikuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2FkIFNDTy5cbiAgICAgICAgICAgICAgICBsb2FkU2NvKGN1cnJlbnRTY28pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgICRzY29wZS5sb2FkU2NvID0gZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgIGlmICghc2NvLnByZXJlcSB8fCAhc2NvLmlzdmlzaWJsZSB8fCAhc2NvLmxhdW5jaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJHNjb3BlLnBvcG92ZXIuaGlkZSgpO1xuICAgICAgICBsb2FkU2NvKHNjbyk7XG4gICAgfTtcblxuICAgIC8vIExpc3RlbiBmb3IgZXZlbnRzIHRvIHVwZGF0ZSB0aGUgVE9DIGFuZCBuYXZpZ2F0ZSB0aHJvdWdoIFNDT3MuXG4gICAgdmFyIHRvY09ic2VydmVyID0gJG1tRXZlbnRzLm9uKG1tYU1vZFNjb3JtRXZlbnRVcGRhdGVUb2MsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuc2Nvcm1pZCA9PT0gc2Nvcm0uaWQpIHtcbiAgICAgICAgICAgIGlmIChvZmZsaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBhIGJpdCB0byBtYWtlIHN1cmUgZGF0YSBpcyBzdG9yZWQuXG4gICAgICAgICAgICAgICAgJHRpbWVvdXQocmVmcmVzaFRvYywgMTAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmcmVzaFRvYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbGF1bmNoTmV4dE9ic2VydmVyID0gJG1tRXZlbnRzLm9uKG1tYU1vZFNjb3JtRXZlbnRMYXVuY2hOZXh0U2NvLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnNjb3JtaWQgPT09IHNjb3JtLmlkICYmICRzY29wZS5uZXh0U2NvKSB7XG4gICAgICAgICAgICBsb2FkU2NvKCRzY29wZS5uZXh0U2NvKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGxhdW5jaFByZXZPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbWFNb2RTY29ybUV2ZW50TGF1bmNoUHJldlNjbywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5zY29ybWlkID09PSBzY29ybS5pZCAmJiAkc2NvcGUucHJldmlvdXNTY28pIHtcbiAgICAgICAgICAgIGxvYWRTY28oJHNjb3BlLnByZXZpb3VzU2NvKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGdvT2ZmbGluZU9ic2VydmVyID0gJG1tRXZlbnRzLm9uKG1tYU1vZFNjb3JtRXZlbnRHb09mZmxpbmUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuc2Nvcm1pZCA9PT0gc2Nvcm0uaWQgJiYgIW9mZmxpbmUpIHtcbiAgICAgICAgICAgIG9mZmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBhIGJpdCB0byBwcmV2ZW50IGNvbGxpc2lvbnMgYmV0d2VlbiB0aGlzIHN0b3JlIGFuZCBTQ09STSBBUEkncyBzdG9yZS5cbiAgICAgICAgICAgICAgICAkbW1hTW9kU2Nvcm1IZWxwZXIuY29udmVydEF0dGVtcHRUb09mZmxpbmUoc2Nvcm0sIGF0dGVtcHQpLmNhdGNoKHNob3dFcnJvcikuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFRvYygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRW1wdHkgc3JjIHdoZW4gbGVhdmluZyB0aGUgc3RhdGUgc28gdW5sb2FkIGV2ZW50IGlzIHRyaWdnZXJlZCBpbiB0aGUgaWZyYW1lLlxuICAgICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlTGVhdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLnNyYyA9ICcnO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdG9jT2JzZXJ2ZXIgJiYgdG9jT2JzZXJ2ZXIub2ZmICYmIHRvY09ic2VydmVyLm9mZigpO1xuICAgICAgICBsYXVuY2hOZXh0T2JzZXJ2ZXIgJiYgbGF1bmNoTmV4dE9ic2VydmVyLm9mZiAmJiBsYXVuY2hOZXh0T2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgIGxhdW5jaFByZXZPYnNlcnZlciAmJiBsYXVuY2hQcmV2T2JzZXJ2ZXIub2ZmICYmIGxhdW5jaFByZXZPYnNlcnZlci5vZmYoKTtcbiAgICAgICAgZ29PZmZsaW5lT2JzZXJ2ZXIgJiYgZ29PZmZsaW5lT2JzZXJ2ZXIub2ZmICYmIGdvT2ZmbGluZU9ic2VydmVyLm9mZigpO1xuICAgIH0pO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2Rfc2Nvcm0nKVxuXG4vKipcbiAqIFNDT1JNIGRhdGEgbW9kZWwgaW1wbGVtZW50YXRpb24gZm9yIHZlcnNpb24gMS4yLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RTY29ybURhdGFNb2RlbDEyXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kU2Nvcm1EYXRhTW9kZWwxMicsIGZ1bmN0aW9uKCRtbWFNb2RTY29ybSwgJG1tRXZlbnRzLCAkd2luZG93LCBtbWFNb2RTY29ybUV2ZW50TGF1bmNoTmV4dFNjbyxcbiAgICAgICAgICAgIG1tYU1vZFNjb3JtRXZlbnRMYXVuY2hQcmV2U2NvLCBtbWFNb2RTY29ybUV2ZW50VXBkYXRlVG9jLCBtbWFNb2RTY29ybUV2ZW50R29PZmZsaW5lKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIGdsb2JhbCBTQ09STSBBUEkgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtICAgIFRoZSBTQ09STSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29JZCAgICBUaGUgU0NPIGlkLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCAgVGhlIGF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdXNlckRhdGEgVGhlIHVzZXIgZGVmYXVsdCBkYXRhLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbW9kZSAgICAgTW9kZS4gT25lIG9mICRtbWFNb2RTY29ybSNNT0RFIGNvbnN0YW50cy5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvZmZsaW5lIFRydWUgaWYgYXR0ZW1wdCBpcyBvZmZsaW5lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU0NPUk1BUEkoc2Nvcm0sIHNjb0lkLCBhdHRlbXB0LCB1c2VyRGF0YSwgbW9kZSwgb2ZmbGluZSkge1xuXG4gICAgICAgIC8vIENvbnRhaW5zIGFsbCB0aGUgY3VycmVudCB2YWx1ZXMgZm9yIGFsbCB0aGUgZGF0YSBtb2RlbCBlbGVtZW50cyBmb3IgZWFjaCBTQ08uXG4gICAgICAgIHZhciBjdXJyZW50VXNlckRhdGEgPSB7fSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIEN1cnJlbnQgU0NPIElkLlxuICAgICAgICBzZWxmLnNjb0lkID0gc2NvSWQ7XG4gICAgICAgIHNlbGYub2ZmbGluZSA9IG9mZmxpbmU7XG5cbiAgICAgICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gdHJpZ2dlciBldmVudHMuXG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChuYW1lKSB7XG4gICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihuYW1lLCB7XG4gICAgICAgICAgICAgICAgc2Nvcm1pZDogc2Nvcm0uaWQsXG4gICAgICAgICAgICAgICAgc2NvaWQ6IHNlbGYuc2NvSWQsXG4gICAgICAgICAgICAgICAgYXR0ZW1wdDogYXR0ZW1wdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFuZGFyZCBEYXRhIFR5cGUgRGVmaW5pdGlvbi5cbiAgICAgICAgdmFyIENNSVN0cmluZzI1NiA9ICdeW1xcXFx1MDAwMC1cXFxcdUZGRkZdezAsMjU1fSQnO1xuICAgICAgICB2YXIgQ01JU3RyaW5nNDA5NiA9ICdeW1xcXFx1MDAwMC1cXFxcdUZGRkZdezAsNDA5Nn0kJztcbiAgICAgICAgdmFyIENNSVRpbWUgPSAnXihbMC0yXXsxfVswLTldezF9KTooWzAtNV17MX1bMC05XXsxfSk6KFswLTVdezF9WzAtOV17MX0pKFxcLlswLTldezEsMn0pPyQnO1xuICAgICAgICB2YXIgQ01JVGltZXNwYW4gPSAnXihbMC05XXsyLDR9KTooWzAtOV17Mn0pOihbMC05XXsyfSkoXFwuWzAtOV17MSwyfSk/JCc7XG4gICAgICAgIHZhciBDTUlJbnRlZ2VyID0gJ15cXFxcZCskJztcbiAgICAgICAgdmFyIENNSVNJbnRlZ2VyID0gJ14tPyhbMC05XSspJCc7XG4gICAgICAgIHZhciBDTUlEZWNpbWFsID0gJ14tPyhbMC05XXswLDN9KShcXC5bMC05XSopPyQnO1xuICAgICAgICB2YXIgQ01JSWRlbnRpZmllciA9ICdeW1xcXFx1MDAyMS1cXFxcdTAwN0VdezAsMjU1fSQnO1xuICAgICAgICB2YXIgQ01JRmVlZGJhY2sgPSBDTUlTdHJpbmcyNTY7IC8vIFRoaXMgbXVzdCBiZSByZWRlZmluZWQuXG4gICAgICAgIHZhciBDTUlJbmRleCA9ICdbLl9dKFxcXFxkKykuJztcblxuICAgICAgICAvLyBWb2NhYnVsYXJ5IERhdGEgVHlwZSBEZWZpbml0aW9uLlxuICAgICAgICB2YXIgQ01JU3RhdHVzID0gJ15wYXNzZWQkfF5jb21wbGV0ZWQkfF5mYWlsZWQkfF5pbmNvbXBsZXRlJHxeYnJvd3NlZCQnO1xuICAgICAgICB2YXIgQ01JU3RhdHVzMiA9ICdecGFzc2VkJHxeY29tcGxldGVkJHxeZmFpbGVkJHxeaW5jb21wbGV0ZSR8XmJyb3dzZWQkfF5ub3QgYXR0ZW1wdGVkJCc7XG4gICAgICAgIHZhciBDTUlFeGl0ID0gJ150aW1lLW91dCR8XnN1c3BlbmQkfF5sb2dvdXQkfF4kJztcbiAgICAgICAgdmFyIENNSVR5cGUgPSAnXnRydWUtZmFsc2UkfF5jaG9pY2UkfF5maWxsLWluJHxebWF0Y2hpbmckfF5wZXJmb3JtYW5jZSR8XnNlcXVlbmNpbmckfF5saWtlcnQkfF5udW1lcmljJCc7XG4gICAgICAgIHZhciBDTUlSZXN1bHQgPSAnXmNvcnJlY3QkfF53cm9uZyR8XnVuYW50aWNpcGF0ZWQkfF5uZXV0cmFsJHxeKFswLTldezAsM30pPyhcXC5bMC05XSopPyQnO1xuICAgICAgICB2YXIgTkFWRXZlbnQgPSAnXnByZXZpb3VzJHxeY29udGludWUkJztcblxuICAgICAgICAvLyBDaGlsZHJlbiBsaXN0cy5cbiAgICAgICAgdmFyIGNtaV9jaGlsZHJlbiA9ICdjb3JlLHN1c3BlbmRfZGF0YSxsYXVuY2hfZGF0YSxjb21tZW50cyxvYmplY3RpdmVzLHN0dWRlbnRfZGF0YSxzdHVkZW50X3ByZWZlcmVuY2UsaW50ZXJhY3Rpb25zJztcbiAgICAgICAgdmFyIGNvcmVfY2hpbGRyZW4gPSAnc3R1ZGVudF9pZCxzdHVkZW50X25hbWUsbGVzc29uX2xvY2F0aW9uLGNyZWRpdCxsZXNzb25fc3RhdHVzLGVudHJ5LHNjb3JlLHRvdGFsX3RpbWUsbGVzc29uX21vZGUsZXhpdCxzZXNzaW9uX3RpbWUnO1xuICAgICAgICB2YXIgc2NvcmVfY2hpbGRyZW4gPSAncmF3LG1pbixtYXgnO1xuICAgICAgICB2YXIgY29tbWVudHNfY2hpbGRyZW4gPSAnY29udGVudCxsb2NhdGlvbix0aW1lJztcbiAgICAgICAgdmFyIG9iamVjdGl2ZXNfY2hpbGRyZW4gPSAnaWQsc2NvcmUsc3RhdHVzJztcbiAgICAgICAgdmFyIGNvcnJlY3RfcmVzcG9uc2VzX2NoaWxkcmVuID0gJ3BhdHRlcm4nO1xuICAgICAgICB2YXIgc3R1ZGVudF9kYXRhX2NoaWxkcmVuID0gJ21hc3Rlcnlfc2NvcmUsbWF4X3RpbWVfYWxsb3dlZCx0aW1lX2xpbWl0X2FjdGlvbic7XG4gICAgICAgIHZhciBzdHVkZW50X3ByZWZlcmVuY2VfY2hpbGRyZW4gPSAnYXVkaW8sbGFuZ3VhZ2Usc3BlZWQsdGV4dCc7XG4gICAgICAgIHZhciBpbnRlcmFjdGlvbnNfY2hpbGRyZW4gPSAnaWQsb2JqZWN0aXZlcyx0aW1lLHR5cGUsY29ycmVjdF9yZXNwb25zZXMsd2VpZ2h0aW5nLHN0dWRlbnRfcmVzcG9uc2UscmVzdWx0LGxhdGVuY3knO1xuXG4gICAgICAgIC8vIERhdGEgcmFuZ2VzLlxuICAgICAgICB2YXIgc2NvcmVfcmFuZ2UgPSAnMCMxMDAnO1xuICAgICAgICB2YXIgYXVkaW9fcmFuZ2UgPSAnLTEjMTAwJztcbiAgICAgICAgdmFyIHNwZWVkX3JhbmdlID0gJy0xMDAjMTAwJztcbiAgICAgICAgdmFyIHdlaWdodGluZ19yYW5nZSA9ICctMTAwIzEwMCc7XG4gICAgICAgIHZhciB0ZXh0X3JhbmdlID0gJy0xIzEnO1xuXG4gICAgICAgIC8vIFByZXBhcmUgdGhlIGRlZmluaXRpb24gYXJyYXkgY29udGFpbmluZyB0aGUgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgIHZhciBkZWYgPSB7fTtcbiAgICAgICAgLy8gV2UgbmVlZCBhbiBleHRyYSBvYmplY3QgdGhhdCB3aWxsIGNvbnRhaW4gdGhlIG9iamVjdGl2ZXMgYW5kIGludGVyYWN0aW9ucyBkYXRhIChhbGwgdGhlIC5uLiBlbGVtZW50cykuXG4gICAgICAgIHZhciBkZWZFeHRyYSA9IHt9O1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1c2VyRGF0YSwgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICBkZWZbc2NvLnNjb2lkXSA9IHNjby5kZWZhdWx0ZGF0YTtcbiAgICAgICAgICAgIGRlZkV4dHJhW3Njby5zY29pZF0gPSBzY28udXNlcmRhdGE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoZSBTQ09STSAxLjIgZGF0YSBtb2RlbC5cbiAgICAgICAgLy8gU2V0IHVwIGRhdGEgbW9kZWwgZm9yIGVhY2ggc2NvLlxuICAgICAgICB2YXIgZGF0YW1vZGVsID0ge307XG4gICAgICAgIGZvciAodmFyIHNjb2lkIGluIGRlZikge1xuICAgICAgICAgICAgZGF0YW1vZGVsW3Njb2lkXSA9IHtcbiAgICAgICAgICAgICAgICAnY21pLl9jaGlsZHJlbic6eydkZWZhdWx0dmFsdWUnOmNtaV9jaGlsZHJlbiwgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMid9LFxuICAgICAgICAgICAgICAgICdjbWkuX3ZlcnNpb24nOnsnZGVmYXVsdHZhbHVlJzonMy40JywgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMid9LFxuICAgICAgICAgICAgICAgICdjbWkuY29yZS5fY2hpbGRyZW4nOnsnZGVmYXVsdHZhbHVlJzpjb3JlX2NoaWxkcmVuLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAyJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLnN0dWRlbnRfaWQnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuY29yZS5zdHVkZW50X2lkJ10sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDMnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUuc3R1ZGVudF9uYW1lJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLmNvcmUuc3R1ZGVudF9uYW1lJ10sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDMnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUubGVzc29uX2xvY2F0aW9uJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLmNvcmUubGVzc29uX2xvY2F0aW9uJ10sICdmb3JtYXQnOkNNSVN0cmluZzI1NiwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUuY3JlZGl0Jzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLmNvcmUuY3JlZGl0J10sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDMnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUubGVzc29uX3N0YXR1cyc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnXSwgJ2Zvcm1hdCc6Q01JU3RhdHVzLCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuY29yZS5lbnRyeSc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb3JlLmVudHJ5J10sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDMnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUuc2NvcmUuX2NoaWxkcmVuJzp7J2RlZmF1bHR2YWx1ZSc6c2NvcmVfY2hpbGRyZW4sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUuc2NvcmUucmF3Jzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLmNvcmUuc2NvcmUucmF3J10sICdmb3JtYXQnOkNNSURlY2ltYWwsICdyYW5nZSc6c2NvcmVfcmFuZ2UsICdtb2QnOidydycsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLnNjb3JlLm1heCc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb3JlLnNjb3JlLm1heCddLCAnZm9ybWF0JzpDTUlEZWNpbWFsLCAncmFuZ2UnOnNjb3JlX3JhbmdlLCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuY29yZS5zY29yZS5taW4nOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuY29yZS5zY29yZS5taW4nXSwgJ2Zvcm1hdCc6Q01JRGVjaW1hbCwgJ3JhbmdlJzpzY29yZV9yYW5nZSwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUudG90YWxfdGltZSc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb3JlLnRvdGFsX3RpbWUnXSwgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMyd9LFxuICAgICAgICAgICAgICAgICdjbWkuY29yZS5sZXNzb25fbW9kZSc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb3JlLmxlc3Nvbl9tb2RlJ10sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDMnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUuZXhpdCc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb3JlLmV4aXQnXSwgJ2Zvcm1hdCc6Q01JRXhpdCwgJ21vZCc6J3cnLCAncmVhZGVycm9yJzonNDA0JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUuc2Vzc2lvbl90aW1lJzp7J2Zvcm1hdCc6Q01JVGltZXNwYW4sICdtb2QnOid3JywgJ2RlZmF1bHR2YWx1ZSc6JzAwOjAwOjAwJywgJ3JlYWRlcnJvcic6JzQwNCcsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5zdXNwZW5kX2RhdGEnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuc3VzcGVuZF9kYXRhJ10sICdmb3JtYXQnOkNNSVN0cmluZzQwOTYsICdtb2QnOidydycsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5sYXVuY2hfZGF0YSc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5sYXVuY2hfZGF0YSddLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAzJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb21tZW50cyc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb21tZW50cyddLCAnZm9ybWF0JzpDTUlTdHJpbmc0MDk2LCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgIC8vIERlcHJlY2F0ZWQgZXZhbHVhdGlvbiBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgICAgICdjbWkuZXZhbHVhdGlvbi5jb21tZW50cy5fY291bnQnOnsnZGVmYXVsdHZhbHVlJzonMCcsICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLmV2YWx1YXRpb24uY29tbWVudHMuX2NoaWxkcmVuJzp7J2RlZmF1bHR2YWx1ZSc6Y29tbWVudHNfY2hpbGRyZW4sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLmV2YWx1YXRpb24uY29tbWVudHMubi5jb250ZW50Jzp7J2RlZmF1bHR2YWx1ZSc6JycsICdwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JU3RyaW5nMjU2LCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuZXZhbHVhdGlvbi5jb21tZW50cy5uLmxvY2F0aW9uJzp7J2RlZmF1bHR2YWx1ZSc6JycsICdwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JU3RyaW5nMjU2LCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuZXZhbHVhdGlvbi5jb21tZW50cy5uLnRpbWUnOnsnZGVmYXVsdHZhbHVlJzonJywgJ3BhdHRlcm4nOkNNSUluZGV4LCAnZm9ybWF0JzpDTUlUaW1lLCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuY29tbWVudHNfZnJvbV9sbXMnOnsnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAzJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5vYmplY3RpdmVzLl9jaGlsZHJlbic6eydkZWZhdWx0dmFsdWUnOm9iamVjdGl2ZXNfY2hpbGRyZW4sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLm9iamVjdGl2ZXMuX2NvdW50Jzp7J21vZCc6J3InLCAnZGVmYXVsdHZhbHVlJzonMCcsICd3cml0ZWVycm9yJzonNDAyJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5vYmplY3RpdmVzLm4uaWQnOnsncGF0dGVybic6Q01JSW5kZXgsICdmb3JtYXQnOkNNSUlkZW50aWZpZXIsICdtb2QnOidydycsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5vYmplY3RpdmVzLm4uc2NvcmUuX2NoaWxkcmVuJzp7J3BhdHRlcm4nOkNNSUluZGV4LCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAyJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5vYmplY3RpdmVzLm4uc2NvcmUucmF3Jzp7J2RlZmF1bHR2YWx1ZSc6JycsICdwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JRGVjaW1hbCwgJ3JhbmdlJzpzY29yZV9yYW5nZSwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLm9iamVjdGl2ZXMubi5zY29yZS5taW4nOnsnZGVmYXVsdHZhbHVlJzonJywgJ3BhdHRlcm4nOkNNSUluZGV4LCAnZm9ybWF0JzpDTUlEZWNpbWFsLCAncmFuZ2UnOnNjb3JlX3JhbmdlLCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkub2JqZWN0aXZlcy5uLnNjb3JlLm1heCc6eydkZWZhdWx0dmFsdWUnOicnLCAncGF0dGVybic6Q01JSW5kZXgsICdmb3JtYXQnOkNNSURlY2ltYWwsICdyYW5nZSc6c2NvcmVfcmFuZ2UsICdtb2QnOidydycsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5vYmplY3RpdmVzLm4uc3RhdHVzJzp7J3BhdHRlcm4nOkNNSUluZGV4LCAnZm9ybWF0JzpDTUlTdGF0dXMyLCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuc3R1ZGVudF9kYXRhLl9jaGlsZHJlbic6eydkZWZhdWx0dmFsdWUnOnN0dWRlbnRfZGF0YV9jaGlsZHJlbiwgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMid9LFxuICAgICAgICAgICAgICAgICdjbWkuc3R1ZGVudF9kYXRhLm1hc3Rlcnlfc2NvcmUnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuc3R1ZGVudF9kYXRhLm1hc3Rlcnlfc2NvcmUnXSwgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMyd9LFxuICAgICAgICAgICAgICAgICdjbWkuc3R1ZGVudF9kYXRhLm1heF90aW1lX2FsbG93ZWQnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuc3R1ZGVudF9kYXRhLm1heF90aW1lX2FsbG93ZWQnXSwgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMyd9LFxuICAgICAgICAgICAgICAgICdjbWkuc3R1ZGVudF9kYXRhLnRpbWVfbGltaXRfYWN0aW9uJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLnN0dWRlbnRfZGF0YS50aW1lX2xpbWl0X2FjdGlvbiddLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAzJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5zdHVkZW50X3ByZWZlcmVuY2UuX2NoaWxkcmVuJzp7J2RlZmF1bHR2YWx1ZSc6c3R1ZGVudF9wcmVmZXJlbmNlX2NoaWxkcmVuLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAyJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5zdHVkZW50X3ByZWZlcmVuY2UuYXVkaW8nOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLmF1ZGlvJ10sICdmb3JtYXQnOkNNSVNJbnRlZ2VyLCAncmFuZ2UnOmF1ZGlvX3JhbmdlLCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLmxhbmd1YWdlJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS5sYW5ndWFnZSddLCAnZm9ybWF0JzpDTUlTdHJpbmcyNTYsICdtb2QnOidydycsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5zdHVkZW50X3ByZWZlcmVuY2Uuc3BlZWQnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLnNwZWVkJ10sICdmb3JtYXQnOkNNSVNJbnRlZ2VyLCAncmFuZ2UnOnNwZWVkX3JhbmdlLCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLnRleHQnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLnRleHQnXSwgJ2Zvcm1hdCc6Q01JU0ludGVnZXIsICdyYW5nZSc6dGV4dF9yYW5nZSwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5fY2hpbGRyZW4nOnsnZGVmYXVsdHZhbHVlJzppbnRlcmFjdGlvbnNfY2hpbGRyZW4sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5fY291bnQnOnsnbW9kJzoncicsICdkZWZhdWx0dmFsdWUnOicwJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5uLmlkJzp7J3BhdHRlcm4nOkNNSUluZGV4LCAnZm9ybWF0JzpDTUlJZGVudGlmaWVyLCAnbW9kJzondycsICdyZWFkZXJyb3InOic0MDQnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuaW50ZXJhY3Rpb25zLm4ub2JqZWN0aXZlcy5fY291bnQnOnsncGF0dGVybic6Q01JSW5kZXgsICdtb2QnOidyJywgJ2RlZmF1bHR2YWx1ZSc6JzAnLCAnd3JpdGVlcnJvcic6JzQwMid9LFxuICAgICAgICAgICAgICAgICdjbWkuaW50ZXJhY3Rpb25zLm4ub2JqZWN0aXZlcy5uLmlkJzp7J3BhdHRlcm4nOkNNSUluZGV4LCAnZm9ybWF0JzpDTUlJZGVudGlmaWVyLCAnbW9kJzondycsICdyZWFkZXJyb3InOic0MDQnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuaW50ZXJhY3Rpb25zLm4udGltZSc6eydwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JVGltZSwgJ21vZCc6J3cnLCAncmVhZGVycm9yJzonNDA0JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5uLnR5cGUnOnsncGF0dGVybic6Q01JSW5kZXgsICdmb3JtYXQnOkNNSVR5cGUsICdtb2QnOid3JywgJ3JlYWRlcnJvcic6JzQwNCcsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5pbnRlcmFjdGlvbnMubi5jb3JyZWN0X3Jlc3BvbnNlcy5fY291bnQnOnsncGF0dGVybic6Q01JSW5kZXgsICdtb2QnOidyJywgJ2RlZmF1bHR2YWx1ZSc6JzAnLCAnd3JpdGVlcnJvcic6JzQwMid9LFxuICAgICAgICAgICAgICAgICdjbWkuaW50ZXJhY3Rpb25zLm4uY29ycmVjdF9yZXNwb25zZXMubi5wYXR0ZXJuJzp7J3BhdHRlcm4nOkNNSUluZGV4LCAnZm9ybWF0JzpDTUlGZWVkYmFjaywgJ21vZCc6J3cnLCAncmVhZGVycm9yJzonNDA0JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5uLndlaWdodGluZyc6eydwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JRGVjaW1hbCwgJ3JhbmdlJzp3ZWlnaHRpbmdfcmFuZ2UsICdtb2QnOid3JywgJ3JlYWRlcnJvcic6JzQwNCcsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5pbnRlcmFjdGlvbnMubi5zdHVkZW50X3Jlc3BvbnNlJzp7J3BhdHRlcm4nOkNNSUluZGV4LCAnZm9ybWF0JzpDTUlGZWVkYmFjaywgJ21vZCc6J3cnLCAncmVhZGVycm9yJzonNDA0JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5uLnJlc3VsdCc6eydwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JUmVzdWx0LCAnbW9kJzondycsICdyZWFkZXJyb3InOic0MDQnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuaW50ZXJhY3Rpb25zLm4ubGF0ZW5jeSc6eydwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JVGltZXNwYW4sICdtb2QnOid3JywgJ3JlYWRlcnJvcic6JzQwNCcsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ25hdi5ldmVudCc6eydkZWZhdWx0dmFsdWUnOicnLCAnZm9ybWF0JzpOQVZFdmVudCwgJ21vZCc6J3cnLCAncmVhZGVycm9yJzonNDA0JywgJ3dyaXRlZXJyb3InOic0MDUnfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY3VycmVudFVzZXJEYXRhW3Njb2lkXSA9IHt9O1xuXG4gICAgICAgICAgICAvLyBMb2FkIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgZm9yICh2YXIgZWxlbWVudCBpbiBkYXRhbW9kZWxbc2NvaWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQubWF0Y2goL1xcLm5cXC4vKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFtb2RlbFtzY29pZF1bZWxlbWVudF0uZGVmYXVsdHZhbHVlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlckRhdGFbc2NvaWRdW2VsZW1lbnRdID0gZGF0YW1vZGVsW3Njb2lkXVtlbGVtZW50XS5kZWZhdWx0dmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExvYWQgaW5pdGlhbCB1c2VyIGRhdGEgZm9yIGN1cnJlbnQgU0NPLlxuICAgICAgICAgICAgZm9yIChlbGVtZW50IGluIGRlZltzY29pZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5tYXRjaCgvXFwublxcLi8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YW1vZGVsW3Njb2lkXVtlbGVtZW50XS5kZWZhdWx0dmFsdWUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bZWxlbWVudF0gPSBkYXRhbW9kZWxbc2NvaWRdW2VsZW1lbnRdLmRlZmF1bHR2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmRXh0cmFbc2NvaWRdW2VsZW1lbnRdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpbiB1c2VyIGRhdGEgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFVzZXJEYXRhW3Njb2lkXVtlbGVtZW50XSA9IGRlZkV4dHJhW3Njb2lkXVtlbGVtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bZWxlbWVudF0gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9hZCBpbnRlcmFjdGlvbnMgYW5kIG9iamVjdGl2ZXMsIGFuZCBpbml0IHRoZSBjb3VudGVycy5cbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gbmV3IFJlZ0V4cChDTUlJbmRleCwnZycpO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnREb3RGb3JtYXQsIGNvdW50ZXJFbGVtZW50LCBjdXJyZW50Q291bnRlckluZGV4LCBjdXJyZW50TjtcbiAgICAgICAgICAgIGZvciAoZWxlbWVudCBpbiBkZWZFeHRyYVtzY29pZF0pIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyRWxlbWVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb3VudGVySW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hlY2sgZm9yIGFuIGluZGV4ZWQgZWxlbWVudC4gY21pLm9iamVjdGl2ZXMuMS5pZCBvciBjbWkub2JqZWN0aXZlc18xLmlkLlxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm1hdGNoKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byB0aGUgZXhwZWN0ZWQgdmFsdWUgYWNjb3JkaW5nIHRoZSBzdGFuZGFyZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gTW9vZGxlIHN0b3JlcyB0aGlzIHZhbHVlcyB1c2luZyBfbi4gaW5zdGVhZCAubi5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudERvdEZvcm1hdCA9IGVsZW1lbnQucmVwbGFjZShleHByZXNzaW9uLCBcIi4kMS5cIik7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bZWxlbWVudERvdEZvcm1hdF0gPSBkZWZFeHRyYVtzY29pZF1bZWxlbWVudF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjb3JyZWN0IGNvdW50ZXIgYW5kIGN1cnJlbnQgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50RG90Rm9ybWF0LmluZGV4T2YoXCJjbWkuZXZhbHVhdGlvbi5jb21tZW50c1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlckVsZW1lbnQgPSBcImNtaS5ldmFsdWF0aW9uLmNvbW1lbnRzLl9jb3VudFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvdW50ZXJJbmRleCA9IGVsZW1lbnREb3RGb3JtYXQubWF0Y2goLy4oXFxkKykuLylbMV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudERvdEZvcm1hdC5pbmRleE9mKFwiY21pLm9iamVjdGl2ZXNcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJFbGVtZW50ID0gXCJjbWkub2JqZWN0aXZlcy5fY291bnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb3VudGVySW5kZXggPSBlbGVtZW50RG90Rm9ybWF0Lm1hdGNoKC8uKFxcZCspLi8pWzFdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnREb3RGb3JtYXQuaW5kZXhPZihcImNtaS5pbnRlcmFjdGlvbnNcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50RG90Rm9ybWF0LmluZGV4T2YoXCIub2JqZWN0aXZlcy5cIikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE4gPSBlbGVtZW50RG90Rm9ybWF0Lm1hdGNoKC9jbWkuaW50ZXJhY3Rpb25zLihcXGQrKS4vKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q291bnRlckluZGV4ID0gZWxlbWVudERvdEZvcm1hdC5tYXRjaCgvb2JqZWN0aXZlcy4oXFxkKykuLylbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlckVsZW1lbnQgPSBcImNtaS5pbnRlcmFjdGlvbnMuXCIgKyBjdXJyZW50TiArIFwiLm9iamVjdGl2ZXMuX2NvdW50XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnREb3RGb3JtYXQuaW5kZXhPZihcIi5jb3JyZWN0X3Jlc3BvbnNlcy5cIikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE4gPSBlbGVtZW50RG90Rm9ybWF0Lm1hdGNoKC9jbWkuaW50ZXJhY3Rpb25zLihcXGQrKS4vKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q291bnRlckluZGV4ID0gZWxlbWVudERvdEZvcm1hdC5tYXRjaCgvY29ycmVjdF9yZXNwb25zZXMuKFxcZCspLi8pWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJFbGVtZW50ID0gXCJjbWkuaW50ZXJhY3Rpb25zLlwiICsgY3VycmVudE4gKyBcIi5jb3JyZWN0X3Jlc3BvbnNlcy5fY291bnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlckVsZW1lbnQgPSBcImNtaS5pbnRlcmFjdGlvbnMuX2NvdW50XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvdW50ZXJJbmRleCA9IGVsZW1lbnREb3RGb3JtYXQubWF0Y2goLy4oXFxkKykuLylbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudFVzZXJEYXRhW3Njb2lkXVtjb3VudGVyRWxlbWVudF0gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bY291bnRlckVsZW1lbnRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gc3VtLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KGN1cnJlbnRDb3VudGVySW5kZXgpID09IHBhcnNlSW50KGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bY291bnRlckVsZW1lbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bY291bnRlckVsZW1lbnRdID0gcGFyc2VJbnQoY3VycmVudFVzZXJEYXRhW3Njb2lkXVtjb3VudGVyRWxlbWVudF0pICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChjdXJyZW50Q291bnRlckluZGV4KSA+IHBhcnNlSW50KGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bY291bnRlckVsZW1lbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bY291bnRlckVsZW1lbnRdID0gcGFyc2VJbnQoY3VycmVudENvdW50ZXJJbmRleCkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCBkZWZhdWx0IHN0YXR1cy5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VXNlckRhdGFbc2NvaWRdWydjbWkuY29yZS5sZXNzb25fc3RhdHVzJ10gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFVzZXJEYXRhW3Njb2lkXVsnY21pLmNvcmUubGVzc29uX3N0YXR1cyddID0gJ25vdCBhdHRlbXB0ZWQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZWZpbmUgbW9kZSBhbmQgY3JlZGl0LlxuICAgICAgICAgICAgY3VycmVudFVzZXJEYXRhW3Njb2lkXVsnY21pLmNvcmUuY3JlZGl0J10gPSBtb2RlID09ICRtbWFNb2RTY29ybS5NT0RFTk9STUFMID8gJ2NyZWRpdCcgOiAnbm8tY3JlZGl0JztcbiAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bJ2NtaS5jb3JlLmxlc3Nvbl9tb2RlJ10gPSBtb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQVBJIGhlbHBlciBtZXRob2RzLlxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGZyb20gdGhlIG5vbi1wZXJzaXN0ZW50IChjdXJyZW50KSB1c2VyIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gZWwgVGhlIGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSAgICBUaGUgZWxlbWVudCB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0RWwoZWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudFVzZXJEYXRhW3NlbGYuc2NvSWRdICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF1bZWxdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXVtlbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgbm9uLXBlcnNpc3RlbnQgKGN1cnJlbnQpIHVzZXIgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBlbCBUaGUgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0RWwoZWwsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFVzZXJEYXRhW3NlbGYuc2NvSWRdW2VsXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGNsb25pbmcgYW4gb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byAgYmUgY2xvbmVkXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG9iamVjdCBjbG9uZWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIENsb25lT2JqKG9iail7XG4gICAgICAgICAgICBpZihvYmogPT0gbnVsbCB8fCB0eXBlb2Yob2JqKSAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZW1wID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpOyAvLyBDaGFuZ2VkICh0d2ljZSkuXG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICB0ZW1wW2tleV0gPSBDbG9uZU9iaihvYmpba2V5XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGFkZGluZyB0d28gdGltZXMgaW4gZm9ybWF0IGhoOm1tOnNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlyc3QgIEZpcnN0IHRpbWUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWNvbmQgU2Vjb25kIHRpbWUuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgVG90YWwgdGltZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFkZFRpbWUgKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBzRmlyc3QgPSBmaXJzdC5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICB2YXIgc1NlY29uZCA9IHNlY29uZC5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICB2YXIgY0ZpcnN0ID0gc0ZpcnN0WzJdLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIHZhciBjU2Vjb25kID0gc1NlY29uZFsyXS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gMDtcblxuICAgICAgICAgICAgRmlyc3RDZW50cyA9IDA7ICAvL0NlbnRzXG4gICAgICAgICAgICBpZiAoY0ZpcnN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBGaXJzdENlbnRzID0gcGFyc2VJbnQoY0ZpcnN0WzFdLDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNlY29uZENlbnRzID0gMDtcbiAgICAgICAgICAgIGlmIChjU2Vjb25kLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBTZWNvbmRDZW50cyA9IHBhcnNlSW50KGNTZWNvbmRbMV0sMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNlbnRzID0gRmlyc3RDZW50cyArIFNlY29uZENlbnRzO1xuICAgICAgICAgICAgY2hhbmdlID0gTWF0aC5mbG9vcihjZW50cyAvIDEwMCk7XG4gICAgICAgICAgICBjZW50cyA9IGNlbnRzIC0gKGNoYW5nZSAqIDEwMCk7XG4gICAgICAgICAgICBpZiAoTWF0aC5mbG9vcihjZW50cykgPCAxMCkge1xuICAgICAgICAgICAgICAgIGNlbnRzID0gXCIwXCIgKyBjZW50cy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VjcyA9IHBhcnNlSW50KGNGaXJzdFswXSwxMCkgKyBwYXJzZUludChjU2Vjb25kWzBdLDEwKSArIGNoYW5nZTsgIC8vU2Vjb25kc1xuICAgICAgICAgICAgY2hhbmdlID0gTWF0aC5mbG9vcihzZWNzIC8gNjApO1xuICAgICAgICAgICAgc2VjcyA9IHNlY3MgLSAoY2hhbmdlICogNjApO1xuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3Ioc2VjcykgPCAxMCkge1xuICAgICAgICAgICAgICAgIHNlY3MgPSBcIjBcIiArIHNlY3MudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWlucyA9IHBhcnNlSW50KHNGaXJzdFsxXSwxMCkgKyBwYXJzZUludChzU2Vjb25kWzFdLDEwKSArIGNoYW5nZTsgICAvL01pbnV0ZXNcbiAgICAgICAgICAgIGNoYW5nZSA9IE1hdGguZmxvb3IobWlucyAvIDYwKTtcbiAgICAgICAgICAgIG1pbnMgPSBtaW5zIC0gKGNoYW5nZSAqIDYwKTtcbiAgICAgICAgICAgIGlmIChtaW5zIDwgMTApIHtcbiAgICAgICAgICAgICAgICBtaW5zID0gXCIwXCIgKyBtaW5zLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhvdXJzID0gcGFyc2VJbnQoc0ZpcnN0WzBdLDEwKSArIHBhcnNlSW50KHNTZWNvbmRbMF0sMTApICsgY2hhbmdlOyAgLy9Ib3Vyc1xuICAgICAgICAgICAgaWYgKGhvdXJzIDwgMTApIHtcbiAgICAgICAgICAgICAgICBob3VycyA9IFwiMFwiICsgaG91cnMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNlbnRzICE9ICcwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VycyArIFwiOlwiICsgbWlucyArIFwiOlwiICsgc2VjcyArICcuJyArIGNlbnRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cnMgKyBcIjpcIiArIG1pbnMgKyBcIjpcIiArIHNlY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgY2FsY3VsYXRpbmcgdGhlIHRvdGFsIHRpbWUgc3BlbnQgaW4gdGhlIFNDTy5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRvdGFsVGltZSgpIHtcbiAgICAgICAgICAgIHRvdGFsX3RpbWUgPSBBZGRUaW1lKGdldEVsKCdjbWkuY29yZS50b3RhbF90aW1lJyksIGdldEVsKCdjbWkuY29yZS5zZXNzaW9uX3RpbWUnKSk7XG4gICAgICAgICAgICByZXR1cm4geydlbGVtZW50JzogJ2NtaS5jb3JlLnRvdGFsX3RpbWUnLCB2YWx1ZTogdG90YWxfdGltZX07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyc2lzdCB0aGUgY3VycmVudCB1c2VyIGRhdGEgKHRoaXMgaXMgdXN1YWxseSBjYWxsZWQgYnkgTE1TQ29tbWl0KVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2x9IHN0b3JldG90YWx0aW1lIElmIHRydWUsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSB0b3RhbCB0aW1lIHRvb1xuICAgICAgICAgKiBAcmV0dXJuIHtCb29sfSBbZGVzY3JpcHRpb25dXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBTdG9yZURhdGEoc3RvcmV0b3RhbHRpbWUpIHtcbiAgICAgICAgICAgIGlmIChzdG9yZXRvdGFsdGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChnZXRFbCgnY21pLmNvcmUubGVzc29uX3N0YXR1cycpID09ICdub3QgYXR0ZW1wdGVkJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRFbCgnY21pLmNvcmUubGVzc29uX3N0YXR1cycsICdjb21wbGV0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdldEVsKCdjbWkuY29yZS5sZXNzb25fbW9kZScpID09ICRtbWFNb2RTY29ybS5NT0RFTk9STUFMKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRFbCgnY21pLmNvcmUuY3JlZGl0JykgPT0gJ2NyZWRpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRFbCgnY21pLnN0dWRlbnRfZGF0YS5tYXN0ZXJ5X3Njb3JlJykgIT09ICcnICYmIGdldEVsKCdjbWkuY29yZS5zY29yZS5yYXcnKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChnZXRFbCgnY21pLmNvcmUuc2NvcmUucmF3JykpID49IHBhcnNlRmxvYXQoZ2V0RWwoJ2NtaS5zdHVkZW50X2RhdGEubWFzdGVyeV9zY29yZScpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbCgnY21pLmNvcmUubGVzc29uX3N0YXR1cycsICdwYXNzZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbCgnY21pLmNvcmUubGVzc29uX3N0YXR1cycsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdldEVsKCdjbWkuY29yZS5sZXNzb25fbW9kZScpID09ICRtbWFNb2RTY29ybS5NT0RFQlJPV1NFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhbW9kZWxbc2VsZi5zY29JZF1bJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnXS5kZWZhdWx0dmFsdWUgPT0gJycgJiYgZ2V0RWwoJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnKSA9PSAnbm90IGF0dGVtcHRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsKCdjbWkuY29yZS5sZXNzb25fc3RhdHVzJywgJ2Jyb3dzZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFja3MgPSBDb2xsZWN0RGF0YSgpO1xuICAgICAgICAgICAgICAgIHRyYWNrcy5wdXNoKFRvdGFsVGltZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2tzID0gQ29sbGVjdERhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdWNjZXNzID0gJG1tYU1vZFNjb3JtLnNhdmVUcmFja3NTeW5jKHNlbGYuc2NvSWQsIGF0dGVtcHQsIHRyYWNrcywgc2VsZi5vZmZsaW5lLCBzY29ybSwgY3VycmVudFVzZXJEYXRhKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5vZmZsaW5lICYmICFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFpbHVyZSBzdG9yaW5nIGRhdGEgaW4gb25saW5lLiBHbyBvZmZsaW5lLlxuICAgICAgICAgICAgICAgIHNlbGYub2ZmbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KG1tYU1vZFNjb3JtRXZlbnRHb09mZmxpbmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uc2F2ZVRyYWNrc1N5bmMoc2VsZi5zY29JZCwgYXR0ZW1wdCwgdHJhY2tzLCBzZWxmLm9mZmxpbmUsIHNjb3JtLCBjdXJyZW50VXNlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGVjdCBhbGwgdGhlIHVzZXIgdHJhY2tpbmcgZGF0YSB0aGF0IG11c3QgYmUgcGVyc2lzdGVkIGluIHRoZSBzeXN0ZW0sIHRoaXMgaXMgdXN1YWxseSBjYWxsZWQgYnkgTE1TQ29tbWl0KCkuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDb2xsZWN0RGF0YSgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBlbGVtZW50IGluIGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXSkge1xuICAgICAgICAgICAgICAgIC8vIE9tbWl0IGZvciBleGFtcGxlIHRoZSBuYXYuIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN1YnN0cigwLCAzKSA9PSAnY21pJykge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gbmV3IFJlZ0V4cChDTUlJbmRleCwnZycpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZ2VuZXJpYyBuYW1lIGZvciB0aGlzIGVsZW1lbnQgKGUuZy4gY29udmVydCAnY21pLmludGVyYWN0aW9ucy4xLmlkJyB0byAnY21pLmludGVyYWN0aW9ucy5uLmlkJylcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudG1vZGVsID0gU3RyaW5nKGVsZW1lbnQpLnJlcGxhY2UoZXhwcmVzc2lvbiwnLm4uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoZSBzZXNzaW9uIHRpbWUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gXCJjbWkuY29yZS5zZXNzaW9uX3RpbWVcIikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHNwZWNpZmljIGVsZW1lbnQgaXMgbm90IGRlZmluZWQgaW4gdGhlIGRhdGFtb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGUgZ2VuZXJpYyBlbGVtZW50IG5hbWUgaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50XSA9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudG1vZGVsXSAhPSBcInVuZGVmaW5lZFwiKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBzcGVjaWZpYyBlbGVtZW50IHRvIHRoZSBkYXRhIG1vZGVsIChieSBjbG9uaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGdlbmVyaWMgZWxlbWVudCkgc28gd2UgY2FuIHRyYWNrIGNoYW5nZXMgdG8gaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRdID0gQ2xvbmVPYmooZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRtb2RlbF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBlbGVtZW50IGV4aXN0cyBpbiB0aGUgZGF0YW1vZGVsLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudF0gIT0gXCJ1bmRlZmluZWRcIikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgaXMgbm90IGEgcmVhZCBvbmx5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50XS5tb2QgIT0gJ3InKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9vZGxlIHN0b3JlcyB0aGUgb3JnYW5pemF0aW9ucyBhbmQgaW50ZXJhY3Rpb25zIHVzaW5nIF9uLiBpbnN0ZWFkIC5uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2VsZW1lbnQnOiBlbGVtZW50LnJlcGxhY2UoZXhwcmVzc2lvbiwgXCJfJDEuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogZ2V0RWwoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBoYXMgYSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50XS5kZWZhdWx0dmFsdWUgIT0gXCJ1bmRlZmluZWRcIikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudF0uZGVmYXVsdHZhbHVlICE9IGVsWyd2YWx1ZSddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudF0uZGVmYXVsdHZhbHVlICE9IHR5cGVvZihlbFsndmFsdWUnXSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGVsZW1lbnQgZGVmYXVsdCB0byByZWZsZWN0IHRoZSBjdXJyZW50IGNvbW1pdHRlZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudF0uZGVmYXVsdHZhbHVlID0gZWxbJ3ZhbHVlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGVsZW1lbnQsIHNvIHNldCBpdCBub3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudF0uZGVmYXVsdHZhbHVlID0gZWxbJ3ZhbHVlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQVBJIG1ldGhvZHMgbm93LlxuICAgICAgICB2YXIgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yQ29kZTtcbiAgICAgICAgdmFyIHRpbWVvdXQ7XG5cbiAgICAgICAgc2VsZi5MTVNJbml0aWFsaXplID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMFwiO1xuICAgICAgICAgICAgaWYgKHBhcmFtID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRydWVcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjEwMVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIyMDFcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFwiZmFsc2VcIjtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLkxNU0ZpbmlzaCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICBlcnJvckNvZGUgPSBcIjBcIjtcbiAgICAgICAgICAgIGlmIChwYXJhbSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN0b3JlRGF0YSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEVsKCduYXYuZXZlbnQnKSAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldEVsKCduYXYuZXZlbnQnKSA9PSAnY29udGludWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KG1tYU1vZFNjb3JtRXZlbnRMYXVuY2hOZXh0U2NvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KG1tYU1vZFNjb3JtRXZlbnRMYXVuY2hQcmV2U2NvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29ybS5hdXRvID09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChtbWFNb2RTY29ybUV2ZW50TGF1bmNoTmV4dFNjbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gKHJlc3VsdCkgPyAnMCcgOiAnMTAxJztcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIFRPQyB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChtbWFNb2RTY29ybUV2ZW50VXBkYXRlVG9jKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjMwMVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIyMDFcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcImZhbHNlXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5MTVNHZXRWYWx1ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMFwiO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gbmV3IFJlZ0V4cChDTUlJbmRleCwnZycpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50bW9kZWwgPSBTdHJpbmcoZWxlbWVudCkucmVwbGFjZShleHByZXNzaW9uLCcubi4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudG1vZGVsXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRtb2RlbF0ubW9kICE9ICd3Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRFbChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRtb2RlbF0ucmVhZGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5zdHIgPSAnLl9jaGlsZHJlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudHN0ciA9ICcuX2NvdW50JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50bW9kZWwuc3Vic3RyKGVsZW1lbnRtb2RlbC5sZW5ndGggLSBjaGlsZHJlbnN0ci5sZW5ndGgsZWxlbWVudG1vZGVsLmxlbmd0aCkgPT0gY2hpbGRyZW5zdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRtb2RlbCA9IGVsZW1lbnRtb2RlbC5zdWJzdHIoMCxlbGVtZW50bW9kZWwubGVuZ3RoIC0gY2hpbGRyZW5zdHIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtwYXJlbnRtb2RlbF0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjIwMlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMjAxXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50bW9kZWwuc3Vic3RyKGVsZW1lbnRtb2RlbC5sZW5ndGggLSBjb3VudHN0ci5sZW5ndGgsZWxlbWVudG1vZGVsLmxlbmd0aCkgPT0gY291bnRzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRtb2RlbCA9IGVsZW1lbnRtb2RlbC5zdWJzdHIoMCxlbGVtZW50bW9kZWwubGVuZ3RoIC0gY291bnRzdHIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtwYXJlbnRtb2RlbF0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjIwM1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMjAxXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjIwMVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIyMDFcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMzAxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLkxNU1NldFZhbHVlID0gZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMFwiO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gbmV3IFJlZ0V4cChDTUlJbmRleCwnZycpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50bW9kZWwgPSBTdHJpbmcoZWxlbWVudCkucmVwbGFjZShleHByZXNzaW9uLCcubi4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudG1vZGVsXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRtb2RlbF0ubW9kICE9ICdyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50bW9kZWxdLmZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkeW5hbWljIGRhdGEgbW9kZWwgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gZWxlbWVudG1vZGVsKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluaXQgZGVmYXVsdCBjb3VudGVycyBhbmQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5kZXhPZihcImNtaS5vYmplY3RpdmVzXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE4gPSBlbGVtZW50Lm1hdGNoKC9jbWkub2JqZWN0aXZlcy4oXFxkKykuLylbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlckVsZW1lbnQgPSBcImNtaS5vYmplY3RpdmVzLlwiICsgY3VycmVudE4gKyBcIi5zY29yZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudFVzZXJEYXRhW3NlbGYuc2NvSWRdW2NvdW50ZXJFbGVtZW50ICsgJy5fY2hpbGRyZW4nXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsKGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXVtjb3VudGVyRWxlbWVudCArICcuX2NoaWxkcmVuJ10sIHNjb3JlX2NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWwoY3VycmVudFVzZXJEYXRhW3NlbGYuc2NvSWRdW2NvdW50ZXJFbGVtZW50ICsgJy5yYXcnXSwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbChjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF1bY291bnRlckVsZW1lbnQgKyAnLm1pbiddLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsKGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXVtjb3VudGVyRWxlbWVudCArICcubWF4J10sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5pbmRleE9mKFwiY21pLmludGVyYWN0aW9uc1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROID0gZWxlbWVudC5tYXRjaCgvY21pLmludGVyYWN0aW9ucy4oXFxkKykuLylbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyRWxlbWVudCA9IFwiY21pLmludGVyYWN0aW9ucy5cIiArIGN1cnJlbnROICsgXCIub2JqZWN0aXZlcy5fY291bnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXVtjb3VudGVyRWxlbWVudF0gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbChjb3VudGVyRWxlbWVudCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJFbGVtZW50ID0gXCJjbWkuaW50ZXJhY3Rpb25zLlwiICsgY3VycmVudE4gKyBcIi5jb3JyZWN0X3Jlc3BvbnNlcy5fY291bnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXVtjb3VudGVyRWxlbWVudF0gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbChjb3VudGVyRWxlbWVudCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50SW5kZXhlcyA9IGVsZW1lbnQuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmVsZW1lbnQgPSAnY21pJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBlbGVtZW50SW5kZXhlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50SW5kZXggPSBlbGVtZW50SW5kZXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEluZGV4ZXNbaSArIDFdLm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXVtzdWJlbGVtZW50ICsgJy4nICsgZWxlbWVudEluZGV4ICsgJy5fY291bnQnXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbChzdWJlbGVtZW50ICsgJy4nICsgZWxlbWVudEluZGV4ICsgJy5fY291bnQnLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEluZGV4ZXNbaSArIDFdID09IGdldEVsKHN1YmVsZW1lbnQgKyAnLicgKyBlbGVtZW50SW5kZXggKyAnLl9jb3VudCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBnZXRFbChzdWJlbGVtZW50ICsgJy4nICsgZWxlbWVudEluZGV4ICsgJy5fY291bnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsKHN1YmVsZW1lbnQgKyAnLicgKyBlbGVtZW50SW5kZXggKyAnLl9jb3VudCcsIHBhcnNlSW50KGNvdW50KSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SW5kZXhlc1tpICsgMV0gPiBnZXRFbChzdWJlbGVtZW50ICsgJy4nICsgZWxlbWVudEluZGV4ICsgJy5fY291bnQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIyMDFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJlbGVtZW50ID0gc3ViZWxlbWVudC5jb25jYXQoJy4nICsgZWxlbWVudEluZGV4ICsgJy4nICsgZWxlbWVudEluZGV4ZXNbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmVsZW1lbnQgPSBzdWJlbGVtZW50LmNvbmNhdCgnLicgKyBlbGVtZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzdWJlbGVtZW50LmNvbmNhdCgnLicgKyBlbGVtZW50SW5kZXhlc1tlbGVtZW50SW5kZXhlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TdG9yZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29ybS5hdXRvY29tbWl0ICYmICEodGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChzZWxmLkxNU0NvbW1pdCwgNjAwMDAsIFtcIlwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50bW9kZWxdLnJhbmdlICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50bW9kZWxdLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcyA9IHJhbmdlLnNwbGl0KCcjJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID49IHJhbmdlc1swXSkgJiYgKHZhbHVlIDw9IHJhbmdlc1sxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWwoZWxlbWVudCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHJ1ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50bW9kZWxdLndyaXRlZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PSAnY21pLmNvbW1lbnRzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbCgnY21pLmNvbW1lbnRzJywgZ2V0RWwoJ2NtaS5jb21tZW50cycpICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsKGVsZW1lbnQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHJ1ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRtb2RlbF0ud3JpdGVlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50bW9kZWxdLndyaXRlZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjIwMVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIyMDFcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMzAxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJmYWxzZVwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuTE1TQ29tbWl0ID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIwXCI7XG4gICAgICAgICAgICBpZiAocGFyYW0gPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBTdG9yZURhdGEoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIFRPQyB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChtbWFNb2RTY29ybUV2ZW50VXBkYXRlVG9jKTtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSByZXN1bHQgPyAnMCcgOiAnMTAxJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjMwMVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIyMDFcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcImZhbHNlXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5MTVNHZXRMYXN0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvckNvZGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gW107XG4gICAgICAgIGVycm9yU3RyaW5nW1wiMFwiXSA9IFwiTm8gZXJyb3JcIjtcbiAgICAgICAgZXJyb3JTdHJpbmdbXCIxMDFcIl0gPSBcIkdlbmVyYWwgZXhjZXB0aW9uXCI7XG4gICAgICAgIGVycm9yU3RyaW5nW1wiMjAxXCJdID0gXCJJbnZhbGlkIGFyZ3VtZW50IGVycm9yXCI7XG4gICAgICAgIGVycm9yU3RyaW5nW1wiMjAyXCJdID0gXCJFbGVtZW50IGNhbm5vdCBoYXZlIGNoaWxkcmVuXCI7XG4gICAgICAgIGVycm9yU3RyaW5nW1wiMjAzXCJdID0gXCJFbGVtZW50IG5vdCBhbiBhcnJheSAtIGNhbm5vdCBoYXZlIGNvdW50XCI7XG4gICAgICAgIGVycm9yU3RyaW5nW1wiMzAxXCJdID0gXCJOb3QgaW5pdGlhbGl6ZWRcIjtcbiAgICAgICAgZXJyb3JTdHJpbmdbXCI0MDFcIl0gPSBcIk5vdCBpbXBsZW1lbnRlZCBlcnJvclwiO1xuICAgICAgICBlcnJvclN0cmluZ1tcIjQwMlwiXSA9IFwiSW52YWxpZCBzZXQgdmFsdWUsIGVsZW1lbnQgaXMgYSBrZXl3b3JkXCI7XG4gICAgICAgIGVycm9yU3RyaW5nW1wiNDAzXCJdID0gXCJFbGVtZW50IGlzIHJlYWQgb25seVwiO1xuICAgICAgICBlcnJvclN0cmluZ1tcIjQwNFwiXSA9IFwiRWxlbWVudCBpcyB3cml0ZSBvbmx5XCI7XG4gICAgICAgIGVycm9yU3RyaW5nW1wiNDA1XCJdID0gXCJJbmNvcnJlY3QgZGF0YSB0eXBlXCI7XG5cbiAgICAgICAgc2VsZi5MTVNHZXRFcnJvclN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICBpZiAocGFyYW0gIT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvclN0cmluZ1twYXJhbV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5MTVNHZXREaWFnbm9zdGljID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgIGlmIChwYXJhbSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgcGFyYW0gPSBlcnJvckNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBkYXRhbW9kZWwgZm9yIFNDT1JNIDEuMiBwb3B1bGF0aW5nIGFsbCB0aGUgcmVxdWlyZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1EYXRhTW9kZWwxMiNpbml0QVBJXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29ybSAgICBUaGUgU0NPUk0gb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgICAgVGhlIFNDTyBpZC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgIFRoZSBhdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHVzZXJEYXRhIFRoZSB1c2VyIGRlZmF1bHQgZGF0YS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFttb2RlXSAgIE1vZGUuIE9uZSBvZiAkbW1hTW9kU2Nvcm0jTU9ERSBjb25zdGFudHMuIEJ5IGRlZmF1bHQsIE1PREVOT1JNQUwuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gb2ZmbGluZSBUcnVlIGlmIGF0dGVtcHQgaXMgb2ZmbGluZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaW5pdEFQSSA9IGZ1bmN0aW9uKHNjb3JtLCBzY29JZCwgYXR0ZW1wdCwgdXNlckRhdGEsIG1vZGUsIG9mZmxpbmUpIHtcbiAgICAgICAgbW9kZSA9IG1vZGUgfHwgJG1tYU1vZFNjb3JtLk1PREVOT1JNQUw7XG4gICAgICAgICR3aW5kb3cuQVBJID0gbmV3IFNDT1JNQVBJKHNjb3JtLCBzY29JZCwgYXR0ZW1wdCwgdXNlckRhdGEsIG1vZGUsIG9mZmxpbmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBkaWZmZXJlbnQgU0NPIGlkIGZvciB0aGUgY3VycmVudCBBUEkgb2JqZWN0LlxuICAgICAqIFRoZSBzY29JZCBpcyBsaWtlIGEgcG9pbnRlciB0byBiZSBhYmxlIHRvIHJldHJpZXZlIHRoZSBTQ08gZGVmYXVsdCB2YWx1ZXMgYW5kIHNldCB0aGUgbmV3IG9uZXMgaW4gdGhlIG92ZXJhbGwgU0NPUk0gZGF0YSBzdHJ1Y3R1cmVcbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1EYXRhTW9kZWwxMiNsb2FkU2NvXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29JZCBUaGUgbmV3IFNDTyBpZC5cbiAgICAgKi9cbiAgICBzZWxmLmxvYWRTY28gPSBmdW5jdGlvbihzY29JZCkge1xuICAgICAgICAkd2luZG93LkFQSS5zY29JZCA9IHNjb0lkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2ZmbGluZSBtb2RlIHRvIHRydWUgb3IgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtRGF0YU1vZGVsMTIjc2V0T2ZmbGluZVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG9mZmxpbmUgVHJ1ZSBpZiBvZmZsaW5lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5zZXRPZmZsaW5lID0gZnVuY3Rpb24ob2ZmbGluZSkge1xuICAgICAgICAkd2luZG93LkFQSS5vZmZsaW5lID0gb2ZmbGluZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9zY29ybScpXG5cbi8qKlxuICogTW9kIHNjb3JtIGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RTY29ybUhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kU2Nvcm1IYW5kbGVycycsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tYU1vZFNjb3JtLCAkbW1FdmVudHMsICRzdGF0ZSwgJG1tU2l0ZSwgJG1tYU1vZFNjb3JtSGVscGVyLFxuICAgICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLCBtbUNvcmVEb3dubG9hZGluZywgbW1Db3JlTm90RG93bmxvYWRlZCwgbW1Db3JlT3V0ZGF0ZWQsIG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsXG4gICAgICAgIG1tYU1vZFNjb3JtQ29tcG9uZW50LCAkcSwgJG1tQ29udGVudExpbmtzSGVscGVyKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvdXJzZSBjb250ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtSGFuZGxlcnMjY291cnNlQ29udGVudFxuICAgICAqL1xuICAgIHNlbGYuY291cnNlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgaW5mby5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIFRoZSBjb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgIHZhciBkb3dubG9hZEJ0bixcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEJ0bjtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYnV0dG9ucyB3aXRob3V0IGFjdGlvbiB5ZXQuIFRoaXMgaXMgdG8gcHJldmVudCBhIGdsaXRjaCBpbiB0aGUgdmlldy5cbiAgICAgICAgICAgICAgICBkb3dubG9hZEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWlvcy1jbG91ZC1kb3dubG9hZCcsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnbW0uY29yZS5kb3dubG9hZCdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1hbmRyb2lkLXJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ21tLmNvcmUucmVmcmVzaCcsXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKCdzY29ybScpO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICRzY29wZS5idXR0b25zID0gW2Rvd25sb2FkQnRuLCByZWZyZXNoQnRuXTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1vZF9zY29ybScsIHttb2R1bGU6IG1vZHVsZSwgY291cnNlaWQ6IGNvdXJzZWlkfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIFNDT1JNIHRvIGNhbGN1bGF0ZSB0aGUgcmVzdCBvZiBkYXRhLlxuICAgICAgICAgICAgICAgICRtbWFNb2RTY29ybS5nZXRTY29ybShjb3Vyc2VpZCwgbW9kdWxlLmlkLCBtb2R1bGUudXJsKS50aGVuKGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXZpc2lvbiA9IHNjb3JtLnNoYTFoYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb3dubG9hZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RTY29ybUhlbHBlci5jb25maXJtRG93bmxvYWQoc2Nvcm0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFNjb3JtLnByZWZldGNoKHNjb3JtKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRkZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RTY29ybUhlbHBlci5zaG93RG93bmxvYWRFcnJvcihzY29ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IGFkZCB0aGUgYWN0aW9uIHRvIHRoZSBidXR0b25zLlxuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEJ0bi5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoQnRuLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kU2Nvcm0uaW52YWxpZGF0ZUNvbnRlbnQoc2Nvcm0uY291cnNlbW9kdWxlKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IGJ1dHRvbnMgYWNjb3JkaW5nIHRvIG1vZHVsZSBzdGF0dXMuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBzdGF0dXMgPT09IG1tQ29yZURvd25sb2FkaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkQnRuLmhpZGRlbiA9IHN0YXR1cyAhPT0gbW1Db3JlTm90RG93bmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoQnRuLmhpZGRlbiA9IHN0YXR1cyAhPT0gbW1Db3JlT3V0ZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhpcyBtb2R1bGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzT2JzZXJ2ZXIgPSAkbW1FdmVudHMub24obW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2l0ZWlkID09PSAkbW1TaXRlLmdldElkKCkgJiYgZGF0YS5jb21wb25lbnRJZCA9PT0gc2Nvcm0uY291cnNlbW9kdWxlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY29tcG9uZW50ID09PSBtbWFNb2RTY29ybUNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dTdGF0dXMoZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgY3VycmVudCBzdGF0dXMgdG8gZGVjaWRlIHdoaWNoIGljb24gc2hvdWxkIGJlIHNob3duLlxuICAgICAgICAgICAgICAgICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLmdldE1vZHVsZVN0YXR1cyhtb2R1bGUsIGNvdXJzZWlkLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKS50aGVuKHNob3dTdGF0dXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNPYnNlcnZlciAmJiBzdGF0dXNPYnNlcnZlci5vZmYgJiYgc3RhdHVzT2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybUhhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICBTaXRlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoc2l0ZUlkLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlSWQgfHwgJG1tQ291cnNlLmNhbkdldE1vZHVsZVdpdGhvdXRDb3Vyc2VJZChzaXRlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgU0NPUk0gVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL3Njb3JtL3ZpZXcucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIudHJlYXRNb2R1bGVJbmRleFVybChzaXRlSWRzLCB1cmwsIGlzRW5hYmxlZCwgY291cnNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3Njb3JtJylcblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2F0aGVyIHNvbWUgY29tbW9uIFNDT1JNIGZ1bmN0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Db3Vyc2VIZWxwZXJcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RTY29ybUhlbHBlcicsIGZ1bmN0aW9uKCRtbWFNb2RTY29ybSwgJG1tVXRpbCwgJHRyYW5zbGF0ZSwgJHEsICRtbWFNb2RTY29ybU9mZmxpbmUsICRtbWFNb2RTY29ybVN5bmMsICRtbVNpdGUpIHtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGVsZW1lbnRzVG9JZ25vcmUgPSBbJ3N0YXR1cycsICdzY29yZV9yYXcnLCAndG90YWxfdGltZScsICdzZXNzaW9uX3RpbWUnLCAnc3R1ZGVudF9pZCcsICdzdHVkZW50X25hbWUnLCAnY3JlZGl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbW9kZScsICdlbnRyeSddOyAvLyBMaXN0IG9mIGVsZW1lbnRzIHdlIHdhbnQgdG8gaWdub3JlIHdoZW4gY29weWluZyBhdHRlbXB0cyAodGhleSdyZSBjYWxjdWxhdGVkKS5cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIG1lc3NhZ2UgdG8gc2hvdyB3YXJuaW5ncy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1IZWxwZXIjYnVpbGRXYXJuaW5nc01lc3NhZ2VcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gd2FybmluZ3MgV2FybmluZ3MgdG8gc2hvdy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgTWVzc2FnZSB3aXRoIGFsbCB0aGUgd2FybmluZ3MuXG4gICAgICovXG4gICAgc2VsZi5idWlsZFdhcm5pbmdzTWVzc2FnZSA9IGZ1bmN0aW9uKHdhcm5pbmdzKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJyc7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh3YXJuaW5ncywgZnVuY3Rpb24od2FybmluZykge1xuICAgICAgICAgICAgaWYgKHdhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSArICc8cD4nICsgd2FybmluZyArICc8L3A+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9mZmxpbmUgYXR0ZW1wdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvbmxpbmUgYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1IZWxwZXIjY29udmVydEF0dGVtcHRUb09mZmxpbmVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtICAgU0NPUk0uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0IE51bWJlciBvZiB0aGUgb25saW5lIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgYXR0ZW1wdCBpcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuY29udmVydEF0dGVtcHRUb09mZmxpbmUgPSBmdW5jdGlvbihzY29ybSwgYXR0ZW1wdCwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgLy8gR2V0IGRhdGEgZnJvbSB0aGUgb25saW5lIGF0dGVtcHQuXG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm1Vc2VyRGF0YShzY29ybS5pZCwgYXR0ZW1wdCwgZmFsc2UsIHNpdGVJZCkudGhlbihmdW5jdGlvbihvbmxpbmVEYXRhKSB7XG4gICAgICAgICAgICAvLyBUaGUgU0NPUk0gQVBJIG1pZ2h0IGhhdmUgd3JpdHRlbiBzb21lIGRhdGEgdG8gdGhlIG9mZmxpbmUgYXR0ZW1wdCBhbHJlYWR5LlxuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBvdmVycmlkZSBpdCB3aXRoIGNhY2hlZCBvbmxpbmUgZGF0YS5cbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmdldFNjb3JtVXNlckRhdGEoc2l0ZUlkLCBzY29ybS5pZCwgYXR0ZW1wdCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycy5cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ob2ZmbGluZURhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVRvU3RvcmUgPSBhbmd1bGFyLmNvcHkob25saW5lRGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIHRoZSBkYXRhIHRvIGNvcHkuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRhdGFUb1N0b3JlLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGNhbGN1bGF0ZWQgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNUb0lnbm9yZS5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NvLnVzZXJkYXRhW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgb2ZmbGluZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICBpZiAob2ZmbGluZURhdGEgJiYgb2ZmbGluZURhdGFbc2NvLnNjb2lkXSAmJiBvZmZsaW5lRGF0YVtzY28uc2NvaWRdLnVzZXJkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NvVXNlckRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY28udXNlcmRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvZmZsaW5lRGF0YVtzY28uc2NvaWRdLnVzZXJkYXRhW2VsZW1lbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZWxlbWVudCBpcyBub3Qgc3RvcmVkIGluIG9mZmxpbmUsIHdlIGNhbiBzYXZlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29Vc2VyRGF0YVtlbGVtZW50XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvLnVzZXJkYXRhID0gc2NvVXNlckRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmNyZWF0ZU5ld0F0dGVtcHQoc2l0ZUlkLCBzY29ybSwgdW5kZWZpbmVkLCBhdHRlbXB0LCBkYXRhVG9TdG9yZSwgb25saW5lRGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBTaG91bGRuJ3QgaGFwcGVuLlxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgkdHJhbnNsYXRlLmluc3RhbnQoJ21tYS5tb2Rfc2Nvcm0uZXJyb3JjcmVhdGVvZmZsaW5lYXR0ZW1wdCcpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2ZmbGluZSBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybUhlbHBlciNjcmVhdGVPZmZsaW5lQXR0ZW1wdFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2Nvcm0gICAgICBTQ09STS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG5ld0F0dGVtcHQgTnVtYmVyIG9mIHRoZSBuZXcgYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxhc3RPbmxpbmUgTnVtYmVyIG9mIHRoZSBsYXN0IG9ubGluZSBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSAgICBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGF0dGVtcHQgaXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmNyZWF0ZU9mZmxpbmVBdHRlbXB0ID0gZnVuY3Rpb24oc2Nvcm0sIG5ld0F0dGVtcHQsIGxhc3RPbmxpbmUsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICAvLyBUcnkgdG8gZ2V0IGRhdGEgZnJvbSBvbmxpbmUgYXR0ZW1wdHMuXG4gICAgICAgIHJldHVybiBzZWxmLnNlYXJjaE9ubGluZUF0dGVtcHRVc2VyRGF0YShzY29ybS5pZCwgbGFzdE9ubGluZSwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHVzZXJEYXRhKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBjcmVhdGluZyBhIG5ldyBhdHRlbXB0LCByZW1vdmUgYWxsIHRoZSB1c2VyIGRhdGEgdGhhdCBpcyBub3QgbmVlZGVkIGZvciBhIG5ldyBhdHRlbXB0LlxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgdGhlIFNDTyBkYXRhIGZyb20gaGVyZSBiZWNhdXNlIFdTIGdldF9zY29lcyBkb2Vzbid0IHJldHVybiBzY29fZGF0YSBpbiBNb29kbGUgMy4wLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHVzZXJEYXRhLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSB7fTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NvLnVzZXJkYXRhLCBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pbmRleE9mKCcuJykgPT0gLTEgJiYgZWxlbWVudHNUb0lnbm9yZS5pbmRleE9mKGVsZW1lbnQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBkb2Vzbid0IHVzZSBhIGRvdCBub3RhdGlvbiwgcHJvYmFibHkgU0NPIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFtlbGVtZW50XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2NvLnVzZXJkYXRhID0gZmlsdGVyZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmNyZWF0ZU5ld0F0dGVtcHQoc2l0ZUlkLCBzY29ybSwgdW5kZWZpbmVkLCBuZXdBdHRlbXB0LCB1c2VyRGF0YSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgkdHJhbnNsYXRlLmluc3RhbnQoJ21tYS5tb2Rfc2Nvcm0uZXJyb3JjcmVhdGVvZmZsaW5lYXR0ZW1wdCcpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3cgYSBjb25maXJtIGRpYWxvZyBpZiBuZWVkZWQuIElmIFNDT1JNIGRvZXNuJ3QgaGF2ZSBzaXplLCB0cnkgdG8gY2FsY3VsYXRlIGl0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybUhlbHBlciNjb25maXJtRG93bmxvYWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gU0NPUk0gdG8gZG93bmxvYWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgIFByb21pc2UgcmVzb2x2ZWQgaWYgdGhlIHVzZXIgY29uZmlybXMgb3Igbm8gY29uZmlybWF0aW9uIG5lZWRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmNvbmZpcm1Eb3dubG9hZCA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICBpZiAoIXNjb3JtLnBhY2thZ2VzaXplKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHBhY2thZ2Ugc2l6ZSwgdHJ5IHRvIGNhbGN1bGF0ZSBpdC5cbiAgICAgICAgICAgIHByb21pc2UgPSAkbW1hTW9kU2Nvcm0uY2FsY3VsYXRlU2Nvcm1TaXplKHNjb3JtKS50aGVuKGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBpdCBzbyB3ZSBkb24ndCBoYXZlIHRvIGNhbGN1bGF0ZSBpdCBhZ2FpbiB3aGVuIHVzaW5nIHRoZSBzYW1lIG9iamVjdC5cbiAgICAgICAgICAgICAgICBzY29ybS5wYWNrYWdlc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKHNjb3JtLnBhY2thZ2VzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbVV0aWwuY29uZmlybURvd25sb2FkU2l6ZShzaXplKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGF0dGVtcHQgdG8gY29udGludWUvcmV2aWV3LiBJdCB3aWxsIGJlOlxuICAgICAqIC0gVGhlIGxhc3QgaW5jb21wbGV0ZSBvbmxpbmUgYXR0ZW1wdCBpZiBpdCBoYXNuJ3QgYmVlbiBjb250aW51ZWQgaW4gb2ZmbGluZSBhbmQgYWxsIG9mZmxpbmUgYXR0ZW1wdHMgYXJlIGNvbXBsZXRlLlxuICAgICAqIC0gVGhlIGF0dGVtcHQgd2l0aCBoaWdoZXN0IG51bWJlciB3aXRob3V0IHN1cnBhc3NpbmcgbWF4IGF0dGVtcHRzIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1IZWxwZXIjZGV0ZXJtaW5lQXR0ZW1wdFRvQ29udGludWVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtICAgIFNDT1JNLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gYXR0ZW1wdHMgUmVzdWx0IG9mICRtbWFNb2RTY29ybSNnZXRBdHRlbXB0Q291bnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdICBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGFuIG9iamVjdCB3aXRoIDIgcHJvcGVydGllczogJ251bWJlcicgYW5kICdvZmZsaW5lJy5cbiAgICAgKi9cbiAgICBzZWxmLmRldGVybWluZUF0dGVtcHRUb0NvbnRpbnVlID0gZnVuY3Rpb24oc2Nvcm0sIGF0dGVtcHRzLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgdmFyIGxhc3RPbmxpbmUsXG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAwLFxuICAgICAgICAgICAgICAgIG9mZmxpbmU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdldCB0aGUgbGFzdCBhdHRlbXB0LiBJdCdsbCBiZSB0aGUgaGlnaGVzdCBudW1iZXIgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IHN1cnBhc3MgdGhlIG1heCBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gICAgICAgIGZ1bmN0aW9uIGdldExhc3RCZWZvcmVNYXgoKSB7XG4gICAgICAgICAgICBpZiAoc2Nvcm0ubWF4YXR0ZW1wdCAhPSAwICYmIGF0dGVtcHRzLmxhc3RBdHRlbXB0Lm51bWJlciA+IHNjb3JtLm1heGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubnVtYmVyID0gc2Nvcm0ubWF4YXR0ZW1wdDtcbiAgICAgICAgICAgICAgICByZXN1bHQub2ZmbGluZSA9IGF0dGVtcHRzLm9mZmxpbmUuaW5kZXhPZihzY29ybS5tYXhhdHRlbXB0KSA+IC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubnVtYmVyID0gYXR0ZW1wdHMubGFzdEF0dGVtcHQubnVtYmVyO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5vZmZsaW5lID0gYXR0ZW1wdHMubGFzdEF0dGVtcHQub2ZmbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBsYXN0IG9ubGluZSBhdHRlbXB0LlxuICAgICAgICBpZiAoYXR0ZW1wdHMub25saW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdE9ubGluZSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGF0dGVtcHRzLm9ubGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdE9ubGluZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbGFzdCBvbmxpbmUgaW5jb21wbGV0ZS5cbiAgICAgICAgICAgIHZhciBoYXNPZmZsaW5lID0gYXR0ZW1wdHMub2ZmbGluZS5pbmRleE9mKGxhc3RPbmxpbmUpID4gLTE7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmlzQXR0ZW1wdEluY29tcGxldGUoc2Nvcm0uaWQsIGxhc3RPbmxpbmUsIGhhc09mZmxpbmUsIGZhbHNlLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5udW1iZXIgPSBsYXN0T25saW5lO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQub2ZmbGluZSA9IGhhc09mZmxpbmU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0TGFzdEJlZm9yZU1heCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRMYXN0QmVmb3JlTWF4KCk7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgU0NPIHRvIGxvYWQgaW4gYSBTQ09STS4gSWYgYSBub24tZW1wdHkgVE9DIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJlIHRoZSBmaXJzdCB2YWxpZCBTQ08gaW4gdGhlIFRPQy5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgYmUgdGhlIGZpcnN0IHZhbGlkIFNDTyByZXR1cm5lZCBieSAkbW1hTW9kU2Nvcm0jZ2V0U2Nvcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1IZWxwZXIjZ2V0Rmlyc3RTY29cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2Nvcm1JZCAgICAgICAgU2Nvcm0gSUQuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gW3RvY10gICAgICAgIFNDT1JNJ3MgVE9DLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3JnYW5pemF0aW9uXSBPcmdhbml6YXRpb24gdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICAgICAgICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9mZmxpbmUgICAgICAgVHJ1ZSBpZiBhdHRlbXB0IGlzIG9mZmxpbmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gICAgICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBmaXJzdCBTQ08uXG4gICAgICovXG4gICAgc2VsZi5nZXRGaXJzdFNjbyA9IGZ1bmN0aW9uKHNjb3JtSWQsIHRvYywgb3JnYW5pemF0aW9uLCBhdHRlbXB0LCBvZmZsaW5lLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgIGlmICh0b2MgJiYgdG9jLmxlbmd0aCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4odG9jKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNDT1JNIGRvZXNuJ3QgaGF2ZSBhIFRPQy4gR2V0IGFsbCB0aGUgc2Nvcy5cbiAgICAgICAgICAgIHByb21pc2UgPSAkbW1hTW9kU2Nvcm0uZ2V0U2Nvc1dpdGhEYXRhKHNjb3JtSWQsIG9yZ2FuaXphdGlvbiwgYXR0ZW1wdCwgb2ZmbGluZSwgZmFsc2UsIHNpdGVJZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNjb3MpIHtcbiAgICAgICAgICAgIC8vIFNlYXJjaCB0aGUgZmlyc3QgdmFsaWQgU0NPLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY29zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjbyA9IHNjb3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNjby5pc3Zpc2libGUgJiYgc2NvLnByZXJlcSAmJiBzY28ubGF1bmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY287XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBUT0MgaW4gYXJyYXkgZm9ybWF0IChAc2VlICRtbWFNb2RTY29ybSNmb3JtYXRUb2NUb0FycmF5KSBhbmQgYSBzY29JZCwgcmV0dXJuIHRoZSBuZXh0IGF2YWlsYWJsZSBTQ08uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtSGVscGVyI2dldE5leHRTY29Gcm9tVG9jXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IHRvYyBTQ09STSdzIFRPQy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkIFNDTyBJRC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIE5leHQgU0NPLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0TmV4dFNjb0Zyb21Ub2MgPSBmdW5jdGlvbih0b2MsIHNjb0lkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0b2NbaV0uaWQgPT0gc2NvSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCB0aGUgY3VycmVudCBTQ08uIE5vdyBsZXQncyBzZWFyY2ggdGhlIG5leHQgdmlzaWJsZSBTQ08gd2l0aCBmdWxmaWxsZWQgcHJlcmVxdWlzaXRlcy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9jW2pdLmlzdmlzaWJsZSAmJiB0b2Nbal0ucHJlcmVxICYmIHRvY1tqXS5sYXVuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2Nbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBUT0MgaW4gYXJyYXkgZm9ybWF0IChAc2VlICRtbWFNb2RTY29ybSNmb3JtYXRUb2NUb0FycmF5KSBhbmQgYSBzY29JZCwgcmV0dXJuIHRoZSBwcmV2aW91cyBhdmFpbGFibGUgU0NPLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybUhlbHBlciNnZXRQcmV2aW91c1Njb0Zyb21Ub2NcbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gdG9jIFNDT1JNJ3MgVE9DLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgU0NPIElELlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgUHJldmlvdXMgU0NPLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UHJldmlvdXNTY29Gcm9tVG9jID0gZnVuY3Rpb24odG9jLCBzY29JZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9jLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodG9jW2ldLmlkID09IHNjb0lkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgdGhlIGN1cnJlbnQgU0NPLiBOb3cgbGV0J3Mgc2VhcmNoIHRoZSBwcmV2aW91cyB2aXNpYmxlIFNDTyB3aXRoIGZ1bGZpbGxlZCBwcmVyZXF1aXNpdGVzLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvY1tqXS5pc3Zpc2libGUgJiYgdG9jW2pdLnByZXJlcSAmJiB0b2Nbal0ubGF1bmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9jW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgVE9DIGluIGFycmF5IGZvcm1hdCAoQHNlZSAkbW1hTW9kU2Nvcm0jZm9ybWF0VG9jVG9BcnJheSkgYW5kIGEgc2NvSWQsIHJldHVybiB0aGUgU0NPLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybUhlbHBlciNnZXRTY29Gcm9tVG9jXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IHRvYyBTQ09STSdzIFRPQy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkIFNDTyBJRC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFNDTy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb0Zyb21Ub2MgPSBmdW5jdGlvbih0b2MsIHNjb0lkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0b2NbaV0uaWQgPT0gc2NvSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9jW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBTQ09STSBzeW5jIHRpbWUgaW4gYSBodW1hbiByZWFkYWJsZSBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtSGVscGVyI2dldFNjb3JtUmVhZGFibGVTeW5jVGltZVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSByZWFkYWJsZSB0aW1lLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2Nvcm1SZWFkYWJsZVN5bmNUaW1lID0gZnVuY3Rpb24oc2Nvcm1JZCwgc2l0ZUlkKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1TeW5jLmdldFNjb3JtU3luY1RpbWUoc2Nvcm1JZCwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aW1lID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZSgnbW0uY29yZS5ub25lJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb21lbnQodGltZSkuZm9ybWF0KCdMTEwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIHVzZXIgZGF0YSBmb3IgYW4gb25saW5lIGF0dGVtcHQuIElmIHRoZSBkYXRhIGNhbid0IGJlIHJldHJpZXZlZCxcbiAgICAgKiByZS10cnkgd2l0aCB0aGUgcHJldmlvdXMgb25saW5lIGF0dGVtcHQgKGlmIGV4aXN0cykuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtSGVscGVyI3NlYXJjaE9ubGluZUF0dGVtcHRVc2VyRGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCAgT25saW5lIGF0dGVtcHQgdG8gZ2V0IHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdXNlciBkYXRhLlxuICAgICAqL1xuICAgIHNlbGYuc2VhcmNoT25saW5lQXR0ZW1wdFVzZXJEYXRhID0gZnVuY3Rpb24oc2Nvcm1JZCwgYXR0ZW1wdCwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm1Vc2VyRGF0YShzY29ybUlkLCBhdHRlbXB0LCBmYWxzZSwgc2l0ZUlkKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkbid0IHJldHJpZXZlIHRoZSBkYXRhLiBUcnkgYWdhaW4gd2l0aCB0aGUgcHJldmlvdXMgb25saW5lIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2VhcmNoT25saW5lQXR0ZW1wdFVzZXJEYXRhKHNjb3JtSWQsIGF0dGVtcHQgLSAxLCBzaXRlSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBtb3JlIGF0dGVtcHRzIHRvIHRyeS4gUmVqZWN0XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvdyBlcnJvciBiZWNhdXNlIGEgU0NPUk0gZG93bmxvYWQgZmFpbGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybUhlbHBlciNzaG93RG93bmxvYWRFcnJvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSBTQ09STSBkb3dubG9hZGVkLlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc2VsZi5zaG93RG93bmxvYWRFcnJvciA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgICR0cmFuc2xhdGUoJ21tYS5tb2Rfc2Nvcm0uZXJyb3Jkb3dubG9hZHNjb3JtJywge25hbWU6IHNjb3JtLm5hbWV9KS50aGVuKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3Njb3JtJylcblxuLyoqXG4gKiBNb2QgU0NPUk0gcHJlZmV0Y2ggaGFuZGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kU2Nvcm1QcmVmZXRjaEhhbmRsZXJcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RTY29ybVByZWZldGNoSGFuZGxlcicsIGZ1bmN0aW9uKCRtbWFNb2RTY29ybSwgbW1hTW9kU2Nvcm1Db21wb25lbnQpIHtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICBzZWxmLmNvbXBvbmVudCA9IG1tYU1vZFNjb3JtQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkb3dubG9hZCBzaXplIG9mIGEgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybVByZWZldGNoSGFuZGxlciNnZXREb3dubG9hZFNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlICAgTW9kdWxlIHRvIGdldCB0aGUgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElEIHRoZSBtb2R1bGUgYmVsb25ncyB0by5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBzaXplLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RG93bmxvYWRTaXplID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldFNjb3JtKGNvdXJzZWlkLCBtb2R1bGUuaWQsIG1vZHVsZS51cmwpLnRoZW4oZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgICAgIGlmICgkbW1hTW9kU2Nvcm0uaXNTY29ybVN1cHBvcnRlZChzY29ybSkgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNjb3JtLnBhY2thZ2VzaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBwYWNrYWdlIHNpemUsIHRyeSB0byBjYWxjdWxhdGUgaXQuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5jYWxjdWxhdGVTY29ybVNpemUoc2Nvcm0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nvcm0ucGFja2FnZXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgZG93bmxvYWRhYmxlIGZpbGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybVByZWZldGNoSGFuZGxlciNnZXRGaWxlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgICBNb2R1bGUgdG8gZ2V0IHRoZSBmaWxlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElEIHRoZSBtb2R1bGUgYmVsb25ncyB0by5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFNpemUuXG4gICAgICovXG4gICAgc2VsZi5nZXRGaWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRTY29ybShjb3Vyc2VpZCwgbW9kdWxlLmlkLCBtb2R1bGUudXJsKS50aGVuKGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldFNjb3JtRmlsZUxpc3Qoc2Nvcm0pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFNDT1JNIG5vdCBmb3VuZCwgcmV0dXJuIGVtcHR5IGxpc3QuXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmV2aXNpb24gb2YgYSBTQ09STSAoc2hhMWhhc2gpLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybVByZWZldGNoSGFuZGxlciNnZXRSZXZpc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgICBNb2R1bGUgdG8gZ2V0IHRoZSByZXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElEIHRoZSBtb2R1bGUgYmVsb25ncyB0by5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgVGltZW1vZGlmaWVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UmV2aXNpb24gPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm0oY291cnNlaWQsIG1vZHVsZS5pZCwgbW9kdWxlLnVybCkudGhlbihmdW5jdGlvbihzY29ybSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3JtLnNoYTFoYXNoO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRpbWVtb2RpZmllZCBvZiBhIFNDT1JNLiBJdCBhbHdheXMgcmV0dXJuIDAsIHdlIGRvbid0IHVzZSB0aW1lbW9kaWZpZWQgZm9yIFNDT1JNIHBhY2thZ2VzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybVByZWZldGNoSGFuZGxlciNnZXRUaW1lbW9kaWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlICAgTW9kdWxlIHRvIGdldCB0aGUgdGltZW1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQgdGhlIG1vZHVsZSBiZWxvbmdzIHRvLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBUaW1lbW9kaWZpZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRUaW1lbW9kaWZpZWQgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybVByZWZldGNoSGFuZGxlciNpc0VuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIHRoZSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtUHJlZmV0Y2hIYW5kbGVyI3ByZWZldGNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSAgIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQgdGhlIG1vZHVsZSBiZWxvbmdzIHRvLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGZpbGVzIGhhdmUgYmVlbiBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldFNjb3JtKGNvdXJzZWlkLCBtb2R1bGUuaWQsIG1vZHVsZS51cmwpLnRoZW4oZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0ucHJlZmV0Y2goc2Nvcm0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9zY29ybScpXG5cbi8qKlxuICogU0NPUk0gc2VydmljZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kU2Nvcm1cbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RTY29ybScsIGZ1bmN0aW9uKCRtbVNpdGUsICRxLCAkdHJhbnNsYXRlLCAkbW1MYW5nLCAkbW1GaWxlcG9vbCwgJG1tRlMsICRtbVdTLCAkc2NlLCAkbW1hTW9kU2Nvcm1PbmxpbmUsICRzdGF0ZSxcbiAgICAgICAgICAgICRtbWFNb2RTY29ybU9mZmxpbmUsICRtbVV0aWwsICRsb2csICRtbVNpdGVzTWFuYWdlciwgbW1hTW9kU2Nvcm1Db21wb25lbnQsIG1tQ29yZU5vdERvd25sb2FkZWQpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU1vZFNjb3JtJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBzdGF0dXNlcyA9IFsnbm90YXR0ZW1wdGVkJywgJ3Bhc3NlZCcsICdjb21wbGV0ZWQnLCAnZmFpbGVkJywgJ2luY29tcGxldGUnLCAnYnJvd3NlZCcsICdzdXNwZW5kJ10sXG4gICAgICAgIGRvd25sb2FkUHJvbWlzZXMgPSB7fTsgLy8gU3RvcmUgZG93bmxvYWQgcHJvbWlzZXMgdG8gYmUgYWJsZSB0byByZXN0b3JlIHRoZW0uXG5cbiAgICAvLyBDb25zdGFudHMuXG4gICAgc2VsZi5HUkFERVNDT0VTICAgICA9IDA7XG4gICAgc2VsZi5HUkFERUhJR0hFU1QgICA9IDE7XG4gICAgc2VsZi5HUkFERUFWRVJBR0UgICA9IDI7XG4gICAgc2VsZi5HUkFERVNVTSAgICAgICA9IDM7XG5cbiAgICBzZWxmLkhJR0hFU1RBVFRFTVBUID0gMDtcbiAgICBzZWxmLkFWRVJBR0VBVFRFTVBUID0gMTtcbiAgICBzZWxmLkZJUlNUQVRURU1QVCAgID0gMjtcbiAgICBzZWxmLkxBU1RBVFRFTVBUICAgID0gMztcblxuICAgIHNlbGYuTU9ERUJST1dTRSA9ICdicm93c2UnO1xuICAgIHNlbGYuTU9ERU5PUk1BTCA9ICdub3JtYWwnO1xuICAgIHNlbGYuTU9ERVJFVklFVyA9ICdyZXZpZXcnO1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgU0NPUk0gZ3JhZGUgYmFzZWQgb24gdGhlIGdyYWRpbmcgbWV0aG9kIGFuZCB0aGUgbGlzdCBvZiBhdHRlbXB0cyBzY29yZXMuXG4gICAgICogV2Ugb25seSB0cmVhdCBvbmxpbmUgYXR0ZW1wdHMgdG8gY2FsY3VsYXRlIGEgU0NPUk0gZ3JhZGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2NhbGN1bGF0ZVNjb3JtR3JhZGVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtICAgICAgICAgICBTQ09STS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9ubGluZUF0dGVtcHRzICBPbmxpbmUgYXR0ZW1wdHMuIEVhY2ggYXR0ZW1wdCBtdXN0IGhhdmUgYSBwcm9wZXJ0eSBjYWxsZWQgXCJncmFkZVwiLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgIEdyYWRlLiAtMSBpZiBubyBncmFkZS5cbiAgICAgKi9cbiAgICBzZWxmLmNhbGN1bGF0ZVNjb3JtR3JhZGUgPSBmdW5jdGlvbihzY29ybSwgb25saW5lQXR0ZW1wdHMpIHtcbiAgICAgICAgaWYgKCFvbmxpbmVBdHRlbXB0cyB8fMKgIU9iamVjdC5rZXlzKG9ubGluZUF0dGVtcHRzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoc2Nvcm0ud2hhdGdyYWRlKSB7XG4gICAgICAgICAgICBjYXNlIHNlbGYuRklSU1RBVFRFTVBUOlxuICAgICAgICAgICAgICAgIHJldHVybiBvbmxpbmVBdHRlbXB0c1sxXSA/IG9ubGluZUF0dGVtcHRzWzFdLmdyYWRlIDogLTE7XG4gICAgICAgICAgICBjYXNlIHNlbGYuTEFTVEFUVEVNUFQ6XG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IDA7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKE9iamVjdC5rZXlzKG9ubGluZUF0dGVtcHRzKSwgZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG51bWJlciwgbWF4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25saW5lQXR0ZW1wdHNbbWF4XS5ncmFkZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgY2FzZSBzZWxmLkhJR0hFU1RBVFRFTVBUOlxuICAgICAgICAgICAgICAgIHZhciBncmFkZSA9IDA7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG9ubGluZUF0dGVtcHRzLCBmdW5jdGlvbihhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRlID0gTWF0aC5tYXgoYXR0ZW1wdC5ncmFkZSwgZ3JhZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBncmFkZTtcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5BVkVSQUdFQVRURU1QVDpcbiAgICAgICAgICAgICAgICB2YXIgc3VtZ3JhZGVzID0gMCxcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgPSAwO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChvbmxpbmVBdHRlbXB0cywgZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgICAgICBzdW1ncmFkZXMgKz0gYXR0ZW1wdC5ncmFkZTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWwrKztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChzdW1ncmFkZXMgLyB0b3RhbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNpemUgb2YgYSBTQ09STS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jY2FsY3VsYXRlU2Nvcm1TaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtIFNDT1JNLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIFNDT1JNIHNpemUuXG4gICAgICovXG4gICAgc2VsZi5jYWxjdWxhdGVTY29ybVNpemUgPSBmdW5jdGlvbihzY29ybSkge1xuICAgICAgICBpZiAoc2Nvcm0ucGFja2FnZXNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKHNjb3JtLnBhY2thZ2VzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1XUy5nZXRSZW1vdGVGaWxlU2l6ZShzZWxmLmdldFBhY2thZ2VVcmwoc2Nvcm0pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ291bnQgdGhlIGF0dGVtcHRzIGxlZnQgZm9yIHRoZSBnaXZlbiBzY29ybS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jY291bnRBdHRlbXB0c0xlZnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gICAgICAgICBTQ09STS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdHNDb3VudCBOdW1iZXIgb2YgYXR0ZW1wdHMgcGVyZm9ybWVkLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgIE51bWJlciBvZiBhdHRlbXB0cyBsZWZ0LlxuICAgICAqL1xuICAgIHNlbGYuY291bnRBdHRlbXB0c0xlZnQgPSBmdW5jdGlvbihzY29ybSwgYXR0ZW1wdHNDb3VudCkge1xuICAgICAgICBpZiAoc2Nvcm0ubWF4YXR0ZW1wdCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTsgLy8gVW5saW1pdGVkIGF0dGVtcHRzLlxuICAgICAgICB9XG5cbiAgICAgICAgYXR0ZW1wdHNDb3VudCA9IHBhcnNlSW50KGF0dGVtcHRzQ291bnQsIDEwKTtcbiAgICAgICAgaWYgKGlzTmFOKGF0dGVtcHRzQ291bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3JtLm1heGF0dGVtcHQgLSBhdHRlbXB0c0NvdW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2RlIGFuZCBhdHRlbXB0IG51bWJlciB0byB1c2UgYmFzZWQgb24gbW9kZSBzZWxlY3RlZCBhbmQgU0NPUk0gZGF0YS5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIE1vb2RsZSdzIHNjb3JtX2NoZWNrX21vZGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2RldGVybWluZUF0dGVtcHRBbmRNb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtICAgICAgIFNDT1JNLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlICAgICAgICBTZWxlY3RlZCBtb2RlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICAgICBDdXJyZW50IGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBuZXdBdHRlbXB0IFRydWUgaWYgc2hvdWxkIHN0YXJ0IGEgbmV3IGF0dGVtcHQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluY29tcGxldGUgVHJ1ZSBpZiBjdXJyZW50IGF0dGVtcHQgaXMgaW5jb21wbGV0ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzOiAnbW9kZScsICdhdHRlbXB0JyBhbmQgJ25ld0F0dGVtcHQnLlxuICAgICAqL1xuICAgIHNlbGYuZGV0ZXJtaW5lQXR0ZW1wdEFuZE1vZGUgPSBmdW5jdGlvbihzY29ybSwgbW9kZSwgYXR0ZW1wdCwgbmV3QXR0ZW1wdCwgaW5jb21wbGV0ZSkge1xuICAgICAgICBpZiAobW9kZSA9PSBzZWxmLk1PREVCUk9XU0UpIHtcbiAgICAgICAgICAgIGlmIChzY29ybS5oaWRlYnJvd3NlKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBCcm93c2UgbW9kZSBpZiBoaWRlYnJvd3NlIGlzIHNldC5cbiAgICAgICAgICAgICAgICBtb2RlID0gc2VsZi5NT0RFTk9STUFMO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGF0dGVtcHRzIGFzIGJyb3dzZSBtb2RlIGlzIHNldC5cbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBuZXdBdHRlbXB0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0LFxuICAgICAgICAgICAgICAgICAgICBuZXdBdHRlbXB0OiBuZXdBdHRlbXB0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHVzZXIgcmVxdWVzdCB0byBzdGFydCBhIG5ldyBhdHRlbXB0LlxuICAgICAgICBpZiAoYXR0ZW1wdCA9PSAwKSB7XG4gICAgICAgICAgICBuZXdBdHRlbXB0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9uIHRvIHN0YXJ0IGEgbmV3IGF0dGVtcHQgc2hvdWxkIG5ldmVyIGhhdmUgYmVlbiBwcmVzZW50ZWQuIEZvcmNlIGZhbHNlLlxuICAgICAgICAgICAgbmV3QXR0ZW1wdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNjb3JtLmZvcmNlbmV3YXR0ZW1wdCkge1xuICAgICAgICAgICAgLy8gQSBuZXcgYXR0ZW1wdCBzaG91bGQgYmUgZm9yY2VkIGZvciBhbHJlYWR5IGNvbXBsZXRlZCBhdHRlbXB0cy5cbiAgICAgICAgICAgIG5ld0F0dGVtcHQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0F0dGVtcHQgJiYgKHNjb3JtLm1heGF0dGVtcHQgPT0gMCB8fCBhdHRlbXB0IDwgc2Nvcm0ubWF4YXR0ZW1wdCkpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBhdHRlbXB0LiBGb3JjZSBtb2RlIG5vcm1hbC5cbiAgICAgICAgICAgIGF0dGVtcHQrKztcbiAgICAgICAgICAgIG1vZGUgPSBzZWxmLk1PREVOT1JNQUw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHJldmlldyBhbiBpbmNvbXBsZXRlIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgbW9kZSA9IHNlbGYuTU9ERU5PUk1BTDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlbid0IHN0YXJ0aW5nIGEgbmV3IGF0dGVtcHQgYW5kIHRoZSBjdXJyZW50IG9uZSBpcyBjb21wbGV0ZSwgZm9yY2UgcmV2aWV3IG1vZGUuXG4gICAgICAgICAgICAgICAgbW9kZSA9IHNlbGYuTU9ERVJFVklFVztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgICAgYXR0ZW1wdDogYXR0ZW1wdCxcbiAgICAgICAgICAgIG5ld0F0dGVtcHQ6IG5ld0F0dGVtcHRcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgVE9DIHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gdGhlIHBsYXllci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZGlzcGxheVRvY0luUGxheWVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtIFNDT1JNLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIHNob3VsZCBkaXNwbGF5IFRPQywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuZGlzcGxheVRvY0luUGxheWVyID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgcmV0dXJuIHNjb3JtLmhpZGV0b2MgIT09IDM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGFuZCB1bnppcHMgdGhlIFNDT1JNIHBhY2thZ2UuXG4gICAgICogQHNlZSAkbW1hTW9kU2Nvcm0jX2Rvd25sb2FkT3JQcmVmZXRjaFxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNkb3dubG9hZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSBTQ09STSBvYmplY3QgcmV0dXJuZWQgYnkgJG1tYU1vZFNjb3JtI2dldFNjb3JtLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHBhY2thZ2UgaXMgZG93bmxvYWRlZCBhbmQgdW56aXBwZWQuXG4gICAgICovXG4gICAgc2VsZi5kb3dubG9hZCA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9kb3dubG9hZE9yUHJlZmV0Y2goc2Nvcm0sIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzL1ByZWZldGNoZXMgYW5kIHVuemlwcyB0aGUgU0NPUk0gcGFja2FnZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jX2Rvd25sb2FkT3JQcmVmZXRjaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSAgICAgU0NPUk0gb2JqZWN0IHJldHVybmVkIGJ5ICRtbWFNb2RTY29ybSNnZXRTY29ybS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZldGNoIFRydWUgaWYgcHJlZmV0Y2gsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgcGFja2FnZSBpcyBkb3dubG9hZGVkIGFuZCB1bnppcHBlZC4gSXQgd2lsbCBjYWxsIG5vdGlmeSBpbiB0aGVzZSBjYXNlczpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLUZpbGUgZG93bmxvYWQgaW4gcHJvZ3Jlc3MuIE5vdGlmeSBvYmplY3Qgd2lsbCBoYXZlIHRoZXNlIHByb3BlcnRpZXM6XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrYWdlRG93bmxvYWQge0Jvb2xlYW59IEFsd2F5cyB0cnVlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkIHtOdW1iZXJ9IE51bWJlciBvZiBieXRlcyBvZiB0aGUgcGFja2FnZSBsb2FkZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlUHJvZ3Jlc3Mge09iamVjdH0gRmlsZVRyYW5zZmVyJ3Mgbm90aWZ5IHBhcmFtIGZvciB0aGUgY3VycmVudCBmaWxlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtRG93bmxvYWQgb3IgdW56aXAgc3RhcnRpbmcuIE5vdGlmeSBvYmplY3Qgd2lsbCBoYXZlIHRoZXNlIHByb3BlcnRpZXM6XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIHtTdHJpbmd9IE1lc3NhZ2UgY29kZSByZWxhdGVkIHRvIHRoZSBzdGFydGluZyBvcGVyYXRpb24uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1GaWxlIHVuemlwIGluIHByb2dyZXNzLiBOb3RpZnkgb2JqZWN0IHdpbGwgaGF2ZSB0aGVzZSBwcm9wZXJ0aWVzOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkIHtOdW1iZXJ9IE51bWJlciBvZiBieXRlcyB1bnppcHBlZC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsIHtOdW1iZXJ9IFRvdGFsIG9mIGJ5dGVzIG9mIHRoZSBaSVAgZmlsZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZG93bmxvYWRPclByZWZldGNoID0gZnVuY3Rpb24oc2Nvcm0sIHByZWZldGNoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBzZWxmLmlzU2Nvcm1TdXBwb3J0ZWQoc2Nvcm0pLFxuICAgICAgICAgICAgc2l0ZUlkID0gJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb3dubG9hZFByb21pc2VzW3NpdGVJZF0gJiYgZG93bmxvYWRQcm9taXNlc1tzaXRlSWRdW3Njb3JtLmlkXSkge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgZG93bmxvYWQgb25nb2luZyBmb3IgdGhpcyBwYWNrYWdlLCByZXR1cm4gdGhlIHByb21pc2UuXG4gICAgICAgICAgICByZXR1cm4gZG93bmxvYWRQcm9taXNlc1tzaXRlSWRdW3Njb3JtLmlkXTtcbiAgICAgICAgfSBlbHNlIGlmICghZG93bmxvYWRQcm9taXNlc1tzaXRlSWRdKSB7XG4gICAgICAgICAgICBkb3dubG9hZFByb21pc2VzW3NpdGVJZF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWxlcyA9IHNlbGYuZ2V0U2Nvcm1GaWxlTGlzdChzY29ybSksXG4gICAgICAgICAgICByZXZpc2lvbiA9IHNjb3JtLnNoYTFoYXNoLCAvLyBXZSB1c2Ugc2hhMWhhc2ggaW5zdGVhZCBvZiByZXZpc2lvbiBudW1iZXIuXG4gICAgICAgICAgICBkaXJQYXRoLFxuICAgICAgICAgICAgZGVmZXJyZWQgPSAkcS5kZWZlcigpLCAvLyBXZSB1c2UgYSBkZWZlcnJlZCB0byBiZSBhYmxlIHRvIG5vdGlmeS5cbiAgICAgICAgICAgIGZuID0gcHJlZmV0Y2ggPyAkbW1GaWxlcG9vbC5wcmVmZXRjaFBhY2thZ2UgOiAkbW1GaWxlcG9vbC5kb3dubG9hZFBhY2thZ2U7XG5cbiAgICAgICAgZG93bmxvYWRQcm9taXNlc1tzaXRlSWRdW3Njb3JtLmlkXSA9IGRlZmVycmVkLnByb21pc2U7IC8vIFN0b3JlIHByb21pc2UgdG8gYmUgYWJsZSB0byByZXN0b3JlIGl0IGxhdGVyLlxuXG4gICAgICAgIC8vIEdldCB0aGUgZm9sZGVyIHdoZXJlIHRoZSB1bnppcHBlZCBmaWxlcyB3aWxsIGJlLlxuICAgICAgICBzZWxmLmdldFNjb3JtRm9sZGVyKHNjb3JtLm1vZHVsZXVybCkudGhlbihmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICBkaXJQYXRoID0gcGF0aDtcbiAgICAgICAgICAgIC8vIERvd25sb2FkIHRoZSBaSVAgZmlsZSB0byB0aGUgZmlsZXBvb2wuXG4gICAgICAgICAgICAvLyBVc2luZyB1bmRlZmluZWQgZm9yIHN1Y2Nlc3MgJiBmYWlsIHdpbGwgcGFzcyB0aGUgc3VjY2Vzcy9mYWlsdXJlIHRvIHRoZSBwYXJlbnQgcHJvbWlzZS5cbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7bWVzc2FnZTogJ21tLmNvcmUuZG93bmxvYWRpbmcnfSk7XG4gICAgICAgICAgICByZXR1cm4gZm4oc2l0ZUlkLCBmaWxlcywgbW1hTW9kU2Nvcm1Db21wb25lbnQsIHNjb3JtLmNvdXJzZW1vZHVsZSwgcmV2aXNpb24sIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIgdG8gcHJldmVudCBoYXZpbmcgb2xkIHVudXNlZCBmaWxlcy5cbiAgICAgICAgICAgIHJldHVybiAkbW1GUy5yZW1vdmVEaXIoZGlyUGF0aCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycywgaXQgbWlnaHQgaGF2ZSBmYWlsZWQgYmVjYXVzZSB0aGUgZm9sZGVyIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgWklQIGZpbGUgcGF0aC5cbiAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXRGaWxlUGF0aEJ5VXJsKHNpdGVJZCwgc2VsZi5nZXRQYWNrYWdlVXJsKHNjb3JtKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oemlwcGF0aCkge1xuICAgICAgICAgICAgLy8gVW56aXAgYW5kIGRlbGV0ZSB0aGUgemlwIHdoZW4gZmluaXNoZWQuXG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoe21lc3NhZ2U6ICdtbS5jb3JlLnVuemlwcGluZyd9KTtcbiAgICAgICAgICAgIHJldHVybiAkbW1GUy51bnppcEZpbGUoemlwcGF0aCwgZGlyUGF0aCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wucmVtb3ZlRmlsZUJ5VXJsKHNpdGVJZCwgc2VsZi5nZXRQYWNrYWdlVXJsKHNjb3JtKSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIHVuemlwcGluZy4gU2V0IHN0YXR1cyBhcyBub3QgZG93bmxvYWRlZCBhbmQgcmVqZWN0LlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5zdG9yZVBhY2thZ2VTdGF0dXMoc2l0ZUlkLCBtbWFNb2RTY29ybUNvbXBvbmVudCwgc2Nvcm0uY291cnNlbW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbUNvcmVOb3REb3dubG9hZGVkLCByZXZpc2lvbiwgMCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgICAgICB9KS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkb3dubG9hZFByb21pc2VzW3NpdGVJZF1bc2Nvcm0uaWRdOyAvLyBEZWxldGUgc3RvcmVkIHByb21pc2UuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgbGl0dGxlIGxhbmd1YWdlIHBhcnNlciBmb3IgQUlDQ19TQ1JJUFQuXG4gICAgICogRXZhbHVhdGVzIHRoZSBleHByZXNzaW9uIGFuZCByZXR1cm5zIGEgYm9vbGVhbiBhbnN3ZXIuXG4gICAgICogU2VlIDIuMy4yLjUuMS4gU2VxdWVuY2luZy9OYXZpZ2F0aW9uIFRvZGF5ICAtIGZyb20gdGhlIFNDT1JNIDEuMiBzcGVjIChDQU0pLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNldmFsUHJlcmVxdWlzaXRlc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcHJlcmVxdWlzaXRlcyBUaGUgQUlDQ19TQ1JJUFQgcHJlcmVxdWlzaXRlcyBleHByZXNzaW9uLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdHJhY2tEYXRhICAgICBUaGUgdHJhY2tlZCB1c2VyIGRhdGEgb2YgZWFjaCBTQ08uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgIFRydWUgaWYgcHJlcmVxdWlzaXRlcyBhcmUgZnVsZmlsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5ldmFsUHJlcmVxdWlzaXRlcyA9IGZ1bmN0aW9uKHByZXJlcXVpc2l0ZXMsIHRyYWNrRGF0YSkge1xuXG4gICAgICAgIHZhciBzdGFjayA9IFtdLFxuICAgICAgICAgICAgc3RhdHVzZXMgPSB7XG4gICAgICAgICAgICAgICAgJ3Bhc3NlZCc6ICdwYXNzZWQnLFxuICAgICAgICAgICAgICAgICdjb21wbGV0ZWQnOiAnY29tcGxldGVkJyxcbiAgICAgICAgICAgICAgICAnZmFpbGVkJzogJ2ZhaWxlZCcsXG4gICAgICAgICAgICAgICAgJ2luY29tcGxldGUnOiAnaW5jb21wbGV0ZScsXG4gICAgICAgICAgICAgICAgJ2Jyb3dzZWQnOiAnYnJvd3NlZCcsXG4gICAgICAgICAgICAgICAgJ25vdCBhdHRlbXB0ZWQnOiAnbm90YXR0ZW1wdGVkJyxcbiAgICAgICAgICAgICAgICAncCc6ICdwYXNzZWQnLFxuICAgICAgICAgICAgICAgICdjJzogJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgJ2YnOiAnZmFpbGVkJyxcbiAgICAgICAgICAgICAgICAnaSc6ICdpbmNvbXBsZXRlJyxcbiAgICAgICAgICAgICAgICAnYic6ICdicm93c2VkJyxcbiAgICAgICAgICAgICAgICAnbic6ICdub3RhdHRlbXB0ZWQnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIEV4cGFuZCB0aGUgYW1wIGVudGl0aWVzLlxuICAgICAgICBwcmVyZXF1aXNpdGVzID0gcHJlcmVxdWlzaXRlcy5yZXBsYWNlKC8mYW1wOy9naSwgJyYnKTtcbiAgICAgICAgLy8gRmluZCBhbGwgbXkgcGFyc2FibGUgdG9rZW5zLlxuICAgICAgICBwcmVyZXF1aXNpdGVzID0gcHJlcmVxdWlzaXRlcy5yZXBsYWNlKC8oJnxcXHx8XFwofFxcKXxcXH4pL2dpLCAnXFx0JDFcXHQnKTtcbiAgICAgICAgLy8gRXhwYW5kIG9wZXJhdG9ycy5cbiAgICAgICAgcHJlcmVxdWlzaXRlcyA9IHByZXJlcXVpc2l0ZXMucmVwbGFjZSgvJi9naSwgJyYmJyk7XG4gICAgICAgIHByZXJlcXVpc2l0ZXMgPSBwcmVyZXF1aXNpdGVzLnJlcGxhY2UoL1xcfC9naSwgJ3x8Jyk7XG4gICAgICAgIC8vIE5vdyAtIGdyYWIgYWxsIHRoZSB0b2tlbnMuXG4gICAgICAgIHZhciBlbGVtZW50cyA9IHByZXJlcXVpc2l0ZXMudHJpbSgpLnNwbGl0KCdcXHQnKTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggdG9rZW4gdG8gYnVpbGQgYW4gZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlbGVtZW50Lm1hdGNoKC9eKCYmfFxcfFxcfHxcXCh8XFwpKSQvZ2kpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGVhY2ggaW5kaXZpZHVhbCBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgfiA9IDw+IFgqe30gLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlID0gL14oXFxkKylcXCpcXHsoLispXFx9JC8sIC8vIFNldHMgbGlrZSAzKntTMzQsIFMzNiwgUzM3LCBTMzl9LlxuICAgICAgICAgICAgICAgICAgICByZU90aGVyID0gL14oLispKFxcPXxcXDxcXD4pKC4rKSQvLCAvLyBPdGhlciBzeW1ib2xzLlxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlLnRlc3QoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IGVsZW1lbnQubWF0Y2gocmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXBlYXQgPSBtYXRjaGVzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0ID0gbWF0Y2hlc1syXS5zcGxpdCgnLCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2V0LCBmdW5jdGlvbihzZXRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRlbGVtZW50ID0gc2V0ZWxlbWVudC50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYWNrRGF0YVtzZXRlbGVtZW50XSAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHJhY2tEYXRhW3NldGVsZW1lbnRdLnN0YXR1cyA9PSAnY29tcGxldGVkJyB8fCB0cmFja0RhdGFbc2V0ZWxlbWVudF0uc3RhdHVzID09ICdwYXNzZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPj0gcmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gJ3RydWUnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgPT0gJ34nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBtYXBzIH4uXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAnISc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZU90aGVyLnRlc3QoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgc3ltYm9scyA9IHwgPD4gLlxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gZWxlbWVudC5tYXRjaChyZU90aGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG1hdGNoZXNbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYWNrRGF0YVtlbGVtZW50XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaGVzWzNdLnRyaW0oKS5yZXBsYWNlKC8oXFwnfFxcXCIpL2dpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzZXNbdmFsdWVdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdGF0dXNlc1t2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1syXSA9PSAnPD4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlciA9ICchPSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXIgPSAnPT0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9ICcoXFwnJyArIHRyYWNrRGF0YVtlbGVtZW50XS5zdGF0dXMgKyAnXFwnICcgKyBvcGVyICsgJyBcXCcnICsgdmFsdWUgKyAnXFwnKSc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gJ2ZhbHNlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBtdXN0IGJlIGFuIGVsZW1lbnQgZGVmaW5lZCBsaWtlIFM0NSAuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFja0RhdGFbZWxlbWVudF0gIT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHJhY2tEYXRhW2VsZW1lbnRdLnN0YXR1cyA9PSAnY29tcGxldGVkJyB8fCB0cmFja0RhdGFbZWxlbWVudF0uc3RhdHVzID09ICdwYXNzZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9ICd0cnVlJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAnZmFsc2UnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKCcgJyArIGVsZW1lbnQgKyAnICcpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZXZhbChzdGFjay5qb2luKCcnKSArICc7Jyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSBncmFkZSB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2Zvcm1hdEdyYWRlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29ybSBTQ09STS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdyYWRlIEdyYWRlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgR3JhZGUgdG8gZGlzcGxheS5cbiAgICAgKi9cbiAgICBzZWxmLmZvcm1hdEdyYWRlID0gZnVuY3Rpb24oc2Nvcm0sIGdyYWRlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ3JhZGUgPT0gJ3VuZGVmaW5lZCcgfHwgZ3JhZGUgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUubm9uZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY29ybS5ncmFkZW1ldGhvZCAhPT0gc2VsZi5HUkFERVNDT0VTICYmIHNjb3JtLm1heGdyYWRlID4gMCkge1xuICAgICAgICAgICAgZ3JhZGUgPSAoZ3JhZGUgLyBzY29ybS5tYXhncmFkZSkgKiAxMDA7XG4gICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLnBlcmNlbnRhZ2VudW1iZXInLCB7JGE6ICRtbVV0aWwucm91bmRUb0RlY2ltYWxzKGdyYWRlLCAyKX0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFkZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIHRyZWUtbGlrZSBUT0MgaW50byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZm9ybWF0VG9jVG9BcnJheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHRvYyAgICAgU0NPUk0ncyBUT0MgKHRyZWUgZm9ybWF0KS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2xldmVsPTBdIFRoZSBsZXZlbCBvZiB0aGUgVE9DIHdlJ3JlIHJpZ2h0IG5vdy4gMCBieSBkZWZhdWx0LlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgU0NPUk0ncyBUT0MgKGFycmF5IGZvcm1hdCkuXG4gICAgICovXG4gICAgc2VsZi5mb3JtYXRUb2NUb0FycmF5ID0gZnVuY3Rpb24odG9jLCBsZXZlbCkge1xuICAgICAgICBpZiAoIXRvYyB8fMKgIXRvYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxldmVsID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmb3JtYXR0ZWQgPSBbXTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHRvYywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgbm9kZS5sZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgZm9ybWF0dGVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQuY29uY2F0KHNlbGYuZm9ybWF0VG9jVG9BcnJheShub2RlLmNoaWxkcmVuLCBsZXZlbCArIDEpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgZG9uZSBieSBhIHVzZXIgaW4gdGhlIGdpdmVuIFNDT1JNLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNnZXRBdHRlbXB0Q291bnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgICAgICAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdICAgICAgIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdICAgICAgIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkIHVzZSBzaXRlJ3MgY3VycmVudCB1c2VyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlTWlzc2luZyBUcnVlIGlmIGl0IHNob3VsZCBpZ25vcmUgYXR0ZW1wdHMgd2l0aG91dCBncmFkZS9jb21wbGV0aW9uLiBPbmx5IGZvciBvbmxpbmUgYXR0ZW1wdHMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSAgIFRydWUgaWYgaXQgc2hvdWxkIGlnbm9yZSBjYWNoZWQgZGF0YSBmb3Igb25saW5lIGF0dGVtcHRzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGF0dGVtcHQgY291bnQgaXMgcmV0cmlldmVkLiBJdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubGluZSBhdHRlbXB0cywgb2ZmbGluZSBhdHRlbXB0cywgdG90YWwgbnVtYmVyIG9mIGF0dGVtcHRzIGFuZCBsYXN0IGF0dGVtcHQuXG4gICAgICovXG4gICAgc2VsZi5nZXRBdHRlbXB0Q291bnQgPSBmdW5jdGlvbihzY29ybUlkLCBzaXRlSWQsIHVzZXJJZCwgaWdub3JlTWlzc2luZywgaWdub3JlQ2FjaGUpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fCBzaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsYXN0QXR0ZW1wdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmbGluZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm1PbmxpbmUuZ2V0QXR0ZW1wdENvdW50KHNpdGVJZCwgc2Nvcm1JZCwgdXNlcklkLCBpZ25vcmVNaXNzaW5nLCBpZ25vcmVDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlcnMgb2Ygb25saW5lIGF0dGVtcHRzLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5vbmxpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5vbmxpbmUucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGxhc3QgYXR0ZW1wdC5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiByZXN1bHQubGFzdEF0dGVtcHQubnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5sYXN0QXR0ZW1wdC5udW1iZXIgPSBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmxhc3RBdHRlbXB0Lm9mZmxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtT2ZmbGluZS5nZXRBdHRlbXB0cyhzaXRlSWQsIHNjb3JtSWQsIHVzZXJJZCkudGhlbihmdW5jdGlvbihhdHRlbXB0cykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBvbmx5IGF0dGVtcHQgbnVtYmVycy5cbiAgICAgICAgICAgICAgICByZXN1bHQub2ZmbGluZSA9IGF0dGVtcHRzLm1hcChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgbGFzdCBhdHRlbXB0LiBXZSB1c2UgPj0gdG8gcHJpb3JpdGl6ZSBvZmZsaW5lIGV2ZW50cyBpZiBhbiBhdHRlbXB0IGlzIGJvdGggb25saW5lIGFuZCBvZmZsaW5lLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuYXR0ZW1wdCA+PSByZXN1bHQubGFzdEF0dGVtcHQubnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGFzdEF0dGVtcHQubnVtYmVyID0gZW50cnkuYXR0ZW1wdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5sYXN0QXR0ZW1wdC5vZmZsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuYXR0ZW1wdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSByZXN1bHQub25saW5lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXN1bHQub2ZmbGluZS5mb3JFYWNoKGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBhdHRlbXB0IGFsc28gZXhpc3RzIGluIG9ubGluZSwgaXQgbWlnaHQgaGF2ZSBiZWVuIGNvcGllZCB0byBsb2NhbC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5vbmxpbmUuaW5kZXhPZihhdHRlbXB0KSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC50b3RhbCA9IHRvdGFsO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZ3JhZGUgZm9yIGEgY2VydGFpbiBTQ09STSBhbmQgYXR0ZW1wdC5cbiAgICAgKiBCYXNlZCBvbiBNb29kbGUncyBzY29ybV9ncmFkZV91c2VyX2F0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldEF0dGVtcHRHcmFkZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybWlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvZmZsaW5lIFRydWUgaWYgYXR0ZW1wdCBpcyBvZmZsaW5lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZ3JhZGUuIElmIHRoZSBhdHRlbXB0IGhhc24ndCByZXBvcnRlZCBncmFkZS9jb21wbGV0aW9uLCBncmFkZSB3aWxsIGJlIC0xLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QXR0ZW1wdEdyYWRlID0gZnVuY3Rpb24oc2Nvcm0sIGF0dGVtcHQsIG9mZmxpbmUsIHNpdGVJZCkge1xuICAgICAgICB2YXIgYXR0ZW1wdHNjb3JlID0ge1xuICAgICAgICAgICAgc2NvczogMCxcbiAgICAgICAgICAgIHZhbHVlczogMCxcbiAgICAgICAgICAgIG1heDogMCxcbiAgICAgICAgICAgIHN1bTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmLmdldFNjb3JtVXNlckRhdGEoc2Nvcm0uaWQsIGF0dGVtcHQsIG9mZmxpbmUsIHNpdGVJZCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZGF0YSwgZnVuY3Rpb24oc2NvZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciB1c2VyZGF0YSA9IHNjb2RhdGEudXNlcmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJkYXRhLnN0YXR1cyA9PSAnY29tcGxldGVkJyB8fCB1c2VyZGF0YS5zdGF0dXMgPT0gJ3Bhc3NlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHNjb3JlLnNjb3MrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlcmRhdGEuc2NvcmVfcmF3IHx8ICh0eXBlb2Ygc2Nvcm0uc2Nvcm10eXBlICE9ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nvcm0uc2Nvcm10eXBlID09ICdzY28nICYmIHR5cGVvZiB1c2VyZGF0YS5zY29yZV9yYXcgIT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY29yZXJhdyA9IHBhcnNlRmxvYXQodXNlcmRhdGEuc2NvcmVfcmF3KTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHNjb3JlLnZhbHVlcysrO1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0c2NvcmUuc3VtICs9IHNjb3JlcmF3O1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0c2NvcmUubWF4ID0gTWF0aC5tYXgoc2NvcmVyYXcsIGF0dGVtcHRzY29yZS5tYXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2NvcmUgPSAwO1xuICAgICAgICAgICAgc3dpdGNoIChzY29ybS5ncmFkZW1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5HUkFERUhJR0hFU1Q6XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlID0gYXR0ZW1wdHNjb3JlLm1heDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHNlbGYuR1JBREVBVkVSQUdFOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdHNjb3JlLnZhbHVlcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlID0gYXR0ZW1wdHNjb3JlLnN1bSAvIGF0dGVtcHRzY29yZS52YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29yZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHNlbGYuR1JBREVTVU06XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlID0gYXR0ZW1wdHNjb3JlLnN1bTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHNlbGYuR1JBREVTQ09FUzpcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgPSBhdHRlbXB0c2NvcmUuc2NvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzY29yZSA9IGF0dGVtcHRzY29yZS5tYXg7ICAgLy8gUmVtb3RlIExlYXJuZXIgR1JBREVISUdIRVNUIGlzIGRlZmF1bHQuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzY29yZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBhIG9yZ2FuaXphdGlvbnMgZGVmaW5lZCBpbiBhIFNDT1JNIHBhY2thZ2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldE9yZ2FuaXphdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBvcmdhbml6YXRpb25zLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0T3JnYW5pemF0aW9ucyA9IGZ1bmN0aW9uKHNjb3JtSWQsIHNpdGVJZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRTY29zKHNjb3JtSWQsIHNpdGVJZCkudGhlbihmdW5jdGlvbihzY29zKSB7XG4gICAgICAgICAgICB2YXIgb3JnYW5pemF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjb3MsIGZ1bmN0aW9uKHNjbykge1xuICAgICAgICAgICAgICAgIC8vIElzIGFuIG9yZ2FuaXphdGlvbiBlbnRyeT9cbiAgICAgICAgICAgICAgICBpZiAoc2NvLm9yZ2FuaXphdGlvbiA9PSAnJyAmJiBzY28ucGFyZW50ID09ICcvJyAmJiBzY28uc2Nvcm10eXBlID09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZ2FuaXphdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBzY28uaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBzY28udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0b3JkZXI6IHNjby5zb3J0b3JkZXJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3JnYW5pemF0aW9ucztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb3JnYW5pemF0aW9uIFRvYyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZ2V0T3JnYW5pemF0aW9uVG9jXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29ybUlkICAgICAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBvcmdhbml6YXRpb24gT3JnYW5pemF0aW9uIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0ICAgICAgVGhlIGF0dGVtcHQgbnVtYmVyICh0byBwb3B1bGF0ZSBTQ08gdHJhY2sgZGF0YSkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvZmZsaW5lICAgICAgVHJ1ZSBpZiBhdHRlbXB0IGlzIG9mZmxpbmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gICAgICBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgdG9jIG9iamVjdC5cbiAgICAgKi9cbiAgICBzZWxmLmdldE9yZ2FuaXphdGlvblRvYyA9IGZ1bmN0aW9uKHNjb3JtSWQsIG9yZ2FuaXphdGlvbiwgYXR0ZW1wdCwgb2ZmbGluZSwgc2l0ZUlkKSB7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2Nvc1dpdGhEYXRhKHNjb3JtSWQsIG9yZ2FuaXphdGlvbiwgYXR0ZW1wdCwgb2ZmbGluZSwgZmFsc2UsIHNpdGVJZCkudGhlbihmdW5jdGlvbihzY29zKSB7XG4gICAgICAgICAgICB2YXIgbWFwID0ge30sXG4gICAgICAgICAgICAgICAgcm9vdFNjb3MgPSBbXTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjb3MsIGZ1bmN0aW9uKHNjbywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzY28uY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICBtYXBbc2NvLmlkZW50aWZpZXJdID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHNjby5wYXJlbnQgIT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvLnBhcmVudCA9PSBvcmdhbml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgYSByb290IFNDTywgYWRkIGl0IHRvIHRoZSByb290IGFycmF5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFNjb3MucHVzaChzY28pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgc2NvIHRvIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29zW21hcFtzY28ucGFyZW50XV0uY2hpbGRyZW4ucHVzaChzY28pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByb290U2NvcztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFja2FnZSBVUkwgb2YgYSBnaXZlbiBTQ09STS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZ2V0UGFja2FnZVVybFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2Nvcm0gU0NPUk0uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBQYWNrYWdlIFVSTC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFBhY2thZ2VVcmwgPSBmdW5jdGlvbihzY29ybSkge1xuICAgICAgICBpZiAoc2Nvcm0ucGFja2FnZXVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3JtLnBhY2thZ2V1cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3JtLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3JtLnJlZmVyZW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdXNlciBkYXRhIGZvciBhIGNlcnRhaW4gU0NPUk0gYW5kIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldFNjb3JtVXNlckRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICAgICAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvZmZsaW5lICAgICBUcnVlIGlmIGF0dGVtcHQgaXMgb2ZmbGluZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSAgICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBbc2Nvc10gICAgIFNDT3MgcmV0dXJuZWQgYnkgJG1tYU1vZFNjb3JtI2dldFNjb3MuIFJlY29tbWVuZGVkIGlmIG9mZmxpbmU9dHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIFRydWUgaWYgaXQgc2hvdWxkIGlnbm9yZSBjYWNoZWQgZGF0YSBmb3Igb25saW5lIGF0dGVtcHRzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSB1c2VyIGRhdGEgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2Nvcm1Vc2VyRGF0YSA9IGZ1bmN0aW9uKHNjb3JtSWQsIGF0dGVtcHQsIG9mZmxpbmUsIHNpdGVJZCwgc2NvcywgaWdub3JlQ2FjaGUpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgaWYgKG9mZmxpbmUpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gc2NvcyA/ICRxLndoZW4oc2NvcykgOiBzZWxmLmdldFNjb3Moc2Nvcm1JZCwgc2l0ZUlkKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2Nvcykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmdldFNjb3JtVXNlckRhdGEoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1bmRlZmluZWQsIHNjb3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT25saW5lLmdldFNjb3JtVXNlckRhdGEoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCBpZ25vcmVDYWNoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZ2V0IFNDT1JNIHNjb3MgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgU0NPUk0gSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY29zQ2FjaGVLZXkoc2Nvcm1JZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZFNjb3JtOnNjb3M6JyArIHNjb3JtSWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIFNDTyBvYmplY3RzIGZvciBhIGdpdmVuIFNDT1JNIGFuZCBvcmdhbml6YXRpb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldFNjb3NcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgICAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gICAgICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcmdhbml6YXRpb25dIE9yZ2FuaXphdGlvbiBJRC5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpZ25vcmVDYWNoZSAgIFRydWUgaWYgaXQgc2hvdWxkIGlnbm9yZSBjYWNoZWQgZGF0YSAoaXQgd2lsbCBhbHdheXMgZmFpbCBpZiBvZmZsaW5lIG9yIHNlcnZlciBkb3duKS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIGxpc3Qgb2YgU0NPIG9iamVjdHMuXG4gICAgICovXG4gICAgc2VsZi5nZXRTY29zID0gZnVuY3Rpb24oc2Nvcm1JZCwgc2l0ZUlkLCBvcmdhbml6YXRpb24sIGlnbm9yZUNhY2hlKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICBvcmdhbml6YXRpb24gPSBvcmdhbml6YXRpb24gfHwgJyc7XG5cbiAgICAgICAgICAgIC8vIERvbid0IHNlbmQgdGhlIG9yZ2FuaXphdGlvbiB0byB0aGUgV1MsIHdlJ2xsIGZpbHRlciB0aGVtIGxvY2FsbHkuXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29ybWlkOiBzY29ybUlkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0U2Nvc0NhY2hlS2V5KHNjb3JtSWQpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGlnbm9yZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgcHJlU2V0cy5nZXRGcm9tQ2FjaGUgPSAwO1xuICAgICAgICAgICAgICAgIHByZVNldHMuZW1lcmdlbmN5Q2FjaGUgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5yZWFkKCdtb2Rfc2Nvcm1fZ2V0X3Njb3JtX3Njb2VzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnNjb2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY29zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmdhbml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBTQ09zIGJ5IG9yZ2FuaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNwb25zZS5zY29lcywgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjby5vcmdhbml6YXRpb24gPT0gb3JnYW5pemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3MucHVzaChzY28pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcyA9IHJlc3BvbnNlLnNjb2VzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBTQ08gb2JqZWN0cyBmb3IgYSBnaXZlbiBTQ09STSBhbmQgb3JnYW5pemF0aW9uLCBpbmNsdWRpbmcgZGF0YSBhYm91dFxuICAgICAqIGEgY2VydGFpbiBhdHRlbXB0IChzdGF0dXMsIGlzdmlzaWJsZSwgLi4uKS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZ2V0U2Nvc1dpdGhEYXRhXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29ybUlkICAgICAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBvcmdhbml6YXRpb24gT3JnYW5pemF0aW9uIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCAgICAgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG9mZmxpbmUgICAgIFRydWUgaWYgYXR0ZW1wdCBpcyBvZmZsaW5lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgVHJ1ZSBpZiBpdCBzaG91bGQgaWdub3JlIGNhY2hlZCBkYXRhIGZvciBvbmxpbmUgYXR0ZW1wdHMuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSAgICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggYSBsaXN0IG9mIFNDTyBvYmplY3RzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2Nvc1dpdGhEYXRhID0gZnVuY3Rpb24oc2Nvcm1JZCwgb3JnYW5pemF0aW9uLCBhdHRlbXB0LCBvZmZsaW5lLCBpZ25vcmVDYWNoZSwgc2l0ZUlkKSB7XG4gICAgICAgIC8vIEdldCBvcmdhbml6YXRpb24gU0NPcy5cbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2NvcyhzY29ybUlkLCBzaXRlSWQsIG9yZ2FuaXphdGlvbiwgaWdub3JlQ2FjaGUpLnRoZW4oZnVuY3Rpb24oc2Nvcykge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB0cmFjayBkYXRhIGZvciBhbGwgdGhlIFNDT3MgaW4gdGhlIG9yZ2FuaXphdGlvbiBmb3IgdGhlIGdpdmVuIGF0dGVtcHQuXG4gICAgICAgICAgICAvLyBXZSdsbCB1c2UgdGhpcyBkYXRhIHRvIHNldCBTQ08gZGF0YSBsaWtlIGlzdmlzaWJsZSwgc3RhdHVzIGFuZCBzby5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFNjb3JtVXNlckRhdGEoc2Nvcm1JZCwgYXR0ZW1wdCwgb2ZmbGluZSwgc2l0ZUlkLCBzY29zLCBpZ25vcmVDYWNoZSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tEYXRhQnlTQ08gPSB7fTtcblxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHBvcHVsYXRlIHRyYWNrRGF0YUJ5U0NPIHRvIGluZGV4IGJ5IFNDTyBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY29zLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tEYXRhQnlTQ09bc2NvLmlkZW50aWZpZXJdID0gZGF0YVtzY28uaWRdLnVzZXJkYXRhO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjb3MsIGZ1bmN0aW9uKHNjbykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgc3BlY2lmaWMgU0NPIGluZm9ybWF0aW9uIChyZWxhdGVkIHRvIHRyYWNrZWQgZGF0YSkuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY29kYXRhID0gZGF0YVtzY28uaWRdLnVzZXJkYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpc3Zpc2libGUgYXR0cmlidXRlLlxuICAgICAgICAgICAgICAgICAgICBzY28uaXN2aXNpYmxlID0gdHlwZW9mIHNjb2RhdGEuaXN2aXNpYmxlICE9ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvZGF0YS5pc3Zpc2libGUgJiYgc2NvZGF0YS5pc3Zpc2libGUgIT09ICdmYWxzZScgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBwcmUtcmVxdWlzaXRlcyBzdGF0dXMuXG4gICAgICAgICAgICAgICAgICAgIHNjby5wcmVyZXEgPSB0eXBlb2Ygc2NvZGF0YS5wcmVyZXF1aXNpdGVzID09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXZhbFByZXJlcXVpc2l0ZXMoc2NvZGF0YS5wcmVyZXF1aXNpdGVzLCB0cmFja0RhdGFCeVNDTyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzdGF0dXMuXG4gICAgICAgICAgICAgICAgICAgIHNjby5zdGF0dXMgPSAodHlwZW9mIHNjb2RhdGEuc3RhdHVzID09ICd1bmRlZmluZWQnwqB8fCBzY29kYXRhLnN0YXR1cyA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vdGF0dGVtcHRlZCcgOiBzY29kYXRhLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCB2YXIuXG4gICAgICAgICAgICAgICAgICAgIHNjby5leGl0dmFyID0gdHlwZW9mIHNjb2RhdGEuZXhpdHZhciA9PSAndW5kZWZpbmVkJyA/ICdjbWkuY29yZS5leGl0JyA6IHNjb2RhdGEuZXhpdHZhcjtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmV4aXR2YWx1ZSA9IHNjb2RhdGFbc2NvLmV4aXR2YXJdO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgU0NPUk0gYW5kIGEgU0NPLCByZXR1cm5zIHRoZSBmdWxsIGxhdW5jaCBVUkwgZm9yIHRoZSBTQ08uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldFNjb1NyY1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2Nvcm0gICBTQ09STS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjbyAgICAgU0NPLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIFVSTC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb1NyYyA9IGZ1bmN0aW9uKHNjb3JtLCBzY28sIHNpdGVJZCkge1xuICAgICAgICBpZiAoc2NvLmxhdW5jaC5tYXRjaCgvaHR0cChzKT86XFwvXFwvLykpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgYW4gb25saW5lIFVSTC5cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKCRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKHNjby5sYXVuY2gpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmdldERpcmVjdG9yeVVybEJ5VXJsKHNpdGVJZCwgc2Nvcm0ubW9kdWxldXJsKS50aGVuKGZ1bmN0aW9uKGRpclBhdGgpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgVVJMIGlzIGdvaW5nIHRvIGJlIGluamVjdGVkIGluIGFuIGlmcmFtZSwgd2UgbmVlZCB0cnVzdEFzUmVzb3VyY2VVcmwgdG8gbWFrZSBpdCB3b3JrIGluIGEgYnJvd3Nlci5cbiAgICAgICAgICAgIHJldHVybiAkc2NlLnRydXN0QXNSZXNvdXJjZVVybCgkbW1GUy5jb25jYXRlbmF0ZVBhdGhzKGRpclBhdGgsIHNjby5sYXVuY2gpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGEgU0NPUk0gaXMgZG93bmxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZ2V0U2Nvcm1Gb2xkZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1vZHVsZVVybCBNb2R1bGUgVVJMIChyZXR1cm5lZCBieSBnZXRfY291cnNlX2NvbnRlbnRzKS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gICBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZm9sZGVyIHBhdGguXG4gICAgICovXG4gICAgc2VsZi5nZXRTY29ybUZvbGRlciA9IGZ1bmN0aW9uKG1vZHVsZVVybCwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXRGaWxlUGF0aEJ5VXJsKHNpdGVJZCwgbW9kdWxlVXJsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgZmlsZXMgdG8gZG93bmxhb2QgZm9yIGEgU0NPUk0sIHVzaW5nIGEgZm9ybWF0IHNpbWlsYXIgdG8gbW9kdWxlLmNvbnRlbnRzIGZyb20gZ2V0X2NvdXJzZV9jb250ZW50cy5cbiAgICAgKiBJdCB3aWxsIG9ubHkgcmV0dXJuIG9uZSBmaWxlOiB0aGUgWklQIHBhY2thZ2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldFNjb3JtRmlsZUxpc3RcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtIFNDT1JNLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgRmlsZSBsaXN0LlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2Nvcm1GaWxlTGlzdCA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IFtdO1xuICAgICAgICBpZiAoc2VsZi5pc1Njb3JtU3VwcG9ydGVkKHNjb3JtKSA9PT0gdHJ1ZSAmJiAhc2Nvcm0ud2FybmluZ21lc3NhZ2UpIHtcbiAgICAgICAgICAgIGZpbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGZpbGV1cmw6IHNlbGYuZ2V0UGFja2FnZVVybChzY29ybSksXG4gICAgICAgICAgICAgICAgZmlsZXBhdGg6ICcvJyxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogc2Nvcm0ucmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIGZpbGVzaXplOiBzY29ybS5wYWNrYWdlc2l6ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgVVJMIGFuZCBkZXNjcmlwdGlvbiBvZiB0aGUgc3RhdHVzIGljb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldFNjb1N0YXR1c0ljb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvICAgICAgICAgU0NPLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jb21wbGV0ZSBUcnVlIGlmIFNDT1JNIGlzIGluY29tcGxldGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgSW1hZ2UgVVJMIGFuZCBkZXNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb1N0YXR1c0ljb24gPSBmdW5jdGlvbihzY28sIGluY29tcGxldGUpIHtcbiAgICAgICAgdmFyIGltYWdlbmFtZSA9ICcnLFxuICAgICAgICAgICAgZGVzY25hbWUgPSAnJyxcbiAgICAgICAgICAgIHN0YXR1cztcblxuICAgICAgICBpZiAoc2NvLnNjb3JtdHlwZSA9PSAnc2NvJykge1xuICAgICAgICAgICAgLy8gTm90IGFuIGFzc2V0LCBjYWxjdWxhdGUgaW1hZ2UgdXNpbmcgc3RhdHVzLlxuICAgICAgICAgICAgc3RhdHVzID0gc2NvLnN0YXR1cztcbiAgICAgICAgICAgIGlmIChzdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzIGVtcHR5IG9yIG5vdCB2YWxpZCwgdXNlICdub3RhdHRlbXB0ZWQnLlxuICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdub3RhdHRlbXB0ZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgU0NPIGlzIGNvbXBsZXRlZCBvciBub3QuIElmIFNDT1JNIGlzIGluY29tcGxldGUgdGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIFNDTy5cbiAgICAgICAgICAgICAgICBpbmNvbXBsZXRlID0gc2VsZi5pc1N0YXR1c0luY29tcGxldGUoc3RhdHVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluY29tcGxldGUgJiYgc2NvLmV4aXR2YWx1ZSA9PSAnc3VzcGVuZCcpIHtcbiAgICAgICAgICAgICAgICBpbWFnZW5hbWUgPSAnc3VzcGVuZCc7XG4gICAgICAgICAgICAgICAgZGVzY25hbWUgPSAnc3VzcGVuZGVkJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VuYW1lID0gc2NvLnN0YXR1cztcbiAgICAgICAgICAgICAgICBkZXNjbmFtZSA9IHNjby5zdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWFnZW5hbWUgPSAnYXNzZXQnO1xuICAgICAgICAgICAgZGVzY25hbWUgPSAoIXNjby5zdGF0dXMgfHwgc2NvLnN0YXR1cyA9PSAnbm90YXR0ZW1wdGVkJykgPyAnYXNzZXQnIDogJ2Fzc2V0bGF1bmNoZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybDogJ2FkZG9ucy9tb2Rfc2Nvcm0vaW1nLycgKyBpbWFnZW5hbWUgKyAnLmdpZicsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLicgKyBkZXNjbmFtZSlcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgU0NPUk0gZGF0YSBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY29ybURhdGFDYWNoZUtleShjb3Vyc2VJZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZFNjb3JtOnNjb3JtOicgKyBjb3Vyc2VJZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBTQ09STSB3aXRoIGtleT12YWx1ZS4gSWYgbW9yZSB0aGFuIG9uZSBpcyBmb3VuZCwgb25seSB0aGUgZmlyc3Qgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VJZCAgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30ga2V5ICAgICAgIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSAge01peGVkfSB2YWx1ZSAgICAgIFZhbHVlIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1vZHVsZVVybCBNb2R1bGUgVVJMLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgU0NPUk0gaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNjb3JtKHNpdGVJZCwgY291cnNlSWQsIGtleSwgdmFsdWUsIG1vZHVsZVVybCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdXJzZWlkczogW2NvdXJzZUlkXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldFNjb3JtRGF0YUNhY2hlS2V5KGNvdXJzZUlkKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBzaXRlLnJlYWQoJ21vZF9zY29ybV9nZXRfc2Nvcm1zX2J5X2NvdXJzZXMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc2Nvcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2Nvcm07XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNwb25zZS5zY29ybXMsIGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRTY29ybSAmJiBzY29ybVtrZXldID09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3JtID0gc2Nvcm07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgU0NPUk0gaXNuJ3QgYXZhaWxhYmxlIHRoZSBXUyByZXR1cm5zIGEgd2FybmluZyBhbmQgaXQgZG9lc24ndCByZXR1cm4gdGltZW9wZW4gYW5kIHRpbWVjbG9zZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRTY29ybS50aW1lb3BlbiA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNwb25zZS53YXJuaW5ncywgZnVuY3Rpb24od2FybmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FybmluZy5pdGVtaWQgPT09IGN1cnJlbnRTY29ybS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3JtLndhcm5pbmdtZXNzYWdlID0gd2FybmluZy5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Nvcm0ubW9kdWxldXJsID0gbW9kdWxlVXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTY29ybTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgU0NPUk0gYnkgbW9kdWxlIElELlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNnZXRTY29ybVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCAgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbWlkICAgICAgQ291cnNlIG1vZHVsZSBJRC5cbiAgICAgKiBAcGFybWEge1N0cmluZ30gbW9kdWxlVXJsIE1vZHVsZSBVUkwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdICBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBTQ09STSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRTY29ybSA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBjbWlkLCBtb2R1bGVVcmwsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICByZXR1cm4gZ2V0U2Nvcm0oc2l0ZUlkLCBjb3Vyc2VJZCwgJ2NvdXJzZW1vZHVsZScsIGNtaWQsIG1vZHVsZVVybCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIFNDT1JNIGJ5IFNDT1JNIElELlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNnZXRTY29ybUJ5SWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY21pZCAgICAgIENvdXJzZSBtb2R1bGUgSUQuXG4gICAgICogQHBhcm1hIHtTdHJpbmd9IG1vZHVsZVVybCBNb2R1bGUgVVJMLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgU0NPUk0gaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2Nvcm1CeUlkID0gZnVuY3Rpb24oY291cnNlSWQsIGlkLCBtb2R1bGVVcmwsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICByZXR1cm4gZ2V0U2Nvcm0oc2l0ZUlkLCBjb3Vyc2VJZCwgJ2lkJywgaWQsIG1vZHVsZVVybCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHJlYWRhYmxlIFNDT1JNIGdyYWRlIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZ2V0U2Nvcm1HcmFkaW5nTWV0aG9kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtIFNDT1JNLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICBHcmFkaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb3JtR3JhZGVNZXRob2QgPSBmdW5jdGlvbihzY29ybSkge1xuICAgICAgICBpZiAoc2Nvcm0ubWF4YXR0ZW1wdCA9PSAxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnNlSW50KHNjb3JtLmdyYWRlbWV0aG9kLCAxMCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHNlbGYuR1JBREVISUdIRVNUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLmdyYWRlaGlnaGVzdCcpO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5HUkFERUFWRVJBR0U6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tYS5tb2Rfc2Nvcm0uZ3JhZGVhdmVyYWdlJyk7XG4gICAgICAgICAgICAgICAgY2FzZSBzZWxmLkdSQURFU1VNOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLmdyYWRlc3VtJyk7XG4gICAgICAgICAgICAgICAgY2FzZSBzZWxmLkdSQURFU0NPRVM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tYS5tb2Rfc2Nvcm0uZ3JhZGVzY29lcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJzZUludChzY29ybS53aGF0Z3JhZGUsIDEwKSkge1xuICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5ISUdIRVNUQVRURU1QVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUuaW5zdGFudCgnbW1hLm1vZF9zY29ybS5oaWdoZXN0YXR0ZW1wdCcpO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5BVkVSQUdFQVRURU1QVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUuaW5zdGFudCgnbW1hLm1vZF9zY29ybS5hdmVyYWdlYXR0ZW1wdCcpO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5GSVJTVEFUVEVNUFQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tYS5tb2Rfc2Nvcm0uZmlyc3RhdHRlbXB0Jyk7XG4gICAgICAgICAgICAgICAgY2FzZSBzZWxmLkxBU1RBVFRFTVBUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLmxhc3RhdHRlbXB0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgYWxsIHRoZSBkYXRhIHJlbGF0ZWQgdG8gYSBjZXJ0YWluIFNDT1JNLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpbnZhbGlkYXRlQWxsU2Nvcm1EYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUFsbFNjb3JtRGF0YSA9IGZ1bmN0aW9uKHNjb3JtSWQsIHNpdGVJZCwgdXNlcklkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RTY29ybU9ubGluZS5pbnZhbGlkYXRlQXR0ZW1wdENvdW50KHNpdGVJZCwgc2Nvcm1JZCwgdXNlcklkKSk7XG4gICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5pbnZhbGlkYXRlU2NvcyhzY29ybUlkLCBzaXRlSWQpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm1PbmxpbmUuaW52YWxpZGF0ZVNjb3JtVXNlckRhdGEoc2l0ZUlkLCBzY29ybUlkKSk7XG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIHRoZSBwcmVmZXRjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2ludmFsaWRhdGVDb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZUlkIFRoZSBtb2R1bGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlSWQsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuaW52YWxpZGF0ZUZpbGVzQnlDb21wb25lbnQoc2l0ZUlkLCBtbWFNb2RTY29ybUNvbXBvbmVudCwgbW9kdWxlSWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBTQ09STSBzY29zIGZvciBhbGwgb3JnYW5pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaW52YWxpZGF0ZVNjb3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlU2NvcyA9IGZ1bmN0aW9uKHNjb3JtSWQsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldFNjb3NDYWNoZUtleShzY29ybUlkKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBTQ09STSBkYXRhLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpbnZhbGlkYXRlU2Nvcm1EYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZVNjb3JtRGF0YSA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRTY29ybURhdGFDYWNoZUtleShjb3Vyc2VJZCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBTQ09STSdzIGF0dGVtcHQgaXMgaW5jb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaXNBdHRlbXB0SW5jb21wbGV0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybUlkICAgICAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgICAgICBBdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2ZmbGluZSAgICAgVHJ1ZSBpZiBhdHRlbXB0IGlzIG9mZmxpbmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIFRydWUgaWYgaXQgc2hvdWxkIGlnbm9yZSBjYWNoZWQgZGF0YSBmb3Igb25saW5lIGF0dGVtcHRzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSAgICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIGJvb2xlYW46IHRydWUgaWYgaW5jb21wbGV0ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNBdHRlbXB0SW5jb21wbGV0ZSA9IGZ1bmN0aW9uKHNjb3JtSWQsIGF0dGVtcHQsIG9mZmxpbmUsIGlnbm9yZUNhY2hlLCBzaXRlSWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2Nvc1dpdGhEYXRhKHNjb3JtSWQsIHVuZGVmaW5lZCwgYXR0ZW1wdCwgb2ZmbGluZSwgaWdub3JlQ2FjaGUsIHNpdGVJZCkudGhlbihmdW5jdGlvbihzY29zKSB7XG4gICAgICAgICAgICB2YXIgaW5jb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NvcywgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIFNDT3Mgbm90IHZpc2libGUgb3Igd2l0aG91dCBsYXVuY2ggVVJMLlxuICAgICAgICAgICAgICAgIGlmIChzY28uaXN2aXNpYmxlICYmIHNjby5sYXVuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNTdGF0dXNJbmNvbXBsZXRlKHNjby5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gaW5jb21wbGV0ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGlzIGVuYWJsZWQgaW4gYSBjZXJ0YWluIHNpdGUuIFBsdWdpbiBpcyBlbmFibGVkIGlmIHRoZSBzY29ybSBXUyBhcmUgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX3Njb3JtX2dldF9zY29ybV9hdHRlbXB0X2NvdW50JykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX3Njb3JtX2dldF9zY29ybV9zY29fdHJhY2tzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX3Njb3JtX2dldF9zY29ybV9zY29lcycpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9zY29ybV9nZXRfc2Nvcm1fdXNlcl9kYXRhJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX3Njb3JtX2dldF9zY29ybXNfYnlfY291cnNlcycpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9zY29ybV9pbnNlcnRfc2Nvcm1fdHJhY2tzJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIFNDT1JNIGlzIGJlaW5nIHBsYXllZCByaWdodCBub3cuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2lzU2Nvcm1CZWluZ1BsYXllZFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gIHNjb3JtSWQgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdICBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgVHJ1ZSBpZiBpdCdzIGJlaW5nIHBsYXllZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNTY29ybUJlaW5nUGxheWVkID0gZnVuY3Rpb24oc2Nvcm1JZCwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmdldElkKCkgPT0gc2l0ZUlkICYmICRzdGF0ZS5jdXJyZW50Lm5hbWUgPT0gJ3NpdGUubW9kX3Njb3JtLXBsYXllcicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5wYXJhbXMuc2Nvcm0gJiYgJHN0YXRlLnBhcmFtcy5zY29ybS5pZCA9PSBzY29ybUlkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gU0NPUk0gaXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpc1Njb3JtQ2xvc2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtIFNDT1JNIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIFNDT1JNIGlzIGNsb3NlZCwgZmFsc2UgaWYgaXQgaGFzbid0IGNsb3NlZCB5ZXQuXG4gICAgICovXG4gICAgc2VsZi5pc1Njb3JtQ2xvc2VkID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgdmFyIHRpbWVOb3cgPSAkbW1VdGlsLnRpbWVzdGFtcCgpO1xuICAgICAgICBpZiAoc2Nvcm0udGltZWNsb3NlID4gMCAmJiB0aW1lTm93ID4gc2Nvcm0udGltZWNsb3NlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBTQ09STSBpcyBkb3dubG9hZGFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2lzU2Nvcm1Eb3dubG9hZGFibGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gU0NPUk0gdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUgaWYgU0NPUk0gaXMgZG93bmxvYWRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1Njb3JtRG93bmxvYWRhYmxlID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzY29ybS5wcm90ZWN0cGFja2FnZWRvd25sb2FkcyAhPSAndW5kZWZpbmVkJyAmJiBzY29ybS5wcm90ZWN0cGFja2FnZWRvd25sb2FkcyA9PT0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBTQ09STSBpcyBvcGVuLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpc1Njb3JtT3BlblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSBTQ09STSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSBpZiBTQ09STSBpcyBvcGVuLCBmYWxzZSBpZiBpdCBoYXNuJ3Qgb3BlbmVkIHlldC5cbiAgICAgKi9cbiAgICBzZWxmLmlzU2Nvcm1PcGVuID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgdmFyIHRpbWVOb3cgPSAkbW1VdGlsLnRpbWVzdGFtcCgpO1xuICAgICAgICBpZiAoc2Nvcm0udGltZW9wZW4gPiAwICYmIHNjb3JtLnRpbWVvcGVuID4gdGltZU5vdykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIFNDT1JNIGlzIHN1cHBvcnRlZCBpbiB0aGUgYXBwLiBJZiBpdCdzIG5vdCwgcmV0dXJucyB0aGUgZXJyb3IgY29kZSB0byBzaG93LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpc1Njb3JtU3VwcG9ydGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtICAgIFNDT1JNIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW58U3RyaW5nfSBUcnVlIGlmIFNDT1JNIGlzIHN1cHBvcnRlZCwgc3RyaW5nIHdpdGggZXJyb3IgY29kZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1Njb3JtU3VwcG9ydGVkID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgaWYgKCFzZWxmLmlzU2Nvcm1WYWxpZFZlcnNpb24oc2Nvcm0pKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21tYS5tb2Rfc2Nvcm0uZXJyb3JpbnZhbGlkdmVyc2lvbic7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNlbGYuaXNTY29ybURvd25sb2FkYWJsZShzY29ybSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW1hLm1vZF9zY29ybS5lcnJvcm5vdGRvd25sb2FkYWJsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNlbGYuaXNWYWxpZFBhY2thZ2VVcmwoc2VsZi5nZXRQYWNrYWdlVXJsKHNjb3JtKSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW1hLm1vZF9zY29ybS5lcnJvcnBhY2thZ2VmaWxlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBpdCdzIGEgdmFsaWQgU0NPUk0gMS4yLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpc1Njb3JtVmFsaWRWZXJzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtIFNDT1JNIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIFNDT1JNIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1Njb3JtVmFsaWRWZXJzaW9uID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgcmV0dXJuIHNjb3JtLnZlcnNpb24gPT0gJ1NDT1JNXzEuMic7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgU0NPIHN0YXR1cyBpcyBpbmNvbXBsZXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpc1N0YXR1c0luY29tcGxldGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBzdGF0dXMgU0NPIHN0YXR1cy5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgVHJ1ZSBpZiBpbmNvbXBsZXRlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1N0YXR1c0luY29tcGxldGUgPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuICFzdGF0dXMgfHwgc3RhdHVzID09ICdub3RhdHRlbXB0ZWQnIHx8IHN0YXR1cyA9PSAnaW5jb21wbGV0ZScgfHwgc3RhdHVzID09ICdicm93c2VkJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBwYWNrYWdlIFVSTCBpcyB2YWxpZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaXNWYWxpZFBhY2thZ2VVcmxcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBwYWNrYWdlVXJsIFBhY2thZ2UgVVJMLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgVHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNWYWxpZFBhY2thZ2VVcmwgPSBmdW5jdGlvbihwYWNrYWdlVXJsKSB7XG4gICAgICAgIGlmICghcGFja2FnZVVybCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWNrYWdlVXJsLmluZGV4T2YoJ2ltc21hbmlmZXN0LnhtbCcpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IGEgU0NPUk0gYXMgYmVpbmcgdmlld2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNsb2dWaWV3XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkICAgICAgIE1vZHVsZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sb2dWaWV3ID0gZnVuY3Rpb24oaWQsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JtaWQ6IGlkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l0ZS53cml0ZSgnbW9kX3Njb3JtX3ZpZXdfc2Nvcm0nLCBwYXJhbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgYSBTQ08gYXMgYmVpbmcgbGF1bmNoZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2xvZ0xhdW5jaFNjb1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NvSWQgICAgU0NPIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ0xhdW5jaFNjbyA9IGZ1bmN0aW9uKHNjb3JtSWQsIHNjb0lkLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHNjb3JtaWQ6IHNjb3JtSWQsXG4gICAgICAgICAgICBzY29pZDogc2NvSWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS53cml0ZSgnbW9kX3Njb3JtX2xhdW5jaF9zY28nLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlZmV0Y2hlcyBhbmQgdW56aXBzIHRoZSBTQ09STSBwYWNrYWdlLCBhbmQgYWxzbyBwcmVmZXRjaGVzIHNvbWUgV1MgY2FsbHMuXG4gICAgICogQHNlZSAkbW1hTW9kU2Nvcm0jX2Rvd25sb2FkT3JQcmVmZXRjaFxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNwcmVmZXRjaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSBTQ09STSBvYmplY3QgcmV0dXJuZWQgYnkgJG1tYU1vZFNjb3JtI2dldFNjb3JtLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gcHJlZmV0Y2ggaXMgZG9uZS4gUmVzb2x2ZSBwYXJhbSBpcyBhIHdhcm5pbmcgbWVzc2FnZSAoaWYgbmVlZGVkKS5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLnByZWZldGNoUGFja2FnZShzY29ybSkpO1xuXG4gICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5wcmVmZXRjaERhdGEoc2Nvcm0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gSWYgcHJlZmV0Y2hEYXRhIGZhaWxzIHdlIGRvbid0IHdhbnQgdG8gZmFpbCB0aGUgd2hvbGUgZG93bmxvYWRlZCwgc28gd2UnbGwgaWdub3JlIHRoZSBlcnJvciBmb3Igbm93LlxuICAgICAgICAgICAgLy8gQHRvZG8gSW1wbGVtZW50IGEgd2FybmluZyBzeXN0ZW0gc28gdGhlIHVzZXIga25vd3Mgd2hpY2ggU0NPUk1zIGhhdmUgZmFpbGVkLlxuICAgICAgICB9KSk7XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoZXMgc29tZSBXUyBkYXRhIGZvciBhIFNDT1JNLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNwcmVmZXRjaERhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gICAgU0NPUk0gb2JqZWN0IHJldHVybmVkIGJ5ICRtbWFNb2RTY29ybSNnZXRTY29ybS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIHByZWZldGNoZWQuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaERhdGEgPSBmdW5jdGlvbihzY29ybSwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIC8vIFByZWZldGNoIG51bWJlciBvZiBhdHRlbXB0cyAoaW5jbHVkaW5nIG5vdCBjb21wbGV0ZWQpLlxuICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RTY29ybU9ubGluZS5nZXRBdHRlbXB0Q291bnQoc2l0ZUlkLCBzY29ybS5pZCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBmYWlscywgYXNzdW1lIHdlIGhhdmUgbm8gYXR0ZW1wdHMuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihudW1BdHRlbXB0cykge1xuICAgICAgICAgICAgaWYgKG51bUF0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB1c2VyIGRhdGEgZm9yIGVhY2ggYXR0ZW1wdC5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YXByb21pc2VzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBGaWxsIGFuIGF0dGVtcHRzIGFycmF5IHRvIGJlIGFibGUgdG8gdXNlIGZvckVhY2ggYW5kIHByZXZlbnQgcHJvYmxlbXMgd2l0aCBhdHRlbXB0IHZhcmlhYmxlIGNoYW5naW5nLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG51bUF0dGVtcHRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhdHRlbXB0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YXByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtT25saW5lLmdldFNjb3JtVXNlckRhdGEoc2l0ZUlkLCBzY29ybS5pZCwgYXR0ZW1wdCkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZmFpbHVyZXMgb2YgYWxsIHRoZSBhdHRlbXB0cyB0aGF0IGFyZW4ndCB0aGUgbGFzdCBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PSBudW1BdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChkYXRhcHJvbWlzZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBhdHRlbXB0cy4gV2UnbGwgc3RpbGwgdHJ5IHRvIGdldCB1c2VyIGRhdGEgdG8gYmUgYWJsZSB0byBpZGVudGlmeSBTQ09zIG5vdCB2aXNpYmxlIGFuZCBzby5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT25saW5lLmdldFNjb3JtVXNlckRhdGEoc2l0ZUlkLCBzY29ybS5pZCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcblxuICAgICAgICAvLyBQcmVmZXRjaCBTQ09zLlxuICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYuZ2V0U2NvcyhzY29ybS5pZCwgc2l0ZUlkKSk7XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoZXMgYW5kIHVuemlwcyB0aGUgU0NPUk0gcGFja2FnZS5cbiAgICAgKiBAc2VlICRtbWFNb2RTY29ybSNfZG93bmxvYWRPclByZWZldGNoXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI3ByZWZldGNoUGFja2FnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSBTQ09STSBvYmplY3QgcmV0dXJuZWQgYnkgJG1tYU1vZFNjb3JtI2dldFNjb3JtLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHBhY2thZ2UgaXMgcHJlZmV0Y2hlZCBhbmQgdW56aXBwZWQuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaFBhY2thZ2UgPSBmdW5jdGlvbihzY29ybSkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZG93bmxvYWRPclByZWZldGNoKHNjb3JtLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgYSBTQ09STSB0cmFja2luZyByZWNvcmQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI3NhdmVUcmFja3NcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkICAgICAgU2NvIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCAgICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gdHJhY2tzICAgVHJhY2tpbmcgZGF0YSB0byBzdG9yZS5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvZmZsaW5lICAgVHJ1ZSBpZiBhdHRlbXB0IGlzIG9mZmxpbmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtICAgICAgU0NPUk0uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbdXNlckRhdGFdIFVzZXIgZGF0YSBmb3IgdGhpcyBhdHRlbXB0IGFuZCBTQ08uIElmIG5vdCBkZWZpbmVkLCBpdCB3aWxsIGJlIHJldHJpZXZlZCBmcm9tIERCLiBSZWNvbW1lbmRlZC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGRhdGEgaXMgc2F2ZWQuXG4gICAgICovXG4gICAgc2VsZi5zYXZlVHJhY2tzID0gZnVuY3Rpb24oc2NvSWQsIGF0dGVtcHQsIHRyYWNrcywgb2ZmbGluZSwgc2Nvcm0sIHVzZXJEYXRhLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgaWYgKG9mZmxpbmUpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gdXNlckRhdGEgPyAkcS53aGVuKHVzZXJEYXRhKSA6IHNlbGYuZ2V0U2Nvcm1Vc2VyRGF0YShzY29ybS5pZCwgYXR0ZW1wdCwgb2ZmbGluZSwgc2l0ZUlkKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24odXNlckRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5zYXZlVHJhY2tzKHNpdGVJZCwgc2Nvcm0sIHNjb0lkLCBhdHRlbXB0LCB0cmFja3MsIHVzZXJEYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9ubGluZS5zYXZlVHJhY2tzKHNpdGVJZCwgc2Nvcm0uaWQsIHNjb0lkLCBhdHRlbXB0LCB0cmFja3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgU0NPUk0gdHJhY2tpbmcgcmVjb3JkIHVzaW5nIGEgc3luY2hyb25vdXMgY2FsbC5cbiAgICAgKiBQbGVhc2UgdXNlIHRoaXMgZnVuY3Rpb24gb25seSBpZiBzeW5jaHJvbm91cyBpcyBhIG11c3QuIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlICRtbWFNb2RTY29ybSNzYXZlVHJhY2tzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNzYXZlVHJhY2tzU3luY1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgICAgICBTY28gSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0ICAgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSAge09iamVjdFtdfSB0cmFja3MgICBUcmFja2luZyBkYXRhIHRvIHN0b3JlLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG9mZmxpbmUgICBUcnVlIGlmIGF0dGVtcHQgaXMgb2ZmbGluZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW3Njb3JtXSAgICBTQ09STS4gUmVxdWlyZWQgaWYgb2ZmbGluZT10cnVlLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW3VzZXJEYXRhXSBVc2VyIGRhdGEgZm9yIHRoaXMgYXR0ZW1wdCBhbmQgU0NPLiBSZXF1aXJlZCBpZiBvZmZsaW5lPXRydWUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgIEluIG9ubGluZSByZXR1cm5zIHRydWUgaWYgZGF0YSBpcyBpbnNlcnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbiBvZmZsaW5lIHJldHVybnMgdHJ1ZSBpZiBkYXRhIHRvIGluc2VydCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLiBUcnVlIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhIGhhcyBiZWVuIHN0b3JlZCwgdGhpcyBmdW5jdGlvbiBjYW4gcmV0dXJuIHRydWUgYnV0IHRoZSBpbnNlcnRpb24gY2FuIHN0aWxsIGZhaWwgc29tZWhvdy5cbiAgICAgKi9cbiAgICBzZWxmLnNhdmVUcmFja3NTeW5jID0gZnVuY3Rpb24oc2NvSWQsIGF0dGVtcHQsIHRyYWNrcywgb2ZmbGluZSwgc2Nvcm0sIHVzZXJEYXRhKSB7XG4gICAgICAgIGlmIChvZmZsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5zYXZlVHJhY2tzU3luYyhzY29ybSwgc2NvSWQsIGF0dGVtcHQsIHRyYWNrcywgdXNlckRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9ubGluZS5zYXZlVHJhY2tzU3luYyhzY29JZCwgYXR0ZW1wdCwgdHJhY2tzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3Njb3JtJylcblxuLmNvbnN0YW50KCdtbWFNb2RTY29ybU9mZmxpbmVBdHRlbXB0c1N0b3JlJywgJ21vZF9zY29ybV9vZmZsaW5lX2F0dGVtcHRzJylcbi5jb25zdGFudCgnbW1hTW9kU2Nvcm1PZmZsaW5lVHJhY2tzU3RvcmUnLCAnbW9kX3Njb3JtX29mZmxpbmVfc2Nvc190cmFja3MnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbVNpdGVzRmFjdG9yeVByb3ZpZGVyLCBtbWFNb2RTY29ybU9mZmxpbmVBdHRlbXB0c1N0b3JlLCBtbWFNb2RTY29ybU9mZmxpbmVUcmFja3NTdG9yZSkge1xuICAgIHZhciBzdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1tYU1vZFNjb3JtT2ZmbGluZUF0dGVtcHRzU3RvcmUsXG4gICAgICAgICAgICBrZXlQYXRoOiBbJ3Njb3JtaWQnLCAndXNlcmlkJywgJ2F0dGVtcHQnXSxcbiAgICAgICAgICAgIGluZGV4ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhdHRlbXB0JyAvLyBBdHRlbXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3VzZXJpZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Njb3JtaWQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb3Vyc2VpZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RpbWVtb2RpZmllZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHVzaW5nIGNvbXBvdW5kIGluZGV4ZXMgYmVjYXVzZSB0aGV5IHNlZW0gdG8gaGF2ZSBpc3N1ZXMgd2l0aCB3aGVyZSgpLlxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2Nvcm1BbmRVc2VyJyxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbb2JqLnNjb3JtaWQsIG9iai51c2VyaWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBtbWFNb2RTY29ybU9mZmxpbmVUcmFja3NTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6IFsndXNlcmlkJywgJ3Njb3JtaWQnLCAnc2NvaWQnLCAnYXR0ZW1wdCcsICdlbGVtZW50J10sXG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAndXNlcmlkJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2Nvcm1pZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Njb2lkJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYXR0ZW1wdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2VsZW1lbnQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzeW5jZWQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCB1c2luZyBjb21wb3VuZCBpbmRleGVzIGJlY2F1c2UgdGhleSBzZWVtIHRvIGhhdmUgaXNzdWVzIHdpdGggd2hlcmUoKS5cbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Njb3JtVXNlckF0dGVtcHQnLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3I6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtvYmouc2Nvcm1pZCwgb2JqLnVzZXJpZCwgb2JqLmF0dGVtcHRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCB1c2luZyBjb21wb3VuZCBpbmRleGVzIGJlY2F1c2UgdGhleSBzZWVtIHRvIGhhdmUgaXNzdWVzIHdpdGggd2hlcmUoKS5cbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Njb3JtVXNlckF0dGVtcHRTeW5jZWQnLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3I6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtvYmouc2Nvcm1pZCwgb2JqLnVzZXJpZCwgb2JqLmF0dGVtcHQsIG9iai5zeW5jZWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgXTtcbiAgICAkbW1TaXRlc0ZhY3RvcnlQcm92aWRlci5yZWdpc3RlclN0b3JlcyhzdG9yZXMpO1xufSlcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGhhbmRsZSBTQ09STSBvZmZsaW5lIGZlYXR1cmVzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmVcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RTY29ybU9mZmxpbmUnLCBmdW5jdGlvbigkbW1TaXRlLCAkbW1VdGlsLCAkcSwgJGxvZywgJG1tU2l0ZXNNYW5hZ2VyLCBtbWFNb2RTY29ybU9mZmxpbmVBdHRlbXB0c1N0b3JlLFxuICAgICAgICAgICAgbW1hTW9kU2Nvcm1PZmZsaW5lVHJhY2tzU3RvcmUpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU1vZFNjb3JtT2ZmbGluZScpO1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgYmxvY2tlZFNjb3JtcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBhbiBhdHRlbXB0IG51bWJlciBpbiB0aGUgZGF0YSBzdG9yZWQgaW4gb2ZmbGluZS5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29udmVydCBhdHRlbXB0cyBpbnRvIG5ldyBhdHRlbXB0cywgc28gdGhlIHN0b3JlZCBzbmFwc2hvdCB3aWxsIGJlIHJlbW92ZWQgYW5kXG4gICAgICogZW50cmllcyB3aWxsIGJlIG1hcmtlZCBhcyBub3Qgc3luY2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjY2hhbmdlQXR0ZW1wdE51bWJlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtSWQgICAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgICAgTnVtYmVyIG9mIHRoZSBhdHRlbXB0IHRvIGNoYW5nZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbmV3QXR0ZW1wdCBOZXcgYXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdICAgVXNlciBJRC4gSWYgbm90IGRlZmluZWQgdXNlIHNpdGUncyBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBhdHRlbXB0IG51bWJlciBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHNlbGYuY2hhbmdlQXR0ZW1wdE51bWJlciA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgbmV3QXR0ZW1wdCwgdXNlcklkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ2hhbmdlIGF0dGVtcHQgbnVtYmVyIGZyb20gJyArIGF0dGVtcHQgKyAnIHRvICcgKyBuZXdBdHRlbXB0ICsgJyBpbiBTQ09STSAnICsgc2Nvcm1JZCk7XG4gICAgICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgc2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAgICAgdmFyIGRiID0gc2l0ZS5nZXREYigpLFxuICAgICAgICAgICAgICAgIG5ld0VudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29ybWlkOiBzY29ybUlkLFxuICAgICAgICAgICAgICAgICAgICB1c2VyaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdDogbmV3QXR0ZW1wdCxcbiAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkOiAkbW1VdGlsLnRpbWVzdGFtcCgpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFibG9ja2VkU2Nvcm1zW3NpdGVJZF0pIHtcbiAgICAgICAgICAgICAgICBibG9ja2VkU2Nvcm1zW3NpdGVJZF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrZWRTY29ybXNbc2l0ZUlkXVtzY29ybUlkXSA9IHRydWU7IC8vIEJsb2NrIHRoZSBTQ09STSBzbyBpdCBjYW4ndCBiZSBzeW5jZWQuXG5cbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGRhdGEuXG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0KG1tYU1vZFNjb3JtT2ZmbGluZUF0dGVtcHRzU3RvcmUsIFtzY29ybUlkLCB1c2VySWQsIGF0dGVtcHRdKS50aGVuKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgbmV3RW50cnkudGltZWNyZWF0ZWQgPSBlbnRyeS50aW1lY3JlYXRlZDtcbiAgICAgICAgICAgICAgICBuZXdFbnRyeS5jb3Vyc2VpZCA9IGVudHJ5LmNvdXJzZWlkO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IG5ldyBhdHRlbXB0LlxuICAgICAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQobW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZSwgbmV3RW50cnkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgdHJhY2tpbmcgZGF0YSB0byB0aGUgbmV3IGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFNjb3JtU3RvcmVkRGF0YShzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIHVzZXJJZCkudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmF0dGVtcHQgPSBuZXdBdHRlbXB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN5bmNlZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYi5pbnNlcnQobW1hTW9kU2Nvcm1PZmZsaW5lVHJhY2tzU3RvcmUsIGVudHJ5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbVV0aWwuYWxsUHJvbWlzZXMocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGVudHJpZXMgaW5zZXJ0ZWQuIERlbGV0ZSB0aGUgb2xkIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZGVsZXRlQXR0ZW1wdChzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGVsZXRlIGZhaWxlZCwgaXQgc2hvdWxkbid0IGhhcHBlbi4gTGV0J3MgcmV0cnkgb25jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZGVsZXRlQXR0ZW1wdChzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQpLmNhdGNoKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFpbGVkIHRvIGdldCB0aGUgZGF0YSwgcmVtb3ZlIHRoZSBuZXcgYXR0ZW1wdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRlbGV0ZUF0dGVtcHQoc2l0ZUlkLCBzY29ybUlkLCBuZXdBdHRlbXB0KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tlZFNjb3Jtc1tzaXRlSWRdW3Njb3JtSWRdID0gZmFsc2U7IC8vIFVuYmxvY2sgdGhlIFNDT1JNLlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBibG9ja2VkIFNDT1JNcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PZmZsaW5lI2NsZWFyQmxvY2tlZFNjb3Jtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBJZiBzZXQsIGNsZWFyIHRoZSBibG9ja2VkIFNDT1JNcyBvbmx5IGZvciB0aGlzIHNpdGUuIE90aGVyd2lzZSBjbGVhciBhbGwgU0NPUk1zLlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc2VsZi5jbGVhckJsb2NrZWRTY29ybXMgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgaWYgKHNpdGVJZCkge1xuICAgICAgICAgICAgZGVsZXRlIGJsb2NrZWRTY29ybXNbc2l0ZUlkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJsb2NrZWRTY29ybXMgPSB7fTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9mZmxpbmUgYXR0ZW1wdC4gSXQgY2FuIGJlIGNyZWF0ZWQgZnJvbSBzY3JhdGNoIG9yIGFzIGEgY29weSBvZiBhbm90aGVyIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT2ZmbGluZSNjcmVhdGVOZXdBdHRlbXB0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gICAgICBTQ09STS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJJZF0gICBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCAgICBOdW1iZXIgb2YgdGhlIG5ldyBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyRGF0YSAgIFVzZXIgZGF0YSB0byBzdG9yZSBpbiB0aGUgYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3NuYXBzaG90XSBPcHRpb25hbC4gU25hcHNob3QgdG8gc3RvcmUgaW4gdGhlIGF0dGVtcHQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBuZXcgYXR0ZW1wdCBpcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuY3JlYXRlTmV3QXR0ZW1wdCA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm0sIHVzZXJJZCwgYXR0ZW1wdCwgdXNlckRhdGEsIHNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ3JlYXRpbmcgbmV3IG9mZmxpbmUgYXR0ZW1wdCAnICsgYXR0ZW1wdCArICcgaW4gU0NPUk0gJyArIHNjb3JtLmlkKTtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fCBzaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICAgICBpZiAoIWJsb2NrZWRTY29ybXNbc2l0ZUlkXSkge1xuICAgICAgICAgICAgICAgIGJsb2NrZWRTY29ybXNbc2l0ZUlkXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2tlZFNjb3Jtc1tzaXRlSWRdW3Njb3JtLmlkXSA9IHRydWU7IC8vIEJsb2NrIHRoZSBTQ09STSBzbyBpdCBjYW4ndCBiZSBzeW5jZWQuXG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhdHRlbXB0IGluIERCLlxuICAgICAgICAgICAgdmFyIGRiID0gc2l0ZS5nZXREYigpLFxuICAgICAgICAgICAgICAgIGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29ybWlkOiBzY29ybS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdXNlcmlkOiB1c2VySWQsXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHQsXG4gICAgICAgICAgICAgICAgICAgIGNvdXJzZWlkOiBzY29ybS5jb3Vyc2UsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVjcmVhdGVkOiAkbW1VdGlsLnRpbWVzdGFtcCgpLFxuICAgICAgICAgICAgICAgICAgICB0aW1lbW9kaWZpZWQ6ICRtbVV0aWwudGltZXN0YW1wKClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIGEgc25hcHNob3Qgb2YgdGhlIGRhdGEgd2UgaGFkIHdoZW4gd2UgY3JlYXRlZCB0aGUgYXR0ZW1wdC5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGRlZmF1bHQgZGF0YSwgd2UgZG9uJ3Qgd2FudCB0byBzdG9yZSBpdC5cbiAgICAgICAgICAgICAgICBlbnRyeS5zbmFwc2hvdCA9IHJlbW92ZURlZmF1bHREYXRhKHNuYXBzaG90KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRiLmluc2VydChtbWFNb2RTY29ybU9mZmxpbmVBdHRlbXB0c1N0b3JlLCBlbnRyeSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBhbGwgdGhlIGRhdGEgaW4gdXNlckRhdGEuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHVzZXJEYXRhLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NvLnVzZXJkYXRhLCBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tzLnB1c2goe2VsZW1lbnQ6IGVsZW1lbnQsIHZhbHVlOiB2YWx1ZX0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLnNhdmVUcmFja3Moc2l0ZUlkLCBzY29ybSwgc2NvLnNjb2lkLCBhdHRlbXB0LCB0cmFja3MsIHVzZXJEYXRhKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJsb2NrZWRTY29ybXNbc2l0ZUlkXVtzY29ybS5pZF0gPSBmYWxzZTsgLy8gVW5ibG9jayB0aGUgU0NPUk0uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbGwgdGhlIHN0b3JlZCBkYXRhIGZyb20gYW4gYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PZmZsaW5lI2RlbGV0ZUF0dGVtcHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCB0aGUgZGF0YSBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqL1xuICAgIHNlbGYuZGVsZXRlQXR0ZW1wdCA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdXNlcklkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRGVsZXRlIG9mZmxpbmUgYXR0ZW1wdCAnICsgYXR0ZW1wdCArICcgaW4gU0NPUk0gJyArIHNjb3JtSWQpO1xuICAgICAgICAgICAgdXNlcklkID0gdXNlcklkIHx8wqBzaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTY29ybVN0b3JlZERhdGEoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1c2VySWQpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBkYiA9IHNpdGUuZ2V0RGIoKTtcblxuICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBhbGwgdGhlIHRyYWNrcy5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5SWQgPSBbZW50cnkudXNlcmlkLCBlbnRyeS5zY29ybWlkLCBlbnRyeS5zY29pZCwgZW50cnkuYXR0ZW1wdCwgZW50cnkuZWxlbWVudF07XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZGIucmVtb3ZlKG1tYU1vZFNjb3JtT2ZmbGluZVRyYWNrc1N0b3JlLCBlbnRyeUlkKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWxldGUgdGhlIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYi5yZW1vdmUobW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZSwgW3Njb3JtSWQsIHVzZXJJZCwgYXR0ZW1wdF0pKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmV0dXJuIGEgZm9ybWF0dGVkIGxpc3Qgb2YgaW50ZXJhY3Rpb25zIGZvciByZXBvcnRzLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgaW4gTW9vZGxlJ3Mgc2Nvcm1fZm9ybWF0X2ludGVyYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2NvVXNlckRhdGEgVXNlcmRhdGEgZnJvbSBhIGNlcnRhaW4gU0NPLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgRm9ybWF0dGVkIHVzZXJkYXRhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcm1hdEludGVyYWN0aW9ucyhzY29Vc2VyRGF0YSkge1xuICAgICAgICB2YXIgZm9ybWF0dGVkID0ge307XG5cbiAgICAgICAgLy8gRGVmaW5lZCBpbiBvcmRlciB0byB1bmlmeSBzY29ybTEuMiBhbmQgc2Nvcm0yMDA0LlxuICAgICAgICBmb3JtYXR0ZWQuc2NvcmVfcmF3ID0gJyc7XG4gICAgICAgIGZvcm1hdHRlZC5zdGF0dXMgPSAnJztcbiAgICAgICAgZm9ybWF0dGVkLnRvdGFsX3RpbWUgPSAnMDA6MDA6MDAnO1xuICAgICAgICBmb3JtYXR0ZWQuc2Vzc2lvbl90aW1lID0gJzAwOjAwOjAwJztcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NvVXNlckRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZWxlbWVudHMgdGhhdCBhcmUgY2FsY3VsYXRlZC5cbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09ICdzY29yZV9yYXcnIHx8IGVsZW1lbnQgPT0gJ3N0YXR1cycgfHwgZWxlbWVudCA9PSAndG90YWxfdGltZScgfHwgZWxlbWVudCA9PSAnc2Vzc2lvbl90aW1lJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0dGVkW2VsZW1lbnRdID0gdmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjbWkuY29yZS5sZXNzb25fc3RhdHVzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjbWkuY29tcGxldGlvbl9zdGF0dXMnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gJ25vdCBhdHRlbXB0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdub3RhdHRlbXB0ZWQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZC5zdGF0dXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY21pLmNvcmUuc2NvcmUucmF3JzpcbiAgICAgICAgICAgICAgICBjYXNlICdjbWkuc2NvcmUucmF3JzpcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkLnNjb3JlX3JhdyA9ICRtbVV0aWwucm91bmRUb0RlY2ltYWxzKHZhbHVlLCAyKTsgLy8gUm91bmQgdG8gMiBkZWNpbWFscyBtYXguXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NtaS5jb3JlLnNlc3Npb25fdGltZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY21pLnNlc3Npb25fdGltZSc6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZC5zZXNzaW9uX3RpbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY21pLmNvcmUudG90YWxfdGltZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY21pLnRvdGFsX3RpbWUnOlxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWQudG90YWxfdGltZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGF1bmNoIFVSTHMgZnJvbSBhIGxpc3Qgb2YgU0NPcywgaW5kZXhpbmcgdGhlbSBieSBTQ08gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gc2NvcyBMaXN0IG9mIFNDT3MuIEVhY2ggU0NPIG5lZWRzIHRvIGhhdmUgJ2lkJyBhbmQgJ2xhdW5jaCcgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICBMYXVuY2ggVVJMcyBpbmRleGVkIGJ5IFNDTyBJRC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRMYXVuY2hVcmxzRnJvbVNjb3Moc2Nvcykge1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjb3MsIGZ1bmN0aW9uKHNjbykge1xuICAgICAgICAgICAgcmVzcG9uc2Vbc2NvLmlkXSA9IHNjby5sYXVuY2g7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgb2ZmbGluZSBhdHRlbXB0cyBpbiBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PZmZsaW5lI2dldEFsbEF0dGVtcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBzZXQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgb2ZmbGluZSBhdHRlbXB0cyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QWxsQXR0ZW1wdHMgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIGlmICghZGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYi5nZXRBbGwobW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG9mZmxpbmUgYXR0ZW1wdHMgZG9uZSBieSBhIHVzZXIgaW4gdGhlIGdpdmVuIFNDT1JNLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjZ2V0QXR0ZW1wdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkIHVzZSBzaXRlJ3MgY3VycmVudCB1c2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIG9mZmxpbmUgYXR0ZW1wdHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEF0dGVtcHRzID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkLCB1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgc2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAgICAgdmFyIGRiID0gc2l0ZS5nZXREYigpO1xuICAgICAgICAgICAgcmV0dXJuIGRiLndoZXJlRXF1YWwobW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZSwgJ3Njb3JtQW5kVXNlcicsIFtzY29ybUlkLCB1c2VySWRdKS50aGVuKGZ1bmN0aW9uKGF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHRzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNuYXBzaG90IG9mIGFuIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT2ZmbGluZSNnZXRBdHRlbXB0U25hcHNob3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBzbmFwc2hvdCBvciB1bmRlZmluZWQgaWYgbm8gc25hcHNob3QuXG4gICAgICovXG4gICAgc2VsZi5nZXRBdHRlbXB0U25hcHNob3QgPSBmdW5jdGlvbihzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fCBzaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5nZXREYigpLmdldChtbWFNb2RTY29ybU9mZmxpbmVBdHRlbXB0c1N0b3JlLCBbc2Nvcm1JZCwgdXNlcklkLCBhdHRlbXB0XSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9OyAvLyBBdHRlbXB0IG5vdCBmb3VuZC5cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuc25hcHNob3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3JlYXRpb24gdGltZSBvZiBhbiBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjZ2V0QXR0ZW1wdENyZWF0aW9uVGltZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkIHVzZSBzaXRlJ3MgY3VycmVudCB1c2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGltZSB0aGUgYXR0ZW1wdCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEF0dGVtcHRDcmVhdGlvblRpbWUgPSBmdW5jdGlvbihzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fCBzaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5nZXREYigpLmdldChtbWFNb2RTY29ybU9mZmxpbmVBdHRlbXB0c1N0b3JlLCBbc2Nvcm1JZCwgdXNlcklkLCBhdHRlbXB0XSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9OyAvLyBBdHRlbXB0IG5vdCBmb3VuZC5cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkudGltZWNyZWF0ZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBkYXRhIHN0b3JlZCBpbiBsb2NhbCBEQiBmb3IgYSBjZXJ0YWluIHNjb3JtIGFuZCBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjZ2V0U2Nvcm1TdG9yZWREYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgICAgICAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICAgICAgICAgICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJJZF0gICAgICAgICAgVXNlciBJRC4gSWYgbm90IGRlZmluZWQgdXNlIHNpdGUncyBjdXJyZW50IHVzZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBleGNsdWRlU3luY2VkICAgIFRydWUgaWYgaXQgc2hvdWxkIG9ubHkgcmV0dXJuIG5vdCBzeW5jZWQgZW50cmllcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV4Y2x1ZGVOb3RTeW5jZWQgVHJ1ZSBpZiBpdCBzaG91bGQgb25seSByZXR1cm4gc3luY2VkIGVudHJpZXMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZW50cmllcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb3JtU3RvcmVkRGF0YSA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdXNlcklkLCBleGNsdWRlU3luY2VkLCBleGNsdWRlTm90U3luY2VkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdXNlcklkID0gdXNlcklkIHx8IHNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAgICAgICAgIHZhciB3aGVyZTtcblxuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVTeW5jZWQgJiYgZXhjbHVkZU5vdFN5bmNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhjbHVkZVN5bmNlZCB8fCBleGNsdWRlTm90U3luY2VkKSB7XG4gICAgICAgICAgICAgICAgd2hlcmUgPSBbJ3Njb3JtVXNlckF0dGVtcHRTeW5jZWQnLCAnPScsIFtzY29ybUlkLCB1c2VySWQsIGF0dGVtcHQsIGV4Y2x1ZGVOb3RTeW5jZWQgPyAxIDogMF1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGVyZSA9IFsnc2Nvcm1Vc2VyQXR0ZW1wdCcsICc9JywgW3Njb3JtSWQsIHVzZXJJZCwgYXR0ZW1wdF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpdGUuZ2V0RGIoKS5xdWVyeShtbWFNb2RTY29ybU9mZmxpbmVUcmFja3NTdG9yZSwgd2hlcmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1c2VyIGRhdGEgZm9yIGEgY2VydGFpbiBTQ09STSBhbmQgb2ZmbGluZSBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjZ2V0U2Nvcm1Vc2VyRGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkIHVzZSBzaXRlJ3MgY3VycmVudCB1c2VyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHNjb3MgICBTQ09zIHJldHVybmVkIGJ5ICRtbWFNb2RTY29ybSNnZXRTY29zLiBSZXF1aXJlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSB1c2VyIGRhdGEgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2Nvcm1Vc2VyRGF0YSA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdXNlcklkLCBzY29zKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdXNlcklkID0gdXNlcklkIHx8IHNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAgICAgICAgIC8vIEdldCB1c2VyIGRhdGEuIE9yZGVyaW5nIHdoZW4gdXNpbmcgYSBjb21wb3VuZCBpbmRleCBpcyBjb21wbGV4LCBzbyB3ZSB3b24ndCBvcmRlciBieSBzY29pZC5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFNjb3JtU3RvcmVkRGF0YShzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIHVzZXJJZCkudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0ge30sXG4gICAgICAgICAgICAgICAgICAgIGxhdW5jaFVybHMgPSBnZXRMYXVuY2hVcmxzRnJvbVNjb3Moc2NvcyksXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJZCA9IHNpdGUuZ2V0VXNlcklkKCksXG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lID0gc2l0ZS5nZXRJbmZvKCkudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxOYW1lID0gc2l0ZS5nZXRJbmZvKCkuZnVsbG5hbWU7XG5cbiAgICAgICAgICAgICAgICAvLyBHYXRoZXIgdXNlciBkYXRhIHJldHJpZXZlZCBmcm9tIERCLCBncm91cGluZyBpdCBieSBzY29pZC5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjb2lkID0gZW50cnkuc2NvaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Vbc2NvaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIFNDTy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlW3Njb2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29pZDogc2NvaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmlkOiB1c2VySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb2lkOiBzY29pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtzY29pZF0udXNlcmRhdGFbZW50cnkuZWxlbWVudF0gPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnRpbWVtb2RpZmllZCA+IHJlc3BvbnNlW3Njb2lkXS51c2VyZGF0YS50aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlW3Njb2lkXS51c2VyZGF0YS50aW1lbW9kaWZpZWQgPSBlbnRyeS50aW1lbW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBlYWNoIHVzZXIgZGF0YSByZXRyaWV2ZWQuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc3BvbnNlLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvLnVzZXJkYXRhID0gZm9ybWF0SW50ZXJhY3Rpb25zKHNjby51c2VyZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZW1wdHkgZW50cmllcyBmb3IgdGhlIFNDT3Mgd2l0aG91dCB1c2VyIGRhdGEgc3RvcmVkLlxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY29zLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZVtzY28uaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtzY28uaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb2lkOiBzY28uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVfcmF3OiAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBkZWZhdWx0ZGF0YS5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzcG9uc2UsIGZ1bmN0aW9uKHNjbykge1xuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5zdHVkZW50X2lkJ10gPSB1c2VybmFtZTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5zdHVkZW50X25hbWUnXSA9IGZ1bGxOYW1lO1xuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5jb3JlLmxlc3Nvbl9tb2RlJ10gPSAnbm9ybWFsJzsgLy8gT3ZlcnJpZGRlbiBpbiBwbGF5ZXIuXG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUuY3JlZGl0J10gPSAnY3JlZGl0JzsgLy8gT3ZlcnJpZGRlbiBpbiBwbGF5ZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY28udXNlcmRhdGEuc3RhdHVzID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5lbnRyeSddID0gJ2FiLWluaXRpbyc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NvLnVzZXJkYXRhWydjbWkuY29yZS5leGl0J10gPT09ICdzdXNwZW5kJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5lbnRyeSddID0gJ3Jlc3VtZSc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5jb3JlLmVudHJ5J10gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5zdHVkZW50X2RhdGEubWFzdGVyeV9zY29yZSddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdtYXN0ZXJ5c2NvcmUnKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuc3R1ZGVudF9kYXRhLm1heF90aW1lX2FsbG93ZWQnXSA9IHNjb3JtSXNzZXQoc2NvLnVzZXJkYXRhLCAnbWF4X3RpbWVfYWxsb3dlZCcpO1xuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5zdHVkZW50X2RhdGEudGltZV9saW1pdF9hY3Rpb24nXSA9IHNjb3JtSXNzZXQoc2NvLnVzZXJkYXRhLCAndGltZV9saW1pdF9hY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS50b3RhbF90aW1lJ10gPSBzY29ybUlzc2V0KHNjby51c2VyZGF0YSwgJ2NtaS5jb3JlLnRvdGFsX3RpbWUnLCAnMDA6MDA6MDAnKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkubGF1bmNoX2RhdGEnXSA9IGxhdW5jaFVybHNbc2NvLnNjb2lkXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgaGFuZGxlIHN0YW5kYXJkIHVzZXJkYXRhIGl0ZW1zLlxuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5jb3JlLmxlc3Nvbl9sb2NhdGlvbiddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuY29yZS5sZXNzb25fbG9jYXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5sZXNzb25fc3RhdHVzJ10gPSBzY29ybUlzc2V0KHNjby51c2VyZGF0YSwgJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5zY29yZS5yYXcnXSA9IHNjb3JtSXNzZXQoc2NvLnVzZXJkYXRhLCAnY21pLmNvcmUuc2NvcmUucmF3Jyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUuc2NvcmUubWF4J10gPSBzY29ybUlzc2V0KHNjby51c2VyZGF0YSwgJ2NtaS5jb3JlLnNjb3JlLm1heCcpO1xuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5jb3JlLnNjb3JlLm1pbiddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuY29yZS5zY29yZS5taW4nKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5leGl0J10gPSBzY29ybUlzc2V0KHNjby51c2VyZGF0YSwgJ2NtaS5jb3JlLmV4aXQnKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuc3VzcGVuZF9kYXRhJ10gPSBzY29ybUlzc2V0KHNjby51c2VyZGF0YSwgJ2NtaS5zdXNwZW5kX2RhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29tbWVudHMnXSA9IHNjb3JtSXNzZXQoc2NvLnVzZXJkYXRhLCAnY21pLmNvbW1lbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS5sYW5ndWFnZSddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLmxhbmd1YWdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS5hdWRpbyddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLmF1ZGlvJywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLnNwZWVkJ10gPSBzY29ybUlzc2V0KHNjby51c2VyZGF0YSwgJ2NtaS5zdHVkZW50X3ByZWZlcmVuY2Uuc3BlZWQnLCAnMCcpO1xuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5zdHVkZW50X3ByZWZlcmVuY2UudGV4dCddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLnRleHQnLCAnMCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgZGF0YSBuZWVkcyB0byBiZSBib3RoIGluIGRlZmF1bHQgZGF0YSBhbmQgdXNlciBkYXRhLlxuICAgICAgICAgICAgICAgICAgICBzY28udXNlcmRhdGEuc3R1ZGVudF9pZCA9IHVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICBzY28udXNlcmRhdGEuc3R1ZGVudF9uYW1lID0gZnVsbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHNjby51c2VyZGF0YS5tb2RlID0gc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5sZXNzb25fbW9kZSddO1xuICAgICAgICAgICAgICAgICAgICBzY28udXNlcmRhdGEuY3JlZGl0ID0gc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5jcmVkaXQnXTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLnVzZXJkYXRhLmVudHJ5ID0gc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5lbnRyeSddO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBpbnNlcnQgYSB0cmFjayBpbiB0aGUgREIuIFBsZWFzZSBkbyBub3QgdXNlIGl0IGRpcmVjdGx5LCB1c2UgaW5zZXJ0VHJhY2sgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZGIgICAgICAgICAgIFNpdGUncyBEQi5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgICAgICBVc2VyIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgICAgICAgIFNDTyBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgICAgICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVsZW1lbnQgICAgICBOYW1lIG9mIHRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gIHtNaXhlZH0gdmFsdWUgICAgICAgICBWYWx1ZSBvZiB0aGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gc3luY2hyb25vdXMgVHJ1ZSBpZiBpbnNlcnQgc2hvdWxkIE5PVCByZXR1cm4gYSBwcm9taXNlLiBQbGVhc2UgdXNlIGl0IG9ubHkgaWYgc3luY2hyb25vdXMgaXMgYSBtdXN0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW58UHJvbWlzZX0gICAgIFJldHVybnMgYSBwcm9taXNlIGlmIHN5bmNocm9ub3VzPWZhbHNlLCBvdGhlcndpc2UgcmV0dXJucyBhIGJvb2xlYW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0VHJhY2tUb0RCKGRiLCB1c2VySWQsIHNjb3JtSWQsIHNjb0lkLCBhdHRlbXB0LCBlbGVtZW50LCB2YWx1ZSwgc3luY2hyb25vdXMpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICAgICAgdXNlcmlkOiB1c2VySWQsXG4gICAgICAgICAgICBzY29ybWlkOiBzY29ybUlkLFxuICAgICAgICAgICAgc2NvaWQ6IHNjb0lkLFxuICAgICAgICAgICAgYXR0ZW1wdDogYXR0ZW1wdCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB0aW1lbW9kaWZpZWQ6ICRtbVV0aWwudGltZXN0YW1wKCksXG4gICAgICAgICAgICBzeW5jZWQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN5bmNocm9ub3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0U3luYyhtbWFNb2RTY29ybU9mZmxpbmVUcmFja3NTdG9yZSwgZW50cnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRiLmluc2VydChtbWFNb2RTY29ybU9mZmxpbmVUcmFja3NTdG9yZSwgZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgdHJhY2sgaW4gdGhlIG9mZmxpbmUgdHJhY2tzIHN0b3JlLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gTW9vZGxlJ3Mgc2Nvcm1faW5zZXJ0X3RyYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt1c2VySWRdICAgICAgICBVc2VyIElELiBJZiBub3Qgc2V0IHVzZSBzaXRlJ3MgY3VycmVudCB1c2VyLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCAgICAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgICAgICAgICAgIFNDTyBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgICAgICAgICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVsZW1lbnQgICAgICAgICBOYW1lIG9mIHRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gIHtNaXhlZH0gdmFsdWUgICAgICAgICAgICBWYWx1ZSBvZiB0aGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gZm9yY2VDb21wbGV0ZWQgVHJ1ZSBpZiBTQ09STSBmb3JjZXMgY29tcGxldGVkLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW3Njb0RhdGFdICAgICAgIFVzZXIgZGF0YSBmb3IgdGhlIGdpdmVuIFNDTy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGluc2VydCBpcyBkb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFRyYWNrKHNpdGVJZCwgdXNlcklkLCBzY29ybUlkLCBzY29JZCwgYXR0ZW1wdCwgZWxlbWVudCwgdmFsdWUsIGZvcmNlQ29tcGxldGVkLCBzY29EYXRhKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdXNlcklkID0gdXNlcklkIHx8wqBzaXRlLmdldFVzZXJJZCgpO1xuICAgICAgICAgICAgc2NvRGF0YSA9IHNjb0RhdGEgfHwge307XG5cbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLCAvLyBMaXN0IG9mIHByb21pc2VzIGZvciBhY3Rpb25zIHByZXZpb3VzIHRvIHRoZSByZWFsIGluc2VydC5cbiAgICAgICAgICAgICAgICBsZXNzb25TdGF0dXNJbnNlcnRlZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNjb1VzZXJEYXRhID0gc2NvRGF0YS51c2VyZGF0YSB8fCB7fSxcbiAgICAgICAgICAgICAgICBkYiA9IHNpdGUuZ2V0RGIoKTtcblxuICAgICAgICAgICAgaWYgKGZvcmNlQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT0gJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnICYmIHZhbHVlID09ICdpbmNvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvVXNlckRhdGFbJ2NtaS5jb3JlLnNjb3JlLnJhdyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdjb21wbGV0ZWQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09ICdjbWkuY29yZS5zY29yZS5yYXcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29Vc2VyRGF0YVsnY21pLmNvcmUubGVzc29uX3N0YXR1cyddID09ICdpbmNvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVzc29uU3RhdHVzSW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChpbnNlcnRUcmFja1RvREIoZGIsIHVzZXJJZCwgc2Nvcm1JZCwgc2NvSWQsIGF0dGVtcHQsICdjbWkuY29yZS5sZXNzb25fc3RhdHVzJywgJ2NvbXBsZXRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCB1cGRhdGUgeC5zdGFydC50aW1lLCBrZWVwIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoIXNjb1VzZXJEYXRhW2VsZW1lbnRdIHx8IGVsZW1lbnQgIT0gJ3guc3RhcnQudGltZScpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0VHJhY2tUb0RCKGRiLCB1c2VySWQsIHNjb3JtSWQsIHNjb0lkLCBhdHRlbXB0LCBlbGVtZW50LCB2YWx1ZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVzc29uU3RhdHVzSW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb2xsYmFjayBwcmV2aW91cyBpbnNlcnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydFRyYWNrVG9EQihkYiwgdXNlcklkLCBzY29ybUlkLCBzY29JZCwgYXR0ZW1wdCwgJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnLCAnaW5jb21wbGV0ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgdHJhY2sgaW4gdGhlIG9mZmxpbmUgdHJhY2tzIHN0b3JlLCByZXR1cm5pbmcgYSBzeW5jaHJvbm91cyB2YWx1ZS5cbiAgICAgKiBQbGVhc2UgdXNlIHRoaXMgZnVuY3Rpb24gb25seSBpZiBzeW5jaHJvbm91cyBpcyBhIG11c3QuIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIGluc2VydFRyYWNrLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gTW9vZGxlJ3Mgc2Nvcm1faW5zZXJ0X3RyYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbdXNlcklkXSAgICAgICAgVXNlciBJRC4gSWYgbm90IHNldCB1c2UgY3VycmVudCB1c2VyLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCAgICAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgICAgICAgICAgIFNDTyBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgICAgICAgICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVsZW1lbnQgICAgICAgICBOYW1lIG9mIHRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gIHtNaXhlZH0gdmFsdWUgICAgICAgICAgICBWYWx1ZSBvZiB0aGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gZm9yY2VDb21wbGV0ZWQgVHJ1ZSBpZiBTQ09STSBmb3JjZXMgY29tcGxldGVkLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW3Njb0RhdGFdICAgICAgIFVzZXIgZGF0YSBmb3IgdGhlIGdpdmVuIFNDTy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGluc2VydCBpcyBkb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFRyYWNrU3luYyh1c2VySWQsIHNjb3JtSWQsIHNjb0lkLCBhdHRlbXB0LCBlbGVtZW50LCB2YWx1ZSwgZm9yY2VDb21wbGV0ZWQsIHNjb0RhdGEpIHtcbiAgICAgICAgdXNlcklkID0gdXNlcklkIHx8wqAkbW1TaXRlLmdldFVzZXJJZCgpO1xuICAgICAgICBzY29EYXRhID0gc2NvRGF0YSB8fCB7fTtcblxuICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICAvLyBOb3QgbG9nZ2VkIGluLCB3ZSBjYW4ndCBnZXQgdGhlIHNpdGUgREIuIFVzZXIgbG9nZ2VkIG91dCBvciBzZXNzaW9uIGV4cGlyZWQgd2hpbGUgYW4gb3BlcmF0aW9uIHdhcyBvbmdvaW5nLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlc3NvblN0YXR1c0luc2VydGVkID0gZmFsc2UsXG4gICAgICAgICAgICBzY29Vc2VyRGF0YSA9IHNjb0RhdGEudXNlcmRhdGEgfHwge30sXG4gICAgICAgICAgICBkYiA9ICRtbVNpdGUuZ2V0RGIoKTtcblxuICAgICAgICBpZiAoZm9yY2VDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09ICdjbWkuY29yZS5sZXNzb25fc3RhdHVzJyAmJiB2YWx1ZSA9PSAnaW5jb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NvVXNlckRhdGFbJ2NtaS5jb3JlLnNjb3JlLnJhdyddKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ2NvbXBsZXRlZCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT0gJ2NtaS5jb3JlLnNjb3JlLnJhdycpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NvVXNlckRhdGFbJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnXSA9PSAnaW5jb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVzc29uU3RhdHVzSW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2VydFRyYWNrVG9EQihkYiwgdXNlcklkLCBzY29ybUlkLCBzY29JZCwgYXR0ZW1wdCwgJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnLCAnY29tcGxldGVkJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvbid0IHVwZGF0ZSB4LnN0YXJ0LnRpbWUsIGtlZXAgdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgICAgICBpZiAoIXNjb1VzZXJEYXRhW2VsZW1lbnRdIHx8IGVsZW1lbnQgIT0gJ3guc3RhcnQudGltZScpIHtcbiAgICAgICAgICAgIGlmICghaW5zZXJ0VHJhY2tUb0RCKGRiLCB1c2VySWQsIHNjb3JtSWQsIHNjb0lkLCBhdHRlbXB0LCBlbGVtZW50LCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgZmFpbGVkLlxuICAgICAgICAgICAgICAgIGlmIChsZXNzb25TdGF0dXNJbnNlcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSb2xsYmFjayBwcmV2aW91cyBpbnNlcnQuXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRyYWNrVG9EQihkYiwgdXNlcklkLCBzY29ybUlkLCBzY29JZCwgYXR0ZW1wdCwgJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnLCAnaW5jb21wbGV0ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgU0NPUk0gaXMgYmxvY2tlZCBieSBhIHdyaXRpbmcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT2ZmbGluZSNpc1Njb3JtQmxvY2tlZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgVHJ1ZSBpZiBibG9ja2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1Njb3JtQmxvY2tlZCA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCkge1xuICAgICAgICBpZiAoIWJsb2NrZWRTY29ybXNbc2l0ZUlkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIWJsb2NrZWRTY29ybXNbc2l0ZUlkXVtzY29ybUlkXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFyayBhbGwgdGhlIGVudHJpZXMgZnJvbSBhIFNDTyBhbmQgYXR0ZW1wdCBhcyBzeW5jZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT2ZmbGluZSNtYXJrQXNTeW5jZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NvSWQgICAgU0NPIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gbWFya2VkLlxuICAgICAqL1xuICAgIHNlbGYubWFya0FzU3luY2VkID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1c2VySWQsIHNjb0lkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnTWFyayBTQ08gJyArIHNjb0lkICsgJyBhcyBzeW5jZWQgZm9yIGF0dGVtcHQgJyArIGF0dGVtcHQgKyAnIGluIFNDT1JNICcgKyBzY29ybUlkKTtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fCBzaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTY29ybVN0b3JlZERhdGEoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1c2VySWQsIHRydWUpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBkYiA9IHNpdGUuZ2V0RGIoKTtcblxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuc2NvaWQgPT0gc2NvSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN5bmNlZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRiLmluc2VydChtbWFNb2RTY29ybU9mZmxpbmVUcmFja3NTdG9yZSwgZW50cnkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGRlZmF1bHQgZGF0YSBmb3JtIHVzZXIgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdXNlckRhdGEgVXNlciBkYXRhIHJldHVybmVkIGJ5ICRtbWFNb2RTY29ybSNnZXRTY29ybVVzZXJEYXRhLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgVXNlciBkYXRhIHdpdGhvdXQgZGVmYXVsdCBkYXRhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZURlZmF1bHREYXRhKHVzZXJEYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBhbmd1bGFyLmNvcHkodXNlckRhdGEpO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzdWx0LCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzY28uZGVmYXVsdGRhdGE7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgU0NPUk0gdHJhY2tpbmcgcmVjb3JkIGluIG9mZmxpbmUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT2ZmbGluZSNzYXZlVHJhY2tzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29ybSAgICAgIFNDT1JNLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgICAgICBTY28gSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0ICAgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSAge09iamVjdFtdfSB0cmFja3MgICBUcmFja2luZyBkYXRhIHRvIHN0b3JlLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdXNlckRhdGEgICBVc2VyIGRhdGEgZm9yIHRoaXMgYXR0ZW1wdCBhbmQgU0NPLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gZGF0YSBpcyBzYXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLnNhdmVUcmFja3MgPSBmdW5jdGlvbihzaXRlSWQsIHNjb3JtLCBzY29JZCwgYXR0ZW1wdCwgdHJhY2tzLCB1c2VyRGF0YSkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQgPSBzaXRlLmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgICAgIGluaXRpYWxCbG9ja2VkO1xuXG4gICAgICAgICAgICBpZiAoIWJsb2NrZWRTY29ybXNbc2l0ZUlkXSkge1xuICAgICAgICAgICAgICAgIGJsb2NrZWRTY29ybXNbc2l0ZUlkXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5pdGlhbEJsb2NrZWQgPSAhIWJsb2NrZWRTY29ybXNbc2l0ZUlkXVtzY29ybS5pZF07IC8vIFNhdmUgaW5pdGlhbCBibG9ja2VkIHN0YXRlLlxuICAgICAgICAgICAgYmxvY2tlZFNjb3Jtc1tzaXRlSWRdW3Njb3JtLmlkXSA9IHRydWU7IC8vIEJsb2NrIHRoZSBTQ09STSBzbyBpdCBjYW4ndCBiZSBzeW5jZWQuXG5cbiAgICAgICAgICAgIC8vIEluc2VydCBhbGwgdGhlIHRyYWNrcy5cbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHRyYWNrcywgZnVuY3Rpb24odHJhY2spIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGluc2VydFRyYWNrKHNpdGVJZCwgdXNlcklkLCBzY29ybS5pZCwgc2NvSWQsIGF0dGVtcHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLmVsZW1lbnQsIHRyYWNrLnZhbHVlLCBzY29ybS5mb3JjZWNvbXBsZXRlZCwgdXNlckRhdGFbc2NvSWRdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbml0aWFsQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja2VkU2Nvcm1zW3NpdGVJZF1bc2Nvcm0uaWRdID0gZmFsc2U7IC8vIFVuYmxvY2sgdGhlIFNDT1JNIG9ubHkgaWYgaXQgd2Fzbid0IGJsb2NrZWQgYnkgYW5vdGhlciBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgU0NPUk0gdHJhY2tpbmcgcmVjb3JkIGluIG9mZmxpbmUgcmV0dXJuaW5nIGEgc3luY2hyb25vdXMgdmFsdWUuXG4gICAgICogUGxlYXNlIHVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgaWYgc3luY2hyb25vdXMgaXMgYSBtdXN0LiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSAkbW1hTW9kU2Nvcm1PZmZsaW5lI3NhdmVUcmFja3MuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT2ZmbGluZSNzYXZlVHJhY2tzU3luY1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2Nvcm0gICAgU0NPUk0uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29JZCAgICBTY28gSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0ICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gdHJhY2tzIFRyYWNraW5nIGRhdGEgdG8gc3RvcmUuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB1c2VyRGF0YSBVc2VyIGRhdGEgZm9yIHRoaXMgYXR0ZW1wdCBhbmQgU0NPLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgVHJ1ZSBpZiBkYXRhIHRvIGluc2VydCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLiBSZXR1cm5pbmcgdHJ1ZSBkb2Vzbid0IG1lYW4gdGhhdCB0aGUgZGF0YVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzIGJlZW4gc3RvcmVkLCB0aGlzIGZ1bmN0aW9uIGNhbiByZXR1cm4gdHJ1ZSBidXQgdGhlIGluc2VydGlvbiBjYW4gc3RpbGwgZmFpbCBzb21laG93LlxuICAgICAqL1xuICAgIHNlbGYuc2F2ZVRyYWNrc1N5bmMgPSBmdW5jdGlvbihzY29ybSwgc2NvSWQsIGF0dGVtcHQsIHRyYWNrcywgdXNlckRhdGEpIHtcbiAgICAgICAgdmFyIHVzZXJJZCA9ICRtbVNpdGUuZ2V0VXNlcklkKCksXG4gICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2godHJhY2tzLCBmdW5jdGlvbih0cmFjaykge1xuICAgICAgICAgICAgaWYgKCFpbnNlcnRUcmFja1N5bmModXNlcklkLCBzY29ybS5pZCwgc2NvSWQsIGF0dGVtcHQsIHRyYWNrLmVsZW1lbnQsIHRyYWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nvcm0uZm9yY2Vjb21wbGV0ZWQsIHVzZXJEYXRhW3Njb0lkXSkpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGEgcGFyYW1ldGVyIGluIHVzZXJkYXRhIGFuZCByZXR1cm4gaXQgaWYgaXQncyBzZXQgb3IgcmV0dXJuICdpZmVtcHR5JyBpZiBpdCdzIGVtcHR5LlxuICAgICAqIEJhc2VkIG9uIE1vb2RsZSdzIHNjb3JtX2lzc2V0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB1c2VyZGF0YSAgQ29udGFpbnMgdXNlcidzIGRhdGEuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwYXJhbSAgICAgTmFtZSBvZiBwYXJhbWV0ZXIgdGhhdCBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgKiBAcGFyYW0gIHtNaXhlZH0gIFtpZmVtcHR5XSBWYWx1ZSB0byBiZSByZXBsYWNlZCB3aXRoIGlmIHBhcmFtIGlzIG5vdCBzZXQuXG4gICAgICogQHJldHVybiB7TWl4ZWR9ICAgICAgICAgICAgVmFsdWUgZnJvbSB1c2VyZGF0YVtwYXJhbV0gaWYgc2V0LCBpZmVtcHR5IG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY29ybUlzc2V0KHVzZXJkYXRhLCBwYXJhbSwgaWZlbXB0eSkge1xuICAgICAgICBpZiAodHlwZW9mIGlmZW1wdHkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmZW1wdHkgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcmRhdGFbcGFyYW1dICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlcmRhdGFbcGFyYW1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZmVtcHR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhbiBhdHRlbXB0J3Mgc25hcHNob3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT2ZmbGluZSNzZXRBdHRlbXB0U25hcHNob3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyRGF0YSBVc2VyIGRhdGEgdG8gc3RvcmUgYXMgc25hcHNob3QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkIHVzZSBzaXRlJ3MgY3VycmVudCB1c2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gc25hcHNob3QgaGFzIGJlZW4gc3RvcmVkLlxuICAgICAqL1xuICAgIHNlbGYuc2V0QXR0ZW1wdFNuYXBzaG90ID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1c2VyRGF0YSwgdXNlcklkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnU2V0IHNuYXBzaG90IGZvciBhdHRlbXB0ICcgKyBhdHRlbXB0ICsgJyBpbiBTQ09STSAnICsgc2Nvcm1JZCk7XG4gICAgICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgc2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNpdGUuZ2V0RGIoKS5nZXQobW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZSwgW3Njb3JtSWQsIHVzZXJJZCwgYXR0ZW1wdF0pLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5zbmFwc2hvdCA9IHJlbW92ZURlZmF1bHREYXRhKHVzZXJEYXRhKTtcbiAgICAgICAgICAgICAgICBlbnRyeS50aW1lbW9kaWZpZWQgPSAkbW1VdGlsLnRpbWVzdGFtcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXRlLmdldERiKCkuaW5zZXJ0KG1tYU1vZFNjb3JtT2ZmbGluZUF0dGVtcHRzU3RvcmUsIGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9zY29ybScpXG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgU0NPUk0gb25saW5lIGZlYXR1cmVzLlxuICogVGhpcyBzZXJ2aWNlIGhvbGRzIGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCBoYXZlIHNvbWUga2luZCBvZiBlcXVpdmFsZW50IGZlYXR1cmUgaW4gJG1tYU1vZFNjb3JtT2ZmbGluZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kU2Nvcm1PbmxpbmVcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RTY29ybU9ubGluZScsIGZ1bmN0aW9uKCRtbVNpdGVzTWFuYWdlciwgJG1tU2l0ZSwgJHEsICRtbVdTLCAkbG9nLCBtbUNvcmVXU1ByZWZpeCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hTW9kU2Nvcm1PbmxpbmUnKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGJsb2NrZWRTY29ybXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGJsb2NrZWQgU0NPUk1zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9ubGluZSNjbGVhckJsb2NrZWRTY29ybXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gSWYgc2V0LCBjbGVhciB0aGUgYmxvY2tlZCBTQ09STXMgb25seSBmb3IgdGhpcyBzaXRlLiBPdGhlcndpc2UgY2xlYXIgYWxsIFNDT1JNcy5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNlbGYuY2xlYXJCbG9ja2VkU2Nvcm1zID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIGlmIChzaXRlSWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBibG9ja2VkU2Nvcm1zW3NpdGVJZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBibG9ja2VkU2Nvcm1zID0ge307XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgU0NPUk0gYXR0ZW1wdCBjb3VudCBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJJZF0gVXNlciBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEF0dGVtcHRDb3VudENhY2hlS2V5KHNjb3JtSWQsIHVzZXJJZCkge1xuICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgJG1tU2l0ZS5nZXRVc2VySWQoKTtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RTY29ybTphdHRlbXB0Y291bnQ6JyArIHNjb3JtSWQgKyAnOicgKyB1c2VySWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgZG9uZSBieSBhIHVzZXIgaW4gdGhlIGdpdmVuIFNDT1JNLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9ubGluZSNnZXRBdHRlbXB0Q291bnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgICAgICAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdICAgICAgIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkIHVzZSBzaXRlJ3MgY3VycmVudCB1c2VyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlTWlzc2luZyBUcnVlIGlmIGl0IHNob3VsZCBpZ25vcmUgYXR0ZW1wdHMgdGhhdCBoYXZlbid0IHJlcG9ydGVkIGEgZ3JhZGUvY29tcGxldGlvbi5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlICAgVHJ1ZSBpZiBpdCBzaG91bGQgaWdub3JlIGNhY2hlZCBkYXRhIChpdCB3aWxsIGFsd2F5cyBmYWlsIGluIG9mZmxpbmUgb3Igc2VydmVyIGRvd24pLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGF0dGVtcHQgY291bnQgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QXR0ZW1wdENvdW50ID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkLCB1c2VySWQsIGlnbm9yZU1pc3NpbmcsIGlnbm9yZUNhY2hlKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdXNlcklkID0gdXNlcklkIHx8IHNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JtaWQ6IHNjb3JtSWQsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJpZDogdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVtaXNzaW5nY29tcGxldGlvbjogaWdub3JlTWlzc2luZyA/IDEgOiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0QXR0ZW1wdENvdW50Q2FjaGVLZXkoc2Nvcm1JZCwgdXNlcklkKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChpZ25vcmVDYWNoZSkge1xuICAgICAgICAgICAgICAgIHByZVNldHMuZ2V0RnJvbUNhY2hlID0gMDtcbiAgICAgICAgICAgICAgICBwcmVTZXRzLmVtZXJnZW5jeUNhY2hlID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNpdGUucmVhZCgnbW9kX3Njb3JtX2dldF9zY29ybV9hdHRlbXB0X2NvdW50JywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZS5hdHRlbXB0c2NvdW50ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5hdHRlbXB0c2NvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIFNDT1JNIHVzZXIgZGF0YSBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0IEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY29ybVVzZXJEYXRhQ2FjaGVLZXkoc2Nvcm1JZCwgYXR0ZW1wdCkge1xuICAgICAgICByZXR1cm4gZ2V0U2Nvcm1Vc2VyRGF0YUNvbW1vbkNhY2hlS2V5KHNjb3JtSWQpICsgJzonICsgYXR0ZW1wdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29tbW9uIGNhY2hlIGtleSBmb3IgU0NPUk0gdXNlciBkYXRhIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgU0NPUk0gSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNjb3JtVXNlckRhdGFDb21tb25DYWNoZUtleShzY29ybUlkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kU2Nvcm06dXNlcmRhdGE6JyArIHNjb3JtSWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1c2VyIGRhdGEgZm9yIGEgY2VydGFpbiBTQ09STSBhbmQgYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PbmxpbmUjZ2V0U2Nvcm1Vc2VyRGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICAgICAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBUcnVlIGlmIGl0IHNob3VsZCBpZ25vcmUgY2FjaGVkIGRhdGEgKGl0IHdpbGwgYWx3YXlzIGZhaWwgaW4gb2ZmbGluZSBvciBzZXJ2ZXIgZG93bikuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHVzZXIgZGF0YSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRTY29ybVVzZXJEYXRhID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCBpZ25vcmVDYWNoZSkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JtaWQ6IHNjb3JtSWQsXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRTY29ybVVzZXJEYXRhQ2FjaGVLZXkoc2Nvcm1JZCwgYXR0ZW1wdClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaWdub3JlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBwcmVTZXRzLmdldEZyb21DYWNoZSA9IDA7XG4gICAgICAgICAgICAgICAgcHJlU2V0cy5lbWVyZ2VuY3lDYWNoZSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzaXRlLnJlYWQoJ21vZF9zY29ybV9nZXRfc2Nvcm1fdXNlcl9kYXRhJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0IHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc3BvbnNlLmRhdGEsIGZ1bmN0aW9uKHNjbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZERlZmF1bHREYXRhID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVXNlckRhdGEgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjby5kZWZhdWx0ZGF0YSwgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWREZWZhdWx0RGF0YVtlbnRyeS5lbGVtZW50XSA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NvLnVzZXJkYXRhLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFVzZXJEYXRhW2VudHJ5LmVsZW1lbnRdID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhID0gZm9ybWF0dGVkRGVmYXVsdERhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY28udXNlcmRhdGEgPSBmb3JtYXR0ZWRVc2VyRGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtzY28uc2NvaWRdID0gc2NvO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgYXR0ZW1wdCBjb3VudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PbmxpbmUjaW52YWxpZGF0ZUF0dGVtcHRDb3VudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJJZF0gVXNlciBJRC4gSWYgbm90IGRlZmluZWQgdXNlIHNpdGUncyBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVBdHRlbXB0Q291bnQgPSBmdW5jdGlvbihzaXRlSWQsIHNjb3JtSWQsIHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fCBzaXRlLmdldFVzZXJJZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0QXR0ZW1wdENvdW50Q2FjaGVLZXkoc2Nvcm1JZCwgdXNlcklkKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBTQ09STSB1c2VyIGRhdGEgZm9yIGFsbCBhdHRlbXB0cy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PbmxpbmUjaW52YWxpZGF0ZVNjb3JtVXNlckRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVTY29ybVVzZXJEYXRhID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXlTdGFydGluZ1dpdGgoZ2V0U2Nvcm1Vc2VyRGF0YUNvbW1vbkNhY2hlS2V5KHNjb3JtSWQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgU0NPUk0gaXMgYmxvY2tlZCBieSBhIHdyaXRpbmcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT25saW5lI2lzU2Nvcm1CbG9ja2VkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICBTaXRlIElELiBJZiBub3Qgc2V0LCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICBUcnVlIGlmIGJsb2NrZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzU2Nvcm1CbG9ja2VkID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkKSB7XG4gICAgICAgIGlmICghYmxvY2tlZFNjb3Jtc1tzaXRlSWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhYmxvY2tlZFNjb3Jtc1tzaXRlSWRdW3Njb3JtSWRdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyBhIFNDT1JNIHRyYWNraW5nIHJlY29yZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PbmxpbmUjc2F2ZVRyYWNrc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC4gSWYgbm90IHNldCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgICAgU2NvIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IHRyYWNrcyBUcmFja2luZyBkYXRhLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGRhdGEgaXMgc2F2ZWQuXG4gICAgICovXG4gICAgc2VsZi5zYXZlVHJhY2tzID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkLCBzY29JZCwgYXR0ZW1wdCwgdHJhY2tzKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBzY29pZDogc2NvSWQsXG4gICAgICAgICAgICAgICAgYXR0ZW1wdDogYXR0ZW1wdCxcbiAgICAgICAgICAgICAgICB0cmFja3M6IHRyYWNrc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCF0cmFja3MgfHwgIXRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbigpOyAvLyBOb3RoaW5nIHRvIHNhdmUuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYmxvY2tlZFNjb3Jtc1tzaXRlSWRdKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tlZFNjb3Jtc1tzaXRlSWRdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9ja2VkU2Nvcm1zW3NpdGVJZF1bc2Nvcm1JZF0gPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS53cml0ZSgnbW9kX3Njb3JtX2luc2VydF9zY29ybV90cmFja3MnLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UudHJhY2tpZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRyYWNraWRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJsb2NrZWRTY29ybXNbc2l0ZUlkXVtzY29ybUlkXSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyBhIFNDT1JNIHRyYWNraW5nIHJlY29yZCB1c2luZyBhIHN5bmNocm9ub3VzIGNhbGwuXG4gICAgICogUGxlYXNlIHVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgaWYgc3luY2hyb25vdXMgaXMgYSBtdXN0LiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSAkbW1hTW9kU2Nvcm0jc2F2ZVRyYWNrcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PbmxpbmUjc2F2ZVRyYWNrc1N5bmNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkICAgIFNjbyBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSAge09iamVjdFtdfSB0cmFja3MgVHJhY2tpbmcgZGF0YS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgIFRydWUgaWYgc3VjY2VzcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuc2F2ZVRyYWNrc1N5bmMgPSBmdW5jdGlvbihzY29JZCwgYXR0ZW1wdCwgdHJhY2tzKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgc2NvaWQ6IHNjb0lkLFxuICAgICAgICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHQsXG4gICAgICAgICAgICAgICAgdHJhY2tzOiB0cmFja3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIHNpdGV1cmw6ICRtbVNpdGUuZ2V0VVJMKCksXG4gICAgICAgICAgICAgICAgd3N0b2tlbjogJG1tU2l0ZS5nZXRUb2tlbigpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd3NGdW5jdGlvbiA9ICRtbVNpdGUuZ2V0Q29tcGF0aWJsZUZ1bmN0aW9uKCdtb2Rfc2Nvcm1faW5zZXJ0X3Njb3JtX3RyYWNrcycpLFxuICAgICAgICAgICAgcmVzcG9uc2U7XG5cbiAgICAgICAgaWYgKCF0cmFja3MgfHwgIXRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBOb3RoaW5nIHRvIHNhdmUuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbWV0aG9kIGlzIGF2YWlsYWJsZSwgdXNlIGEgcHJlZml4ZWQgdmVyc2lvbiBpZiBwb3NzaWJsZS5cbiAgICAgICAgaWYgKCEkbW1TaXRlLndzQXZhaWxhYmxlKHdzRnVuY3Rpb24sIGZhbHNlKSkge1xuICAgICAgICAgICAgaWYgKCRtbVNpdGUud3NBdmFpbGFibGUobW1Db3JlV1NQcmVmaXggKyB3c0Z1bmN0aW9uLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICB3c0Z1bmN0aW9uID0gbW1Db3JlV1NQcmVmaXggKyB3c0Z1bmN0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbG9nLmVycm9yKFwiV1MgZnVuY3Rpb24gJ1wiICsgd3NGdW5jdGlvbiArIFwiJyBpcyBub3QgYXZhaWxhYmxlLCBldmVuIGluIGNvbXBhdGliaWxpdHkgbW9kZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzcG9uc2UgPSAkbW1XUy5zeW5jQ2FsbCh3c0Z1bmN0aW9uLCBwYXJhbXMsIHByZVNldHMpO1xuICAgICAgICBpZiAocmVzcG9uc2UgJiYgIXJlc3BvbnNlLmVycm9yICYmIHJlc3BvbnNlLnRyYWNraWRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2Rfc2Nvcm0nKVxuXG4uY29uc3RhbnQoJ21tYU1vZFNjb3JtU3luY2hyb25pemF0aW9uU3RvcmUnLCAnbW9kX3Njb3JtX3N5bmMnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbVNpdGVzRmFjdG9yeVByb3ZpZGVyLCBtbWFNb2RTY29ybVN5bmNocm9uaXphdGlvblN0b3JlKSB7XG4gICAgdmFyIHN0b3JlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogbW1hTW9kU2Nvcm1TeW5jaHJvbml6YXRpb25TdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6ICdzY29ybWlkJyxcbiAgICAgICAgICAgIGluZGV4ZXM6IFtdXG4gICAgICAgIH1cbiAgICBdO1xuICAgICRtbVNpdGVzRmFjdG9yeVByb3ZpZGVyLnJlZ2lzdGVyU3RvcmVzKHN0b3Jlcyk7XG59KVxuXG4vKipcbiAqIFNDT1JNIHN5bmNocm9uaXphdGlvbiBzZXJ2aWNlLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RTY29ybVN5bmNcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RTY29ybVN5bmMnLCBmdW5jdGlvbigkbW1hTW9kU2Nvcm0sICRtbVNpdGUsICRxLCAkdHJhbnNsYXRlLCAkbW1hTW9kU2Nvcm1PbmxpbmUsICRtbWFNb2RTY29ybU9mZmxpbmUsICRtbVV0aWwsXG4gICAgICAgICAgICAkbG9nLCBtbWFNb2RTY29ybVN5bmNocm9uaXphdGlvblN0b3JlLCBtbWFNb2RTY29ybVN5bmNUaW1lLCAkbW1Db25maWcsIG1tQ29yZVNldHRpbmdzU3luY09ubHlPbldpZmksICRtbUFwcCxcbiAgICAgICAgICAgICRtbUV2ZW50cywgbW1hTW9kU2Nvcm1FdmVudEF1dG9tU3luY2VkLCAkbW1TaXRlc01hbmFnZXIpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU1vZFNjb3JtU3luYycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgc3luY1Byb21pc2VzID0ge307IC8vIFN0b3JlIHN5bmMgcHJvbWlzZXMuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN5bmNocm9uaXphdGlvbiB0aW1lIG9mIGEgU0NPUk0uIFJldHVybnMgMCBpZiBubyB0aW1lIHN0b3JlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1TeW5jI2dldFNjb3JtU3luY1RpbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgdGltZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb3JtU3luY1RpbWUgPSBmdW5jdGlvbihzY29ybUlkLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0KG1tYU1vZFNjb3JtU3luY2hyb25pemF0aW9uU3RvcmUsIHNjb3JtSWQpLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkudGltZTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN5bmNocm9uaXphdGlvbiB0aW1lIG9mIGEgU0NPUk0uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtU3luYyNzZXRTY29ybVN5bmNUaW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZV0gICBUaW1lIHRvIHNldC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgdGltZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSB0aW1lIGlzIHNldC5cbiAgICAgKi9cbiAgICBzZWxmLnNldFNjb3JtU3luY1RpbWUgPSBmdW5jdGlvbihzY29ybUlkLCBzaXRlSWQsIHRpbWUpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpbWUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KG1tYU1vZFNjb3JtU3luY2hyb25pemF0aW9uU3RvcmUsIHtzY29ybWlkOiBzY29ybUlkLCB0aW1lOiB0aW1lfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcnkgdG8gc3luY2hyb25pemUgYWxsIFNDT1JNcyBmcm9tIGN1cnJlbnQgc2l0ZSB0aGF0IG5lZWQgaXQgYW5kIGhhdmVuJ3QgYmVlbiBzeW5jaHJvbml6ZWQgaW4gYSB3aGlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1TeW5jI3N5bmNBbGxTY29ybXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRCB0byBzeW5jLiBJZiBub3QgZGVmaW5lZCwgc3luYyBhbGwgc2l0ZXMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgc3luYyBpcyBkb25lLlxuICAgICAqL1xuICAgIHNlbGYuc3luY0FsbFNjb3JtcyA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBpZiAoISRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdDYW5ub3Qgc3luYyBhbGwgU0NPUk1zIGJlY2F1c2UgZGV2aWNlIGlzIG9mZmxpbmUuJyk7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBmaXJzdCBjaGVjayBzeW5jIHNldHRpbmdzIGFuZCBjdXJyZW50IGNvbm5lY3Rpb24gdG8gc2VlIGlmIHdlIGNhbiBzeW5jLlxuICAgICAgICByZXR1cm4gJG1tQ29uZmlnLmdldChtbUNvcmVTZXR0aW5nc1N5bmNPbmx5T25XaWZpLCB0cnVlKS50aGVuKGZ1bmN0aW9uKHN5bmNPbmx5T25XaWZpKSB7XG5cbiAgICAgICAgICAgIGlmIChzeW5jT25seU9uV2lmaSAmJiAkbW1BcHAuaXNOZXR3b3JrQWNjZXNzTGltaXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ2Fubm90IHN5bmMgYWxsIFNDT1JNcyBiZWNhdXNlIGRldmljZSBpc25cXCd0IHVzaW5nIGEgV2lGaSBuZXR3b3JrLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgICBpZiAoIXNpdGVJZCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIHNpdGUgSUQgZGVmaW5lZCwgc3luYyBhbGwgc2l0ZXMuXG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVHJ5IHRvIHN5bmMgU0NPUk1zIGluIGFsbCBzaXRlcy4nKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGVzSWRzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1RyeSB0byBzeW5jIFNDT1JNcyBpbiBzaXRlICcgKyBzaXRlSWQpO1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKFtzaXRlSWRdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihzaXRlSWRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpdGVQcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNpdGVJZHMsIGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBzaXRlUHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm1PZmZsaW5lLmdldEFsbEF0dGVtcHRzKHNpdGVJZCkudGhlbihmdW5jdGlvbihhdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjb3JtcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkcyA9IFtdLCAvLyBUbyBwcmV2ZW50IGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBJRHMgb2YgYWxsIHRoZSBTQ09STXMgdGhhdCBoYXZlIHNvbWV0aGluZyB0byBiZSBzeW5jZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goYXR0ZW1wdHMsIGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWRzLmluZGV4T2YoYXR0ZW1wdC5zY29ybWlkKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChhdHRlbXB0LnNjb3JtaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29ybXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogYXR0ZW1wdC5zY29ybWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291cnNlaWQ6IGF0dGVtcHQuY291cnNlaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN5bmMgYWxsIFNDT1JNcyB0aGF0IGhhdmVuJ3QgYmVlbiBzeW5jZWQgZm9yIGEgd2hpbGUgYW5kIHRoYXQgYXJlbid0IHBsYXllZCByaWdodCBub3cuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2Nvcm1zLCBmdW5jdGlvbihzY29ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJG1tYU1vZFNjb3JtLmlzU2Nvcm1CZWluZ1BsYXllZChzY29ybS5pZCwgc2l0ZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RTY29ybS5nZXRTY29ybUJ5SWQoc2Nvcm0uY291cnNlaWQsIHNjb3JtLmlkLCAnJywgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zeW5jU2Nvcm1JZk5lZWRlZChzY29ybSwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHdhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3YXJuaW5ncyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB0cmllZCB0byBzeW5jLiBTZW5kIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbWFNb2RTY29ybUV2ZW50QXV0b21TeW5jZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVpZDogc2l0ZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nvcm1pZDogc2Nvcm0uaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwoc2l0ZVByb21pc2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gYSBTQ09STSBvZmZsaW5lIGF0dGVtcHQgdG8gdGhlIHNpdGUuXG4gICAgICogUmVzZXJ2ZWQgZm9yIGNvcmUgdXNlLCBwbGVhc2UgdXNlICRtbWFNb2RTY29ybVN5bmMjc3luY1Njb3JtIHRvIHN5bmNocm9uaXplIFNDT1JNIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtU3luYyNfc3luY0F0dGVtcHRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBhdHRlbXB0IGlzIHN1Y2Nlc3NmdWxseSBzeW5jZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX3N5bmNBdHRlbXB0ID0gZnVuY3Rpb24oc2Nvcm1JZCwgYXR0ZW1wdCwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgICRsb2cuZGVidWcoJ1RyeSB0byBzeW5jIGF0dGVtcHQgJyArIGF0dGVtcHQgKyAnIGluIFNDT1JNICcgKyBzY29ybUlkICsgJyBhbmQgc2l0ZSAnICsgc2l0ZUlkKTtcbiAgICAgICAgLy8gR2V0IG9ubHkgbm90IHN5bmNlZCBlbnRyaWVzLlxuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5nZXRTY29ybVN0b3JlZERhdGEoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1bmRlZmluZWQsIHRydWUpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgdmFyIHNjb3MgPSB7fSxcbiAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgIHNvbWV0aGluZ1N5bmNlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBHZXQgZGF0YSB0byBzZW5kIChvbmx5IGVsZW1lbnRzIHdpdGggZG90cyBsaWtlIGNtaS5jb3JlLmV4aXQsIGluIE1vYmlsZSB3ZSBzdG9yZSBtb3JlIGRhdGEgdG8gbWFrZSBvZmZsaW5lIHdvcmspLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmVsZW1lbnQuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29zW2VudHJ5LnNjb2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nvc1tlbnRyeS5zY29pZF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzY29zW2VudHJ5LnNjb2lkXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVudHJ5LmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY29zLCBmdW5jdGlvbih0cmFja3MsIHNjb0lkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm1PbmxpbmUuc2F2ZVRyYWNrcyhzaXRlSWQsIHNjb3JtSWQsIHNjb0lkLCBhdHRlbXB0LCB0cmFja3MpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjbyBkYXRhIHN1Y2Nlc3NmdWxseSBzZW50LiBNYXJrIHRoZW0gYXMgc3luY2VkLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHNvbWUgU0NPcyBzeW5jIG1pZ2h0IGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLm1hcmtBc1N5bmNlZChzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIHVuZGVmaW5lZCwgc2NvSWQpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbWV0aGluZ1N5bmNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJG1tVXRpbC5hbGxQcm9taXNlcyhwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IGhhcyBiZWVuIHNlbnQuIExldCdzIGRlbGV0ZSBpdCBmcm9tIGxvY2FsLlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmRlbGV0ZUF0dGVtcHQoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFpbGVkIHRvIGRlbGV0ZSAoc2hvdWxkbid0IGhhcHBlbikuIExldCdzIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmRlbGV0ZUF0dGVtcHQoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIHRoZXJlJ3Mgc29tZXRoaW5nIHdyb25nIHdpdGggdGhlIGRhdGEgb3IgdGhlIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdBZnRlciBzeW5jOiBlcnJvciBkZWxldGluZyBhdHRlbXB0ICcgKyBhdHRlbXB0ICsgJyBpbiBTQ09STSAnICsgc2Nvcm1JZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvbWV0aGluZ1N5bmNlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb21lIFNDT3MgaGF2ZSBiZWVuIHN5bmNlZCBhbmQgc29tZSBub3QuIFdlJ2xsIHRyeSB0byBzdG9yZSBhIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGFibGUgdG8gcmUtdHJ5IHRoZSBzeW5jaHJvbml6YXRpb24gbGF0ZXIuXG4gICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIHN5bmNocm9uaXppbmcgc29tZSBTQ09zIGZvciBhdHRlbXB0ICcgKyBhdHRlbXB0ICsgJyBpbiBTQ09STSAnICsgc2Nvcm1JZCArICcuIFNhdmluZyBzbmFwc2hvdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhdmVTeW5jU25hcHNob3Qoc2Nvcm1JZCwgYXR0ZW1wdCwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciBzeW5jaHJvbml6aW5nIGF0dGVtcHQgJyArIGF0dGVtcHQgKyAnIGluIFNDT1JNICcgKyBzY29ybUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIGEgc25hcHNob3QgZnJvbSBhIHN5bmNocm9uaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgQXR0ZW1vdCBudW1iZXIuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgIFNpdGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgc25hcHNob3QgaXMgc3RvcmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhdmVTeW5jU25hcHNob3Qoc2Nvcm1JZCwgYXR0ZW1wdCwgc2l0ZUlkKSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgY3VycmVudCBzdGF0ZSBmcm9tIE1vb2RsZS5cbiAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRTY29ybVVzZXJEYXRhKHNjb3JtSWQsIGF0dGVtcHQsIGZhbHNlLCBzaXRlSWQsIHVuZGVmaW5lZCwgdHJ1ZSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5zZXRBdHRlbXB0U25hcHNob3Qoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCBkYXRhKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBFcnJvciBnZXR0aW5nIHVzZXIgZGF0YSBmcm9tIE1vb2RsZS4gV2UnbGwgaGF2ZSB0byBidWlsZCBpdCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAvLyBMZXQncyB0cnkgdG8gZ2V0IGNhY2hlZCBkYXRhIGFib3V0IHRoZSBhdHRlbXB0LlxuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRTY29ybVVzZXJEYXRhKHNjb3JtSWQsIGF0dGVtcHQsIGZhbHNlLCBzaXRlSWQpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIGNhY2hlZCBkYXRhLCBNb29kbGUgaGFzIG5vIGRhdGEgc3RvcmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYWRkIHRoZSBzeW5jZWQgZGF0YSB0byB0aGUgc25hcHNob3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9mZmxpbmUuZ2V0U2Nvcm1TdG9yZWREYXRhKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdW5kZWZpbmVkLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihzeW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHN5bmNlZCwgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YVtlbnRyeS5zY29pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2VudHJ5LnNjb2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvaWQ6IGVudHJ5LnNjb2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyZGF0YToge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtlbnRyeS5zY29pZF0udXNlcmRhdGFbZW50cnkuZWxlbWVudF0gPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLnNldEF0dGVtcHRTbmFwc2hvdChzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN5bmMgYSBTQ09STSBvbmx5IGlmIGEgY2VydGFpbiB0aW1lIGhhcyBwYXNzZWQgc2luY2UgdGhlIGxhc3QgdGltZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1TeW5jI3N5bmNTY29ybUlmTmVlZGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtICAgIFNDT1JNIGRvd25sb2FkZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgU0NPUk0gaXMgc3luY2VkIG9yIGlmIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBzeW5jZWQuXG4gICAgICovXG4gICAgc2VsZi5zeW5jU2Nvcm1JZk5lZWRlZCA9IGZ1bmN0aW9uKHNjb3JtLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2Nvcm1TeW5jVGltZShzY29ybS5pZCwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIG1tYU1vZFNjb3JtU3luY1RpbWUgPj0gdGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnN5bmNTY29ybShzY29ybSwgc2l0ZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyeSB0byBzeW5jaHJvbml6ZSBhIFNDT1JNJ3MgYXR0ZW1wdHMuXG4gICAgICogVGhlIHByb21pc2UgcmV0dXJuZWQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIGFuIGFycmF5IHdpdGggd2FybmluZ3MgaWYgdGhlIHN5bmNocm9uaXphdGlvbiBpcyBzdWNjZXNzZnVsLiBBIHN1Y2Nlc3NmdWxcbiAgICAgKiBzeW5jaHJvbml6YXRpb24gZG9lc24ndCBtZWFuIHRoYXQgYWxsIHRoZSBkYXRhIGhhcyBiZWVuIHNlbnQgdG8gdGhlIHNpdGUsIGl0J3MgcG9zc2libGUgdGhhdCBzb21lIGF0dGVtcHQgY2FuJ3QgYmUgc2VudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1TeW5jI3N5bmNTY29ybVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2Nvcm0gICBTQ09STSB0byBzeW5jLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggd2FybmluZ3MgaW4gc3VjY2VzcywgcmVqZWN0ZWQgaWYgc3luY2hyb25pemF0aW9uIGZhaWxzLlxuICAgICAqL1xuICAgIHNlbGYuc3luY1Njb3JtID0gZnVuY3Rpb24oc2Nvcm0sIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICB2YXIgd2FybmluZ3MgPSBbXSxcbiAgICAgICAgICAgIHN5bmNQcm9taXNlLFxuICAgICAgICAgICAgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzeW5jUHJvbWlzZXNbc2l0ZUlkXSAmJiBzeW5jUHJvbWlzZXNbc2l0ZUlkXVtzY29ybS5pZF0pIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHN5bmMgb25nb2luZyBmb3IgdGhpcyBTQ09STSwgcmV0dXJuIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgcmV0dXJuIHN5bmNQcm9taXNlc1tzaXRlSWRdW3Njb3JtLmlkXTtcbiAgICAgICAgfSBlbHNlIGlmICghc3luY1Byb21pc2VzW3NpdGVJZF0pIHtcbiAgICAgICAgICAgIHN5bmNQcm9taXNlc1tzaXRlSWRdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJG1tYU1vZFNjb3JtT25saW5lLmlzU2Nvcm1CbG9ja2VkKHNpdGVJZCwgc2Nvcm0uaWQpIHx8ICRtbWFNb2RTY29ybU9mZmxpbmUuaXNTY29ybUJsb2NrZWQoc2l0ZUlkLCBzY29ybS5pZCkpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0Nhbm5vdCBzeW5jIFNDT1JNICcgKyBzY29ybS5pZCArICcgYmVjYXVzZSBpdCBpcyBibG9ja2VkLicpO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgJGxvZy5kZWJ1ZygnVHJ5IHRvIHN5bmMgU0NPUk0gJyArIHNjb3JtLmlkICsgJyBpbiBzaXRlICcgKyBzaXRlSWQpO1xuXG4gICAgICAgIC8vIFByZWZldGNoZXMgZGF0YSAsIHNldCBzeW5jIHRpbWUgYW5kIHJldHVybiB3YXJuaW5ncy5cbiAgICAgICAgZnVuY3Rpb24gZmluaXNoU3luYygpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uaW52YWxpZGF0ZUFsbFNjb3JtRGF0YShzY29ybS5pZCwgc2l0ZUlkKS5jYXRjaChmdW5jdGlvbigpIHt9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0ucHJlZmV0Y2hEYXRhKHNjb3JtLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNldFNjb3JtU3luY1RpbWUoc2Nvcm0uaWQsIHNpdGVJZCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzLlxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhcm5pbmdzOyAvLyBObyBvZmZsaW5lIGF0dGVtcHRzLCBub3RoaW5nIHRvIHN5bmMuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYXR0ZW1wdHMgZGF0YS4gV2UgaWdub3JlIGNhY2hlIGZvciBvbmxpbmUgYXR0ZW1wdHMsIHNvIHRoaXMgY2FsbCB3aWxsIGZhaWwgaWYgb2ZmbGluZSBvciBzZXJ2ZXIgZG93bi5cbiAgICAgICAgc3luY1Byb21pc2UgPSAkbW1hTW9kU2Nvcm0uZ2V0QXR0ZW1wdENvdW50KHNjb3JtLmlkLCBzaXRlSWQsIHVuZGVmaW5lZCwgZmFsc2UsIHRydWUpLnRoZW4oZnVuY3Rpb24oYXR0ZW1wdHNEYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWF0dGVtcHRzRGF0YS5vZmZsaW5lIHx8ICFhdHRlbXB0c0RhdGEub2ZmbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoU3luYygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29sbGlzaW9ucyA9IFtdLFxuICAgICAgICAgICAgICAgIGxhc3RPbmxpbmUgPSAwLFxuICAgICAgICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBjb2xsaXNpb25zIGJldHdlZW4gb2ZmbGluZSBhbmQgb25saW5lIGF0dGVtcHRzIChzYW1lIG51bWJlcikuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goYXR0ZW1wdHNEYXRhLm9ubGluZSwgZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIGxhc3RPbmxpbmUgPSBNYXRoLm1heChsYXN0T25saW5lLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdHNEYXRhLm9mZmxpbmUuaW5kZXhPZihhdHRlbXB0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbnMucHVzaChhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbGFzdCBvbmxpbmUgYXR0ZW1wdCBpcyBmaW5pc2hlZC4gSWdub3JlIGNhY2hlLlxuICAgICAgICAgICAgcHJvbWlzZSA9IGxhc3RPbmxpbmUgPiAwID8gJG1tYU1vZFNjb3JtLmlzQXR0ZW1wdEluY29tcGxldGUoc2Nvcm0uaWQsIGxhc3RPbmxpbmUsIGZhbHNlLCB0cnVlLCBzaXRlSWQpIDogJHEud2hlbihmYWxzZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghY29sbGlzaW9ucy5sZW5ndGggJiYgIWluY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY29sbGlzaW9ucyBhbmQgbGFzdCBhdHRlbXB0IGlzIGNvbXBsZXRlLiBTZW5kIG9mZmxpbmUgYXR0ZW1wdHMgdG8gTW9vZGxlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGF0dGVtcHRzRGF0YS5vZmZsaW5lLCBmdW5jdGlvbihhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nvcm0ubWF4YXR0ZW1wdCA9PSAwIHx8IGF0dGVtcHQgPD0gc2Nvcm0ubWF4YXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5fc3luY0F0dGVtcHQoc2Nvcm0uaWQsIGF0dGVtcHQsIHNpdGVJZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2hTeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xsaXNpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGNvbGxpc2lvbnMsIHRyZWF0IHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmVhdENvbGxpc2lvbnMoc2Nvcm0uaWQsIHNpdGVJZCwgY29sbGlzaW9ucywgbGFzdE9ubGluZSwgYXR0ZW1wdHNEYXRhLm9mZmxpbmUpLnRoZW4oZnVuY3Rpb24od2FybnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzID0gd2FybmluZ3MuY29uY2F0KHdhcm5zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9mZmxpbmUgYXR0ZW1wdHMgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNpbmNlIHNvbWUgY29sbGlzaW9ucyBjYW4gYmUgY29udmVydGVkIHRvIG5ldyBhdHRlbXB0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmdldEF0dGVtcHRzKHNpdGVJZCwgc2Nvcm0uaWQpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ub3RTeW5jU29tZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcyA9IGVudHJpZXMubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5hdHRlbXB0OyAvLyBHZXQgb25seSB0aGUgYXR0ZW1wdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluY29tcGxldGUgJiYgZW50cmllcy5pbmRleE9mKGxhc3RPbmxpbmUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCBvbmxpbmUgd2FzIGluY29tcGxldGUsIGJ1dCBpdCB3YXMgY29udGludWVkIGluIG9mZmxpbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdsbCBhbHdheXMgc3luYyBhdHRlbXB0cyBwcmV2aW91cyB0byBsYXN0T25saW5lIChmYWlsZWQgc3luYyBvciBjb250aW51ZWQgaW4gb2ZmbGluZSkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ2xsIG9ubHkgc3luYyBuZXcgYXR0ZW1wcyBpZiBsYXN0IG9ubGluZSBhdHRlbXB0IGlzIGNvbXBsZXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmNvbXBsZXRlIHx8IGF0dGVtcHQgPD0gbGFzdE9ubGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3JtLm1heGF0dGVtcHQgPT0gMCB8fCBhdHRlbXB0IDw9IHNjb3JtLm1heGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYuX3N5bmNBdHRlbXB0KHNjb3JtLmlkLCBhdHRlbXB0LCBzaXRlSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm5vdFN5bmNTb21lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5ub3RTeW5jU29tZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MucHVzaCgkdHJhbnNsYXRlLmluc3RhbnQoJ21tYS5tb2Rfc2Nvcm0ud2FybmluZ3N5bmNvbmxpbmVpbmNvbXBsZXRlJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2hTeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY29sbGlzaW9ucywgYnV0IGxhc3Qgb25saW5lIGF0dGVtcHQgaXMgaW5jb21wbGV0ZSBzbyB3ZSBjYW4ndCBzZW5kIG9mZmxpbmUgYXR0ZW1wdHMuXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLndhcm5pbmdzeW5jb25saW5laW5jb21wbGV0ZScpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFN5bmMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlIHN5bmNQcm9taXNlc1tzaXRlSWRdW3Njb3JtLmlkXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFkZWxldGVkKSB7XG4gICAgICAgICAgICBzeW5jUHJvbWlzZXNbc2l0ZUlkXVtzY29ybS5pZF0gPSBzeW5jUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3luY1Byb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyZWF0IGNvbGxpc2lvbnMgZm91bmQgaW4gYSBTQ09STSBzeW5jaHJvbml6YXRpb24gcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCAgICAgICAgICAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgICAgICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcltdfSBjb2xsaXNpb25zICAgICAgTnVtYmVycyBvZiBhdHRlbXB0cyB0aGF0IGV4aXN0IGJvdGggaW4gb25saW5lIGFuZCBvZmZsaW5lLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGFzdE9ubGluZSAgICAgICAgTGFzdCBvbmxpbmUgYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJbXX0gb2ZmbGluZUF0dGVtcHRzIE51bWJlcnMgb2Ygb2ZmbGluZSBhdHRlbXB0cy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY29sbGlzaW9ucyBoYXZlIGJlZW4gdHJlYXRlZC4gSXQgcmV0dXJucyB3YXJuaW5ncyBhcnJheS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFRyZWF0IGNvbGxpc2lvbnMgZm91bmQgaW4gYSBTQ09STSBzeW5jaHJvbml6YXRpb24gcHJvY2Vzcy4gQSBjb2xsaXNpb24gaXMgd2hlbiBhbiBhdHRlbXB0IGV4aXN0cyBib3RoIGluIG9mZmxpbmVcbiAgICAgKiBhbmQgb25saW5lLiBBIGNvbGxpc2lvbiBjYW4gYmU6XG4gICAgICpcbiAgICAgKiAtIFR3byBkaWZmZXJlbnQgYXR0ZW1wdHMuXG4gICAgICogLSBBbiBvbmxpbmUgYXR0ZW1wdCBjb250aW51ZWQgaW4gb2ZmbGluZS5cbiAgICAgKiAtIEEgZmFpbHVyZSBpbiBhIHByZXZpb3VzIHN5bmMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbW92ZSBpbnRvIG5ldyBhdHRlbXB0cyB0aGUgY29sbGlzaW9ucyB0aGF0IGNhbid0IGJlIG1lcmdlZC4gSXQgd2lsbCB1c3VhbGx5IGtlZXAgdGhlIG9yZGVyIG9mIHRoZVxuICAgICAqIG9mZmxpbmUgYXR0ZW1wdHMgRVhDRVBUIGlmIHRoZSBvZmZsaW5lIGF0dGVtcHQgd2FzIGNyZWF0ZWQgYWZ0ZXIgdGhlIGxhc3Qgb2ZmbGluZSBhdHRlbXB0IChlZGdlIGNhc2UpLlxuICAgICAqXG4gICAgICogRWRnZSBjYXNlOiBBIHVzZXIgY3JlYXRlcyBvZmZsaW5lIGF0dGVtcHRzIGFuZCB3aGVuIGhlIHN5bmNzIHdlIHJldHJpZXZlIGFuIGluY29tcGxldGUgb25saW5lIGF0dGVtcHQsIHNvIHRoZSBvZmZsaW5lXG4gICAgICogYXR0ZW1wdHMgY2Fubm90IGJlIHN5bmNlZC4gVGhlbiB0aGUgdXNlciBjb250aW51ZXMgdGhhdCBvbmxpbmUgYXR0ZW1wdCBhbmQgZ29lcyBvZmZsaW5lLCBzbyBhIGNvbGxpc2lvbiBpcyBjcmVhdGVkLlxuICAgICAqIFdoZW4gd2UgcGVyZm9ybSB0aGUgbmV4dCBzeW5jIHdlIGRldGVjdCB0aGF0IHRoaXMgY29sbGlzaW9uIGNhbm5vdCBiZSBtZXJnZWQsIHNvIHRoaXMgb2ZmbGluZSBhdHRlbXB0IG5lZWRzIHRvIGJlXG4gICAgICogY3JlYXRlZCBhcyBhIG5ldyBhdHRlbXB0LiBTaW5jZSB0aGlzIGF0dGVtcHQgd2FzIGNyZWF0ZWQgYWZ0ZXIgdGhlIGxhc3Qgb2ZmbGluZSBhdHRlbXB0LCBpdCB3aWxsIGJlIGFkZGVkIG90IHRoZSBlbmRcbiAgICAgKiBvZiB0aGUgbGlzdCBpZiB0aGUgbGFzdCBhdHRlbXB0IGlzIGNvbXBsZXRlZC4gSWYgdGhlIGxhc3QgYXR0ZW1wdCBpcyBub3QgY29tcGxldGVkIHRoZW4gdGhlIG9mZmxpbmUgZGF0YSB3aWxsIGRlIGRlbGV0ZWRcbiAgICAgKiBiZWNhdXNlIHdlIGNhbid0IGNyZWF0ZSBhIG5ldyBhdHRlbXB0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyZWF0Q29sbGlzaW9ucyhzY29ybUlkLCBzaXRlSWQsIGNvbGxpc2lvbnMsIGxhc3RPbmxpbmUsIG9mZmxpbmVBdHRlbXB0cykge1xuICAgICAgICB2YXIgd2FybmluZ3MgPSBbXSxcbiAgICAgICAgICAgIHByb21pc2VzID0gW10sXG4gICAgICAgICAgICBuZXdBdHRlbXB0c1NhbWVPcmRlciA9IFtdLCAvLyBBdHRlbXB0cyB0aGF0IHdpbGwgYmUgY3JlYXRlZCBhcyBuZXcgYXR0ZW1wdHMgYnV0IGtlZXBpbmcgdGhlIGN1cnJlbnQgb3JkZXIuXG4gICAgICAgICAgICBuZXdBdHRlbXB0c0F0RW5kID0ge30sIC8vIEF0dGVtcHRzIHRoYXQgd2lsbCBiZSBjcmVhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3Qgb2YgYXR0ZW1wdHMgKHNob3VsZCBiZSBtYXggMSBhdHRlbXB0KS5cbiAgICAgICAgICAgIGxhc3RDb2xsaXNpb24gPSBNYXRoLm1heC5hcHBseShNYXRoLCBjb2xsaXNpb25zKSxcbiAgICAgICAgICAgIGxhc3RPZmZsaW5lID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgb2ZmbGluZUF0dGVtcHRzKSxcbiAgICAgICAgICAgIGxhc3RPZmZsaW5lSW5jb21wbGV0ZSxcbiAgICAgICAgICAgIGxhc3RPZmZsaW5lQ3JlYXRlZDtcblxuICAgICAgICAvLyBHZXQgdGhlIGNyZWF0aW9uIHRpbWUgYW5kIHRoZSBzdGF0dXMgKGNvbXBsZXRlL2luY29tcGxldGUpIG9mIHRoZSBsYXN0IG9mZmxpbmUgYXR0ZW1wdC5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGFzdE9mZmxpbmVBdHRlbXB0RGF0YSgpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGxhc3Qgb2ZmbGluZSBhdHRlbXB0IGlzIGluY29tcGxldGUuXG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmlzQXR0ZW1wdEluY29tcGxldGUoc2Nvcm1JZCwgbGFzdE9mZmxpbmUsIHRydWUsIGZhbHNlLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZsaW5lSW5jb21wbGV0ZSA9IGluY29tcGxldGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9mZmxpbmUuZ2V0QXR0ZW1wdENyZWF0aW9uVGltZShzaXRlSWQsIHNjb3JtSWQsIGxhc3RPZmZsaW5lKS50aGVuKGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE9mZmxpbmVDcmVhdGVkID0gdGltZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGFuIGF0dGVtcHQgdG8gdGhlIHJpZ2h0IG5ldyBhdHRlbXB0cyBhcnJheSBpZiBwb3NzaWJsZS5cbiAgICAgICAgLy8gSWYgdGhlIGF0dGVtcHQgY2Fubm90IGJlIGNyZWF0ZWQgYXMgYSBuZXcgYXR0ZW1wdCB0aGVuIGl0IHdpbGwgYmUgZGVsZXRlZC5cbiAgICAgICAgZnVuY3Rpb24gYWRkVG9OZXdPckRlbGV0ZShhdHRlbXB0KSB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PSBsYXN0T2ZmbGluZSkge1xuICAgICAgICAgICAgICAgIG5ld0F0dGVtcHRzU2FtZU9yZGVyLnB1c2goYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9mZmxpbmUuZ2V0QXR0ZW1wdENyZWF0aW9uVGltZShzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQpLnRoZW4oZnVuY3Rpb24odGltZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lID4gbGFzdE9mZmxpbmVDcmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYXR0ZW1wdCB3YXMgY3JlYXRlZCBhZnRlciB0aGUgbGFzdCBvZmZsaW5lIGF0dGVtcHQsIHdlJ2xsIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0IGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE9mZmxpbmVJbmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBjYW4ndCBiZSBhZGRlZCBiZWNhdXNlIHRoZSBsYXN0IG9mZmxpbmUgYXR0ZW1wdCBpcyBpbmNvbXBsZXRlLCBkZWxldGUgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdUcnkgdG8gZGVsZXRlIGF0dGVtcHQgJyArIGF0dGVtcHQgKyAnIGJlY2F1c2UgaXQgY2Fubm90IGJlIGNyZWF0ZWQgYXMgYSBuZXcgYXR0ZW1wdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmRlbGV0ZUF0dGVtcHQoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLndhcm5pbmdvZmZsaW5lZGF0YWRlbGV0ZWQnLCB7bnVtYmVyOiBhdHRlbXB0fSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF5YmUgdGhlcmUncyBzb21ldGhpbmcgd3Jvbmcgd2l0aCB0aGUgZGF0YSBvciB0aGUgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QXR0ZW1wdHNBdEVuZFt0aW1lXSA9IGF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0F0dGVtcHRzU2FtZU9yZGVyLnB1c2goYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgbmVlZGVkIGRhdGEgZnJvbSB0aGUgbGFzdCBvZmZsaW5lIGF0dGVtcHQuXG4gICAgICAgIHJldHVybiBnZXRMYXN0T2ZmbGluZUF0dGVtcHREYXRhKCkudGhlbihmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgY29sbGlzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBnZXQgc3luY2VkIGVudHJpZXMgdG8gZGV0ZWN0IGlmIGl0IHdhcyBhIGZhaWxlZCBzeW5jaHJvbml6YXRpb24uXG4gICAgICAgICAgICAgICAgdmFyIGdldERhdGFGbiA9ICRtbWFNb2RTY29ybU9mZmxpbmUuZ2V0U2Nvcm1TdG9yZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gZ2V0RGF0YUZuKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdW5kZWZpbmVkLCBmYWxzZSwgdHJ1ZSkudGhlbihmdW5jdGlvbihzeW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5bmNlZCAmJiBzeW5jZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXR0ZW1wdCBoYXMgc3luY2VkIGVudHJpZXMsIGl0IHNlZW1zIHRvIGJlIGEgZmFpbGVkIHN5bmNocm9uaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIGdldCB0aGUgZW50cmllcyB0aGF0IGhhdmVuJ3QgYmVlbiBzeW5jZWQsIG1heWJlIGl0IGp1c3QgZmFpbGVkIHRvIGRlbGV0ZSB0aGUgYXR0ZW1wdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXREYXRhRm4oc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1bmRlZmluZWQsIHRydWUpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNEYXRhVG9TZW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5lbGVtZW50LmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNEYXRhVG9TZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0RhdGFUb1NlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIGVsZW1lbnRzIHRvIHN5bmMuIFdlIG5lZWQgdG8gY2hlY2sgaWYgaXQncyBwb3NzaWJsZSB0byBzeW5jIHRoZW0gb3Igbm90LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FuUmV0cnlTeW5jKHNjb3JtSWQsIHNpdGVJZCwgYXR0ZW1wdCwgbGFzdE9ubGluZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmV0cnkgc3luYywgd2UnbGwgY3JlYXRlIGEgbmV3IG9mZmxpbmUgYXR0ZW1wdCBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRUb05ld09yRGVsZXRlKGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIHN5bmMsIGRlbGV0ZSB0aGUgYXR0ZW1wdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9mZmxpbmUuZGVsZXRlQXR0ZW1wdChzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF5YmUgdGhlcmUncyBzb21ldGhpbmcgd3Jvbmcgd2l0aCB0aGUgZGF0YSBvciB0aGUgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBhIGZhaWxlZCBzeW5jaHJvbml6YXRpb24uIENoZWNrIGlmIGl0J3MgYW4gYXR0ZW1wdCBjb250aW51ZWQgaW4gb2ZmbGluZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmdldEF0dGVtcHRTbmFwc2hvdChzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQpLnRoZW4oZnVuY3Rpb24oc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc25hcHNob3QgJiYgT2JqZWN0LmtleXMoc25hcHNob3QpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBoYXMgYSBzbmFwc2hvdCwgaXQgbWVhbnMgaXQgY29udGludWVkIGFuIG9ubGluZSBhdHRlbXB0LiBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXkndmUgZGl2ZXJnZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgdGhlIGxhc3QgYXR0ZW1wdCB3ZSBkb24ndCBuZWVkIHRvIGlnbm9yZSBjYWNoZSBiZWNhdXNlIHdlIGFscmVhZHkgZGlkIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmcmVzaCA9IGxhc3RPbmxpbmUgIT0gYXR0ZW1wdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRTY29ybVVzZXJEYXRhKHNjb3JtSWQsIGF0dGVtcHQsIGZhbHNlLCBzaXRlSWQsIHVuZGVmaW5lZCwgcmVmcmVzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzbmFwc2hvdEVxdWFscyhzbmFwc2hvdCwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBoYXMgZGl2ZXJnZWQsIGl0IHdpbGwgYmUgY29udmVydGVkIGludG8gYSBuZXcgYXR0ZW1wdCBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkVG9OZXdPckRlbGV0ZShhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gc25hcHNob3QsIGl0J3MgYSBkaWZmZXJlbnQgYXR0ZW1wdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QXR0ZW1wdHNTYW1lT3JkZXIucHVzaChhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW92ZU5ld0F0dGVtcHRzKHNjb3JtSWQsIHNpdGVJZCwgbmV3QXR0ZW1wdHNTYW1lT3JkZXIsIGxhc3RPbmxpbmUsIGxhc3RDb2xsaXNpb24sIG9mZmxpbmVBdHRlbXB0cykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldyBhdHRlbXB0cyB0aGF0IG5lZWQgdG8ga2VlcCB0aGUgb3JkZXIgaGF2ZSBiZWVuIGNyZWF0ZWQuIE5vdyB3ZSdsbCBjcmVhdGUgdGhlIG5ldyBhdHRlbXB0c1xuICAgICAgICAgICAgICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IG9mIG9mZmxpbmUgYXR0ZW1wdHMuIEl0IHNob3VsZCBvbmx5IGJlIDEgYXR0ZW1wdCBtYXguXG4gICAgICAgICAgICAgICAgICAgIGxhc3RPZmZsaW5lID0gbGFzdE9mZmxpbmUgKyBuZXdBdHRlbXB0c1NhbWVPcmRlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXdBdHRlbXB0c0F0RW5kKHNjb3JtSWQsIHNpdGVJZCwgbmV3QXR0ZW1wdHNBdEVuZCwgbGFzdE9mZmxpbmUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FybmluZ3M7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgbnVtYmVyIG9mIHNvbWUgb2ZmbGluZSBhdHRlbXB0cy4gV2UgbmVlZCB0byBtb3ZlIGFsbCBvZmZsaW5lIGF0dGVtcHRzIGFmdGVyIHRoZSBjb2xsaXNpb25zXG4gICAgICogdG9vLCBvdGhlcndpc2Ugd2Ugd291bGQgb3ZlcndyaXRlIGRhdGEuXG4gICAgICogRXhhbXBsZTogV2UgaGF2ZSBvZmZsaW5lIGF0dGVtcHRzIDEsIDIgYW5kIDMuICMxIGFuZCAjMiBoYXZlIGNvbGxpc2lvbnMuICMxIGNhbiBiZSBzeW5jZWQsIGJ1dCAjMiBuZWVkc1xuICAgICAqIHRvIGJlIGEgbmV3IGF0dGVtcHQuICMzIHdpbGwgbm93IGJlICM0LCBhbmQgIzIgd2lsbCBub3cgYmUgIzMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgICAgICAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICAgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJbXX0gbmV3QXR0ZW1wdHMgICAgIEF0dGVtcHRzIHRoYXQgbmVlZCB0byBiZSBjb252ZXJ0ZWQgaW50byBuZXcgYXR0ZW1wdHMuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsYXN0T25saW5lICAgICAgICBMYXN0IG9ubGluZSBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGFzdENvbGxpc2lvbiAgICAgTGFzdCBhdHRlbXB0IHdpdGggY29sbGlzaW9uIChleGlzdHMgaW4gb25saW5lIGFuZCBvZmZsaW5lKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJbXX0gb2ZmbGluZUF0dGVtcHRzIE51bWJlcnMgb2Ygb2ZmbGluZSBhdHRlbXB0cy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhdHRlbXB0cyBoYXZlIGJlZW4gbW92ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW92ZU5ld0F0dGVtcHRzKHNjb3JtSWQsIHNpdGVJZCwgbmV3QXR0ZW1wdHMsIGxhc3RPbmxpbmUsIGxhc3RDb2xsaXNpb24sIG9mZmxpbmVBdHRlbXB0cykge1xuICAgICAgICBpZiAoIW5ld0F0dGVtcHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlID0gJHEud2hlbigpLFxuICAgICAgICAgICAgbGFzdFN1Y2Nlc3NmdWw7XG5cbiAgICAgICAgLy8gU29ydCBvZmZsaW5lIGF0dGVtcHRzIGluIERFU0Mgb3JkZXIuXG4gICAgICAgIG9mZmxpbmVBdHRlbXB0cyA9IG9mZmxpbmVBdHRlbXB0cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChhLCAxMCkgPCBwYXJzZUludChiLCAxMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpcnN0IG1vdmUgdGhlIG9mZmxpbmUgYXR0ZW1wdHMgYWZ0ZXIgdGhlIGNvbGxpc2lvbnM7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChvZmZsaW5lQXR0ZW1wdHMsIGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0ID4gbGFzdENvbGxpc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhIGNoYWluIG9mIHByb21pc2VzIGJlY2F1c2Ugd2UgbmVlZCB0byBtb3ZlIHRoZW0gaW4gb3JkZXIuXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld051bWJlciA9IGF0dGVtcHQgKyBuZXdBdHRlbXB0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmNoYW5nZUF0dGVtcHROdW1iZXIoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCBuZXdOdW1iZXIpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U3VjY2Vzc2Z1bCA9IGF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW10sXG4gICAgICAgICAgICAgICAgc3VjY2Vzc2Z1bCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBTb3J0IG5ld0F0dGVtcHRzIGluIEFTQyBvcmRlci5cbiAgICAgICAgICAgIG5ld0F0dGVtcHRzID0gbmV3QXR0ZW1wdHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGEsIDEwKSA+IHBhcnNlSW50KGIsIDEwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBOb3cgbW92ZSB0aGUgYXR0ZW1wdHMgaW4gbmV3QXR0ZW1wdHMuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobmV3QXR0ZW1wdHMsIGZ1bmN0aW9uKGF0dGVtcHQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byB1c2UgY2hhaW4gb2YgcHJvbWlzZXMuXG4gICAgICAgICAgICAgICAgdmFyIG5ld051bWJlciA9IGxhc3RPbmxpbmUgKyBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm1PZmZsaW5lLmNoYW5nZUF0dGVtcHROdW1iZXIoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCBuZXdOdW1iZXIpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NmdWwucHVzaChhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92aW5nIHRoZSBuZXcgYXR0ZW1wdHMgZmFpbGVkIChpdCBzaG91bGRuJ3QgaGFwcGVuKS4gTGV0J3MgdW5kbyB0aGUgbmV3IGF0dGVtcHRzIG1vdmUuXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc3VjY2Vzc2Z1bCwgZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TnVtYmVyID0gbGFzdE9ubGluZSArIG5ld0F0dGVtcHRzLmluZGV4T2YoYXR0ZW1wdCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RTY29ybU9mZmxpbmUuY2hhbmdlQXR0ZW1wdE51bWJlcihzaXRlSWQsIHNjb3JtSWQsIG5ld051bWJlciwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1VdGlsLmFsbFByb21pc2VzKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7IC8vIEl0IHdpbGwgbm93IGVudGVyIHRoZSAuY2F0Y2ggdGhhdCBtb3ZlcyBvZmZsaW5lIGF0dGVtcHRzIGFmdGVyIGNvbGxpc2lvbnMuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIE1vdmluZyBvZmZsaW5lIGF0dGVtcHRzIGFmdGVyIGNvbGxpc2lvbnMgZmFpbGVkIChpdCBzaG91bGRuJ3QgaGFwcGVuKS4gTGV0J3MgdW5kbyB0aGUgY2hhbmdlcy5cbiAgICAgICAgICAgIGlmICghbGFzdFN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKCk7XG5cbiAgICAgICAgICAgIHZhciBhdHRlbXB0c1RvVW5kbyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxhc3RTdWNjZXNzZnVsOyBvZmZsaW5lQXR0ZW1wdHMuaW5kZXhPZihpKSAhPSAtMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHNUb1VuZG8ucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dGVtcHRzVG9VbmRvLmZvckVhY2goZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgaXQgYmFjay5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9mZmxpbmUuY2hhbmdlQXR0ZW1wdE51bWJlcihzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQgKyBuZXdBdHRlbXB0cy5sZW5ndGgsIGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbmV3IGF0dGVtcHRzIGF0IHRoZSBlbmQgb2YgdGhlIG9mZmxpbmUgYXR0ZW1wdHMgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCAgICAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbmV3QXR0ZW1wdHMgQXR0ZW1wdHMgdG8gY3JlYXRlLiBUaGUga2V5cyBhcmUgdGhlIHRpbWVjcmVhdGVkLCB0aGUgdmFsdWVzIGFyZSB0aGUgYXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsYXN0T2ZmbGluZSBOdW1iZXIgb2YgbGFzdCBvZmZsaW5lIGF0dGVtcHQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNyZWF0aW9uIGlzIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU5ld0F0dGVtcHRzQXRFbmQoc2Nvcm1JZCwgc2l0ZUlkLCBuZXdBdHRlbXB0cywgbGFzdE9mZmxpbmUpIHtcbiAgICAgICAgdmFyIHRpbWVzID0gT2JqZWN0LmtleXMobmV3QXR0ZW1wdHMpLnNvcnQoKSwgLy8gU29ydCBpbiBBU0Mgb3JkZXIuXG4gICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGlmICghdGltZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHRpbWVzLCBmdW5jdGlvbih0aW1lLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGF0dGVtcHQgPSBuZXdBdHRlbXB0c1t0aW1lXTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtT2ZmbGluZS5jaGFuZ2VBdHRlbXB0TnVtYmVyKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgbGFzdE9mZmxpbmUgKyBpbmRleCArIDEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAkbW1VdGlsLmFsbFByb21pc2VzKHByb21pc2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYW4gcmV0cnkgYW4gYXR0ZW1wdCBzeW5jaHJvbml6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgICAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0ICAgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGFzdE9ubGluZSBMYXN0IG9ubGluZSBhdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCBpZiBjYW4gcmV0cnkgdGhlIHN5bmNocm9uaXphdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhblJldHJ5U3luYyhzY29ybUlkLCBzaXRlSWQsIGF0dGVtcHQsIGxhc3RPbmxpbmUpIHtcbiAgICAgICAgLy8gSWYgaXQncyB0aGUgbGFzdCBhdHRlbXB0IHdlIGRvbid0IG5lZWQgdG8gaWdub3JlIGNhY2hlIGJlY2F1c2Ugd2UgYWxyZWFkeSBkaWQgaXQuXG4gICAgICAgIHZhciByZWZyZXNoID0gbGFzdE9ubGluZSAhPSBhdHRlbXB0O1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldFNjb3JtVXNlckRhdGEoc2Nvcm1JZCwgYXR0ZW1wdCwgZmFsc2UsIHNpdGVJZCwgdW5kZWZpbmVkLCByZWZyZXNoKS50aGVuKGZ1bmN0aW9uKHNpdGVEYXRhKSB7XG4gICAgICAgICAgICAvLyBHZXQgc3luY2hyb25pemF0aW9uIHNuYXBzaG90IChpZiBzeW5jIGZhaWxzIGl0IHNob3VsZCBzdG9yZSBhIHNuYXBzaG90KS5cbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmdldEF0dGVtcHRTbmFwc2hvdChzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQpLnRoZW4oZnVuY3Rpb24oc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNuYXBzaG90IHx8ICFPYmplY3Qua2V5cyhzbmFwc2hvdCkubGVuZ3RoIHx8ICFzbmFwc2hvdEVxdWFscyhzbmFwc2hvdCwgc2l0ZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHNuYXBzaG90IG9yIGl0IGRvZXNuJ3QgbWF0Y2gsIHdlIGNhbid0IHJldHJ5IHRoZSBzeW5jaHJvbml6YXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgYW4gYXR0ZW1wdCdzIHNuYXBzaG90IHdpdGggdGhlIGRhdGEgcmV0cmlldmVkIGZyb20gdGhlIHNpdGUuXG4gICAgICogSXQgb25seSBjb21wYXJlcyBlbGVtZW50cyB3aXRoIGRvdCBub3RhdGlvbi4gVGhpcyBtZWFucyB0aGF0LCBpZiBzb21lIFNDTyBoYXMgYmVlbiBhZGRlZCB0byBNb29kbGUgd2ViXG4gICAgICogYnV0IHRoZSB1c2VyIGhhc24ndCBnZW5lcmF0ZWQgZGF0YSBmb3IgaXQsIHRoZW4gdGhlIHNuYXBzaG90IHdpbGwgYmUgZGV0ZWN0ZWQgYXMgZXF1YWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNuYXBzaG90IEF0dGVtcHQncyBzbmFwc2hvdC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHVzZXJEYXRhIERhdGEgcmV0cmlldmVkIGZyb20gdGhlIHNpdGUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICBUcnVlIGlmIHNuYXBzaG90IGlzIGVxdWFsIHRvIHRoZSB1c2VyIGRhdGEsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbmFwc2hvdEVxdWFscyhzbmFwc2hvdCwgdXNlckRhdGEpIHtcbiAgICAgICAgdmFyIHNjb0lkLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIHNpdGVTY28sXG4gICAgICAgICAgICBzbmFwc2hvdFNjbztcblxuICAgICAgICAvLyBDaGVjayB0aGF0IHNuYXBzaG90IGNvbnRhaW5zIHRoZSBkYXRhIGZyb20gdGhlIHNpdGUuXG4gICAgICAgIGZvciAoc2NvSWQgaW4gdXNlckRhdGEpIHtcbiAgICAgICAgICAgIHNpdGVTY28gPSB1c2VyRGF0YVtzY29JZF07XG4gICAgICAgICAgICBzbmFwc2hvdFNjbyA9IHNuYXBzaG90W3Njb0lkXTtcblxuICAgICAgICAgICAgZm9yIChlbGVtZW50IGluIHNpdGVTY28udXNlcmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNuYXBzaG90U2NvIHx8IHNpdGVTY28udXNlcmRhdGFbZWxlbWVudF0gIT09IHNuYXBzaG90U2NvLnVzZXJkYXRhW2VsZW1lbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgY2hlY2sgdGhlIG9wcG9zaXRlIHdheTogc2l0ZSB1c2VyRGF0YSBjb250YWlucyB0aGUgZGF0YSBmcm9tIHRoZSBzbmFwc2hvdC5cbiAgICAgICAgZm9yIChzY29JZCBpbiBzbmFwc2hvdCkge1xuICAgICAgICAgICAgc2l0ZVNjbyA9IHVzZXJEYXRhW3Njb0lkXTtcbiAgICAgICAgICAgIHNuYXBzaG90U2NvID0gc25hcHNob3Rbc2NvSWRdO1xuXG4gICAgICAgICAgICBmb3IgKGVsZW1lbnQgaW4gc25hcHNob3RTY28udXNlcmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNpdGVTY28gfHwgc2l0ZVNjby51c2VyZGF0YVtlbGVtZW50XSAhPT0gc25hcHNob3RTY28udXNlcmRhdGFbZWxlbWVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlJ3MgYW4gb25nb2luZyBzeW5jIGZvciBhIGNlcnRhaW4gU0NPUk0sIHdhaXQgZm9yIGl0IHRvIGVuZC5cbiAgICAgKiBJZiB0aGVyZSdzIG5vIHN5bmMgb25nb2luZyB0aGUgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHJpZ2h0IGF3YXkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtU3luYyN3YWl0Rm9yU3luY1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gdG8gY2hlY2suXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZXJlJ3Mgbm8gc3luYyBnb2luZyBvbiBmb3IgdGhlIFNDT1JNLlxuICAgICAqL1xuICAgIHNlbGYud2FpdEZvclN5bmMgPSBmdW5jdGlvbihzY29ybUlkLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgaWYgKHN5bmNQcm9taXNlc1tzaXRlSWRdICYmIHN5bmNQcm9taXNlc1tzaXRlSWRdW3Njb3JtSWRdKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIGEgc3luYyBvbmdvaW5nIGZvciB0aGlzIFNDT1JNLlxuICAgICAgICAgICAgcmV0dXJuIHN5bmNQcm9taXNlc1tzaXRlSWRdW3Njb3JtSWRdLmNhdGNoKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS53aGVuKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2Rfc3VydmV5JylcblxuLyoqXG4gKiBTdXJ2ZXkgaW5kZXggY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc3VydmV5XG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kU3VydmV5SW5kZXhDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RTdXJ2ZXlJbmRleEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tYU1vZFN1cnZleSwgJG1tVXRpbCwgJHEsICRtbUNvdXJzZSwgJHRyYW5zbGF0ZSxcbiAgICAgICAgICAgICRpb25pY1BsYXRmb3JtLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSkge1xuICAgIHZhciBtb2R1bGUgPSAkc3RhdGVQYXJhbXMubW9kdWxlIHx8IHt9LFxuICAgICAgICBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZCxcbiAgICAgICAgc3VydmV5LFxuICAgICAgICBzY3JvbGxWaWV3O1xuXG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbW9kdWxlLmRlc2NyaXB0aW9uO1xuICAgICRzY29wZS5tb2R1bGV1cmwgPSBtb2R1bGUudXJsO1xuICAgICRzY29wZS5jb3Vyc2VpZCA9IGNvdXJzZWlkO1xuICAgICRzY29wZS5hbnN3ZXJzID0ge307XG4gICAgJHNjb3BlLmlzVGFibGV0ID0gJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKTtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBzdXJ2ZXkgZGF0YS5cbiAgICBmdW5jdGlvbiBmZXRjaFN1cnZleURhdGEocmVmcmVzaCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZFN1cnZleS5nZXRTdXJ2ZXkoY291cnNlaWQsIG1vZHVsZS5pZCkudGhlbihmdW5jdGlvbihzdXJ2ZXlkYXRhKSB7XG4gICAgICAgICAgICBzdXJ2ZXkgPSBzdXJ2ZXlkYXRhO1xuXG4gICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBzdXJ2ZXkubmFtZSB8fCAkc2NvcGUudGl0bGU7XG4gICAgICAgICAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBzdXJ2ZXkuaW50cm8gfHzCoCRzY29wZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICRzY29wZS5zdXJ2ZXkgPSBzdXJ2ZXk7XG5cbiAgICAgICAgICAgIGlmICghc3VydmV5LnN1cnZleWRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hRdWVzdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKCFyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZSBjYWxsIGZhaWxlZCwgcmV0cnkgd2l0aG91dCB1c2luZyBjYWNoZSBzaW5jZSBpdCBtaWdodCBiZSBhIG5ldyBhY3Rpdml0eS5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmcmVzaEFsbERhdGEoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX3N1cnZleS5lcnJvcmdldHN1cnZleScsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgc3VydmV5IHF1ZXN0aW9ucy5cbiAgICBmdW5jdGlvbiBmZXRjaFF1ZXN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RTdXJ2ZXkuZ2V0UXVlc3Rpb25zKHN1cnZleS5pZCkudGhlbihmdW5jdGlvbihxdWVzdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU3VydmV5LmZvcm1hdFF1ZXN0aW9ucyhxdWVzdGlvbnMpLnRoZW4oZnVuY3Rpb24oZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnF1ZXN0aW9ucyA9IGZvcm1hdHRlZDtcblxuICAgICAgICAgICAgICAgIC8vIEluaXQgYW5zd2VycyBvYmplY3QuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZvcm1hdHRlZCwgZnVuY3Rpb24ocSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNUZXh0QXJlYSA9IHEubXVsdGkgJiYgcS5tdWx0aS5sZW5ndGggPT09IDAgJiYgcS50eXBlID09PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFuc3dlcnNbcS5uYW1lXSA9IHEucmVxdWlyZWQgPyAtMSA6IChpc1RleHRBcmVhID8gJycgOiAnMCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gcmVmcmVzaCBhbGwgdGhlIGRhdGEuXG4gICAgZnVuY3Rpb24gcmVmcmVzaEFsbERhdGEoKSB7XG4gICAgICAgIHZhciBwMSA9ICRtbWFNb2RTdXJ2ZXkuaW52YWxpZGF0ZVN1cnZleURhdGEoY291cnNlaWQpLFxuICAgICAgICAgICAgcDIgPSBzdXJ2ZXkgPyAkbW1hTW9kU3VydmV5LmludmFsaWRhdGVRdWVzdGlvbnMoc3VydmV5LmlkKSA6ICRxLndoZW4oKTtcblxuICAgICAgICByZXR1cm4gJHEuYWxsKFtwMSwgcDJdKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoU3VydmV5RGF0YSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmV0Y2hTdXJ2ZXlEYXRhKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYU1vZFN1cnZleS5sb2dWaWV3KHN1cnZleS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbUNvdXJzZS5jaGVja01vZHVsZUNvbXBsZXRpb24oY291cnNlaWQsIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLnN1cnZleUxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBDaGVjayBpZiBhbnN3ZXJzIGFyZSB2YWxpZCB0byBiZSBzdWJtaXR0ZWQuXG4gICAgJHNjb3BlLmlzVmFsaWRSZXNwb25zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsaWQgPSB0cnVlO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLmFuc3dlcnMsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIGlmIChhID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfTtcblxuICAgIC8vIFNhdmUgb3B0aW9ucyBzZWxlY3RlZC5cbiAgICAkc2NvcGUuc3VibWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbVV0aWwuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSgnbW0uY29yZS5hcmV5b3VzdXJlJykpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYW5zd2VycyA9IFtdLFxuICAgICAgICAgICAgICAgIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbS5jb3JlLnNlbmRpbmcnLCB0cnVlKTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5hbnN3ZXJzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgYW5zd2Vycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICRtbWFNb2RTdXJ2ZXkuc3VibWl0QW5zd2VycyhzdXJ2ZXkuaWQsIGFuc3dlcnMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFZpZXcgPSAkaW9uaWNTY3JvbGxEZWxlZ2F0ZS4kZ2V0QnlIYW5kbGUoJ21tYU1vZFN1cnZleVNjcm9sbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY3JvbGxWaWV3ICYmIHNjcm9sbFZpZXcuc2Nyb2xsVG9wICYmIHNjcm9sbFZpZXcuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZnJlc2hBbGxEYXRhKCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX3N1cnZleS5jYW5ub3RzdWJtaXRzdXJ2ZXknLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gUHVsbCB0byByZWZyZXNoLlxuICAgICRzY29wZS5yZWZyZXNoU3VydmV5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZnJlc2hBbGxEYXRhKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9zdXJ2ZXknKVxuXG4vKipcbiAqIE1vZCBzdXJ2ZXkgaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3N1cnZleVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RTdXJ2ZXlIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZFN1cnZleUhhbmRsZXJzJywgZnVuY3Rpb24oJG1tQ291cnNlLCAkbW1hTW9kU3VydmV5LCAkc3RhdGUsICRxLCAkbW1Db250ZW50TGlua3NIZWxwZXIpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zdXJ2ZXlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFN1cnZleUhhbmRsZXJzI2NvdXJzZUNvbnRlbnRcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU3VydmV5LmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBpbmZvLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYygnc3VydmV5Jyk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1vZF9zdXJ2ZXknLCB7bW9kdWxlOiBtb2R1bGUsIGNvdXJzZWlkOiBjb3Vyc2VpZH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc3VydmV5XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTdXJ2ZXlIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU3VydmV5LmlzUGx1Z2luRW5hYmxlZChzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb3Vyc2VJZCB8fCAkbW1Db3Vyc2UuY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkKHNpdGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSBzdXJ2ZXkgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL3N1cnZleS92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9zdXJ2ZXknKVxuXG4vKipcbiAqIFN1cnZleSBzZXJ2aWNlLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zdXJ2ZXlcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kU3VydmV5XG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kU3VydmV5JywgZnVuY3Rpb24oJHEsICRtbVNpdGUsICR0cmFuc2xhdGUsICRtbVNpdGVzTWFuYWdlcikge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBhIHN0cmluZyB3aXRoIHZhbHVlcyBzZXBhcmF0ZWQgYnkgY29tbWFzIGludG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tbWFTdHJpbmdUb0FycmF5KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGEgcXVlc3Rpb25zIGxpc3QsIHR1cm5pbmcgXCJtdWx0aVwiIGFuZCBcIm9wdGlvbnNcIiBzdHJpbmdzIGludG8gYXJyYXlzIGFuZCBhZGRpbmcgdGhlIHByb3BlcnRpZXNcbiAgICAgKiAnbnVtJyBhbmQgJ25hbWUnLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3N1cnZleVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU3VydmV5I2Zvcm1hdFF1ZXN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHF1ZXN0aW9ucyBRdWVzdGlvbnMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZm9ybWF0dGVkIHF1ZXN0aW9ucy5cbiAgICAgKi9cbiAgICBzZWxmLmZvcm1hdFF1ZXN0aW9ucyA9IGZ1bmN0aW9uKHF1ZXN0aW9ucykge1xuICAgICAgICB2YXIgc3RyaW5na2V5cyA9IFtcbiAgICAgICAgICAgICdtbWEubW9kX3N1cnZleS5pcHJlZmVydGhhdCcsXG4gICAgICAgICAgICAnbW1hLm1vZF9zdXJ2ZXkuaWZvdW5kdGhhdCcsXG4gICAgICAgICAgICAnbW0uY29yZS5jaG9vc2UnXG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUoc3RyaW5na2V5cykudGhlbihmdW5jdGlvbih0cmFuc2xhdGVzKSB7XG4gICAgICAgICAgICB2YXIgc3RyaXByZWZlcnRoYXQgPSB0cmFuc2xhdGVzW3N0cmluZ2tleXNbMF1dLFxuICAgICAgICAgICAgICAgIHN0cmlmb3VuZHRoYXQgPSB0cmFuc2xhdGVzW3N0cmluZ2tleXNbMV1dLFxuICAgICAgICAgICAgICAgIHN0cmNob29zZSA9IHRyYW5zbGF0ZXNbc3RyaW5na2V5c1syXV0sXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkID0gW10sXG4gICAgICAgICAgICAgICAgcGFyZW50cyA9IHNlbGYuZ2V0UGFyZW50UXVlc3Rpb25zKHF1ZXN0aW9ucyksXG4gICAgICAgICAgICAgICAgbnVtID0gMTtcblxuICAgICAgICAgICAgcXVlc3Rpb25zID0gYW5ndWxhci5jb3B5KHF1ZXN0aW9ucyk7IC8vIENvcHkgdGhlIGFycmF5IHRvIHByZXZlbnQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHF1ZXN0aW9ucywgZnVuY3Rpb24ocXVlc3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1txdWVzdGlvbi5wYXJlbnRdO1xuXG4gICAgICAgICAgICAgICAgLy8gVHVybiBtdWx0aSBhbmQgb3B0aW9ucyBpbnRvIGFycmF5cy5cbiAgICAgICAgICAgICAgICBxdWVzdGlvbi5tdWx0aSA9IGNvbW1hU3RyaW5nVG9BcnJheShxdWVzdGlvbi5tdWx0aSk7XG4gICAgICAgICAgICAgICAgcXVlc3Rpb24ub3B0aW9ucyA9IGNvbW1hU3RyaW5nVG9BcnJheShxdWVzdGlvbi5vcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBhIHN1Yi1xdWVzdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgcXVlc3Rpb24ucmVxdWlyZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gMSB8fMKgcGFyZW50LnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9uZSBhbnN3ZXIgcXVlc3Rpb24uIFNldCBpdHMgbmFtZSBhbmQgYWRkIGl0IHRvIHRoZSByZXR1cm5lZCBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXN0aW9uLm5hbWUgPSAncScgKyAocGFyZW50LnR5cGUgPT0gMiA/ICdQJyA6ICcnKSArIHF1ZXN0aW9uLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlc3Rpb24ubnVtID0gbnVtKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUd28gYW5zd2VycyBwZXIgcXVlc3Rpb24gKENPTExFUyBQJkEpLiBXZSdsbCBhZGQgdHdvIHF1ZXN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxMiA9IGFuZ3VsYXIuY29weShxdWVzdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXN0aW9uLnRleHQgPSBzdHJpcHJlZmVydGhhdCArICcgJyArIHF1ZXN0aW9uLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVzdGlvbi5uYW1lID0gJ3FQJyArIHF1ZXN0aW9uLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlc3Rpb24ubnVtID0gbnVtKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWQucHVzaChxdWVzdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHEyLnRleHQgPSBzdHJpZm91bmR0aGF0ICsgJyAnICsgcTIudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEyLm5hbWUgPSAncScgKyBxdWVzdGlvbi5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEyLm51bSA9IG51bSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkLnB1c2gocTIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXN0aW9uLm11bHRpICYmIHF1ZXN0aW9uLm11bHRpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIGEgc2luZ2xlIHF1ZXN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBxdWVzdGlvbi5uYW1lID0gJ3EnICsgcXVlc3Rpb24uaWQ7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXN0aW9uLm51bSA9IG51bSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVlc3Rpb24udHlwZSA+IDApIHsgLy8gQWRkIFwiY2hvb3NlXCIgb3B0aW9uIHNpbmNlIHRoaXMgcXVlc3Rpb24gaXMgbm90IHJlcXVpcmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlc3Rpb24ub3B0aW9ucy51bnNoaWZ0KHN0cmNob29zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQucHVzaChxdWVzdGlvbik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCBxdWVzdGlvbnMgYW5kIHB1dHMgdGhlbSBpbiBhbiBvYmplY3Q6IElEIC0+IHF1ZXN0aW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3N1cnZleVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU3VydmV5I2dldFBhcmVudFF1ZXN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHF1ZXN0aW9ucyBRdWVzdGlvbnMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgIE9iamVjdCB3aXRoIHBhcmVudCBxdWVzdGlvbnMuXG4gICAgICovXG4gICAgc2VsZi5nZXRQYXJlbnRRdWVzdGlvbnMgPSBmdW5jdGlvbihxdWVzdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhcmVudHMgPSB7fTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2gocXVlc3Rpb25zLCBmdW5jdGlvbihxdWVzdGlvbikge1xuICAgICAgICAgICAgaWYgKHF1ZXN0aW9uLnBhcmVudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBhcmVudHNbcXVlc3Rpb24uaWRdID0gcXVlc3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdXJ2ZXkncyBxdWVzdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc3VydmV5XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTdXJ2ZXkjZ2V0UXVlc3Rpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFN1cnZleSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBxdWVzdGlvbnMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFF1ZXN0aW9ucyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgc3VydmV5aWQ6IGlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0UXVlc3Rpb25zQ2FjaGVLZXkoaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9zdXJ2ZXlfZ2V0X3F1ZXN0aW9ucycsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnF1ZXN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5xdWVzdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBzdXJ2ZXkgcXVlc3Rpb25zIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFN1cnZleSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFF1ZXN0aW9uc0NhY2hlS2V5KGlkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kU3VydmV5OnF1ZXN0aW9uczonICsgaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3VydmV5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3N1cnZleVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU3VydmV5I2dldFN1cnZleVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNtaWQgICAgIENvdXJzZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgc3VydmV5IGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFN1cnZleSA9IGZ1bmN0aW9uKGNvdXJzZWlkLCBjbWlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY291cnNlaWRzOiBbY291cnNlaWRdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0U3VydmV5RGF0YUNhY2hlS2V5KGNvdXJzZWlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2Rfc3VydmV5X2dldF9zdXJ2ZXlzX2J5X2NvdXJzZXMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdXJ2ZXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTdXJ2ZXk7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc3BvbnNlLnN1cnZleXMsIGZ1bmN0aW9uKHN1cnZleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VydmV5LmNvdXJzZW1vZHVsZSA9PSBjbWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3VydmV5ID0gc3VydmV5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdXJ2ZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTdXJ2ZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3Igc3VydmV5IGRhdGEgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U3VydmV5RGF0YUNhY2hlS2V5KGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kU3VydmV5OnN1cnZleTonICsgY291cnNlaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgc3VydmV5IHF1ZXN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zdXJ2ZXlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFN1cnZleSNpbnZhbGlkYXRlUXVlc3Rpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFN1cnZleSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZVF1ZXN0aW9ucyA9IGZ1bmN0aW9uKGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldFF1ZXN0aW9uc0NhY2hlS2V5KGNvdXJzZWlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHN1cnZleSBkYXRhLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3N1cnZleVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU3VydmV5I2ludmFsaWRhdGVTdXJ2ZXlEYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZVN1cnZleURhdGEgPSBmdW5jdGlvbihjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRTdXJ2ZXlEYXRhQ2FjaGVLZXkoY291cnNlaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaXMgZW5hYmxlZCBpbiBhIGNlcnRhaW4gc2l0ZS4gUGx1Z2luIGlzIGVuYWJsZWQgaWYgdGhlIHN1cnZleSBXUyBhcmUgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3N1cnZleVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU3VydmV5I2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIHBsdWdpbiBpcyBlbmFibGVkLCByZWplY3RlZCBvciByZXNvbHZlZCB3aXRoIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICBzaXRlLndzQXZhaWxhYmxlKCdtb2Rfc3VydmV5X2dldF9xdWVzdGlvbnMnKSAmJlxuICAgICAgICAgICAgICAgICAgICBzaXRlLndzQXZhaWxhYmxlKCdtb2Rfc3VydmV5X2dldF9zdXJ2ZXlzX2J5X2NvdXJzZXMnKSAmJlxuICAgICAgICAgICAgICAgICAgICBzaXRlLndzQXZhaWxhYmxlKCdtb2Rfc3VydmV5X3N1Ym1pdF9hbnN3ZXJzJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgdGhlIHN1cnZleSBhcyBiZWluZyB2aWV3ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc3VydmV5XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTdXJ2ZXkjbG9nVmlld1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBTdXJ2ZXkgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgY2FsbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHNlbGYubG9nVmlldyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBzdXJ2ZXlpZDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX3N1cnZleV92aWV3X3N1cnZleScsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIHN1cnZleSBhbnN3ZXJzIHRvIE1vb2RsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zdXJ2ZXlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFN1cnZleSNzdWJtaXRBbnN3ZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN1cnZleWlkICB1cnZleSBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBhbnN3ZXJzIEFuc3dlcnMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYW5zd2VycyBhcmUgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZC5cbiAgICAgKi9cbiAgICBzZWxmLnN1Ym1pdEFuc3dlcnMgPSBmdW5jdGlvbihzdXJ2ZXlpZCwgYW5zd2Vycykge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgc3VydmV5aWQ6IHN1cnZleWlkLFxuICAgICAgICAgICAgYW5zd2VyczogYW5zd2Vyc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX3N1cnZleV9zdWJtaXRfYW5zd2VycycsIHBhcmFtcykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3VybCcpXG5cbi8qKlxuICogVVJMIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3VybFxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZFVybEluZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kVXJsSW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbWFNb2RVcmwsICRtbUNvdXJzZSkge1xuICAgIHZhciBtb2R1bGUgPSAkc3RhdGVQYXJhbXMubW9kdWxlIHx8IHt9LFxuICAgICAgICBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZDtcbiAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBtb2R1bGUuZGVzY3JpcHRpb247XG4gICAgJHNjb3BlLnVybCA9IChtb2R1bGUuY29udGVudHMgJiYgbW9kdWxlLmNvbnRlbnRzWzBdICYmIG1vZHVsZS5jb250ZW50c1swXS5maWxldXJsKSA/IG1vZHVsZS5jb250ZW50c1swXS5maWxldXJsIDogdW5kZWZpbmVkO1xuXG4gICAgJHNjb3BlLmdvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNb2RVcmwubG9nVmlldyhtb2R1bGUuaW5zdGFuY2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgICAgICAkbW1hTW9kVXJsLm9wZW4oJHNjb3BlLnVybCk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3VybCcpXG5cbi8qKlxuICogTW9kIFVSTCBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfdXJsXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZFVybEhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kVXJsSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbWFNb2RVcmwsICRzdGF0ZSwgJG1tVXRpbCwgJG1tQ29udGVudExpbmtzSGVscGVyLCAkcSkge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvdXJzZSBjb250ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfdXJsXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RVcmxIYW5kbGVycyNjb3Vyc2VDb250ZW50SGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYuY291cnNlQ29udGVudEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgaW5mby5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIFRoZSBjb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ3VybCcpO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2RfdXJsJywge21vZHVsZTogbW9kdWxlLCBjb3Vyc2VpZDogY291cnNlaWR9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5jb250ZW50cyAmJiBtb2R1bGUuY29udGVudHNbMF0gJiYgbW9kdWxlLmNvbnRlbnRzWzBdLmZpbGV1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJ1dHRvbnMgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1saW5rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnbW0uY29yZS5vcGVuaW5icm93c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFVybC5sb2dWaWV3KG1vZHVsZS5pbnN0YW5jZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RVcmwub3Blbihtb2R1bGUuY29udGVudHNbMF0uZmlsZXVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF91cmxcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFVybEhhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICBTaXRlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoc2l0ZUlkLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgaWYgKGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4odHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJG1tQ291cnNlLmNhbkdldE1vZHVsZVdpdGhvdXRDb3Vyc2VJZChzaXRlSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhY3Rpb25zIHRvIHBlcmZvcm0gd2l0aCB0aGUgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhIG1vZF91cmwgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL3VybC92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF91cmwnKVxuXG4vKipcbiAqIFVSTCBzZXJ2aWNlLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF91cmxcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kVXJsXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kVXJsJywgZnVuY3Rpb24oJG1tU2l0ZSwgJG1tVXRpbCwgJHEpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IGEgVVJMIGFzIGJlaW5nIHZpZXdlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF91cmxcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFVybCNsb2dWaWV3XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIE1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sb2dWaWV3ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVybGlkOiBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfdXJsX3ZpZXdfdXJsJywgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgVVJMLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3VybFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kVXJsI29wZW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gZ28gdG8uXG4gICAgICovXG4gICAgc2VsZi5vcGVuID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICRtbVV0aWwub3BlbkluQnJvd3Nlcih1cmwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubm90ZXMnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIG5vdGVzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGVzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTm90ZXNMaXN0Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTm90ZXNMaXN0Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1VdGlsLCAkbW1hTm90ZXMsICRtbVNpdGUsICR0cmFuc2xhdGUpIHtcblxuICAgIHZhciBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZCxcbiAgICAgICAgdHlwZSA9ICRzdGF0ZVBhcmFtcy50eXBlO1xuXG4gICAgJHNjb3BlLmNvdXJzZWlkID0gY291cnNlaWQ7XG4gICAgJHNjb3BlLnR5cGUgPSB0eXBlO1xuXG4gICAgJHRyYW5zbGF0ZSgnbW1hLm5vdGVzLicgKyB0eXBlICsgJ25vdGVzJykudGhlbihmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgJHNjb3BlLnRpdGxlID0gc3RyaW5nO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZmV0Y2hOb3RlcyhyZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTm90ZXMuZ2V0Tm90ZXMoY291cnNlaWQsIHJlZnJlc2gpLnRoZW4oZnVuY3Rpb24obm90ZXMpIHtcbiAgICAgICAgICAgIG5vdGVzID0gbm90ZXNbdHlwZSArICdub3RlcyddO1xuXG4gICAgICAgICAgICByZXR1cm4gJG1tYU5vdGVzLmdldE5vdGVzVXNlckRhdGEobm90ZXMsIGNvdXJzZWlkKS50aGVuKGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm5vdGVzID0gbm90ZXM7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmZXRjaE5vdGVzKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQWRkIGxvZyBpbiBNb29kbGUuXG4gICAgICAgICRtbVNpdGUud3JpdGUoJ2NvcmVfbm90ZXNfdmlld19ub3RlcycsIHtcbiAgICAgICAgICAgIGNvdXJzZWlkOiBjb3Vyc2VpZCxcbiAgICAgICAgICAgIHVzZXJpZDogMFxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUubm90ZXNMb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLnJlZnJlc2hOb3RlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmZXRjaE5vdGVzKHRydWUpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5ub3RlcycpXG5cbi8qKlxuICogTm90ZSB0eXBlcyB2aWV3IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubm90ZXNcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFOb3Rlc1R5cGVzQ3RybFxuICovXG4uY29udHJvbGxlcignbW1hTm90ZXNUeXBlc0N0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcykge1xuICAgIHZhciBjb3Vyc2UgPSAkc3RhdGVQYXJhbXMuY291cnNlLFxuICAgICAgICBjb3Vyc2VpZCA9IGNvdXJzZS5pZDtcbiAgICAkc2NvcGUuY291cnNlaWQgPSBjb3Vyc2VpZDtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubm90ZXMnKVxuXG4vKipcbiAqIE5vdGVzIGhhbmRsZXJzIGZhY3RvcnkuXG4gKlxuICogVGhpcyBmYWN0b3J5IGhvbGRzIHRoZSBkaWZmZXJlbnQgaGFuZGxlcnMgdXNlZCBmb3IgZGVsZWdhdGVzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGVzXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU5vdGVzSGFuZGxlcnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFOb3Rlc0hhbmRsZXJzJywgZnVuY3Rpb24oJG1tYU5vdGVzLCAkbW1TaXRlLCAkbW1BcHAsICRpb25pY01vZGFsLCAkbW1VdGlsLCBtbUNvdXJzZXNBY2Nlc3NNZXRob2RzKSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbm90ZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubm90ZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU5vdGVzSGFuZGxlcnMjYWRkTm90ZVxuICAgICAqL1xuICAgIHNlbGYuYWRkTm90ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU5vdGVzLmlzUGx1Z2luQWRkTm90ZUVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkIGZvciB0aGlzIHVzZXIgaW4gdGhpcyBjb250ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlciAgICAgVXNlciB0byBjaGVjay5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZEZvclVzZXIgPSBmdW5jdGlvbih1c2VyLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQWN0aXZlIGNvdXJzZSByZXF1aXJlZC5cbiAgICAgICAgICAgIHJldHVybiBjb3Vyc2VJZCAmJiB1c2VyLmlkICE9ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXIgICAgIENvdXJzZSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIENvbnRyb2xsZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbih1c2VyLCBjb3Vyc2VpZCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZCBub3RlIGhhbmRsZXIgY29udHJvbGxlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3Rlc1xuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFOb3Rlc0hhbmRsZXJzI2FkZE5vdGU6Y29udHJvbGxlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBCdXR0b24gdGl0bGUuXG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5ub3Rlcy5hZGRuZXdub3RlJztcblxuICAgICAgICAgICAgICAgICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgnYWRkb25zL25vdGVzL3RlbXBsYXRlcy9hZGQuaHRtbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICRzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiAnc2xpZGUtaW4tdXAnXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5tb2RhbCA9IG07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VNb2RhbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5tb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5hZGROb3RlID0gZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgICAgICAkbW1BcHAuY2xvc2VLZXlib2FyZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2FkaW5nTW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tLmNvcmUuc2VuZGluZycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGcmVlemUgdGhlIGFkZCBub3RlIGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICRtbWFOb3Rlcy5hZGROb3RlKHVzZXIuaWQsIGNvdXJzZWlkLCAkc2NvcGUubm90ZS5wdWJsaXNoc3RhdGUsICRzY29wZS5ub3RlLnRleHQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dNb2RhbCgnbW0uY29yZS5zdWNjZXNzJywgJ21tYS5ub3Rlcy5ldmVudG5vdGVjcmVhdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VNb2RhbCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUucHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZ01vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUubm90ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hzdGF0ZTogJ3BlcnNvbmFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5wcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm1vZGFsLnNob3coKTtcblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvdXJzZSBuYXYgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3Rlc0hhbmRsZXJzI2NvdXJzZXNOYXZcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZXNOYXYgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFOb3Rlcy5pc1BsdWdpblZpZXdOb3Rlc0VuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkIGZvciB0aGlzIGNvdXJzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkICAgQ291cnNlIElELlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjZXNzRGF0YSBUeXBlIG9mIGFjY2VzcyB0byB0aGUgY291cnNlOiBkZWZhdWx0LCBndWVzdCwgLi4uXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZEZvckNvdXJzZSA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBhY2Nlc3NEYXRhKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXNzRGF0YSAmJiBhY2Nlc3NEYXRhLnR5cGUgPT0gbW1Db3Vyc2VzQWNjZXNzTWV0aG9kcy5ndWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm90IGVuYWJsZWQgZm9yIGd1ZXN0cy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBDb250cm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24oY291cnNlSWQpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb3Vyc2VzIG5hdiBoYW5kbGVyIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMubm90ZXNcbiAgICAgICAgICAgICAqIEBuZ2RvYyBjb250cm9sbGVyXG4gICAgICAgICAgICAgKiBAbmFtZSAkbW1hTm90ZXNIYW5kbGVycyNjb3Vyc2VzTmF2OmNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAnaW9uLWlvcy1saXN0JztcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLm5vdGVzLm5vdGVzJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oJGV2ZW50LCBjb3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm5vdGVzLXR5cGVzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291cnNlOiBjb3Vyc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5ub3RlcycpXG5cbi8qKlxuICogTm90ZXMgZmFjdG9yeS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3Rlc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFOb3Rlc1xuICovXG4uZmFjdG9yeSgnJG1tYU5vdGVzJywgZnVuY3Rpb24oJG1tU2l0ZSwgJGxvZywgJHEsICRtbVVzZXIsICR0cmFuc2xhdGUpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU5vdGVzJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbm90ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3RlcyNhZGROb3RlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJJZCAgICAgICBVc2VyIElEIG9mIHRoZSBwZXJzb24gdG8gYWRkIHRoZSBub3RlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCAgICAgQ291cnNlIElEIHdoZXJlIHRoZSBub3RlIGJlbG9uZ3MuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHB1Ymxpc2hTdGF0ZSBQZXJzb25hbCwgU2l0ZSBvciBDb3Vyc2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5vdGVUZXh0ICAgICBUaGUgbm90ZSB0ZXh0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5hZGROb3RlID0gZnVuY3Rpb24odXNlcklkLCBjb3Vyc2VJZCwgcHVibGlzaFN0YXRlLCBub3RlVGV4dCkge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIFwibm90ZXNbMF1bdXNlcmlkXVwiIDogdXNlcklkLFxuICAgICAgICAgICAgXCJub3Rlc1swXVtwdWJsaXNoc3RhdGVdXCI6IHB1Ymxpc2hTdGF0ZSxcbiAgICAgICAgICAgIFwibm90ZXNbMF1bY291cnNlaWRdXCI6IGNvdXJzZUlkLFxuICAgICAgICAgICAgXCJub3Rlc1swXVt0ZXh0XVwiOiBub3RlVGV4dCxcbiAgICAgICAgICAgIFwibm90ZXNbMF1bZm9ybWF0XVwiOiAxXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdjb3JlX25vdGVzX2NyZWF0ZV9ub3RlcycsIGRhdGEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBhZGQgbm90ZSBwbHVnaW4gaXMgZW5hYmxlZCBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBxdWl0ZSBvZnRlbiBhbmQgdGh1cyBzaG91bGQgb25seSBwZXJmb3JtIGEgcXVpY2tcbiAgICAgKiBjaGVjaywgd2Ugc2hvdWxkIG5vdCBiZSBjYWxsaW5nIFdTIGZyb20gaGVyZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3RlcyNpc1BsdWdpbkFkZE5vdGVFbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luQWRkTm90ZUVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGluZm9zO1xuXG4gICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghJG1tU2l0ZS5jYW5Vc2VBZHZhbmNlZEZlYXR1cmUoJ2VuYWJsZW5vdGVzJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghJG1tU2l0ZS53c0F2YWlsYWJsZSgnY29yZV9ub3Rlc19jcmVhdGVfbm90ZXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlYWQgbm90ZXMgcGx1Z2luIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgcXVpdGUgb2Z0ZW4gYW5kIHRodXMgc2hvdWxkIG9ubHkgcGVyZm9ybSBhIHF1aWNrXG4gICAgICogY2hlY2ssIHdlIHNob3VsZCBub3QgYmUgY2FsbGluZyBXUyBmcm9tIGhlcmUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3Rlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTm90ZXMjaXNQbHVnaW5WaWV3Tm90ZXNFbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luVmlld05vdGVzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5mb3M7XG5cbiAgICAgICAgaWYgKCEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCEkbW1TaXRlLmNhblVzZUFkdmFuY2VkRmVhdHVyZSgnZW5hYmxlbm90ZXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCEkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX25vdGVzX2dldF9jb3Vyc2Vfbm90ZXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VycyBub3RlcyBmb3IgYSBjZXJ0YWluIHNpdGUsIGNvdXJzZSBhbmQgcGVyc29uYWwgbm90ZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3Rlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTm90ZXMjZ2V0Tm90ZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgSUQgb2YgdGhlIGNvdXJzZSB0byBnZXQgdGhlIG5vdGVzIGZyb20uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZWZyZXNoIFRydWUgd2hlbiB3ZSBzaG91bGQgbm90IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgbm90ZXMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldE5vdGVzID0gZnVuY3Rpb24oY291cnNlaWQsIHJlZnJlc2gpIHtcblxuICAgICAgICAkbG9nLmRlYnVnKCdHZXQgbm90ZXMgZm9yIGNvdXJzZSAnICsgY291cnNlaWQpO1xuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkIDogY291cnNlaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVzZXRzID0ge307XG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICBwcmVzZXRzLmdldEZyb21DYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnY29yZV9ub3Rlc19nZXRfY291cnNlX25vdGVzJywgZGF0YSwgcHJlc2V0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGRhdGEgZm9yIG5vdGVzIHNpbmNlIHRoZXkgb25seSBoYXZlIHVzZXJpZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3RlcyNnZXROb3Rlc1VzZXJEYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gbm90ZXMgICAgICAgTm90ZXMgdG8gZ2V0IHRoZSBkYXRhIGZvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBjb3Vyc2VpZCAgICBJRCBvZiB0aGUgY291cnNlIHRoZSBub3RlcyBiZWxvbmcgdG8uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgUHJvbWlzZSBhbHdheXMgcmVzb2x2ZWQuIFJlc29sdmUgcGFyYW0gaXMgdGhlIGZvcm1hdHRlZCBub3Rlcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldE5vdGVzVXNlckRhdGEgPSBmdW5jdGlvbihub3RlcywgY291cnNlaWQpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG5vdGVzLCBmdW5jdGlvbihub3RlKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICRtbVVzZXIuZ2V0UHJvZmlsZShub3RlLnVzZXJpZCwgY291cnNlaWQsIHRydWUpLnRoZW4oZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgICAgIG5vdGUudXNlcmZ1bGxuYW1lID0gdXNlci5mdWxsbmFtZTtcbiAgICAgICAgICAgICAgICBub3RlLnVzZXJwcm9maWxlaW1hZ2V1cmwgPSB1c2VyLnByb2ZpbGVpbWFnZXVybDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIGdldHRpbmcgcHJvZmlsZS4gU2V0IGRlZmF1bHQgZGF0YS5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZSgnbW1hLm5vdGVzLnVzZXJ3aXRoaWQnLCB7aWQ6IG5vdGUudXNlcmlkfSkudGhlbihmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZS51c2VyZnVsbG5hbWUgPSBzdHI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vdGVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm5vdGlmaWNhdGlvbnMnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIG5vdGlmaWNhdGlvbiBsaXN0LlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGlmaWNhdGlvbnNcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFOb3RpZmljYXRpb25zTGlzdEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU5vdGlmaWNhdGlvbnNMaXN0Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJG1tVXRpbCwgJG1tYU5vdGlmaWNhdGlvbnMsIG1tYU5vdGlmaWNhdGlvbnNMaXN0TGltaXQpIHtcblxuICAgIHZhciByZWFkQ291bnQgPSAwLFxuICAgICAgICB1bnJlYWRDb3VudCA9IDA7XG5cbiAgICAkc2NvcGUubm90aWZpY2F0aW9ucyA9IFtdO1xuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IG5vdGlmaWNhdGlvbnMuIEdldCB1bnJlYWQgbm90aWZpY2F0aW9ucyBmaXJzdC5cbiAgICBmdW5jdGlvbiBmZXRjaE5vdGlmaWNhdGlvbnMocmVmcmVzaCkge1xuXG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICByZWFkQ291bnQgPSAwO1xuICAgICAgICAgICAgdW5yZWFkQ291bnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbWFOb3RpZmljYXRpb25zLmdldFVucmVhZE5vdGlmaWNhdGlvbnModW5yZWFkQ291bnQswqBtbWFOb3RpZmljYXRpb25zTGlzdExpbWl0KS50aGVuKGZ1bmN0aW9uKHVucmVhZCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHRoZSB1bnJlYWQgbm90aWZpY2F0aW9ucyB0byAkc2NvcGUubm90aWZpY2F0aW9ucyB5ZXQuIElmIHRoZXJlIGFyZSBubyB1bnJlYWQgbm90aWZpY2F0aW9uc1xuICAgICAgICAgICAgLy8gdGhhdCBjYXVzZXMgdGhhdCB0aGUgXCJUaGVyZSBhcmUgbm8gbm90aWZpY2F0aW9uc1wiIG1lc3NhZ2UgaXMgc2hvd24gaW4gcHVsbCB0byByZWZyZXNoLlxuICAgICAgICAgICAgdW5yZWFkQ291bnQgKz0gdW5yZWFkLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHVucmVhZC5sZW5ndGggPCBtbWFOb3RpZmljYXRpb25zTGlzdExpbWl0KSB7XG4gICAgICAgICAgICAgICAgLy8gTGltaXQgbm90IHJlYWNoZWQuIEdldCByZWFkIG5vdGlmaWNhdGlvbnMgdW50aWwgcmVhY2ggdGhlIGxpbWl0LlxuICAgICAgICAgICAgICAgIHZhciByZWFkTGltaXQgPcKgbW1hTm90aWZpY2F0aW9uc0xpc3RMaW1pdCAtIHVucmVhZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbWFOb3RpZmljYXRpb25zLmdldFJlYWROb3RpZmljYXRpb25zKHJlYWRDb3VudCwgcmVhZExpbWl0KS50aGVuKGZ1bmN0aW9uKHJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZENvdW50ICs9IHJlYWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm5vdGlmaWNhdGlvbnMgPSB1bnJlYWQuY29uY2F0KHJlYWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm5vdGlmaWNhdGlvbnMgPSAkc2NvcGUubm90aWZpY2F0aW9ucy5jb25jYXQodW5yZWFkKS5jb25jYXQocmVhZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNhbkxvYWRNb3JlID0gcmVhZC5sZW5ndGggPj0gcmVhZExpbWl0O1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bnJlYWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubm90aWZpY2F0aW9ucy5lcnJvcmdldG5vdGlmaWNhdGlvbnMnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IGZhbHNlOyAvLyBTZXQgdG8gZmFsc2UgdG8gcHJldmVudCBpbmZpbml0ZSBjYWxscyB3aXRoIGluZmluaXRlLWxvYWRpbmcuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm5vdGlmaWNhdGlvbnMgPSB1bnJlYWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm5vdGlmaWNhdGlvbnMgPSAkc2NvcGUubm90aWZpY2F0aW9ucy5jb25jYXQodW5yZWFkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNhbkxvYWRNb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubm90aWZpY2F0aW9ucy5lcnJvcmdldG5vdGlmaWNhdGlvbnMnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IGZhbHNlOyAvLyBTZXQgdG8gZmFsc2UgdG8gcHJldmVudCBpbmZpbml0ZSBjYWxscyB3aXRoIGluZmluaXRlLWxvYWRpbmcuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaE5vdGlmaWNhdGlvbnMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUubm90aWZpY2F0aW9uc0xvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUucmVmcmVzaE5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYU5vdGlmaWNhdGlvbnMuaW52YWxpZGF0ZU5vdGlmaWNhdGlvbnNMaXN0KCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZldGNoTm90aWZpY2F0aW9ucyh0cnVlKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5sb2FkTW9yZU5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgICAgICBmZXRjaE5vdGlmaWNhdGlvbnMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5pbmZpbml0ZVNjcm9sbENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm5vdGlmaWNhdGlvbnMnKVxuXG4vKipcbiAqIE5vdGlmaWNhdGlvbiBhY3Rpb24gZGlyZWN0aXZlLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGlmaWNhdGlvbnNcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tYU5vdGlmaWNhdGlvbnNBY3Rpb25zXG4gKi9cbi5kaXJlY3RpdmUoJ21tYU5vdGlmaWNhdGlvbnNBY3Rpb25zJywgZnVuY3Rpb24oJGxvZywgJG1tQ29udGVudExpbmtzRGVsZWdhdGUpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1hTm90aWZpY2F0aW9uc0FjdGlvbnMnKTtcblxuICAgIC8vIERpcmVjdGl2ZSBsaW5rIGZ1bmN0aW9uLlxuICAgIGZ1bmN0aW9uIGxpbmsoc2NvcGUpIHtcbiAgICAgICAgaWYgKHNjb3BlLmNvbnRleHR1cmwpIHtcbiAgICAgICAgICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlLmdldEFjdGlvbnNGb3Ioc2NvcGUuY29udGV4dHVybCwgc2NvcGUuY291cnNlaWQpLnRoZW4oZnVuY3Rpb24oYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHNjb3BlLmFjdGlvbnMgPSBhY3Rpb25zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5rOiBsaW5rLFxuICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgY29udGV4dHVybDogJz0nLFxuICAgICAgICAgICAgY291cnNlaWQ6ICc9J1xuICAgICAgICB9LFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9ub3RpZmljYXRpb25zL3RlbXBsYXRlcy9hY3Rpb25zLmh0bWwnLFxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm5vdGlmaWNhdGlvbnMnKVxuXG4vKipcbiAqIEZpbHRlciB0byBmb3JtYXQgYSBub3RpZmljYXRpb24uXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubm90aWZpY2F0aW9uc1xuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgbW1hTm90aWZpY2F0aW9uc0Zvcm1hdFxuICovXG4uZmlsdGVyKCdtbWFOb3RpZmljYXRpb25zRm9ybWF0JywgZnVuY3Rpb24oJG1tVGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLy17NCx9L2lnLCAnJyk7XG4gICAgdGV4dCA9ICRtbVRleHQucmVwbGFjZU5ld0xpbmVzKHRleHQsICc8YnIgLz4nKTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubm90aWZpY2F0aW9ucycpXG5cbi8qKlxuICogTm90aWZpY2F0aW9ucyBoYW5kbGVycyBmYWN0b3J5LlxuICpcbiAqIFRoaXMgZmFjdG9yeSBob2xkcyB0aGUgZGlmZmVyZW50IGhhbmRsZXJzIHVzZWQgZm9yIGRlbGVnYXRlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3RpZmljYXRpb25zXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU5vdGlmaWNhdGlvbnNIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU5vdGlmaWNhdGlvbnNIYW5kbGVycycsIGZ1bmN0aW9uKCRsb2csICRtbWFOb3RpZmljYXRpb25zKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFOb3RpZmljYXRpb25zSGFuZGxlcnMnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBTaWRlIG1lbnUgbmF2IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3RpZmljYXRpb25zSGFuZGxlcnMjc2lkZU1lbnVOYXZcbiAgICAgKi9cbiAgICBzZWxmLnNpZGVNZW51TmF2ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTm90aWZpY2F0aW9ucy5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbnRyb2xsZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTaWRlIG1lbnUgbmF2IGhhbmRsZXIgY29udHJvbGxlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3RpZmljYXRpb25zXG4gICAgICAgICAgICAgKiBAbmdkb2MgY29udHJvbGxlclxuICAgICAgICAgICAgICogQG5hbWUgJG1tYU5vdGlmaWNhdGlvbnNIYW5kbGVycyNzaWRlTWVudU5hdjpjb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICdpb24taW9zLWJlbGwnO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEubm90aWZpY2F0aW9ucy5ub3RpZmljYXRpb25zJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3RhdGUgPSAnc2l0ZS5ub3RpZmljYXRpb25zJztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5ub3RpZmljYXRpb25zJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGhhbmRsZSBub3RpZmljYXRpb25zIChtZXNzYWdlcykuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubm90aWZpY2F0aW9uc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFOb3RpZmljYXRpb25zXG4gKi9cbi5mYWN0b3J5KCckbW1hTm90aWZpY2F0aW9ucycsIGZ1bmN0aW9uKCRxLCAkbG9nLCAkbW1TaXRlLCAkbW1TaXRlc01hbmFnZXIsIG1tYU5vdGlmaWNhdGlvbnNMaXN0TGltaXQpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hTm90aWZpY2F0aW9ucycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8vIEZ1bmN0aW9uIHRvIGZvcm1hdCBub3RpZmljYXRpb24gZGF0YS5cbiAgICBmdW5jdGlvbiBmb3JtYXROb3RpZmljYXRpb25zRGF0YShub3RpZmljYXRpb25zKSB7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChub3RpZmljYXRpb25zLCBmdW5jdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFNldCBtZXNzYWdlIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uLmNvbnRleHR1cmwgJiYgbm90aWZpY2F0aW9uLmNvbnRleHR1cmwuaW5kZXhPZignL21vZC9mb3J1bS8nKSkge1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5tb2JpbGV0ZXh0ID0gbm90aWZpY2F0aW9uLnNtYWxsbWVzc2FnZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uLm1vYmlsZXRleHQgPSBub3RpZmljYXRpb24uZnVsbG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byBzZXQgY291cnNlaWQgdGhlIG5vdGlmaWNhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgICAgdmFyIGNpZCA9IG5vdGlmaWNhdGlvbi5mdWxsbWVzc2FnZWh0bWwubWF0Y2goL2NvdXJzZVxcL3ZpZXdcXC5waHBcXD9pZD0oW15cIl0qKS8pO1xuICAgICAgICAgICAgaWYgKGNpZCAmJiBjaWRbMV0pIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb24uY291cnNlaWQgPSBjaWRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIG5vdGlmaWNhdGlvbiBsaXN0IFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Tm90aWZpY2F0aW9uc0NhY2hlS2V5KCkge1xuICAgICAgICByZXR1cm4gJ21tYU5vdGlmaWNhdGlvbnM6bGlzdCc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBub3RpZmljYXRpb25zIGZyb20gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU5vdGlmaWNhdGlvbnMjZ2V0Tm90aWZpY2F0aW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVhZCAgICAgICBUcnVlIGlmIHNob3VsZCBnZXQgcmVhZCBub3RpZmljYXRpb25zLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0RnJvbSAgIFBvc2l0aW9uIG9mIHRoZSBmaXJzdCBub3RpZmljYXRpb24gdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdE51bWJlciBOdW1iZXIgb2Ygbm90aWZpY2F0aW9ucyB0byBnZXQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Tm90aWZpY2F0aW9ucyA9IGZ1bmN0aW9uKHJlYWQsIGxpbWl0RnJvbSwgbGltaXROdW1iZXIpIHtcbiAgICAgICAgbGltaXRGcm9tID0gbGltaXRGcm9tIHx8IDA7XG4gICAgICAgIGxpbWl0TnVtYmVyID0gbGltaXROdW1iZXIgfHzCoG1tYU5vdGlmaWNhdGlvbnNMaXN0TGltaXQ7XG5cbiAgICAgICAgJGxvZy5kZWJ1ZygnR2V0ICcgKyAocmVhZCA/ICdyZWFkJyA6ICd1bnJlYWQnKSArICcgbm90aWZpY2F0aW9ucyBmcm9tICcgKyBsaW1pdEZyb20gKyAnLiBMaW1pdDogJyArIGxpbWl0TnVtYmVyKTtcblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIHVzZXJpZHRvOiAkbW1TaXRlLmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgdXNlcmlkZnJvbTogMCxcbiAgICAgICAgICAgIHR5cGU6ICdub3RpZmljYXRpb25zJyxcbiAgICAgICAgICAgIHJlYWQ6IHJlYWQgPyAxIDogMCxcbiAgICAgICAgICAgIG5ld2VzdGZpcnN0OiAxLFxuICAgICAgICAgICAgbGltaXRmcm9tOiBsaW1pdEZyb20sXG4gICAgICAgICAgICBsaW1pdG51bTogbGltaXROdW1iZXJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByZVNldHMgPSB7XG4gICAgICAgICAgICBjYWNoZUtleTogZ2V0Tm90aWZpY2F0aW9uc0NhY2hlS2V5KClcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgdW5yZWFkIG5vdGlmaWNhdGlvbnMuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ2NvcmVfbWVzc2FnZV9nZXRfbWVzc2FnZXMnLCBkYXRhLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm90aWZpY2F0aW9ucyA9IHJlc3BvbnNlLm1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIGZvcm1hdE5vdGlmaWNhdGlvbnNEYXRhKG5vdGlmaWNhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RpZmljYXRpb25zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVhZCBub3RpZmljYXRpb25zIGZyb20gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU5vdGlmaWNhdGlvbnMjZ2V0UmVhZE5vdGlmaWNhdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXRGcm9tICAgUG9zaXRpb24gb2YgdGhlIGZpcnN0IG5vdGlmaWNhdGlvbiB0byBnZXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0TnVtYmVyIE51bWJlciBvZiBub3RpZmljYXRpb25zIHRvIGdldC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIG5vdGlmaWNhdGlvbnMuXG4gICAgICovXG4gICAgc2VsZi5nZXRSZWFkTm90aWZpY2F0aW9ucyA9IGZ1bmN0aW9uKGxpbWl0RnJvbSwgbGltaXROdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Tm90aWZpY2F0aW9ucyh0cnVlLCBsaW1pdEZyb20sIGxpbWl0TnVtYmVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHVucmVhZCBub3RpZmljYXRpb25zIGZyb20gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU5vdGlmaWNhdGlvbnMjZ2V0VW5yZWFkTm90aWZpY2F0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdEZyb20gICBQb3NpdGlvbiBvZiB0aGUgZmlyc3Qgbm90aWZpY2F0aW9uIHRvIGdldC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXROdW1iZXIgTnVtYmVyIG9mIG5vdGlmaWNhdGlvbnMgdG8gZ2V0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFVucmVhZE5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbihsaW1pdEZyb20sIGxpbWl0TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldE5vdGlmaWNhdGlvbnMoZmFsc2UsIGxpbWl0RnJvbSwgbGltaXROdW1iZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBub3RpZmljYXRpb25zIGxpc3QgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3RpZmljYXRpb25zI2ludmFsaWRhdGVOb3RpZmljYXRpb25zTGlzdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbGlzdCBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVOb3RpZmljYXRpb25zTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXROb3RpZmljYXRpb25zQ2FjaGVLZXkoKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHBsdWdpbiBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3RpZmljYXRpb25zI2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgcGx1Z2luIGlzIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX21lc3NhZ2VfZ2V0X21lc3NhZ2VzJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHBsdWdpbiBpcyBhdmFpbGFibGUgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubm90aWZpY2F0aW9uc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTm90aWZpY2F0aW9ucyNpc1BsdWdpbkVuYWJsZWRGb3JTaXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVpZCBTaXRlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUmVzb2x2ZWQgd2hlbiBlbmFibGVkLCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWRGb3JTaXRlID0gZnVuY3Rpb24oc2l0ZWlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlaWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgaWYgKCFzaXRlLndzQXZhaWxhYmxlKCdjb3JlX21lc3NhZ2VfZ2V0X21lc3NhZ2VzJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMucGFydGljaXBhbnRzJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGhhbmRsZSBjb3Vyc2UgcGFydGljaXBhbnRzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLnBhcnRpY2lwYW50c1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYVBhcnRpY2lwYW50c0xpc3RDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFQYXJ0aWNpcGFudHNMaXN0Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlLCAkc3RhdGVQYXJhbXMsICRtbVV0aWwsICRtbWFQYXJ0aWNpcGFudHMsICRpb25pY1BsYXRmb3JtLCAkbW1TaXRlLFxuICAgICAgICAgICAgbW1Vc2VyUHJvZmlsZVN0YXRlKSB7XG4gICAgdmFyIGNvdXJzZSA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2UsXG4gICAgICAgIGNvdXJzZWlkID0gY291cnNlLmlkO1xuXG4gICAgJHNjb3BlLnBhcnRpY2lwYW50cyA9IFtdO1xuICAgICRzY29wZS5jb3Vyc2VpZCA9IGNvdXJzZWlkO1xuICAgICRzY29wZS51c2VyU3RhdGVOYW1lID0gbW1Vc2VyUHJvZmlsZVN0YXRlO1xuXG4gICAgZnVuY3Rpb24gZmV0Y2hQYXJ0aWNpcGFudHMocmVmcmVzaCkge1xuICAgICAgICB2YXIgZmlyc3RUb0dldCA9IHJlZnJlc2ggPyAwIDogJHNjb3BlLnBhcnRpY2lwYW50cy5sZW5ndGg7XG4gICAgICAgIHJldHVybiAkbW1hUGFydGljaXBhbnRzLmdldFBhcnRpY2lwYW50cyhjb3Vyc2VpZCwgZmlyc3RUb0dldCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5wYXJ0aWNpcGFudHMgPSBkYXRhLnBhcnRpY2lwYW50cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnBhcnRpY2lwYW50cyA9ICRzY29wZS5wYXJ0aWNpcGFudHMuY29uY2F0KGRhdGEucGFydGljaXBhbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IGRhdGEuY2FuTG9hZE1vcmU7XG4gICAgICAgIH0sIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICAkc2NvcGUuY2FuTG9hZE1vcmUgPSBmYWxzZTsgLy8gU2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgaW5maW5pdGUgY2FsbHMgd2l0aCBpbmZpbml0ZS1sb2FkaW5nLlxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBHZXQgZmlyc3QgcGFydGljaXBhbnRzLlxuICAgIGZldGNoUGFydGljaXBhbnRzKHRydWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEFkZCBsb2cgaW4gTW9vZGxlLlxuICAgICAgICAkbW1TaXRlLndyaXRlKCdjb3JlX3VzZXJfdmlld191c2VyX2xpc3QnLCB7XG4gICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlaWRcbiAgICAgICAgfSk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLnBhcnRpY2lwYW50c0xvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBMb2FkIG1vcmUgcGFydGljaXBhbnRzLlxuICAgICRzY29wZS5sb2FkTW9yZVBhcnRpY2lwYW50cyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGZldGNoUGFydGljaXBhbnRzKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwuaW5maW5pdGVTY3JvbGxDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLnJlZnJlc2hQYXJ0aWNpcGFudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYVBhcnRpY2lwYW50cy5pbnZhbGlkYXRlUGFydGljaXBhbnRzTGlzdChjb3Vyc2VpZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZldGNoUGFydGljaXBhbnRzKHRydWUpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5wYXJ0aWNpcGFudHMnKVxuXG4vKipcbiAqIFBhcnRpY2lwYW50cyBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5wYXJ0aWNpcGFudHNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hUGFydGljaXBhbnRzSGFuZGxlcnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFQYXJ0aWNpcGFudHNIYW5kbGVycycsIGZ1bmN0aW9uKCRtbWFQYXJ0aWNpcGFudHMsIG1tQ291cnNlc0FjY2Vzc01ldGhvZHMsICRtbVV0aWwsICRtbUNvbnRlbnRMaW5rc0hlbHBlcikge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgbmF2IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wYXJ0aWNpcGFudHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVBhcnRpY2lwYW50c0hhbmRsZXJzI2NvdXJzZXNOYXZIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5jb3Vyc2VzTmF2SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkIGZvciB0aGlzIGNvdXJzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkICAgQ291cnNlIElELlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjZXNzRGF0YSBUeXBlIG9mIGFjY2VzcyB0byB0aGUgY291cnNlOiBkZWZhdWx0LCBndWVzdCwgLi4uXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW58UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgIHdpdGggdHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIG9yIHByb21pc2UgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZEZvckNvdXJzZSA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBhY2Nlc3NEYXRhKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXNzRGF0YSAmJiBhY2Nlc3NEYXRhLnR5cGUgPT0gbW1Db3Vyc2VzQWNjZXNzTWV0aG9kcy5ndWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm90IGVuYWJsZWQgZm9yIGd1ZXN0cy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkbW1hUGFydGljaXBhbnRzLmlzUGx1Z2luRW5hYmxlZEZvckNvdXJzZShjb3Vyc2VJZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIENvbnRyb2xsZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAnaW9uLXBlcnNvbi1zdGFsa2VyJztcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLnBhcnRpY2lwYW50cy5wYXJ0aWNpcGFudHMnO1xuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbigkZXZlbnQsIGNvdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUucGFydGljaXBhbnRzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291cnNlOiBjb3Vyc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnBhcnRpY2lwYW50c1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hUGFydGljaXBhbnRzSGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0W119ICAgICAgICBMaXN0IG9mIGFjdGlvbnMuIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSB1c2VyIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignZ3JhZGUvcmVwb3J0L3VzZXInKSA9PSAtMSAmJiB1cmwuaW5kZXhPZignL3VzZXIvaW5kZXgucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSAkbW1VdGlsLmV4dHJhY3RVcmxQYXJhbXModXJsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5pZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbW0uY29yZS52aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tZXllJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVzOiBzaXRlSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdXJzZToge2lkOiBwYXJzZUludChwYXJhbXMuaWQsIDEwKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUNvbnRlbnRMaW5rc0hlbHBlci5nb0luU2l0ZSgnc2l0ZS5wYXJ0aWNpcGFudHMnLCBzdGF0ZVBhcmFtcywgc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMucGFydGljaXBhbnRzJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGhhbmRsZSBjb3Vyc2UgcGFydGljaXBhbnRzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLnBhcnRpY2lwYW50c1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFQYXJ0aWNpcGFudHNcbiAqL1xuLmZhY3RvcnkoJyRtbWFQYXJ0aWNpcGFudHMnLCBmdW5jdGlvbigkbG9nLCAkbW1TaXRlLCAkbW1Vc2VyLCBtbWFQYXJ0aWNpcGFudHNMaXN0TGltaXQpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hUGFydGljaXBhbnRzJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgcGFydGljaXBhbnQgbGlzdCBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBhcnRpY2lwYW50c0xpc3RDYWNoZUtleShjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gJ21tYVBhcnRpY2lwYW50czpsaXN0OicrY291cnNlaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHBhcnRpY2lwYW50cyBmb3IgYSBjZXJ0YWluIGNvdXJzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnBhcnRpY2lwYW50c1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hUGFydGljaXBhbnRzI2dldFBhcnRpY2lwYW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb3Vyc2VpZCAgICBJRCBvZiB0aGUgY291cnNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdEZyb20gICBQb3NpdGlvbiBvZiB0aGUgZmlyc3QgcGFydGljaXBhbnQgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdE51bWJlciBOdW1iZXIgb2YgcGFydGljaXBhbnRzIHRvIGdldC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBwYXJ0aWNpcGFudHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFBhcnRpY2lwYW50cyA9IGZ1bmN0aW9uKGNvdXJzZWlkLCBsaW1pdEZyb20sIGxpbWl0TnVtYmVyKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaW1pdEZyb20gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxpbWl0RnJvbSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaW1pdE51bWJlciA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGltaXROdW1iZXIgPSBtbWFQYXJ0aWNpcGFudHNMaXN0TGltaXQ7XG4gICAgICAgIH1cblxuICAgICAgICAkbG9nLmRlYnVnKCdHZXQgcGFydGljaXBhbnRzIGZvciBjb3Vyc2UgJyArIGNvdXJzZWlkICsgJyBzdGFydGluZyBhdCAnICsgbGltaXRGcm9tKTtcblxuICAgICAgICB2YXIgd3NOYW1lLFxuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlaWRcbiAgICAgICAgICAgIH0sIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldFBhcnRpY2lwYW50c0xpc3RDYWNoZUtleShjb3Vyc2VpZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKCRtbVNpdGUud3NBdmFpbGFibGUoJ2NvcmVfZW5yb2xfZ2V0X2Vucm9sbGVkX3VzZXJzJykpIHtcbiAgICAgICAgICAgIHdzTmFtZSA9ICdjb3JlX2Vucm9sX2dldF9lbnJvbGxlZF91c2Vycyc7XG4gICAgICAgICAgICBkYXRhLm9wdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXRmcm9tJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpbWl0RnJvbVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXRudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGltaXROdW1iZXJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NvcnRieScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnc2l0ZW9yZGVyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3c05hbWUgPSAnbW9vZGxlX2Vucm9sX2dldF9lbnJvbGxlZF91c2Vycyc7XG4gICAgICAgICAgICBsaW1pdE51bWJlciA9IDk5OTk5OTk5OTk7IC8vIFNldCBhIGJpZyBsaW1pdE51bWJlciBzbyBjYW5Mb2FkTW9yZSBpcyBhbHdheXMgZmFsc2UgKFdTIG5vdCBwYWdpbmF0ZWQpLlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCh3c05hbWUsIGRhdGEsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24odXNlcnMpIHtcbiAgICAgICAgICAgIC8vIEZvcm1hdCB1c2VyIGRhdGEsIG1vb2RsZV9lbnJvbF9nZXRfZW5yb2xsZWRfdXNlcnMgcmV0dXJucyBzb21lIGF0dHJpYnV0ZXMgd2l0aCBhIGRpZmZlcmVudCBuYW1lLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1c2VyLmlkID09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB1c2VyLnVzZXJpZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLmlkID0gdXNlci51c2VyaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlci5wcm9maWxlaW1hZ2V1cmwgPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHVzZXIucHJvZmlsZWltZ3VybCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLnByb2ZpbGVpbWFnZXVybCA9IHVzZXIucHJvZmlsZWltZ3VybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGNhbkxvYWRNb3JlID0gdXNlcnMubGVuZ3RoID49IGxpbWl0TnVtYmVyO1xuICAgICAgICAgICAgJG1tVXNlci5zdG9yZVVzZXJzKHVzZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7cGFydGljaXBhbnRzOiB1c2VycywgY2FuTG9hZE1vcmU6IGNhbkxvYWRNb3JlfTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHBhcnRpY2lwYW50IGxpc3QgZm9yIGEgY2VydGFpbiBjb3Vyc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wYXJ0aWNpcGFudHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVBhcnRpY2lwYW50cyNpbnZhbGlkYXRlUGFydGljaXBhbnRzTGlzdFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBsaXN0IGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZVBhcnRpY2lwYW50c0xpc3QgPSBmdW5jdGlvbihjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRQYXJ0aWNpcGFudHNMaXN0Q2FjaGVLZXkoY291cnNlaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGFydGljaXBhbnRzIGFkZG9uIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBjb3Vyc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wYXJ0aWNpcGFudHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVBhcnRpY2lwYW50cyNpc1BsdWdpbkVuYWJsZWRGb3JDb3Vyc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWRGb3JDb3Vyc2UgPSBmdW5jdGlvbihjb3Vyc2VJZCkge1xuICAgICAgICBpZiAoIWNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXRyaWV2aW5nIG9uZSBwYXJ0aWNpcGFudCB3aWxsIGZhaWwgaWYgYnJvd3NpbmcgdXNlcnMgaXMgZGlzYWJsZWQgYnkgY2FwYWJpbGl0aWVzLlxuICAgICAgICByZXR1cm4gc2VsZi5nZXRQYXJ0aWNpcGFudHMoY291cnNlSWQsIDAsIDEpLnRoZW4oZnVuY3Rpb24ocGFyY2l0aXBhbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9ucycpXG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgcHVzaCBub3RpZmljYXRpb25zIGNsaWNrcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9uc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGVcbiAqL1xuLmZhY3RvcnkoJyRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUnLCBmdW5jdGlvbigkbG9nKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tUHVzaE5vdGlmaWNhdGlvbnNEZWxlZ2F0ZScpO1xuXG4gICAgdmFyIGhhbmRsZXJzID0ge30sXG4gICAgICAgIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgcHVzaCBub3RpZmljYXRpb24gaXMgY2xpY2tlZC4gU2VuZHMgbm90aWZpY2F0aW9uIHRvIGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tUHVzaE5vdGlmaWNhdGlvbnNEZWxlZ2F0ZSNjbGlja2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vdGlmaWNhdGlvbiBOb3RpZmljYXRpb24gY2xpY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNlbGYuY2xpY2tlZCA9IGZ1bmN0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBoYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhciB0cmVhdGVkID0gY2FsbGJhY2sobm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAodHJlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFN0b3AgZXhlY3V0aW9uIHdoZW4gbm90aWZpY2F0aW9uIGlzIHRyZWF0ZWQuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgcHVzaCBub3RpZmljYXRpb25zIGhhbmRsZXIuIFRoZSBoYW5kbGVyIHdpbGwgcmVjZWl2ZSBhIG5vdGlmaWNhdGlvbiB0byB0cmVhdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnB1c2hub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUjcmVnaXN0ZXJIYW5kbGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICAgICAgSGFuZGxlcidzIG5hbWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLiBXaWxsIGdldCBhcyBwYXJhbWV0ZXIgdGhlIFVSTCB0byBoYW5kbGUuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIGhhbmRsZXIgc2hvdWxkIHJldHVybiB0cnVlIGlmIHRoZSBub3RpZmljYXRpb24gaXMgdGhlIG9uZSBleHBlY3RlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBzZWUge0BsaW5rICRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUjY2xpY2tlZH1cbiAgICAgKi9cbiAgICBzZWxmLnJlZ2lzdGVySGFuZGxlciA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICRsb2cuZGVidWcoXCJSZWdpc3RlcmVkIGhhbmRsZXIgJ1wiICsgbmFtZSArIFwiJyBhcyBwdXNoIG5vdGlmaWNhdGlvbiBoYW5kbGVyLlwiKTtcbiAgICAgICAgaGFuZGxlcnNbbmFtZV0gPSBjYWxsYmFjaztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLnB1c2hub3RpZmljYXRpb25zJylcblxuLyoqXG4gKiBQdXNoIG5vdGlmaWNhdGlvbnMgZmFjdG9yeS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9uc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFQdXNoTm90aWZpY2F0aW9uc1xuICovXG4uZmFjdG9yeSgnJG1tYVB1c2hOb3RpZmljYXRpb25zJywgZnVuY3Rpb24oJG1tU2l0ZSwgJGxvZywgJGNvcmRvdmFQdXNoLCAkbW1UZXh0LCAkcSwgJGNvcmRvdmFEZXZpY2UsICRtbVV0aWwsIG1tQ29yZUNvbmZpZ0NvbnN0YW50cyxcbiAgICAgICAgICAgICRtbUFwcCwgJG1tTG9jYWxOb3RpZmljYXRpb25zLCAkbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlLCAkbW1TaXRlc01hbmFnZXIsIG1tYVB1c2hOb3RpZmljYXRpb25zQ29tcG9uZW50KSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFQdXNoTm90aWZpY2F0aW9ucycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgcHVzaElEO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9uc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hUHVzaE5vdGlmaWNhdGlvbnMjaXNQbHVnaW5FbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3NBdmFpbGFibGUoJ2NvcmVfdXNlcl9hZGRfdXNlcl9kZXZpY2UnKVxuICAgICAgICAgICAgICAgICYmICRtbVNpdGUud3NBdmFpbGFibGUoJ21lc3NhZ2VfYWlybm90aWZpZXJfaXNfc3lzdGVtX2NvbmZpZ3VyZWQnKVxuICAgICAgICAgICAgICAgICYmICRtbVNpdGUud3NBdmFpbGFibGUoJ21lc3NhZ2VfYWlybm90aWZpZXJfYXJlX25vdGlmaWNhdGlvbl9wcmVmZXJlbmNlc19jb25maWd1cmVkJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgcHVzaCBub3RpZmljYXRpb24gaXMgY2xpY2tlZC4gUmVkaXJlY3QgdGhlIHVzZXIgdG8gdGhlIHJpZ2h0IHN0YXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVB1c2hOb3RpZmljYXRpb25zI25vdGlmaWNhdGlvbkNsaWNrZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBOb3RpZmljYXRpb24gZGF0YS5cbiAgICAgKi9cbiAgICBzZWxmLm5vdGlmaWNhdGlvbkNsaWNrZWQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICRtbUFwcC5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlLmNsaWNrZWQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmcm9tIHRoZSBQdXNoUGx1Z2luIHdoZW4gd2UgcmVjZWl2ZSBhIE5vdGlmaWNhdGlvbiBmcm9tIEdDTS5cbiAgICAgKiBUaGUgYXBwIGNhbiBiZSBpbiBmb3JlZ3JvdW5kIG9yIGJhY2tncm91bmQsXG4gICAgICogaWYgd2UgYXJlIGluIGJhY2tncm91bmQgdGhpcyBjb2RlIGlzIGV4ZWN1dGVkIHdoZW4gd2Ugb3BlbiB0aGUgYXBwIGNsaWNraW5nIGluIHRoZSBub3RpZmljYXRpb24gYmFyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVB1c2hOb3RpZmljYXRpb25zI29uR0NNUmVjZWl2ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm90aWZpY2F0aW9uIE5vdGlmaWNhdGlvbiBkYXRhLlxuICAgICAqL1xuICAgIHNlbGYub25HQ01SZWNlaXZlZCA9IGZ1bmN0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgICAgICAkbG9nLmRlYnVnKCdHQ00gbm90aWZpY2F0aW9uIHJlY2VpdmVkLiBUeXBlOiAnK25vdGlmaWNhdGlvbi5ldmVudCk7XG5cbiAgICAgICAgc3dpdGNoIChub3RpZmljYXRpb24uZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JlZ2lzdGVyZWQnOlxuICAgICAgICAgICAgICAgIGlmIChub3RpZmljYXRpb24ucmVnaWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoSUQgPSBub3RpZmljYXRpb24ucmVnaWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJlZ2lzdGVyRGV2aWNlT25Nb29kbGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdEZXZpY2UgTk9UIHJlZ2lzdGVyZWQgaW4gR0NNLCBpbnZhbGlkIHJlZ2lkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uLnBheWxvYWQuZm9yZWdyb3VuZCA9IG5vdGlmaWNhdGlvbi5mb3JlZ3JvdW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLm9uTWVzc2FnZVJlY2VpdmVkKG5vdGlmaWNhdGlvbi5wYXlsb2FkKTtcblxuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1B1c2ggbWVzc2FnZXMgZXJyb3InKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdQdXNoIHVua25vd24gbWVzc2FnZScpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gd2UgcmVjZWl2ZSBhIE5vdGlmaWNhdGlvbiBmcm9tIEFQTlMgb3IgYSBtZXNzYWdlIG5vdGlmaWNhdGlvbiBmcm9tIEdDTS5cbiAgICAgKiBUaGUgYXBwIGNhbiBiZSBpbiBmb3JlZ3JvdW5kIG9yIGJhY2tncm91bmQsXG4gICAgICogaWYgd2UgYXJlIGluIGJhY2tncm91bmQgdGhpcyBjb2RlIGlzIGV4ZWN1dGVkIHdoZW4gd2Ugb3BlbiB0aGUgYXBwIGNsaWNraW5nIGluIHRoZSBub3RpZmljYXRpb24gYmFyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVB1c2hOb3RpZmljYXRpb25zI29uTWVzc2FnZVJlY2VpdmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgTm90aWZpY2F0aW9uIGRhdGEuXG4gICAgICovXG4gICAgc2VsZi5vbk1lc3NhZ2VSZWNlaXZlZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5zaXRlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoZGF0YS5zaXRlKTsgLy8gQ2hlY2sgaWYgc2l0ZSBleGlzdHMuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbigpOyAvLyBObyBzaXRlIHNwZWNpZmllZCwgcmVzb2x2ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgkbW1VdGlsLmlzVHJ1ZU9yT25lKGRhdGEuZm9yZWdyb3VuZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXBwIGlzIGluIGZvcmVncm91bmQgd2hlbiB0aGUgbm90aWZpY2F0aW9uIGlzIHJlY2VpdmVkLCBpdCdzIG5vdCBzaG93bi4gTGV0J3Mgc2hvdyBpdCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgaWYgKCRtbUxvY2FsTm90aWZpY2F0aW9ucy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGZvcm1hdFRleHQgdG8gdGl0bGUgYW5kIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgICRtbVRleHQuZm9ybWF0VGV4dChkYXRhLnRpdGxlLCB0cnVlLCB0cnVlKS50aGVuKGZ1bmN0aW9uKGZvcm1hdHRlZFRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1UZXh0LmZvcm1hdFRleHQoZGF0YS5tZXNzYWdlLCB0cnVlLCB0cnVlKS50aGVuKGZ1bmN0aW9uKGZvcm1hdHRlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxOb3RpZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBmb3JtYXR0ZWRUaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZm9ybWF0dGVkTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYWxsSWNvbjogJ3JlczovL2ljb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZjogZGF0YS5ub3RpZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpdGU6IGRhdGEuc2l0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMuc2NoZWR1bGUobG9jYWxOb3RpZiwgbW1hUHVzaE5vdGlmaWNhdGlvbnNDb21wb25lbnQsIGRhdGEuc2l0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLm5vdGlmaWNhdGlvbkNsaWNrZWQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGRldmljZSBpbiBBcHBsZSBBUE5TIG9yIEdvb2dsZSBHQ00uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9uc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hUHVzaE5vdGlmaWNhdGlvbnMjcmVnaXN0ZXJEZXZpY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRldmljZSBpcyByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIHNlbGYucmVnaXN0ZXJEZXZpY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3JlZ2lzdGVyRGV2aWNlQVBOUygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZWdpc3RlckRldmljZUdDTSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGV4KSB7fVxuXG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBkZXZpY2UgaW4gQXBwbGUgQVBOUyAoQXBwbGUgUHVzaCBOb3RpZmljYWl0b24gU3lzdGVtKSB1c2luZyB0aGUgUGhvbmVnYXAgUHVzaFBsdWdpbi5cbiAgICAgKiBJdCBhbHNvIHJlZ2lzdGVycyB0aGUgZGV2aWNlIGluIHRoZSBNb29kbGUgc2l0ZSB1c2luZyB0aGUgY29yZV91c2VyX2FkZF91c2VyX2RldmljZSBXZWJTZXJ2aWNlLlxuICAgICAqIFdlIG5lZWQgdGhlIGRldmljZSByZWdpc3RlcmVkIGluIE1vb2RsZSBzbyB3ZSBjYW4gY29ubmVjdCB0aGUgZGV2aWNlIHdpdGggdGhlIG1lc3NhZ2Ugb3V0cHV0IE1vb2RlIHBsdWdpbiBhaXJub3RpZmllci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnB1c2hub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFQdXNoTm90aWZpY2F0aW9ucyNfcmVnaXN0ZXJEZXZpY2VBUE5TXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkZXZpY2UgaXMgcmVnaXN0ZXJlZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fcmVnaXN0ZXJEZXZpY2VBUE5TID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgYWxlcnQ6ICd0cnVlJyxcbiAgICAgICAgICAgIGJhZGdlOiAndHJ1ZScsXG4gICAgICAgICAgICBzb3VuZDogJ3RydWUnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkY29yZG92YVB1c2gucmVnaXN0ZXIob3B0aW9ucykudGhlbihmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgcHVzaElEID0gdG9rZW47XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yZWdpc3RlckRldmljZU9uTW9vZGxlKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGRldmljZSBpbiBHb29nbGUgR0NNIHVzaW5nIHRoZSBQaG9uZWdhcCBQdXNoUGx1Z2luLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVB1c2hOb3RpZmljYXRpb25zI19yZWdpc3RlckRldmljZUdDTVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGV2aWNlIGlzIHJlZ2lzdGVyZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX3JlZ2lzdGVyRGV2aWNlR0NNID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChtbUNvcmVDb25maWdDb25zdGFudHMuZ2NtcG4pIHtcbiAgICAgICAgICAgIHJldHVybiAkY29yZG92YVB1c2gucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICAgIHNlbmRlcklEOiBtbUNvcmVDb25maWdDb25zdGFudHMuZ2NtcG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZGV2aWNlIG9uIGN1cnJlbnQgTW9vZGxlIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9uc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hUHVzaE5vdGlmaWNhdGlvbnMjcmVnaXN0ZXJEZXZpY2VPbk1vb2RsZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGRldmljZSBpcyByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIHNlbGYucmVnaXN0ZXJEZXZpY2VPbk1vb2RsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbG9nLmRlYnVnKCdSZWdpc3RlciBkZXZpY2Ugb24gTW9vZGxlLicpO1xuXG4gICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkgfHwgIXB1c2hJRCB8fCAhJG1tQXBwLmlzRGV2aWNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgYXBwaWQ6ICAgICAgbW1Db3JlQ29uZmlnQ29uc3RhbnRzLmFwcF9pZCxcbiAgICAgICAgICAgIG5hbWU6ICAgICAgIGlvbmljLlBsYXRmb3JtLmRldmljZSgpLm5hbWUgfHwgJycsXG4gICAgICAgICAgICBtb2RlbDogICAgICAkY29yZG92YURldmljZS5nZXRNb2RlbCgpLFxuICAgICAgICAgICAgcGxhdGZvcm06ICAgJGNvcmRvdmFEZXZpY2UuZ2V0UGxhdGZvcm0oKSxcbiAgICAgICAgICAgIHZlcnNpb246ICAgICRjb3Jkb3ZhRGV2aWNlLmdldFZlcnNpb24oKSxcbiAgICAgICAgICAgIHB1c2hpZDogICAgIHB1c2hJRCxcbiAgICAgICAgICAgIHV1aWQ6ICAgICAgICRjb3Jkb3ZhRGV2aWNlLmdldFVVSUQoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnY29yZV91c2VyX2FkZF91c2VyX2RldmljZScsIGRhdGEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVycyBhIGRldmljZSBmcm9tIGEgY2VydGFpbiBNb29kbGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnB1c2hub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFQdXNoTm90aWZpY2F0aW9ucyN1bnJlZ2lzdGVyRGV2aWNlT25Nb29kbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2l0ZSBTaXRlIHRvIHVucmVnaXN0ZXIgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gZGV2aWNlIGlzIHVucmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBzZWxmLnVucmVnaXN0ZXJEZXZpY2VPbk1vb2RsZSA9IGZ1bmN0aW9uKHNpdGUpIHtcblxuICAgICAgICBpZiAoIXNpdGUgfHwgISRtbUFwcC5pc0RldmljZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAkbG9nLmRlYnVnKCdVbnJlZ2lzdGVyIGRldmljZSBvbiBNb29kbGU6ICcgKyBzaXRlLmlkKTtcblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGFwcGlkOiBtbUNvcmVDb25maWdDb25zdGFudHMuYXBwX2lkLFxuICAgICAgICAgICAgdXVpZDogICRjb3Jkb3ZhRGV2aWNlLmdldFVVSUQoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2l0ZS53cml0ZSgnY29yZV91c2VyX3JlbW92ZV91c2VyX2RldmljZScsIGRhdGEpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UgfHzCoCFyZXNwb25zZS5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLnJlbW90ZXN0eWxlcycpXG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgcmVtb3RlIHN0eWxlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5yZW1vdGVzdHlsZXNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hUmVtb3RlU3R5bGVzXG4gKi9cbi5mYWN0b3J5KCckbW1hUmVtb3RlU3R5bGVzJywgZnVuY3Rpb24oJGxvZywgJHEsICRtbVNpdGUsICRtbVNpdGVzTWFuYWdlciwgJG1tRmlsZXBvb2wsICRodHRwLCAkbW1GUywgbW1hUmVtb3RlU3R5bGVzQ29tcG9uZW50LFxuICAgICAgICAgICAgbW1Db3JlTm90RG93bmxvYWRlZCkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFSZW1vdGVTdHlsZXMnKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIHJlbW90ZVN0eWxlc0VsID0gYW5ndWxhci5lbGVtZW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtb2JpbGVjc3N1cmwnKSk7XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciByZW1vdGUgc3R5bGVzIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5yZW1vdGVzdHlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVJlbW90ZVN0eWxlcyNjbGVhclxuICAgICAqL1xuICAgIHNlbGYuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVtb3RlU3R5bGVzRWwuaHRtbCgnJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCByZW1vdGUgc3R5bGVzIG9mIGEgY2VydGFpbiBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucmVtb3Rlc3R5bGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFSZW1vdGVTdHlsZXMjZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVpZCBTaXRlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBzdHlsZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXQgPSBmdW5jdGlvbihzaXRlaWQpIHtcbiAgICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgICAgc2l0ZWlkID0gc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgaWYgKCFzaXRlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvd25sb2FkcyBhIENTUyBmaWxlIGFuZCByZW1vdmUgb2xkIGZpbGVzIGlmIG5lZWRlZC5cbiAgICAgICAgZnVuY3Rpb24gZG93bmxvYWRGaWxlQW5kUmVtb3ZlT2xkKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmdldEZpbGVTdGF0ZUJ5VXJsKHNpdGVpZCwgdXJsKS50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlICE9PSBtbUNvcmVOb3REb3dubG9hZGVkO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGdldHRpbmcgc3RhdGUgKHNob3VsZG4ndCBoYXBwZW4pLiBEb24ndCBkZWxldGUgZG93bmxvYWRlZCBmaWxlLlxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihpc0Rvd25sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRG93bmxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIG5vdCBkb3dubG9hZGVkLCBVUkwgaGFzIGNoYW5nZWQgb3IgZmlyc3QgdGltZS4gRGVsZXRlIGRvd25sb2FkZWQgQ1NTIGZpbGVzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wucmVtb3ZlRmlsZXNCeUNvbXBvbmVudChzaXRlaWQsIG1tYVJlbW90ZVN0eWxlc0NvbXBvbmVudCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZG93bmxvYWRVcmwoc2l0ZWlkLCB1cmwsIGZhbHNlLCBtbWFSZW1vdGVTdHlsZXNDb21wb25lbnQsIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciBpbmZvcyA9IHNpdGUuZ2V0SW5mbygpO1xuICAgICAgICAgICAgaWYgKGluZm9zICYmIGluZm9zLm1vYmlsZWNzc3VybCkge1xuICAgICAgICAgICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIHN5c3RlbSBpcyBhdmFpbGFibGUuIERvd25sb2FkIHRoZSBmaWxlIGFuZCByZW1vdmUgb2xkIENTUyBmaWxlcyBpZiBuZWVkZWQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3dubG9hZEZpbGVBbmRSZW1vdmVPbGQoaW5mb3MubW9iaWxlY3NzdXJsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSByZXR1cm4gdGhlIG9ubGluZSBVUkwuIFdlJ3JlIHByb2JhYmx5IG9uIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmZvcy5tb2JpbGVjc3N1cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mb3MubW9iaWxlY3NzdXJsID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDU1MgVVJMIGlzIGVtcHR5LiBEZWxldGUgZG93bmxvYWRlZCBmaWxlcyAoaWYgYW55KS5cbiAgICAgICAgICAgICAgICAgICAgJG1tRmlsZXBvb2wucmVtb3ZlRmlsZXNCeUNvbXBvbmVudChzaXRlaWQsIG1tYVJlbW90ZVN0eWxlc0NvbXBvbmVudCwgMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnTG9hZGluZyBzdHlsZXMgZnJvbTogJyt1cmwpO1xuICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldCh1cmwpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9hZCBzdHlsZXMgZm9yIGN1cnJlbnQgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnJlbW90ZXN0eWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hUmVtb3RlU3R5bGVzI2xvYWRcbiAgICAgKi9cbiAgICBzZWxmLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNpdGVpZCA9ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgaWYgKHNpdGVpZCkge1xuICAgICAgICAgICAgc2VsZi5nZXQoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHN0eWxlcykge1xuICAgICAgICAgICAgICAgIGlmIChzaXRlaWQgPT09ICRtbVNpdGUuZ2V0SWQoKSkgeyAvLyBNYWtlIHN1cmUgaXQgaGFzbid0IGxvZ291dCB3aGlsZSByZXRyaWV2aW5nIHN0eWxlcy5cbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU3R5bGVzRWwuaHRtbChzdHlsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=

angular.module('mm.core')

.constant('mmCoreConfigConstants', {
    "app_id" : "uk.ac.bbk.moodle",
    "versioncode" : "2009",
    "versionname" : "0.0.18",
    "cache_expiration_time" : 300000,
    "default_lang" : "en",
    "languages": {"ar": "عربي", "bg": "Български", "ca": "Català", "cs": "Čeština", "de": "Deutsch","en": "English", "es": "Español", "es-mx": "Español - México", "eu": "Euskara", "fa": "فارسی", "fr" : "Français", "he" : "עברית", "hu": "magyar", "it": "Italiano", "ja": "日本語","nl": "Nederlands", "pl": "Polski", "pt-br": "Português - Brasil", "ru": "Русский", "sv": "Svenska", "tr" : "Türkçe", "zh-cn" : "简体中文", "zh-tw" : "正體中文"},
    "wsservice" : "moodle_mobile_app",
    "wsextservice" : "local_mobile",
    "gcmpn": "694767596569"
}
);