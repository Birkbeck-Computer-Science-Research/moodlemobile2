// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Dependencies will be automatically added here, the following line must declare ionic as first dependency
// and should not be split into multiple lines, see gulpfile.js.
angular.module('mm', ['ionic', 'mm.core', 'mm.core.contentlinks', 'mm.core.course', 'mm.core.courses', 'mm.core.login', 'mm.core.settings', 'mm.core.sidemenu', 'mm.core.textviewer', 'mm.core.user', 'mm.addons.calendar', 'mm.addons.coursecompletion', 'mm.addons.files', 'mm.addons.frontpage', 'mm.addons.grades', 'mm.addons.messages', 'mm.addons.mod_assign', 'mm.addons.mod_book', 'mm.addons.mod_chat', 'mm.addons.mod_choice', 'mm.addons.mod_folder', 'mm.addons.mod_forum', 'mm.addons.mod_glossary', 'mm.addons.mod_imscp', 'mm.addons.mod_label', 'mm.addons.mod_lti', 'mm.addons.mod_page', 'mm.addons.mod_resource', 'mm.addons.mod_scorm', 'mm.addons.mod_survey', 'mm.addons.mod_url', 'mm.addons.notes', 'mm.addons.notifications', 'mm.addons.participants', 'mm.addons.pushnotifications', 'mm.addons.remotestyles', 'ngCordova', 'angular-md5', 'pascalprecht.translate', 'ngAria', 'ngIOS9UIWebViewPatch', 'nvd3'])

.run(["$ionicPlatform", function($ionicPlatform) {
  $ionicPlatform.ready(function() {
    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
    }
    if (window.StatusBar) {
      StatusBar.styleDefault();
    }
  });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core', ['pascalprecht.translate'])

.constant('mmCoreSessionExpired', 'mmCoreSessionExpired')
.constant('mmCoreUserDeleted', 'mmCoreUserDeleted')
.constant('mmCoreSecondsYear', 31536000)
.constant('mmCoreSecondsDay', 86400)
.constant('mmCoreSecondsHour', 3600)
.constant('mmCoreSecondsMinute', 60)

// States for downloading files/modules.
.constant('mmCoreDownloaded', 'downloaded')
.constant('mmCoreDownloading', 'downloading')
.constant('mmCoreNotDownloaded', 'notdownloaded')
.constant('mmCoreOutdated', 'outdated')
.constant('mmCoreNotDownloadable', 'notdownloadable')

.constant('mmCoreWifiDownloadThreshold', 104857600) // 100MB.
.constant('mmCoreDownloadThreshold', 10485760) // 10MB.

.config(["$stateProvider", "$provide", "$ionicConfigProvider", "$httpProvider", "$mmUtilProvider", "$mmLogProvider", "$compileProvider", "$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($stateProvider, $provide, $ionicConfigProvider, $httpProvider, $mmUtilProvider,
        $mmLogProvider, $compileProvider, $mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {

    // Set tabs to bottom on Android.
    $ionicConfigProvider.platform.android.tabs.position('bottom');

    // Decorate $ionicPlatform.
    $provide.decorator('$ionicPlatform', ['$delegate', '$window', function($delegate, $window) {
        $delegate.isTablet = function() {
            var mq = 'only screen and (min-width: 768px) and (-webkit-min-device-pixel-ratio: 1)';
            return $window.matchMedia(mq).matches;
        };
        return $delegate;
    }]);

    /**
     * Decorate $log. Usage:
     * $log = $log.getInstance('MyFactory')
     * $log.debug('My message') -> "dd/mm/aaaa hh:mm:ss MyFactory: My message"
     */
    $provide.decorator('$log', ['$delegate', $mmLogProvider.logDecorator]);

    $stateProvider
        .state('redirect', {
            url: '/redirect',
            params: {
                siteid: null,
                state: null,
                params: null
            },
            cache: false,
            controller: ["$scope", "$state", "$stateParams", "$mmSite", "$mmSitesManager", "$ionicHistory", function($scope, $state, $stateParams, $mmSite, $mmSitesManager, $ionicHistory) {

                $ionicHistory.nextViewOptions({disableBack: true});

                function loadSiteAndGo() {
                    $mmSitesManager.loadSite($stateParams.siteid).then(function() {
                        $state.go($stateParams.state, $stateParams.params);
                    }, function() {
                        // Site doesn't exist.
                        $state.go('mm_login.sites');
                    });
                }

                $scope.$on('$ionicView.enter', function() {
                    if ($mmSite.isLoggedIn()) {
                        if ($stateParams.siteid && $stateParams.siteid != $mmSite.getId()) {
                            // Notification belongs to a different site. Change site.
                            $mmSitesManager.logout().then(function() {
                                loadSiteAndGo();
                            });
                        } else {
                            $state.go($stateParams.state, $stateParams.params);
                        }
                    } else {
                        if ($stateParams.siteid) {
                            loadSiteAndGo();
                        } else {
                            $state.go('mm_login.sites');
                        }
                    }
                });
            }]
        });

    // This code is to be able to get data sent with $http.post using $_POST variable.
    // Otherwise all the data ends up in php://input and seems like local/mobile/check.php doesn't like it.
    $httpProvider.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8';
    $httpProvider.defaults.transformRequest = [function(data) {
        return angular.isObject(data) && String(data) !== '[object File]' ? $mmUtilProvider.param(data) : data;
    }];

    // Add some protocols to safe protocols.
    function addProtocolIfMissing(list, protocol) {
        if (list.indexOf(protocol) == -1) {
            list = list.replace('https?', 'https?|' + protocol);
        }
        return list;
    }

    var hreflist = $compileProvider.aHrefSanitizationWhitelist().source,
        imglist = $compileProvider.imgSrcSanitizationWhitelist().source;

    hreflist = addProtocolIfMissing(hreflist, 'file');
    hreflist = addProtocolIfMissing(hreflist, 'tel');
    hreflist = addProtocolIfMissing(hreflist, 'mailto');
    hreflist = addProtocolIfMissing(hreflist, 'geo');
    hreflist = addProtocolIfMissing(hreflist, 'filesystem'); // For HTML5 FileSystem.
    imglist = addProtocolIfMissing(imglist, 'filesystem'); // For HTML5 FileSystem.

    $compileProvider.aHrefSanitizationWhitelist(hreflist);
    $compileProvider.imgSrcSanitizationWhitelist(imglist);

    // Register the core init process, this should be the very first thing.
    $mmInitDelegateProvider.registerProcess('mmAppInit', '$mmApp.initProcess', mmInitDelegateMaxAddonPriority + 400, true);

    // Register upgrade check process, this should happen almost before everything else.
    $mmInitDelegateProvider.registerProcess('mmUpdateManager', '$mmUpdateManager.check', mmInitDelegateMaxAddonPriority + 300, true);
}])

.run(["$ionicPlatform", "$ionicBody", "$window", "$mmEvents", "$mmInitDelegate", "mmCoreEventKeyboardShow", "mmCoreEventKeyboardHide", function($ionicPlatform, $ionicBody, $window, $mmEvents, $mmInitDelegate, mmCoreEventKeyboardShow, mmCoreEventKeyboardHide) {
    // Execute all the init processes.
    $mmInitDelegate.executeInitProcesses();

    // When the platform is ready.
    $ionicPlatform.ready(function() {
        var checkTablet = function() {
            $ionicBody.enableClass($ionicPlatform.isTablet(), 'tablet');
        };
        ionic.on('resize', checkTablet, $window);
        checkTablet();

        // Listen for keyboard events. We don't use $cordovaKeyboard because it doesn't support keyboardHeight property.
        $window.addEventListener('native.keyboardshow', function(e) {
            $mmEvents.trigger(mmCoreEventKeyboardShow, e);
        });
        $window.addEventListener('native.keyboardhide', function(e) {
            $mmEvents.trigger(mmCoreEventKeyboardHide, e);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmAddonManager
 * @module mm.core
 * @description
 * This service provides functions related to addons, like checking if an addon is available.
 */
.factory('$mmAddonManager', ["$log", "$injector", function($log, $injector) {

    $log = $log.getInstance('$mmAddonManager');

    var self = {},
        instances = {};

    /**
     * Get a service instance if it's available.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmAddonManager#get
     * @param  {String} name Service name.
     * @return {Object}      Service instance.
     */
    self.get = function(name) {
        if (self.isAvailable(name)) {
            return instances[name];
        }
    };

    /**
     * Check if a service is available.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmAddonManager#isAvailable
     * @param  {String} name Service name.
     * @return {Boolean}     True if available, false otherwise.
     */
    self.isAvailable = function(name) {
        if (!name) {
            return false;
        }

        if (instances[name]) {
            return true;
        }

        try {
            instances[name] = $injector.get(name);
            return true;
        } catch(ex) {
            $log.warn('Service not available: '+name);
            return false;
        }
    };

    return self;
}]);

/**
 * ==================  angular-ios9-uiwebview.patch.js v1.1.0 ==================
 *
 * This patch works around iOS9 UIWebView regression that causes infinite digest
 * errors in Angular.
 *
 * The patch can be applied to Angular 1.2.0 – 1.4.5. Newer versions of Angular
 * have the workaround baked in.
 *
 * To apply this patch load/bundle this file with your application and add a
 * dependency on the "ngIOS9Patch" module to your main app module.
 *
 * For example:
 *
 * ```
 * angular.module('myApp', ['ngRoute'])`
 * ```
 *
 * becomes
 *
 * ```
 * angular.module('myApp', ['ngRoute', 'ngIOS9UIWebViewPatch'])
 * ```
 *
 *
 * More info:
 * - https://openradar.appspot.com/22186109
 * - https://github.com/angular/angular.js/issues/12241
 * - https://github.com/driftyco/ionic/issues/4082
 *
 *
 * @license AngularJS
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */

angular.module('ngIOS9UIWebViewPatch', ['ng']).config(["$provide", function($provide) {
  $provide.decorator('$browser', ['$delegate', '$window', function($delegate, $window) {

    if (isIOS9UIWebView($window.navigator.userAgent)) {
      return applyIOS9Shim($delegate);
    }

    return $delegate;

    function isIOS9UIWebView(userAgent) {
      return /(iPhone|iPad|iPod).* OS 9_\d/.test(userAgent) && !/Version\/9\./.test(userAgent);
    }

    function applyIOS9Shim(browser) {
      var pendingLocationUrl = null;
      var originalUrlFn= browser.url;

      browser.url = function() {
        if (arguments.length) {
          pendingLocationUrl = arguments[0];
          return originalUrlFn.apply(browser, arguments);
        }

        return pendingLocationUrl || originalUrlFn.apply(browser, arguments);
      };

      window.addEventListener('popstate', clearPendingLocationUrl, false);
      window.addEventListener('hashchange', clearPendingLocationUrl, false);

      function clearPendingLocationUrl() {
        pendingLocationUrl = null;
      }

      return browser;
    }
  }]);
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Factory to provide some global functionalities, like access to the global app database.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmApp
 * @description
 * This provider is the interface with the app database. The modules that need to store
 * information here need to register their stores.
 *
 * Example:
 *
 * .config(function($mmAppProvider) {
 *      $mmAppProvider.registerStore({
 *          name: 'settings',
 *          keyPath: 'name'
 *      });
 *  })
 */
.provider('$mmApp', ["$stateProvider", function($stateProvider) {

    /** Define the app storage schema. */
    var DBNAME = 'MoodleMobile',
        dbschema = {
            stores: []
        },
        dboptions = {
            autoSchema: true
        };

    /**
     * Register a store schema.
     *
     * @param  {Object} store The store object definition.
     * @return {Void}
     */
    this.registerStore = function(store) {
        if (typeof(store.name) === 'undefined') {
            console.log('$mmApp: Error: store name is undefined.');
            return;
        } else if (storeExists(store.name)) {
            console.log('$mmApp: Error: store ' + store.name + ' is already defined.');
            return;
        }
        dbschema.stores.push(store);
    };

    /**
     * Register multiple stores at once.
     *
     * @param  {Array} stores Array of store objects.
     * @return {Void}
     */
    this.registerStores = function(stores) {
        var self = this;
        angular.forEach(stores, function(store) {
            self.registerStore(store);
        });
    };

    /**
     * Check if a store is already defined.
     *
     * @param  {String} name The name of the store.
     * @return {Boolean} True when the store was already defined.
     */
    function storeExists(name) {
        var exists = false;
        angular.forEach(dbschema.stores, function(store) {
            if (store.name === name) {
                exists = true;
            }
        });
        return exists;
    }

    this.$get = ["$mmDB", "$cordovaNetwork", "$log", "$injector", "$ionicPlatform", function($mmDB, $cordovaNetwork, $log, $injector, $ionicPlatform) {

        $log = $log.getInstance('$mmApp');

        var db,
            self = {};

        /**
         * Create a new state in the UI-router.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#createState
         * @param {String} name   State name.
         * @param {Object} config State config.
         */
        self.createState = function(name, config) {
            $log.debug('Adding new state: '+name);
            $stateProvider.state(name, config);
        };

        /**
         * Closes the keyboard if plugin is available.
         *
         * @return {Boolean} True if plugin is available, false otherwise.
         */
        self.closeKeyboard = function() {
            if (typeof cordova != 'undefined' && cordova.plugins && cordova.plugins.Keyboard && cordova.plugins.Keyboard.close) {
                cordova.plugins.Keyboard.close();
                return true;
            }
            return false;
        };

        /**
         * Get the application global database.
         * @return {Object} App's DB.
         */
        self.getDB = function() {
            if (typeof db == 'undefined') {
                db = $mmDB.getDB(DBNAME, dbschema, dboptions);
            }

            return db;
        };

        /**
         * Get the database schema.
         *
         * Do not use this method to modify the schema. Use $mmAppProvider#registerStore instead.
         *
         * @return {Object} The schema.
         */
        self.getSchema = function() {
            return dbschema;
        };

        /**
         * Core init process for the app.
         *
         * @description
         * This should be the first init process of all, no other process should run until we
         * are certain that the cordova plugins are loaded, which is what $ionicPlatform tells us.
         * There should not be any logic acting on the database here as the upgrade is
         * another process and has not run yet at this point.
         *
         * Keep this fast.
         *
         * Reserved for core use, do not call directly.
         *
         * @module mm.core
         * @ngdoc service
         * @name $mmApp#initProcess
         * @protected
         * @return {Promise}
         */
        self.initProcess = function() {
            return $ionicPlatform.ready();
        };

        /**
         * Checks if the app is running in a real device with cordova-plugin-device installed.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#isDevice
         * @return {Bool} True if device is defined, false otherwise.
         */
        self.isDevice = function() {
            return !!window.device;
        };

        /**
         * Returns whether we are online.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#isOnline
         * @return {Bool} True when we are.
         * @description
         * This methods returns whether the app is online or not.
         * Note that a browser is always considered being online.
         */
        self.isOnline = function() {
            var online = typeof navigator.connection === 'undefined' || $cordovaNetwork.isOnline();
            // Double check we are not online because we cannot rely 100% in Cordova APIs.
            if (!online && navigator.onLine) {
                online = true;
            }
            return online;
        };

        /*
         * Check if device uses a limited connection.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#isNetworkAccessLimited
         * @return {Boolean} True if device used a limited connection, false otherwise.
         * @description
         * This method allows for us to first check if cordova is loaded,
         * otherwise exceptions can be thrown when trying on a browser.
         */
        self.isNetworkAccessLimited = function() {
            if (typeof navigator.connection === 'undefined') {
                // Plugin not defined, probably in browser.
                return false;
            }
            var type = $cordovaNetwork.getNetwork();
            var limited = [Connection.CELL_2G, Connection.CELL_3G, Connection.CELL_4G, Connection.CELL];
            return limited.indexOf(type) > -1;
        };

        /**
         * Instantly returns if the app is ready.
         *
         * To be notified when the app is ready, refer to {@link $mmApp#ready}.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#ready
         * @return {Boolean} True when it is, false when not.
         */
        self.isReady = function() {
            var promise = $injector.get('$mmInitDelegate').ready();
            return promise.$$state.status === 1;
        };

        /**
         * Open the keyboard if plugin is available.
         *
         * @return {Boolean} True if plugin is available, false otherwise.
         */
        self.openKeyboard = function() {
            if (typeof cordova != 'undefined' && cordova.plugins && cordova.plugins.Keyboard && cordova.plugins.Keyboard.show) {
                cordova.plugins.Keyboard.show();
                return true;
            }
            return false;
        };

        /**
         * Resolves when the app is ready.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#ready
         * @description
         * This returns a promise that is resolved when the app is initialised.
         *
         * Usage:
         *
         *    $mmApp.ready().then(function() {
         *        // What you want to do.
         *    });
         *
         * @return {Promise} Resolved when the app is initialised. Never rejected.
         */
        self.ready = function() {
            // Injects to prevent circular dependencies.
            return $injector.get('$mmInitDelegate').ready();
        };

        return self;
    }];
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreConfigStore', 'config')

.config(["$mmAppProvider", "mmCoreConfigStore", function($mmAppProvider, mmCoreConfigStore) {
    var stores = [
        {
            name: mmCoreConfigStore,
            keyPath: 'name'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

/**
 * Factory to provide access to dynamic and permanent config and settings.
 * It should not be abused into a temporary storage.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmConfig
 * @description
 * Provides access to the app settings.
 */
.factory('$mmConfig', ["$q", "$log", "$mmApp", "mmCoreConfigStore", function($q, $log, $mmApp, mmCoreConfigStore) {

    $log = $log.getInstance('$mmConfig');

    var self = {};

    /**
     * Get an app setting.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmConfig#get
     * @param {String} name           The config name.
     * @param {Mixed}  [defaultValue] Default value to use if the entry is not found.
     * @return {Promise}              Resolves upon success along with the config data. Reject on failure.
     * @description
     * Get an app setting.
     */
    self.get = function(name, defaultValue) {
        return $mmApp.getDB().get(mmCoreConfigStore, name).then(function(entry) {
            return entry.value;
        }).catch(function() {
            if (typeof defaultValue != 'undefined') {
                return defaultValue;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Set an app setting.
     *
     * @module mm.core
     * @ngdoc service
     * @name $mmConfig#set
     * @param {String} name The config name.
     * @param {Mixed} value The config value.
     * @return {Promise}    Promise which resolves on success, providing no data.
     * @description
     * Set an app setting.
     */
    self.set = function(name, value) {
        return $mmApp.getDB().insert(mmCoreConfigStore, {name: name, value: value});
    };

    /**
     * Deletes an app setting.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmConfig#delete
     * @param {String} name The config name.
     * @return {Promise}    Promise which resolves on success, providing no data.
     * @description
     * Delete an app setting.
     */
    self.delete = function(name) {
        return $mmApp.getDB().remove(mmCoreConfigStore, name);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmDB
 * @module mm.core
 * @description
 * This service allows to interact with the local database to store and retrieve data.
 */
.factory('$mmDB', ["$q", "$log", function($q, $log) {

    $log = $log.getInstance('$mmDB');

    var self = {},
        dbInstances = {};

    /**
     * Convenient helper to apply an order to a query.
     *
     * @param  {Object}  [query]   A query object.
     * @param  {String}  [order]   The field to order on.
     * @param  {Boolean} [reverse] Whether to reverse the results.
     * @return {Object}  The updated query object (or initial one).
     */
    function applyOrder(query, order, reverse) {
        if (order) {
            query = query.order(order);
            if (reverse) {
                query = query.reverse();
            }
        }
        return query;
    }

    /**
     * Convenient helper to apply a where condition to a query.
     *
     * @param  {Object} [query]   A query object.
     * @param  {Array}  [where]   Array of parameters, in order:
     *                            - The field to filter on
     *                            - The operator: <, <=, =, >, >=, ^ (starts with)
     *                            - The value
     *                            - An additional operator
     *                            - An additional value
     * @return {Object} The updated query object (or initial one).
     */
    function applyWhere(query, where) {
        if (where && where.length > 0) {
            query = query.where.apply(query, where);
        }
        return query;
    }

    /**
     * Call a DB simple function.
     * @param  {Object}  db      DB to use.
     * @param  {String}  func    Name of the function to call.
     * @return {Promise}         Promise to be resolved when the operation finishes.
     */
    function callDBFunction(db, func) {
        var deferred = $q.defer();

        try {
            if (typeof(db) != 'undefined') {
                db[func].apply(db, Array.prototype.slice.call(arguments, 2)).then(function(result) {
                    if (typeof(result) == 'undefined') {
                        deferred.reject();
                    } else {
                        deferred.resolve(result);
                    }
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error executing function '+func+' to DB '+db.getName());
            $log.error(ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Retrieve the count of entries matching certain conditions.
     * @param  {Object}  db         DB to use.
     * @param  {String}  store      Name of the store to get the entries from.
     * @param  {Array}   where      Array of where conditions, see applyWhere.
     * @return {Promise}
     */
    function callCount(db, store, where) {
        var deferred = $q.defer(),
            query;

        try {
            if (typeof(db) != 'undefined') {
                query = db.from(store);
                query = applyWhere(query, where);
                query.count().then(function(count) {
                    deferred.resolve(count);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying db '+db.getName()+'. '+ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Retrieve the list of entries matching certain conditions.
     * @param  {Object}  db         DB to use.
     * @param  {String}  store      Name of the store to get the entries from.
     * @param  {String}  field_name Name of the field that should match the conditions.
     * @param  {String}  op         First operator symbol. One of '<', '<=', '=', '>', '>=', '^'.
     * @param  {String}  value      Value for the first operator.
     * @param  {String}  op2        Second operator symbol.
     * @param  {String}  value2     Value for the second operator.
     * @return {Promise}            Promise to be resolved when the list is retrieved.
     */
    function callWhere(db, store, field_name, op, value, op2, value2) {
        var deferred = $q.defer();

        try {
            if (typeof(db) != 'undefined') {
                db.from(store).where(field_name, op, value, op2, value2).list().then(function(list) {
                    deferred.resolve(list);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying db '+db.getName()+'. '+ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Retrieve the list of entries where a certain field is equal to a certain value.
     * Important: the field must be an index.
     * @param  {Object}  db         DB to use.
     * @param  {String}  store      Name of the store to get the entries from.
     * @param  {String}  field_name Name of the field to check.
     * @param  {String}  value      Value the field should be equal to.
     * @return {Promise}            Promise to be resolved when the list is retrieved.
     */
    function callWhereEqual(db, store, field_name, value) {
        var deferred = $q.defer();

        try {
            if (typeof(db) != 'undefined') {
                db.from(store).where(field_name, '=', value).list().then(function(list) {
                    deferred.resolve(list);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error getting where equal from db '+db.getName()+'. '+ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Performs an operation with every entry in a certain store.
     * @param  {Object}   db       DB to use.
     * @param  {String}   store    Name of the store to get the entries from.
     * @param  {Function} callback Function to call with each entry.
     * @return {Promise}           Promise to be resolved when the the operation has been applied to all entries.
     */
    function callEach(db, store, callback) {
        var deferred = $q.defer();

        callDBFunction(db, 'values', store, undefined, 99999999).then(function(entries) {
            for (var i = 0; i < entries.length; i++) {
                callback(entries[i]);
            }
            deferred.resolve();
        }, function() {
            deferred.reject();
        });

        return deferred.promise;
    }

    /**
     * Retrieve the list of entries matching certain conditions.
     *
     * @param  {Object}  db      DB to use.
     * @param  {String}  store   Name of the store to get the entries from.
     * @param  {Array}   where   Array of where conditions, see applyWhere.
     * @param  {Array}   order   The key to order on.
     * @param  {Boolean} reverse Whether to reverse the order.
     * @param  {Number}  limit   The number of result to return.
     * @return {Promise}
     */
    function doQuery(db, store, where, order, reverse, limit) {
        var deferred = $q.defer(),
            query;

        try {
            if (typeof(db) != 'undefined') {
                query = db.from(store);
                query = applyWhere(query, where);
                query = applyOrder(query, order, reverse);
                query.list(limit).then(function(list) {
                    deferred.resolve(list);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying ' + store + ' on ' + db.getName() + '. ' + ex.name + ': ' + ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Update a list of entries matching conditions.
     *
     * @param  {Object}  db      DB to use.
     * @param  {String}  store   Name of the store to get the entries from.
     * @param  {Object}  values  The values to set.
     * @param  {Array}   where   An array of where() parameters.
     * @return {Promise}
     */
    function doUpdate(db, store, values, where) {
        var deferred = $q.defer(),
            query;

        try {
            if (typeof(db) != 'undefined') {
                query = db.from(store);
                query = applyWhere(query, where);
                query.patch(values).then(function(count) {
                    deferred.resolve(count);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying ' + store + ' on ' + db.getName() + '. ' + ex.name + ': ' + ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Create a new database object.
     *
     * The database objects are cached statically.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmDB#getDB
     * @param  {String} name    DB name.
     * @param  {Object} schema  DB schema.
     * @param  {Object} options DB options.
     * @return {Object}         DB.
     */
    self.getDB = function(name, schema, options) {
        if (typeof dbInstances[name] === 'undefined') {

            var isSafari = !ionic.Platform.isIOS() && !ionic.Platform.isAndroid() && navigator.userAgent.indexOf('Safari') != -1
                            && navigator.userAgent.indexOf('Chrome') == -1 && navigator.userAgent.indexOf('Firefox') == -1;
            if (typeof IDBObjectStore == 'undefined' || typeof IDBObjectStore.prototype.count == 'undefined' || isSafari) {
                // IndexedDB not implemented or not fully implemented (Galaxy S4 Mini). Use WebSQL.
                if (typeof options.mechanisms == 'undefined') {
                    options.mechanisms = ['websql', 'sqlite', 'localstorage', 'sessionstorage', 'userdata', 'memory'];
                } else {
                    var position = options.mechanisms.indexOf('indexeddb');
                    if (position != -1) {
                        options.mechanisms.splice(position, 1);
                    }
                }
            }

            var db = new ydn.db.Storage(name, schema, options);

            dbInstances[name] = {
                /**
                 * Get DB name.
                 *
                 * @return {String} DB name.
                 */
                getName: function() {
                    return db.getName();
                },
                /**
                 * Get an entry from a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Mixed}  id    Entry's identifier (primary key / keyPath).
                 * @return {Promise}     Promise resolved when the entry is retrieved. Resolve param: DB entry (object).
                 */
                get: function(store, id) {
                    return callDBFunction(db, 'get', store, id);
                },
                /**
                 * Get all the entries from a store.
                 *
                 * @param {String} store Name of the store.
                 * @return {Promise}     Promise resolved when the entries are retrieved. Resolve param: DB entries (array).
                 */
                getAll: function(store) {
                    return callDBFunction(db, 'values', store, undefined, 99999999);
                },
                /**
                 * Count the number of entries in a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Array} [where] Array of where conditions, see applyWhere.
                 * @return {Promise}     Promise resolved when the count is done. Resolve param: number of entries.
                 */
                count: function(store, where) {
                    return callCount(db, store, where);
                },
                /**
                 * Add an entry to a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Object} value Object to store. Primary key (keyPath) is required.
                 * @param {IDbKey} id The key when needed.
                 * @return {Promise}     Promise resolved when the entry is inserted. Resolve param: new entry's primary key.
                 */
                insert: function(store, value, id) {
                    return callDBFunction(db, 'put', store, value, id);
                },
                /**
                 * Add an entry to a store, returning a synchronous value.
                 * Please use this function only if synchronous is a must, you should always use $mmDB#insert.
                 * Take into account that the value will be returned BEFORE the value is actually stored. The value of the
                 * boolean returned only indicates if it has passed the first validation.
                 *
                 * @param {String} store Name of the store.
                 * @param {Object} value Object to store. Primary key (keyPath) is required.
                 * @return {Boolean}     True if data to insert is valid, false otherwise. Returning true doesn't mean that the
                 *                       data has been stored, this function can return true but the insertion can still fail.
                 */
                insertSync: function(store, value) {
                    if (db) {
                        try {
                            db.put(store, value);
                            return true;
                        } catch(ex) {
                            $log.error('Error executing function sync put to DB '+db.getName());
                            $log.error(ex.name+': '+ex.message);
                        }
                    }

                    return false;
                },
                /**
                 * Query the database.
                 *
                 * @param {String} store Name of the store.
                 * @param {Array} [where] Array of where conditions, see applyWhere.
                 * @param {String} [order] The key to sort the results with.
                 * @param {Boolean} [reverse=false] Whether to reverse the results.
                 * @param {Number} [limit] The number of results to return.
                 * @return {Promise} Promise resolved with an array of entries.
                 */
                query: function(store, where, order, reverse, limit) {
                    return doQuery(db, store, where, order, reverse, limit);
                },
                /**
                 * Removes an entry from a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Mixed}  id    Entry's identifier (primary key / keyPath).
                 * @return {Promise}     Promise resolved when the entry is deleted. Resolve param: number of entries deleted.
                 */
                remove: function(store, id) {
                    return callDBFunction(db, 'remove', store, id);
                },
                /**
                 * Removes all entries from a store.
                 *
                 * @param {String} store Name of the store.
                 * @return {Promise}     Promise resolved when the entries are deleted.
                 */
                removeAll: function(store) {
                    return callDBFunction(db, 'clear', store);
                },
                /**
                 * Update records matching.
                 *
                 * @param {String} store Name of the store.
                 * @param {Object} values The values to update.
                 * @param {Array} [where] Array of where conditions, see applyWhere.
                 * @return {Promise}
                 */
                update: function(store, values, where) {
                    return doUpdate(db, store, values, where);
                },
                /**
                 * Get the entries where a field match certain conditions.
                 *
                 * @param {String} store      Name of the store.
                 * @param {String} field_name Name of the field to match.
                 * @param {String} op         First operator to apply to the field. <, <=, =, >, >=, ^ (start with).
                 * @param {Mixed}  value      Value to compare using the first operator.
                 * @param {String} op2        Second operator to apply to the field. Optional.
                 * @param {Mixed}  value2     Value to compare using the second operator. Optional.
                 * @return {Promise}          Promise resolved when the entries are retrieved. Resolve param: entries (array).
                 */
                where: function(store, field_name, op, value, op2, value2) {
                    return callWhere(db, store, field_name, op, value, op2, value2);
                },
                /**
                 * Get the entries where a field is equal to a certain value.
                 *
                 * @param {String} store      Name of the store.
                 * @param {String} field_name Name of the field to match.
                 * @param {Mixed}  value      Value to compare to the field.
                 * @return {Promise}          Promise resolved when the entries are retrieved. Resolve param: entries (array).
                 */
                whereEqual: function(store, field_name, value) {
                    return callWhereEqual(db, store, field_name, value);
                },
                /**
                 * Call a function with each of the entries from a store.
                 *
                 * @param {String} store      Name of the store.
                 * @param {Function} callback Function to call with each entry.
                 * @return {Promise}          Promise resolved when the function is called for all entries. No resolve params.
                 */
                each: function(store, callback) {
                    return callEach(db, store, callback);
                },
                /**
                 * Close the database.
                 */
                close: function() {
                    db.close();
                    db = undefined;
                },
                /**
                 * Call a callback once DB is ready.
                 *
                 * @param {Function} cb Callback to call.
                 */
                onReady: function(cb) {
                    db.onReady(cb);
                },
                /**
                 * Get storage type.
                 *
                 * @return {String} Storage type.
                 */
                getType: function() {
                    return db.getType();
                }
            };
        }
        return dbInstances[name];
    };

    /**
     * Delete a DB.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmDB#deleteDB
     * @param  {String} name   DB name.
     * @return {Promise}       Promise to be resolved when the site DB is deleted.
     */
    self.deleteDB = function(name) {
        var deferred = $q.defer();

        function deleteDB() {
            delete dbInstances[name];
            $q.when(ydn.db.deleteDatabase(name)).then(deferred.resolve, deferred.reject);
        }

        if (typeof dbInstances[name] != 'undefined') {
            // We have a DB instance. Wait for it to be ready before deleting the DB.
            dbInstances[name].onReady(deleteDB);
        } else {
            deleteDB();
        }

        return deferred.promise;
    };

    return self;

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmEmulatorManager
 * @module mm.core
 * @description
 * This service handles the emulation of Cordova plugins in other environments like browser.
 */
.factory('$mmEmulatorManager', ["$log", "$q", "$http", "$mmFS", "$window", function($log, $q, $http, $mmFS, $window) {

    $log = $log.getInstance('$mmEmulatorManager');

    var self = {};

    /**
     * Loads HTML API to simulate Cordova APIs. Reserved for core use.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEmulatorManager#loadHTMLAPI
     * @return {Promise} Promise resolved when the API is loaded.
     * @protected
     */
    self.loadHTMLAPI = function() {

        if ($mmFS.isAvailable()) {
            $log.debug('Stop loading HTML API, it was already loaded or the environment doesn\'t need it.');
            return $q.when();
        }

        var deferred = $q.defer(),
            basePath;

        $log.debug('Loading HTML API.');

        // File API.
        $window.requestFileSystem  = $window.requestFileSystem || $window.webkitRequestFileSystem;
        $window.resolveLocalFileSystemURL = $window.resolveLocalFileSystemURL || $window.webkitResolveLocalFileSystemURL;

        $window.LocalFileSystem = {
            PERSISTENT: 1
        };

        // FileTransfer API.
        $window.FileTransfer = function() {};

        $window.FileTransfer.prototype.download = function(url, filePath, successCallback, errorCallback) {
            $http.get(url, {responseType: 'blob'}).then(function(data) {
                if (!data || !data.data) {
                    errorCallback();
                } else {
                    filePath = filePath.replace(basePath, ''); // Remove basePath from the filePath.
                    $mmFS.writeFile(filePath, data.data).then(function(e) {
                        successCallback(e);
                    }).catch(function(error) {
                        errorCallback(error);
                    });
                }
            }).catch(function(error) {
                errorCallback(error);
            });
        };

        // Cordova ZIP plugin.
        $window.zip = {
            unzip: function(source, destination, callback, progressCallback) {
                // Remove basePath from the source and destination.
                source = source.replace(basePath, '');
                destination = destination.replace(basePath, '');

                $mmFS.readFile(source, $mmFS.FORMATARRAYBUFFER).then(function(data) {
                    var zip = new JSZip(data),
                        promises = [];

                    angular.forEach(zip.files, function(file, name) {
                        var filepath = $mmFS.concatenatePaths(destination, name),
                            type;

                        if (!file.dir) {
                            // It's a file. Get the mimetype and write the file.
                            type = $mmFS.getMimeType($mmFS.getFileExtension(name));
                            promises.push($mmFS.writeFile(filepath, new Blob([file.asArrayBuffer()], {type: type})));
                        } else {
                            // It's a folder, create it if it doesn't exist.
                            promises.push($mmFS.createDir(filepath));
                        }
                    });

                    return $q.all(promises).then(function() {
                        // Success.
                        callback(0);
                    });
                }).catch(function() {
                    // Error.
                    callback(-1);
                });
            }
        };

        // @todo: Implement FileTransfer.upload.

        // Request 500MB.
        $window.webkitStorageInfo.requestQuota(PERSISTENT, 500 * 1024 * 1024, function(granted) {
            $window.requestFileSystem(PERSISTENT, granted, function(entry) {
                basePath = entry.root.toURL();
                $mmFS.setHTMLBasePath(basePath);
                deferred.resolve();
            }, deferred.reject);
        }, deferred.reject);

        return deferred.promise;
    };

    return self;
}])

.config(["$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {
    if (!ionic.Platform.isWebView()) {
        $mmInitDelegateProvider.registerProcess('mmEmulator', '$mmEmulatorManager.loadHTMLAPI',
                mmInitDelegateMaxAddonPriority + 500, true);
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreEventKeyboardShow', 'keyboard_show')
.constant('mmCoreEventKeyboardHide', 'keyboard_hide')
.constant('mmCoreEventSessionExpired', 'session_expired')
.constant('mmCoreEventLogin', 'login')
.constant('mmCoreEventLogout', 'logout')
.constant('mmCoreEventLanguageChanged', 'language_changed')
.constant('mmCoreEventSiteAdded', 'site_added')
.constant('mmCoreEventSiteUpdated', 'site_updated')
.constant('mmCoreEventSiteDeleted', 'site_deleted')
.constant('mmCoreEventQueueEmpty', 'filepool_queue_empty')
.constant('mmCoreEventCompletionModuleViewed', 'completion_module_viewed')
.constant('mmCoreEventUserDeleted', 'user_deleted')
.constant('mmCoreEventPackageStatusChanged', 'filepool_package_status_changed')
.constant('mmCoreEventSectionStatusChanged', 'section_status_changed')

/**
 * Service to send and listen to events.
 *
 * @ngdoc service
 * @name $mmEvents
 * @module mm.core
 * @description
 * This service allows sending and listening to events in the Moodle Mobile app.
 */
.factory('$mmEvents', ["$log", "md5", function($log, md5) {

    $log = $log.getInstance('$mmEvents');

    var self = {},
        observers = {},
        uniqueEvents = {},
        uniqueEventsData = {};

    /**
     * Adds an observer for a certain event.
     * To deregister the event:
     * var observer = $mmEvents.on('something', myCallBack);
     * observer.off();
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEvents#on
     * @param  {String}   eventName  Name of the event to listen to.
     * @param  {Function} callBack   Function to call when the event is triggered.
     * @return {Object}              Object to deregister the observer. Undefined if it's an already triggered unique event.
     */
    self.on = function(eventName, callBack) {

        // If it's a unique event and has been triggered already, call the callBack.
        // We don't need to store the observer because the event won't be triggered again.
        if (uniqueEvents[eventName]) {
            callBack(uniqueEventsData[eventName]);
            // Return a fake observer to prevent errors.
            return {
                id: -1,
                off: function() {}
            };
        }

        var observerID;

        if (typeof(observers[eventName]) === 'undefined') {
            observers[eventName] = {};
        }

        while (typeof(observerID) === 'undefined') {
            var candidateID = md5.createHash(Math.random().toString());
            if (typeof(observers[eventName][candidateID]) === 'undefined') {
                observerID = candidateID;
            }
        }
        $log.debug('Observer ' + observerID + ' listening to event '+eventName);

        observers[eventName][observerID] = callBack;

        // Create observer object to deregister the listener.
        var observer = {
            id: observerID,
            off: function() {
                $log.debug('Disable observer ' + observerID + ' for event '+eventName);
                delete observers[eventName][observerID];
            }
        };
        return observer;
    };

    /**
     * Triggers an event, notifying all the observers.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEvents#trigger
     * @param {String} event Name of the event to trigger.
     * @param {Mixed}  data  Data to pass to the observers.
     */
    self.trigger = function(eventName, data) {
        $log.debug('Event ' + eventName + ' triggered.');
        var affected = observers[eventName];
        for (var observerName in affected) {
            if (typeof(affected[observerName]) === 'function') {
                affected[observerName](data);
            }
        }
    };

    /**
     * Triggers a unique event, notifying all the observers. If the event has already been triggered, don't do anything.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEvents#trigger
     * @param {String} event Name of the event to trigger.
     * @param {Mixed}  data  Data to pass to the observers.
     */
    self.triggerUnique = function(eventName, data) {
        if (uniqueEvents[eventName]) {
            $log.debug('Unique event ' + eventName + ' ignored because it was already triggered.');
        } else {
            $log.debug('Unique event ' + eventName + ' triggered.');
            uniqueEvents[eventName] = true;
            uniqueEventsData[eventName] = data;
            var affected = observers[eventName];
            angular.forEach(affected, function(callBack) {
                if (typeof callBack === 'function') {
                    callBack(data);
                }
            });
        }
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmFilepoolQueueProcessInterval', 0)
.constant('mmFilepoolFolder', 'filepool')
.constant('mmFilepoolStore', 'filepool')
.constant('mmFilepoolQueueStore', 'files_queue')
.constant('mmFilepoolLinksStore', 'files_links')
.constant('mmFilepoolPackagesStore', 'filepool_packages')

.config(["$mmAppProvider", "$mmSitesFactoryProvider", "mmFilepoolStore", "mmFilepoolLinksStore", "mmFilepoolQueueStore", "mmFilepoolPackagesStore", function($mmAppProvider, $mmSitesFactoryProvider, mmFilepoolStore, mmFilepoolLinksStore, mmFilepoolQueueStore,
            mmFilepoolPackagesStore) {
    var siteStores = [
        {
            // File store.
            //
            // Each entry should contain:
            // - fileId: A hash of the file info.
            // - url: URL to download the file.
            // - modified: The time at which the file was last downloaded.
            // - stale: When true, it means that the file should be redownloaded.
            // - etag: Store the ETAG code of the file.
            name: mmFilepoolStore,
            keyPath: 'fileId',
            indexes: []
        },
        {
            // Associations between files and components.
            //
            // Each entry should contain:
            // - fileId: Hash used in the file store.
            // - component: The component name (e.g. mmaModPage).
            // - componentId: An ID that can be used by the component. -1 when not provided.
            name: mmFilepoolLinksStore,
            keyPath: ['fileId', 'component', 'componentId'],
            indexes: [
                {
                    name: 'fileId',
                },
                {
                    name: 'component',
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'componentAndId',
                    generator: function(obj) {
                        return [obj.component, obj.componentId];
                    }
                }
            ]
        },
        {
            // Packages store.
            //
            // Each entry should contain:
            // - id: The package ID. See {@link $mmFilepool#getPackageId}
            // - component: Package's component.
            // - componentId: Package's componentId.
            // - status: The package status: mmCoreDownloaded, mmCoreDownloading, etc.
            // - previous: (optional) The package previous status.
            // - revision: The package revision.
            // - timemodified: The package timemodified.
            // - updated: When was the entry updated for the last time.
            name: mmFilepoolPackagesStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'component',
                },
                {
                    name: 'componentId',
                },
                {
                    name: 'status',
                }
            ]
        }
    ];
    var appStores = [
        {
            // Files queue.
            //
            // Each entry should contain:
            // - siteId: The site ID.
            // - fileId: A hash of the file info.
            // - url: URL to download the file.
            // - added: Timestamp (in milliseconds) at which the file was added to the queue.
            // - priority: Indicates which files should be treated first. Maximum value is 999.
            // - links: Array of objects containing component and ID to create links once the file has been processed.
            name: mmFilepoolQueueStore,
            keyPath: ['siteId', 'fileId'],
            indexes: [
                {
                    name: 'siteId',
                },
                {
                    name: 'sortorder',
                    generator: function(obj) {
                        // Creates an index to sort the queue items by priority, sort is ascending.
                        // The oldest are considered to be the most important ones.
                        // The additional priority argument allows to bump any queue item on top of the queue.
                        // The index will look as follow:
                        //    [999 - priority] + "-" + timestamp
                        //    "999-1431491086913": item without priority.
                        //    "900-1431491086913": item with priority of 99.
                        //    "000-1431491086913": item with max priority.

                        var sortorder = parseInt(obj.added, 10),
                            priority = 999 - Math.max(0, Math.min(parseInt(obj.priority || 0, 10), 999)),
                            padding = "000";

                        // Convert to strings.
                        sortorder = "" + sortorder;
                        priority = "" + priority;

                        // Final format.
                        priority = padding.substring(0, padding.length - priority.length) + priority;
                        sortorder = priority + '-' + sortorder;

                        return sortorder;
                    }
                }
            ]
        }
    ];
    $mmAppProvider.registerStores(appStores);
    $mmSitesFactoryProvider.registerStores(siteStores);
}])

/**
 * Factory for handling the files in the pool.
 *
 * @module mm.core
 * @ngdoc factory
 * @name $mmFilepool
 * @todo Use transactions (e.g. when querying, then updating)
 * @todo Setting files as stale after a certain time
 * @todo Use ETAGs
 * @todo Do not download on limited network
 * @description
 *
 * This factory is responsible for handling external content.
 *
 * It will always try to get a file from the filepool and return it, when the file is not
 * found it will be added to a queue to be downloaded later. The two main goals of this
 * is to keep the content available offline, and improve the user experience by caching
 * the content locally.
 *
 * The filepool has a very limited understanding of pluginfiles, you should always call
 * {@link $mmUtil#fixPluginfileURL} prior to passing the URL. The reason for this is to
 * allow for any type of URL to be handled here. We can download and cache content
 * that is not served by Moodle. The only little handling of pluginfile is located in
 * {@link $mmFilepool#_getFileIdByUrl}.
 */
.factory('$mmFilepool', ["$q", "$log", "$timeout", "$mmApp", "$mmFS", "$mmWS", "$mmSitesManager", "$mmEvents", "md5", "mmFilepoolStore", "mmFilepoolLinksStore", "mmFilepoolQueueStore", "mmFilepoolFolder", "mmFilepoolQueueProcessInterval", "mmCoreEventQueueEmpty", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreNotDownloadable", "mmFilepoolPackagesStore", "mmCoreEventPackageStatusChanged", function($q, $log, $timeout, $mmApp, $mmFS, $mmWS, $mmSitesManager, $mmEvents, md5, mmFilepoolStore,
        mmFilepoolLinksStore, mmFilepoolQueueStore, mmFilepoolFolder, mmFilepoolQueueProcessInterval, mmCoreEventQueueEmpty,
        mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreNotDownloadable, mmFilepoolPackagesStore,
        mmCoreEventPackageStatusChanged) {

    $log = $log.getInstance('$mmFilepool');

    var self = {},
        extensionRegex = new RegExp('^[a-z0-9]+$'),
        tokenRegex = new RegExp('(\\?|&)token=([A-Za-z0-9]+)'),
        queueState,
        urlAttributes = [
            tokenRegex,
            new RegExp('(\\?|&)forcedownload=[0-1]')
        ],
        revisionRegex = new RegExp('/content/([0-9]+)/'),
        queueDeferreds = {}, // To handle file downloads using the queue.
        packagesPromises = {}, // To prevent downloading packages twice at the same time.
        filePromises = {}; // To prevent downloading files twice at the same time.

    // Queue status codes.
    var QUEUE_RUNNING = 'mmFilepool:QUEUE_RUNNING',
        QUEUE_PAUSED = 'mmFilepool:QUEUE_PAUSED';

    // Error codes.
    var ERR_QUEUE_IS_EMPTY = 'mmFilepoolError:ERR_QUEUE_IS_EMPTY',
        ERR_FS_OR_NETWORK_UNAVAILABLE = 'mmFilepoolError:ERR_FS_OR_NETWORK_UNAVAILABLE',
        ERR_QUEUE_ON_PAUSE = 'mmFilepoolError:ERR_QUEUE_ON_PAUSE';

    /**
     * Files states. Deprecated, please use core constants instead: mmCoreDownloaded, mmCoreDownloading, ...
     * @deprecated since version 2.6
     */
    self.FILEDOWNLOADED = 'downloaded';
    self.FILEDOWNLOADING = 'downloading';
    self.FILENOTDOWNLOADED = 'notdownloaded';
    self.FILEOUTDATED = 'outdated';

    /**
     * Convenient site DB getter.
     */
    function getSiteDb(siteId) {
        return $mmSitesManager.getSiteDb(siteId);
    }

    /**
     * Link a file with a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_addFileLink
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._addFileLink = function(siteId, fileId, component, componentId) {
        if (!component) {
            return $q.reject();
        }

        componentId = self._fixComponentId(componentId);
        return getSiteDb(siteId).then(function(db) {
            return db.insert(mmFilepoolLinksStore, {
                fileId: fileId,
                component: component,
                componentId: componentId
            });
        });
    };

    /**
     * Link a file with a component by URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#addFileLinkByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file Url.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @description
     * Use this method to create a link between a URL and a component. You usually do not need to call
     * this manually as adding a file to queue allows you to do so. Note that this method
     * does not check if the file exists in the pool, so you probably want to use is after
     * a successful {@link $mmFilepool#downloadUrl}.
     */
    self.addFileLinkByUrl = function(siteId, fileUrl, component, componentId) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._addFileLink(siteId, fileId, component, componentId);
        });
    };

    /**
     * Link a file with a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_addFileLinks
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @param {Object[]} links Array of objects containing the link component and optionally componentId.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._addFileLinks = function(siteId, fileId, links) {
        var promises = [];
        angular.forEach(links, function(link) {
            promises.push(self._addFileLink(siteId, fileId, link.component, link.componentId));
        });
        return $q.all(promises);
    };

    /**
     * Add a file to the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_addFileToPool
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @param {Object} data Additional information to store about the file (timemodified, url, ...). See mmFilepoolStore schema.
     * @return {Promise}
     * @protected
     * @description
     * Note that this method will override any existing entry with the same key.
     * That is the only way to update an entry.
     */
    self._addFileToPool = function(siteId, fileId, data) {
        var values = angular.copy(data) || {};
        values.fileId = fileId;
        return getSiteDb(siteId).then(function(db) {
            return db.insert(mmFilepoolStore, values);
        });
    };

    /**
     * Add an entry to queue using a URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#addToQueueByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} [component] The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component (optional).
     * @param {Number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {String} [filePath]       Filepath to download the file to.
     * @param {Number} [priority=0] The priority this file should get in the queue (range 0-999).
     * @return {Promise} Resolved on success. The returned value can be inconsistent, do not use.
     */
    self.addToQueueByUrl = function(siteId, fileUrl, component, componentId, timemodified, filePath, priority) {
        var db = $mmApp.getDB(),
            fileId,
            now = new Date(),
            link,
            revision,
            queueDeferred;

        if (!$mmFS.isAvailable()) {
            return $q.reject();
        }

        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {

            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            fileId = self._getFileIdByUrl(fileUrl);
            priority = priority || 0;

            // Set up the component.
            if (typeof component !== 'undefined') {
                link = {
                    component: component,
                    componentId: componentId
                };
            }

            // Retrieve the queue deferred now if it exists to prevent errors if file is removed from queue
            // while we're checking if the file is in queue.
            queueDeferred = self._getQueueDeferred(siteId, fileId, false);

            return db.get(mmFilepoolQueueStore, [siteId, fileId]).then(function(fileObject) {
                var foundLink = false,
                    update = false;

                if (fileObject) {
                    // We already have the file in queue, we update the priority and links.
                    if (fileObject.priority < priority) {
                        update = true;
                        fileObject.priority = priority;
                    }
                    if (revision && fileObject.revision !== revision) {
                        update = true;
                        fileObject.revision = revision;
                    }
                    if (timemodified && fileObject.timemodified !== timemodified) {
                        update = true;
                        fileObject.timemodified = timemodified;
                    }
                    if (filePath && fileObject.path !== filePath) {
                        update = true;
                        fileObject.path = filePath;
                    }

                    if (link) {
                        // We need to add the new link if it does not exist yet.
                        angular.forEach(fileObject.links, function(fileLink) {
                            if (fileLink.component == link.component && fileLink.componentId == link.componentId) {
                                foundLink = true;
                            }
                        });
                        if (!foundLink) {
                            update = true;
                            fileObject.links.push(link);
                        }
                    }

                    if (update) {
                        // Update only when required.
                        $log.debug('Updating file ' + fileId + ' which is already in queue');
                        return db.insert(mmFilepoolQueueStore, fileObject).then(function() {
                            return self._getQueuePromise(siteId, fileId);
                        });
                    }

                    $log.debug('File ' + fileId + ' already in queue and does not require update');
                    if (queueDeferred) {
                        // If we were able to retrieve the queue deferred before we use that one, since the file download
                        // might have finished now and the deferred wouldn't be in the array anymore.
                        return queueDeferred.promise;
                    } else {
                        return self._getQueuePromise(siteId, fileId);
                    }
                } else {
                    return addToQueue();
                }
            }, function() {
                // Unsure why we could not get the record, let's add to the queue anyway.
                return addToQueue();
            });

            function addToQueue() {
                $log.debug('Adding ' + fileId + ' to the queue');
                return db.insert(mmFilepoolQueueStore, {
                    siteId: siteId,
                    fileId: fileId,
                    added: now.getTime(),
                    priority: priority,
                    url: fileUrl,
                    revision: revision,
                    timemodified: timemodified,
                    path: filePath,
                    links: link ? [link] : []
                }).then(function() {
                    // Check if the queue is running.
                    self.checkQueueProcessing();
                    return self._getQueuePromise(siteId, fileId);
                });
            }
        });
    };

    /**
     * Check the queue processing.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#checkQueueProcessing
     * @return {Void}
     * @description
     * In mose cases, this will enable the queue processing if it was paused.
     * Though, this will disable the queue if we are missing network or if the file system
     * is not accessible. Also, this will have no effect if the queue is already running.
     *
     * Do not use directly, it is reserved for core use.
     */
    self.checkQueueProcessing = function() {

        if (!$mmFS.isAvailable() || !$mmApp.isOnline()) {
            queueState = QUEUE_PAUSED;
            return;

        } else if (queueState === QUEUE_RUNNING) {
            return;
        }

        queueState = QUEUE_RUNNING;
        self._processQueue();
    };

    /**
     * Clear all packages status in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#clearAllPackagesStatus
     * @param {String} siteId Site ID.
     * @return {Promise}      Promise resolved when all status are cleared.
     */
    self.clearAllPackagesStatus = function(siteId) {
        var promises = [];
        $log.debug('Clear all packages status for site ' + siteId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb();
            return db.getAll(mmFilepoolPackagesStore).then(function(entries) {
                angular.forEach(entries, function(entry) {
                    promises.push(db.remove(mmFilepoolPackagesStore, entry.id).then(function() {
                        // Trigger module status changed, setting it as not downloaded.
                        self._triggerPackageStatusChanged(siteId, entry.component, entry.componentId, mmCoreNotDownloaded);
                    }));
                });
                return $q.all(promises);
            });
        });
    };

    /**
     * Clears the filepool. Use it only when all the files from a site are deleted.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#clearFilepool
     * @param  {String} siteId ID of the site to clear.
     * @return {Promise}       Promise resolved when the filepool is cleared.
     */
    self.clearFilepool = function(siteId) {
        return getSiteDb(siteId).then(function(db) {
            return db.removeAll(mmFilepoolStore);
        });
    };

    /**
     * Returns whether a component has files in the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#componentHasFiles
     * @param {String} siteId The site ID.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved means yes, rejected means no.
     */
    self.componentHasFiles = function(siteId, component, componentId) {
        return getSiteDb(siteId).then(function(db) {
            var where;
            if (typeof componentId !== 'undefined') {
                where = ['componentAndId', '=', [component, self._fixComponentId(componentId)]];
            } else {
                where = ['component', '=', component];
            }
            return db.count(mmFilepoolLinksStore, where).then(function(count) {
                if (count > 0) {
                    return true;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Given the current status of a list of packages and the status of one of the packages,
     * determine the new status for the list of packages. The status of a list of packages is:
     *     - mmCoreNotDownloadable if there are no downloadable packages.
     *     - mmCoreNotDownloaded if at least 1 package has status mmCoreNotDownloaded.
     *     - mmCoreDownloaded if ALL the downloadable packages have status mmCoreDownloaded.
     *     - mmCoreDownloading if ALL the downloadable packages have status mmCoreDownloading or mmCoreDownloaded,
     *                                     with at least 1 package with mmCoreDownloading.
     *     - mmCoreOutdated if ALL the downloadable packages have status mmCoreOutdated or mmCoreDownloaded or
     *                                     mmCoreDownloading, with at least 1 package with mmCoreOutdated.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#determinePackagesStatus
     * @param {String} current       Current status of the list of packages.
     * @param {String} packagestatus Status of one of the packages.
     * @return {String}              New status for the list of packages;
     */
    self.determinePackagesStatus = function(current, packagestatus) {
        if (!current) {
            current = mmCoreNotDownloadable;
        }

        if (packagestatus === mmCoreNotDownloaded) {
            // If 1 package is not downloaded the status of the whole list will always be not downloaded.
            return mmCoreNotDownloaded;
        } else if (packagestatus === mmCoreDownloaded && current === mmCoreNotDownloadable) {
            // If all packages are downloaded or not downloadable with at least 1 downloaded, status will be downloaded.
            return mmCoreDownloaded;
        } else if (packagestatus === mmCoreDownloading && (current === mmCoreNotDownloadable || current === mmCoreDownloaded)) {
            // If all packages are downloading/downloaded/notdownloadable with at least 1 downloading, status will be downloading.
            return mmCoreDownloading;
        } else if (packagestatus === mmCoreOutdated && current !== mmCoreNotDownloaded) {
            // If there are no packages notdownloaded and there is at least 1 outdated, status will be outdated.
            return mmCoreOutdated;
        }

        // Status remains the same.
        return current;
    };

    /**
     * Downloads or prefetches a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_downloadOrPrefetchPackage
     * @param {String} siteId        The site ID.
     * @param  {Object[]} fileList   List of files to download.
     * @param  {Boolean} prefetch    True if should prefetch the contents (queue), false if they should be downloaded right now.
     * @param {String} component     The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [revision]    Package's revision. If not defined, it will be calculated using the list of files.
     * @param {Number} [timemod]     Package's timemodified. If not defined, it will be calculated using the list of files.
     * @param {String} [dirPath]     Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                               the files directly inside the filepool folder.
     * @return {Promise}             Promise resolved when all files are downloaded.
     * @protected
     */
    self._downloadOrPrefetchPackage = function(siteId, fileList, prefetch, component, componentId, revision, timemod, dirPath) {

        var packageId = self.getPackageId(component, componentId);

        if (packagesPromises[siteId] && packagesPromises[siteId][packageId]) {
            // There's already a download ongoing for this package, return the promise.
            return packagesPromises[siteId][packageId];
        } else if (!packagesPromises[siteId]) {
            packagesPromises[siteId] = {};
        }

        revision = revision || self.getRevisionFromFileList(fileList);
        timemod = timemod || self.getTimemodifiedFromFileList(fileList);

        var dwnPromise,
            deleted = false;

        // Set package as downloading.
        dwnPromise = self.storePackageStatus(siteId, component, componentId, mmCoreDownloading, revision, timemod).then(function() {
            var promises = [],
                deferred = $q.defer(),
                packageLoaded = 0; // Use a deferred to be able to use notify.

            angular.forEach(fileList, function(file) {
                var path,
                    promise,
                    fileLoaded = 0;

                if (dirPath) {
                    // Calculate the path to the file.
                    path = file.filename;
                    if (file.filepath !== '/') {
                        path = file.filepath.substr(1) + path;
                    }
                    path = $mmFS.concatenatePaths(dirPath, path);
                }

                if (prefetch) {
                    promise = self.addToQueueByUrl(siteId, file.fileurl, component, componentId, file.timemodified, path);
                } else {
                    promise = self.downloadUrl(siteId, file.fileurl, false, component, componentId, file.timemodified, path);
                }

                // Using undefined for success & fail will pass the success/failure to the parent promise.
                promises.push(promise.then(undefined, undefined, function(progress) {
                    if (progress && progress.loaded) {
                        // Add the new size loaded to the package loaded.
                        packageLoaded = packageLoaded + (progress.loaded - fileLoaded);
                        fileLoaded = progress.loaded;
                        deferred.notify({
                            packageDownload: true,
                            loaded: packageLoaded,
                            fileProgress: progress
                        });
                    }
                }));
            });

            $q.all(promises).then(function() {
                // Success prefetching, store package as downloaded.
                return self.storePackageStatus(siteId, component, componentId, mmCoreDownloaded, revision, timemod);
            }).catch(function() {
                // Error downloading, go back to previous status and reject the promise.
                return self.setPackagePreviousStatus(siteId, component, componentId).then(function() {
                    return $q.reject();
                });
            }).then(deferred.resolve, deferred.reject);

            return deferred.promise;
        }).finally(function() {
            // Download finished, delete the promise.
            delete packagesPromises[siteId][packageId];
            deleted = true;
        });

        if (!deleted) { // In case promise was finished immediately.
            packagesPromises[siteId][packageId] = dwnPromise;
        }
        return dwnPromise;
    };

    /**
     * Downloads a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#downloadPackage
     * @param {String} siteId         The site ID.
     * @param  {Object[]} fileList    List of files to download.
     * @param {String} component      The component to link the file to.
     * @param {Number} componentId    An ID to identify the download. Must be unique.
     * @param {Number} [revision]     Package's revision. If not defined, it will be calculated using the list of files.
     * @param {Number} [timemodified] Package's timemodified. If not defined, it will be calculated using the list of files.
     * @param {String} [dirPath]      Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                                the files directly inside the filepool folder.
     * @return {Promise}              Promise resolved when all files are downloaded.
     */
    self.downloadPackage = function(siteId, fileList, component, componentId, revision, timemodified, dirPath) {
        return self._downloadOrPrefetchPackage(siteId, fileList, false, component, componentId, revision, timemodified, dirPath);
    };

    /**
     * Downloads a file on the spot.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#downloadUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @param {Boolean} [ignoreStale] True if 'stale' should be ignored.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {String} [filePath]       Filepath to download the file to.
     * @return {Promise} Resolved with internal URL on success, rejected otherwise.
     * @description
     * Downloads a file on the spot.
     *
     * This will also take care of adding the file to the pool if it's missing.
     * However, please note that this will not force a file to be re-downloaded
     * if it is already part of the pool. You should mark a file as stale using
     * {@link $mmFilepool#invalidateFileByUrl} to trigger a download.
     *
     * See {@link $mmFilepool#_getInternalUrlById} for the type of local URL returned.
     */
    self.downloadUrl = function(siteId, fileUrl, ignoreStale, component, componentId, timemodified, filePath) {
        var fileId,
            revision,
            promise;

        if ($mmFS.isAvailable()) {
            return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
                timemodified = timemodified || 0;
                revision = self.getRevisionFromUrl(fileUrl);
                fileId = self._getFileIdByUrl(fileUrl);

                return self._hasFileInPool(siteId, fileId).then(function(fileObject) {

                    if (typeof fileObject === 'undefined') {
                        // We do not have the file, download and add to pool.
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath);

                    } else if (self._isFileOutdated(fileObject, revision, timemodified) && $mmApp.isOnline() && !ignoreStale) {
                        // The file is outdated, force the download and update it.
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject);
                    }

                    // Everything is fine, return the file on disk.
                    if (filePath) {
                        promise = self._getInternalUrlByPath(filePath);
                    } else {
                        promise = self._getInternalUrlById(siteId, fileId);
                    }
                    return promise.then(function(response) {
                        return response;
                    }, function() {
                        // The file was not found in the pool, weird.
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject);
                    });

                }, function() {
                    // The file is not in the pool just yet.
                    return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath);
                })
                .then(function(response) {
                    if (typeof component !== 'undefined') {
                        self._addFileLink(siteId, fileId, component, componentId);
                    }
                    self._notifyFileDownloaded(siteId, fileId);
                    return response;
                }, function(err) {
                    self._notifyFileDownloadError(siteId, fileId);
                    return $q.reject(err);
                });
            });
        } else {
            return $q.reject();
        }
    };

    /**
     * Downloads a URL and update or add it to the pool.
     *
     * This uses the file system, you should always make sure that it is
     * accessible before calling this method.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_downloadForPoolByUrl
     * @param {String} siteId           The site ID.
     * @param {String} fileUrl          The file URL.
     * @param {Number} [revision]       File revision number.
     * @param {Number} [timemodified]   The time this file was modified. Can be used to check file state.
     * @param {String} [filePath]       Filepath to download the file to.
     * @param {Object} [poolFileObject] When set, the object will be updated, a new entry will not be created.
     * @return {Promise} Resolved with internal URL on success, rejected otherwise.
     * @protected
     */
    self._downloadForPoolByUrl = function(siteId, fileUrl, revision, timemodified, filePath, poolFileObject) {
        var fileId = self._getFileIdByUrl(fileUrl);
        filePath = filePath || self._getFilePath(siteId, fileId);

        if (poolFileObject && poolFileObject.fileId !== fileId) {
            $log.error('Invalid object to update passed');
            return $q.reject();
        }

        var downloadId = self.getFileDownloadId(fileUrl, filePath),
            deleted = false,
            promise;

        if (filePromises[siteId] && filePromises[siteId][downloadId]) {
            // There's already a download ongoing for this file in this location, return the promise.
            return filePromises[siteId][downloadId];
        } else if (!filePromises[siteId]) {
            filePromises[siteId] = {};
        }

        promise = $mmSitesManager.getSite(siteId).then(function(site) {

            if (!site.canDownloadFiles()) {
                return $q.reject();
            }

            return $mmWS.downloadFile(fileUrl, filePath).then(function(fileEntry) {
                var now = new Date(),
                    data = poolFileObject || {};

                data.downloaded = now.getTime();
                data.stale = false;
                data.url = fileUrl;
                data.revision = revision;
                data.timemodified = timemodified;
                data.path = filePath;

                return self._addFileToPool(siteId, fileId, data).then(function() {
                    return fileEntry.toURL();
                });
            });
        }).finally(function() {
            // Download finished, delete the promise.
            delete filePromises[siteId][downloadId];
            deleted = true;
        });

        if (!deleted) { // In case promise was finished immediately.
            filePromises[siteId][downloadId] = promise;
        }
        return promise;
    };

    /**
     * Fix a component ID to always be a Number.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_fixComponentId
     * @param {String|Number|undefined} The component ID.
     * @return {Number} The normalised component ID. -1 when undefined was passed.
     * @protected
     */
    self._fixComponentId = function(componentId) {
        var id = parseInt(componentId, 10);
        if (isNaN(id)) {
            return -1;
        }
        return id;
    };

    /**
     * Add the wstoken url and points to the correct script.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_fixPluginfileURL
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise}       Resolved with fixed URL on success, rejected otherwise.
     * @protected
     */
    self._fixPluginfileURL = function(siteId, fileUrl) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.fixPluginfileURL(fileUrl);
        });
    };

    /**
     * Get the ID of a file download. Used to keep track of filePromises.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileDownloadId
     * @param {String} fileUrl  The file URL.
     * @param {String} filePath The file destination path.
     * @return {String}         File download ID.
     * @protected
     */
    self.getFileDownloadId = function(fileUrl, filePath) {
        return md5.createHash(fileUrl + '###' + filePath);
    };

    /**
     * Get the name of the event used to notify download events ($mmEvents).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileEventName
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {String}       Event name.
     * @protected
     */
    self._getFileEventName = function(siteId, fileId) {
        return 'mmFilepoolFile:'+siteId+':'+fileId;
    };

    /**
     * Get the name of the event used to notify download events ($mmEvents).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileEventNameByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @return {Promise}       Promise resolved with event name.
     */
    self.getFileEventNameByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._getFileEventName(siteId, fileId);
        });
    };

    /**
     * Get a download promise. If the promise is not set, return undefined.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackageDownloadPromise
     * @param {String} siteId        Site ID.
     * @param {String} component     The component of the package.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {String}             Download promise or undefined.
     */
    self.getPackageDownloadPromise = function(siteId, component, componentId) {
        var packageId = self.getPackageId(component, componentId);
        if (packagesPromises[siteId] && packagesPromises[siteId][packageId]) {
            return packagesPromises[siteId][packageId];
        }
    };

    /**
     * Get the ID of a package.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackageId
     * @param {String} component     Package's component.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {String}              Package ID.
     */
    self.getPackageId = function(component, componentId) {
        return md5.createHash(component + '#' + self._fixComponentId(componentId));
    };

    /**
     * Get a package previous status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackagePreviousStatus
     * @param {String} siteId           Site ID.
     * @param {String} component        Package's component.
     * @param {Number} [componentId]    An ID to use in conjunction with the component.
     * @return {Promise}                Promise resolved with the status.
     */
    self.getPackagePreviousStatus = function(siteId, component, componentId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                return entry.previous || mmCoreNotDownloaded;
            }, function() {
                return mmCoreNotDownloaded;
            });
        });
    };

    /**
     * Get a package status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackageStatus
     * @param {String} siteId              Site ID.
     * @param {String} component           Package's component.
     * @param {Number} [componentId]       An ID to use in conjunction with the component.
     * @param {Number|String} [revision=0] Package's revision.
     * @param {Number} [timemodified=0]    Package's timemodified.
     * @return {Promise}                   Promise resolved with the status.
     */
    self.getPackageStatus = function(siteId, component, componentId, revision, timemodified) {
        revision = revision || 0;
        timemodified = timemodified || 0;
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);

            // Get status.
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                if (entry.status === mmCoreDownloaded) {
                    if (revision != entry.revision || timemodified > entry.timemodified) {
                        // File is outdated. Let's change its status.
                        entry.status = mmCoreOutdated;
                        entry.updated = new Date().getTime();
                        db.insert(mmFilepoolPackagesStore, entry).then(function() {
                            // Success inserting, trigger event.
                            self._triggerPackageStatusChanged(siteId, component, componentId, mmCoreOutdated);
                        });
                    }
                } else if (entry.status === mmCoreOutdated) {
                    if (revision === entry.revision && timemodified === entry.timemodified) {
                        // File isn't outdated anymore. Let's change its status.
                        entry.status = mmCoreDownloaded;
                        entry.updated = new Date().getTime();
                        db.insert(mmFilepoolPackagesStore, entry).then(function() {
                            // Success inserting, trigger event.
                            self._triggerPackageStatusChanged(siteId, component, componentId, mmCoreDownloaded);
                        });
                    }
                }
                return entry.status;
            }, function() {
                return mmCoreNotDownloaded;
            });
        });
    };

    /**
     * Get the deferred object for a file in the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getQueueDeferred
     * @param {String} siteId         The site ID.
     * @param {String} fileId         The file ID.
     * @param {Boolean} [create=true] True if it should create a new deferred if it doesn't exist.
     * @return {Object}               Deferred.
     * @protected
     */
    self._getQueueDeferred = function(siteId, fileId, create) {
        if (typeof create == 'undefined') {
            create = true;
        }

        if (!queueDeferreds[siteId]) {
            if (!create) {
                return;
            }
            queueDeferreds[siteId] = {};
        }
        if (!queueDeferreds[siteId][fileId]) {
            if (!create) {
                return;
            }
            queueDeferreds[siteId][fileId] = $q.defer();
        }
        return queueDeferreds[siteId][fileId];
    };

    /**
     * Get the promise for a file in the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getQueuePromise
     * @param {String} siteId         The site ID.
     * @param {String} fileId         The file ID.
     * @param {Boolean} [create=true] True if it should create a new promise if it doesn't exist.
     * @return {Promise}              Promise.
     * @protected
     */
    self._getQueuePromise = function(siteId, fileId, create) {
        return self._getQueueDeferred(siteId, fileId, create).promise;
    };

    /**
     * Is the file already in the pool?
     *
     * This does not check if the file is on the disk.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_hasFileInPool
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Resolved with file object from DB on success, rejected otherwise.
     * @protected
     */
    self._hasFileInPool = function(siteId, fileId) {
        return getSiteDb(siteId).then(function(db) {
            return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                if (typeof fileObject === 'undefined') {
                    return $q.reject();
                }
                return fileObject;
            });
        });
    };

    /**
     * Is the file in queue?
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_hasFileInQueue
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Resolved with file object from DB on success, rejected otherwise.
     * @protected
     */
    self._hasFileInQueue = function(siteId, fileId) {
        return $mmApp.getDB().get(mmFilepoolQueueStore, [siteId, fileId]).then(function(fileObject) {
            if (typeof fileObject === 'undefined') {
                return $q.reject();
            }
            return fileObject;
        });
    };

    /**
     * Returns the local URL of a drectory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getInternalUrlByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise}       Resolved with the URL. Rejected otherwise.
     * @protected
     */
    self.getDirectoryUrlByUrl = function(siteId, fileUrl) {
        if ($mmFS.isAvailable()) {
            return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
                var fileId = self._getFileIdByUrl(fileUrl);
                return $mmFS.getDir(self._getFilePath(siteId, fileId)).then(function(dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return $q.reject();
    };

    /**
     * Creates a unique ID based on a URL.
     *
     * This has a minimal handling of pluginfiles in order to generate a clean
     * file ID which will not change if pointing to the same pluginfile URL even
     * if the token or extra attributes have changed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getFileIdByUrl
     * @param {String} fileUrl The absolute URL to the file.
     * @return {Promise} The file ID.
     * @protected
     */
    self._getFileIdByUrl = function(fileUrl) {
        var url = self._removeRevisionFromUrl(fileUrl),
            candidate,
            extension = '';

        if (url.indexOf('/webservice/pluginfile') !== -1) {
            // Remove attributes that do not matter.
            angular.forEach(urlAttributes, function(regex) {
                url = url.replace(regex, '');
            });

            // For now only guesses the extension of the plugin files. We need the extension
            // for the inAppBrowser to open the files properly, e.g. the extension needs to be
            // part of the file name. Also, we need the mimetype to open the file with
            // web intents. The easiest way to provide such information is to keep the extension
            // in the file ID. Developers should not care about it, but as we are using the
            // file ID in the file path, devs and system can guess it.
            candidate = self._guessExtensionFromUrl(url);
            if (candidate && candidate !== 'php') {
                extension = '.' + candidate;
            }
        }
        return md5.createHash('url:' + url) + extension;
    };

    /**
     * Returns an absolute URL to access the file URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getFileUrlByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified=0] The time this file was modified.
     * @return {Promise} Resolved with the URL to use. When rejected, nothing could be done.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     *
     * This handles the queue and validity of the file. When we have a local copy of the file
     * we will assess whether or not it is still valid. If it is not valid, or we did not find
     * the file, we will add it to the queue to be downloaded later and we will return the URL
     * we received. When the file is valid we return a local URL to it.
     *
     * When the file cannot be found, and we are offline, then we reject the promise because
     * there was nothing we could do.
     */
    self._getFileUrlByUrl = function(siteId, fileUrl, mode, component, componentId, timemodified) {
        var fileId,
            revision;

        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._hasFileInPool(siteId, fileId).then(function(fileObject) {
                var response,
                    addToQueue = false,
                    fn;

                if (typeof fileObject === 'undefined') {
                    // We do not have the file, add it to the queue, and return real URL.
                    self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                    response = fileUrl;

                } else if (self._isFileOutdated(fileObject, revision, timemodified) && $mmApp.isOnline()) {
                    // The file is outdated, we add to the queue and return real URL.
                    self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                    response = fileUrl;

                } else {
                    // We found the file entry, now look for the file on disk.

                    if (mode === 'src') {
                        fn = self._getInternalSrcById;
                    } else {
                        fn = self._getInternalUrlById;
                    }

                    response = fn(siteId, fileId).then(function(internalUrl) {
                        // Perfect, the file is on disk.
                        // For the time being we assume that the component link already exists.
                        return internalUrl;
                    }, function() {
                        // We have a problem here, we could not retrieve the file though we thought
                        // we had it, we will delete the entries associated with that ID.
                        $log.debug('File ' + fileId + ' not found on disk');
                        self._removeFileById(siteId, fileId);
                        self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);

                        if ($mmApp.isOnline()) {
                            // We still have a chance to serve the right content.
                            return fileUrl;
                        }

                        return $q.reject();
                    });
                }

                return response;
            }, function() {
                // We do not have the file in store yet.
                self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                return fileUrl;
            });
        });
    };

    /**
     * Get the path to a file.
     *
     * This does not check if the file exists or not.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getFilePath
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {String} The path to the file relative to storage root.
     * @protected
     */
    self._getFilePath = function(siteId, fileId) {
        return $mmFS.getSiteFolder(siteId) + '/' + mmFilepoolFolder + '/' + fileId;
    };

    /**
     * Get the path to a file from its URL.
     *
     * This does not check if the file exists or not.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFilePathByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Promise resolved with the path to the file relative to storage root.
     */
    self.getFilePathByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._getFilePath(siteId, fileId);
        });
    };

    /**
     * Returns the file state: mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded or mmCoreOutdated.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileStateByUrl
     * @param {String} siteId           The site ID.
     * @param {String} fileUrl          File URL.
     * @param {Number} [timemodified=0] The time this file was modified.
     * @return {Promise}                Promise resolved with the file state.
     */
    self.getFileStateByUrl = function(siteId, fileUrl, timemodified) {
        var fileId,
            revision;

        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            fileId = self._getFileIdByUrl(fileUrl);

            return self._hasFileInQueue(siteId, fileId).then(function() {
                return mmCoreDownloading;
            }, function() {
                return self._hasFileInPool(siteId, fileId).then(function(fileObject) {
                    if (self._isFileOutdated(fileObject, revision, timemodified)) {
                        return mmCoreOutdated;
                    } else {
                        return mmCoreDownloaded;
                    }
                }, function() {
                    return mmCoreNotDownloaded;
                });
            });
        });
    };

    /**
     * Returns the internal SRC of a file.
     *
     * The returned URL from this method is typically used with IMG tags.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getInternalSrcById
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved with the internal URL. Rejected otherwise.
     * @protected
     */
    self._getInternalSrcById = function(siteId, fileId) {
        if ($mmFS.isAvailable()) {
            return $mmFS.getFile(self._getFilePath(siteId, fileId)).then(function(fileEntry) {
                // We use toInternalURL so images are loaded in iOS8 using img HTML tags,
                // with toURL the OS is unable to find the image files.
                return $mmFS.getInternalURL(fileEntry);
            });
        }
        return $q.reject();
    };

    /**
     * Returns the local URL of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getInternalUrlById
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved with the URL. Rejected otherwise.
     * @protected
     */
    self._getInternalUrlById = function(siteId, fileId) {
        if ($mmFS.isAvailable()) {
            return $mmFS.getFile(self._getFilePath(siteId, fileId)).then(function(fileEntry) {
                return fileEntry.toURL();
            });
        }
        return $q.reject();
    };

    /**
     * Returns the local URL of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getInternalUrlByPath
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved with the URL. Rejected otherwise.
     * @protected
     */
    self._getInternalUrlByPath = function(filePath) {
        if ($mmFS.isAvailable()) {
            return $mmFS.getFile(filePath).then(function(fileEntry) {
                return fileEntry.toURL();
            });
        }
        return $q.reject();
    };

    /**
     * Get package revision number from a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getRevisionFromFileList
     * @param {Object[]} files Package files.
     * @return {Number}        Package revision.
     */
    self.getRevisionFromFileList = function(files) {
        var revision = 0;

        angular.forEach(files, function(file) {
            if (file.fileurl) {
                var r = self.getRevisionFromUrl(file.fileurl);
                if (r > revision) {
                    revision = r;
                }
            }
        });

        return revision;
    };

    /**
     * Get the revision number from a file URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getRevisionFromUrl
     * @param {String} url URL to get the revision number.
     * @return {String}    Revision number.
     * @protected
     */
    self.getRevisionFromUrl = function(url) {
        var matches = url.match(revisionRegex);
        if (matches && typeof matches[1] != 'undefined') {
            return parseInt(matches[1]);
        }
    };

    /**
     * Returns an absolute URL to use in IMG tags.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getSrcByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified] The time this file was modified.
     * @return {Promise} Resolved with the URL to use. When rejected, nothing could be done,
     *                   which means that you should not even use the fileUrl passed.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with IMG tags.
     * See {@link $mmFilepool#_getFileUrlByUrl} for more details.
     */
    self.getSrcByUrl = function(siteId, fileUrl, component, componentId, timemodified) {
        return self._getFileUrlByUrl(siteId, fileUrl, 'src', component, componentId, timemodified);
    };

    /**
     * Get package timemodified from a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getTimemodifiedFromFileList
     * @param {Object[]} files Package files.
     * @return {Number}        Package time modified.
     */
    self.getTimemodifiedFromFileList = function(files) {
        var timemod = 0;

        angular.forEach(files, function(file) {
            if (file.timemodified > timemod) {
                timemod = file.timemodified;
            }
        });

        return timemod;
    };

    /**
     * Returns an absolute URL to access the file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getUrlByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified] The time this file was modified.
     * @return {Promise} Resolved with the URL to use. When rejected, nothing could be done,
     *                   which means that you should not even use the fileUrl passed.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with a local browser.
     * See {@link $mmFilepool#_getFileUrlByUrl} for more details.
     */
    self.getUrlByUrl = function(siteId, fileUrl, component, componentId, timemodified) {
        return self._getFileUrlByUrl(siteId, fileUrl, 'url', component, componentId, timemodified);
    };

    /**
     * Guess the extension of a file from its URL.
     *
     * This is very weak and unreliable.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_guessExtensionFromUrl
     * @param {String} fileUrl The file URL.
     * @return {String} The lowercased extension without the dot, or undefined.
     * @protected
     */
    self._guessExtensionFromUrl = function(fileUrl) {
        var split = fileUrl.split('.'),
            candidate,
            extension;

        if (split.length > 1) {
            candidate = split.pop().toLowerCase();
            if (extensionRegex.test(candidate)) {
                extension = candidate;
            }
        }

        return extension;
    };

    /**
     * Invalidate all the files in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#invalidateAllFiles
     * @param {String} siteId The site ID.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to ignore a failure.
     * @description
     * Invalidates all files by marking it stale. See {@link $mmFilepool#invalidateFileByUrl} for more details.
     */
    self.invalidateAllFiles = function(siteId) {
        return getSiteDb(siteId).then(function(db) {
            return db.getAll(mmFilepoolStore).then(function(items) {
                var promises = [];
                angular.forEach(items, function(item) {
                    item.stale = true;
                    promises.push(db.insert(mmFilepoolStore, item));
                });
                return $q.all(promises);
            });
        });
    };

    /**
     * Invalidate a file by URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#invalidateFileByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to ignore a failure.
     * @description
     * Invalidates a file by marking it stale. It will not be added to the queue automatically,
     * but the next time this file will be requested it will be added to the queue. This is to allow
     * for cache invalidation without necessarily re-triggering downloads.
     * You can manully call {@link $mmFilepool#addToQueueByUrl} to counter this behaviour.
     * Please note that when a file is marked as stale, the user will be presented the stale file
     * only if they do not have network access.
     */
    self.invalidateFileByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return getSiteDb(siteId).then(function(db) {
                return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                    if (!fileObject) {
                        // Nothing to do, we do not have the file in store.
                        return;
                    }
                    fileObject.stale = true;
                    return db.insert(mmFilepoolStore, fileObject);
                });
            });
        });
    };

    /**
     * Invalidate all the matching files from a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#invalidateFilesByComponent
     * @param {String} siteId The site ID.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to ignore a failure.
     * @description
     * Invalidates a file by marking it stale. See {@link $mmFilepool#invalidateFileByUrl} for more details.
     */
    self.invalidateFilesByComponent = function(siteId, component, componentId) {
        var values = { stale: true },
            where;
        if (typeof componentId !== 'undefined') {
            where = ['componentAndId', '=', [component, self._fixComponentId(componentId)]];
        } else {
            where = ['component', '=', component];
        }

        return getSiteDb(siteId).then(function(db) {
            return db.query(mmFilepoolLinksStore, where).then(function(items) {
                var promise,
                    promises = [];

                angular.forEach(items, function(item) {
                    promise = db.get(mmFilepoolStore, item.fileId).then(function(fileEntry) {
                        if (!fileEntry) {
                            return;
                        }
                        fileEntry.stale = true;
                        return db.insert(mmFilepoolStore, fileEntry);
                    });
                    promises.push(promise);
                });

                return $q.all(promises);
            });
        });
    };

    /**
     * Check if a file is downloading.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#isFileDownloadingByUrl
     * @param {String} siteId           The site ID.
     * @param {String} fileUrl          File URL.
     * @param {Promise}                 Promise resolved if file is downloading, false otherwise.
     */
    self.isFileDownloadingByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            fileId = self._getFileIdByUrl(fileUrl);
            return self._hasFileInQueue(siteId, fileId);
        });
    };

    /**
     * Check if a file is outdated.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_isFileOutdated
     * @param {Object} fileObject     File object.
     * @param {Number} [revision]     File revision number.
     * @param {Number} [timemodified] The time this file was modified.
     * @param {Boolean}               True if file is outdated, false otherwise.
     */
    self._isFileOutdated = function(fileObject, revision, timemodified) {
        return fileObject.stale || revision > fileObject.revision || timemodified > fileObject.timemodified;
    };

    /**
     * Notify a file has been downloaded.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_notifyFileDownloaded
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     */
    self._notifyFileDownloaded = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {success: true});
    };

    /**
     * Notify error occurred while downloading a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_notifyFileDownloadError
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     */
    self._notifyFileDownloadError = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {success: false});
    };

    /**
     * Prefetches a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#prefetchPackage
     * @param {String} siteId         The site ID.
     * @param  {Object[]} fileList    List of files to download.
     * @param {String} component      The component to link the file to.
     * @param {Number} componentId    An ID to identify the download. Must be unique.
     * @param {Number} [revision]     Package's revision. If not defined, it will be calculated using the list of files.
     * @param {Number} [timemodified] Package's timemodified. If not defined, it will be calculated using the list of files.
     * @param {String} [dirPath]      Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                                the files directly inside the filepool folder.
     * @return {Promise}              Promise resolved when all files are downloaded.
     */
    self.prefetchPackage = function(siteId, fileList, component, componentId, revision, timemodified, dirPath) {
        return self._downloadOrPrefetchPackage(siteId, fileList, true, component, componentId, revision, timemodified, dirPath);
    };

    /**
     * Process the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_processQueue
     * @return {Void}
     * @description
     * Processes the queue.
     *
     * This loops over itself to keep on processing the queue in the background.
     * The queue process is site agnostic.
     */
    self._processQueue = function() {
        var deferred = $q.defer(),
            promise;

        if (queueState !== QUEUE_RUNNING) {
            // Silently ignore, the queue is on pause.
            deferred.reject(ERR_QUEUE_ON_PAUSE);
            promise = deferred.promise;

        } else if (!$mmFS.isAvailable() || !$mmApp.isOnline()) {
            deferred.reject(ERR_FS_OR_NETWORK_UNAVAILABLE);
            promise = deferred.promise;

        } else {
            promise = self._processImportantQueueItem();
        }

        promise.then(function() {
            // All good, we schedule next execution.
            $timeout(self._processQueue, mmFilepoolQueueProcessInterval);

        }, function(error) {

            // We had an error, in which case we pause the processing.
            if (error === ERR_FS_OR_NETWORK_UNAVAILABLE) {
                $log.debug('Filesysem or network unavailable, pausing queue processing.');

            } else if (error === ERR_QUEUE_IS_EMPTY) {
                $log.debug('Queue is empty, pausing queue processing.');
                $mmEvents.trigger(mmCoreEventQueueEmpty);
            }

            queueState = QUEUE_PAUSED;
        });
    };

    /**
     * Process the most important queue item.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_processImportantQueueItem
     * @return {Promise} Resolved on success. Rejected on failure.
     */
    self._processImportantQueueItem = function() {
        return $mmApp.getDB().query(mmFilepoolQueueStore, undefined, 'sortorder', undefined, 1)
        .then(function(items) {
            var item = items.pop();
            if (!item) {
                return $q.reject(ERR_QUEUE_IS_EMPTY);
            }
            return self._processQueueItem(item);
        }, function() {
            return $q.reject(ERR_QUEUE_IS_EMPTY);
        });
    };

    /**
     * Process a queue item.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_processQueueItem
     * @param {Object} item The object from the queue store.
     * @return {Promise} Resolved on success. Rejected on failure.
     * @protected
     */
    self._processQueueItem = function(item) {
        var siteId = item.siteId,
            fileId = item.fileId,
            fileUrl = item.url,
            revision = item.revision,
            timemodified = item.timemodified,
            filePath = item.path,
            links = item.links || [];

        $log.debug('Processing queue item: ' + siteId + ', ' + fileId);
        return getSiteDb(siteId).then(function(db) {
            return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                if (fileObject && !self._isFileOutdated(fileObject, revision, timemodified)) {
                    // We have the file, it is not stale, we can update links and remove from queue.
                    $log.debug('Queued file already in store, ignoring...');
                    self._addFileLinks(siteId, fileId, links);
                    self._removeFromQueue(siteId, fileId).finally(function() {
                        self._treatQueueDeferred(siteId, fileId, true);
                    });
                    self._notifyFileDownloaded(siteId, fileId);
                    return;
                }
                // The file does not exist, or is stale, ... download it.
                return download(siteId, fileUrl, fileObject, links);
            }, function() {
                // The file does not exist, download it.
                return download(siteId, fileUrl, undefined, links);
            });
        }, function() {
            // Couldn't get site DB, site was probably deleted.
            $log.debug('Item dropped from queue due to site DB not retrieved: ' + fileUrl);
            return self._removeFromQueue(siteId, fileId).catch(function() {}).finally(function() {
                self._treatQueueDeferred(siteId, fileId, false);
                self._notifyFileDownloadError(siteId, fileId);
            });
        });

        /**
         * Download helper to avoid code duplication.
         */
        function download(siteId, fileUrl, fileObject, links) {
            return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject).then(function() {
                var promise;

                // Success, we add links and remove from queue.
                self._addFileLinks(siteId, fileId, links);
                promise = self._removeFromQueue(siteId, fileId);

                self._treatQueueDeferred(siteId, fileId, true);
                self._notifyFileDownloaded(siteId, fileId);

                // Wait for the item to be removed from queue before resolving the promise.
                // If the item could not be removed from queue we still resolve the promise.
                return promise.catch(function() {});

            }, function(errorObject) {
                // Whoops, we have an error...
                var dropFromQueue = false;

                if (typeof errorObject !== 'undefined' && errorObject.source === fileUrl) {
                    // This is most likely a $cordovaFileTransfer error.

                    if (errorObject.code === 1) { // FILE_NOT_FOUND_ERR.
                        // The file was not found, most likely a 404, we remove from queue.
                        dropFromQueue = true;

                    } else if (errorObject.code === 2) { // INVALID_URL_ERR.
                        // The URL is invalid, we drop the file from the queue.
                        dropFromQueue = true;

                    } else if (errorObject.code === 3) { // CONNECTION_ERR.
                        // If there was an HTTP status, then let's remove from the queue.
                        dropFromQueue = true;
                    } else if (errorObject.code === 4) { // ABORTED_ERR.
                        // The transfer was aborted, we will keep the file in queue.
                    } else if (errorObject.code === 5) { // NOT_MODIFIED_ERR.
                        // We have the latest version of the file, HTTP 304 status.
                        dropFromQueue = true;
                    } else {
                        // Unknown error, let's remove the file from the queue to avoid
                        // locking down the queue because of one file.
                        dropFromQueue = true;
                    }
                } else {
                    dropFromQueue = true;
                }

                if (dropFromQueue) {
                    var promise;

                    $log.debug('Item dropped from queue due to error: ' + fileUrl);
                    promise = self._removeFromQueue(siteId, fileId);

                    // Consider this as a silent error, never reject the promise here.
                    return promise.catch(function() {}).finally(function() {
                        self._treatQueueDeferred(siteId, fileId, false);
                        self._notifyFileDownloadError(siteId, fileId);
                    });
                } else {
                    // We considered the file as legit but did not get it, failure.
                    self._treatQueueDeferred(siteId, fileId, false);
                    self._notifyFileDownloadError(siteId, fileId);
                    return $q.reject();
                }

            }, function(progress) {
                // Send the progress object to the queue deferred.
                if (queueDeferreds[siteId] && queueDeferreds[siteId][fileId]) {
                    queueDeferreds[siteId][fileId].notify(progress);
                }
            });
        }

    };

    /**
     * Remove a file from the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_removeFromQueue
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._removeFromQueue = function(siteId, fileId) {
        return $mmApp.getDB().remove(mmFilepoolQueueStore, [siteId, fileId]);
    };

    /**
     * Remove a file from the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_removeFileById
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._removeFileById = function(siteId, fileId) {
        return getSiteDb(siteId).then(function(db) {
            var p1, p2, p3;
            p1 = db.remove(mmFilepoolStore, fileId);
            p2 = db.where(mmFilepoolLinksStore, 'fileId', '=', fileId).then(function(entries) {
                return $q.all(entries.map(function(entry) {
                    return db.remove(mmFilepoolLinksStore, [entry.fileId, entry.component, entry.componentId]);
                }));
            });
            p3 = $mmFS.isAvailable() ? $mmFS.removeFile(self._getFilePath(siteId, fileId)) : $q.when();
            return $q.all([p1, p2, p3]);
        });
    };

    /**
     * Delete all the matching files from a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#removeFilesByComponent
     * @param {String} siteId        The site ID.
     * @param {String} component     The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise}             Resolved on success. Rejected on failure.
     */
    self.removeFilesByComponent = function(siteId, component, componentId) {
        var where;
        if (typeof componentId !== 'undefined') {
            where = ['componentAndId', '=', [component, self._fixComponentId(componentId)]];
        } else {
            where = ['component', '=', component];
        }

        return getSiteDb(siteId).then(function(db) {
            return db.query(mmFilepoolLinksStore, where);
        }).then(function(items) {
            return $q.all(items.map(function(item) {
                return self._removeFileById(siteId, item.fileId);
            }));
        });
    };

    /**
     * Remove a file from the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#removeFileByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise}       Resolved on success, rejected on failure. It is advised to silently ignore failures.
     */
    self.removeFileByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._removeFileById(siteId, fileId);
        });
    };

    /**
     * Removes the revision number from a file URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_removeRevisionFromUrl
     * @param {String} url URL to remove the revision number.
     * @return {String}    URL without revision number.
     * @protected
     * @description
     * The revision is used to know if a file has changed. We remove it from the URL to prevent storing a file per revision.
     */
    self._removeRevisionFromUrl = function(url) {
        return url.replace(revisionRegex, '/content/0/');
    };

    /**
     * Change the package status, setting it to the previous status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#setPackagePreviousStatus
     * @param {String} siteId        Site ID.
     * @param {String} component     Package's component.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise}             Promise resolved when the status is changed. Resolve param: new status.
     */
    self.setPackagePreviousStatus = function(siteId, component, componentId) {
        $log.debug('Set previous status for package ' + component + ' ' + componentId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);

            // Get current stored data, we'll only update 'status' and 'updated' fields.
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                entry.status = entry.previous || mmCoreNotDownloaded;
                entry.updated = new Date().getTime();
                $log.debug('Set status \'' + entry.status + '\' for package ' + component + ' ' + componentId);

                return db.insert(mmFilepoolPackagesStore, entry).then(function() {
                    // Success updating, trigger event.
                    self._triggerPackageStatusChanged(siteId, component, componentId, entry.status);
                    return entry.status;
                });
            });
        });
    };

    /**
     * Store package status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#storePackageStatus
     * @param {String} siteId           Site ID.
     * @param {String} component        Package's component.
     * @param {Number} [componentId]    An ID to use in conjunction with the component.
     * @param {String} status           New package status.
     * @param {Number} [revision=0]     Package's revision.
     * @param {Number} [timemodified=0] Package's timemodified.
     * @return {Promise}                Promise resolved when status is stored.
     */
    self.storePackageStatus = function(siteId, component, componentId, status, revision, timemodified) {
        $log.debug('Set status \'' + status + '\' for package ' + component + ' ' + componentId);
        revision = revision || 0;
        timemodified = timemodified || 0;

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);

            // Search current status to set it as previous status.
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                return entry.status;
            }, function() {
                return undefined; // No previous status.
            }).then(function(previousStatus) {
                var promise;
                if (previousStatus === status) {
                    // The package already has this status, no need to change it.
                    promise = $q.when();
                } else {
                    promise = db.insert(mmFilepoolPackagesStore, {
                        id: packageId,
                        component: component,
                        componentId: componentId,
                        status: status,
                        previous: previousStatus,
                        revision: revision,
                        timemodified: timemodified,
                        updated: new Date().getTime()
                    });
                }

                return promise.then(function() {
                    // Success inserting, trigger event.
                    self._triggerPackageStatusChanged(siteId, component, componentId, status);
                });
            });
        });
    };

    /**
     * Resolves or rejects a queue deferred and removes it from the list.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_treatQueueDeferred
     * @param {String} siteId   The site ID.
     * @param {String} fileId   The file ID.
     * @param {Boolean} resolve True if promise should be resolved, false if it should be rejected.
     * @return {Object}         Deferred.
     * @protected
     */
    self._treatQueueDeferred = function(siteId, fileId, resolve) {
        if (queueDeferreds[siteId] && queueDeferreds[siteId][fileId]) {
            if (resolve) {
                queueDeferreds[siteId][fileId].resolve();
            } else {
                queueDeferreds[siteId][fileId].reject();
            }
            delete queueDeferreds[siteId][fileId];
        }
    };

    /**
     * Trigger mmCoreEventPackageStatusChanged with the right data.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_triggerPackageStatusChanged
     * @param {String} siteId        Site ID.
     * @param {String} component     Package's component.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {String} status        New package status.
     * @return {Void}
     * @protected
     */
    self._triggerPackageStatusChanged = function(siteId, component, componentId, status) {
        var data = {
            siteid: siteId,
            component: component,
            componentId: componentId,
            status: status
        };
        $mmEvents.trigger(mmCoreEventPackageStatusChanged, data);
    };

    return self;
}])

.run(["$log", "$ionicPlatform", "$timeout", "$mmFilepool", function($log, $ionicPlatform, $timeout, $mmFilepool) {
    $log = $log.getInstance('$mmFilepool');

    $ionicPlatform.ready(function() {
        // Waiting for the platform to be ready, and a few more before we start processing the queue.
        $timeout($mmFilepool.checkQueueProcessing, 1000);
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmFsSitesFolder', 'sites')
.constant('mmFsTmpFolder', 'tmp')

/**
 * @ngdoc service
 * @name $mmFS
 * @module mm.core
 * @description
 * This service handles the interaction with the FileSystem.
 */
.factory('$mmFS', ["$ionicPlatform", "$cordovaFile", "$log", "$q", "$http", "$cordovaZip", "mmFsSitesFolder", "mmFsTmpFolder", function($ionicPlatform, $cordovaFile, $log, $q, $http, $cordovaZip, mmFsSitesFolder, mmFsTmpFolder) {

    $log = $log.getInstance('$mmFS');

    var self = {},
        initialized = false,
        basePath = '',
        isHTMLAPI = false,
        mimeTypes = {};

    // Loading all the mimetypes.
    $http.get('core/assets/mimetypes.json').then(function(response) {
        mimeTypes = response.data;
    }, function() {
        // It failed, never mind...
    });

    // Formats to read a file.
    self.FORMATTEXT         = 0;
    self.FORMATDATAURL      = 1;
    self.FORMATBINARYSTRING = 2;
    self.FORMATARRAYBUFFER  = 3;

    /**
     * Sets basePath to use with HTML API. Reserved for core use.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#setHTMLBasePath
     * @param {String} path Base path to use.
     */
    self.setHTMLBasePath = function(path) {
        isHTMLAPI = true;
        basePath = path;
    };

    /**
     * Checks if we're using HTML API.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#usesHTMLAPI
     * @return {Boolean} True if uses HTML API, false otherwise.
     */
    self.usesHTMLAPI = function() {
        return isHTMLAPI;
    };

    /**
     * Initialize basePath based on the OS if it's not initialized already.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#init
     * @return {Promise} Promise to be resolved when the initialization is finished.
     */
    self.init = function() {

        var deferred = $q.defer();

        if (initialized) {
            deferred.resolve();
            return deferred.promise;
        }

        $ionicPlatform.ready(function() {

            if (ionic.Platform.isAndroid()) {
                basePath = cordova.file.externalApplicationStorageDirectory;
            } else if (ionic.Platform.isIOS()) {
                basePath = cordova.file.documentsDirectory;
            } else if (!self.isAvailable() || basePath === '') {
                $log.error('Error getting device OS.');
                deferred.reject();
                return;
            }

            initialized = true;
            $log.debug('FS initialized: '+basePath);
            deferred.resolve();
        });

        return deferred.promise;
    };

    /**
     * Check if the plugin is available.
     *
     * @return {Boolean} True when cordova is initialised.
     */
    self.isAvailable = function() {
        return typeof window.resolveLocalFileSystemURL !== 'undefined' && typeof FileTransfer !== 'undefined';
    };

    /**
     * Get a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFile
     * @param  {String}  path Relative path to the file.
     * @return {Promise}      Promise to be resolved when the file is retrieved.
     */
    self.getFile = function(path) {
        return self.init().then(function() {
            $log.debug('Get file: '+path);
            return $cordovaFile.checkFile(basePath, path);
        });
    };

    /**
     * Get a directory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getDir
     * @param  {String}  path Relative path to the directory.
     * @return {Promise}      Promise to be resolved when the directory is retrieved.
     */
    self.getDir = function(path) {
        return self.init().then(function() {
            $log.debug('Get directory: '+path);
            return $cordovaFile.checkDir(basePath, path);
        });
    };

    /**
     * Get site folder path.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getSiteFolder
     * @param  {String} siteId Site ID.
     * @return {String}        Site folder path.
     */
    self.getSiteFolder = function(siteId) {
        return mmFsSitesFolder + '/' + siteId;
    };

    /**
     * Create a directory or a file.
     *
     * @param  {Boolean} isDirectory  True if a directory should be created, false if it should create a file.
     * @param  {String}  path         Relative path to the dir/file.
     * @param  {Boolean} failIfExists True if it should fail if the dir/file exists, false otherwise.
     * @param  {String}  base         Base path to create the dir/file in. If not set, use basePath.
     * @return {Promise}              Promise to be resolved when the dir/file is created.
     */
    function create(isDirectory, path, failIfExists, base) {
        return self.init().then(function() {
            base = base || basePath;

            if (path.indexOf('/') == -1) {
                if (isDirectory) {
                    $log.debug('Create dir ' + path + ' in ' + base);
                    return $cordovaFile.createDir(base, path, !failIfExists);
                } else {
                    $log.debug('Create file ' + path + ' in ' + base);
                    return $cordovaFile.createFile(base, path, !failIfExists);
                }
            } else {
                // $cordovaFile doesn't allow creating more than 1 level at a time (e.g. tmp/folder).
                // We need to create them 1 by 1.
                var firstDir = path.substr(0, path.indexOf('/'));
                var restOfPath = path.substr(path.indexOf('/') + 1);

                $log.debug('Create dir ' + firstDir + ' in ' + base);

                return $cordovaFile.createDir(base, firstDir, true).then(function(newDirEntry) {
                    return create(isDirectory, restOfPath, failIfExists, newDirEntry.toURL());
                }, function(error) {
                    $log.error('Error creating directory ' + firstDir + ' in ' + base);
                    return $q.reject(error);
                });
            }
        });
    }

    /**
     * Create a directory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#createDir
     * @param  {String}  path         Relative path to the directory.
     * @param  {Boolean} failIfExists True if it should fail if the directory exists, false otherwise.
     * @return {Promise}              Promise to be resolved when the directory is created.
     */
    self.createDir = function(path, failIfExists) {
        failIfExists = failIfExists || false; // Default value false.
        return create(true, path, failIfExists);
    };

    /**
     * Create a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#createFile
     * @param  {String}  path         Relative path to the file.
     * @param  {Boolean} failIfExists True if it should fail if the file exists, false otherwise..
     * @return {Promise}              Promise to be resolved when the file is created.
     */
    self.createFile = function(path, failIfExists) {
        failIfExists = failIfExists || false; // Default value false.
        return create(false, path, failIfExists);
    };

    /**
     * Removes a directory and all its contents.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeDir
     * @param  {String}  path    Relative path to the directory.
     * @return {Promise}         Promise to be resolved when the directory is deleted.
     */
    self.removeDir = function(path) {
        return self.init().then(function() {
            $log.debug('Remove directory: ' + path);
            return $cordovaFile.removeRecursively(basePath, path);
        });
    };

    /**
     * Removes a file and all its contents.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeFile
     * @param  {String}  path    Relative path to the file.
     * @return {Promise}         Promise to be resolved when the file is deleted.
     */
    self.removeFile = function(path) {
        return self.init().then(function() {
            $log.debug('Remove file: ' + path);
            return $cordovaFile.removeFile(basePath, path);
        });
    };

    /**
     * Retrieve the contents of a directory (not subdirectories).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getDirectoryContents
     * @param  {String} path Relative path to the directory.
     * @return {Promise}     Promise to be resolved when the contents are retrieved.
     */
    self.getDirectoryContents = function(path) {
        $log.debug('Get contents of dir: ' + path);
        return self.getDir(path).then(function(dirEntry) {

            var deferred = $q.defer();

            var directoryReader = dirEntry.createReader();
            directoryReader.readEntries(deferred.resolve, deferred.reject);

            return deferred.promise;
        });
    };

    /**
     * Calculate the size of a directory or a file.
     *
     * @param  {String} path Relative path to the directory or file.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    function getSize(entry) {

        var deferred = $q.defer();

        if (entry.isDirectory) {

            var directoryReader = entry.createReader();
            directoryReader.readEntries(function(entries) {

                var promises = [];
                for (var i = 0; i < entries.length; i++) {
                    promises.push(getSize(entries[i]));
                }

                $q.all(promises).then(function(sizes) {

                    var directorySize = 0;
                    for (var i = 0; i < sizes.length; i++) {
                        var fileSize = parseInt(sizes[i]);
                        if (isNaN(fileSize)) {
                            deferred.reject();
                            return;
                        }
                        directorySize += fileSize;
                    }
                    deferred.resolve(directorySize);

                }, deferred.reject);

            }, deferred.reject);

        } else if (entry.isFile) {
            entry.file(function(file) {
                deferred.resolve(file.size);
            }, deferred.reject);
        }

        return deferred.promise;
    }

    /**
     * Calculate the size of a directory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getDirectorySize
     * @param  {String} path Relative path to the directory.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    self.getDirectorySize = function(path) {
        $log.debug('Get size of dir: ' + path);
        return self.getDir(path).then(function(dirEntry) {
           return getSize(dirEntry);
        });
    };

    /**
     * Calculate the size of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFileSize
     * @param  {String} path Relative path to the file.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    self.getFileSize = function(path) {
        $log.debug('Get size of file: ' + path);
        return self.getFile(path).then(function(fileEntry) {
           return getSize(fileEntry);
        });
    };

    /**
     * Get file object from a FileEntry.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFileSizeFromFileEntry
     * @param  {String} path Relative path to the file.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    self.getFileObjectFromFileEntry = function(entry) {
        $log.debug('Get file object of: ' + entry.fullPath);
        var deferred = $q.defer();
        entry.file(function(file) {
            deferred.resolve(file);
        }, deferred.reject);
        return deferred.promise;
    };

    /**
     * Calculate the free space in the disk.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#calculateFreeSpace
     * @return {Promise} Promise resolved with the estimated free space in bytes.
     */
    self.calculateFreeSpace = function() {
        if (ionic.Platform.isIOS() || isHTMLAPI) {
            // getFreeDiskSpace doesn't work on iOS. See https://tracker.moodle.org/browse/MOBILE-956.
            // Ugly fix: request a file system instance with a minimum size until we get an error.

            if (window.requestFileSystem) {

                var iterations = 0,
                    maxIterations = 50,
                    deferred = $q.defer();

                function calculateByRequest(size, ratio) {
                    var deferred = $q.defer();

                    window.requestFileSystem(LocalFileSystem.PERSISTENT, size, function() {
                        iterations++;
                        if (iterations > maxIterations) {
                            deferred.resolve(size);
                            return;
                        }
                        calculateByRequest(size * ratio, ratio).then(deferred.resolve);
                    }, function() {
                        deferred.resolve(size / ratio);
                    });

                    return deferred.promise;
                };

                // General calculation, base 1MB and increasing factor 1.3.
                calculateByRequest(1048576, 1.3).then(function(size) {
                    iterations = 0;
                    maxIterations = 10;
                    // More accurate. Factor is 1.1.
                    calculateByRequest(size, 1.1).then(deferred.resolve);
                });

                return deferred.promise;
            } else {
                return $q.reject();
            }

        } else {
            return $cordovaFile.getFreeDiskSpace().then(function(size) {
                return size * 1024; // GetFreeDiskSpace returns KB.
            });
        }
    };

    /**
     * Normalize a filename that usually comes URL encoded.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#normalizeFileName
     * @param  {String} filename The file name.
     * @return {String}          The file name normalized.
     */
    self.normalizeFileName = function(filename) {
        filename = decodeURIComponent(filename);
        return filename;
    };

    /**
     * Read a file from local file system.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#readFile
     * @param  {String}  path   Relative path to the file.
     * @param  {Number}  format Format to read the file. By default, FORMATTEXT. Must be one of:
     *                                  $mmFS.FORMATTEXT
     *                                  $mmFS.FORMATDATAURL
     *                                  $mmFS.FORMATBINARYSTRING
     *                                  $mmFS.FORMATARRAYBUFFER
     * @return {Promise}        Promise to be resolved when the file is read.
     */
    self.readFile = function(path, format) {
        format = format || self.FORMATTEXT;
        $log.debug('Read file ' + path + ' with format '+format);
        switch (format) {
            case self.FORMATDATAURL:
                return $cordovaFile.readAsDataURL(basePath, path);
            case self.FORMATBINARYSTRING:
                return $cordovaFile.readAsBinaryString(basePath, path);
            case self.FORMATARRAYBUFFER:
                return $cordovaFile.readAsArrayBuffer(basePath, path);
            default:
                return $cordovaFile.readAsText(basePath, path);
        }
    };

    /**
     * Read file contents from a file data object.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#readFileData
     * @param  {Object}  fileData File's data.
     * @param  {Number}  format   Format to read the file. By default, FORMATTEXT. Must be one of:
     *                                  $mmFS.FORMATTEXT
     *                                  $mmFS.FORMATDATAURL
     *                                  $mmFS.FORMATBINARYSTRING
     *                                  $mmFS.FORMATARRAYBUFFER
     * @return {Promise}          Promise to be resolved when the file is read.
     */
    self.readFileData = function(fileData, format) {
        format = format || self.FORMATTEXT;
        $log.debug('Read file from file data with format '+format);

        var deferred = $q.defer();

        var reader = new FileReader();
        reader.onloadend = function(evt) {
            if (evt.target.result !== undefined || evt.target.result !== null) {
                deferred.resolve(evt.target.result);
            } else if (evt.target.error !== undefined || evt.target.error !== null) {
                deferred.reject(evt.target.error);
            } else {
                deferred.reject({code: null, message: 'READER_ONLOADEND_ERR'});
            }
        };

        switch (format) {
            case self.FORMATDATAURL:
                reader.readAsDataURL(fileData);
                break;
            case self.FORMATBINARYSTRING:
                reader.readAsBinaryString(fileData);
                break;
            case self.FORMATARRAYBUFFER:
                reader.readAsArrayBuffer(fileData);
                break;
            default:
                reader.readAsText(fileData);
        }

        return deferred.promise;
    };

    /**
     * Writes some data in a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#writeFile
     * @param  {String}  path Relative path to the file.
     * @param  {String}  data Data to write.
     * @return {Promise}      Promise to be resolved when the file is written.
     */
    self.writeFile = function(path, data) {
        $log.debug('Write file: ' + path);
        return self.init().then(function() {
            // Create file (and parent folders) to prevent errors.
            return self.createFile(path).then(function(fileEntry) {
                if (isHTMLAPI && typeof data == 'string') {
                    // We need to write Blobs.
                    var type = self.getMimeType(self.getFileExtension(path));
                    data = new Blob([data], {type: type || 'text/plain'});
                }
                return $cordovaFile.writeFile(basePath, path, data, true).then(function() {
                    return fileEntry;
                });
            });
        });
    };

    /**
     * Gets a file that might be outside the app's folder.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getExternalFile
     * @param  {String}  fullPath Absolute path to the file.
     * @return {Promise}          Promise to be resolved when the file is retrieved.
     */
    self.getExternalFile = function(fullPath) {
        return $cordovaFile.checkFile(fullPath, '');
    };

    /**
     * Removes a file that might be outside the app's folder.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeExternalFile
     * @param  {String}  fullPath Absolute path to the file.
     * @return {Promise}          Promise to be resolved when the file is removed.
     */
    self.removeExternalFile = function(fullPath) {
        // removeFile(fullPath, '') does not work, we need to pass two valid parameters.
        var directory = fullPath.substring(0, fullPath.lastIndexOf('/') );
        var filename = fullPath.substr(fullPath.lastIndexOf('/') + 1);
        return $cordovaFile.removeFile(directory, filename);
    };

    /**
     * Get the base path where the application files are stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getBasePath
     * @return {Promise} Promise to be resolved when the base path is retrieved.
     */
    self.getBasePath = function() {
        return self.init().then(function() {
            if (basePath.slice(-1) == '/') {
                return basePath;
            } else {
                return basePath + '/';
            }
        });
    };

    /**
     * Get the base path where the application files are stored in the format to be used for downloads.
     * iOS: Internal URL (cdvfile://).
     * Others: basePath (file://)
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getBasePathToDownload
     * @return {Promise} Promise to be resolved when the base path is retrieved.
     */
    self.getBasePathToDownload = function() {
        return self.init().then(function() {
            if (ionic.Platform.isIOS()) {
                // In iOS we want the internal URL (cdvfile://localhost/persistent/...).
                return $cordovaFile.checkDir(basePath, '').then(function(dirEntry) {
                    return dirEntry.toInternalURL();
                });
            } else {
                // In the other platforms we use the basePath as it is (file://...).
                return basePath;
            }
        });
    };

    /**
     * Get temporary directory path.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getTmpFolder
     * @return {String} Tmp directory path.
     */
    self.getTmpFolder = function() {
        return mmFsTmpFolder;
    };

    /**
     * Move a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#moveEntry
     * @param {String} originalPath Path to the file to move.
     * @param {String} newPath      New path of the file.
     * @return {Promise}            Promise resolved when the entry is moved.
     */
    self.moveFile = function(originalPath, newPath) {
        return self.init().then(function() {
            if (isHTMLAPI) {
                // In Cordova API we need to calculate the longest matching path to make it work.
                // $cordovaFile.moveFile('a/', 'b/c.ext', 'a/', 'b/d.ext') doesn't work.
                // cordovaFile.moveFile('a/b/', 'c.ext', 'a/b/', 'd.ext') works.
                var commonPath = basePath,
                    dirsA = originalPath.split('/'),
                    dirsB = newPath.split('/');

                for (var i = 0; i < dirsA.length; i++) {
                    var dir = dirsA[i];
                    if (dirsB[i] === dir) {
                        // Found a common folder, add it to common path and remove it from each specific path.
                        dir = dir + '/';
                        commonPath = self.concatenatePaths(commonPath, dir);
                        originalPath = originalPath.replace(dir, '');
                        newPath = newPath.replace(dir, '');
                    } else {
                        // Folder doesn't match, stop searching.
                        break;
                    }
                }

                return $cordovaFile.moveFile(commonPath, originalPath, commonPath, newPath);
            } else {
                return $cordovaFile.moveFile(basePath, originalPath, basePath, newPath);
            }
        });
    };

    /**
     * Copy a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#copyFile
     * @param {String} from   Path to the file to move.
     * @param {String} to     New path of the file.
     * @return {Promise}      Promise resolved when the entry is copied.
     */
    self.copyFile = function(from, to) {
        return self.init().then(function() {
            // Check if to contains a directory.
            var toFile = self.getFileAndDirectoryFromPath(to);
            if (toFile.directory == '') {
                return $cordovaFile.copyFile(basePath, from, basePath, to);
            } else {
                // Ensure directory is created.
                return self.createDir(toFile.directory).then(function() {
                    return $cordovaFile.copyFile(basePath, from, basePath, to);
                });
            }
        });
    };

    /**
     * Extract the file name and directory from a given path.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFileAndDirectoryFromPath
     * @param {String} path   Path to be extracted.
     * @return {Object}       Plain object containing the file name and directory.
     * @description
     * file.pdf         -> directory: '', name: 'file.pdf'
     * /file.pdf        -> directory: '', name: 'file.pdf'
     * path/file.pdf    -> directory: 'path', name: 'file.pdf'
     * path/            -> directory: 'path', name: ''
     * path             -> directory: '', name: 'path'
     */
    self.getFileAndDirectoryFromPath = function(path) {
        var file = {
            directory: '',
            name: ''
        };

        file.directory = path.substring(0, path.lastIndexOf('/') );
        file.name = path.substr(path.lastIndexOf('/') + 1);

        return file;
    };

    /**
     * Concatenate two paths, adding a slash between them if needed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#concatenatePaths
     * @param {String} leftPath  Left path.
     * @param {String} rightPath Right path.
     * @return {String}          Concatenated path.
     */
    self.concatenatePaths = function(leftPath, rightPath) {
        var lastCharLeft = leftPath.slice(-1),
            firstCharRight = rightPath.charAt(0);

        if (lastCharLeft === '/' && firstCharRight === '/') {
            return leftPath + rightPath.substr(1);
        } else if(lastCharLeft !== '/' && firstCharRight !== '/') {
            return leftPath + '/' + rightPath;
        } else {
            return leftPath + rightPath;
        }
    };

    /**
     * Get the internal URL of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getInternalURL
     * @param  {Object} fileEntry File Entry.
     * @return {String}           Internal URL.
     */
    self.getInternalURL = function(fileEntry) {
        if (isHTMLAPI) {
            // HTML API doesn't implement toInternalURL.
            return fileEntry.toURL();
        }
        return fileEntry.toInternalURL();
    };

    /**
     * Get a file icon URL based on its file name.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#getFileIcon
     * @param  {String} The name of the file.
     * @return {String} The path to a file icon.
     */
    self.getFileIcon = function(filename) {
        var ext = self.getFileExtension(filename),
            icon;

        if (ext && mimeTypes[ext] && mimeTypes[ext].icon) {
            icon = mimeTypes[ext].icon + '-64.png';
        } else {
            icon = 'unknown-64.png';
        }

        return 'img/files/' + icon;
    };

    /**
     * Get the folder icon URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#getFolderIcon
     * @return {String} The path to a folder icon.
     */
    self.getFolderIcon = function() {
        return 'img/files/folder-64.png';
    };

    /**
     * Returns the file extension of a file.
     *
     * When the file does not have an extension, it returns undefined.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#getFileExtension
     * @param  {string} filename The file name.
     * @return {string}          The lowercased extension, or undefined.
     */
    self.getFileExtension = function(filename) {
        var dot = filename.lastIndexOf("."),
            ext;

        if (dot > -1) {
            ext = filename.substr(dot + 1).toLowerCase();
        }

        return ext;
    };

    /**
     * Get the mimetype of an extension. Returns undefined if not found.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#allPromises
     * @param  {String} extension Extension.
     * @return {String}           Mimetype.
     */
    self.getMimeType = function(extension) {
        if (mimeTypes[extension] && mimeTypes[extension].type) {
            return mimeTypes[extension].type;
        }
    };

    /**
     * Remove the extension from a path (if any).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeExtension
     * @param  {String} path Path.
     * @return {String}      Path without extension.
     */
    self.removeExtension = function(path) {
        var index = path.lastIndexOf('.');
        if (index > -1) {
            return path.substr(0, index); // Remove extension.
        }
        return path;
    };

    /**
     * Adds the basePath to a path if it doesn't have it already.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#addBasePathIfNeeded
     * @param {String} path Path to treat.
     * @return {String}     Path with basePath added.
     */
    self.addBasePathIfNeeded = function(path) {
        if (path.indexOf(basePath) > -1) {
            return path;
        } else {
            return self.concatenatePaths(basePath, path);
        }
    };

    /**
     * Unzips a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#unzipFile
     * @param  {String} path         Path to the ZIP file.
     * @param  {String} [destFolder] Path to the destination folder. If not defined, a new folder will be created with the
     *                               same location and name as the ZIP file (without extension).
     * @return {Promise}             Promise resolved when the file is unzipped.
     */
    self.unzipFile = function(path, destFolder) {
        // We need to use ansolute paths (including basePath).
        path = self.addBasePathIfNeeded(path);
         // If destFolder is not set, use same location as ZIP file.
        destFolder = self.addBasePathIfNeeded(destFolder || self.removeExtension(path));
        return $cordovaZip.unzip(path, destFolder);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Service to handle groups.
 *
 * @module mm.core.groups
 * @ngdoc service
 * @name $mmGroups
 */
.factory('$mmGroups', ["$log", "$q", "$mmSite", "$mmSitesManager", function($log, $q, $mmSite, $mmSitesManager) {

    $log = $log.getInstance('$mmGroups');

    // Group mode constants.
    self.NOGROUPS       = 0;
    self.SEPARATEGROUPS = 1;
    self.VISIBLEGROUPS  = 2;

    /**
     * Get the groups allowed in an activity.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getActivityAllowedGroups
     * @param {Number} cmid     Course module ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise}        Promise resolved when the groups are retrieved.
     */
    self.getActivityAllowedGroups = function(cmid, userid) {
        userid = userid || $mmSite.getUserId();

        var params = {
                cmid: cmid,
                userid: userid
            },
            preSets = {
                cacheKey: getActivityAllowedGroupsCacheKey(cmid, userid)
            };

        return $mmSite.read('core_group_get_activity_allowed_groups', params, preSets).then(function(response) {
            if (!response || !response.groups) {
                return $q.reject();
            }
            return response.groups;
        });
    };

    /**
     * Get cache key for group mode WS calls.
     *
     * @param {Number} cmid Course module ID.
     * @return {String}     Cache key.
     */
    function getActivityAllowedGroupsCacheKey(cmid, userid) {
        return 'mmGroups:allowedgroups:' + cmid + ':' + userid;
    }

    /**
     * Get the group mode of an activity.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getActivityGroupMode
     * @param {Number} cmid Course module ID.
     * @return {Promise}    Promise resolved when the group mode is retrieved.
     */
    self.getActivityGroupMode = function(cmid) {
        var params = {
                cmid: cmid
            },
            preSets = {
                cacheKey: getActivityGroupModeCacheKey(cmid)
            };

        return $mmSite.read('core_group_get_activity_groupmode', params, preSets).then(function(response) {
            if (!response || typeof response.groupmode == 'undefined') {
                return $q.reject();
            }
            return response.groupmode;
        });
    };

    /**
     * Get cache key for group mode WS calls.
     *
     * @param {Number} cmid Course module ID.
     * @return {String}     Cache key.
     */
    function getActivityGroupModeCacheKey(cmid) {
        return 'mmGroups:groupmode:' + cmid;
    }

    /**
     * Get user groups in courses.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getUserGroups
     * @param {Object[]|Number[]} courses List of courses or course ids to get the groups from.
     * @param {Boolean} [refresh]         True when we should not get the value from the cache.
     * @param {String} [siteid]           Site to get the groups from. If not defined, use current site.
     * @param {Number} [userid]           ID of the user. If not defined, use the userid related to siteid.
     * @return {Promise}                  Promise to be resolved when the groups are retrieved.
     */
    self.getUserGroups = function(courses, refresh, siteid, userid) {
        var promises = [],
            groups = [],
            deferred = $q.defer();

        angular.forEach(courses, function(course) {
            var courseid;
            if (typeof course == 'object') { // Param is array of courses.
                courseid = course.id;
            } else { // Param is array of courseids.
                courseid = course;
            }
            var promise = self.getUserGroupsInCourse(courseid, refresh, siteid, userid).then(function(coursegroups) {
                groups = groups.concat(coursegroups);
            });
            promises.push(promise);
        });

        $q.all(promises).finally(function() {
            // Use finally because we don't want to block the load of events if a request fails.
            deferred.resolve(groups);
        });

        return deferred.promise;
    };

    /**
     * Get user groups in a course.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getUserGroupsInCourse
     * @param {Number} courseid   ID of the course.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @param {String} [siteid]   Site to get the groups from. If not defined, use current site.
     * @param {Number} [userid]   ID of the user. If not defined, use ID related to siteid.
     * @return {Promise}        Promise to be resolved when the groups are retrieved.
     */
    self.getUserGroupsInCourse = function(courseid, refresh, siteid, userid) {
        siteid = siteid || $mmSite.getId();

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var presets = {},
                data = {
                    userid: userid || site.getUserId(),
                    courseid: courseid
                };
            if (refresh) {
                presets.getFromCache = false;
            }
            return site.read('core_group_get_course_user_groups', data, presets).then(function(response) {
                if (response && response.groups) {
                    return response.groups;
                } else {
                    return $q.reject();
                }
            });
        });
    };

    /**
     * Invalidates activity allowed groups.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#invalidateActivityAllowedGroups
     * @param {Number} cmid     Course module ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateActivityAllowedGroups = function(cmid, userid) {
        userid = userid || $mmSite.getUserId();
        return $mmSite.invalidateWsCacheForKey(getActivityAllowedGroupsCacheKey(cmid, userid));
    };

    /**
     * Invalidates activity group mode.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#invalidateActivityGroupMode
     * @param {Number} cmid Course module ID.
     * @return {Promise}    Promise resolved when the data is invalidated.
     */
    self.invalidateActivityGroupMode = function(cmid) {
        return $mmSite.invalidateWsCacheForKey(getActivityGroupModeCacheKey(cmid));
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * The default priority for init processes.
 * @module mm.core
 * @ngdoc constant
 * @name mmInitDelegateDefaultPriority
 */
.constant('mmInitDelegateDefaultPriority', 100)

/**
 * The maximum priority that an addon can use for init process, anything over that is reserved for core use.
 * @module mm.core
 * @ngdoc constant
 * @name mmInitDelegateMaxAddonPriority
 */
.constant('mmInitDelegateMaxAddonPriority', 599)

/**
 * Provider for initialisation mechanisms.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmInitDelegate
 */
.provider('$mmInitDelegate', ["mmInitDelegateDefaultPriority", function(mmInitDelegateDefaultPriority) {
    var initProcesses = {},
        self = {};

    /**
     * Registers an initialisation process.
     *
     * @description
     * Init processes can be used to add initialisation logic to the app. Anything that should
     * block the user interface while some processes are done should be an init process. When defining
     * an init process make sure you do not set a priority higher than mmInitDelegateMaxAddonPriority
     * in your addons. This is to make sure that your process does not happen before some essential
     * other core processes such as the upgrade, and restoring the user session.
     *
     * An init process should never change state or prompt user interaction.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmInitDelegateProvider#registerProcess
     * @param {String} name The name of the process.
     * @param {String|Function} callable The callable of the process. See {@link $mmUtil.resolveObject}.
     *                                   The resolved function will get $injector as first argument.
     * @param {Number} [priority=100] The priority of the process, the highest priority is executed first.
     * @param {Boolean} [blocking=false] Set this to true when this process should be resolved before any following one.
     * @return {Void}
     */
    self.registerProcess = function(name, callable, priority, blocking) {
        priority = typeof priority === 'undefined' ? mmInitDelegateDefaultPriority : priority;

        if (typeof initProcesses[name] !== 'undefined') {
            console.log('$mmInitDelegateProvider: Process \'' + name + '\' already defined.');
            return;
        }

        console.log('$mmInitDelegateProvider: Registered process \'' + name + '\'.');
        initProcesses[name] = {
            blocking: blocking,
            callable: callable,
            name: name,
            priority: priority
        };
    };

    self.$get = ["$q", "$log", "$injector", "$mmUtil", function($q, $log, $injector, $mmUtil) {

        $log = $log.getInstance('$mmInitDelegate');

        var self = {},
            readiness;

        /**
         * Convenience function to return a function that executes the process.
         *
         * @param  {Object} data The data of the process.
         * @return {Function}
         */
        function prepareProcess(data) {
            return function() {
                var promise,
                    fn;

                $log.debug('Executing init process \'' + data.name + '\'');

                try {
                    fn = $mmUtil.resolveObject(data.callable);
                } catch (e) {
                    $log.error('Could not resolve object of init process \'' + data.name + '\'. ' + e);
                    return;
                }

                try {
                    promise = fn($injector);
                } catch (e) {
                    $log.error('Error while calling the init process \'' + data.name + '\'. ' + e);
                    return;
                }

                return promise;
            };
        }

        /**
         * Executes the registered init processes.
         *
         * Reserved for core use, do not call directly.
         *
         * @module mm.core
         * @ngdoc service
         * @name $mmInitDelegate#executeInitProcesses
         * @protected
         * @return {Void}
         */
        self.executeInitProcesses = function() {
            var ordered = [],
                promises = [],
                dependency = $q.when();

            if (typeof readiness === 'undefined') {
                readiness = $q.defer();
            }

            // Re-ordering by priority.
            angular.forEach(initProcesses, function(data) {
                ordered.push(data);
            });
            ordered.sort(function(a, b) {
                return b.priority - a.priority;
            });

            // Execute all the processes.
            angular.forEach(ordered, function(data) {
                var promise;

                // Add the process to the dependency stack.
                promise = dependency.finally(prepareProcess(data));
                promises.push(promise);

                // If the new process is blocking, we set it as the dependency.
                if (data.blocking) {
                    dependency = promise;
                }
            });

            $q.all(promises).finally(readiness.resolve);
        };

        /**
         * Notifies when the app is ready.
         *
         * This returns a promise that is resolved when the app is initialised.
         *
         * Reserved for core use, do not call directly, use {@link $mmApp.ready} instead.
         *
         * @module mm.core
         * @ngdoc service
         * @name $mmInitDelegate#ready
         * @protected
         * @return {Promise} Resolved when the app is initialised. Never rejected.
         */
        self.ready = function() {
            if (typeof readiness === 'undefined') {
                // Prevent race conditions if this is called before executeInitProcesses.
                readiness = $q.defer();
            }

            return readiness.promise;
        };

        return self;
    }];

    return self;
}]);

/**
 * ionRadioFix - fixes a bug in iOS 9 UIWebView that breaks the tilde selector in CSS. To
 * use this fix, include it after your Ionic bundle JS.
 *
 * Note: due to Angular directive override limitations, you'll need to change any reference
 * to <ion-radio> to <ion-radio-fix> to apply this patched radio button.
 *
 * Also, make sure to add the new CSS from the second part of this gist.
 */
angular.module('ionic').directive('ionRadioFix', function() {
  return {
    restrict: 'E',
    replace: true,
    require: '?ngModel',
    transclude: true,
    template:
      '<label class="item item-radio">' +
        '<input type="radio" name="radio-group">' +
        '<div class="radio-content">' +
          '<div class="item-content disable-pointer-events" ng-transclude></div>' +
          '<i class="radio-icon disable-pointer-events icon ion-checkmark"></i>' +
        '</div>' +
      '</label>',

    compile: function(element, attr) {
      if (attr.icon) {
        var iconElm = element.find('i');
        iconElm.removeClass('ion-checkmark').addClass(attr.icon);
      }

      var input = element.find('input');
      angular.forEach({
          'name': attr.name,
          'value': attr.value,
          'disabled': attr.disabled,
          'ng-value': attr.ngValue,
          'ng-model': attr.ngModel,
          'ng-disabled': attr.ngDisabled,
          'ng-change': attr.ngChange,
          'ng-required': attr.ngRequired,
          'required': attr.required
      }, function(value, name) {
        if (angular.isDefined(value)) {
            input.attr(name, value);
          }
      });

      return function(scope, element, attr) {
        scope.getValue = function() {
          return scope.ngValue || attr.value;
        };
      };
    }
  };
});
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmLang
 * @module mm.core
 * @description
 * This service allows to add new languages strings.
 */
.factory('$mmLang', ["$translate", "$translatePartialLoader", "$mmConfig", "$cordovaGlobalization", "$q", "mmCoreConfigConstants", function($translate, $translatePartialLoader, $mmConfig, $cordovaGlobalization, $q, mmCoreConfigConstants) {

    var self = {},
        currentLanguage; // Save current language in a variable to speed up the get function.

    /**
     * Register a folder to search language files into it.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#registerLanguageFolder
     * @param  {String} path Path of the folder to use.
     * @return {Promise}     Promise resolved when file is loaded.
     */
    self.registerLanguageFolder = function(path) {
        $translatePartialLoader.addPart(path);
        return $translate.refresh();
    };

    /**
     * Get current language.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#getCurrentLanguage
     * @return {[type]} [description]
     */
    self.getCurrentLanguage = function() {

        if (typeof currentLanguage != 'undefined') {
            return $q.when(currentLanguage);
        }

        // Get current language from config (user might have changed it).
        return $mmConfig.get('current_language').then(function(language) {
            return language;
        }, function() {
            try {
                // User hasn't defined a language. Get it from cordova globalization.
                return $cordovaGlobalization.getPreferredLanguage().then(function(result) {
                    var language = result.value.toLowerCase();
                    if (language.indexOf('-') > -1) {
                        // Language code defined by locale has a dash, like en-US or es-ES. Check if it's supported.
                        if (mmCoreConfigConstants.languages && typeof mmCoreConfigConstants.languages[language] == 'undefined') {
                            // Code is NOT supported. Fallback to language without dash. E.g. 'en-US' would fallback to 'en'.
                            language = language.substr(0, language.indexOf('-'));

                        }
                    }
                    return language;
                }, function() {
                    // Error getting locale. Use default language.
                    return mmCoreConfigConstants.default_lang || 'en';
                });
            } catch(err) {
                // Error getting locale. Use default language.
                return mmCoreConfigConstants.default_lang || 'en';
            }
        }).then(function(language) {
            currentLanguage = language; // Save it for later.
            return language;
        });
    };

    /**
     * Change current language.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#changeCurrentLanguage
     * @param {String} language New language to use.
     * @return {Promise}        Promise resolved when the change is finished.
     */
    self.changeCurrentLanguage = function(language) {
        var p1 = $translate.use(language),
            p2 = $mmConfig.set('current_language', language);
        moment.locale(language);
        currentLanguage = language;
        return $q.all([p1, p2]);
    };

    /**
     * Translates an error message and returns a rejected promise with the translated message.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#translateAndReject
     * @param  {String} errorkey Key of the message to show.
     * @return {Promise}         Rejected promise.
     */
    self.translateAndReject = function(errorkey) {
        return $translate(errorkey).then(function(errorMessage) {
            return $q.reject(errorMessage);
        }, function() {
            return $q.reject(errorkey);
        });
    };

    /**
     * Translates an error message and rejects a deferred with the translated message.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#translateAndRejectDeferred
     * @param  {Object} deferred Deferred object to reject.
     * @param  {String} errorkey Key of the message to show.
     */
    self.translateAndRejectDeferred = function(deferred, errorkey) {
        $translate(errorkey).then(function(errorMessage) {
            deferred.reject(errorMessage);
        }, function() {
            deferred.reject(errorkey);
        });
    };

    return self;
}])

.config(["$translateProvider", "$translatePartialLoaderProvider", function($translateProvider, $translatePartialLoaderProvider) {

    $translateProvider.useLoader('$translatePartialLoader', {
        urlTemplate: '{part}/{lang}.json'
    });

    // Load the built language files from build/lang.
    $translatePartialLoaderProvider.addPart('build/lang');

    // Set fallback language.
    $translateProvider.fallbackLanguage('en');
    $translateProvider.preferredLanguage('en'); // Set English until we know which language to use.
}])

.run(["$ionicPlatform", "$translate", "$mmLang", function($ionicPlatform, $translate, $mmLang) {
    $ionicPlatform.ready(function() {
        $mmLang.getCurrentLanguage().then(function(language) {
            $translate.use(language);
            moment.locale(language);
        });
    });
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

// Stores used to create unique IDs for notifications.
.constant('mmCoreNotificationsSitesStore', 'notification_sites')
.constant('mmCoreNotificationsComponentsStore', 'notification_components')
.constant('mmCoreNotificationsTriggeredStore', 'notifications_triggered')

.config(["$mmAppProvider", "mmCoreNotificationsSitesStore", "mmCoreNotificationsComponentsStore", "mmCoreNotificationsTriggeredStore", function($mmAppProvider, mmCoreNotificationsSitesStore, mmCoreNotificationsComponentsStore,
        mmCoreNotificationsTriggeredStore) {
    var stores = [
        {
            name: mmCoreNotificationsSitesStore, // Store to asigne unique codes to each site.
            keyPath: 'id',
            indexes: [
                {
                    name: 'code',
                }
            ]
        },
        {
            name: mmCoreNotificationsComponentsStore, // Store to asigne unique codes to each component.
            keyPath: 'id',
            indexes: [
                {
                    name: 'code',
                }
            ]
        },
        {
            name: mmCoreNotificationsTriggeredStore, // Store to prevent re-triggering notifications.
            keyPath: 'id',
            indexes: []
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

/**
 * Factory to handle local notifications.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmLocalNotifications
 * @description
 * Provides methods to trigger notifications, listen clicks on them, etc.
 */
.factory('$mmLocalNotifications', ["$log", "$cordovaLocalNotification", "$mmApp", "$q", "mmCoreNotificationsSitesStore", "mmCoreNotificationsComponentsStore", "mmCoreNotificationsTriggeredStore", function($log, $cordovaLocalNotification, $mmApp, $q,
        mmCoreNotificationsSitesStore, mmCoreNotificationsComponentsStore, mmCoreNotificationsTriggeredStore) {

    $log = $log.getInstance('$mmLocalNotifications');

    var self = {},
        observers = {},
        codes = {}; // Store codes in memory to make getCode function faster.

    // We need a queue to request unique codes, to handle simultaneous requests.
    var codeRequestsQueue = {};

    /**
     * Get a code to create unique notifications. If there's no code assigned, create a new one.
     *
     * @param  {String} store Store to search in local DB.
     * @param  {String} id    ID of the element to get its code.
     * @return {Promise}      Promise resolved when the code is retrieved.
     */
    function getCode(store, id) {
        var db = $mmApp.getDB(),
            key = store + '#' + id;

        if (typeof codes[key] != 'undefined') {
            return $q.when(codes[key]);
        }

        return db.get(store, id).then(function(entry) {
            var code = parseInt(entry.code);
            codes[key] = code;
            return code;
        }, function() {
            // Site is not in the DB. Create a new ID for it.
            return db.query(store, undefined, 'code', true).then(function(entries) {
                var newCode = 0;
                if (entries.length > 0) {
                    newCode = parseInt(entries[0].code) + 1;
                }
                return db.insert(store, {id: id, code: newCode}).then(function() {
                    codes[key] = newCode;
                    return newCode;
                });
            });
        });
    }

    /**
     * Get a site code to be used.
     * If it's the first time this site is used to send notifications, create a new code for it.
     *
     * @param  {String} siteid   Site ID.
     * @return {Promise}         Promise resolved when the site code is retrieved.
     */
    function getSiteCode(siteid) {
        return requestCode(mmCoreNotificationsSitesStore, siteid);
    }

    /**
     * Get a notification component code to be used.
     * If it's the first time this component is used to send notifications, create a new code for it.
     *
     * @param {String} component Component name.
     * @return {Promise}         Promise resolved when the component code is retrieved.
     */
    function getComponentCode(component) {
        return requestCode(mmCoreNotificationsComponentsStore, component);
    }

    /**
     * Create a unique notification ID, trying to prevent collisions. Generated ID must be a Number (Android).
     * The generated ID shouldn't be higher than 2147483647 or it's going to cause problems in Android.
     * This function will prevent collisions and keep the number under Android limit if:
     *     -User has used less than 21 sites.
     *     -There are less than 11 components.
     *     -The notificationid passed as parameter is lower than 10000000.
     *
     * @param  {Number} notificationid Notification ID.
     * @param {String} component       Component triggering the notification.
     * @param  {String} siteid         Site ID.
     * @return {Promise}               Promise resolved when the notification ID is generated.
     */
    function getUniqueNotificationId(notificationid, component, siteid) {
        if (!siteid || !component) {
            return $q.reject();
        }

        return getSiteCode(siteid).then(function(sitecode) {
            return getComponentCode(component).then(function(componentcode) {
                // We use the % operation to keep the number under Android's limit.
                return (sitecode * 100000000 + componentcode * 10000000 + parseInt(notificationid)) % 2147483647;
            });
        });
    }

    /**
     * Process the next request in queue.
     */
    function processNextRequest() {
        var nextKey = Object.keys(codeRequestsQueue)[0],
            request,
            promise;

        if (typeof nextKey == 'undefined') {
            // No more requests in queue, stop.
            return;
        }

        request = codeRequestsQueue[nextKey];
        // Check if request is valid.
        if (angular.isObject(request) && typeof request.store != 'undefined' && typeof request.id != 'undefined') {
            // Get the code and resolve/reject all the promises of this request.
            promise = getCode(request.store, request.id).then(function(code) {
                angular.forEach(request.promises, function(p) {
                    p.resolve(code);
                });
            }, function(error) {
                angular.forEach(request.promises, function(p) {
                    p.reject(error);
                });
            });
        } else {
            promise = $q.when();
        }

        // Once this item is treated, remove it and process next.
        promise.finally(function() {
            delete codeRequestsQueue[nextKey];
            processNextRequest();
        });
    }

    /**
     * Request a unique code. The request will be added to the queue and the queue is going to be started if it's paused.
     *
     * @param  {String} store Store to search in local DB.
     * @param  {String} id    ID of the element to get its code.
     * @return {Promise}      Promise resolved when the code is retrieved.
     */
    function requestCode(store, id) {
        var deferred = $q.defer(),
            key = store+'#'+id,
            isQueueEmpty = Object.keys(codeRequestsQueue).length == 0;

        if (typeof codeRequestsQueue[key] != 'undefined') {
            // There's already a pending request for this store and ID, add the promise to it.
            codeRequestsQueue[key].promises.push(deferred);
        } else {
            // Add a pending request to the queue.
            codeRequestsQueue[key] = {
                store: store,
                id: id,
                promises: [deferred]
            };
        }

        if (isQueueEmpty) {
            processNextRequest();
        }

        return deferred.promise;
    }

    /**
     * Cancel a local notification.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#cancel
     * @param {Number} id        Notification id.
     * @param {String} component Component of the notification.
     * @param {String} siteid    Site ID.
     * @return {Promise}         Promise resolved when the notification is cancelled.
     */
    self.cancel = function(id, component, siteid) {
        return getUniqueNotificationId(id, component, siteid).then(function(uniqueId) {
            return $cordovaLocalNotification.cancel(uniqueId);
        });
    };

    /**
     * Cancel all the scheduled notifications belonging to a certain site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#cancelSiteNotifications
     * @param {String} siteid Site ID.
     * @return {Promise} Promise resolved when the notifications are cancelled.
     */
    self.cancelSiteNotifications = function(siteid) {

        if (!self.isAvailable()) {
            return $q.when();
        } else if (!siteid) {
            return $q.reject();
        }

        return $cordovaLocalNotification.getAllScheduled().then(function(scheduled) {
            var ids = [];

            angular.forEach(scheduled, function(notif) {
                if (typeof notif.data == 'string') {
                    notif.data = JSON.parse(notif.data);
                }

                if (typeof notif.data == 'object' && notif.data.siteid === siteid) {
                    ids.push(notif.id);
                }
            });

            return $cordovaLocalNotification.cancel(ids);
        });
    };

    /**
     * Returns whether local notifications plugin is installed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#isAvailable
     * @return {Boolean} True when local notifications plugin is installed.
     */
    self.isAvailable = function() {
        return window.plugin && window.plugin.notification && window.plugin.notification.local ? true: false;
    };

    /**
     * Check if a notification has been triggered with the same trigger time.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#isTriggered
     * @param  {Object}  notification Notification to check. Needs to have 'id' and 'at' properties.
     * @return {Promise}              Promise resolved with a boolean indicating if promise is triggered (true) or not.
     */
    self.isTriggered = function(notification) {
        return $mmApp.getDB().get(mmCoreNotificationsTriggeredStore, notification.id).then(function(stored) {
            var notifTime = notification.at.getTime() / 1000;
            return stored.at === notifTime;
        }, function() {
            return false;
        });
    };

    /**
     * Notify notification click to observer. Only the observer with the same component as the notification will be notified.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#notifyClick
     * @param {Object} data Data received by the notification.
     */
    self.notifyClick = function(data) {
        var component = data.component;
        if (component) {
            var callback = observers[component];
            if (typeof callback == 'function') {
                callback(data);
            }
        }
    };

    /**
     * Register an observer to be notified when a notification belonging to a certain component is clicked.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#registerClick
     * @param {String} component  Component to listen notifications for.
     * @param {Function} callback Function to call with the data received by the notification.
     */
    self.registerClick = function(component, callback) {
        $log.debug("Register observer '"+component+"' for notification click.");
        observers[component] = callback;
    };

    /**
     * Remove a notification from triggered store.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#removeTriggered
     * @param {String} id Notification ID.
     * @return {Promise}  Promise resolved when it is removed.
     */
    self.removeTriggered = function(id) {
        return $mmApp.getDB().remove(mmCoreNotificationsTriggeredStore, id);
    };

    /**
     * Schedule a local notification.
     * @see https://github.com/katzer/cordova-plugin-local-notifications/wiki/04.-Scheduling
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#schedule
     * @param {Object} notification Notification to schedule. Its ID should be lower than 10000000 and it should be unique inside
     *                              its component and site. If the ID is higher than that number there might be collisions.
     * @param {String} component    Component triggering the notification. It is used to generate unique IDs.
     * @param {String} siteid       Site ID.
     * @return {Promise}            Promise resolved when the notification is scheduled.
     */
    self.schedule = function(notification, component, siteid) {
        return getUniqueNotificationId(notification.id, component, siteid).then(function(uniqueId) {
            notification.id = uniqueId;
            notification.data = notification.data || {};
            notification.data.component = component;
            notification.data.siteid = siteid;

            return self.isTriggered(notification).then(function(triggered) {
                if (!triggered) {
                    // Remove from triggered, since the notification could be in there with a different time.
                    self.removeTriggered(notification.id);
                    return $cordovaLocalNotification.schedule(notification);
                }
            });
        });
    };

    /**
     * Function to call when a notification is triggered. Stores the notification so it's not scheduled again unless the
     * time is changed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#trigger
     * @param {Object} notification Triggered notification.
     * @return {Promise}            Promise resolved when stored, rejected otherwise.
     */
    self.trigger = function(notification) {
        var id = parseInt(notification.id);
        if (!isNaN(id)) {
            return $mmApp.getDB().insert(mmCoreNotificationsTriggeredStore, {
                id: id,
                at: parseInt(notification.at)
            });
        } else {
            return $q.reject();
        }
    };

    return self;
}])

.run(["$rootScope", "$log", "$mmLocalNotifications", "$mmEvents", "mmCoreEventSiteDeleted", function($rootScope, $log, $mmLocalNotifications, $mmEvents, mmCoreEventSiteDeleted) {
    $log = $log.getInstance('$mmLocalNotifications');

    $rootScope.$on('$cordovaLocalNotification:trigger', function(e, notification, state) {
        $mmLocalNotifications.trigger(notification);
    });

    $rootScope.$on('$cordovaLocalNotification:click', function(e, notification, state) {
        if (notification && notification.data) {
            $log.debug('Notification clicked: '+notification.data);
            var data = JSON.parse(notification.data);
            $mmLocalNotifications.notifyClick(data);
        }
    });

    $mmEvents.on(mmCoreEventSiteDeleted, function(site) {
        if (site) {
            $mmLocalNotifications.cancelSiteNotifications(site.id);
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreLogEnabledDefault', true) // Default value for logEnabled.
.constant('mmCoreLogEnabledConfigName', 'debug_enabled')

/**
 * Provider to decorate angular's $log service.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmLog
 * @description
 * $mmLogProvider.logDecorator function is designed to decorate '$log'. It should be used like this:
 *     $provide.decorator('$log', ['$delegate', $mmLogProvider.logDecorator]);
 *
 * Decorated $log usage:
 *     $log = $log.getInstance('MyFactory')
 *     $log.debug('My message') -> "dd/mm/aaaa hh:mm:ss MyFactory: My message"
 *
 * To permanently enable/disable logging messages, use:
 *     $mmLog.enabled(true/false)
 */
.provider('$mmLog', ["mmCoreLogEnabledDefault", function(mmCoreLogEnabledDefault) {

    var isEnabled = mmCoreLogEnabledDefault,
        self = this;

    // Function to pre-capture a logger function.
    function prepareLogFn(logFn, className) {
        className = className || '';
        // Invoke the specified 'logFn' with our new code.
        var enhancedLogFn = function() {
            if (isEnabled) {
                var args = Array.prototype.slice.call(arguments),
                    now  = moment().format('l LTS');

                args[0] = now + ' ' + className + ': ' + args[0]; // Prepend timestamp and className to the original message.
                logFn.apply(null, args);
            }
        };

        // Special, only needed to support angular-mocks expectations.
        enhancedLogFn.logs = [];

        return enhancedLogFn;
    }

    /**
     * Enhances $log service, adding date and component to the logged message, and allowing disable log.
     *
     * @param  {Service} $log Angular's $log service to decorate.
     * @return {Service}      Decorated $log.
     */
    self.logDecorator = function($log) {
        // Copy the original methods.
        var _$log = (function($log) {
            return {
                log   : $log.log,
                info  : $log.info,
                warn  : $log.warn,
                debug : $log.debug,
                error : $log.error
            };
        })($log);

        // Create the getInstance method so services/controllers can configure the className to be shown.
        var getInstance = function(className) {
            return {
                log   : prepareLogFn(_$log.log, className),
                info  : prepareLogFn(_$log.info, className),
                warn  : prepareLogFn(_$log.warn, className),
                debug : prepareLogFn(_$log.debug, className),
                error : prepareLogFn(_$log.error, className)
            };
        };

        // Decorate original $log functions too. This way if a service/controller uses $log without $log.getInstance,
        // it's going to prepend the date and 'Core'.
        $log.log   = prepareLogFn($log.log);
        $log.info  = prepareLogFn($log.info);
        $log.warn  = prepareLogFn($log.warn);
        $log.debug = prepareLogFn($log.debug);
        $log.error = prepareLogFn($log.error);
        $log.getInstance = getInstance;

        return $log;
    };

    this.$get = ["$mmConfig", "mmCoreLogEnabledDefault", "mmCoreLogEnabledConfigName", function($mmConfig, mmCoreLogEnabledDefault, mmCoreLogEnabledConfigName) {
        var self = {};

        /**
         * Initialize logging, enabling/disabling it based on settings and mmCoreLogEnabledDefault.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmLog#init
         */
        self.init = function() {
            $mmConfig.get(mmCoreLogEnabledConfigName).then(function(enabled) {
                isEnabled = enabled;
            }, function() {
                // Not set, use default value.
                isEnabled = mmCoreLogEnabledDefault;
            });
        }

        /**
         * Enable/disable logging in the app.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmLog#enabled
         * @param {Boolean} flag True if log should be enabled, false otherwise.
         */
        self.enabled = function(flag) {
            $mmConfig.set(mmCoreLogEnabledConfigName, flag);
            isEnabled = flag;
        };

        /**
         * Check if app logging is enabled.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmLog#isEnabled
         * @return {Boolean} True if log is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return isEnabled;
        };

        return self;
    }];
}])

.run(["$mmLog", function($mmLog) {
    $mmLog.init();
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Service to provide functionalities related to current site.
 *
 * @module mm.core
 * @ngdoc factory
 * @name $mmSite
 * @description
 * This services provides a set of functionalities related to current site. The current site instance is stored in $mmSitesManager.
 * This service can be seen as an instance of Site defined in $mmSitesFactory, with one method added: $mmSite.isLoggedIn.
 */
.factory('$mmSite', ["$mmSitesManager", "$mmSitesFactory", function($mmSitesManager, $mmSitesFactory) {

    var self = {},
        siteMethods = $mmSitesFactory.getSiteMethods();

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getId
     * @return {String} Current site ID.
     * @description
     *
     * Get current site ID.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getURL
     * @return {String} Current site URL.
     * @description
     *
     * Get current site URL.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getToken
     * @return {String} Current site token.
     * @description
     *
     * Get current site token.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getInfo
     * @return {Object} Current site info.
     * @description
     *
     * Get current site info.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getDb
     * @return {Object} Current site DB.
     * @description
     *
     * Get current site DB.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getUserId
     * @return {Object} User's ID.
     * @description
     *
     * Get current site user's ID.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#setId
     * @param {String} New ID.
     * @description
     *
     * Set current site ID.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#setToken
     * @param {String} New token.
     * @description
     *
     * Set current site token.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canAccessMyFiles
     * @return {Boolean} False when they cannot.
     * #description
     *
     * Check if user can access private files in current site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canDownloadFiles
     * @return {Boolean} False when they cannot.
     * #description
     *
     * Check if user can download files in current site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canUseAdvancedFeature
     * @param {String} feature The name of the feature.
     * @param {Boolean} [whenUndefined=true] The value to return when the parameter is undefined
     * @return {Boolean} False when they cannot.
     * @description
     *
     * Can the user use an advanced feature?
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canUploadFiles
     * @return {Boolean} False when they cannot.
     * #description
     *
     * Check if user can upload files in current site.
     */

    /**
     * Fetch site info from the Moodle site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#fetchSiteInfo
     * @return {Promise} A promise to be resolved when the site info is retrieved.
     * #description
     *
     * Fetch site info from the current Moodle site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#read
     * @param  {String} read  WS method to use.
     * @param  {Object} data    Data to send to the WS.
     * @param  {Object} preSets Options. @see $mmSite#request.
     * @return {Promise}        Promise to be resolved when the request is finished.
     * #description
     *
     * Read some data from the current Moodle site using WS. Requests are cached by default.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#write
     * @param  {String} method  WS method to use.
     * @param  {Object} data    Data to send to the WS.
     * @param  {Object} preSets Options. @see $mmSite#request.
     * @return {Promise}        Promise to be resolved when the request is finished.
     * #description
     *
     * Sends some data to the current Moodle site using WS. Requests are NOT cached by default.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#request
     * @param {string} method The WebService method to be called.
     * @param {Object} data Arguments to pass to the method.
     * @param {Object} preSets Extra settings.
     *                    - getFromCache boolean (false) Use the cache when possible.
     *                    - saveToCache boolean (false) Save the call results to the cache.
     *                    - omitExpires boolean (false) Ignore cache expiry.
     *                    - sync boolean (false) Add call to queue if device is not connected.
     *                    - cacheKey (string) Extra key to add to the cache when storing this call. This key is to
     *                                        flag the cache entry, it doesn't affect the data retrieved in this call.
     *                    - getCacheUsingCacheKey (boolean) True if it should retrieve cached data by cacheKey,
     *                                        false if it should get the data based on the params passed (usual behavior).
     * @return {Promise}
     * @description
     *
     * Sends a webservice request to the site. This method will automatically add the
     * required parameters and pass it on to the low level API in $mmWS.call().
     *
     * Caching is also implemented, when enabled this method will returned a cached
     * version of itself rather than contacting the server.
     *
     * This method is smart which means that it will try to map the method to a
     * compatibility one if need be, usually that means that it will fallback on
     * the 'local_mobile_' prefixed function if it is available and the non-prefixed is not.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#wsAvailable
     * @param  {String}       method      WS name.
     * @param  {Boolean=true} checkPrefix When true also checks with the compatibility prefix.
     * @return {Boolean}                  True if the WS is available, false otherwise.
     * @description
     * Check if a WS is available in the current site.
     *
     * This method checks if a web service function is available. By default it will
     * also check if there is a compatibility function for it, e.g. a prefixed one.
     */

    /*
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#uploadFile
     * @param {Object} uri File URI.
     * @param {Object} options File settings: fileKey, fileName and mimeType.
     * @return {Promise}
     * @description
     *
     * Uploads a file to the current site using Cordova File API.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#invalidateWsCacheForKey
     * @param  {String} key Key to search.
     * @return {Promise}    Promise resolved when the cache entries are invalidated.
     * @description
     *
     * Invalidates all the cache entries with a certain key.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#invalidateWsCacheForKeyStartingWith
     * @param  {String} key Key to search.
     * @return {Promise}    Promise resolved when the cache entries are invalidated.
     * @description
     *
     * Invalidates all the cache entries whose key starts with a certain value.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#fixPluginfileURL
     * @param {String} url   The url to be fixed.
     * @return {String}      Fixed URL.
     * @description
     *
     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
     * Uses $mmUtil.fixPluginfileURL, passing current site's token.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#deleteDB
     * @return {Promise} Promise to be resolved when the DB is deleted.
     * @description
     *
     * Deletes current site's DB.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#deleteFolder
     * @return {Promise} Promise to be resolved when the folder is deleted.
     * @description
     *
     * Deletes current site's folder.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getSpaceUsage
     * @return {Promise} Promise resolved with the site space usage (size).
     * @description
     *
     * Get space usage of the site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getDocsUrl
     * @param {String} [page]    Docs page to go to.
     * @return {Promise}         Promise resolved with the Moodle docs URL.
     * @description
     *
     * Returns the URL to the documentation of the app, based on Moodle version and current language.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#checkLocalMobilePlugin
     * @return {Promise} Promise resolved when the check is done. Resolve params:
     *                           - {Number} code Code to identify the authentication method to use.
     *                           - {String} [service] If defined, name of the service to use.
     *                           - {String} [warning] If defined, code of the warning message.
     * @description
     *
     * Check if the local_mobile plugin is installed in the Moodle site.
     * This plugin provide extended services.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#checkLocalMobilePlugin
     * @return {Promise} Promise resolved it local_mobile was added, rejected otherwise.
     * @description
     *
     * Check if local_mobile has been installed in Moodle but the app is not using it.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#containsUrl
     * @param  {String}  url URL to check.
     * @return {Boolean}     True if URL belongs to this site, false otherwise.
     * @description
     *
     * Check if a URL belongs to this site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getCompatibleFunction
     * @param  {String} method WS function to check.
     * @return {String}        Method to use based in the available functions.
     * @description
     *
     * Return the function to be used, based on the available functions in the site. It'll try to use non-deprecated
     * functions first, and fallback to deprecated ones if needed.
     */

    // Replicate all Site methods refined in $mmSitesFactory to be used with current site.
    angular.forEach(siteMethods, function(method) {
        self[method] = function() {
            var currentSite = $mmSitesManager.getCurrentSite();
            if (typeof currentSite == 'undefined') {
                return undefined;
            } else {
                return currentSite[method].apply(currentSite, arguments);
            }
        };
    });

    /**
     * Check if the user is logged in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#isLoggedIn
     * @return {Boolean} True if the user is logged in a site, false otherwise.
     */
    self.isLoggedIn = function() {
        var currentSite = $mmSitesManager.getCurrentSite();
        return typeof currentSite != 'undefined' && typeof currentSite.token != 'undefined' && currentSite.token != '';
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.value('mmCoreWSPrefix', 'local_mobile_')

.constant('mmCoreWSCacheStore', 'wscache')

.config(["$mmSitesFactoryProvider", "mmCoreWSCacheStore", function($mmSitesFactoryProvider, mmCoreWSCacheStore) {
    var stores = [
        {
            name: mmCoreWSCacheStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'key'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Provider to create sites instances.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmSitesFactory
 * @description
 * This provider is the interface with the DB database. The modules that need to store
 * information here need to register their stores.
 *
 * Example:
 *
 * .config(function($mmSitesFactoryProvider) {
 *      $mmSitesFactoryProvider.registerStore({
 *          name: 'courses',
 *          keyPath: 'id'
 *      });
 *  })
 *
 * The service $mmSitesFactory is used to create site instances. It's not intended to be used directly, its usage is
 * restricted to core. Developers should only use $mmSitesFactoryProvider, $mmSitesManager and $mmSite.
 */
.provider('$mmSitesFactory', function() {

    /** Define the site storage schema. */
    var siteSchema = {
            stores: []
        },
        dboptions = {
            autoSchema: true
        };

    /**
     * Register a store schema.
     * IMPORTANT: Modifying the schema of an already existing store deletes all its data in WebSQL Storage.
     * If a store schema needs to be modified, the data should be manually migrated to the new store.
     *
     * @param  {Object} store The store object definition.
     * @return {Void}
     */
    this.registerStore = function(store) {
        if (typeof(store.name) === 'undefined') {
            console.log('$mmSite: Error: store name is undefined.');
            return;
        } else if (storeExists(store.name)) {
            console.log('$mmSite: Error: store ' + store.name + ' is already defined.');
            return;
        }
        siteSchema.stores.push(store);
    };

    /**
     * Register multiple stores at once.
     * IMPORTANT: Modifying the schema of an already existing store deletes all its data in WebSQL Storage.
     * If a store schema needs to be modified, the data should be manually migrated to the new store.
     *
     * @param  {Array} stores Array of store objects.
     * @return {Void}
     */
    this.registerStores = function(stores) {
        var self = this;
        angular.forEach(stores, function(store) {
            self.registerStore(store);
        });
    };

    /**
     * Check if a store is already defined.
     *
     * @param  {String} name The name of the store.
     * @return {Boolean} True when the store was already defined.
     */
    function storeExists(name) {
        var exists = false;
        angular.forEach(siteSchema.stores, function(store) {
            if (store.name === name) {
                exists = true;
            }
        });
        return exists;
    }

    this.$get = ["$http", "$q", "$mmWS", "$mmDB", "$log", "md5", "$mmApp", "$mmLang", "$mmUtil", "$mmFS", "mmCoreWSCacheStore", "mmCoreWSPrefix", "mmCoreSessionExpired", "$mmEvents", "mmCoreEventSessionExpired", "mmCoreUserDeleted", "mmCoreEventUserDeleted", "$mmText", "mmCoreConfigConstants", function($http, $q, $mmWS, $mmDB, $log, md5, $mmApp, $mmLang, $mmUtil, $mmFS, mmCoreWSCacheStore,
            mmCoreWSPrefix, mmCoreSessionExpired, $mmEvents, mmCoreEventSessionExpired, mmCoreUserDeleted, mmCoreEventUserDeleted,
            $mmText, mmCoreConfigConstants) {

        $log = $log.getInstance('$mmSite');

        /**
         * List of deprecated WS functions with their corresponding NOT deprecated name.
         *
         * When the function does not have an equivalent set its value to true.
         *
         * @type {Object}
         */
        var deprecatedFunctions = {
            "core_grade_get_definitions": "core_grading_get_definitions",
            "moodle_course_create_courses": "core_course_create_courses",
            "moodle_course_get_courses": "core_course_get_courses",
            "moodle_enrol_get_users_courses": "core_enrol_get_users_courses",
            "moodle_file_get_files": "core_files_get_files",
            "moodle_file_upload": "core_files_upload",
            "moodle_group_add_groupmembers": "core_group_add_group_members",
            "moodle_group_create_groups": "core_group_create_groups",
            "moodle_group_delete_groupmembers": "core_group_delete_group_members",
            "moodle_group_delete_groups": "core_group_delete_groups",
            "moodle_group_get_course_groups": "core_group_get_course_groups",
            "moodle_group_get_groupmembers": "core_group_get_group_members",
            "moodle_group_get_groups": "core_group_get_groups",
            "moodle_message_send_instantmessages": "core_message_send_instant_messages",
            "moodle_notes_create_notes": "core_notes_create_notes",
            "moodle_role_assign": "core_role_assign_role",
            "moodle_role_unassign": "core_role_unassign_role",
            "moodle_user_create_users": "core_user_create_users",
            "moodle_user_delete_users": "core_user_delete_users",
            "moodle_user_get_course_participants_by_id": "core_user_get_course_user_profiles",
            "moodle_user_get_users_by_courseid": "core_enrol_get_enrolled_users",
            // Both *_user_get_users_by_id are deprecated, but there is no equivalent available in the Mobile service.
            "moodle_user_get_users_by_id": "core_user_get_users_by_id",
            "moodle_user_update_users": "core_user_update_users",
            "moodle_webservice_get_siteinfo": "core_webservice_get_site_info",
        };

        var self = {};

        /**
         * Site object to store site data.
         *
         * @param {String} id      Site ID.
         * @param {String} siteurl Site URL.
         * @param {String} token   User's token in the site.
         * @param {Object} infos   Site's info.
         */
        function Site(id, siteurl, token, infos) {
            this.id = id;
            this.siteurl = siteurl;
            this.token = token;
            this.infos = infos;

            if (this.id) {
                this.db = $mmDB.getDB('Site-' + this.id, siteSchema, dboptions);
            }
        }

        /**
         * Get site ID.
         *
         * @return {String} Current site ID.
         */
        Site.prototype.getId = function() {
            return this.id;
        };

        /**
         * Get site URL.
         *
         * @return {String} Current site URL.
         */
        Site.prototype.getURL = function() {
            return this.siteurl;
        };

        /**
         * Get site token.
         *
         * @return {String} Current site token.
         */
        Site.prototype.getToken = function() {
            return this.token;
        };

        /**
         * Get site info.
         *
         * @return {Object} Current site info.
         */
        Site.prototype.getInfo = function() {
            return this.infos;
        };

        /**
         * Get site DB.
         *
         * @return {Object} Current site DB.
         */
        Site.prototype.getDb = function() {
            return this.db;
        };

        /**
         * Get site user's ID.
         *
         * @return {Object} User's ID.
         */
        Site.prototype.getUserId = function() {
            if (typeof this.infos != 'undefined' && typeof this.infos.userid != 'undefined') {
                return this.infos.userid;
            } else {
                return undefined;
            }
        };

        /**
         * Set site ID.
         *
         * @param {String} New ID.
         */
        Site.prototype.setId = function(id) {
            this.id = id;
            this.db = $mmDB.getDB('Site-' + this.id, siteSchema, dboptions);
        };

        /**
         * Set site token.
         *
         * @param {String} New token.
         */
        Site.prototype.setToken = function(token) {
            this.token = token;
        };

        /**
         * Set site info.
         *
         * @param {Object} New info.
         */
        Site.prototype.setInfo = function(infos) {
            this.infos = infos;
        };

        /**
         * Can the user access their private files?
         *
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canAccessMyFiles = function() {
            var infos = this.getInfo();
            return infos && (typeof infos.usercanmanageownfiles === 'undefined' || infos.usercanmanageownfiles);
        };

        /**
         * Can the user download files?
         *
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canDownloadFiles = function() {
            var infos = this.getInfo();
            return infos && infos.downloadfiles;
        };

        /**
         * Can the user use an advanced feature?
         *
         * @param {String} feature The name of the feature.
         * @param {Boolean} [whenUndefined=true] The value to return when the parameter is undefined
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canUseAdvancedFeature = function(feature, whenUndefined) {
            var infos = this.getInfo(),
                canUse = true;

            whenUndefined = (typeof whenUndefined === 'undefined') ? true : whenUndefined;

            if (typeof infos.advancedfeatures === 'undefined') {
                canUse = whenUndefined;
            } else {

                angular.forEach(infos.advancedfeatures, function(item) {
                    if (item.name === feature && parseInt(item.value, 10) === 0) {
                        canUse = false;
                    }
                });

            }

            return canUse;
        };

        /**
         * Can the user upload files?
         *
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canUploadFiles = function() {
            var infos = this.getInfo();
            return infos && infos.uploadfiles;
        };

        /**
         * Fetch site info from the Moodle site.
         *
         * @return {Promise} A promise to be resolved when the site info is retrieved.
         */
        Site.prototype.fetchSiteInfo = function() {
            var deferred = $q.defer(),
                site = this;

            // get_site_info won't be cached.
            var preSets = {
                getFromCache: 0,
                saveToCache: 0
            };

            site.read('core_webservice_get_site_info', {}, preSets).then(deferred.resolve, function(error) {
                site.read('moodle_webservice_get_siteinfo', {}, preSets).then(deferred.resolve, function(error) {
                    deferred.reject(error);
                });
            });

            return deferred.promise;
        };

        /**
         * Read some data from the Moodle site using WS. Requests are cached by default.
         *
         * @param  {String} read  WS method to use.
         * @param  {Object} data    Data to send to the WS.
         * @param  {Object} preSets Options: @see Site#request.
         * @return {Promise}        Promise to be resolved when the request is finished.
         */
        Site.prototype.read = function(method, data, preSets) {
            preSets = preSets || {};
            if (typeof(preSets.getFromCache) === 'undefined') {
                preSets.getFromCache = 1;
            }
            if (typeof(preSets.saveToCache) === 'undefined') {
                preSets.saveToCache = 1;
            }
            if (typeof(preSets.sync) === 'undefined') {
                preSets.sync = 0;
            }
            return this.request(method, data, preSets);
        };

        /**
         * Sends some data to the Moodle site using WS. Requests are NOT cached by default.
         *
         * @param  {String} method  WS method to use.
         * @param  {Object} data    Data to send to the WS.
         * @param  {Object} preSets Options: @see Site#request.
         * @return {Promise}        Promise to be resolved when the request is finished.
         */
        Site.prototype.write = function(method, data, preSets) {
            preSets = preSets || {};
            if (typeof(preSets.getFromCache) === 'undefined') {
                preSets.getFromCache = 0;
            }
            if (typeof(preSets.saveToCache) === 'undefined') {
                preSets.saveToCache = 0;
            }
            if (typeof(preSets.sync) === 'undefined') {
                preSets.sync = 0;
            }
            return this.request(method, data, preSets);
        };

        /**
         * WS request to the site.
         *
         * @param {string} method The WebService method to be called.
         * @param {Object} data Arguments to pass to the method.
         * @param {Object} preSets Extra settings.
         *                    - getFromCache boolean (false) Use the cache when possible.
         *                    - saveToCache boolean (false) Save the call results to the cache.
         *                    - omitExpires boolean (false) Ignore cache expiry.
         *                    - emergencyCache boolean (true) If possible, use the cache when the request fails.
         *                    - sync boolean (false) Add call to queue if device is not connected.
         *                    - cacheKey (string) Extra key to add to the cache when storing this call. This key is to
         *                                        flag the cache entry, it doesn't affect the data retrieved in this call.
         *                    - getCacheUsingCacheKey (boolean) True if it should retrieve cached data by cacheKey,
         *                                        false if it should get the data based on the params passed (usual behavior).
         * @return {Promise}
         * @description
         *
         * Sends a webservice request to the site. This method will automatically add the
         * required parameters and pass it on to the low level API in $mmWS.call().
         *
         * Caching is also implemented, when enabled this method will returned a cached
         * version of itself rather than contacting the server.
         *
         * This method is smart which means that it will try to map the method to a
         * compatibility one if need be, usually that means that it will fallback on
         * the 'local_mobile_' prefixed function if it is available and the non-prefixed is not.
         */
        Site.prototype.request = function(method, data, preSets) {
            var deferred = $q.defer(),
                site = this;
            data = data || {};

            // Get the method to use based on the available ones.
            method = site.getCompatibleFunction(method);

            // Check if the method is available, use a prefixed version if possible.
            // We ignore this check when we do not have the site info, as the list of functions is not loaded yet.
            if (site.getInfo() && !site.wsAvailable(method, false)) {
                if (site.wsAvailable(mmCoreWSPrefix + method, false)) {
                    $log.info("Using compatibility WS method '" + mmCoreWSPrefix + method + "'");
                    method = mmCoreWSPrefix + method;
                } else {
                    $log.error("WS function '" + method + "' is not available, even in compatibility mode.");
                    $mmLang.translateAndRejectDeferred(deferred, 'mm.core.wsfunctionnotavailable');
                    return deferred.promise;
                }
            }

            preSets = angular.copy(preSets) || {};
            preSets.wstoken = site.token;
            preSets.siteurl = site.siteurl;

            // Enable text filtering.
            data.moodlewssettingfilter = true;

            getFromCache(site, method, data, preSets).then(function(data) {
                deferred.resolve(data);
            }, function() {
                // Do not pass those options to the core WS factory.
                var wsPreSets = angular.copy(preSets);
                delete wsPreSets.getFromCache;
                delete wsPreSets.saveToCache;
                delete wsPreSets.omitExpires;
                delete wsPreSets.cacheKey;
                delete wsPreSets.emergencyCache;
                delete wsPreSets.getCacheUsingCacheKey;

                // TODO: Sync

                $mmWS.call(method, data, wsPreSets).then(function(response) {

                    if (preSets.saveToCache) {
                        saveToCache(site, method, data, response, preSets.cacheKey);
                    }

                    // We pass back a clone of the original object, this may
                    // prevent errors if in the callback the object is modified.
                    deferred.resolve(angular.copy(response));
                }, function(error) {
                    if (error === mmCoreSessionExpired) {
                        // Session expired, trigger event.
                        $mmLang.translateAndRejectDeferred(deferred, 'mm.core.lostconnection');
                        $mmEvents.trigger(mmCoreEventSessionExpired, site.id);
                    } else if (error === mmCoreUserDeleted) {
                        // User deleted, trigger event.
                        $mmLang.translateAndRejectDeferred(deferred, 'mm.core.userdeleted');
                        $mmEvents.trigger(mmCoreEventUserDeleted, {siteid: site.id, params: data});
                    } else if (typeof preSets.emergencyCache !== 'undefined' && !preSets.emergencyCache) {
                        $log.debug('WS call ' + method + ' failed. Emergency cache is forbidden, rejecting.');
                        deferred.reject(error);
                    } else {
                        $log.debug('WS call ' + method + ' failed. Trying to use the emergency cache.');
                        preSets.omitExpires = true;
                        preSets.getFromCache = true;
                        getFromCache(site, method, data, preSets).then(function(data) {
                            deferred.resolve(data);
                        }, function() {
                            deferred.reject(error);
                        });
                    }
                });
            });

            return deferred.promise;
        };

        /**
         * Check if a WS is available in this site.
         *
         * @param  {String} method WS name.
         * @param  {Boolean=true} checkPrefix When true also checks with the compatibility prefix.
         * @return {Boolean}       True if the WS is available, false otherwise.
         * @description
         *
         * This method checks if a web service function is available. By default it will
         * also check if there is a compatibility function for it, e.g. a prefixed one.
         */
        Site.prototype.wsAvailable = function(method, checkPrefix) {
            checkPrefix = (typeof checkPrefix === 'undefined') ? true : checkPrefix;

            if (typeof this.infos == 'undefined') {
                return false;
            }

            for (var i = 0; i < this.infos.functions.length; i++) {
                var f = this.infos.functions[i];
                if (f.name == method) {
                    return true;
                }
            }

            // Let's try again with the compatibility prefix.
            if (checkPrefix) {
                return this.wsAvailable(mmCoreWSPrefix + method, false);
            }

            return false;
        };

        /*
         * Uploads a file using Cordova File API.
         *
         * @param {Object} uri File URI.
         * @param {Object} options File settings: fileKey, fileName and mimeType.
         * @return {Promise}
         */
        Site.prototype.uploadFile = function(uri, options) {
            return $mmWS.uploadFile(uri, options, {
                siteurl: this.siteurl,
                token: this.token
            });
        };

        /**
         * Invalidates all the cache entries.
         *
         * @return {Promise} Promise resolved when the cache entries are invalidated.
         */
        Site.prototype.invalidateWsCache = function() {
            var db = this.db;
            if (!db) {
                return $q.reject();
            }

            $log.debug('Invalidate all the cache for site: '+ this.id);
            return db.getAll(mmCoreWSCacheStore).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };

        /**
         * Invalidates all the cache entries with a certain key.
         *
         * @param  {String} key Key to search.
         * @return {Promise}    Promise resolved when the cache entries are invalidated.
         */
        Site.prototype.invalidateWsCacheForKey = function(key) {
            var db = this.db;
            if (!db || !key) {
                return $q.reject();
            }

            $log.debug('Invalidate cache for key: '+key);
            return db.whereEqual(mmCoreWSCacheStore, 'key', key).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };

        /**
         * Invalidates all the cache entries whose key starts with a certain value.
         *
         * @param  {String} key Key to search.
         * @return {Promise}    Promise resolved when the cache entries are invalidated.
         */
        Site.prototype.invalidateWsCacheForKeyStartingWith = function(key) {
            var db = this.db;
            if (!db || !key) {
                return $q.reject();
            }

            $log.debug('Invalidate cache for key starting with: '+key);
            return db.where(mmCoreWSCacheStore, 'key', '^', key).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };

        /**
         * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
         * Uses $mmUtil.fixPluginfileURL, passing site's token.
         *
         * @param {String} url   The url to be fixed.
         * @return {String}      Fixed URL.
         */
        Site.prototype.fixPluginfileURL = function(url) {
            return $mmUtil.fixPluginfileURL(url, this.token);

        };

        /**
         * Deletes site's DB.
         *
         * @return {Promise} Promise to be resolved when the DB is deleted.
         */
        Site.prototype.deleteDB = function() {
            return $mmDB.deleteDB('Site-' + this.id);
        };

        /**
         * Deletes site's folder.
         *
         * @return {Promise} Promise to be resolved when the DB is deleted.
         */
        Site.prototype.deleteFolder = function() {
            if ($mmFS.isAvailable()) {
                var siteFolder = $mmFS.getSiteFolder(this.id);
                return $mmFS.removeDir(siteFolder).catch(function() {
                    // Ignore any errors, $mmFS.removeDir fails if folder doesn't exists.
                });
            } else {
                return $q.when();
            }
        };

        /**
         * Get space usage of the site.
         *
         * @return {Promise} Promise resolved with the site space usage (size).
         */
        Site.prototype.getSpaceUsage = function() {
            if ($mmFS.isAvailable()) {
                var siteFolderPath = $mmFS.getSiteFolder(this.id);
                return $mmFS.getDirectorySize(siteFolderPath).catch(function() {
                    return 0;
                });
            } else {
                return $q.when(0);
            }
        };

        /**
         * Returns the URL to the documentation of the app, based on Moodle version and current language.
         *
         * @param {String} [page]    Docs page to go to.
         * @return {Promise}         Promise resolved with the Moodle docs URL.
         */
        Site.prototype.getDocsUrl = function(page) {
            var release = this.infos.release ? this.infos.release : undefined;
            return $mmUtil.getDocsUrl(release, page);
        };

        /**
         * Check if the local_mobile plugin is installed in the Moodle site.
         * This plugin provide extended services.
         *
         * @param {Boolean} retrying True if we're retrying the check.
         * @return {Promise}         Promise resolved when the check is done. Resolve params:
         *                                   - {Number} code Code to identify the authentication method to use.
         *                                   - {String} [service] If defined, name of the service to use.
         *                                   - {String} [warning] If defined, code of the warning message.
         */
        Site.prototype.checkLocalMobilePlugin = function(retrying) {
            var siteurl = this.siteurl,
                self = this,
                service = mmCoreConfigConstants.wsextservice;

            if (!service) {
                // External service not defined.
                return $q.when({code: 0});
            }

            return $http.post(siteurl + '/local/mobile/check.php', {service: service}).then(function(response) {
                var data = response.data;

                if (typeof data != 'undefined' && data.errorcode === 'requirecorrectaccess') {
                    if (!retrying) {
                        self.siteurl = $mmText.addOrRemoveWWW(siteurl);
                        return self.checkLocalMobilePlugin(true);
                    } else {
                        return $q.reject(data.error);
                    }
                } else if (typeof data == 'undefined' || typeof data.code == 'undefined') {
                    // local_mobile returned something we didn't expect. Let's assume it's not installed.
                    return {code: 0, warning: 'mm.login.localmobileunexpectedresponse'};
                }

                var code = parseInt(data.code, 10);
                if (data.error) {
                    switch (code) {
                        case 1:
                            // Site in maintenance mode.
                            return $mmLang.translateAndReject('mm.login.siteinmaintenance');
                        case 2:
                            // Web services not enabled.
                            return $mmLang.translateAndReject('mm.login.webservicesnotenabled');
                        case 3:
                            // Extended service not enabled, but the official is enabled.
                            return {code: 0};
                        case 4:
                            // Neither extended or official services enabled.
                            return $mmLang.translateAndReject('mm.login.mobileservicesnotenabled');
                        default:
                            return $mmLang.translateAndReject('mm.core.unexpectederror');
                    }
                } else {
                    return {code: code, service: service};
                }
            }, function() {
                return {code: 0};
            });
        };

        /**
         * Check if local_mobile has been installed in Moodle but the app is not using it.
         *
         * @return {Promise} Promise resolved it local_mobile was added, rejected otherwise.
         */
        Site.prototype.checkIfLocalMobileInstalledAndNotUsed = function() {
            var appUsesLocalMobile = false;
            angular.forEach(this.infos.functions, function(func) {
                if (func.name.indexOf(mmCoreWSPrefix) != -1) {
                    appUsesLocalMobile = true;
                }
            });

            if (appUsesLocalMobile) {
                // App already uses local_mobile, it wasn't added.
                return $q.reject();
            }

            return this.checkLocalMobilePlugin().then(function(data) {
                if (typeof data.service == 'undefined') {
                    // local_mobile NOT installed. Reject.
                    return $q.reject();
                }
                return data;
            });
        };

        /**
         * Check if a URL belongs to this site.
         *
         * @param  {String}  url URL to check.
         * @return {Boolean}     True if URL belongs to this site, false otherwise.
         */
        Site.prototype.containsUrl = function(url) {
            if (!url) {
                return false;
            }
            var siteurl = $mmText.removeProtocolAndWWW(this.siteurl);
            url = $mmText.removeProtocolAndWWW(url);
            return url.indexOf(siteurl) == 0;
        };

        /**
         * Invalidate entries from the cache.
         *
         * @param  {Object} db      DB the entries belong to.
         * @param  {Array}  entries Entries to invalidate.
         * @return {Promise}        Promise resolved when the cache entries are invalidated.
         */
        function invalidateWsCacheEntries(db, entries) {
            var promises = [];
            angular.forEach(entries, function(entry) {
                entry.expirationtime = 0;
                var promise = db.insert(mmCoreWSCacheStore, entry);
                promises.push(promise);
            });
            return $q.all(promises);
        }

        /**
         * Return the function to be used, based on the available functions in the site. It'll try to use non-deprecated
         * functions first, and fallback to deprecated ones if needed.
         *
         * @param  {String} method WS function to check.
         * @return {String}        Method to use based in the available functions.
         */
        Site.prototype.getCompatibleFunction = function(method) {
            if (typeof deprecatedFunctions[method] !== "undefined") {
                // Deprecated function is being used. Warn the developer.
                if (this.wsAvailable(deprecatedFunctions[method])) {
                    $log.warn("You are using deprecated Web Services: " + method +
                        " you must replace it with the newer function: " + deprecatedFunctions[method]);
                    return deprecatedFunctions[method];
                } else {
                    $log.warn("You are using deprecated Web Services. " +
                        "Your remote site seems to be outdated, consider upgrade it to the latest Moodle version.");
                }
            } else if (!this.wsAvailable(method)) {
                // Method not available. Check if there is a deprecated method to use.
                for (var oldFunc in deprecatedFunctions) {
                    if (deprecatedFunctions[oldFunc] === method && this.wsAvailable(oldFunc)) {
                        $log.warn("Your remote site doesn't support the function " + method +
                            ", it seems to be outdated, consider upgrade it to the latest Moodle version.");
                        return oldFunc; // Use deprecated function.
                    }
                }
            }
            return method;
        };

        /**
         * Get a WS response from cache.
         *
         * @param {Object} site    Site.
         * @param {String} method  The WebService method.
         * @param {Object} data    Arguments to pass to the method.
         * @param {Object} preSets Extra settings.
         * @return {Promise}       Promise to be resolved with the WS response.
         */
        function getFromCache(site, method, data, preSets) {
            var result,
                db = site.db,
                deferred = $q.defer(),
                id,
                promise;

            if (!db) {
                deferred.reject();
                return deferred.promise;
            } else if (!preSets.getFromCache) {
                deferred.reject();
                return deferred.promise;
            }

            id = md5.createHash(method + ':' + JSON.stringify(data));

            if (preSets.getCacheUsingCacheKey) {
                promise = db.whereEqual(mmCoreWSCacheStore, 'key', preSets.cacheKey).then(function(entries) {
                    if (entries.length == 0) {
                        // Cache key not found, get by params sent.
                        return db.get(mmCoreWSCacheStore, id);
                    }
                    return entries[0];
                });
            } else {
                promise = db.get(mmCoreWSCacheStore, id);
            }

            promise.then(function(entry) {
                var now = new Date().getTime();

                preSets.omitExpires = preSets.omitExpires || !$mmApp.isOnline();

                if (!preSets.omitExpires) {
                    if (now > entry.expirationtime) {
                        $log.debug('Cached element found, but it is expired');
                        deferred.reject();
                        return;
                    }
                }

                if (typeof entry != 'undefined' && typeof entry.data != 'undefined') {
                    var expires = (entry.expirationtime - now) / 1000;
                    $log.info('Cached element found, id: ' + id + ' expires in ' + expires + ' seconds');
                    deferred.resolve(entry.data);
                    return;
                }

                deferred.reject();
            }, function() {
                deferred.reject();
            });

            return deferred.promise;
        }

        /**
         * Save a WS response to cache.
         *
         * @param {Object} site    Site.
         * @param {String} method   The WebService method.
         * @param {Object} data     Arguments to pass to the method.
         * @param {Object} preSets  Extra settings.
         * @param {String} cacheKey (Optional) Extra key to add to the cache object to identify similar calls.
         * @return {Promise}        Promise to be resolved when the response is saved.
         */
        function saveToCache(site, method, data, response, cacheKey) {
            var db = site.db,
                id = md5.createHash(method + ':' + JSON.stringify(data)),
                cacheExpirationTime = mmCoreConfigConstants.cache_expiration_time,
                entry = {
                        id: id,
                        data: response
                    };

            if (!db) {
                return $q.reject();
            } else {
                cacheExpirationTime = isNaN(cacheExpirationTime) ? 300000 : cacheExpirationTime;
                entry.expirationtime = new Date().getTime() + cacheExpirationTime;
                if (cacheKey) {
                    entry.key = cacheKey;
                }
                return db.insert(mmCoreWSCacheStore, entry);
            }
        }

        /**
         * Make a site object.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmSitesFactory#makeSite
         * @param {String} id      Site ID.
         * @param {String} siteurl Site URL.
         * @param {String} token   User's token in the site.
         * @param {Object} infos   Site's info.
         * @return {Object} The current site object.
         * @description
         * This returns a site object.
         */
        self.makeSite = function(id, siteurl, token, infos) {
            return new Site(id, siteurl, token, infos);
        };

        /**
         * Gets the list of Site methods.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmSitesFactory#getSiteMethods
         * @return {Array} List of methods.
         */
        self.getSiteMethods = function() {
            var methods = [];
            for (var name in Site.prototype) {
                methods.push(name);
            }
            return methods;
        };

        return self;
    }];
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreSitesStore', 'sites')
.constant('mmCoreCurrentSiteStore', 'current_site')

.config(["$mmAppProvider", "mmCoreSitesStore", "mmCoreCurrentSiteStore", function($mmAppProvider, mmCoreSitesStore, mmCoreCurrentSiteStore) {
    var stores = [
        {
            name: mmCoreSitesStore,
            keyPath: 'id'
        },
        {
            name: mmCoreCurrentSiteStore,
            keyPath: 'id'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

/**
 * Sites manager service.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmSitesManager
 */
.factory('$mmSitesManager', ["$http", "$q", "$mmSitesFactory", "md5", "$mmLang", "$mmApp", "$mmUtil", "$mmEvents", "$state", "$translate", "mmCoreSitesStore", "mmCoreCurrentSiteStore", "mmCoreEventLogin", "mmCoreEventLogout", "$log", "mmCoreWSPrefix", "mmCoreEventSiteUpdated", "mmCoreEventSiteAdded", "mmCoreEventSessionExpired", "mmCoreEventSiteDeleted", "$mmText", "mmCoreConfigConstants", function($http, $q, $mmSitesFactory, md5, $mmLang, $mmApp, $mmUtil, $mmEvents, $state,
            $translate, mmCoreSitesStore, mmCoreCurrentSiteStore, mmCoreEventLogin, mmCoreEventLogout, $log, mmCoreWSPrefix,
            mmCoreEventSiteUpdated, mmCoreEventSiteAdded, mmCoreEventSessionExpired, mmCoreEventSiteDeleted, $mmText,
            mmCoreConfigConstants) {

    $log = $log.getInstance('$mmSitesManager');

    var self = {},
        services = {},
        sessionRestored = false,
        currentSite,
        sites = {};

    /**
     * Get the demo data of the siteurl if it is a demo site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getDemoSiteData
     * @param  {String} siteurl URL of the site to check.
     * @return {Object}         Site data if it's a demo site, undefined otherwise.
     */
    self.getDemoSiteData = function(siteurl) {
        var demoSites = mmCoreConfigConstants.demo_sites;
        if (typeof demoSites != 'undefined' && typeof demoSites[siteurl] != 'undefined') {
            return demoSites[siteurl];
        }
    };

    /**
     * Check if a site is valid and if it has specifics settings for authentication
     * (like force to log in using the browser).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#checkSite
     * @param {String} siteurl  URL of the site to check.
     * @param {String} protocol Protocol to use. If not defined, use https.
     * @return {Promise}        A promise to be resolved when the site is checked. Resolve params:
     *                            {Number} code      Code to identify the authentication method to use.
     *                            {String} siteurl   Site url to use (might have changed during the process).
     *                            {String} [warning] Code of the warning message to show to the user.
     */
    self.checkSite = function(siteurl, protocol) {

        // formatURL adds the protocol if is missing.
        siteurl = $mmUtil.formatURL(siteurl);

        if (siteurl.indexOf('://localhost') == -1 && !$mmUtil.isValidURL(siteurl)) {
            return $mmLang.translateAndReject('mm.login.invalidsite');
        } else if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        } else {

            protocol = protocol || "https://";

            // Now, replace the siteurl with the protocol.
            siteurl = siteurl.replace(/^http(s)?\:\/\//i, protocol);

            return self.siteExists(siteurl).then(function() {
                // Create a temporary site to check if local_mobile is installed.
                var temporarySite = $mmSitesFactory.makeSite(undefined, siteurl);
                return temporarySite.checkLocalMobilePlugin().then(function(data) {
                    siteurl = temporarySite.getURL();
                    services[siteurl] = data.service; // No need to store it in DB.
                    return {siteurl: siteurl, code: data.code, warning: data.warning};
                });
            }, function() {
                // Site doesn't exist.

                if (siteurl.indexOf("https://") === 0) {
                    // Retry without HTTPS.
                    return self.checkSite(siteurl, "http://");
                } else{
                    return $mmLang.translateAndReject('mm.core.cannotconnect');
                }
            });
        }
    };

    /**
     * Check if a site exists.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#siteExists
     * @param  {String} siteurl URL of the site to check.
     * @return {Promise}        A promise to be resolved if the site exists.
     */
    self.siteExists = function(siteurl) {
        var url = siteurl + '/login/token.php';
        if (!ionic.Platform.isWebView()) {
            // We pass fake parameters to make CORS work (without params, the script stops before allowing CORS).
            url = url + '?username=a&password=b&service=c';
        }
        return $http.get(url, {timeout: 30000});
    };

    /**
     * Gets a user token from the server.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getUserToken
     * @param {String} siteurl   The site url.
     * @param {String} username  User name.
     * @param {String} password  Password.
     * @param {String} [service] Service to use. If not defined, it will be searched in memory.
     * @param {Boolean} retry    We are retrying with a prefixed URL.
     * @return {Promise}         A promise to be resolved when the token is retrieved. If success, returns an object
     *                           with the token and the siteurl to use.
     */
    self.getUserToken = function(siteurl, username, password, service, retry) {
        retry = retry || false;

        if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        }

        if (!service) {
            service = determineService(siteurl);
        }

        var loginurl = siteurl + '/login/token.php';
        var data = {
            username: username,
            password: password,
            service: service
        };

        return $http.post(loginurl, data).then(function(response) {
            var data = response.data;

            if (typeof data == 'undefined') {
                return $mmLang.translateAndReject('mm.core.cannotconnect');
            } else {
                if (typeof data.token != 'undefined') {
                    return {token: data.token, siteurl: siteurl};
                } else {
                    if (typeof data.error != 'undefined') {
                        // We only allow one retry (to avoid loops).
                        if (!retry && data.errorcode == "requirecorrectaccess") {
                            siteurl = $mmText.addOrRemoveWWW(siteurl);
                            return self.getUserToken(siteurl, username, password, service, true);
                        } else {
                            return $q.reject(data.error);
                        }
                    } else {
                        return $mmLang.translateAndReject('mm.login.invalidaccount');
                    }
                }
            }
        }, function() {
            return $mmLang.translateAndReject('mm.core.cannotconnect');
        });
    };

    /**
     * Add a new site to the site list and authenticate the user in this site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#newSite
     * @param {String} siteurl  The site url.
     * @param {String} token    User's token.
     * @return {Promise}        A promise to be resolved when the site is added and the user is authenticated.
     */
    self.newSite = function(siteurl, token) {

        var candidateSite = $mmSitesFactory.makeSite(undefined, siteurl, token);

        return candidateSite.fetchSiteInfo().then(function(infos) {
            if (isValidMoodleVersion(infos)) {
                var validation = validateSiteInfo(infos);
                if (validation === true) {
                    var siteid = self.createSiteID(infos.siteurl, infos.username);
                    // Add site to sites list.
                    self.addSite(siteid, siteurl, token, infos);
                    // Turn candidate site into current site.
                    candidateSite.setId(siteid);
                    candidateSite.setInfo(infos);
                    currentSite = candidateSite;
                    // Store session.
                    self.login(siteid);
                    $mmEvents.trigger(mmCoreEventSiteAdded);
                } else {
                    return $translate(validation.error, validation.params).then(function(error) {
                        return $q.reject(error);
                    });
                }
            } else {
                return $mmLang.translateAndReject('mm.login.invalidmoodleversion');
            }
        });
    };

    /**
     * Create a site ID based on site URL and username.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#createSiteID
     * @param {String} siteurl  The site url.
     * @param {String} username Username.
     * @return {String}         Site ID.
     */
    self.createSiteID = function(siteurl, username) {
        return md5.createHash(siteurl + username);
    };

    /**
     * Function for determine which service we should use (default or extended plugin).
     *
     * @param  {String} siteurl The site URL.
     * @return {String}         The service shortname.
     */
    function determineService(siteurl) {
        // We need to try siteurl in both https or http (due to loginhttps setting).

        // First http://
        siteurl = siteurl.replace("https://", "http://");
        if (services[siteurl]) {
            return services[siteurl];
        }

        // Now https://
        siteurl = siteurl.replace("http://", "https://");
        if (services[siteurl]) {
            return services[siteurl];
        }

        // Return default service.
        return mmCoreConfigConstants.wsservice;
    }

    /**
     * Check for the minimum required version (Moodle 2.4).
     *
     * @param {Array} sitefunctions List of functions of the Moodle site.
     * @return {Boolean}            True if the moodle version is valid, false otherwise.
     */
    function isValidMoodleVersion(infos) {
        if (!infos) {
            return false;
        }

        var minVersion = 2012120300, // Moodle 2.4 version.
            minRelease = "2.4";

        // Try to validate by version.
        if (infos.version) {
            var version = parseInt(infos.version);
            if (!isNaN(version)) {
                return version >= minVersion;
            }
        }

        // We couldn't validate by version number. Let's try to validate by release number.
        if (infos.release) {
            var matches = infos.release.match(/^([\d|\.]*)/);
            if (matches && matches.length > 1) {
                return matches[1] >= minRelease;
            }
        }

        // Couldn't validate by release either. Check if it uses local_mobile plugin.
        var appUsesLocalMobile = false;
        angular.forEach(infos.functions, function(func) {
            if (func.name.indexOf(mmCoreWSPrefix) != -1) {
                appUsesLocalMobile = true;
            }
        });

        return appUsesLocalMobile;
    }

    /**
     * Check if site info is valid. If it's not, return error message.
     *
     * @param {Object} infos    Site info.
     * @return {Object|Boolean} Object with error message to show and its params if info is not valid, true if info is valid.
     */
    function validateSiteInfo(infos) {
        if (!infos.firstname || !infos.lastname) {
            var moodleLink = '<a mm-browser href="' + infos.siteurl + '">' + infos.siteurl + '</a>';
            return {error: 'mm.core.requireduserdatamissing', params: {'$a': moodleLink}};
        }
        return true;
    }

    /**
     * Saves a site in local DB.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#addSite
     * @param {String} id      Site ID.
     * @param {String} siteurl Site URL.
     * @param {String} token   User's token in the site.
     * @param {Object} infos   Site's info.
     */
    self.addSite = function(id, siteurl, token, infos) {
        return $mmApp.getDB().insert(mmCoreSitesStore, {
            id: id,
            siteurl: siteurl,
            token: token,
            infos: infos
        });
    };

    /**
     * Login a user to a site from the list of sites.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#loadSite
     * @param {String} siteid ID of the site to load.
     * @return {Promise}      Promise to be resolved when the site is loaded.
     */
    self.loadSite = function(siteid) {
        $log.debug('Load site '+siteid);

        return self.getSite(siteid).then(function(site) {
            currentSite = site;
            self.login(siteid);

            // Check if local_mobile was installed to Moodle.
            return site.checkIfLocalMobileInstalledAndNotUsed().then(function() {
                // Local mobile was added. Throw invalid session to force reconnect and create a new token.
                $mmEvents.trigger(mmCoreEventSessionExpired, siteid);
            }, function() {
                // Update site info. We don't block the UI.
                self.updateSiteInfo(siteid).finally(function() {
                    var infos = site.getInfo(),
                        validation = validateSiteInfo(infos);
                    if (validation !== true) {
                        // Site info is not valid. Logout the user and show an error message.
                        self.logout();
                        $state.go('mm_login.sites');
                        $translate(validation.error, validation.params).then(function(error) {
                            $mmUtil.showErrorModal(error);
                        });
                    }
                });
            });
        });
    };

    /**
     * Get current site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getCurrentSite
     * @return {Object} Current site.
     */
    self.getCurrentSite = function() {
        return currentSite;
    };

    /**
     * Delete a site from the sites list.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#deleteSite
     * @param {String} siteid ID of the site to delete.
     * @return {Promise}      Promise to be resolved when the site is deleted.
     */
    self.deleteSite = function(siteid) {
        $log.debug('Delete site '+siteid);

        if (typeof currentSite != 'undefined' && currentSite.id == siteid) {
            self.logout();
        }

        return self.getSite(siteid).then(function(site) {
            return site.deleteDB().then(function() {
                delete sites[siteid];
                return $mmApp.getDB().remove(mmCoreSitesStore, siteid).then(function() {
                    return site.deleteFolder();
                }, function() {
                    // DB remove shouldn't fail, but we'll go ahead even if it does.
                    return site.deleteFolder();
                }).then(function() {
                    $mmEvents.trigger(mmCoreEventSiteDeleted, site);
                });
            });
        });
    };

    /**
     * Check if there are no sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#hasNoSites
     * @return {Promise} Promise to be resolved if there are no sites, and rejected if there is at least one.
     */
    self.hasNoSites = function() {
        return $mmApp.getDB().count(mmCoreSitesStore).then(function(count) {
            if (count > 0) {
                return $q.reject();
            }
        });
    };

    /**
     * Check if there are sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#hasSites
     * @return {Promise} Promise to be resolved if there is at least one site, and rejected if there aren't.
     */
    self.hasSites = function() {
        return $mmApp.getDB().count(mmCoreSitesStore).then(function(count) {
            if (count == 0) {
                return $q.reject();
            }
        });
    };

    /**
     * Returns a site object.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSite
     * @param  {Number} siteId The site ID.
     * @return {Promise}
     */
    self.getSite = function(siteId) {
        if (!siteId) {
            // Site ID not valid, reject.
            return $q.reject();
        } else if (currentSite && currentSite.getId() === siteId) {
            return $q.when(currentSite);
        } else if (typeof sites[siteId] != 'undefined') {
            return $q.when(sites[siteId]);
        } else {
            return $mmApp.getDB().get(mmCoreSitesStore, siteId).then(function(data) {
                var site = $mmSitesFactory.makeSite(siteId, data.siteurl, data.token, data.infos);
                sites[siteId] = site;
                return site;
            });
        }
    };

    /**
     * Returns the database object of a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSiteDb
     * @param  {Number} siteId The site ID.
     * @return {Promise}
     */
    self.getSiteDb = function(siteId) {
        return self.getSite(siteId).then(function(site) {
            return site.getDb();
        });
    };

    /**
     * Get the list of sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSites
     * @param {String[]} [ids] IDs of the sites to get. If not defined, return all sites.
     * @return {Promise}       Promise to be resolved when the sites are retrieved.
     */
    self.getSites = function(ids) {
        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var formattedSites = [];
            angular.forEach(sites, function(site) {
                if (!ids || ids.indexOf(site.id) > -1) {
                    formattedSites.push({
                        id: site.id,
                        siteurl: site.siteurl,
                        fullname: site.infos.fullname,
                        sitename: site.infos.sitename,
                        avatar: site.infos.userpictureurl
                    });
                }
            });
            return formattedSites;
        });
    };

    /**
     * Get the list of IDs of sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSitesIds
     * @return {Promise} Promise to be resolved when the sites IDs are retrieved.
     */
    self.getSitesIds = function() {
        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var ids = [];
            angular.forEach(sites, function(site) {
                ids.push(site.id);
            });
            return ids;
        });
    };

    /**
     * Login the user in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#login
     * @param  {String} siteid ID of the site the user is accessing.
     * @return {Promise}       Promise resolved when current site is stored.
     */
    self.login = function(siteid) {
        return $mmApp.getDB().insert(mmCoreCurrentSiteStore, {
            id: 1,
            siteid: siteid
        }).then(function() {
            $mmEvents.trigger(mmCoreEventLogin);
        });
    };

    /**
     * Logout the user.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#logout
     * @return {Promise} Promise to be resolved when the user is logged out.
     */
    self.logout = function() {
        currentSite = undefined;
        $mmEvents.trigger(mmCoreEventLogout);
        return $mmApp.getDB().remove(mmCoreCurrentSiteStore, 1);
    }

    /**
     * Restores the session to the previous one so the user doesn't has to login everytime the app is started.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#restoreSession
     * @return {Promise} Promise to be resolved if a session is restored.
     */
    self.restoreSession = function() {
        if (sessionRestored) {
            return $q.reject();
        }
        sessionRestored = true;

        return $mmApp.getDB().get(mmCoreCurrentSiteStore, 1).then(function(current_site) {
            var siteid = current_site.siteid;
            $log.debug('Restore session in site '+siteid);
            return self.loadSite(siteid);
        }, function() {
            return $q.reject(); // Reject without params.
        });
    };

    /**
     * Updates a site's token.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#updateSiteToken
     * @param {String} siteurl  Site's URL.
     * @param {String} username Username.
     * @param {String} token    User's new token.
     * @return {Promise}        A promise to be resolved when the site is updated.
     */
    self.updateSiteToken = function(siteurl, username, token) {
        var siteid = self.createSiteID(siteurl, username);
        return self.getSite(siteid).then(function(site) {
            site.token = token;

            return $mmApp.getDB().insert(mmCoreSitesStore, {
                id: siteid,
                siteurl: site.getURL(),
                token: token,
                infos: site.getInfo()
            });
        });
    };

    /**
     * Updates a site's info.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#updateSiteInfo
     * @param {String} siteid Site's ID.
     * @return {Promise}      A promise to be resolved when the site is updated.
     */
    self.updateSiteInfo = function(siteid) {
        return self.getSite(siteid).then(function(site) {
            return site.fetchSiteInfo().then(function(infos) {
                site.setInfo(infos);
                return $mmApp.getDB().insert(mmCoreSitesStore, {
                    id: siteid,
                    siteurl: site.getURL(),
                    token: site.getToken(),
                    infos: infos
                }).finally(function() {
                    $mmEvents.trigger(mmCoreEventSiteUpdated, siteid);
                });
            });
        });
    };

    /**
     * Updates a site's info.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#updateSiteInfoByUrl
     * @param {String} siteurl  Site's URL.
     * @param {String} username Username.
     * @return {Promise}        A promise to be resolved when the site is updated.
     */
    self.updateSiteInfoByUrl = function(siteurl, username) {
        var siteid = self.createSiteID(siteurl, username);
        return self.updateSiteInfo(siteid);
    };

    /**
     * Get the site IDs a URL belongs to.
     * Someone can have more than one account in the same site, that's why this function returns an array of IDs.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSitesUrls
     * @param {String} url         URL to check.
     * @param {Boolean} prioritize True if it should prioritize current site. If the URL belongs to current site then it won't
     *                             check any other site, it will only return current site.
     * @return {Promise}           Promise resolved with the site IDs (array).
     */
    self.getSiteIdsFromUrl = function(url, prioritize) {
        // Check current site first, it has priority over the rest of sites.
        if (prioritize && currentSite && currentSite.containsUrl(url)) {
            return $q.when([currentSite.getId()]);
        }

        // Check if URL has http(s) protocol.
        if (!url.match(/^https?:\/\//i)) {
            // URL doesn't have http(s) protocol. Check if it has any protocol.
            if (url.match(/^[^:]{2,10}:\/\//i)) {
                // It has some protocol. Return empty array.
                return $q.when([]);
            } else {
                // No protocol, probably a relative URL. Return current site.
                if (currentSite) {
                    return $q.when([currentSite.getId()]);
                } else {
                    return $q.when([]);
                }
            }
        }

        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var ids = [];
            angular.forEach(sites, function(site) {
                if (!sites[site.id]) {
                    sites[site.id] = $mmSitesFactory.makeSite(site.id, site.siteurl, site.token, site.infos);
                }
                if (sites[site.id].containsUrl(url)) {
                    ids.push(site.id);
                }
            });
            return ids;
        }).catch(function() {
            // Shouldn't happen.
            return [];
        });
    };

    return self;

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmText
 * @module mm.core
 * @description
 * This service provides functions related to text, like formatting texts from Moodle.
 */
.factory('$mmText', ["$q", "$mmLang", "$translate", function($q, $mmLang, $translate) {

    var self = {};

    /**
     * Convert size in bytes into human readable format
     * http://codeaid.net/javascript/convert-size-in-bytes-to-human-readable-format-(javascript)
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#bytesToSize
     * @param {Number} bytes         Number of bytes to convert.
     * @param {Number} [precision=2] Number of digits after the decimal separator.
     * @return {String}              Size in human readable format.
     */
    self.bytesToSize = function(bytes, precision) {

        if (typeof bytes == 'undefined' || bytes < 0) {
            return $translate.instant('mm.core.notapplicable');
        }

        if (typeof precision == 'undefined' || precision < 0) {
            precision = 2;
        }

        var keys = ['mm.core.sizeb', 'mm.core.sizekb', 'mm.core.sizemb', 'mm.core.sizegb', 'mm.core.sizetb'];
        var units = $translate.instant(keys);
        var posttxt = 0;
        if (bytes >= 1024) {
            while (bytes >= 1024) {
                posttxt++;
                bytes = bytes / 1024;
            }
            bytes = Number(Math.round(bytes+'e+'+precision) + 'e-'+precision); // Round to "precision" decimals if needed.
        }
        return $translate.instant('mm.core.humanreadablesize', {size: Number(bytes), unit: units[keys[posttxt]]});
    };

    /**
     * Function to clean HTML tags.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#cleanTags
     * @param  {String}  text         The text to be cleaned.
     * @param  {Boolean} [singleLine] True if new lines should be removed (all the text in a single line).
     * @return {String}               Text cleaned.
     */
    self.cleanTags = function(text, singleLine) {
        // First, we use a regexpr.
        text = text.replace(/(<([^>]+)>)/ig,"");
        // Then, we rely on the browser. We need to wrap the text to be sure is HTML.
        text = angular.element('<p>').html(text).text(); // Get directive's content.
        // Recover or remove new lines.
        text = self.replaceNewLines(text, singleLine ? ' ' : '<br />');
        return text;
    };

    /**
     * Replace all the new lines on a certain text.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#replaceNewLines
     * @param  {String}  text     The text to be treated.
     * @param  {Boolean} newValue Text to place on each new line.
     * @return {String}           Treated text.
     */
    self.replaceNewLines = function(text, newValue) {
        return text.replace(/(?:\r\n|\r|\n)/g, newValue);
    };

    /**
     * Formats a text, treating multilang tags and cleaning HTML if needed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#formatText
     * @param  {String} text             Text to format.
     * @param  {Boolean} clean           True if HTML tags should be removed, false otherwise.
     * @param  {Boolean} [singleLine]    True if new lines should be removed. Only valid if clean is true.
     * @param  {Number}  [shortenLength] Number of characters to shorten the text.
     * @return {Promise}                 Promise resolved with the formatted text.
     */
    self.formatText = function(text, clean, singleLine, shortenLength) {
        return self.treatMultilangTags(text).then(function(formatted) {
            if (clean) {
                formatted = self.cleanTags(formatted, singleLine);
            }
            if (shortenLength && parseInt(shortenLength) > 0) {
                formatted = self.shortenText(formatted, parseInt(shortenLength));
            }
            return formatted;
        });
    };

    /**
     * Shortens a text to length and adds an ellipsis.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#shortenText
     * @param  {String} text The text to be shortened.
     * @param  {Number} length The desired length.
     * @return {String} Shortened text.
     */
    self.shortenText = function(text, length) {
        if (text.length > length) {
            text = text.substr(0, length);

            // Now, truncate at the last word boundary (if exists).
            var lastWordPos = text.lastIndexOf(' ');
            if (lastWordPos > 0) {
                text = text.substr(0, lastWordPos);
            }
            text += '&hellip;';
        }
        return text;
    };

    /**
     * Treat the multilang tags from a HTML code, leaving only the current language.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#treatMultilangTags
     * @param {String} text   The text to be formatted.
     * @param {String} siteId ID of the site to use. If not set, use current site.
     * @return {Promise}      Promise resolved with the formatted text.
     */
    self.treatMultilangTags = function(text) {
        if (!text) {
            return $q.when('');
        }

        return $mmLang.getCurrentLanguage().then(function(language) {
            // Match the current language
            var currentLangRe = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g'),
                anyLangRE = /<(?:lang|span)[^>]+lang="[a-zA-Z0-9_-]+"[^>]*>(.*?)<\/(?:lang|span)>/g;

            if (!text.match(currentLangRe)) {
                // Current lang not found. Try to find the first language.
                var matches = text.match(anyLangRE);
                if (matches && matches[0]) {
                    language = matches[0].match(/lang="([a-zA-Z0-9_-]+)"/)[1];
                    currentLangRe = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g');
                } else {
                    // No multi-lang tag found, stop.
                    return text;
                }
            }
            // Extract contents of current language.
            text = text.replace(currentLangRe, '$1');
            // Delete the rest of languages
            text = text.replace(anyLangRE, '');
            return text;
        });
    };

    /**
     * Escape an HTML text. This implementation is based on PHP's htmlspecialchars.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#escapeHTML
     * @param  {String} text Text to escape.
     * @return {String}      Escaped text.
     */
    self.escapeHTML = function(text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        } else if (typeof text != 'string') {
            return '' + text;
        }

        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    };

    /**
     * Add or remove 'www' from a URL. The url needs to have http or https protocol.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#addOrRemoveWWW
     * @param {String} url URL to modify.
     * @return             Modified URL.
     */
    self.addOrRemoveWWW = function(url) {
        if (typeof url == 'string') {
            if (url.match(/http(s)?:\/\/www\./)) {
                // Already has www. Remove it.
                url = url.replace('www.', '');
            } else {
                url = url.replace('https://', 'https://www.');
                url = url.replace('http://', 'http://www.');
            }
        }
        return url;
    };

    /**
     * Remove protocol and www from a URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#removeProtocolAndWWW
     * @param  {String} url URL to treat.
     * @return {String}     Treated URL.
     */
    self.removeProtocolAndWWW = function(url) {
        // Remove protocol.
        url = url.replace(/.*?:\/\//g, '');
        // Remove www.
        url = url.replace(/^www./, '');
        return url;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreVersionApplied', 'version_applied')

/**
 * Factory to handle app updates. This factory shouldn't be used outside of core.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmUpdateManager
 * @description
 * This service handles processes that need to be run when updating the app, like migrate MM1 sites to MM2.
 */
.factory('$mmUpdateManager', ["$log", "$q", "$mmConfig", "$mmSitesManager", "$mmFS", "$cordovaLocalNotification", "$mmLocalNotifications", "$mmApp", "$mmEvents", "mmCoreSitesStore", "mmCoreVersionApplied", "mmCoreEventSiteAdded", "mmCoreEventSiteUpdated", "mmCoreEventSiteDeleted", "$injector", "$mmFilepool", "mmCoreCourseModulesStore", "mmFilepoolLinksStore", "mmFilepoolPackagesStore", "mmCoreConfigConstants", function($log, $q, $mmConfig, $mmSitesManager, $mmFS, $cordovaLocalNotification, $mmLocalNotifications,
            $mmApp, $mmEvents, mmCoreSitesStore, mmCoreVersionApplied, mmCoreEventSiteAdded, mmCoreEventSiteUpdated,
            mmCoreEventSiteDeleted, $injector, $mmFilepool, mmCoreCourseModulesStore, mmFilepoolLinksStore,
            mmFilepoolPackagesStore, mmCoreConfigConstants) {

    $log = $log.getInstance('$mmUpdateManager');

    var self = {},
        sitesFilePath = 'migration/sites.json';

    /**
     * Check if the app has been updated and performs the needed processes.
     * This function shouldn't be used outside of core.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUpdateManager#check
     * @return {Promise} Promise resolved when the update process finishes.
     */
    self.check = function() {
        var promises = [],
            versionCode = mmCoreConfigConstants.versioncode;

        return $mmConfig.get(mmCoreVersionApplied, 0).then(function(versionApplied) {

            if (versionCode >= 391 && versionApplied < 391) {
                // Migrating from MM1 to MM2.
                promises.push(migrateMM1Sites());
                // Ignore errors in clearAppFolder. We don't want to clear the folder
                // everytime the app is opened if something goes wrong.
                promises.push(clearAppFolder().catch(function() {}));
            }

            if (versionCode >= 2003 && versionApplied < 2003) {
                promises.push(cancelAndroidNotifications());
            }

            if (versionCode >= 2003) {
                setStoreSitesInFile();
            }

            if (versionCode >= 2007 && versionApplied < 2007) {
                promises.push(migrateModulesStatus());
            }

            return $q.all(promises).then(function() {
                return $mmConfig.set(mmCoreVersionApplied, versionCode);
            }).catch(function() {
                $log.error('Error applying update from ' + versionApplied + ' to ' + versionCode);
            });
        });
    };

    /**
     * Clear the app folder.
     *
     * @return {Promise} Promise resolved when the folder is cleared.
     */
    function clearAppFolder() {
        if ($mmFS.isAvailable()) {
            return $mmFS.getDirectoryContents('').then(function(entries) {
                var promises = [];
                angular.forEach(entries, function(entry) {
                    // In Android, don't delete 'cache' and 'files' folders, created by the OS.
                    var canDeleteAndroid = ionic.Platform.isAndroid() && entry.name !== 'cache' && entry.name !== 'files';
                    var canDeleteIOS = ionic.Platform.isIOS() && entry.name !== 'NoCloud';
                    if (canDeleteIOS || canDeleteAndroid) {
                        promises.push($mmFS.removeDir(entry.name));
                    }
                });
                return $q.all(promises);
            });
        } else {
            return $q.when();
        }
    }

    /**
     * Migrate MoodleMobile 1 sites to MoodleMobile 2.
     *
     * @return {Promise} Promise resolved when the sites are migrated.
     */
    function migrateMM1Sites() {
        var sites = localStorage.getItem('sites'),
            promises = [];

        if (sites) {
            sites = sites.split(',');

            angular.forEach(sites, function(siteid) {
                if (!siteid) {
                    return;
                }

                $log.debug('Migrating site from MoodleMobile 1: ' + siteid);
                var site = localStorage.getItem('sites-'+siteid),
                    infos;

                if (site) {
                    try {
                        site = JSON.parse(site);
                    } catch(ex) {
                        // Invalid site. Shouldn't happen.
                        $log.warn('Site ' + siteid + ' data is invalid. Ignoring.');
                        return;
                    }

                    // In MM1 site info is mixed with site basic data (id, token, siteurl).
                    infos = angular.copy(site);
                    delete infos.id;
                    delete infos.token;
                    promises.push($mmSitesManager.addSite(site.id, site.siteurl, site.token, infos));
                } else {
                    $log.warn('Site ' + siteid + ' not found in local storage. Ignoring.');
                }
            });
        }

        return $q.all(promises).then(function() {
            if (sites) {
                localStorage.clear();
            }
        });
    }

    /**
     * Cancel all Android notifications. MM 2.0 was released with a bug in notifications ID (Android). These IDs were stored in
     * SharedPreferences, cancel them all will clear the stored values. @see MOBILE-1148.
     *
     * @return {Promise} Promise resolved when the notifications are cancelled.
     */
    function cancelAndroidNotifications() {
        if ($mmLocalNotifications.isAvailable() && ionic.Platform.isAndroid()) {
            return $cordovaLocalNotification.cancelAll().catch(function() {
                $log.error('Error cancelling Android notifications.');
            });
        }
        return $q.when();
    }

    /**
     * Sets the events to store the sites in a file.
     */
    function setStoreSitesInFile() {
        $mmEvents.on(mmCoreEventSiteAdded, storeSitesInFile);
        $mmEvents.on(mmCoreEventSiteUpdated, storeSitesInFile);
        $mmEvents.on(mmCoreEventSiteDeleted, storeSitesInFile);
        storeSitesInFile();
    }

    /**
     * Get sites stored in a file. It'll be used to migrate to Crosswalk if users skipped SQLite migration version.
     *
     * @return {Promise} Promise resolved with sites are retrieved. Resolve param is the sites list.
     */
    function getSitesStoredInFile() {
        if ($mmFS.isAvailable()) {
            return $mmFS.readFile(sitesFilePath).then(function(sites) {
                try {
                    sites = JSON.parse(sites);
                } catch (ex) {
                    sites = [];
                }
                return sites;
            }).catch(function() {
                // Error reading, probably file doesn't exist. Return empty list.
                return [];
            });
        } else {
            return $q.when([]);
        }
    }

    /**
     * Store sites in a file. It'll be used to migrate to Crosswalk if users skipped SQLite migration version.
     *
     * @return {Promise} Promise resolved when file is written.
     */
    function storeSitesInFile() {
        if ($mmFS.isAvailable()) {
            return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
                angular.forEach(sites, function(site) {
                    site.token = 'private'; // Remove the token, we don't want it written in a file.
                });
                return $mmFS.writeFile(sitesFilePath, JSON.stringify(sites));
            });
        } else {
            return $q.when();
        }
    }

    /**
     * Delete file with sites stored.
     *
     * @return {Promise} Promise resolved when file is deleted.
     */
    function deleteSitesFile() {
        if ($mmFS.isAvailable()) {
            return $mmFS.removeFile(sitesFilePath);
        } else {
            return $q.when();
        }
    }

    /**
     * Migrate mmCoreCourseModulesStore to mmFilepoolPackagesStore.
     *
     * @return {Promise} Promise resolved when the migration is finished.
     */
    function migrateModulesStatus() {
        var components = [];
        components.push($injector.get('mmaModBookComponent'));
        components.push($injector.get('mmaModImscpComponent'));
        components.push($injector.get('mmaModPageComponent'));
        components.push($injector.get('mmaModResourceComponent'));

        return $mmSitesManager.getSitesIds().then(function(sites) {
            var promises = [];
            angular.forEach(sites, function(siteId) {
                promises.push(migrateSiteModulesStatus(siteId, components));
            });
            return $q.all(promises);
        });
    }

    /**
     * Migrates the modules status from a certain site.
     *
     * @param {String} siteId       Site ID.
     * @param {String[]} components Components to check.
     * @return {Promise}            Promise resolved when the site migration is finished.
     */
    function migrateSiteModulesStatus(siteId, components) {
        $log.debug('Migrate site modules status from site ' + siteId);

        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            return db.getAll(mmCoreCourseModulesStore).then(function(entries) {
                var promises = [];

                angular.forEach(entries, function(entry) {
                    if (!parseInt(entry.id)) {
                        return; // The id is not a number, ignore it.
                    }

                    promises.push(determineComponent(db, entry.id, components).then(function(component) {
                        if (component) {
                            // Add a new entry in filepool store.
                            // We don't use $mmFilepool#storePackageStatus because we want to keep previousStatus.
                            entry.component = component;
                            entry.componentId = entry.id;
                            entry.id = $mmFilepool.getPackageId(component, entry.id);
                            promises.push(db.insert(mmFilepoolPackagesStore, entry));
                        }
                    }));
                });

                return $q.all(promises).then(function() {
                    // Success creating all the new entries. Let's remove the old ones.
                    return db.removeAll(mmCoreCourseModulesStore).catch(function() {
                        // Ignore errors.
                    });
                });
            });
        });
    }

    /**
     * Determines the component of a module status entry.
     *
     * @param  {Object} db           Site database.
     * @param  {Number} componentId  Component ID.
     * @param  {String[]} components List of components to check.
     * @return {Promise}             Promise resolved with the component or undefined if no component found.
     */
    function determineComponent(db, componentId, components) {
        var promises = [],
            component;

        angular.forEach(components, function(c) {
            if (c) {
                promises.push(db.query(mmFilepoolLinksStore, ['componentAndId', '=', [c, componentId]]).then(function(items) {
                    if (items.length) {
                        component = c;
                    }
                }).catch(function() {
                    // Never reject.
                }));
            }
        });

        return $q.all(promises).then(function() {
            return component;
        });
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Service to handle custom URLs schemes. Notifies all the observers when the app is invoked with a custom URL.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmURLDelegate
 */
.factory('$mmURLDelegate', ["$log", function($log) {

    $log = $log.getInstance('$mmURLDelegate');

    var observers = {},
        self = {};

    /**
     * Register an observer to be notified when the app is launched via custom URL scheme.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmURLDelegate#register
     * @param {String} name       Observer's name. Must be unique.
     * @param {Function} callback Function to call with the URLs received by the app. This function should check if the URL
     *                            is the one expected by the observer and return true if it is, return false otherwise.
     */
    self.register = function(name, callback) {
        $log.debug("Register observer '"+name+"' for custom URL.");
        observers[name] = callback;
    };

    /**
     * Notify all observers.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmURLDelegate#notify
     * @param {String} url URL to notify to the observers.
     */
    self.notify = function(url) {
        var treated = false; // Once an observer accepts a URL (return true) we stop notifying.
        angular.forEach(observers, function(callback, name) {
            if (!treated && typeof(callback) === 'function') {
                treated = callback(url);
            }
        });
    };

    return self;
}])

.run(["$mmURLDelegate", "$log", function($mmURLDelegate, $log) {
    window.handleOpenURL = function(url) {
        $log.debug('App launched by URL.');
        $mmURLDelegate.notify(url);
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Provider with some 'util' functionalities.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmUtil
 */
.provider('$mmUtil', ["mmCoreSecondsYear", "mmCoreSecondsDay", "mmCoreSecondsHour", "mmCoreSecondsMinute", function(mmCoreSecondsYear, mmCoreSecondsDay, mmCoreSecondsHour, mmCoreSecondsMinute) {

    var self = this, // Use 'self' to be coherent with the rest of services.
        provider = this; // To access provider methods from the service.

    /**
     * Serialize an object to be used in a request.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtilProvider#param
     * @param  {Object} obj Object to serialize.
     * @return {String}     Serialization of the object.
     */
    self.param = function(obj) {
        var query = '', name, value, fullSubName, subName, subValue, innerObj, i;

        for (name in obj) {
            value = obj[name];

            if (value instanceof Array) {
                for (i = 0; i < value.length; ++i) {
                    subValue = value[i];
                    fullSubName = name + '[' + i + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += self.param(innerObj) + '&';
                }
            }
            else if (value instanceof Object) {
                for (subName in value) {
                    subValue = value[subName];
                    fullSubName = name + '[' + subName + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += self.param(innerObj) + '&';
                }
            }
            else if (value !== undefined && value !== null) query += encodeURIComponent(name) + '=' + encodeURIComponent(value) + '&';
        }

        return query.length ? query.substr(0, query.length - 1) : query;
    };

    this.$get = ["$ionicLoading", "$ionicPopup", "$injector", "$translate", "$http", "$log", "$q", "$mmLang", "$mmFS", "$timeout", "$mmApp", "$mmText", "mmCoreWifiDownloadThreshold", "mmCoreDownloadThreshold", function($ionicLoading, $ionicPopup, $injector, $translate, $http, $log, $q, $mmLang, $mmFS, $timeout, $mmApp,
                $mmText, mmCoreWifiDownloadThreshold, mmCoreDownloadThreshold) {

        $log = $log.getInstance('$mmUtil');

        var self = {}; // Use 'self' to be coherent with the rest of services.

        /**
         * Formats a URL, trim, lowercase, etc...
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#formatURL
         * @param  {String} url The url to be formatted.
         * @return {String}     Fromatted url.
         */
        self.formatURL = function(url) {

            url = url.trim();

            // Check if the URL starts by http or https.
            if (! /^http(s)?\:\/\/.*/i.test(url)) {
                // Test first allways https.
                url = "https://" + url;
            }

            // http allways in lowercase.
            url = url.replace(/^http/i, 'http');
            url = url.replace(/^https/i, 'https');

            // Replace last slash.
            url = url.replace(/\/$/, "");

            return url;
        };

        /**
         * Resolves an object.
         *
         * @description
         * This is used to resolve what a callback should be when attached to a delegate.
         * For instance, if the object attached is a function, it is returned as is, but
         * we also support complex definition of objects. If we receive a string we will parse
         * it and to inject its service using $injector from Angular.
         *
         * Examples:
         * - (Function): returns the same function.
         * - (Object): returns the same object.
         * - '$mmSomething': Injects and returns $mmSomething.
         * - '$mmSomething.method': Injectes and returns a reference to the function 'method'.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#resolveObject
         * @param  {Mixed} object String, object or function.
         * @param  {Boolean} [instantiate=false] When true, if the object resolved is a function, instantiates it.
         * @return {Object} The reference to the object resolved.
         */
        self.resolveObject = function(object, instantiate) {
            var toInject,
                resolved;

            instantiate = angular.isUndefined(instantiate) ? false : instantiate;

            if (angular.isFunction(object) || angular.isObject(object)) {
                resolved = object;

            } else if (angular.isString(object)) {
                toInject = object.split('.');
                resolved = $injector.get(toInject[0]);

                if (toInject.length > 1) {
                    resolved = resolved[toInject[1]];
                }
            }

            if (angular.isFunction(resolved) && instantiate) {
                resolved = resolved();
            }

            if (typeof resolved === 'undefined') {
                throw new Error('Unexpected argument passed passed');
            }
            return resolved;
        };

        /**
         * Returns if a URL is downloadable: plugin file OR theme/image.php OR gravatar.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isDownloadableUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is downloadable.
         */
        self.isDownloadableUrl = function(url) {
            return self.isPluginFileUrl(url) || self.isThemeImageUrl(url) || self.isGravatarUrl(url);
        };

        /**
         * Returns if a URL is a gravatar URL.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isGravatarUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is a gravatar URL.
         */
        self.isGravatarUrl = function(url) {
            return url && url.indexOf('gravatar.com/avatar') !== -1;
        };

        /**
         * Returns if a URL is a pluginfile URL.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isPluginFileUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is a pluginfile URL.
         */
        self.isPluginFileUrl = function(url) {
            return url && url.indexOf('/pluginfile.php') !== -1;
        };

        /**
         * Returns if a URL is a theme image URL.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isThemeImageUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is a theme image URL.
         */
        self.isThemeImageUrl = function(url) {
            return url && url.indexOf('/theme/image.php') !== -1;
        };

        /**
         * Validates a URL for a specific pattern.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isValidURL
         * @param {String} url The url to test against the pattern
         * @return {Boolean}   TRUE if the url matches the expected pattern.
         *                     FALSE otherwise.
         */
        self.isValidURL = function(url) {
            return /^http(s)?\:\/\/([\da-zA-Z\.-]+)\.([\da-zA-Z\.]{2,6})([\/\w \.-]*)*\/?/i.test(url);
        };

        /**
         * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
         * For download remote files from Moodle we need to use the special /webservice/pluginfile passing
         * the ws token as a get parameter.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#fixPluginfileURL
         * @param {String} url   The url to be fixed.
         * @param {String} token Token to use.
         * @return {String}      Fixed URL.
         */
        self.fixPluginfileURL = function(url, token) {

            // This function is used in regexp callbacks, better not to risk!!
            if (!url) {
                return '';
            }

            // First check if we need to fix this url or is already fixed.
            if (url.indexOf('token=') != -1) {
                return url;
            }

            // Check if is a valid URL (contains the pluginfile endpoint).
            if (url.indexOf('pluginfile') == -1) {
                return url;
            }

            if (!token) {
                return '';
            }

            // In which way the server is serving the files? Are we using slash parameters?
            if (url.indexOf('?file=') != -1 || url.indexOf('?forcedownload=') != -1 || url.indexOf('?rev=') != -1) {
                url += '&';
            } else {
                url += '?';
            }
            url += 'token=' + token;

            // Some webservices returns directly the correct download url, others not.
            if (url.indexOf('/webservice/pluginfile') == -1) {
                url = url.replace('/pluginfile', '/webservice/pluginfile');
            }
            return url;
        };

        /**
         * Open a file using platform specific method.
         *
         * node-webkit: Using the default application configured.
         * Android: Using the WebIntent plugin.
         * iOs: Using the window.open method.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#openFile
         * @param  {String} path The local path of the file to be open.
         * @return {Void}
         */
        self.openFile = function(path) {
            var deferred = $q.defer();

            if (false) {
                // TODO Restore node-webkit support.

                // Link is the file path in the file system.
                // We use the node-webkit shell for open the file (pdf, doc) using the default application configured in the os.
                // var gui = require('nw.gui');
                // gui.Shell.openItem(path);
                deferred.resolve();

            } else if (window.plugins) {
                var extension = $mmFS.getFileExtension(path),
                    mimetype = $mmFS.getMimeType(extension);

                if (ionic.Platform.isAndroid() && window.plugins.webintent) {
                    var iParams = {
                        action: "android.intent.action.VIEW",
                        url: path,
                        type: mimetype
                    };

                    window.plugins.webintent.startActivity(
                        iParams,
                        function() {
                            $log.debug('Intent launched');
                            deferred.resolve();
                        },
                        function() {
                            $log.debug('Intent launching failed.');
                            $log.debug('action: ' + iParams.action);
                            $log.debug('url: ' + iParams.url);
                            $log.debug('type: ' + iParams.type);

                            if (!extension || extension.indexOf('/') > -1 || extension.indexOf('\\') > -1) {
                                // Extension not found.
                                $mmLang.translateAndRejectDeferred(deferred, 'mm.core.erroropenfilenoextension');
                            } else {
                                $mmLang.translateAndRejectDeferred(deferred, 'mm.core.erroropenfilenoapp');
                            }
                        }
                    );

                } else if (ionic.Platform.isIOS() && typeof handleDocumentWithURL == 'function') {

                    $mmFS.getBasePath().then(function(fsRoot) {
                        // Encode/decode the specific file path, note that a path may contain directories
                        // with white spaces, special characters...
                        if (path.indexOf(fsRoot > -1)) {
                            path = path.replace(fsRoot, "");
                            path = encodeURIComponent(decodeURIComponent(path));
                            path = fsRoot + path;
                        }

                        handleDocumentWithURL(
                            function() {
                                $log.debug('File opened with handleDocumentWithURL' + path);
                                deferred.resolve();
                            },
                            function(error) {
                                $log.debug('Error opening with handleDocumentWithURL' + path);
                                if(error == 53) {
                                    $log.error('No app that handles this file type.');
                                }
                                self.openInBrowser(path);
                                deferred.resolve();
                            },
                            path
                        );
                    }, deferred.reject);
                } else {
                    // Last try, launch the file with the browser.
                    self.openInBrowser(path);
                    deferred.resolve();
                }
            } else {
                // Changing _blank for _system may work in cordova 2.4 and onwards.
                $log.debug('Opening external file using window.open()');
                window.open(path, '_blank');
                deferred.resolve();
            }

            return deferred.promise;
        };

        /**
         * Open a URL using a browser.
         *
         * Do not use for files, refer to {@link $mmUtil#openFile}.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#openInBrowser
         * @param  {String} url The URL to open.
         * @return {Void}
         */
        self.openInBrowser = function(url) {
            window.open(url, '_system');
        };

        /**
         * Open a URL using InAppBrowser.
         *
         * Do not use for files, refer to {@link $mmUtil#openFile}.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#openInApp
         * @param  {String} url The URL to open.
         * @return {Void}
         */
        self.openInApp = function(url) {
            window.open(url, '_blank');
        };

        /**
         * Displays a loading modal window.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showModalLoading
         * @param {String}  text           The text of the modal window.
         * @param {Boolean} needsTranslate True if the 'text' is a $translate key, false otherwise.
         * @return {Object}                Object with a 'dismiss' function to close the modal.
         * @description
         * Usage:
         *     var modal = $mmUtil.showModalLoading(myText);
         *     ...
         *     modal.dismiss();
         */
        self.showModalLoading = function(text, needsTranslate) {
            var modalClosed = false,
                modalShown = false;

            if (!text) {
                text = 'mm.core.loading';
                needsTranslate = true;
            }

            function showModal(text) {
                if (!modalClosed) {
                    $ionicLoading.show({
                        template:   '<ion-spinner></ion-spinner>' +
                                    '<p>'+text+'</p>'
                    });
                    modalShown = true;
                }
            }

            if (needsTranslate) {
                $translate(text).then(showModal);
            } else {
                showModal(text);
            }

            return {
                dismiss: function() {
                    modalClosed = true;
                    if (modalShown) {
                        $ionicLoading.hide();
                    }
                }
            };
        };

        /**
         * Show a modal with an error message.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showErrorModal
         * @param {String} errorMessage    Message to show.
         * @param {Boolean} needsTranslate True if the errorMessage is a $translate key, false otherwise.
         * @param {Number} [autocloseTime] Number of milliseconds to wait to close the modal.
         *                                 If not defined, modal won't be automatically closed.
         */
        self.showErrorModal = function(errorMessage, needsTranslate, autocloseTime) {
            var errorKey = 'mm.core.error',
                langKeys = [errorKey];

            if (needsTranslate) {
                langKeys.push(errorMessage);
            }

            $translate(langKeys).then(function(translations) {
                var popup = $ionicPopup.alert({
                    title: translations[errorKey],
                    template: needsTranslate ? translations[errorMessage] : errorMessage
                });

                if (typeof autocloseTime != 'undefined' && !isNaN(parseInt(autocloseTime))) {
                    $timeout(function() {
                        popup.close();
                    }, parseInt(autocloseTime));
                } else {
                    delete popup;
                }
            });
        };

        /**
         * Show a modal with an error message.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showModal
         * @param {String} title        Language key.
         * @param {String} message      Language key.
         */
        self.showModal = function(title, message) {
            var promises = [
                $translate(title),
                $translate(message),
            ];

            $q.all(promises).then(function(translations) {
                $ionicPopup.alert({
                    title: translations[0],
                    template: translations[1]
                });
            });
        };

        /**
         * Show a confirm modal.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showConfirm
         * @param  {Mixed} template Template to show in the modal body. Can be a string or a promise.
         * @return {Promise}        Promise resolved if the user confirms and rejected if he cancels.
         */
        self.showConfirm = function(template, title) {
            return $ionicPopup.confirm({template: template, title: title}).then(function(confirmed) {
                if (!confirmed) {
                    return $q.reject();
                }
            });
        };

        /**
         * Show a prompt modal to input some data.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showPrompt
         * @param  {String} body             Modal body.
         * @param  {String} title            Modal title.
         * @param  {String} inputPlaceholder Placeholder of the input box. By default, "Password".
         * @param  {String} [inputType]      Type of the input box. By default, password.
         * @return {Promise}                 Promise resolved with the input data if the user clicks OK, rejected if cancels.
         */
        self.showPrompt = function(body, title, inputPlaceholder, inputType) {
            inputType = inputType || 'password';

            var options = {
                template: body,
                title: title,
                inputPlaceholder: inputPlaceholder,
                inputType: inputType
            };
            return $ionicPopup.prompt(options).then(function(data) {
                if (typeof data == 'undefined') {
                    return $q.reject();
                }
                return data;
            });
        };

        /**
         * Reads and parses a JSON file.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#readJSONFile
         * @param  {String} path Path to the file.
         * @return {Promise}     Promise to be resolved when the file is parsed.
         */
        self.readJSONFile = function(path) {
            return $http.get(path).then(function(response) {
                return response.data;
            });
        };

        /**
         * Get country name based on country code.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#getCountryName
         * @param {String} code Country code (AF, ES, US, ...).
         * @return {String}     Country name. If the country is not found, return the country code.
         */
        self.getCountryName = function(code) {
            var countryKey = 'mm.core.country-' + code,
                countryName = $translate.instant(countryKey);

            return countryName !== countryKey ? countryName : code;
        };

        /**
         * Returns the URL to the documentation of the app, based on Moodle version and current language.
         *
         * @param {String} [release] Moodle release.
         * @param {String} [page]    Docs page to go to.
         * @return {Promise}         Promise resolved with the Moodle docs URL.
         */
        self.getDocsUrl = function(release, page) {
            page = page || 'Mobile_app';

            var docsurl = 'https://docs.moodle.org/en/' + page;

            if (typeof release != 'undefined') {
                var version = release.substr(0, 3).replace(".", "");
                // Check is a valid number.
                if (parseInt(version) >= 24) {
                    // Append release number.
                    docsurl = docsurl.replace('https://docs.moodle.org/', 'https://docs.moodle.org/' + version + '/');
                }
            }

            docsurl = 'https://sites.google.com/a/miraclefish.com/birkbeck/';

            return $mmLang.getCurrentLanguage().then(function(lang) {
                return docsurl.replace('/en/', '/' + lang + '/');
            }, function() {
                return docsurl;
            });
        };

        /**
         * Return the current timestamp (UNIX format, seconds).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#timestamp
         * @return {Number} The current timestamp in seconds.
         */
        self.timestamp = function() {
            return Math.round(new Date().getTime() / 1000);
        };

        /**
         * Return true if the param is false (bool), 0 (number) or "0" (string).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isFalseOrZero
         * @param {Mixed} value Value to check.
         * @return {Number}     True if value is false, 0 or "0".
         */
        self.isFalseOrZero = function(value) {
            return typeof value != 'undefined' && (value === false || parseInt(value) === 0);
        };

        /**
         * Return true if the param is true (bool), 1 (number) or "1" (string).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isTrueOrOne
         * @param {Mixed} value Value to check.
         * @return {Number}     True if value is true, 1 or "1".
         */
        self.isTrueOrOne = function(value) {
            return typeof value != 'undefined' && (value === true || parseInt(value) === 1);
        };

        /**
         * Returns hours, minutes and seconds in a human readable format
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#formatTime
         * @param  {Integer} seconds A number of seconds
         * @return {String}         Human readable seconds formatted
         */
        self.formatTime = function(seconds) {
            var langKeys = ['mm.core.day', 'mm.core.days', 'mm.core.hour', 'mm.core.hours', 'mm.core.min', 'mm.core.mins',
                            'mm.core.sec', 'mm.core.secs', 'mm.core.year', 'mm.core.years', 'mm.core.now'];

            return $translate(langKeys).then(function(translations) {

                totalSecs = Math.abs(seconds);

                var years     = Math.floor(totalSecs / mmCoreSecondsYear);
                var remainder = totalSecs - (years * mmCoreSecondsYear);
                var days      = Math.floor(remainder / mmCoreSecondsDay);
                remainder = totalSecs - (days * mmCoreSecondsDay);
                var hours     = Math.floor(remainder / mmCoreSecondsHour);
                remainder = remainder - (hours * mmCoreSecondsHour);
                var mins      = Math.floor(remainder / mmCoreSecondsMinute);
                var secs      = remainder - (mins * mmCoreSecondsMinute);

                var ss = (secs == 1)  ? translations['mm.core.sec']  : translations['mm.core.secs'];
                var sm = (mins == 1)  ? translations['mm.core.min']  : translations['mm.core.mins'];
                var sh = (hours == 1) ? translations['mm.core.hour'] : translations['mm.core.hours'];
                var sd = (days == 1)  ? translations['mm.core.day']  : translations['mm.core.days'];
                var sy = (years == 1) ? translations['mm.core.year'] : translations['mm.core.years'];

                var oyears = '',
                    odays = '',
                    ohours = '',
                    omins = '',
                    osecs = '';

                if (years) {
                    oyears  = years + ' ' + sy;
                }
                if (days) {
                    odays  = days + ' ' + sd;
                }
                if (hours) {
                    ohours = hours + ' ' + sh;
                }
                if (mins) {
                    omins  = mins + ' ' + sm;
                }
                if (secs) {
                    osecs  = secs + ' ' + ss;
                }

                if (years) {
                    return oyears + ' ' + odays;
                }
                if (days) {
                    return odays + ' ' + ohours;
                }
                if (hours) {
                    return ohours + ' ' + omins;
                }
                if (mins) {
                    return omins + ' ' + osecs;
                }
                if (secs) {
                    return osecs;
                }
                return translations['mm.core.now'];
            });
        };

        /**
         * Empties an array without losing its reference.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#emptyArray
         * @param  {Array} array Array to empty.
         */
        self.emptyArray = function(array) {
            array.length = 0; // Empty array without losing its reference.
        };

        /**
         * Similar to $q.all, but if a promise fails this function's promise won't be rejected until ALL promises have finished.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#allPromises
         * @param  {Promise[]} promises Promises.
         * @return {Promise}            Promise resolved if all promises are resolved and rejected if at least 1 promise fails.
         */
        self.allPromises = function(promises) {
            if (!promises || !promises.length) {
                return $q.when();
            }

            var count = 0,
                failed = false,
                deferred = $q.defer();

            angular.forEach(promises, function(promise) {
                promise.catch(function() {
                    failed = true;
                }).finally(function() {
                    count++;

                    if (count === promises.length) {
                        // All promises have finished, reject/resolve.
                        if (failed) {
                            deferred.reject();
                        } else {
                            deferred.resolve();
                        }
                    }
                });
            });

            return deferred.promise;
        };

        /**
         * Compare two objects. This function won't compare functions and proto properties, it's a basic compare.
         * Also, this will only check if itemA's properties are in itemB with same value. This function will still
         * return true if itemB has more properties than itemA.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#basicLeftCompare
         * @param {Mixed}  itemA         First object.
         * @param {Mixed}  itemB         Second object.
         * @param {Number} [maxLevels=0] Number of levels to reach if 2 objects are compared.
         * @param {Number} [level=0]     Current deep level (when comparing objects).
         * @return {Boolean}             True if equal, false otherwise.
         */
        self.basicLeftCompare = function(itemA, itemB, maxLevels, level) {
            level = level || 0;
            maxLevels = maxLevels || 0;

            if (angular.isFunction(itemA) || angular.isFunction(itemB)) {
                return true; // Don't compare functions.
            } else if (angular.isObject(itemA) && angular.isObject(itemB)) {
                if (level >= maxLevels) {
                    return true; // Max deep reached.
                }

                var equal = true;
                angular.forEach(itemA, function(value, name) {
                    if (!self.basicLeftCompare(value, itemB[name], maxLevels, level + 1)) {
                        equal = false;
                    }
                });
                return equal;
            } else {
                // We'll treat "2" and 2 as the same value.
                var floatA = parseFloat(itemA),
                    floatB = parseFloat(itemB);

                if (!isNaN(floatA) && !isNaN(floatB)) {
                    return floatA == floatB;
                }
                return itemA === itemB;
            }
        };

        /**
         * If the download size is higher than a certain threshold shows a confirm dialog.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#confirmDownloadSize
         * @param {Number} size                 Size to download (in bytes).
         * @param {String} [message]            Code of the message to show. Default: 'mm.course.confirmdownload'.
         * @param {String} [unknownsizemessage] Code of the message to show if size is unknown.
         *                                      Default: 'mm.course.confirmdownloadunknownsize'.
         * @param {Number} [wifiThreshold]      Threshold to show confirm in WiFi connection. Default: mmCoreWifiDownloadThreshold.
         * @param {Number} [limitedThreshold]   Threshold to show confirm in limited connection. Default: mmCoreDownloadThreshold.
         * @return {Promise}                   Promise resolved when the user confirms or if no confirm needed.
         */
        self.confirmDownloadSize = function(size, message, unknownsizemessage, wifiThreshold, limitedThreshold) {
            wifiThreshold = typeof wifiThreshold == 'undefined' ? mmCoreWifiDownloadThreshold : wifiThreshold;
            limitedThreshold = typeof limitedThreshold == 'undefined' ? mmCoreDownloadThreshold : limitedThreshold;
            message = message || 'mm.course.confirmdownload';
            unknownsizemessage = unknownsizemessage || 'mm.course.confirmdownloadunknownsize';

            if (size <= 0) {
                // Seems size was unable to be calculated. Show a warning.
                return self.showConfirm($translate(unknownsizemessage));
            }
            else if (size >= wifiThreshold || ($mmApp.isNetworkAccessLimited() && size >= limitedThreshold)) {
                var readableSize = $mmText.bytesToSize(size, 2);
                return self.showConfirm($translate(message, {size: readableSize}));
            }
            return $q.when();
        };

        /**
         * Formats a size to be used as width/height of an element.
         * If the size is already valid (like '500px' or '50%') it won't be modified.
         * Returned size will have a format like '500px'.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#formatPixelsSize
         * @param  {Mixed} size Size to format.
         * @return {String}     Formatted size. If size is not valid, returns an empty string.
         */
        self.formatPixelsSize = function(size) {
            if (typeof size == 'string' && (size.indexOf('px') > -1 || size.indexOf('%') > -1)) {
                // It seems to be a valid size.
                return size;
            }

            size = parseInt(size, 10);
            if (!isNaN(size)) {
                return size + 'px';
            }
            return '';
        };

        /**
         * Serialize an object to be used in a request.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#param
         * @param  {Object} obj Object to serialize.
         * @return {String}     Serialization of the object.
         */
        self.param = function(obj) {
            return provider.param(obj);
        };

        /**
         * Rounds a number to use a certain amout of decimals or less.
         * Difference between this function and float's toFixed:
         * 7.toFixed(2) -> 7.00
         * roundToDecimals(7, 2) -> 7
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#roundToDecimals
         * @param  {Float}  number       Float to round.
         * @param  {Number} [decimals=2] Number of decimals. By default, 2.
         * @return {Float}               Rounded number.
         */
        self.roundToDecimals = function(number, decimals) {
            if (typeof decimals == 'undefined') {
                decimals = 2;
            }

            var multiplier = Math.pow(10, decimals);
            return Math.round(parseFloat(number) * multiplier) / multiplier;
        };

        /**
         * Extracts the parameters from a URL and stores them in an object.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#extractUrlParams
         * @param  {String} url URL to treat.
         * @return {Object}     Object with the params.
         */
        self.extractUrlParams = function(url) {
            var regex = /[?&]+([^=&]+)=?([^&]*)?/gi,
                params = {};
            url.replace(regex, function(match, key, value) {
                params[key] = value !== undefined ? value : '';
            });
            return params;
        };

        return self;
    }];
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Web service module.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmWS
 */
.factory('$mmWS', ["$http", "$q", "$log", "$mmLang", "$cordovaFileTransfer", "$mmApp", "$mmFS", "$mmText", "mmCoreSessionExpired", "mmCoreUserDeleted", "$translate", "$window", "$mmUtil", function($http, $q, $log, $mmLang, $cordovaFileTransfer, $mmApp, $mmFS, $mmText, mmCoreSessionExpired,
            mmCoreUserDeleted, $translate, $window, $mmUtil) {

    $log = $log.getInstance('$mmWS');

    var self = {};

    /**
     * A wrapper function for a moodle WebService call.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#call
     * @param {string} method The WebService method to be called.
     * @param {Object} data Arguments to pass to the method.
     * @param {Object} preSets Extra settings and information.
     *                    - siteurl string The site URL.
     *                    - wstoken string The Webservice token.
     *                    - responseExpected boolean Defaults to true. Set to false when the expected response is null.
     *                    - typeExpected string Defaults to 'object'. Use it when you expect a type that's not an object|array.
     * @return {Promise} Promise resolved with the response data in success and rejected with the error message if it fails.
     */
    self.call = function(method, data, preSets) {

        var siteurl;

        data = convertValuesToString(data);

        if (typeof preSets == 'undefined' || preSets === null ||
                typeof preSets.wstoken == 'undefined' || typeof preSets.siteurl == 'undefined') {
            return $mmLang.translateAndReject('mm.core.unexpectederror');
        } else if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        }

        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }

        data.wsfunction = method;
        data.wstoken = preSets.wstoken;
        siteurl = preSets.siteurl + '/webservice/rest/server.php?moodlewsrestformat=json';

        var ajaxData = data;

        return $http.post(siteurl, ajaxData).then(function(data) {

            // Some moodle web services return null.
            // If the responseExpected value is set then so long as no data
            // is returned, we create a blank object.
            if ((!data || !data.data) && !preSets.responseExpected) {
                data = {};
            } else {
                data = data.data;
            }

            if (!data) {
                return $mmLang.translateAndReject('mm.core.serverconnection');
            } else if (typeof data != preSets.typeExpected) {
                $log.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
                return $mmLang.translateAndReject('mm.core.errorinvalidresponse');
            }

            if (typeof(data.exception) !== 'undefined') {
                if (data.errorcode == 'invalidtoken' ||
                        (data.errorcode == 'accessexception' && data.message.indexOf('Invalid token - token expired') > -1)) {
                    $log.error("Critical error: " + JSON.stringify(data));
                    return $q.reject(mmCoreSessionExpired);
                } else if (data.errorcode === 'userdeleted') {
                    return $q.reject(mmCoreUserDeleted);
                } else {
                    return $q.reject(data.message);
                }
            }

            if (typeof(data.debuginfo) != 'undefined') {
                return $q.reject('Error. ' + data.message);
            }

            $log.info('WS: Data received from WS ' + typeof(data));

            if (typeof(data) == 'object' && typeof(data.length) != 'undefined') {
                $log.info('WS: Data number of elements '+ data.length);
            }

            return data;

        }, function() {
            return $mmLang.translateAndReject('mm.core.serverconnection');
        });
    };

    /**
     * Converts an objects values to strings where appropriate.
     * Arrays (associative or otherwise) will be maintained.
     *
     * @param {Object} data The data that needs all the non-object values set to strings.
     * @return {Object} The cleaned object, with multilevel array and objects preserved.
     */
    function convertValuesToString(data) {
        var result = [];
        if (!angular.isArray(data) && angular.isObject(data)) {
            result = {};
        }
        for (var el in data) {
            if (angular.isObject(data[el])) {
                result[el] = convertValuesToString(data[el]);
            } else {
                result[el] = data[el] + '';
            }
        }
        return result;
    }

    /**
     * Downloads a file from Moodle using Cordova File API.
     * @todo Use Web Workers.
     *
     * @param {String}   url        Download url.
     * @param {String}   path       Local path to store the file.
     * @param {Boolean}  background True if this function should be executed in background using Web Workers.
     * @return {Promise}            The success returns the fileEntry, the reject will contain the error object.
     */
    self.downloadFile = function(url, path, background) {
        $log.debug('Downloading file ' + url);

        return $mmFS.getBasePathToDownload().then(function(basePath) {
            // Use a tmp path to download the file and then move it to final location. This is because if the download fails,
            // the local file is deleted.
            var tmpPath = basePath + path + '.tmp';
            return $cordovaFileTransfer.download(url, tmpPath, { encodeURI: false }, true).then(function() {
                return $mmFS.moveFile(path + '.tmp', path).then(function(movedEntry) {
                    $log.debug('Success downloading file ' + url + ' to ' + path);
                    return movedEntry;
                });
            }, function(err) {
                $log.error('Error downloading ' + url + ' to ' + path);
                $log.error(JSON.stringify(err));
                return $q.reject(err);
            });
        });
    };

    /*
     * Uploads a file using Cordova File API.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#uploadFile
     * @param {Object} uri File URI.
     * @param {Object} options File settings: fileKey, fileName and mimeType.
     * @param {Object} presets Contains siteurl and token.
     * @return {Promise}
     */
    self.uploadFile = function(uri, options, presets) {
        $log.debug('Trying to upload file: ' + uri);

        var ftOptions = {},
            deferred = $q.defer();

        ftOptions.fileKey = options.fileKey;
        ftOptions.fileName = options.fileName;
        ftOptions.httpMethod = 'POST';
        ftOptions.mimeType = options.mimeType;
        ftOptions.params = {
            token: presets.token
        };
        ftOptions.chunkedMode = false;
        ftOptions.headers = {
            Connection: "close"
        };

        $log.debug('Initializing upload');
        $cordovaFileTransfer.upload(presets.siteurl + '/webservice/upload.php', uri, ftOptions, true).then(function(success) {
            $log.debug('Successfully uploaded file');
            deferred.resolve(success);
        }, function(error) {
            $log.error('Error while uploading file: ' + error.exception);
            deferred.reject(error);
        }, function(progress) {
            deferred.notify(progress);
        });

        return deferred.promise;
    };

    /*
     * Perform a HEAD request to get the size of a remote file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#getRemoteFileSize
     * @param {Object} uri File URI.
     * @return {Promise}   Promise resolved with the size or -1 if failure.
     */
    self.getRemoteFileSize = function(url) {
        return $http.head(url).then(function(data) {
            var size = parseInt(data.headers('Content-Length'), 10);
            if (size) {
                return size;
            }
            return -1;
        }).catch(function() {
            return -1;
        });
    };

    /**
     * A wrapper function for a synchronous Moodle WebService call.
     * Warning: This function should only be used if synchronous is a must. It's recommended to use $mmWS#call.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#syncCall
     * @param {string} method The WebService method to be called.
     * @param {Object} data Arguments to pass to the method.
     * @param {Object} preSets Extra settings and information.
     *                    - siteurl string The site URL.
     *                    - wstoken string The Webservice token.
     *                    - responseExpected boolean Defaults to true. Set to false when the expected response is null.
     *                    - typeExpected string Defaults to 'object'. Use it when you expect a type that's not an object|array.
     * @return {Mixed} Request response. If the request fails, returns an object with 'error'=true and 'message' properties.
     */
    self.syncCall = function(method, data, preSets) {
        var siteurl,
            xhr,
            errorResponse = {
                error: true,
                message: ''
            };

        data = convertValuesToString(data);

        if (typeof preSets == 'undefined' || preSets === null ||
                typeof preSets.wstoken == 'undefined' || typeof preSets.siteurl == 'undefined') {
            errorResponse.message = $translate.instant('mm.core.unexpectederror');
            return errorResponse;
        } else if (!$mmApp.isOnline()) {
            errorResponse.message = $translate.instant('mm.core.networkerrormsg');
            return errorResponse;
        }

        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }

        data.wsfunction = method;
        data.wstoken = preSets.wstoken;
        siteurl = preSets.siteurl + '/webservice/rest/server.php?moodlewsrestformat=json';

        // Serialize data.
        data = $mmUtil.param(data);

        // Perform sync request using XMLHttpRequest.
        xhr = new $window.XMLHttpRequest();
        xhr.open('post', siteurl, false);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');

        xhr.send(data);

        // Get response.
        data = ('response' in xhr) ? xhr.response : xhr.responseText;

        // Check status.
        xhr.status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);
        if (xhr.status < 200 || xhr.status >= 300) {
            // Request failed.
            errorResponse.message = data;
            return errorResponse;
        }

        // Treat response.
        try {
            data = JSON.parse(data);
        } catch(ex) {}

        // Some moodle web services return null.
        // If the responseExpected value is set then so long as no data is returned, we create a blank object.
        if ((!data || !data.data) && !preSets.responseExpected) {
            data = {};
        }

        if (!data) {
            errorResponse.message = $translate.instant('mm.core.serverconnection');
        } else if (typeof data != preSets.typeExpected) {
            $log.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
            errorResponse.message = $translate.instant('mm.core.errorinvalidresponse');
        }

        if (typeof data.exception != 'undefined' || typeof data.debuginfo != 'undefined') {
            errorResponse.message = data.message;
        }

        if (errorResponse.message !== '') {
            return errorResponse;
        }

        $log.info('Synchronous: Data received from WS ' + typeof data);

        if (typeof(data) == 'object' && typeof(data.length) != 'undefined') {
            $log.info('Synchronous: Data number of elements '+ data.length);
        }

        return data;
    };

    return self;

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to turn a number in bytes to a human readable size (e.g. 5,25 MB).
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmBytesToSize
 */
.filter('mmBytesToSize', ["$mmText", function($mmText) {
    return function(text) {
        return $mmText.bytesToSize(text);
    };
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to search URLs that are not inside <a> tags and add the corresponding <a> tags.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmCreateLinks
 */
.filter('mmCreateLinks', function() {
    var replacePattern = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])(?![^<]*>|[^<>]*<\/)/gim;
    return function(text) {
        return text.replace(replacePattern, '<a href="$1">$1</a>');
    };

});
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to display a date using the day, or the time.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmDateDayOrTime
 * @description
 * This shows a short version of a date. Use this filter when you want
 * the user to visualise when the action was done relatively to today's date.
 *
 * For instance, if the action happened during this day it will display the time,
 * but when the action happened few days ago, it will display the day of the week.
 *
 * The older the date is, the more information about it will be displayed.
 *
 * This filter expects a timestamp NOT including milliseconds.
 */
.filter('mmDateDayOrTime', ["$translate", function($translate) {

    return function(timestamp) {
        return moment(timestamp * 1000).calendar(null, {
            sameDay: $translate.instant('mm.core.dftimedate'),
            lastDay: $translate.instant('mm.core.dflastweekdate'),
            lastWeek: $translate.instant('mm.core.dflastweekdate')
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to format a date.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmFormatDate
 * @description
 * This formats a timestamp into a date. Parameters:
 *
 * @param {Number} timestamp Timestamp to format (in seconds). If not defined, use current time.
 * @param {String} format    Format to use. It should be a string code to handle i18n (e.g. mm.core.dftimedate). If the code doesn't
 *                           have a prefix, 'mm.core' will be used by default. E.g. 'dftimedate' -> 'mm.core.dftimedate'.
 * @return {String}          Formatted date.
 */
.filter('mmFormatDate', ["$translate", function($translate) {

    return function(timestamp, format) {
        if (format.indexOf('.') == -1) {
            format = 'mm.core.' + format;
        }
        return moment(timestamp).format($translate.instant(format));
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to remove HTML tags.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmNoTags
 */
.filter('mmNoTags', function() {
    return function(text) {
        return String(text).replace(/(<([^>]+)>)/ig, '');
    }
});
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to turn a UNIX timestamp to "time ago".
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmTimeAgo
 */
.filter('mmTimeAgo', function() {

    return function(timestamp) {
        return moment(timestamp * 1000).fromNow(true);
    };

});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to format a timestamp to a locale string. Timestamp can be in seconds or milliseconds.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmToLocaleString
 */
.filter('mmToLocaleString', function() {
    return function(text) {
        var timestamp = parseInt(text);

        if (isNaN(timestamp) || timestamp < 0) {
            // Date not valid.
            return '';
        }
        if (timestamp < 100000000000) {
            // Timestamp is in seconds, convert it to milliseconds.
            timestamp = timestamp * 1000;
        }
        return new Date(timestamp).toLocaleString();
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to auto focus an element when a view is loaded.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmAutoFocus
 */
.directive('mmAutoFocus', ["$mmApp", function($mmApp) {
    return {
        restrict: 'A',
        link: function(scope, el) {
            // Wait for transition to finish before auto-focus.
            var unregister = scope.$watch(function() {
                return ionic.transition.isActive;
            }, function(isActive) {
                if (!isActive) {
                    el[0].focus();
                    unregister(); // Stop watching.
                    if (ionic.Platform.isAndroid()) {
                        // On some Android versions the keyboard doesn't open automatically.
                        $mmApp.openKeyboard();
                    }
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to open a link in external browser.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmBrowser
 */
.directive('mmBrowser', ["$mmUtil", "$mmContentLinksHelper", function($mmUtil, $mmContentLinksHelper) {

    return {
        restrict: 'A',
        priority: 100,
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                var href = element[0].getAttribute('href');
                if (href) {
                    event.preventDefault();
                    event.stopPropagation();

                    $mmContentLinksHelper.handleLink(href).then(function(treated) {
                        if (!treated) {
                           if (href.indexOf('cdvfile://') === 0 || href.indexOf('file://') === 0) {
                                // We have a local file.
                                $mmUtil.openFile(href).catch(function(error) {
                                    $mmUtil.showErrorModal(error);
                                });
                            } else {
                                // It's an external link, we will open with browser.
                                $mmUtil.openInBrowser(href);
                            }
                        }
                    });
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to handle activity completion. It can be adapted to handle course completion once it's implemented.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmCompletion
 * @description
 * This directive will show a checkbox to show completion status and to allow manually changing the completion if it's allowed.
 * Attributes:
 *
 * @param {Object} completion    Completion status of the activity. Required properties:
 *                                   - cmid: Module ID.
 *                                   - state: Current completion state: 0 incomplete, 1 complete, 2 complete pass, 3 complete fail.
 *                                   - tracking: 0 means none, 1 manual, 2 automatic.
 * @param {String} after-change  Name of a scope function to call when completion changes.
 * @param {String} module-name   Name of the module this completion refers to.
 */
.directive('mmCompletion', ["$mmSite", "$mmUtil", "$mmText", "$translate", "$q", function($mmSite, $mmUtil, $mmText, $translate, $q) {

    // Set image and description to show as completion icon.
    function showStatus(scope) {
        var langKey,
            moduleName = scope.moduleName || '';

        if (scope.completion.tracking === 1 && scope.completion.state === 0) {
            scope.completionImage = 'img/completion/completion-manual-n.svg';
            langKey = 'mm.core.completion-alt-manual-n';
        } else if(scope.completion.tracking === 1 && scope.completion.state === 1) {
            scope.completionImage = 'img/completion/completion-manual-y.svg';
            langKey = 'mm.core.completion-alt-manual-y';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 0) {
            scope.completionImage = 'img/completion/completion-auto-n.svg';
            langKey = 'mm.core.completion-alt-auto-n';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 1) {
            scope.completionImage = 'img/completion/completion-auto-y.svg';
            langKey = 'mm.core.completion-alt-auto-y';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 2) {
            scope.completionImage = 'img/completion/completion-auto-pass.svg';
            langKey = 'mm.core.completion-alt-auto-pass';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 3) {
            scope.completionImage = 'img/completion/completion-auto-fail.svg';
            langKey = 'mm.core.completion-alt-auto-fail';
        }

        if (moduleName) {
            $mmText.formatText(moduleName, true, true, 50).then(function(formatted) {
                $translate(langKey, {$a: formatted}).then(function(translated) {
                    scope.completionDescription = translated;
                });
            });
        }
    }

    return {
        restrict: 'E',
        priority: 100,
        scope: {
            completion: '=',
            afterChange: '=',
            moduleName: '=?'
        },
        templateUrl: 'core/templates/completion.html',
        link: function(scope, element, attrs) {
            if (scope.completion) {
                showStatus(scope);

                element.on('click', function(e) {
                    if (typeof scope.completion.cmid == 'undefined' || scope.completion.tracking !== 1) {
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();

                    var modal = $mmUtil.showModalLoading(),
                        params = {
                            cmid: scope.completion.cmid,
                            completed: scope.completion.state === 1 ? 0 : 1
                        };

                    $mmSite.write('core_completion_update_activity_completion_status_manually', params).then(function(response) {
                        if (!response.status) {
                            return $q.reject();
                        }

                        if (angular.isFunction(scope.afterChange)) {
                            scope.afterChange();
                        }
                    }).catch(function(error) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errorchangecompletion', true);
                        }
                    }).finally(function() {
                        modal.dismiss();
                    });
                });
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to handle external content.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmExternalContent
 * @description
 * Directive to handle external content.
 *
 * This directive should be used with any element that links to external content
 * which we want to have available when the app is offline. Typically images and links.
 *
 * It uses {@link $mmFilepool} in the background.
 *
 * Attributes accepted:
 *     - siteid: Reference to the site ID if different than the site the user is connected to.
 */
.directive('mmExternalContent', ["$log", "$mmFilepool", "$mmSite", "$mmSitesManager", "$mmUtil", function($log, $mmFilepool, $mmSite, $mmSitesManager, $mmUtil) {
    $log = $log.getInstance('mmExternalContent');

    function handleExternalContent(siteId, dom, targetAttr, url, component, componentId) {

        if (!url || !$mmUtil.isDownloadableUrl(url)) {
            $log.debug('Ignoring non-downloadable URL: ' + url);
            return;
        }

        // Get the webservice pluginfile URL, we ignore failures here.
        $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canDownloadFiles() && $mmUtil.isPluginFileUrl(url)) {
                dom.remove(); // Remove element since it'll be broken.
                return;
            }

            var fn;

            if (targetAttr === 'src') {
                fn = $mmFilepool.getSrcByUrl;
            } else {
                fn = $mmFilepool.getUrlByUrl;
            }

            fn(siteId, url, component, componentId).then(function(finalUrl) {
                $log.debug('Using URL ' + finalUrl + ' for ' + url);
                dom.setAttribute(targetAttr, finalUrl);
            });
        });
    }

    return {
        restrict: 'A',
        scope: {
            siteid: '='
        },
        link: function(scope, element, attrs) {
            var dom = element[0],
                component = attrs.component,
                componentId = attrs.componentId,
                targetAttr,
                observe = false,
                url;

            if (dom.tagName === 'A') {
                targetAttr = 'href';
                if (attrs.hasOwnProperty('ngHref')) {
                    observe = true;
                }

            } else if (dom.tagName === 'IMG') {
                targetAttr = 'src';
                if (attrs.hasOwnProperty('ngSrc')) {
                    observe = true;
                }

            } else {
                // Unsupported tag.
                $log.warn('Directive attached to non-supported tag: ' + dom.tagName);
                return;
            }

            if (observe) {
                attrs.$observe(targetAttr, function(url) {
                    if (!url) {
                        return;
                    }
                    handleExternalContent(scope.siteid || $mmSite.getId(), dom, targetAttr, url, component, componentId);
                });
            } else {
                handleExternalContent(scope.siteid || $mmSite.getId(), dom, targetAttr, attrs[targetAttr], component, componentId);
            }

        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to handle a file (my files, attachments, etc.). The file is not downloaded automatically.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmFile
 * @description
 * Directive to handle files (my files, attachments, etc.). Shows the file name, icon (depending on mimetype) and a button
 * to download/refresh it.
 *
 * Attributes:
 * @param {Object} file            Required. Object with the following attributes:
 *                                     'filename': Name of the file.
 *                                     'fileurl' or 'url': File URL.
 * @param {String} [component]     Component the file belongs to.
 * @param {Number} [componentId]   Component ID.
 * @param {Boolean} [timemodified] If set, the value will be used to check if the file is outdated.
 */
.directive('mmFile', ["$q", "$mmUtil", "$mmFilepool", "$mmSite", "$mmApp", "$mmEvents", "$mmFS", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", function($q, $mmUtil, $mmFilepool, $mmSite, $mmApp, $mmEvents, $mmFS, mmCoreDownloaded, mmCoreDownloading,
            mmCoreNotDownloaded, mmCoreOutdated) {

    /**
     * Convenience function to get the file state and set scope variables based on it.
     *
     * @param  {Object} scope          Directive's scope.
     * @param  {String} siteid         Site ID.
     * @param  {String} fileurl        File URL.
     * @param  {Number} [timemodified] File's timemodified.
     * @return {Void}
     */
    function getState(scope, siteid, fileurl, timemodified) {
        return $mmFilepool.getFileStateByUrl(siteid, fileurl, timemodified).then(function(state) {
            var canDownload = $mmSite.canDownloadFiles();
            scope.isDownloaded = state === mmCoreDownloaded || state === mmCoreOutdated;
            scope.isDownloading = canDownload && state === mmCoreDownloading;
            scope.showDownload = canDownload && (state === mmCoreNotDownloaded || state === mmCoreOutdated);
        });
    }

    /**
     * Convenience function to download a file.
     *
     * @param  {Object} scope          Directive's scope.
     * @param  {String} siteid         Site ID.
     * @param  {String} fileurl        File URL.
     * @param  {String} component      Component the file belongs to.
     * @param  {Number} componentid    Component ID.
     * @param  {Number} [timemodified] File's timemodified.
     * @return {Promise}               Promise resolved when file is downloaded.
     */
    function downloadFile(scope, siteid, fileurl, component, componentid, timemodified) {
        if (!$mmSite.canDownloadFiles()) {
            $mmUtil.showErrorModal('mm.core.cannotdownloadfiles', true);
            return $q.reject();
        }

        scope.isDownloading = true;
        return $mmFilepool.downloadUrl(siteid, fileurl, true, component, componentid, timemodified).then(function(localUrl) {
            getState(scope, siteid, fileurl, timemodified); // Update state.
            return localUrl;
        }, function() {
            return getState(scope, siteid, fileurl, timemodified).then(function() {
                if (scope.isDownloaded) {
                    return localUrl;
                } else {
                    return $q.reject();
                }
            });
        });
    }

    return {
        restrict: 'E',
        templateUrl: 'core/templates/file.html',
        scope: {
            file: '='
        },
        link: function(scope, element, attrs) {
            var fileurl = scope.file.fileurl || scope.file.url,
                filename = scope.file.filename,
                timemodified = attrs.timemodified || 0,
                siteid = $mmSite.getId(),
                component = attrs.component,
                componentid = attrs.componentId,
                observer;

            scope.filename = filename;
            scope.fileicon = $mmFS.getFileIcon(filename);
            getState(scope, siteid, fileurl, timemodified);

            $mmFilepool.getFileEventNameByUrl(siteid, fileurl).then(function(eventName) {
                observer = $mmEvents.on(eventName, function(data) {
                    getState(scope, siteid, fileurl, timemodified);
                    if (!data.success) {
                        $mmUtil.showErrorModal('mm.core.errordownloading', true);
                    }
                });
            });

            scope.download = function(e, openAfterDownload) {
                e.preventDefault();
                e.stopPropagation();

                if (scope.isDownloading) {
                    return;
                }

                if (!$mmApp.isOnline() && (!openAfterDownload || (openAfterDownload && !scope.isDownloaded))) {
                    $mmUtil.showErrorModal('mm.core.networkerrormsg', true);
                    return;
                }

                if (openAfterDownload) {
                    // File needs to be opened now. If file needs to be downloaded, skip the queue.
                    downloadFile(scope, siteid, fileurl, component, componentid, timemodified).then(function(localUrl) {
                        $mmUtil.openFile(localUrl).catch(function(error) {
                            $mmUtil.showErrorModal(error);
                        });
                    });
                } else {
                    // File doesn't need to be opened, add it to queue.
                    $mmFilepool.invalidateFileByUrl(siteid, fileurl).finally(function() {
                        scope.isDownloading = true;
                        $mmFilepool.addToQueueByUrl(siteid, fileurl, component, componentid, timemodified);
                    });
                }
            }

            scope.$on('$destroy', function() {
                if (observer && observer.off) {
                    observer.off();
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to format text rendered.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmFormatText
 * @description
 * Directive to format text rendered. Attributes it accepts:
 *     -siteid: Site ID to use.
 *     -component: The component for mmExternalContent
 *     -component-id: The component ID for mmExternalContent
 *     -after-render: Scope function to call once the content is renderered. Passes the current scope as argument.
 *     -clean: True if all HTML tags should be removed, false otherwise.
 *     -singleline: True if new lines should be removed (all the text in a single line). Only valid if clean is true.
 *     -shorten: To shorten the text. If a number is supplied, it will shorten the text to that number of characters.
 *               If a percentage is supplied the number of characters to short will be the percentage of element's width.
 *               E.g. 50% of an element with 1000px width = 500 characters.
 *               If the element has no width it'll use 100 characters. If the attribute is empty it'll use 30% width.
 *     -expand-on-click: Indicate if contents should be expanded on click (undo shorten). Only applied if "shorten" is set.
 *     -fullview-on-click: Indicate if should open a new state with the full contents on click. Only applied if "shorten" is set.
 *     -watch: True if the variable used inside the directive should be watched for changes. If the variable data is retrieved
 *             asynchronously, this value must be set to true, or the directive should be inside a ng-if, ng-repeat or similar.
 */
.directive('mmFormatText', ["$interpolate", "$mmText", "$compile", "$translate", "$state", function($interpolate, $mmText, $compile, $translate, $state) {

    var extractVariableRegex = new RegExp('{{([^|]+)(|.*)?}}', 'i'),
        tagsToIgnore = ['AUDIO', 'VIDEO', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'];

    /**
     * Returns the number of characters to shorten the text. If the text shouldn't be shortened, returns undefined.
     *
     * @param  {Object} element   Directive root DOM element.
     * @param  {String} [shorten] Shorten attribute. Can be undefined or a string: empty, number or a percentage.
     * @return {Number}           Number of characters to shorten the text to. Undefined if it shouldn't shorten.
     */
    function calculateShorten(element, shorten) {
        var multiplier;

        if (typeof shorten == 'string' && shorten.indexOf('%') > -1) {
            // It's a percentage. Extract the multiplier.
            multiplier = parseInt(shorten.replace(/%/g, '').trim()) / 100;
            if (isNaN(multiplier)) {
                multiplier = 0.3;
            }
        } else if (typeof shorten != 'undefined' && shorten === '') {
            // Not defined, use default value.
            multiplier = 0.3;
        } else {
            var number = parseInt(shorten);
            if (isNaN(number)) {
                return; // Return undefined so it's not shortened.
            } else {
                return number;
            }
        }

        var el = element[0],
            elWidth = el.offsetWidth || el.width || el.clientWidth;
        if (!elWidth) {
            // Cannot calculate element's width, use default value.
            return 100;
        } else {
            return Math.round(elWidth * multiplier);
        }
    }

    /**
     * Format contents and render.
     *
     * @param  {Object} scope   Directive scope.
     * @param  {Object} element Directive root DOM element.
     * @param  {Object} attrs   Directive attributes.
     * @param  {String} text    Directive contents.
     * @return {Void}
     */
    function formatAndRenderContents(scope, element, attrs, text) {

        if (typeof text == 'undefined') {
            element.removeClass('hide');
            return;
        }

        attrs.shorten = calculateShorten(element, attrs.shorten);

        // If expandOnClick or fullviewOnClick are set we won't shorten the text on formatContents, we'll do it later.
        var shorten = (attrs.expandOnClick || attrs.fullviewOnClick) ? 0 : attrs.shorten;

        text = $interpolate(text)(scope); // "Evaluate" scope variables.
        text = text.trim();

        formatContents(scope, element, attrs, text, shorten).then(function(fullText) {
            if (attrs.shorten && (attrs.expandOnClick || attrs.fullviewOnClick)) {
                var shortened = $mmText.shortenText($mmText.cleanTags(fullText, false), parseInt(attrs.shorten)),
                    expanded = false;

                if (shortened.trim() === '') {
                    // The content could have images or media that were removed with shortenText. Check if that's the case.
                    var hasContent = false,
                        meaningfulTags = ['img', 'video', 'audio'];

                    angular.forEach(meaningfulTags, function(tag) {
                        if (fullText.indexOf('<'+tag) > -1) {
                            hasContent = true;
                        }
                    });

                    if (hasContent) {
                        // The content has meaningful tags. Show a placeholder to expand the content.
                        shortened = $translate.instant(attrs.expandOnClick ? 'mm.core.clicktohideshow' : 'mm.core.clicktoseefull');
                    }
                }

                element.on('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    var target = e.target;
                    if (tagsToIgnore.indexOf(target.tagName) === -1 || (target.tagName === 'A' && !target.getAttribute('href'))) {
                        if (attrs.expandOnClick) {
                            // Expand/collapse.
                            expanded = !expanded;
                            element.html( expanded ? fullText : shortened);
                            if (expanded) {
                                $compile(element.contents())(scope);
                            }
                        } else {
                            // Open a new state with the interpolated contents.
                            $state.go('site.mm_textviewer', {
                                title: $translate.instant('mm.core.description'),
                                content: text
                            });
                        }
                    }
                });

                renderText(scope, element, shortened, attrs.afterRender);
            } else {
                renderText(scope, element, fullText, attrs.afterRender);
            }
        });
    }

    /**
     * Apply formatText and set sub-directives.
     *
     * @param  {Object} scope     Directive scope.
     * @param  {Object} element   Directive root DOM element.
     * @param  {Object} attrs     Directive attributes.
     * @param  {String} text      Directive contents.
     * @param  {Number} [shorten] Number of characters to shorten contents to. If not defined, don't shorten the text.
     * @return {Promise}          Promise resolved with the formatted text.
     */
    function formatContents(scope, element, attrs, text, shorten) {

        var siteId = scope.siteid,
            component = attrs.component,
            componentId = attrs.componentId;

        // Apply format text function.
        return $mmText.formatText(text, attrs.clean, attrs.singleline, shorten).then(function(formatted) {

            var el = element[0],
                elWidth = el.offsetWidth || el.width || el.clientWidth;

            function addMediaAdaptClass(el) {
                angular.element(el).addClass('mm-media-adapt-width');
            }

            // Convert the content into DOM.
            var dom = angular.element('<div>').html(formatted);

            // Walk through the content to find the links and add our directive to it.
            // Important: We need to look for links first because in 'img' we add new links without mm-browser.
            angular.forEach(dom.find('a'), function(anchor) {
                anchor.setAttribute('mm-external-content', '');
                anchor.setAttribute('mm-browser', '');
                if (component) {
                    anchor.setAttribute('component', component);
                    if (componentId) {
                        anchor.setAttribute('component-id', componentId);
                    }
                }
                if (siteId) {
                    anchor.setAttribute('siteid', siteId);
                }
            });

            // Walk through the content to find images, and add our directive.
            angular.forEach(dom.find('img'), function(img) {
                addMediaAdaptClass(img);
                img.setAttribute('mm-external-content', '');
                if (component) {
                    img.setAttribute('component', component);
                    if (componentId) {
                        img.setAttribute('component-id', componentId);
                    }
                }
                if (siteId) {
                    img.setAttribute('siteid', siteId);
                }
                // Check if image width has been adapted. If so, add an icon to view the image at full size.
                var imgWidth = img.offsetWidth || img.width || img.clientWidth;
                if (imgWidth > elWidth) {
                    // Wrap the image in a new div with position relative.
                    var div = angular.element('<div class="mm-adapted-img-container"></div>'),
                        jqImg = angular.element(img),
                        label = $mmText.escapeHTML($translate.instant('mm.core.openfullimage')),
                        imgSrc = $mmText.escapeHTML(img.getAttribute('src'));
                    img.style.float = ''; // Disable float since image will fill the whole width.
                    jqImg.wrap(div);
                    jqImg.after('<a href="#" class="mm-image-viewer-icon" mm-image-viewer img="' + imgSrc +
                                    '" aria-label="' + label + '"><i class="icon ion-ios-search-strong"></i></a>');
                }
            });

            angular.forEach(dom.find('audio'), addMediaAdaptClass);
            angular.forEach(dom.find('video'), addMediaAdaptClass);
            angular.forEach(dom.find('iframe'), addMediaAdaptClass);

            return dom.html();
        });
    }

    /**
     * Render some text on the directive's element, compile it and call afterRender.
     *
     * @param  {Object} scope         Directive scope.
     * @param  {Object} element       Directive root DOM element.
     * @param  {String} text          Directive contents.
     * @param  {String} [afterRender] Scope function to call once the content is renderered.
     * @return {Void}
     */
    function renderText(scope, element, text, afterRender) {
        element.html(text);
        element.removeClass('hide');
        $compile(element.contents())(scope);
        // Call the after render function.
        if (afterRender && scope[afterRender]) {
            scope[afterRender](scope);
        }
    }

    return {
        restrict: 'E',
        scope: true,
        link: function(scope, element, attrs) {
            element.addClass('hide'); // Hide contents until they're treated.
            var content = element.html(); // Get directive's content.

            if (attrs.watch) {
                // Watch the variable inside the directive.
                var matches = content.match(extractVariableRegex);
                if (matches && typeof matches[1] == 'string') {
                    var variable = matches[1].trim();
                    scope.$watch(variable, function() {
                        formatAndRenderContents(scope, element, attrs, content);
                    });
                }
            } else {
                formatAndRenderContents(scope, element, attrs, content);
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to display content in an iframe.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmIframe
 * @description
 * Accepts the following attributes:
 *
 * @param {String} src          The source of the iframe.
 * @param {Mixed} [width=100%]  Width of the iframe. If not defined, use 100%.
 * @param {Mixed} [height=100%] Height of the iframe. If not defined, use 100%.
 */
.directive('mmIframe', ["$mmUtil", function($mmUtil) {

    var errorShownTime = 0,
        tags = ['iframe', 'frame', 'object', 'embed'];

    /**
     * Intercept window.open in a frame and its subframes, shows an error modal instead.
     *
     * @param  {DOMElement} element Element to treat.
     * @return {Void}
     */
    function interceptPopups(element) {
        if (element) {
            // Redefine window.open in this element and sub frames, it might have been loaded already.
            redefineWindowOpen(element);

            element.on('load', function() {
                // Element loaded, redefine window.open again.
                redefineWindowOpen(element);
            });
        }
    }

    /**
     * Redefine the open method in the contentWindow of an element and the sub frames.
     *
     * @param  {DOMElement} element Element to treat.
     * @return {Void}
     */
    function redefineWindowOpen(element) {
        var el = element[0],
            contentWindow = element.contentWindow || el.contentWindow,
            contents = element.contents();

        if (!contentWindow && el && el.contentDocument) {
            // It's probably an <object>. Try to get the window.
            contentWindow = el.contentDocument.defaultView;
        }

        if (!contentWindow && el && el.getSVGDocument) {
            // It's probably an <embed>. Try to get the window.
            var svgDoc = el.getSVGDocument;
            if (svgDoc && svgDoc.defaultView) {
                contents = angular.element(svgdoc);
                contentWindow = svgdoc.defaultView;
            } else if (el.window) {
                contentWindow = el.window;
            } else if (el.getWindow) {
                contentWindow = el.getWindow();
            }
        }

        if (contentWindow) {
            // Intercept window.open.
            contentWindow.open = function () {
                // Prevent showing more than one consecutive error. This shouldn't happen often because it means that the
                // element is using more than one window.open, but it's better to handle it just in case.
                var currentTime = new Date().getTime();
                if (currentTime - errorShownTime > 500) {
                    errorShownTime = currentTime;
                    $mmUtil.showErrorModal('mm.core.erroropenpopup', true);
                }
                return {}; // Return empty "window" object.
            };
        }

        // Search sub frames.
        angular.forEach(tags, function(tag) {
            angular.forEach(contents.find(tag), function(subelement) {
                interceptPopups(angular.element(subelement));
            });
        });
    }

    return {
        restrict: 'E',
        template: '<div class="iframe-wrapper"><iframe class="mm-iframe" ng-style="{\'width\': width, \'height\': height}" ng-src="{{src}}"></iframe></div>',
        scope: {
            src: '='
        },
        link: function(scope, element, attrs) {
            scope.width = $mmUtil.formatPixelsSize(attrs.iframeWidth) || '100%';
            scope.height = $mmUtil.formatPixelsSize(attrs.iframeHeight) || '100%';

            var iframe = angular.element(element.find('iframe')[0]);
            interceptPopups(iframe);
            iframe.on('load', function() {
                angular.forEach(iframe.contents().find('a'), function(el) {
                    var href = el.getAttribute('href');
                    if (href && href.indexOf('http') === 0) { // Check that href is not null.
                        angular.element(el).on('click', function(e) {
                            $mmUtil.openInBrowser(href);
                            e.preventDefault();
                        });
                    }
                });
            });

        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to prevent input validation on input fields.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmNoInputValidation
 * @description
 * Sometimes we might want to disable automatic validation on some input fields (like URLs).
 * This directive allows us to do so.
 */
.directive('mmImageViewer', ["$ionicModal", function($ionicModal) {
    return {
        restrict: 'A',
        priority: 500,
        scope: true,
        link: function(scope, element, attrs) {
            if (attrs.img) {
                scope.img = attrs.img;

                scope.closeModal = function(){
                    scope.modal.hide();
                };

                element.on('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    if (!scope.modal) {
                        $ionicModal.fromTemplateUrl('core/templates/imageviewer.html', {
                            scope: scope,
                            animation: 'slide-in-up'
                        }).then(function(m) {
                            scope.modal = m;
                            scope.modal.show();
                        });
                    } else {
                        scope.modal.show();
                    }
                });

                scope.$on('$destroy', function() {
                    if (scope.modal) {
                        scope.modal.remove();
                    }
                });
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to show a loading spinner and message while data is being loaded.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmLoading
 * @description
 * Usage:
 * <mm-loading message="{{loadingMessage}}" hide-until="dataLoaded" loading-padding-top="paddingTop">
 *     <!-- CONTENT TO HIDE UNTIL LOADED -->
 * </mm-loading>
 * This directive will show a ion-spinner with a message and hide all the content until 'dataLoaded' variable is set to true.
 * If 'message' attribute is not set, default message "Loading" is shown.
 * 'message' attribute accepts hardcoded strings, variables, filters, etc. E.g. message="{{ 'mm.core.loading' | translate}}".
 *
 * @param {String} [message]           Message to show while loading. If not set, default "Loading" message is shown.
 * @param {String} hideUntil           Scope variable to determine when should the contents be shown. When the variable is set
 *                                     to true, the loading is hidden and the contents are shown.
 * @param {String} [loadingPaddingTop] Padding top to set to loading view. If not set, no padding top is set. This attribute is
 *                                     meant to be used with dynamic paddings (e.g. to move the loading spinner to the user
 *                                     scrollTop). Static padding-top should be set using CSS.
 */
.directive('mmLoading', ["$translate", function($translate) {

    return {
        restrict: 'E',
        templateUrl: 'core/templates/loading.html',
        transclude: true,
        scope: {
            hideUntil: '=?',
            message: '@?',
            loadingPaddingTop: '=?'
        },
        link: function(scope, element, attrs) {
            var el = element[0],
                loading = angular.element(el.querySelector('.mm-loading-container'));

            if (!attrs.message) {
                // Default loading message.
                $translate('mm.core.loading').then(function(loadingString) {
                    scope.message = loadingString;
                });
            }

            if (attrs.loadingPaddingTop) {
                scope.$watch('loadingPaddingTop', function(newValue) {
                    // parseInt of an invalid string is NaN, but parseInt('a') == NaN is FALSE and typeof NaN = 'number'.
                    // That's why we use num >= 0 or num < 0 to check if it's a valid number.
                    var num = parseInt(newValue);
                    if (num >= 0 || num < 0) {
                        loading.css('padding-top', newValue + 'px');
                    } else if(typeof newValue == 'string') {
                        // Maybe they set a value like '200px'.
                        loading.css('padding-top', newValue);
                    }
                });
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * This directive adds a "bar" with arrows to navigate forward/backward and a "info" icon to display more data.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmNavigationBar
 * @description
 * This directive will show two arrows at the left and right of the screen to navigate to previous/next item when clicked.
 * If no previous/next item is defined, that arrow won't be shown. It will also show a button to show more info.
 *
 * @param {Mixed}    [previous] Previous item. If not defined, the previous arrow won't be shown.
 * @param {Mixed}    [next]     Next item. If not defined, the next arrow won't be shown.
 * @param {Function} [action]   Function to call when an arrow is clicked. Will receive as a param the item to load.
 * @param {String}   [info]     Info to show when clicking the info button. If not defined, the info button won't be shown.
 * @param {String}   [title]    Title to show when seeing the info (new state).
 */
.directive('mmNavigationBar', ["$state", "$translate", function($state, $translate) {
    return {
        restrict: 'E',
        scope: {
            previous: '=?',
            next: '=?',
            action: '=?',
            info: '=?'
        },
        templateUrl: 'core/templates/navigationbar.html',
        link: function(scope, element, attrs) {
            scope.title = attrs.title || $translate.instant('mm.core.info');
            scope.showInfo = function() {
                $state.go('site.mm_textviewer', {
                    title: scope.title,
                    content: scope.info
                });
            };
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to prevent input validation on input fields.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmNoInputValidation
 * @description
 * Sometimes we might want to disable automatic validation on some input fields (like URLs).
 * This directive allows us to do so.
 */
.directive('mmNoInputValidation', function() {
    return {
        restrict: 'A',
        priority: 500,
        compile: function(el, attrs) {
            attrs.$set('type',
                null,                //to delete type from attributes object
                false                //to preserve type attribute in DOM
            );
        }
    }
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreSplitViewLoad', 'mmSplitView:load')

/**
 * Directive to create a split view layout. This directive should be used along with mm-split-view-link.
 *
 * IMPORTANT: Due to a limitation in Angular ui-router, the left pane state and the right pane state should NOT have
 * parameters with the same name but different value. It can cause unexpected behaviors.
 * Example: if the left pane loads a state with param 'courseid', then all the states that can be loaded in the right pane
 * should avoid having a parameter named 'courseid'. The right pane state can have a 'courseid' param only if it will always
 * have the same value than in left pane state.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmSplitView
 * @description
 * Usage:
 * <mm-split-view component="mmaCalendarEventsList">
 *     <!-- CONTENT TO SHOW ON THE LEFT PANEL (MENU) -->
 * </mm-split-view>
 *
 * To change the right pane contents (content pane), mmSplitViewLink directive is needed.
 * mmSplitView will automatically try to load a mmSplitViewLink when the view is loaded. This can be configured using
 * the attributes "load" and "loadWhen".
 *
 * If you don't have access to the directive's scope but you still want to configure when should the data be loaded and which
 * element should it load you can use the mmCoreSplitViewLoad event. When the directive receives this event it will try to
 * immediately load the link set (if no link is set it will load the first link found). Example:
 * $rootScope.$broadcast(mmCoreSplitViewLoad, {load: 2});
 *
 * IMPORTANT: Due to a limitation in Angular ui-router, the left pane state and the right pane state should NOT have
 * parameters with the same name but different value. It can cause unexpected behaviors.
 * Example: if the left pane loads a state with param 'courseid', then all the states that can be loaded in the right pane
 * should avoid having a parameter named 'courseid'. The right pane state can have a 'courseid' param only if it will always
 * have the same value than in left pane state.
 *
 * Accepts the following params:
 *
 * @param {String} [menuWidth] Width of the left menu. Can be specified in pixels ('200px') or in percentage ('30%').
 *
 * @param {String} [loadWhen]  Name of a scope variable. When that variable is set to true, a mm-split-view-link will be loaded in
 *                             in the contents pane. If not set, try to load it right at the start. See "load" param.
 *
 * @param {String} component   Component. In tablet, the new view will be named after the component.
 *
 * @param {Number} [load] Link to load. If not set then the first link will be loaded by default. If it's set then it will
 *                        try to load the nth link. E.g. load=2 will load the second link in the page.
 */
.directive('mmSplitView', ["$log", "$state", "$ionicPlatform", "$timeout", "$mmUtil", "$interpolate", "mmCoreSplitViewLoad", function($log, $state, $ionicPlatform, $timeout, $mmUtil, $interpolate, mmCoreSplitViewLoad) {

    $log = $log.getInstance('mmSplitView');

    /**
     * Trigger click on a DOM element.
     *
     * @param  {Object} link DOM element to trigger click.
     * @return {Boolean}     True if success, false otherwise.
     */
    function triggerClick(link) {
        if (link && link.length && link.triggerHandler) {
            link.triggerHandler('click');
            return true;
        }
        return false;
    }

    // Directive controller.
    function controller() {
        var self = this,
            element,
            menuState,
            linkToLoad,
            component;

        /**
         * Clears links marked as selected.
         */
        this.clearMarkedLinks = function() {
            angular.element(element.querySelectorAll('[mm-split-view-link]')).removeClass('mm-split-item-selected');
        };

        /**
         * Get component.
         *
         * @return {String} Component.
         */
        this.getComponent = function() {
            return component;
        };

        /**
         * Get split view menu's state name (left pane).
         *
         * @return {String} Menu state name.
         */
        this.getMenuState = function() {
            return menuState || $state.current.name;
        };

        /**
         * Load a mm-split-view-link.
         *
         * @param {Object} [scope]           Directive's scope.
         * @param {String|Number} [loadAttr] Number of link to load.
         * @param {Boolean} retrying         True if we're retrying because the function failed (link wasn't ready).
         */
        this.loadLink = function(scope, loadAttr, retrying) {
            if ($ionicPlatform.isTablet()) {
                if (!linkToLoad) {
                    // No link set. Let's determine if loadAttr is set and its real value.
                    if (typeof loadAttr != 'undefined') {
                        var position = parseInt(loadAttr);
                        if (!position) {
                            // Seems it's not a number. Try to interpolate it.
                            position = parseInt($interpolate(loadAttr)(scope), 10); // "Evaluate" scope variables.
                        }
                        if (position) {
                            var links = element.querySelectorAll('[mm-split-view-link]');
                            position = position > links.length ? 0 : position - 1;
                            linkToLoad = angular.element(links[position]);
                        } else {
                            // Load first link
                            linkToLoad = angular.element(element.querySelector('[mm-split-view-link]'));
                        }
                    } else {
                        // Load first link
                        linkToLoad = angular.element(element.querySelector('[mm-split-view-link]'));
                    }
                }

                if (!triggerClick(linkToLoad)) {
                    // Link not found. Let's retry once in the next digest.
                    if (!retrying) {
                        linkToLoad = undefined;
                        $timeout(function() {
                            self.loadLink(scope, loadAttr, true);
                        });
                    }
                }
            }
        };

        /**
         * Set component.
         *
         * @param {String} cmp Component.
         */
        this.setComponent = function(cmp) {
            component = cmp;
        };

        /**
         * Set directive's DOM element.
         *
         * @param {Object} el Directive's DOM element.
         */
        this.setElement = function(el) {
            element = el;
        };

        /**
         * Set mm-split-view-link to load. Used to re-load last state if needed.
         *
         * @param {Object} link Link to set (DOM element).
         */
        this.setLink = function(link) {
            linkToLoad = link;
        };

        /**
         * Set split view menu's state name (left pane).
         *
         * @param {String} state State name to set.
         */
        this.setMenuState = function(state) {
            menuState = state;
        };
    }

    return {
        restrict: 'E',
        templateUrl: 'core/templates/splitview.html',
        transclude: true,
        controller: controller,
        link: function(scope, element, attrs, controller) {
            var el = element[0],
                menu = angular.element(el.querySelector('.mm-split-pane-menu')),
                menuState = $state.$current.name,
                menuParams = $state.params,
                menuWidth = attrs.menuWidth,
                component = attrs.component || 'tablet';

            scope.component = component;

            controller.setComponent(component);
            controller.setElement(el);
            controller.setMenuState(menuState);

            if (menuWidth && $ionicPlatform.isTablet()) {
                menu.css('width', menuWidth);
                menu.css('-webkit-flex-basis', menuWidth);
                menu.css('-moz-flex-basis', menuWidth);
                menu.css('-ms-flex-basis', menuWidth);
                menu.css('flex-basis', menuWidth);
            }

            // We'll set all the listeners even if it's not a tablet, to support change between tablet-smartphone mode.

            if (attrs.loadWhen) {
                // Load link when variable is set to true.
                scope.$watch(attrs.loadWhen, function(newValue) {
                    if (newValue) {
                        controller.loadLink(scope, attrs.load);
                    }
                });
            } else {
                controller.loadLink(scope, attrs.load);
            }

            // Load last opened link when we re-enter the same state. We use $stateChangeSuccess instead of $ionicView.enter
            // because $ionicView.enter is not triggered when going to the same state.
            scope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
                // Compare that name and params are similar. We'll only compare 1st level of params, it's not a deep compare.
                if (toState.name === menuState && $mmUtil.basicLeftCompare(toParams, menuParams, 1)) {
                    controller.loadLink(); // No need to pass scope and load, link should be set.
                }
            });

            // Listen for event to load link.
            scope.$on(mmCoreSplitViewLoad, function(e, data) {
                if (data && data.load) {
                    controller.loadLink(scope, data.load);
                } else {
                    controller.loadLink(scope, attrs.load);
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to load a state in a split-view-content pane in tablet or in a new page in phone.
 * Requires being a child of mmSplitView.
 *
 * IMPORTANT: Due to a limitation in Angular ui-router, the left pane state and the right pane state should NOT have
 * parameters with the same name but different value. It can cause unexpected behaviors.
 * Example: if the left pane loads a state with param 'courseid', then all the states that can be loaded in the right pane
 * should avoid having a parameter named 'courseid'. The right pane state can have a 'courseid' param only if it will always
 * have the same value than in left pane state.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmSplitViewLink
 * @description
 * Usage:
 * <... mm-split-view-link="site.mm_user-profile({courseid: courseid, userid: participant.id})" >
 *
 * This directive accepts a sref string that indicates the state to go to and the params. Scope variable need to be
 * inside curly brackets: {{variable_name}}.
 * In tablet, the new state contents will be loaded in split-pane contents pane.
 * In phone, the new state contents will be loaded in a new page.
 */
.directive('mmSplitViewLink', ["$log", "$ionicPlatform", "$state", "$mmApp", function($log, $ionicPlatform, $state, $mmApp) {
    $log = $log.getInstance('mmSplitViewLink');

    var srefRegex = new RegExp(/([^\(]*)(\((.*)\))?$/);

    /**
     * Create a new state for tablet view (split-view). The state created will be exactly the same as the target state
     * (stateName), but changing the name and the view name.
     *
     * @param  {String} stateName       Name of the state to copy.
     * @param  {String} tabletStateName Name of the new state.
     * @param  {String} newViewName     Name of the new view.
     * @return {Boolean}                True if success, false otherwise.
     */
    function createTabletState(stateName, tabletStateName, newViewName) {
        var targetState = $state.get(stateName),
            newConfig,
            viewName;

        if (targetState) {
            newConfig = angular.copy(targetState);

            // Change first view name to 'tablet' so it's loaded in the split-view content pane.
            viewName = Object.keys(newConfig.views)[0];
            newConfig.views[newViewName] = newConfig.views[viewName];
            delete newConfig.views[viewName];
            delete newConfig['name'];

            $mmApp.createState(tabletStateName, newConfig);
            return true;
        } else {
            $log.error('State doesn\'t exist: '+stateName);
            return false;
        }
    }

    /**
     * Evaluate a string using scope.
     *
     * @param  {Object} scope Scope.
     * @param  {String} value String to eval.
     * @return {Mixed}        Evaluated value or undefined if not valid.
     */
    function scopeEval(scope, value) {
        if (typeof value == 'string') {
            try {
                return scope.$eval(value);
            } catch(ex) {
                $log.error('Error evaluating string: ' + param);
            }
        }
    }

    return {
        restrict: 'A',
        require: '^mmSplitView',
        link: function(scope, element, attrs, splitViewController) {
            var sref = attrs.mmSplitViewLink,
                menuState = splitViewController.getMenuState(),
                matches,
                stateName,
                stateParams,
                stateParamsString,
                tabletStateName;

            if (sref) {
                matches = sref.match(srefRegex);
                if (matches && matches.length) {
                    stateName = matches[1]; // E.g. site.mm_user-profile
                    tabletStateName = menuState + '.' + stateName.substr(stateName.lastIndexOf('.') + 1);

                    stateParamsString = matches[3]; // E.g. {courseid: courseid, userid: userid}
                    stateParams = scopeEval(scope, stateParamsString);

                    // Watch for changes on stateParams.
                    scope.$watch(stateParamsString, function(newVal) {
                        stateParams = newVal;
                    });

                    element.on('click', function(event) {
                        event.stopPropagation();
                        event.preventDefault();

                        if ($ionicPlatform.isTablet()) {
                            if (!$state.get(tabletStateName)) {
                                // State doesn't exists. Let's create it.
                                if (!createTabletState(stateName, tabletStateName, splitViewController.getComponent())) {
                                    return;
                                }
                            }
                            splitViewController.setLink(element); // Set last link loaded.
                            splitViewController.clearMarkedLinks();
                            element.addClass('mm-split-item-selected');
                            $state.go(tabletStateName, stateParams, {location:'replace'});
                        } else {
                            $state.go(stateName, stateParams);
                        }
                    });
                } else {
                    $log.error('Invalid sref.');
                }
            } else {
                $log.error('Invalid sref.');
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('mm_contentlinks', {
        url: '/mm_contentlinks',
        abstract: true,
        templateUrl: 'core/components/contentlinks/templates/base.html',
        cache: false,   // Disable caching to force controller reload.
    })

    .state('mm_contentlinks.choosesite', {
        url: '/choosesite',
        templateUrl: 'core/components/contentlinks/templates/choosesite.html',
        controller: 'mmContentLinksChooseSiteCtrl',
        params: {
            url: null
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course', ['mm.core.courses'])

.constant('mmCoreCoursePriority', 800)
.constant('mmCoreCourseAllSectionsId', -1)

.config(["$stateProvider", "$mmCoursesDelegateProvider", "mmCoreCoursePriority", function($stateProvider, $mmCoursesDelegateProvider, mmCoreCoursePriority) {

    $stateProvider

    .state('site.mm_course', {
        url: '/mm_course',
        params: {
            courseid: null,
            sid: null, // Section to load. Not naming it sectionid because it collides with 'mm_course-section' param in split-view.
            moduleid: null // Module to load.
        },
        views: {
            'site': {
                templateUrl: 'core/components/course/templates/sections.html',
                controller: 'mmCourseSectionsCtrl'
            }
        }
    })

    .state('site.mm_course-section', {
        url: '/mm_course-section',
        params: {
            sectionid: null,
            cid: null, // Not naming it courseid because it collides with 'site.mm_course' param in split-view.
            mid: null // Not naming it moduleid because it collides with 'site.mm_course' param in split-view.
        },
        views: {
            'site': {
                templateUrl: 'core/components/course/templates/section.html',
                controller: 'mmCourseSectionCtrl'
            }
        }
    })

    .state('site.mm_course-modcontent', {
        url: '/mm_course-modcontent',
        params: {
            module: null
        },
        views: {
            site: {
                templateUrl: 'core/components/course/templates/modcontent.html',
                controller: 'mmCourseModContentCtrl'
            }
        }
    });

    $mmCoursesDelegateProvider.registerNavHandler('mmCourse', '$mmCourseCoursesNavHandler', mmCoreCoursePriority);
}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmCourseDelegate", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmCourseDelegate) {
    $mmEvents.on(mmCoreEventLogin, $mmCourseDelegate.updateContentHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCourseDelegate.updateContentHandlers);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses', [])

.constant('mmCoursesSearchComponent', 'mmCoursesSearch')
.constant('mmCoursesSearchPerPage', 20) // Max of courses per page when searching courses.
.constant('mmCoursesEnrolInvalidKey', 'mmCoursesEnrolInvalidKey')
.constant('mmCoursesEventMyCoursesUpdated', 'my_courses_updated')
.constant('mmCoursesAccessMethods', {
     guest: 'guest',
     default: 'default'
})

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mm_courses', {
        url: '/mm_courses',
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/list.html',
                controller: 'mmCoursesListCtrl'
            }
        }
    })

    .state('site.mm_searchcourses', {
        url: '/mm_searchcourses',
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/search.html',
                controller: 'mmCoursesSearchCtrl'
            }
        }
    })

    .state('site.mm_viewresult', {
        url: '/mm_viewresult',
        params: {
            course: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/viewresult.html',
                controller: 'mmCoursesViewResultCtrl'
            }
        }
    });

}])

.config(["$mmContentLinksDelegateProvider", function($mmContentLinksDelegateProvider) {
    $mmContentLinksDelegateProvider.registerLinkHandler('mmCourses', '$mmCoursesHandlers.linksHandler');
}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmCoursesDelegate", "$mmCourses", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmCoursesDelegate, $mmCourses) {
    $mmEvents.on(mmCoreEventLogin, $mmCoursesDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCoursesDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventLogout, function() {
        $mmCoursesDelegate.clearCoursesHandlers();
        $mmCourses.clearCurrentCourses();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login', [])

.config(["$stateProvider", "$urlRouterProvider", "$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($stateProvider, $urlRouterProvider, $mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {

    $stateProvider

    .state('mm_login', {
        url: '/mm_login',
        abstract: true,
        templateUrl: 'core/components/login/templates/base.html',
        cache: false,   // Disable caching to force controller reload.
        onEnter: ["$ionicHistory", function($ionicHistory) {
            // Ensure that there is no history stack when getting here.
            $ionicHistory.clearHistory();
        }]
    })

    .state('mm_login.init', {
        url: '/init',
        templateUrl: 'core/components/login/templates/init.html',
        controller: 'mmLoginInitCtrl',
        cache: false // Disable caching to force controller reload.
    })

    .state('mm_login.sites', {
        url: '/sites',
        templateUrl: 'core/components/login/templates/sites.html',
        controller: 'mmLoginSitesCtrl',
        onEnter: ["$mmLoginHelper", "$mmSitesManager", function($mmLoginHelper, $mmSitesManager) {
            // Skip this page if there are no sites yet.
            $mmSitesManager.hasNoSites().then(function() {
                $mmLoginHelper.goToAddSite();
            });
        }]
    })

    .state('mm_login.site', {
        url: '/site',
        templateUrl: 'core/components/login/templates/site.html',
        controller: 'mmLoginSiteCtrl'
    })

    .state('mm_login.credentials', {
        url: '/cred',
        templateUrl: 'core/components/login/templates/credentials.html',
        controller: 'mmLoginCredentialsCtrl',
        params: {
            siteurl: ''
        },
        onEnter: ["$state", "$stateParams", function($state, $stateParams) {
            // Do not allow access to this page when the URL was not passed.
            if (!$stateParams.siteurl) {
              $state.go('mm_login.init');
            }
        }]
    })

    .state('mm_login.reconnect', {
        url: '/reconnect',
        templateUrl: 'core/components/login/templates/reconnect.html',
        controller: 'mmLoginReconnectCtrl',
        cache: false,
        params: {
            siteurl: '',
            username: '',
            infositeurl: ''
        }
    });

    // Default redirect to the login page.
    $urlRouterProvider.otherwise(function($injector) {
        var $state = $injector.get('$state');
        return $state.href('mm_login.init').replace('#', '');
    });

    // Restore the session.
    $mmInitDelegateProvider.registerProcess('mmLogin', '$mmSitesManager.restoreSession', mmInitDelegateMaxAddonPriority + 200);
}])

.run(["$log", "$state", "$mmUtil", "$translate", "$mmSitesManager", "$rootScope", "$mmSite", "$mmURLDelegate", "$ionicHistory", "$mmEvents", "$mmLoginHelper", "mmCoreEventSessionExpired", "$mmApp", function($log, $state, $mmUtil, $translate, $mmSitesManager, $rootScope, $mmSite, $mmURLDelegate, $ionicHistory,
                $mmEvents, $mmLoginHelper, mmCoreEventSessionExpired, $mmApp) {

    $log = $log.getInstance('mmLogin');

    // Listen for sessionExpired event to reconnect the user.
    $mmEvents.on(mmCoreEventSessionExpired, sessionExpired);

    // Register observer to check if the app was launched via URL scheme.
    $mmURLDelegate.register('mmLoginSSO', appLaunchedByURL);

    // Redirect depending on user session.
    $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {

        // Prevent state changes while the app is not ready.
        if (!$mmApp.isReady() && toState.name !== 'mm_login.init') {
            event.preventDefault();
            $state.transitionTo('mm_login.init');
            $log.warn('Forbidding state change to \'' + toState.name + '\'. App is not ready yet.');
            return;
        }

        if (toState.name.substr(0, 8) === 'redirect' || toState.name.substr(0, 15) === 'mm_contentlinks') {
            return;
        } else if ((toState.name.substr(0, 8) !== 'mm_login' || toState.name === 'mm_login.reconnect') && !$mmSite.isLoggedIn()) {
            // We are not logged in.
            event.preventDefault();
            $log.debug('Redirect to login page, request was: ' + toState.name);
            // Disable animation and back button for the next transition.
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.transitionTo('mm_login.init');
        } else if (toState.name.substr(0, 8) === 'mm_login' && toState.name !== 'mm_login.reconnect' && $mmSite.isLoggedIn()) {
            // We are logged in and requested the login page.
            event.preventDefault();
            $log.debug('Redirect to course page, request was: ' + toState.name);
            // Disable animation and back button for the next transition.
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.transitionTo('site.mm_courses');
        }

    });

    // Function to handle session expired events.
    function sessionExpired(siteid) {

        var siteurl = $mmSite.getURL();

        if (typeof(siteurl) !== 'undefined') {

            if (siteid && siteid !== $mmSite.getId()) {
                return; // Site that triggered the event is not current site.
            }

            // Check authentication method.
            $mmSitesManager.checkSite(siteurl).then(function(result) {

                if (result.warning) {
                    $mmUtil.showErrorModal(result.warning, true, 4000);
                }

                if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                    // SSO. User needs to authenticate in a browser.
                    $mmUtil.showConfirm($translate('mm.login.reconnectssodescription')).then(function() {
                        $mmLoginHelper.openBrowserForSSOLogin(result.siteurl);
                    });
                } else {
                    var info = $mmSite.getInfo();
                    if (typeof(info) !== 'undefined' && typeof(info.username) !== 'undefined') {
                        $ionicHistory.nextViewOptions({disableBack: true});
                        $state.go('mm_login.reconnect',
                                        {siteurl: result.siteurl, username: info.username, infositeurl: info.siteurl});
                    }
                }
            });
        }
    }

    // Function to handle URL received by Custom URL Scheme. If it's a SSO login, perform authentication.
    function appLaunchedByURL(url) {
        var ssoScheme = 'moodlemobile://token=';
        if (url.indexOf(ssoScheme) == -1) {
            return false;
        }

        // App opened using custom URL scheme. Probably an SSO authentication.
        $log.debug('App launched by URL');

        var modal = $mmUtil.showModalLoading('mm.login.authenticating', true);

        // Delete the sso scheme from the URL.
        url = url.replace(ssoScheme, '');
        // Decode from base64.
        try {
            url = atob(url);
        } catch(err) {
            // Error decoding the parameter.
            $log.error('Error decoding parameter received for login SSO');
            return false;
        }

        $mmLoginHelper.validateBrowserSSOLogin(url).then(function(sitedata) {

            $mmLoginHelper.handleSSOLoginAuthentication(sitedata.siteurl, sitedata.token).then(function() {
                $state.go('site.mm_courses');
            }, function(error) {
                $mmUtil.showErrorModal(error);
            }).finally(function() {
                modal.dismiss();
            });

        }, function(errorMessage) {
            modal.dismiss();
            if (typeof(errorMessage) === 'string' && errorMessage != '') {
                $mmUtil.showErrorModal(errorMessage);
            }
        });

        return true;
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings', [])

.constant('mmCoreSettingsDownloadSection', 'mmCoreSettingsDownloadSection')
.constant('mmCoreSettingsReportInBackground', 'mmCoreReportInBackground')
.constant('mmCoreSettingsSyncOnlyOnWifi', 'mmCoreSyncOnlyOnWifi')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mm_settings', {
        url: '/mm_settings',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/list.html'
            }
        }
    })

    .state('site.mm_settings-about', {
        url: '/mm_settings-about',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/about.html',
                controller: 'mmSettingsAboutCtrl'
            }
        }
    })

    .state('site.mm_settings-general', {
        url: '/mm_settings-general',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/general.html',
                controller: 'mmSettingsGeneralCtrl'
            }
        }
    })

    .state('site.mm_settings-spaceusage', {
        url: '/mm_settings-spaceusage',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/space-usage.html',
                controller: 'mmSettingsSpaceUsageCtrl'
            }
        }
    })

    .state('site.mm_settings-synchronization', {
        url: '/mm_settings-synchronization',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/synchronization.html',
                controller: 'mmSettingsSynchronizationCtrl'
            }
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.sidemenu', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site', {
        url: '/site',
        templateUrl: 'core/components/sidemenu/templates/menu.html',
        controller: 'mmSideMenuCtrl',
        abstract: true,
        cache: false,
        onEnter: ["$ionicHistory", "$state", "$mmSite", "$timeout", function($ionicHistory, $state, $mmSite, $timeout) {
            // Remove the login page from the history stack.
            $ionicHistory.clearHistory();

            // Go to login if user is not logged in.
            if (!$mmSite.isLoggedIn()) {
                $state.go('mm_login.init');
            }
        }]
    });

}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmSideMenuDelegate", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmSideMenuDelegate) {
    $mmEvents.on(mmCoreEventLogin, $mmSideMenuDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmSideMenuDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventLogout, $mmSideMenuDelegate.clearSiteHandlers);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.textviewer', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mm_textviewer', {
        url: '/mm_textviewer',
        params: {
            title: null,
            content: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/textviewer/templates/textviewer.html',
                controller: 'mmTextViewerIndexCtrl'
            }
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user', [])

.value('mmUserProfileState', 'site.mm_user-profile')

.config(["$stateProvider", "$mmContentLinksDelegateProvider", function($stateProvider, $mmContentLinksDelegateProvider) {

    $stateProvider

        .state('site.mm_user-profile', {
            url: '/mm_user-profile',
            views: {
                'site': {
                    controller: 'mmUserProfileCtrl',
                    templateUrl: 'core/components/user/templates/profile.html'
                }
            },
            params: {
                courseid: 0,
                userid: 0
            }
        });

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmUser', '$mmUserHandlers.linksHandler');

}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmUserDelegate", "$mmSite", "mmCoreEventUserDeleted", "$mmUser", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmUserDelegate, $mmSite, mmCoreEventUserDeleted, $mmUser) {
    $mmEvents.on(mmCoreEventLogin, $mmUserDelegate.updateProfileHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmUserDelegate.updateProfileHandlers);

    $mmEvents.on(mmCoreEventUserDeleted, function(data) {
        if (data.siteid && data.siteid === $mmSite.getId() && data.params) {
            // Search for userid in params.
            var params = data.params,
                userid = 0;
            if (params.userid) {
                userid = params.userid;
            } else if (params.userids) {
                userid = params.userids[0];
            } else if (params.field === 'id' && params.values && params.values.length) {
                userid = params.values[0];
            } else if (params.userlist && params.userlist.length) {
                userid = params.userlist[0].userid;
            }

            userid = parseInt(userid);
            if (userid > 0) {
                $mmUser.deleteStoredUser(userid);
            }
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks')

/**
 * Controller to choose an account to handle content links.
 *
 * @module mm.core.contentlinks
 * @ngdoc controller
 * @name mmContentLinksChooseSiteCtrl
 */
.controller('mmContentLinksChooseSiteCtrl', ["$scope", "$stateParams", "$mmSitesManager", "$mmUtil", "$ionicHistory", "$state", "$q", "$mmContentLinksDelegate", "$mmContentLinksHelper", function($scope, $stateParams, $mmSitesManager, $mmUtil, $ionicHistory, $state, $q,
            $mmContentLinksDelegate, $mmContentLinksHelper) {

    $scope.url = $stateParams.url || '';

    var action;

    function leaveView() {
        $mmSitesManager.logout().finally(function() {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.go('mm_login.sites');
        });
    }

    if (!$scope.url) {
        leaveView();
        return;
    }

    $mmContentLinksDelegate.getActionsFor($scope.url).then(function(actions) {
        action = $mmContentLinksHelper.getFirstValidAction(actions);
        if (!action) {
            return $q.reject();
        }

        $mmSitesManager.getSites(action.sites).then(function(sites) {
            $scope.sites = sites;
        });
    }).catch(function() {
        $mmUtil.showErrorModal('mm.contentlinks.errornosites', true);
        leaveView();
    });

    $scope.siteClicked = function(siteId) {
        action.action(siteId);
    };

    $scope.cancel = function() {
        leaveView();
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks')

/**
 * Service to handle links found in contents. Allows to capture links in content and redirect to certain parts
 * of the app instead of opening them in browser.
 *
 * @module mm.core.contentlinks
 * @ngdoc provider
 * @name $mmContentLinksDelegate
 */
.provider('$mmContentLinksDelegate', function() {
    var linkHandlers = {},
        self = {};

    /**
     * Register a link handler.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksDelegateProvider#registerLinkHandler
     * @param {String} name                    Handler's name.
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                         returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - getActions(siteIds, url, courseId) (Promise) Returns list of actions. Each action must have:
     *                                                           - message: Message related to the action to do. E.g. 'View'.
     *                                                           - icon: Icon related to the action to do.
     *                                                           - sites: Sites IDs that support the action. Subset of 'siteIds'.
     *                                                           - action(siteId): A function to be called when the link is clicked.
     * @param {Number} [priority]              Handler's priority.
     */
    self.registerLinkHandler = function(name, handler, priority) {
        if (typeof linkHandlers[name] !== 'undefined') {
            console.log("$mmContentLinksDelegateProvider: Addon '" + linkHandlers[name].name +
                        "' already registered as link handler");
            return false;
        }
        console.log("$mmContentLinksDelegateProvider: Registered handler '" + name + "' as link handler.");
        linkHandlers[name] = {
            name: name,
            handler: handler,
            instance: undefined,
            priority: typeof priority === 'undefined' ? 100 : priority
        };
        return true;
    };

    self.$get = ["$mmUtil", "$log", "$q", "$mmSitesManager", function($mmUtil, $log, $q, $mmSitesManager) {
        var self = {};

        $log = $log.getInstance('$mmContentLinksDelegate');

        /**
         * Get the list of possible actions to do for a URL.
         *
         * @module mm.core.contentlinks
         * @ngdoc method
         * @name $mmContentLinksDelegate#getLinkHandlersFor
         * @param {String} url        URL to handle.
         * @param {Number} [courseId] Course ID related to the URL. Optional but recommended since some handlers might require
         *                            to know the courseid if Moodle version is previous to 3.0.
         * @return {Promise}          Promise resolved with the actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActionsFor = function(url, courseId) {
            if (!url) {
                return $q.when([]);
            }

            // Get the list of sites the URL belongs to.
            return $mmSitesManager.getSiteIdsFromUrl(url, true).then(function(siteIds) {
                var linkActions = [],
                    promises = [];

                angular.forEach(linkHandlers, function(handler) {
                    if (typeof handler.instance === 'undefined') {
                        handler.instance = $mmUtil.resolveObject(handler.handler, true);
                    }

                    if (handler.instance) {
                        promises.push($q.when(handler.instance.getActions(siteIds, url, courseId)).then(function(actions) {
                            if (actions && actions.length) {
                                linkActions.push({
                                    priority: handler.priority,
                                    actions: actions
                                });
                            }
                        }));
                    }
                });

                return $mmUtil.allPromises(promises).catch(function() {}).then(function() {
                    // Sort link actions by priority.
                    return sortActionsByPriority(linkActions);
                });
            });
        };

        /**
         * Sort actions by priority. Each object in the actions param must have a priority and a list of actions.
         * The returned array only contains the actions ordered by priority.
         *
         * @param  {Object[]} actions Actions to sort.
         * @return {Object[]}         Sorted actions.
         */
        function sortActionsByPriority(actions) {
            var sorted = [];

            // Sort by priority.
            actions = actions.sort(function(a, b) {
                return a.priority > b.priority;
            });

            // Fill result array.
            actions.forEach(function(entry) {
                sorted = sorted.concat(entry.actions);
            });
            return sorted;
        }

        return self;
    }];

    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks')

/**
 * Service to provide some helper functionalities for the contentlinks component.
 *
 * @module mm.core.contentlinks
 * @ngdoc service
 * @name $mmContentLinksHelper
 */
.factory('$mmContentLinksHelper', ["$log", "$ionicHistory", "$state", "$mmSite", "$mmContentLinksDelegate", "$mmUtil", "$translate", "$mmCourseHelper", function($log, $ionicHistory, $state, $mmSite, $mmContentLinksDelegate, $mmUtil, $translate,
            $mmCourseHelper) {

    $log = $log.getInstance('$mmContentLinksHelper');

    var self = {};

    /**
     * Filter the list of supported sites based on a isEnabled function.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#filterSupportedSites
     * @param  {String[]} siteIds     Site IDs to filter.
     * @param  {Function} isEnabledFn Function to call for each site. Must return a promise resolved with true if enabled. It
     *                                receives a siteId param and all the params sent to this function after 'checkAll'.
     * @param  {Boolean} checkAll     True if it should check all the sites, false if it should check only 1 and treat them all
     *                                depending on this result.
     * @param  {Mixed}                All the params sent after checkAll will be passed to isEnabledFn.
     * @return {Promise}              Promise resolved with the list of supported sites.
     */
    self.filterSupportedSites = function(siteIds, isEnabledFn, checkAll) {
        var promises = [],
            supported = [],
            extraParams = Array.prototype.slice.call(arguments, 3); // Params received after 'checkAll'.

        angular.forEach(siteIds, function(siteId) {
            if (checkAll || !promises.length) {
                promises.push(isEnabledFn.apply(isEnabledFn, [siteId].concat(extraParams)).then(function(enabled) {
                    if (enabled) {
                        supported.push(siteId);
                    }
                }));
            }
        });

        return $mmUtil.allPromises(promises).catch(function() {}).then(function() {
            if (!checkAll) {
                if (supported.length) {
                    return siteIds; // Checking 1 was enough and it succeeded, all sites supported.
                } else {
                    return []; // Checking 1 was enough and it failed, no sites supported.
                }
            } else {
                return supported;
            }
        });
    };

    /**
     * Get the first valid action in a list of actions.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#getFirstValidAction
     * @param  {Object[]} actions List of actions.
     * @return {Object}           First valid action. Returns undefined if no valid action found.
     */
    self.getFirstValidAction = function(actions) {
        if (actions) {
            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];
                if (action && action.sites && action.sites.length && angular.isFunction(action.action)) {
                    return action;
                }
            }
        }
    };

    /**
     * Goes to a certain state in a certain site. If the site is current site it will perform a regular navigation,
     * otherwise it uses the 'redirect' state to change the site.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#goInSite
     * @param  {String} stateName   Name of the state to go.
     * @param  {Object} stateParams Params to send to the state.
     * @param  {String} [siteId]    Site ID. If not defined, current site.
     * @return {Promise}            Promise resolved when the state is changed.
     */
    self.goInSite = function(stateName, stateParams, siteId) {
        siteId = siteId || $mmSite.getId();
        if (siteId == $mmSite.getId()) {
            return $state.go(stateName, stateParams);
        } else {
            return $state.go('redirect', {
                siteid: siteId,
                state: stateName,
                params: stateParams
            });
        }
    };

    /**
     * Go to the view to choose a site.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#goToChooseSite
     * @param {String} url URL to treat.
     * @return {Promise}   Promise resolved when the state changes.
     */
    self.goToChooseSite = function(url) {
        $ionicHistory.nextViewOptions({
            disableBack: true
        });
        return $state.go('mm_contentlinks.choosesite', {url: url});
    };

    /**
     * Handle a link.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#handleLink
     * @param  {String} url URL to handle.
     * @return {Promise}    Promise resolved with a boolean: true if URL was treated, false otherwise.
     */
    self.handleLink = function(url) {
        // Check if the link should be treated by some component/addon.
        return $mmContentLinksDelegate.getActionsFor(url).then(function(actions) {
            var action = self.getFirstValidAction(actions);
            if (action) {
                if (action.sites.length == 1 && action.sites[0] == $mmSite.getId()) {
                    // Current site.
                    action.action(action.sites[0]);
                } else {
                    // Not current site or more than one site. Ask for confirmation.
                    $mmUtil.showConfirm($translate('mm.contentlinks.confirmurlothersite')).then(function() {
                        if (action.sites.length == 1) {
                            action.action(action.sites[0]);
                        } else {
                            self.goToChooseSite(url);
                        }
                    });
                }
                return true;
            }
        }).catch(function() {
            return false;
        });
    };

    /**
     * Treats a URL that belongs to a module's index page.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#treatModuleIndexUrl
     * @param {String[]} siteIds   Site IDs the URL belongs to.
     * @param {String} url         URL to treat.
     * @param {Function} isEnabled Function to check if the module is enabled. @see $mmContentLinksHelper#filterSupportedSites .
     * @param {Number} [courseId]  Course ID related to the URL.
     * @return {Promise}           Promise resolved with the list of actions.
     */
    self.treatModuleIndexUrl = function(siteIds, url, isEnabled, courseId) {
        var params = $mmUtil.extractUrlParams(url);
        if (typeof params.id != 'undefined') {
            // Pass false because all sites should have the same siteurl.
            return self.filterSupportedSites(siteIds, isEnabled, false, courseId).then(function(ids) {
                if (!ids.length) {
                    return [];
                } else {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: ids,
                        action: function(siteId) {
                            $mmCourseHelper.navigateToModule(parseInt(params.id, 10), siteId, courseId);
                        }
                    }];
                }
            });
        }
        return $q.when([]);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Controller to handle the courses list.
 *
 * @module mm.core.courses
 * @ngdoc controller
 * @name mmCoursesListCtrl
 */
.controller('mmCoursesListCtrl', ["$scope", "$mmCourses", "$mmCoursesDelegate", "$mmUtil", "$mmEvents", "$mmSite", "mmCoursesEventMyCoursesUpdated", function($scope, $mmCourses, $mmCoursesDelegate, $mmUtil, $mmEvents, $mmSite,
            mmCoursesEventMyCoursesUpdated) {

    $scope.searchEnabled = $mmCourses.isSearchCoursesAvailable();
    $scope.areNavHandlersLoadedFor = $mmCoursesDelegate.areNavHandlersLoadedFor;

    // Convenience function to fetch courses.
    function fetchCourses(refresh) {
        return $mmCourses.getUserCourses().then(function(courses) {
            $scope.courses = courses;
            angular.forEach(courses, function(course) {
                course._handlers = $mmCoursesDelegate.getNavHandlersFor(course.id, refresh);
            });
            $scope.filterText = ''; // Filter value MUST be set after courses are shown.
        }, function(error) {
            if (typeof error != 'undefined' && error !== '') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.courses.errorloadcourses', true);
            }
        });
    }
    fetchCourses().finally(function() {
        $scope.coursesLoaded = true;
    });

    $scope.refreshCourses = function() {
        $mmCourses.invalidateUserCourses().finally(function() {
            fetchCourses(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    $mmEvents.on(mmCoursesEventMyCoursesUpdated, function(siteid) {
        if (siteid == $mmSite.getId()) {
            fetchCourses();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Controller to handle search courses.
 *
 * @module mm.core.courses
 * @ngdoc controller
 * @name mmCoursesSearchCtrl
 */
.controller('mmCoursesSearchCtrl', ["$scope", "$mmCourses", "$q", "$mmUtil", function($scope, $mmCourses, $q, $mmUtil) {

    var page = 0,
    	currentSearch = '';

    $scope.searchText = '';

    // Convenience function to search courses.
    function searchCourses(refresh) {
        if (refresh) {
            page = 0;
        }

        return $mmCourses.search(currentSearch, page).then(function(response) {
            if (page === 0) {
                $scope.courses = response.courses;
            } else {
                $scope.courses = $scope.courses.concat(response.courses);
            }
            $scope.total = response.total;

            page++;
            $scope.canLoadMore = $scope.courses.length < $scope.total;

        }).catch(function(message) {
            $scope.canLoadMore = false;
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.searchcourses.errorsearching', true);
            }
            return $q.reject();
        });
    }

    $scope.search = function(text) {
        currentSearch = text;
        $scope.courses = undefined;

    	var modal = $mmUtil.showModalLoading('mm.core.searching', true);
    	searchCourses(true).finally(function() {
            modal.dismiss();
    	});
    };

    $scope.loadMoreResults = function() {
    	searchCourses();
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Controller to handle view a course that was searched.
 *
 * @module mm.core.courses
 * @ngdoc controller
 * @name mmCoursesViewResultCtrl
 */
.controller('mmCoursesViewResultCtrl', ["$scope", "$stateParams", "$mmCourses", "$mmCoursesDelegate", "$mmUtil", "$translate", "$q", "$ionicModal", "$mmEvents", "$mmSite", "mmCoursesSearchComponent", "mmCoursesEnrolInvalidKey", "mmCoursesEventMyCoursesUpdated", function($scope, $stateParams, $mmCourses, $mmCoursesDelegate, $mmUtil, $translate, $q,
            $ionicModal, $mmEvents, $mmSite, mmCoursesSearchComponent, mmCoursesEnrolInvalidKey, mmCoursesEventMyCoursesUpdated) {

    var course = $stateParams.course || {},
        selfEnrolWSAvailable = $mmCourses.isSelfEnrolmentEnabled(),
        guestWSAvailable = $mmCourses.isGuestWSAvailable(),
        isGuestEnabled = false,
        guestInstanceId,
        handlersShouldBeShown = true,
        enrollmentMethods;

    $scope.course = course;
    $scope.title = course.fullname;
    $scope.component = mmCoursesSearchComponent;
    $scope.selfEnrolInstances = [];
    $scope.enroldata = {
        password: ''
    };

    // Function to determine if handlers are being loaded.
    $scope.loadingHandlers = function() {
        return handlersShouldBeShown && !$mmCoursesDelegate.areNavHandlersLoadedFor(course.id);
    };

    // Convenience function to get course. We use this to determine if a user can see the course or not.
    function getCourse(refresh) {
        var promise;
        if (selfEnrolWSAvailable || guestWSAvailable) {
            // Get course enrolment methods.
            $scope.selfEnrolInstances = [];
            promise = $mmCourses.getCourseEnrolmentMethods(course.id).then(function(methods) {
                enrollmentMethods = methods;

                angular.forEach(enrollmentMethods, function(method) {
                    if (selfEnrolWSAvailable && method.type === 'self') {
                        $scope.selfEnrolInstances.push(method);
                    } else if (guestWSAvailable && method.type === 'guest') {
                        isGuestEnabled = true;
                    }
                });
            }).catch(function(error) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                }
            });
        } else {
            promise = $q.when(); // No need to get enrolment methods.
        }

        return promise.then(function() {
            // Check if user is enrolled in the course.
            return $mmCourses.getUserCourse(course.id).then(function(c) {
                $scope.isEnrolled = true;
                return c;
            }).catch(function() {
                // The user is not enrolled in the course. Use getCourses to see if it's an admin/manager and can see the course.
                $scope.isEnrolled = false;
                return $mmCourses.getCourse(course.id);
            }).then(function(c) {
                // Success retrieving the course, we can assume the user has permissions to view it.
                course.fullname = c.fullname || course.fullname;
                course.summary = c.summary || course.summary;
                course._handlers = $mmCoursesDelegate.getNavHandlersFor(course.id, refresh);
            }).catch(function() {
                // The user is not an admin/manager. Check if we can provide guest access to the course.
                return canAccessAsGuest().then(function(passwordRequired) {
                    if (!passwordRequired) {
                        course._handlers = $mmCoursesDelegate.getNavHandlersForGuest(course.id, refresh);
                    } else {
                        course._handlers = [];
                        handlersShouldBeShown = false;
                    }
                }).catch(function() {
                    course._handlers = [];
                    handlersShouldBeShown = false;
                });
            });
        });
    }

    // Convenience function to check if the user can access as guest.
    function canAccessAsGuest() {
        if (!isGuestEnabled) {
            return $q.reject();
        }

            // Search instance ID of guest enrolment method.
        angular.forEach(enrollmentMethods, function(method) {
            if (method.type == 'guest') {
                guestInstanceId = method.id;
            }
        });

        if (guestInstanceId) {
            return $mmCourses.getCourseGuestEnrolmentInfo(guestInstanceId).then(function(info) {
                if (!info.status) {
                    // Not active, reject.
                    return $q.reject();
                }
                return info.passwordrequired;
            });
        }
        return $q.reject();
    }

    function refreshData() {
        var promises = [];

        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourses.invalidateCourse(course.id));
        promises.push($mmCourses.invalidateCourseEnrolmentMethods(course.id));
        if (guestInstanceId) {
            promises.push($mmCourses.invalidateCourseGuestEnrolmentInfo(guestInstanceId));
        }

        return $q.all(promises).finally(function() {
            return getCourse(true);
        });
    }

    getCourse().finally(function() {
        $scope.courseLoaded = true;
    });

    $scope.doRefresh = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    if (selfEnrolWSAvailable && course.enrollmentmethods.indexOf('self') > -1) {
        // Setup password modal for self-enrolment.
        $ionicModal.fromTemplateUrl('core/components/courses/templates/password-modal.html', {
            scope: $scope,
            animation: 'slide-in-up'
        }).then(function(modal) {
            $scope.modal = modal;

            $scope.closeModal = function() {
                $scope.enroldata.password = '';
                delete $scope.currentEnrolInstance;
                modal.hide();
            };
            $scope.$on('$destroy', function() {
                modal.remove();
            });
        });

        // Convenience function to self-enrol a user in a course.
        $scope.enrol = function(instanceId, password) {
            var promise;

            if ($scope.modal.isShown()) {
                // Don't show confirm if password is shown, we already showed it before.
                promise = $q.when();
            } else {
                promise = $mmUtil.showConfirm($translate('mm.courses.confirmselfenrol'));
            }

            promise.then(function() {
                var modal = $mmUtil.showModalLoading('mm.core.loading', true);

                $mmCourses.selfEnrol(course.id, password, instanceId).then(function() {
                    // Close modal and refresh data.
                    $scope.closeModal();
                    $scope.isEnrolled = true;
                    refreshData().finally(function() {
                        // My courses have been updated, trigger event.
                        $mmEvents.trigger(mmCoursesEventMyCoursesUpdated, $mmSite.getId());
                    });
                }).catch(function(error) {
                    if (error) {
                        if (error.code === mmCoursesEnrolInvalidKey) {
                            // Invalid password. If password was already shown, show error message.
                            if ($scope.modal.isShown()) {
                                $mmUtil.showErrorModal(error.message);
                            } else {
                                $scope.currentEnrolInstance = instanceId;
                                $scope.modal.show();
                            }
                        } else if (typeof error == 'string') {
                            $mmUtil.showErrorModal(error);
                        }
                    } else {
                        $mmUtil.showErrorModal('mm.courses.errorselfenrol', true);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            });
        };
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Service to handle site courses.
 *
 * @module mm.core.courses
 * @ngdoc service
 * @name $mmCourses
 */
.factory('$mmCourses', ["$q", "$mmSite", "$log", "$mmSitesManager", "mmCoursesSearchPerPage", "mmCoursesEnrolInvalidKey", function($q, $mmSite, $log, $mmSitesManager, mmCoursesSearchPerPage, mmCoursesEnrolInvalidKey) {

    $log = $log.getInstance('$mmCourses');

    var self = {},
        currentCourses = {};

    /**
     * DEPRECATED: this function will be removed in a future version.
     * Clear current courses array. Reserved for core use.
     *
     * @deprecated since version 2.5
     * @protected
     */
    self.clearCurrentCourses = function() {
        currentCourses = {};
    };

    /**
     * Get course.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourse
     * @param {Number} id       ID of the course to get.
     * @param {String} [siteid] Site to get the courses from. If not defined, use current site.
     * @return {Promise}        Promise to be resolved when the courses are retrieved.
     */
    self.getCourse = function(id, siteid) {
        return self.getCourses([id], siteid).then(function(courses) {
            if (courses && courses.length > 0) {
                return courses[0];
            }
            return $q.reject();
        });
    };

    /**
     * Get the enrolment methods from a course.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourseEnrolmentMethods
     * @param {Number} id ID of the course.
     * @return {Promise}  Promise to be resolved when the methods are retrieved.
     */
    self.getCourseEnrolmentMethods = function(id) {
        var params = {
                courseid: id
            },
            preSets = {
                cacheKey: getCourseEnrolmentMethodsCacheKey(id)
            };

        return $mmSite.read('core_enrol_get_course_enrolment_methods', params, preSets);
    };

    /**
     * Get cache key for get course enrolment methods WS call.
     *
     * @param  {Number} id Course ID.
     * @return {String}    Cache key.
     */
    function getCourseEnrolmentMethodsCacheKey(id) {
        return 'mmCourses:enrolmentmethods:' + id;
    }

    /**
     * Get info from a course guest enrolment method.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourseGuestEnrolmentInfo
     * @param {Number} instanceId Guest instance ID.
     * @return {Promise}          Promise to be resolved when the info is retrieved.
     */
    self.getCourseGuestEnrolmentInfo = function(instanceId) {
        var params = {
                instanceid: instanceId
            },
            preSets = {
                cacheKey: getCourseGuestEnrolmentInfoCacheKey(instanceId)
            };

        return $mmSite.read('enrol_guest_get_instance_info', params, preSets).then(function(response) {
            return response.instanceinfo;
        });
    };

    /**
     * Get cache key for get course enrolment methods WS call.
     *
     * @param {Number} instanceId Guest instance ID.
     * @return {String}           Cache key.
     */
    function getCourseGuestEnrolmentInfoCacheKey(instanceId) {
        return 'mmCourses:guestinfo:' + instanceId;
    }

    /**
     * Get courses.
     * Warning: if the user doesn't have permissions to view some of the courses passed the WS call will fail.
     * The user must be able to view ALL the courses passed.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourses
     * @param {Number[]} ids    List of IDs of the courses to get.
     * @param {String} [siteid] Site to get the courses from. If not defined, use current site.
     * @return {Promise}        Promise to be resolved when the courses are retrieved.
     */
    self.getCourses = function(ids, siteid) {
        siteid = siteid || $mmSite.getId();

        if (!angular.isArray(ids)) {
            return $q.reject();
        } else if (ids.length === 0) {
            return $q.when([]);
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {

            var data = {
                    options: {
                        ids: ids
                    }
                },
                preSets = {
                    cacheKey: getCoursesCacheKey(ids)
                };

            return site.read('core_course_get_courses', data, preSets).then(function(courses) {
                if (typeof courses != 'object' && !angular.isArray(courses)) {
                    return $q.reject();
                }
                return courses;
            });
        });
    };

    /**
     * Get cache key for get courses WS call.
     *
     * @param  {Number[]} ids Courses IDs.
     * @return {String}       Cache key.
     */
    function getCoursesCacheKey(ids) {
        return 'mmCourses:course:' + JSON.stringify(ids);
    }

    /**
     * DEPRECATED: this function will be removed in a future version. Please use $mmCourses#getUserCourse.
     * Get a course stored in memory.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getStoredCourse
     * @param  {Number} id ID of the course to get.
     * @return {Object}    Course.
     * @deprecated since version 2.5
     */
    self.getStoredCourse = function(id) {
        $log.warn('The function \'getStoredCourse\' is deprecated. Please use \'getUserCourse\' instead');
        return currentCourses[id];
    };

    /**
     * Get a course the user is enrolled in. This function relies on $mmCourses#getUserCourses.
     * preferCache=true will try to speed up the response, but the data returned might not be updated.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getUserCourse
     * @param {Number} id                   ID of the course to get.
     * @param {Boolean} [preferCache=false] True if shouldn't call WS if data is cached, false otherwise.
     * @param {String} [siteid]             Site to get the courses from. If not defined, use current site.
     * @return {Promise}                    Promise resolved with the course.
     * @since 2.5
     */
    self.getUserCourse = function(id, preferCache, siteid) {
        siteid = siteid || $mmSite.getId();

        if (!id) {
            return $q.reject();
        }

        if (typeof preferCache == 'undefined') {
            preferCache = false;
        }

        return self.getUserCourses(preferCache, siteid).then(function(courses) {
            var course;
            angular.forEach(courses, function(c) {
                if (c.id == id) {
                    course = c;
                }
            });
            return course ? course : $q.reject();
        });
    };

    /**
     * Get user courses.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getUserCourses
     * @param {Boolean} [preferCache=false] True if shouldn't call WS if data is cached, false otherwise.
     * @param {String} [siteid]            Site to get the courses from. If not defined, use current site.
     * @return {Promise}                   Promise to be resolved when the courses are retrieved.
     */
    self.getUserCourses = function(preferCache, siteid) {
        siteid = siteid || $mmSite.getId();
        if (typeof preferCache == 'undefined') {
            preferCache = false;
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {

            var userid = site.getUserId(),
                presets = {
                    cacheKey: getUserCoursesCacheKey(),
                    omitExpires: preferCache
                },
                data = {userid: userid};

            if (typeof userid === 'undefined') {
                return $q.reject();
            }

            return site.read('core_enrol_get_users_courses', data, presets).then(function(courses) {
                if (siteid === $mmSite.getId()) {
                    // Only store courses if we're getting current site courses. This function is deprecated and will be removed.
                    storeCoursesInMemory(courses);
                }
                return courses;
            });
        });
    };

    /**
     * Get cache key for get user courses WS call.
     *
     * @return {String}       Cache key.
     */
    function getUserCoursesCacheKey() {
        return 'mmCourses:usercourses';
    }

    /**
     * Invalidates get course WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateCourse
     * @param  {Number} id Course ID.
     * @return {Promise}   Promise resolved when the data is invalidated.
     */
    self.invalidateCourse = function(id, siteid) {
        return self.invalidateCourses([id], siteid);
    };

    /**
     * Invalidates get course enrolment methods WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateUserCourses
     * @param {Number} id Course ID.
     * @return {Promise}  Promise resolved when the data is invalidated.
     */
    self.invalidateCourseEnrolmentMethods = function(id) {
        return $mmSite.invalidateWsCacheForKey(getCourseEnrolmentMethodsCacheKey(id));
    };

    /**
     * Invalidates get course guest enrolment info WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateUserCourses
     * @param {Number} instanceId Guest instance ID.
     * @return {Promise}          Promise resolved when the data is invalidated.
     */
    self.invalidateCourseGuestEnrolmentInfo = function(instanceId) {
        return $mmSite.invalidateWsCacheForKey(getCourseGuestEnrolmentInfoCacheKey(instanceId));
    };

    /**
     * Invalidates get courses WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateCourses
     * @param  {Number[]} ids   Courses IDs.
     * @param {String} [siteid] Site ID to invalidate. If not defined, use current site.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateCourses = function(ids, siteid) {
        siteid = siteid || $mmSite.getId();
        return $mmSitesManager.getSite(siteid).then(function(site) {
            return site.invalidateWsCacheForKey(getCoursesCacheKey(ids));
        });
    };

    /**
     * Invalidates get user courses WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateUserCourses
     * @param {String} [siteid] Site ID to invalidate. If not defined, use current site.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateUserCourses = function(siteid) {
        siteid = siteid || $mmSite.getId();
        return $mmSitesManager.getSite(siteid).then(function(site) {
            return site.invalidateWsCacheForKey(getUserCoursesCacheKey());
        });
    };

    /**
     * Check if WS to retrieve guest enrolment data is available.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#isGuestWSAvailable
     * @return {Boolean} True if guest WS is available, false otherwise.
     */
    self.isGuestWSAvailable = function() {
        return $mmSite.wsAvailable('enrol_guest_get_instance_info');
    };

    /**
     * Check if search courses feature is available in the current site.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#isSearchCoursesAvailable
     * @return {Boolean} True if is available, false otherwise.
     */
    self.isSearchCoursesAvailable = function() {
        return $mmSite.wsAvailable('core_course_search_courses');
    };

    /**
     * Check if self enrolment is available.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#isSelfEnrolmentEnabled
     * @return {Boolean} True if self enrolment is available, false otherwise.
     */
    self.isSelfEnrolmentEnabled = function() {
        return $mmSite.wsAvailable('enrol_self_enrol_user');
    };

    /**
     * Search courses.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#search
     * @param {String} text      Text to search.
     * @param {Number} [page]    Page to get. Defaults to 0.
     * @param {Number} [perpage] Number of courses per page. Defaults to mmCoursesSearchPerPage.
     * @return {Promise}         Promise resolved with the courses and the total of matches.
     */
    self.search = function(text, page, perpage) {
        page = page || 0;
        perpage = perpage || mmCoursesSearchPerPage;

        var params = {
                criterianame: 'search',
                criteriavalue: text,
                page: page,
                perpage: perpage
            }, preSets = {
                getFromCache: false
            };

        return $mmSite.read('core_course_search_courses', params, preSets).then(function(response) {
            if (typeof response == 'object') {
                return {total: response.total, courses: response.courses};
            }
            return $q.reject();
        });
    };

    /**
     * Self enrol current user in a certain course.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#selfEnrol
     * @param {String} courseid     Course ID.
     * @param {String} [password]   Password to use.
     * @param {Number} [instanceId] Enrol instance ID.
     * @return {Promise}            Promise resolved if the user is enrolled. If the password is invalid,
     *                              the promise is rejected with an object with code = mmCoursesEnrolInvalidKey.
     */
    self.selfEnrol = function(courseid, password, instanceId) {
        if (typeof password == 'undefined') {
            password = '';
        }

        var params = {
            courseid: courseid,
            password: password
        };
        if (instanceId) {
            params.instanceid = instanceId;
        }

        return $mmSite.write('enrol_self_enrol_user', params).then(function(response) {
            if (response) {
                if (response.status) {
                    return true;
                } else if (response.warnings && response.warnings.length) {
                    var message;
                    angular.forEach(response.warnings, function(warning) {
                        if (warning.warningcode == '2' || warning.warningcode == '4') { // Invalid password warnings.
                            message = warning.message;
                        }
                    });

                    if (message) {
                        return $q.reject({code: mmCoursesEnrolInvalidKey, message: message});
                    }
                }
            }
            return $q.reject();
        });
    };

    /**
     * DEPRECATED: this function will be removed in a future version.
     * Stores a list of courses in memory so they can be retrieved later.
     *
     * @param  {Object[]} courses Courses to store
     * @return {Void}
     * @deprecated since version 2.5
     */
    function storeCoursesInMemory(courses) {
        angular.forEach(courses, function(course) {
            currentCourses[course.id] = angular.copy(course); // Store a copy to prevent unwanted modifications.
        });
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Service to interact with courses.
 *
 * @module mm.core.courses
 * @ngdoc service
 * @name $mmCoursesDelegate
 */
.provider('$mmCoursesDelegate', function() {
    var navHandlers = {},
        self = {};

    /**
     * Register a navigation handler.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCoursesDelegate#registerNavHandler
     * @param {String} addon The addon's name (mmaLabel, mmaForum, ...)
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                                                           When using a promise, it should return a boolean.
     *                             - isEnabledForCourse(courseid, accessData) (Boolean|Promise) Whether or not the handler is
     *                                               enabled on a course level. When using a promise, it should return a boolean.
     *                             - getController(courseid) (Object) Returns the object that will act as controller.
     *                                                                See core/components/courses/templates/list.html
     *                                                                for the list of scope variables expected.
     */
    self.registerNavHandler = function(addon, handler, priority) {
        if (typeof navHandlers[addon] !== 'undefined') {
            console.log("$mmCoursesDelegateProvider: Addon '" + navHandlers[addon].addon + "' already registered as navigation handler");
            return false;
        }
        console.log("$mmCoursesDelegateProvider: Registered addon '" + addon + "' as navigation handler.");
        navHandlers[addon] = {
            addon: addon,
            handler: handler,
            instance: undefined,
            priority: priority
        };
        return true;
    };

    self.$get = ["$mmUtil", "$q", "$log", "$mmSite", "mmCoursesAccessMethods", function($mmUtil, $q, $log, $mmSite, mmCoursesAccessMethods) {
        var enabledNavHandlers = {},
            coursesHandlers = {},
            self = {},
            loaded = {};

        $log = $log.getInstance('$mmCoursesDelegate');

        /**
         * Check if addons are loaded for a certain course.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#areNavHandlersLoadedFor
         * @param {Number} courseId The course ID.
         * @return {Boolean} True if addons are loaded, false otherwise.
         */
        self.areNavHandlersLoadedFor = function(courseId) {
            return loaded[courseId];
        };

        /**
         * Clear all courses handlers.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#clearCoursesHandlers
         * @protected
         */
        self.clearCoursesHandlers = function() {
            coursesHandlers = {};
            loaded = {};
        };

        /**
         * Get the handler for a course using a certain access type.
         *
         * @param {Number} courseId    The course ID.
         * @param {Boolean} refresh    True if it should refresh the list.
         * @param  {Object} accessData Access type and data. Default, guest, ...
         * @return {Array}             Array of objects containing 'priority' and 'controller'.
         */
        function getNavHandlersForAccess(courseId, refresh, accessData) {
            if (refresh || !coursesHandlers[courseId] || coursesHandlers[courseId].access.type != accessData.type) {
                coursesHandlers[courseId] = {
                    access: accessData,
                    handlers: []
                };
                self.updateNavHandlersForCourse(courseId, accessData);
            }
            return coursesHandlers[courseId].handlers;
        }

        /**
         * Get the handlers for a course where the user is enrolled in.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#getNavHandlersFor
         * @param {Number} courseId The course ID.
         * @param {Boolean} refresh True if it should refresh the list.
         * @return {Array}          Array of objects containing 'priority' and 'controller'.
         */
        self.getNavHandlersFor = function(courseId, refresh) {
            // Default access.
            var accessData = {
                type: mmCoursesAccessMethods.default
            };
            return getNavHandlersForAccess(courseId, refresh, accessData);
        };

        /**
         * Get the handlers for a course as guest.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#getNavHandlersForGuest
         * @param {Number} courseId The course ID.
         * @param {Boolean} refresh True if it should refresh the list.
         * @return {Array}          Array of objects containing 'priority' and 'controller'.
         */
        self.getNavHandlersForGuest = function(courseId, refresh) {
            // Guest access.
            var accessData = {
                type: mmCoursesAccessMethods.guest
            };
            return getNavHandlersForAccess(courseId, refresh, accessData);
        };

        /**
         * Update the handler for the current site.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#updateNavHandler
         * @param {String} addon The addon.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateNavHandler = function(addon, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledNavHandlers[addon] = {
                        instance: handlerInfo.instance,
                        priority: handlerInfo.priority
                    };
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledNavHandlers[addon];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#updateNavHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateNavHandlers = function() {
            var promises = [];

            $log.debug('Updating navigation handlers for current site.');

            // Loop over all the content handlers.
            angular.forEach(navHandlers, function(handlerInfo, addon) {
                promises.push(self.updateNavHandler(addon, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            }).finally(function() {
                // Update handlers for all courses.
                angular.forEach(coursesHandlers, function(handler, courseId) {
                    self.updateNavHandlersForCourse(parseInt(courseId), handler.access);
                });
            });
        };

        /**
         * Update the handlers for a certain course.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#updateNavHandlersForCourse
         * @param {Number} courseId    The course ID.
         * @param  {Object} accessData Access type and data. Default, guest, ...
         * @return {Promise}           Resolved when updated.
         * @protected
         */
        self.updateNavHandlersForCourse = function(courseId, accessData) {
            var promises = [],
                enabledForCourse = [];

            angular.forEach(enabledNavHandlers, function(handler) {
                // Checks if the handler is enabled for the user.
                var promise = $q.when(handler.instance.isEnabledForCourse(courseId, accessData)).then(function(enabled) {
                    if (enabled) {
                        enabledForCourse.push(handler);
                    } else {
                        return $q.reject();
                    }
                }).catch(function() {
                    // Nothing to do here, it is not enabled for this user.
                });
                promises.push(promise);
            });

            return $q.all(promises).then(function() {
                return true;
            }).catch(function() {
                // Never fails.
                return true;
            }).finally(function() {
                // Update the coursesHandlers array with the new enabled addons.
                $mmUtil.emptyArray(coursesHandlers[courseId].handlers);
                angular.forEach(enabledForCourse, function(handler) {
                    coursesHandlers[courseId].handlers.push({
                        controller: handler.instance.getController(courseId),
                        priority: handler.priority
                    });
                });
                loaded[courseId] = true;
            });
        };

        return self;
    }];


    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Courses handlers factory.
 *
 * @module mm.core.courses
 * @ngdoc service
 * @name $mmCoursesHandlers
 */
.factory('$mmCoursesHandlers', ["$mmSite", "$state", "$mmCourses", "$q", "$mmUtil", "$translate", "$timeout", "$mmContentLinksHelper", "mmCoursesEnrolInvalidKey", function($mmSite, $state, $mmCourses, $q, $mmUtil, $translate, $timeout, $mmContentLinksHelper,
            mmCoursesEnrolInvalidKey) {

    var self = {};

    /**
     * Content links handler.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCoursesHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Action to perform when an enrol link is clicked.
         *
         * @param  {Number} courseId Course ID.
         * @param  {String} url      Treated URL.
         * @return {Void}
         */
        function actionEnrol(courseId, url) {
            var modal = $mmUtil.showModalLoading();

            // Check if user is enrolled in the course.
            $mmCourses.getUserCourse(courseId).catch(function() {
                // User is not enrolled in the course. Check if can self enrol.
                return canSelfEnrol(courseId).then(function() {
                    modal.dismiss();
                    return selfEnrol(courseId).catch(function() {
                        if (typeof error == 'string') {
                            $mmUtil.showErrorModal(error);
                        }
                        return $q.reject();
                    });
                }, function(error) {
                    // Error. Show error message and allow the user to open the link in browser.
                    modal.dismiss();
                    if (typeof error != 'string') {
                        error = $translate.instant('mm.courses.notenroled');
                    }

                    var body = $translate('mm.core.twoparagraphs',
                                    {p1: error, p2: $translate.instant('mm.core.confirmopeninbrowser')});
                    $mmUtil.showConfirm(body).then(function() {
                        $mmUtil.openInBrowser(url);
                    });
                    return $q.reject();
                });
            }).then(function() {
                modal.dismiss();
                $state.go('site.mm_course', {courseid: parseInt(courseId)});
            });
        }

        /**
         * Check if a user can be "automatically" self enrolled in a course.
         *
         * @param  {Number} courseId Course ID.
         * @return {Promise}         Promise resolved if user is can be enrolled in a course, rejected otherwise.
         */
        function canSelfEnrol(courseId) {
            // Check if self enrolment is enabled.
            if (!$mmCourses.isSelfEnrolmentEnabled()) {
                return $q.reject();
            }

            // Check that the course has self enrolment enabled.
            return $mmCourses.getCourseEnrolmentMethods(courseId).then(function(methods) {
                var isSelfEnrolEnabled = false,
                    instances = 0;
                angular.forEach(methods, function(method) {
                    if (method.type == 'self' && method.status) {
                        isSelfEnrolEnabled = true;
                        instances++;
                    }
                });

                if (!isSelfEnrolEnabled || instances != 1) {
                    // Self enrol not enabled or more than one instance.
                    return $q.reject();
                }
            });
        }

        /**
         * Try to self enrol a user in a course.
         *
         * @param  {Number} courseId Course ID.
         * @param  {String} password Password.
         * @return {Promise}         Promiser esolved when the user is enrolled, rejected otherwise.
         */
        function selfEnrol(courseId, password) {
            var modal = $mmUtil.showModalLoading();
            return $mmCourses.selfEnrol(courseId, password).then(function() {
                // Success self enrolling the user, invalidate the courses list.
                return $mmCourses.invalidateUserCourses().catch(function() {
                    // Ignore errors.
                }).then(function() {
                    // For some reason, if we get the course list right after self enrolling
                    // we won't retrieve the new course. Let's delay it a bit.
                    return $timeout(function() {}, 4000).finally(function() {
                        modal.dismiss();
                    });
                });

            }).catch(function(error) {
                modal.dismiss();
                if (error && error.code === mmCoursesEnrolInvalidKey) {
                    // Invalid password. Allow the user to input password.
                    var title = $translate.instant('mm.courses.selfenrolment'),
                        body = ' ', // Empty message.
                        placeholder = $translate.instant('mm.courses.password');

                    if (typeof password != 'undefined') {
                        // The user attempted a password. Show an error message.
                        $mmUtil.showErrorModal(error.message);
                    }

                    return $mmUtil.showPrompt(body, title, placeholder).then(function(password) {
                        return selfEnrol(courseId, password);
                    });
                } else {
                    return $q.reject(error);
                }
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        List of actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check if it's a course URL.
            if (url.indexOf('enrol/index.php') > -1 || url.indexOf('course/enrol.php') > -1 ||
                        url.indexOf('course/view.php') > -1) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: siteIds,
                        action: function(siteId) {
                            siteId = siteId || $mmSite.getId();
                            if (siteId == $mmSite.getId()) {
                                actionEnrol(parseInt(params.id, 10), url);
                            } else {
                                $mmContentLinksHelper.goInSite('site.mm_course', {courseid: parseInt(params.id, 10)}, siteId);
                            }
                        }
                    }];
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle input of user credentials.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginCredentialsCtrl
 */
.controller('mmLoginCredentialsCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmUtil", "$ionicHistory", "$mmApp", "$q", "$mmLoginHelper", "$translate", function($scope, $state, $stateParams, $mmSitesManager, $mmUtil, $ionicHistory, $mmApp,
            $q, $mmLoginHelper, $translate) {

    $scope.siteurl = $stateParams.siteurl;
    $scope.credentials = {};

    var siteChecked = false;

    // Function to check if a site uses local_mobile, requires SSO login, etc.
    // This should be used only if a fixed URL is set, otherwise this check is already performed in mmLoginSiteCtrl.
    function checkSite(siteurl) {
        var checkmodal = $mmUtil.showModalLoading();
        return $mmSitesManager.checkSite(siteurl).then(function(result) {

            siteChecked = true;
            $scope.siteurl = result.siteurl;

            if (result && result.warning) {
                $mmUtil.showErrorModal(result.warning, true, 4000);
            }

            if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                // SSO. User needs to authenticate in a browser.
                $scope.isBrowserSSO = true;
                $mmUtil.showConfirm($translate('mm.login.logininsiterequired')).then(function() {
                    $mmLoginHelper.openBrowserForSSOLogin(result.siteurl);
                });
            } else {
                $scope.isBrowserSSO = false;
            }

        }).catch(function(error) {
            $mmUtil.showErrorModal(error);
            return $q.reject();
        }).finally(function() {
            checkmodal.dismiss();
        });
    }

    if ($mmLoginHelper.isFixedUrlSet()) {
        // Fixed URL, we need to check if it uses browser SSO login.
        checkSite($scope.siteurl);
    } else {
        siteChecked = true;
    }

    $scope.login = function() {

        $mmApp.closeKeyboard();

        // Get input data.
        var siteurl = $scope.siteurl,
            username = $scope.credentials.username,
            password = $scope.credentials.password;

        if (!siteChecked) {
            // Site wasn't checked (it failed), let's check again.
            return checkSite(siteurl).then(function() {
                if (!$scope.isBrowserSSO) {
                    // Site doesn't use browser SSO, throw app's login again.
                    return $scope.login();
                }
            });
        } else if ($scope.isBrowserSSO) {
            // A previous check determined that browser SSO is needed. Let's check again, maybe site was updated.
            return checkSite(siteurl);
        }

        if (!username) {
            $mmUtil.showErrorModal('mm.login.usernamerequired', true);
            return;
        }
        if (!password) {
            $mmUtil.showErrorModal('mm.login.passwordrequired', true);
            return;
        }

        var modal = $mmUtil.showModalLoading();

        // Start the authentication process.
        return $mmSitesManager.getUserToken(siteurl, username, password).then(function(data) {
            return $mmSitesManager.newSite(data.siteurl, data.token).then(function() {
                delete $scope.credentials; // Delete username and password from the scope.
                $ionicHistory.nextViewOptions({disableBack: true});
                $state.go('site.mm_courses');
            });
        }).catch(function(error) {
            $mmUtil.showErrorModal(error);
        }).finally(function() {
            modal.dismiss();
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle splash screen and initialize the app (restore session, determine first state, etc.).
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginInitCtrl
 */
.controller('mmLoginInitCtrl', ["$log", "$ionicHistory", "$state", "$mmSitesManager", "$mmSite", "$mmApp", "$mmLoginHelper", function($log, $ionicHistory, $state, $mmSitesManager, $mmSite, $mmApp, $mmLoginHelper) {

    $log = $log.getInstance('mmLoginInitCtrl');

    $mmApp.ready().then(function() {

        // Disable animation and back button for the next transition.
        $ionicHistory.nextViewOptions({
            disableAnimate: true,
            disableBack: true
        });

        if ($mmSite.isLoggedIn()) {
            $state.go('site.mm_courses');
        } else {
            $mmSitesManager.hasSites().then(function() {
                return $state.go('mm_login.sites');
            }, function() {
                return $mmLoginHelper.goToAddSite();
            });
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle input of user credentials.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginReconnectCtrl
 */
.controller('mmLoginReconnectCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmApp", "$mmUtil", "$ionicHistory", function($scope, $state, $stateParams, $mmSitesManager, $mmApp, $mmUtil, $ionicHistory) {

    var infositeurl = $stateParams.infositeurl; // Siteurl in site info. It might be different than siteurl (http/https).
    $scope.siteurl = $stateParams.siteurl;
    $scope.credentials = {
        username: $stateParams.username,
        password: ''
    };

    $scope.cancel = function() {
        $mmSitesManager.logout().finally(function() {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.go('mm_login.sites');
        });
    };

    $scope.login = function() {

        $mmApp.closeKeyboard();

        // Get input data.
        var siteurl = $scope.siteurl,
            username = $scope.credentials.username,
            password = $scope.credentials.password;

        if (!password) {
            $mmUtil.showErrorModal('mm.login.passwordrequired', true);
            return;
        }

        var modal = $mmUtil.showModalLoading();

        // Start the authentication process.
        $mmSitesManager.getUserToken(siteurl, username, password).then(function(data) {
            $mmSitesManager.updateSiteToken(infositeurl, username, data.token).then(function() {
                // Update site info too because functions might have changed (e.g. unisntall local_mobile).
                $mmSitesManager.updateSiteInfoByUrl(infositeurl, username).finally(function() {
                    delete $scope.credentials; // Delete password from the scope.
                    $ionicHistory.nextViewOptions({disableBack: true});
                    $state.go('site.mm_courses');
                });
            }, function(error) {
                // Site deleted? Go back to login page.
                $mmUtil.showErrorModal('mm.login.errorupdatesite', true);
                $scope.cancel();
            }).finally(function() {
                modal.dismiss();
            });
        }, function(error) {
            modal.dismiss();
            $mmUtil.showErrorModal(error);
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle the input of a site URL and its validation.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginSiteCtrl
 */
.controller('mmLoginSiteCtrl', ["$scope", "$state", "$mmSitesManager", "$mmUtil", "$translate", "$ionicHistory", "$mmApp", "$ionicModal", "$mmLoginHelper", function($scope, $state, $mmSitesManager, $mmUtil, $translate, $ionicHistory, $mmApp,
        $ionicModal, $mmLoginHelper) {

    $scope.siteurl = '';
    $scope.isInvalidUrl = true;

    $scope.validate = function(url) {
        if (!url) {
            $scope.isInvalidUrl = true;
            return;
        }

        if ($mmSitesManager.getDemoSiteData(url)) {
            // Is demo site.
            $scope.isInvalidUrl = false;
        } else {
            // formatURL adds the protocol if is missing.
            var formattedurl = $mmUtil.formatURL(url);
            $scope.isInvalidUrl = formattedurl.indexOf('://localhost') == -1 && !$mmUtil.isValidURL(formattedurl);
        }
    };

    $scope.connect = function(url) {

        $mmApp.closeKeyboard();

        if (!url) {
            $mmUtil.showErrorModal('mm.login.siteurlrequired', true);
            return;
        }

        var modal = $mmUtil.showModalLoading(),
            sitedata = $mmSitesManager.getDemoSiteData(url);

        if (sitedata) {
            // It's a demo site.
            $mmSitesManager.getUserToken(sitedata.url, sitedata.username, sitedata.password).then(function(data) {
                $mmSitesManager.newSite(data.siteurl, data.token).then(function() {
                    $ionicHistory.nextViewOptions({disableBack: true});
                    $state.go('site.mm_courses');
                }, function(error) {
                    $mmUtil.showErrorModal(error);
                }).finally(function() {
                    modal.dismiss();
                });
            }, function(error) {
                modal.dismiss();
                $mmUtil.showErrorModal(error);
            });

        } else {
            // Not a demo site.
            $mmSitesManager.checkSite(url).then(function(result) {

                if (result.warning) {
                    $mmUtil.showErrorModal(result.warning, true, 4000);
                }

                if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                    // SSO. User needs to authenticate in a browser.
                    $mmUtil.showConfirm($translate('mm.login.logininsiterequired')).then(function() {
                        $mmLoginHelper.openBrowserForSSOLogin(result.siteurl);
                    });
                } else {
                    $state.go('mm_login.credentials', {siteurl: result.siteurl});
                }

            }, function(error) {
                $mmUtil.showErrorModal(error);
            }).finally(function() {
                modal.dismiss();
            });
        }
    };

    // Get docs URL for help modal.
    $mmUtil.getDocsUrl().then(function(docsurl) {
        $scope.docsurl = docsurl;
    });

    // Setup help modal.
    $ionicModal.fromTemplateUrl('core/components/login/templates/help-modal.html', {
        scope: $scope,
        animation: 'slide-in-up'
    }).then(function(helpModal) {
        $scope.showHelp = function() {
            helpModal.show();
        };
        $scope.closeHelp = function() {
            helpModal.hide();
        };
        $scope.$on('$destroy', function() {
            helpModal.remove();
        });
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle the list of sites.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginSitesCtrl
 */
.controller('mmLoginSitesCtrl', ["$scope", "$state", "$mmSitesManager", "$log", "$translate", "$mmUtil", "$ionicHistory", "$mmText", "$mmLoginHelper", function($scope, $state, $mmSitesManager, $log, $translate, $mmUtil, $ionicHistory, $mmText,
            $mmLoginHelper) {

    $log = $log.getInstance('mmLoginSitesCtrl');

    $mmSitesManager.getSites().then(function(sites) {
        $scope.sites = sites;
        $scope.data = {
            hasSites: sites.length > 0,
            showDelete: false
        };
    });

    $scope.toggleDelete = function() {
        $scope.data.showDelete = !$scope.data.showDelete;
    };

    $scope.onItemDelete = function(e, index) {
        // Prevent login() from being triggered. No idea why I cannot replicate this
        // problem on http://codepen.io/ionic/pen/JsHjf.
        e.stopPropagation();

        var site = $scope.sites[index],
            sitename = site.sitename;

        $mmText.formatText(sitename).then(function(sitename) {
            $mmUtil.showConfirm($translate('mm.login.confirmdeletesite', {sitename: sitename})).then(function() {
                $mmSitesManager.deleteSite(site.id).then(function() {
                    $scope.sites.splice(index, 1);
                    $mmSitesManager.hasNoSites().then(function() {
                        // No sites left, go to add a new site state.
                        $ionicHistory.nextViewOptions({disableBack: true});
                        $mmLoginHelper.goToAddSite();
                    });
                }, function() {
                    $log.error('Delete site failed');
                    $mmUtil.showErrorModal('mm.login.errordeletesite', true);
                });
            });
        });
    };

    $scope.login = function(siteid) {
        var modal = $mmUtil.showModalLoading();

        $mmSitesManager.loadSite(siteid).then(function() {
            $ionicHistory.nextViewOptions({disableBack: true});
            $state.go('site.mm_courses');
        }, function(error) {
            $log.error('Error loading site '+siteid);
            error = error || 'Error loading site.';
            $mmUtil.showErrorModal(error);
        }).finally(function() {
            modal.dismiss();
        });
    };

    $scope.add = function() {
        $mmLoginHelper.goToAddSite();
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

.constant('mmLoginSSOCode', 2) // This code is returned by local_mobile Moodle plugin if SSO in browser is required.
.constant('mmLoginLaunchSiteURL', 'mmLoginLaunchSiteURL')
.constant('mmLoginLaunchPassport', 'mmLoginLaunchPassport')

/**
 * Service to provide some helper functionalities for the login component.
 *
 * @module mm.core.login
 * @ngdoc service
 * @name $mmLoginHelper
 */
.factory('$mmLoginHelper', ["$q", "$log", "$mmConfig", "mmLoginSSOCode", "mmLoginLaunchSiteURL", "mmLoginLaunchPassport", "md5", "$mmSite", "$mmSitesManager", "$mmLang", "$mmUtil", "$state", "mmCoreConfigConstants", function($q, $log, $mmConfig, mmLoginSSOCode, mmLoginLaunchSiteURL, mmLoginLaunchPassport,
            md5, $mmSite, $mmSitesManager, $mmLang, $mmUtil, $state, mmCoreConfigConstants) {

    $log = $log.getInstance('$mmLoginHelper');

    var self = {};

    /**
     * Go to the view to add a new site.
     * If a fixed URL is configured, go to credentials instead.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#goToAddSite
     * @return {Promise} Promise resolved when the state changes.
     */
    self.goToAddSite = function() {
        if (mmCoreConfigConstants.siteurl) {
            // Fixed URL is set, go to credentials page.
            return $state.go('mm_login.credentials', {siteurl: mmCoreConfigConstants.siteurl});
        } else {
            return $state.go('mm_login.site');
        }
    };

    /**
     * Check if the app is configured to use a fixed URL.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#isFixedUrlSet
     * @return {Boolean} True if set, false otherwise.
     */
    self.isFixedUrlSet = function() {
        return typeof mmCoreConfigConstants.siteurl != 'undefined';
    };

    /**
     * Check if SSO login is needed based on code returned by the WS.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#isSSOLoginNeeded
     * @param  {Number}  code Code to check.
     * @return {Boolean}      True if SSO login is needed, false othwerise.
     */
    self.isSSOLoginNeeded = function(code) {
        return code == mmLoginSSOCode;
    };

    /**
     * Open a browser to perform SSO login.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#openBrowserForSSOLogin
     * @param {String} siteurl URL of the site where the SSO login will be performed.
     */
    self.openBrowserForSSOLogin = function(siteurl) {
        var passport = Math.random() * 1000;
        var loginurl = siteurl + "/local/mobile/launch.php?service=" + mmCoreConfigConstants.wsextservice;
        loginurl += "&passport=" + passport;

        // Store the siteurl and passport in $mmConfig for persistence. We are "configuring"
        // the app to wait for an SSO. $mmConfig shouldn't be used as a temporary storage.
        $mmConfig.set(mmLoginLaunchSiteURL, siteurl);
        $mmConfig.set(mmLoginLaunchPassport, passport);

        $mmUtil.openInBrowser(loginurl);
        if (navigator.app) {
            navigator.app.exitApp();
        }
    };

    /**
     * Convenient helper to validate a browser SSO login.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#validateBrowserSSOLogin
     * @param {String} url URL received, to be validated.
     * @return {Promise}   The success contains the signature and token. The reject contains the error message.
     */
    self.validateBrowserSSOLogin = function(url) {
        // Split signature:::token
        var params = url.split(":::");

        return $mmConfig.get(mmLoginLaunchSiteURL).then(function(launchSiteURL) {
            return $mmConfig.get(mmLoginLaunchPassport).then(function(passport) {

                // Reset temporary values.
                $mmConfig.delete(mmLoginLaunchSiteURL);
                $mmConfig.delete(mmLoginLaunchPassport);

                // Validate the signature.
                // We need to check both http and https.
                var signature = md5.createHash(launchSiteURL + passport);
                if (signature != params[0]) {
                    if (launchSiteURL.indexOf("https://") != -1) {
                        launchSiteURL = launchSiteURL.replace("https://", "http://");
                    } else {
                        launchSiteURL = launchSiteURL.replace("http://", "https://");
                    }
                    signature = md5.createHash(launchSiteURL + passport);
                }

                if (signature == params[0]) {
                    $log.debug('Signature validated');
                    return { siteurl: launchSiteURL, token: params[1] };
                } else {
                    $log.debug('Inalid signature in the URL request yours: ' + params[0] + ' mine: '
                                    + signature + ' for passport ' + passport);
                    return $mmLang.translateAndReject('mm.core.unexpectederror');
                }

            });
        });
    };

    /**
     * Convenient helper to handle authentication in the app using a token received by SSO login. If it's a new account,
     * the site is stored and the user is authenticated. If the account already exists, update its token.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#handleSSOLoginAuthentication
     * @param {String} siteurl Site's URL.
     * @param {String} token   User's token.
     * @return {Promise}       Promise resolved when the user is authenticated with the token. Reject returns an error message.
     */
    self.handleSSOLoginAuthentication = function(siteurl, token) {
        if ($mmSite.isLoggedIn()) {
            // User logged in, he is reconnecting.
            var deferred = $q.defer();

            // Retrieve username.
            var info = $mmSite.getInfo();
            if (typeof(info) !== 'undefined' && typeof(info.username) !== 'undefined') {
                $mmSitesManager.updateSiteToken(info.siteurl, info.username, token).then(function() {
                    $mmSitesManager.updateSiteInfoByUrl(info.siteurl, info.username).finally(deferred.resolve);
                }, function() {
                    // Error updating token, return proper error message.
                    $mmLang.translateAndRejectDeferred(deferred, 'mm.login.errorupdatesite');
                });
            } else {
                $mmLang.translateAndRejectDeferred(deferred, 'mm.login.errorupdatesite');
            }
            return deferred.promise;
        } else {
            return $mmSitesManager.newSite(siteurl, token);
        }
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'About' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsAboutCtrl
 */
.controller('mmSettingsAboutCtrl', ["$scope", "$translate", "$window", "$mmApp", "$ionicPlatform", "$mmLang", "$mmFS", "$mmLocalNotifications", "mmCoreConfigConstants", function($scope, $translate, $window, $mmApp, $ionicPlatform, $mmLang, $mmFS,
            $mmLocalNotifications, mmCoreConfigConstants) {

    $scope.versionname = mmCoreConfigConstants.versionname;
    $translate('mm.settings.appname', {version: $scope.versionname}).then(function(appName) {
        $scope.appname = appName;
    });

    $scope.versioncode = mmCoreConfigConstants.versioncode;

    $scope.navigator = $window.navigator;
    if ($window.location && $window.location.href) {
        var url = $window.location.href;
        $scope.locationhref = url.substr(0, url.indexOf('#/site/'));
    }

    $scope.appready = $mmApp.isReady() ? 'mm.core.yes' : 'mm.core.no';
    $scope.devicetype = $ionicPlatform.isTablet() ? 'mm.core.tablet' : 'mm.core.phone';

    if (ionic.Platform.isAndroid()) {
        $scope.deviceos = 'mm.core.android';
    } else if (ionic.Platform.isIOS()) {
        $scope.deviceos = 'mm.core.ios';
    } else if (ionic.Platform.isWindowsPhone()) {
        $scope.deviceos = 'mm.core.windowsphone';
    } else {
        var matches = navigator.userAgent.match(/\(([^\)]*)\)/);
        if (matches && matches.length > 1) {
            $scope.deviceos = matches[1];
        } else {
            $scope.deviceos = 'mm.core.unknown';
        }
    }

    $mmLang.getCurrentLanguage().then(function(lang) {
        $scope.currentlanguage = lang;
    });

    $scope.networkstatus = $mmApp.isOnline() ? 'mm.core.online' : 'mm.core.offline';
    $scope.wificonnection = $mmApp.isNetworkAccessLimited() ? 'mm.core.no' : 'mm.core.yes';
    $scope.devicewebworkers = !!window.Worker && !!window.URL ? 'mm.core.yes' : 'mm.core.no';
    $scope.device = ionic.Platform.device();

    if ($mmFS.isAvailable()) {
        $mmFS.getBasePath().then(function(basepath) {
            $scope.filesystemroot = basepath;
            $scope.fsclickable = $mmFS.usesHTMLAPI();
        });
    }

    $scope.storagetype = $mmApp.getDB().getType();
    $scope.localnotifavailable = $mmLocalNotifications.isAvailable() ? 'mm.core.yes' : 'mm.core.no';
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'General' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsGeneralCtrl
 */
.controller('mmSettingsGeneralCtrl', ["$scope", "$mmLang", "$ionicHistory", "$mmEvents", "$mmConfig", "mmCoreEventLanguageChanged", "mmCoreSettingsReportInBackground", "mmCoreConfigConstants", "mmCoreSettingsDownloadSection", function($scope, $mmLang, $ionicHistory, $mmEvents, $mmConfig, mmCoreEventLanguageChanged,
            mmCoreSettingsReportInBackground, mmCoreConfigConstants, mmCoreSettingsDownloadSection) {

    $scope.langs = mmCoreConfigConstants.languages;

    $mmLang.getCurrentLanguage().then(function(currentLanguage) {
        $scope.selectedLanguage = currentLanguage;
    });

    $scope.languageChanged = function(newLang) {
        $mmLang.changeCurrentLanguage(newLang).finally(function() {
            // Clear cached views.
            $ionicHistory.clearCache();
            $mmEvents.trigger(mmCoreEventLanguageChanged);
        });
    };

    $mmConfig.get(mmCoreSettingsDownloadSection, true).then(function(downloadSectionEnabled) {
        $scope.downloadSection = downloadSectionEnabled;
    });

    $scope.downloadSectionChanged = function(downloadSection) {
        $mmConfig.set(mmCoreSettingsDownloadSection, downloadSection);
    };

    if (localStorage && localStorage.getItem && localStorage.setItem) {
        $scope.showReport = true;
        $scope.reportInBackground = parseInt(localStorage.getItem(mmCoreSettingsReportInBackground), 10) === 1;

        $scope.reportChanged = function(inBackground) {
            localStorage.setItem(mmCoreSettingsReportInBackground, inBackground ? '1' : '0');
        };
    } else {
        $scope.showReport = false;
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'Space Usage' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsSpaceUsageCtrl
 * @todo When "mock site" is implemented we should have functions to calculate the site usage and delete its files.
 */
.controller('mmSettingsSpaceUsageCtrl', ["$log", "$scope", "$mmSitesManager", "$mmFS", "$q", "$mmUtil", "$translate", "$mmText", "$mmFilepool", function($log, $scope, $mmSitesManager, $mmFS, $q, $mmUtil, $translate,
            $mmText, $mmFilepool) {
    $log = $log.getInstance('mmSettingsSpaceUsageCtrl');

    // Convenience function to calculate each site's usage, and the total usage.
    function calculateSizeUsage() {
        return $mmSitesManager.getSites().then(function(sites) {
            var promises = [];
            $scope.sites = sites;

            angular.forEach(sites, function(siteEntry) {
                var promise = $mmSitesManager.getSite(siteEntry.id).then(function(site) {
                    return site.getSpaceUsage().then(function(size) {
                        siteEntry.spaceusage = size;
                    });
                });
                promises.push(promise);
            });

            return $q.all(promises);
        });
    }

    // Convenience function to calculate total usage.
    function calculateTotalUsage() {
        var total = 0;
        angular.forEach($scope.sites, function(site) {
            if (site.spaceusage) {
                total += parseInt(site.spaceusage, 10);
            }
        });
        $scope.totalusage = total;
    }

    // Convenience function to calculate free space in the device.
    function calculateFreeSpace() {
        if ($mmFS.isAvailable()) {
            return $mmFS.calculateFreeSpace().then(function(freespace) {
                $scope.freespace = freespace;
            }, function() {
                $scope.freespace = 0;
            });
        } else {
            $scope.freespace = 0;
        }
    }

    function fetchData() {
        var promises = [];
        promises.push(calculateSizeUsage().then(calculateTotalUsage));
        promises.push($q.when(calculateFreeSpace()));
        return $q.all(promises);
    }
    fetchData().finally(function() {
        $scope.sizeLoaded = true;
    });

    // Pull to refresh.
    $scope.refresh = function() {
        fetchData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Convenience function to update site size, along with total usage and free space.
    function updateSiteUsage(site, newUsage) {
        var oldUsage = site.spaceusage;
        site.spaceusage = newUsage;
        $scope.totalusage -= oldUsage - newUsage;
        $scope.freespace += oldUsage - newUsage;
    }

    $scope.deleteSiteFiles = function(siteData) {
        if (siteData) {
            var siteid = siteData.id,
                sitename = siteData.sitename;

            $mmText.formatText(sitename).then(function(sitename) {
                $translate('mm.settings.deletesitefilestitle').then(function(title) {
                    return $mmUtil.showConfirm($translate('mm.settings.deletesitefiles', {sitename: sitename}), title);
                }).then(function() {
                    return $mmSitesManager.getSite(siteid);
                }).then(function(site) {
                    return site.deleteFolder().then(function() {
                        $mmFilepool.clearAllPackagesStatus(siteid);
                        $mmFilepool.clearFilepool(siteid);
                        updateSiteUsage(siteData, 0);
                    }).catch(function(error) {
                        if (error && error.code === FileError.NOT_FOUND_ERR) {
                            // Not found, set size 0.
                            $mmFilepool.clearAllPackagesStatus(siteid);
                            updateSiteUsage(siteData, 0);
                        } else {
                            // Error, recalculate the site usage.
                            $mmUtil.showErrorModal('mm.settings.errordeletesitefiles', true);
                            site.getSpaceUsage().then(function(size) {
                                updateSiteUsage(siteData, size);
                            });
                        }
                    });
                });
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'Synchronization' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsSynchronizationCtrl
 */
.controller('mmSettingsSynchronizationCtrl', ["$log", "$scope", "$mmSitesManager", "$mmUtil", "$mmFilepool", "$mmEvents", "$mmLang", "$mmConfig", "mmCoreEventSessionExpired", "mmCoreSettingsSyncOnlyOnWifi", function($log, $scope, $mmSitesManager, $mmUtil, $mmFilepool, $mmEvents,
            $mmLang, $mmConfig, mmCoreEventSessionExpired, mmCoreSettingsSyncOnlyOnWifi) {
    $log = $log.getInstance('mmSettingsSynchronizationCtrl');

    $mmSitesManager.getSites().then(function(sites) {
        $scope.sites = sites;
    });

    $mmConfig.get(mmCoreSettingsSyncOnlyOnWifi, true).then(function(syncOnlyOnWifi) {
        $scope.syncOnlyOnWifi = syncOnlyOnWifi;
    });

    $scope.syncWifiChanged = function(syncOnlyOnWifi) {
        $mmConfig.set(mmCoreSettingsSyncOnlyOnWifi, syncOnlyOnWifi);
    };

    $scope.synchronize = function(siteData) {
        if (siteData) {
            var siteid = siteData.id,
                modal = $mmUtil.showModalLoading('mm.settings.synchronizing', true);
            $mmFilepool.invalidateAllFiles(siteid).finally(function() {
                $mmSitesManager.getSite(siteid).then(function(site) {
                    return site.invalidateWsCache().then(function() {
                        // Check if local_mobile was installed to Moodle.
                        return site.checkIfLocalMobileInstalledAndNotUsed().then(function() {
                            // Local mobile was added. Throw invalid session to force reconnect and create a new token.
                            $mmEvents.trigger(mmCoreEventSessionExpired, siteid);
                            return $mmLang.translateAndReject('mm.core.lostconnection');
                        }, function() {
                            // Update site info.
                            return $mmSitesManager.updateSiteInfo(siteid);
                        });
                    }).then(function() {
                        siteData.fullname = site.getInfo().fullname;
                        siteData.sitename = site.getInfo().sitename;
                        $mmUtil.showModal('mm.core.success', 'mm.settings.syncsitesuccess');
                    });
                }).catch(function(error) {
                    if (error) {
                        $mmUtil.showErrorModal(error);
                    } else {
                        $mmUtil.showErrorModal('mm.settings.errorsyncsite', true);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.sidemenu')

/**
 * Controller to handle the side menu.
 *
 * @module mm.core.sidemenu
 * @ngdoc controller
 * @name mmSideMenuCtrl
 */
.controller('mmSideMenuCtrl', ["$scope", "$state", "$mmSideMenuDelegate", "$mmSitesManager", "$mmSite", "$mmEvents", "$timeout", "mmCoreEventLanguageChanged", "mmCoreEventSiteUpdated", function($scope, $state, $mmSideMenuDelegate, $mmSitesManager, $mmSite, $mmEvents,
            $timeout, mmCoreEventLanguageChanged, mmCoreEventSiteUpdated) {

    $scope.handlers = $mmSideMenuDelegate.getNavHandlers();
    $scope.areNavHandlersLoaded = $mmSideMenuDelegate.areNavHandlersLoaded;
    $scope.siteinfo = $mmSite.getInfo();

    $scope.logout = function() {
        $mmSitesManager.logout().finally(function() {
            $state.go('mm_login.sites');
        });
    };

    $mmSite.getDocsUrl().then(function(docsurl) {
        $scope.docsurl = docsurl;
    });

    function updateSiteInfo() {
        // We need to use $timeout to force a $digest and make $watch notice the variable change.
        $scope.siteinfo = undefined;
        $timeout(function() {
            $scope.siteinfo = $mmSite.getInfo();

            // Update docs URL, maybe the Moodle release has changed.
            $mmSite.getDocsUrl().then(function(docsurl) {
                $scope.docsurl = docsurl;
            });
        });
    }

    var langObserver = $mmEvents.on(mmCoreEventLanguageChanged, updateSiteInfo);
    var updateSiteObserver = $mmEvents.on(mmCoreEventSiteUpdated, function(siteid) {
        if ($mmSite.getId() === siteid) {
            updateSiteInfo();
        }
    });

    $scope.$on('$destroy', function() {
        if (langObserver && langObserver.off) {
            langObserver.off();
        }
        if (updateSiteObserver && updateSiteObserver.off) {
            updateSiteObserver.off();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.sidemenu')

/**
 * Service to interact with plugins to be shown in the side menu. Provides functions to register a plugin
 * and notify an update in the data.
 *
 * @module mm.core.sidemenu
 * @ngdoc provider
 * @name $mmSideMenuDelegate
 */
.provider('$mmSideMenuDelegate', function() {
    var navHandlers = {},
        self = {};

    /**
     * Register a navigation handler.
     *
     * @module mm.core.sidemenu
     * @ngdoc method
     * @name $mmSideMenuDelegateProvider#registerNavHandler
     * @param {String} addon The addon's name (mmaFiles, mmaMessages, ...)
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                                                           When using a promise, it should return a boolean.
     *                             - getController (Object) Returns the object that will act as controller.
     *                                                                See core/components/sidemenu/templates/menu.html
     *                                                                for the list of scope variables expected.
     */
    self.registerNavHandler = function(addon, handler, priority) {
        if (typeof navHandlers[addon] !== 'undefined') {
            console.log("$mmSideMenuDelegateProvider: Addon '" + navHandlers[addon].addon + "' already registered as navigation handler");
            return false;
        }
        console.log("$mmSideMenuDelegateProvider: Registered addon '" + addon + "' as navigation handler.");
        navHandlers[addon] = {
            addon: addon,
            handler: handler,
            instance: undefined,
            priority: priority
        };
        return true;
    };

    self.$get = ["$mmUtil", "$q", "$log", "$mmSite", function($mmUtil, $q, $log, $mmSite) {
        var enabledNavHandlers = {},
            currentSiteHandlers = [], // Handlers to return.
            self = {},
            loaded = false; // If site handlers have been loaded.

        $log = $log.getInstance('$mmSideMenuDelegate');

        /**
         * Check if addons are loaded.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#areNavHandlersLoaded
         * @return {Boolean} True if addons are loaded, false otherwise.
         */
        self.areNavHandlersLoaded = function() {
            return loaded;
        };

        /**
         * Clear current site nav handlers. Reserved for core use.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#clearSiteHandlers
         * @return {Void}
         */
        self.clearSiteHandlers = function() {
            loaded = false;
            $mmUtil.emptyArray(currentSiteHandlers);
        };

        /**
         * Get the handlers for the current site.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#getNavHandlers
         * @return {Promise} Resolved with an array of objects containing 'priority' and 'controller'.
         */
        self.getNavHandlers = function() {
            return currentSiteHandlers;
        };

        /**
         * Update the handler for the current site.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#updateNavHandler
         * @param {String} addon The addon.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateNavHandler = function(addon, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledNavHandlers[addon] = {
                        instance: handlerInfo.instance,
                        priority: handlerInfo.priority
                    };
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledNavHandlers[addon];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#updateNavHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateNavHandlers = function() {
            var promises = [];

            $log.debug('Updating navigation handlers for current site.');

            // Loop over all the content handlers.
            angular.forEach(navHandlers, function(handlerInfo, addon) {
                promises.push(self.updateNavHandler(addon, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            }).finally(function() {

                $mmUtil.emptyArray(currentSiteHandlers);

                angular.forEach(enabledNavHandlers, function(handler) {
                    currentSiteHandlers.push({
                        controller: handler.instance.getController(),
                        priority: handler.priority
                    });
                });

                loaded = true;
            });
        };

        return self;
    }];

    return self;

});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.textviewer')

/**
 * Text viewer  controller.
 *
 * @module mm.core.textviewer
 * @ngdoc controller
 * @name mmTextViewerIndexCtrl
 */
.controller('mmTextViewerIndexCtrl', ["$stateParams", "$scope", function($stateParams, $scope) {
    $scope.title = $stateParams.title;
    $scope.content = $stateParams.content;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

/**
 * Controller to handle a user profile page.
 *
 * @module mm.core.user
 * @ngdoc controller
 * @name mmaParticipantsProfileCtrl
 */
.controller('mmUserProfileCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmUser", "$mmUserDelegate", "$mmSite", "$q", "$translate", function($scope, $stateParams, $mmUtil, $mmUser, $mmUserDelegate, $mmSite, $q, $translate) {

    var courseid = $stateParams.courseid,
        userid   = $stateParams.userid;

    $scope.isAndroid = ionic.Platform.isAndroid();
    $scope.plugins = [];

    function fetchUserData() {
        return $mmUser.getProfile(userid, courseid).then(function(user) {

            user.address = $mmUser.formatAddress(user.address, user.city, user.country);
            if (user.address) {
                user.encodedAddress = encodeURIComponent(user.address);
            }

            $mmUser.formatRoleList(user.roles).then(function(roles) {
                user.roles = roles;
            });

            $scope.user = user;
            $scope.title = user.fullname;
            $scope.hasContact = user.email || user.phone1 || user.phone2 || user.city || user.country || user.address;
            $scope.hasDetails = user.url || user.roles || user.interests;

            $scope.isLoadingHandlers = true;
            $mmUserDelegate.getProfileHandlersFor(user, courseid).then(function(handlers) {
                $scope.profileHandlers = handlers;
            }).finally(function() {
                $scope.isLoadingHandlers = false;
            });
        }, function(message) {
            $scope.user = false;
            if (message) {
                $mmUtil.showErrorMessage(message);
            }
            return $q.reject();
        });
    }

    fetchUserData().then(function() {
        // Add log in Moodle.
        return $mmSite.write('core_user_view_user_profile', {
            userid: userid,
            courseid: courseid
        }).catch(function(error) {
            $scope.isDeleted = error === $translate.instant('mm.core.userdeleted');
        });
    }).finally(function() {
        $scope.userLoaded = true;
    });

    $scope.refreshUser = function() {
        $mmUser.invalidateUserCache(userid).finally(function() {
            fetchUserData().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to go to user profile on click.
 *
 * @module mm.core
 * @ngdoc provider
 * @name mmUserLink
 */
.directive('mmUserLink', ["$state", "mmUserProfileState", function($state, mmUserProfileState) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                $state.go(mmUserProfileState, {courseid: attrs.courseid, userid: attrs.userid});
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

/**
 * Service to interact with plugins to be shown in user profile. Provides functions to register a plugin
 * and notify an update in the data.
 *
 * @module mm.core.user
 * @ngdoc provider
 * @name $mmUserDelegate
 */
.provider('$mmUserDelegate', function() {
    var profileHandlers = {},
        self = {};

    /**
     * Register a profile handler.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUserDelegateProvider#registerProfileHandler
     * @param {String} component The addon's name, or addon and sub context (mmaMessages, mmaMessage:blockContact, ...)
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                          returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                                                           When using a promise, it should return a boolean.
     *                             - isEnabledForUser (Boolean|Promise) Whether or not the handler is enabled for a user.
     *                                                                  When using a promise, it should return a boolean.
     *                             - getController(userid) (Function) Returns the function that will act as controller.
     *                                                                See core/components/user/templates/profile.html
     *                                                                for the list of scope variables expected.
     *                           The string can either be 'factoryName' or 'factoryName.functionToCall'.
     * @param {Number} [priority=100] Plugin priority.
     */
    self.registerProfileHandler = function(component, handler, priority) {
        if (typeof profileHandlers[component] !== 'undefined') {
            console.log("$mmUserDelegateProvider: Handler '" + profileHandlers[component].component + "' already registered as profile handler");
            return false;
        }
        console.log("$mmUserDelegateProvider: Registered component '" + component + "' as profile handler.");
        profileHandlers[component] = {
            component: component,
            handler: handler,
            instance: undefined,
            priority: typeof priority === 'undefined' ? 100 : priority
        };
        return true;
    };

    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", function($q, $log, $mmSite, $mmUtil) {
        var enabledProfileHandlers = {},
            self = {};

        $log = $log.getInstance('$mmUserDelegate');

        /**
         * Get the profile handlers for a user.
         *
         * @module mm.core.user
         * @ngdoc method
         * @name $mmUserDelegate#getProfileHandlersFor
         * @param {Object} user The user object.
         * @param {Number} courseId The course ID.
         * @return {Promise} Resolved with an array of objects containing 'priority' and 'controller'.
         */
        self.getProfileHandlersFor = function(user, courseId) {
            var handlers = [],
                promises = [];

            angular.forEach(enabledProfileHandlers, function(handler) {
                // Checks if the handler is enabled for the user.
                var promise = $q.when(handler.instance.isEnabledForUser(user, courseId)).then(function(enabled) {
                    if (enabled) {
                        handlers.push({
                            controller: handler.instance.getController(user, courseId),
                            priority: handler.priority
                        });
                    } else {
                        return $q.reject();
                    }
                }).catch(function() {
                    // Nothing to do here, it is not enabled for this user.
                });
                promises.push(promise);
            });

            return $q.all(promises).then(function() {
                return handlers;
            }).catch(function() {
                // Never fails.
                return handlers;
            });
        };

        /**
         * Update the enabled profile handlers for the current site.
         *
         * @module mm.core.user
         * @ngdoc method
         * @name $mmUserDelegate#updateProfileHandler
         * @param {String} component The component name.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateProfileHandler = function(component, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledProfileHandlers[component] = {
                        instance: handlerInfo.instance,
                        priority: handlerInfo.priority
                    };
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledProfileHandlers[component];
            });
        };

        /**
         * Update the profile handlers for the current site.
         *
         * @module mm.core.user
         * @ngdoc method
         * @name $mmUserDelegate#updateProfileHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateProfileHandlers = function() {
            var promises = [];

            $log.debug('Updating profile handlers for current site.');

            // Loop over all the profile handlers.
            angular.forEach(profileHandlers, function(handlerInfo, component) {
                promises.push(self.updateProfileHandler(component, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            });
        };

        return self;

    }];

    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

/**
 * User handlers factory.
 *
 * @module mm.core.user
 * @ngdoc service
 * @name $mmUserHandlers
 */
.factory('$mmUserHandlers', ["$mmUtil", "$mmContentLinksHelper", function($mmUtil, $mmContentLinksHelper) {

    var self = {};

    /**
     * Content links handler.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUserHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        List of actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a user URL.
            if (url.indexOf('grade/report/user') == -1 &&
                    (url.indexOf('/user/view.php') > -1 || url.indexOf('/user/profile.php') > -1)) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: siteIds,
                        action: function(siteId) {
                            var stateParams = {
                                courseid: params.course,
                                userid: parseInt(params.id, 10)
                            };
                            $mmContentLinksHelper.goInSite('site.mm_user-profile', stateParams, siteId);
                        }
                    }];
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

.constant('mmCoreUsersStore', 'users')

.config(["$mmSitesFactoryProvider", "mmCoreUsersStore", function($mmSitesFactoryProvider, mmCoreUsersStore) {
    var stores = [
        {
            name: mmCoreUsersStore,
            keyPath: 'id'
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Service to provide user functionalities.
 *
 * @module mm.core.user
 * @ngdoc service
 * @name $mmUser
 */
.factory('$mmUser', ["$log", "$q", "$mmSite", "$mmUtil", "$translate", "mmCoreUsersStore", function($log, $q, $mmSite, $mmUtil, $translate, mmCoreUsersStore) {

    $log = $log.getInstance('$mmUser');

    var self = {};

    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @param  {Number} id User ID.
     * @return {Promise}   Promise resolve when the user is deleted.
     */
    self.deleteStoredUser = function(id) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }

        self.invalidateUserCache(id); // Invalidate WS calls.
        return $mmSite.getDb().remove(mmCoreUsersStore, parseInt(id));
    };

    /**
     * Formats a user address, concatenating address, city and country.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#formatAddress
     * @param  {String} address Address.
     * @param  {String} city    City..
     * @param  {String} country Country.
     * @return {String}         Formatted address.
     */
    self.formatAddress = function(address, city, country) {
        if (address) {
            address += city ? ', ' + city : '';
            address += country ? ', ' + country : '';
        }
        return address;
    };

    /**
     * Formats a user role list, translating and concatenating them.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#formatRoleList
     * @param  {Array} roles List of user roles.
     * @return {Promise}     Promise resolved with the formatted roles (string).
     */
    self.formatRoleList = function(roles) {
        var deferred = $q.defer();

        if (roles && roles.length > 0) {
            $translate('mm.core.elementseparator').then(function(separator) {
                var rolekeys = roles.map(function(el) {
                    return 'mm.user.'+el.shortname; // Set the string key to be translated.
                });

                $translate(rolekeys).then(function(roleNames) {
                    var roles = '';
                    for (var roleKey in roleNames) {
                        var roleName = roleNames[roleKey];
                        if (roleName.indexOf('mm.user.') > -1) {
                            // Role name couldn't be translated, leave it like it was.
                            roleName = roleName.replace('mm.user.', '');
                        }
                        roles += (roles != '' ? separator: '') + roleName;
                    }
                    deferred.resolve(roles);
                });
            });
        } else {
            deferred.resolve('');
        }
        return deferred.promise;
    };

    /**
     * Get user profile. The type of profile retrieved depends on the params.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#getProfile
     * @param  {Number} userid      User's ID.
     * @param  {Number} [courseid]  Course ID to get course profile, undefined or 0 to get site profile.
     * @param  {Boolean} forceLocal True to retrieve the user data from local DB, false to retrieve it from WS.
     * @return {Promise}            Promise resolved with the user data.
     */
    self.getProfile = function(userid, courseid, forceLocal) {

        var deferred = $q.defer();

        if (forceLocal) {
            self.getUserFromLocal(userid).then(deferred.resolve, function() {
                self.getUserFromWS(userid, courseid).then(deferred.resolve, deferred.reject);
            });
        } else {
            self.getUserFromWS(userid, courseid).then(deferred.resolve, function() {
                self.getUserFromLocal(userid).then(deferred.resolve, deferred.reject);
            });
        }

        return deferred.promise;
    };

    /**
     * Invalidates user WS calls.
     *
     * @param  {Number} userid User ID.
     * @return {String}        Cache key.
     */
    function getUserCacheKey(userid) {
        return 'mmUser:data:'+userid;
    }

    /**
     * Get user basic information from local DB.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#getUserFromLocal
     * @param  {Number} id User ID.
     * @return {Promise}   Promise resolve when the user is retrieved.
     */
    self.getUserFromLocal = function(id) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }
        return $mmSite.getDb().get(mmCoreUsersStore, parseInt(id));
    };

    /**
     * Get user profile from WS.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#getUserFromWS
     * @param  {Number} id         User ID.
     * @param  {Number} [courseid] Course ID to get course profile, undefined or 0 to get site profile.
     * @return {Promise}           Promise resolve when the user is retrieved.
     */
    self.getUserFromWS = function(userid, courseid) {
        var wsName,
            data,
            preSets ={
                cacheKey: getUserCacheKey(userid)
            };

        // Determine WS and data to use.
        if (courseid > 1) {
            $log.debug('Get participant with ID ' + userid + ' in course '+courseid);
            wsName = 'core_user_get_course_user_profiles';
            data = {
                "userlist[0][userid]": userid,
                "userlist[0][courseid]": courseid
            };
        } else {
            $log.debug('Get user with ID ' + userid);
            if ($mmSite.wsAvailable('core_user_get_users_by_field')) {
                wsName = 'core_user_get_users_by_field';
                data = {
                    'field': 'id',
                    'values[0]': userid
                };
            } else {
                wsName = 'core_user_get_users_by_id';
                data = {
                    'userids[0]': userid
                };
            }
        }

        return $mmSite.read(wsName, data, preSets).then(function(users) {
            if (users.length == 0) {
                return $q.reject();
            }

            var user = users.shift();
            if (user.country) {
                user.country = $mmUtil.getCountryName(user.country);
            }
            self.storeUser(user.id, user.fullname, user.profileimageurl);
            return user;
        });
    };

    /**
     * Invalidates user WS calls.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#invalidateUserCache
     * @param  {Number} userid User ID.
     * @return {Promise}       Promise resolved when the data is invalidated.
     */
    self.invalidateUserCache = function(userid) {
        return $mmSite.invalidateWsCacheForKey(getUserCacheKey(userid));
    };

    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#storeUser
     * @param  {Number} id       User ID.
     * @param  {String} fullname User full name.
     * @param  {String} avatar   User avatar URL.
     * @return {Promise}         Promise resolve when the user is stored.
     */
    self.storeUser = function(id, fullname, avatar) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }

        return $mmSite.getDb().insert(mmCoreUsersStore, {
            id: parseInt(id),
            fullname: fullname,
            profileimageurl: avatar
        });
    };

    /**
     * Store users basic information in local DB.
     *
     * @param  {Object[]} users Users to store. Fields stored: id, fullname, profileimageurl.
     * @return {Promise}        Promise resolve when the user is stored.
     */
    self.storeUsers = function(users) {
        var promises = [];

        angular.forEach(users, function(user) {
            var userid = user.id || user.userid,
                img = user.profileimageurl || user.profileimgurl;
            if (typeof userid != 'undefined') {
                promises.push(self.storeUser(userid, user.fullname, img));
            }
        });

        return $q.all(promises);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Mod content controller.
 *
 * @todo MDL-50114 The description might be missing because this data is based on the course
 *       contents which does not always include it.
 * @module mm.core.course
 * @ngdoc controller
 * @name mmCourseModContentCtrl
 */
.controller('mmCourseModContentCtrl', ["$log", "$stateParams", "$scope", function($log, $stateParams, $scope) {
    $log = $log.getInstance('mmCourseModContentCtrl');
    var module = $stateParams.module || {};
    $scope.description = module.description;
    $scope.title = module.name;
    $scope.url = module.url;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Section view controller.
 *
 * @module mm.core.course
 * @ngdoc controller
 * @name mmCourseSectionCtrl
 */
.controller('mmCourseSectionCtrl', ["$mmCourseDelegate", "$mmCourse", "$mmUtil", "$scope", "$stateParams", "$translate", "$mmSite", "$mmEvents", "$ionicScrollDelegate", "$mmCourses", "$q", "mmCoreEventCompletionModuleViewed", "$controller", function($mmCourseDelegate, $mmCourse, $mmUtil, $scope, $stateParams, $translate, $mmSite,
            $mmEvents, $ionicScrollDelegate, $mmCourses, $q, mmCoreEventCompletionModuleViewed, $controller) {

    // Default values are course 1 (front page) and all sections.
    var courseId = $stateParams.cid || 1,
        sectionId = $stateParams.sectionid || -1,
        moduleId = $stateParams.mid;

    $scope.sitehome = (courseId === 1); // Are we visiting the site home?
    $scope.sections = []; // Reset scope.sections, otherwise an error is shown in console with tablet view.

    if (sectionId < 0) {
        // Special scenario, we want all sections.
        if ($scope.sitehome) {
            $scope.title = $translate.instant('mma.frontpage.sitehome');
        } else {
            $scope.title = $translate.instant('mm.course.allsections');
        }
        $scope.summary = null;
    }

    // Convenience function to fetch section(s).
    function loadContent(sectionId) {
        return $mmCourses.getUserCourse(courseId, true).catch(function() {
            // User not enrolled in the course or an error occurred, ignore the error.
        }).then(function(course) {
            var promise;
            if (course && course.enablecompletion === false) {
                promise = $q.when([]); // Completion not enabled, return empty array.
            } else {
                promise = $mmCourse.getActivitiesCompletionStatus(courseId).catch(function() {
                    return []; // If fail, return empty array (as if there was no completion).
                });
            }

            return promise.then(function(statuses) {
                var promise,
                    sectionnumber;

                if (sectionId < 0) {
                    sectionnumber = 0;
                    promise = $mmCourse.getSections(courseId);
                } else {
                    sectionnumber = sectionId;
                    promise = $mmCourse.getSection(courseId, sectionId).then(function(section) {
                        $scope.title = section.name;
                        $scope.summary = section.summary;
                        return [section];
                    });
                }

                return promise.then(function(sections) {
                    // For the site home, we need to reverse the order to display first the site home section topic.
                    if ($scope.sitehome) {
                        sections.reverse();
                    }

                    var hasContent = false;

                    angular.forEach(sections, function(section) {
                        if (section.summary != '' || section.modules.length) {
                            hasContent = true;
                        }

                        angular.forEach(section.modules, function(module) {
                            module._controller =
                                    $mmCourseDelegate.getContentHandlerControllerFor(module.modname, module, courseId, section.id);
                            // Check if activity has completions and if it's marked.
                            var status = statuses[module.id];
                            if (typeof status != 'undefined') {
                                module.completionstatus = status;
                            }

                            if (module.id == moduleId) {
                                // This is the module we're looking for. Open it.
                                var scope = $scope.$new();
                                $controller(module._controller, {$scope: scope});
                                if (scope.action) {
                                    scope.action();
                                }
                            }
                        });
                    });

                    $scope.sections = sections;
                    $scope.hasContent = hasContent;

                    // Add log in Moodle.
                    $mmSite.write('core_course_view_course', {
                        courseid: courseId,
                        sectionnumber: sectionnumber
                    });
                }, function(error) {
                    if (error) {
                        $mmUtil.showErrorModal(error);
                    } else {
                        $mmUtil.showErrorModal('mm.course.couldnotloadsectioncontent', true);
                    }
                });
            });
        });
    }

    loadContent(sectionId).finally(function() {
        $scope.sectionLoaded = true;
    });

    $scope.doRefresh = function() {
        $mmCourse.invalidateSections(courseId).finally(function() {
            loadContent(sectionId).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    // Refresh list after a completion change since there could be new activities or so.
    function refreshAfterCompletionChange() {
        var scrollView = $ionicScrollDelegate.$getByHandle('mmSectionScroll');
        if (scrollView && scrollView.getScrollPosition()) {
            $scope.loadingPaddingTop = scrollView.getScrollPosition().top;
        }
        $scope.sectionLoaded = false;
        $scope.sections = [];
        loadContent(sectionId).finally(function() {
            $scope.sectionLoaded = true;
            $scope.loadingPaddingTop = 0;
        });
    }

    // Completion changed for at least one module. Invalidate data and re-load it.
    $scope.completionChanged = function() {
        $mmCourse.invalidateSections(courseId).finally(function() {
            refreshAfterCompletionChange();
        });
    };

    // Listen for viewed modules. If an automatic completion module is viewed, refresh the whole list.
    var observer = $mmEvents.on(mmCoreEventCompletionModuleViewed, function(cid) {
        if (cid === courseId) {
            refreshAfterCompletionChange();
        }
    });
    $scope.$on('$destroy', function() {
        if (observer && observer.off) {
            observer.off();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Sections view controller.
 *
 * @module mm.core.course
 * @ngdoc controller
 * @name mmCourseSectionsCtrl
 */
.controller('mmCourseSectionsCtrl', ["$mmCourse", "$mmUtil", "$scope", "$stateParams", "$translate", "$mmCourseHelper", "$mmEvents", "$mmSite", "$mmCoursePrefetchDelegate", "$mmCourses", "$q", "$ionicHistory", "$ionicPlatform", "mmCoreCourseAllSectionsId", "mmCoreEventSectionStatusChanged", "$mmConfig", "mmCoreSettingsDownloadSection", "$state", "$timeout", function($mmCourse, $mmUtil, $scope, $stateParams, $translate, $mmCourseHelper, $mmEvents,
            $mmSite, $mmCoursePrefetchDelegate, $mmCourses, $q, $ionicHistory, $ionicPlatform, mmCoreCourseAllSectionsId,
            mmCoreEventSectionStatusChanged, $mmConfig, mmCoreSettingsDownloadSection, $state, $timeout) {
    var courseId = $stateParams.courseid,
        sectionId = $stateParams.sid,
        moduleId = $stateParams.moduleid,
        downloadSectionsEnabled;

    $scope.courseId = courseId;
    $scope.sectionToLoad = 2; // Load "General" section by default.

    function checkDownloadSectionsEnabled() {
        return $mmConfig.get(mmCoreSettingsDownloadSection, true).then(function(enabled) {
            downloadSectionsEnabled = enabled;
        }).catch(function() {
            // Shouldn't happen.
            downloadSectionsEnabled = false;
        });
    }

    function loadSections(refresh) {
        // Get full course data. If not refreshing we'll try to get it from cache to speed up the response.
        return $mmCourses.getUserCourse(courseId).then(function(course) {
            $scope.fullname = course.fullname;
            // Get the sections.
            return $mmCourse.getSections(courseId).then(function(sections) {
                // Add a fake first section (all sections).
                return $translate('mm.course.allsections').then(function(str) {
                    // Adding fake first section.
                    var result = [{
                        name: str,
                        id: mmCoreCourseAllSectionsId
                    }].concat(sections);

                    $scope.sections = result;

                    if (downloadSectionsEnabled) {
                        // Calculate status of the sections.
                        return $mmCourseHelper.calculateSectionsStatus(result, courseId, true, refresh).catch(function() {
                            // Ignore errors (shouldn't happen).
                        }).then(function(downloadpromises) {
                            // If we restored any download we'll recalculate the status once all of them have finished.
                            if (downloadpromises && downloadpromises.length) {
                                $mmUtil.allPromises(downloadpromises).catch(function() {
                                    if (!$scope.$$destroyed) {
                                        $mmUtil.showErrorModal('mm.course.errordownloadingsection', true);
                                    }
                                }).finally(function() {
                                    if (!$scope.$$destroyed) {
                                        // Recalculate the status.
                                        $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false);
                                    }
                                });
                            }
                        });
                    }
                });
            });
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.couldnotloadsections', true);
            }
        });
    }

    // Prefetch a section. The second parameter indicates if the prefetch was started manually (true)
    // or it was automatically started because all modules are being downloaded (false).
    function prefetch(section, manual) {
        $mmCourseHelper.prefetch(section, courseId, $scope.sections).catch(function() {
            // Don't show error message if scope is destroyed or it's an automatic download but we aren't in this state.
            if ($scope.$$destroyed) {
                return;
            }

            var current = $ionicHistory.currentStateName(),
                isCurrent = ($ionicPlatform.isTablet() && current == 'site.mm_course.mm_course-section') ||
                            (!$ionicPlatform.isTablet() && current == 'site.mm_course');
            if (!manual && !isCurrent) {
                return;
            }

            $mmUtil.showErrorModal('mm.course.errordownloadingsection', true);
        }).finally(function() {
            if (!$scope.$$destroyed) {
                // Recalculate the status.
                $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false);
            }
        });
    }

    // Convenience function to autoload a section if sectionId param is set.
    function autoloadSection() {
        if (sectionId) {
            if ($ionicPlatform.isTablet()) {
                // Search the position of the section to load.
                angular.forEach($scope.sections, function(section, index) {
                    if (section.id == sectionId) {
                        $scope.sectionToLoad = index + 1;
                    }
                });
                // Set moduleId to pass it to the new state when the section is autoloaded. We unset it after this
                // to prevent autoloading the module when the user manually loads a section.
                $scope.moduleId = moduleId;
                $timeout(function() {
                    $scope.moduleId = null; // Unset moduleId when
                }, 500);
            } else {
                $state.go('site.mm_course-section', {
                    sectionid: sectionId,
                    cid: courseId,
                    mid: moduleId
                });
            }
        }
    }

    $scope.doRefresh = function() {
        var promises = [];
        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourse.invalidateSections(courseId));

        $q.all(promises).finally(function() {
            loadSections(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    $scope.prefetch = function(e, section) {
        e.preventDefault();
        e.stopPropagation();

        $mmCourseHelper.confirmDownloadSize(courseId, section, $scope.sections).then(function() {
            prefetch(section, true);
        });
    };

    checkDownloadSectionsEnabled().then(function() {
        loadSections().finally(function() {
            autoloadSection();
            $scope.sectionsLoaded = true;
        });
    });

    // Listen for section status changes.
    var statusObserver = $mmEvents.on(mmCoreEventSectionStatusChanged, function(data) {
        if (downloadSectionsEnabled && $scope.sections && $scope.sections.length && data.siteid === $mmSite.getId() &&
                    !$scope.$$destroyed&& data.sectionid) {
            // Check if the affected section is being downloaded. If so, we don't update section status
            // because it'll already be updated when the download finishes.
            if ($mmCoursePrefetchDelegate.isBeingDownloaded($mmCourseHelper.getSectionDownloadId({id: data.sectionid}))) {
                return;
            }

            // Recalculate the status.
            $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false).then(function() {
                var section;
                angular.forEach($scope.sections, function(s) {
                    if (s.id === data.sectionid) {
                        section = s;
                    }
                });
                if (section) {
                    var downloadid = $mmCourseHelper.getSectionDownloadId(section);
                    if (section.isDownloading && !$mmCoursePrefetchDelegate.isBeingDownloaded(downloadid)) {
                        // All the modules are now downloading, set a download all promise.
                        prefetch(section, false);
                    }
                }
            });
        }
    });

    $scope.$on('$destroy', function() {
        statusObserver && statusObserver.off && statusObserver.off();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Course Mod Description directive.
 *
 * To use to display the description of a module.
 *
 * @module mm.core.course
 * @ngdoc directive
 * @name mmCourseModDescription
 * @description
 *
 * This directive is meant to display a module description in a similar way throughout
 * all the modules. It has its own scope and so will use the attribute 'description' to
 * know what scope variable to look for in the parent scope.
 *
 * If the description is asynchronous you should set the attribute 'watch' to true.
 * This attribute is directly shared with mmFormatText which needs it.
 *
 * You can add a note at the right side of the description by using the 'note' attribute.
 *
 * Module descriptions are shortened by default, allowing the user to see the full description by clicking in it.
 * If you want the whole description to be shown you can use the 'showfull' attribute.
 *
 * @example
 *
 * <mm-course-mod-description description="myDescription"></mm-course-mod-description>
 *
 * <mm-course-mod-description description="myAsyncDesc" watch="true"></mm-course-mod-description>
 */
.directive('mmCourseModDescription', function() {
    return {
        compile: function(element, attrs) {
            if (attrs.watch) {
                element.find('mm-format-text').attr('watch', attrs.watch);
            }

            return function(scope) { // Link function.
                scope.showfull = !!attrs.showfull;
            };
        },
        restrict: 'E',
        scope: {
            description: '=',
            note: '='
        },
        templateUrl: 'core/components/course/templates/mod_description.html'
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Default course content handler.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseContentHandler
 */
.factory('$mmCourseContentHandler', ["$mmCourse", "$mmUtil", function($mmCourse, $mmUtil) {
    return {
        getController: function(module) {
            return function($scope, $state) {
                $scope.icon = $mmCourse.getModuleIconSrc(module.modname);
                $scope.title = module.name;

                $scope.action = function(e) {
                    $state.go('site.mm_course-modcontent', {module: module});
                    e.preventDefault();
                    e.stopPropagation();
                };

                if (module.url) {
                    $scope.buttons = [{
                        icon: 'ion-ios-browsers-outline',
                        label: 'mm.core.openinbrowser',
                        action: function(e) {
                            $mmUtil.openInBrowser(module.url);
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }];
                }
            };
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

.constant('mmCoreCourseModulesStore', 'course_modules') // @deprecated since version 2.6. Please do not use.

.config(["$mmSitesFactoryProvider", "mmCoreCourseModulesStore", function($mmSitesFactoryProvider, mmCoreCourseModulesStore) {
    var stores = [
        {
            name: mmCoreCourseModulesStore,
            keyPath: 'id'
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Factory containing course related methods.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourse
 */
.factory('$mmCourse', ["$mmSite", "$translate", "$q", "$log", "$mmEvents", "$mmSitesManager", "mmCoreEventCompletionModuleViewed", function($mmSite, $translate, $q, $log, $mmEvents, $mmSitesManager, mmCoreEventCompletionModuleViewed) {

    $log = $log.getInstance('$mmCourse');

    var self = {},
        mods = ["assign", "assignment", "book", "chat", "choice", "data", "database", "date", "external-tool",
            "feedback", "file", "folder", "forum", "glossary", "ims", "imscp", "label", "lesson", "lti", "page", "quiz",
            "resource", "scorm", "survey", "url", "wiki", "workshop"
        ],
        modsWithContent = ['book', 'folder', 'imscp', 'page', 'resource', 'url'];

    /**
     * Add a 'contents' property if the module needs it and it doesn't have it already. In some weird cases the site
     * doesn't return this property and it's needed. See MOBILE-1381.
     *
     * @param {Object} module Module to check.
     * @return {Object}       Module with contents.
     */
    function addContentsIfNeeded(module) {
        if (modsWithContent.indexOf(module.modname) > -1) {
            module.contents = module.contents || [];
        }
        return module;
    }

    /**
     * Check if the site is prepared to return a module without having its course ID.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#canGetModuleWithoutCourseId
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if can return it, rejected or resolved with false otherwise.
     */
    self.canGetModuleWithoutCourseId = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('core_course_get_course_module');
        });
    };

    /**
     * Check if the site is prepared to return a module by instance ID.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#canGetModuleByInstance
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if can return it, rejected or resolved with false otherwise.
     */
    self.canGetModuleByInstance = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('core_course_get_course_module_by_instance');
        });
    };

    /**
     * Check if module completion could have changed. If it could have, trigger event. This function must be used,
     * for example, after calling a "module_view" WS since it can change the module completion.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#checkModuleCompletion
     * @param {Number} courseId   Course ID.
     * @param {Object} completion Completion status of the module.
     */
    self.checkModuleCompletion = function(courseId, completion) {
        if (completion && completion.tracking === 2 && completion.state === 0) {
            self.invalidateSections(courseId).finally(function() {
                $mmEvents.trigger(mmCoreEventCompletionModuleViewed, courseId);
            });
        }
    };

    /**
     * Get completion status of all the activities in a course for a certain user.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getActivitiesCompletionStatus
     * @param  {Number} courseid Course ID.
     * @param  {Number} [userid] User ID. If not defined, current user.
     * @return {Promise}         Promise resolved with the completion statuses: object where the key is module ID.
     */
    self.getActivitiesCompletionStatus = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();

        $log.debug('Getting completion status for user ' + userid + ' in course ' + courseid);

        var params = {
                courseid: courseid,
                userid: userid
            },
            preSets = {
                cacheKey: getActivitiesCompletionCacheKey(courseid, userid)
            };

        return $mmSite.read('core_completion_get_activities_completion_status', params, preSets).then(function(data) {
            if (data && data.statuses) {
                var formattedStatuses = {};
                angular.forEach(data.statuses, function(status) {
                    formattedStatuses[status.cmid] = status;
                });
                return formattedStatuses;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for activities completion WS calls.
     *
     * @param  {Number} courseid Course ID.
     * @param  {Number} userid   User ID.
     * @return {String}          Cache key.
     */
    function getActivitiesCompletionCacheKey(courseid, userid) {
        return 'mmCourse:activitiescompletion:' + courseid + ':' + userid;
    }

    /**
     * Gets a module basic info by module ID.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleBasicInfo
     * @param  {Number} moduleId Module ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the module's info.
     */
    self.getModuleBasicInfo = function(moduleId, siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    cmid: moduleId
                },
                preSets = {
                    cacheKey: getModuleCacheKey(moduleId)
                };

            return site.read('core_course_get_course_module', params, preSets).then(function(response) {
                if (response.cm && (!response.warnings || !response.warnings.length)) {
                    return response.cm;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Gets a module basic info by instance.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleBasicInfoByInstance
     * @param {Number} id        Instance ID.
     * @param {String} module    Name of the module. E.g. 'glossary'.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the module's info.
     */
    self.getModuleBasicInfoByInstance = function(id, module, siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    instance: id,
                    module: module
                },
                preSets = {
                    cacheKey: getModuleByInstanceCacheKey(id, module)
                };

            return site.read('core_course_get_course_module_by_instance', params, preSets).then(function(response) {
                if (response.cm && (!response.warnings || !response.warnings.length)) {
                    return response.cm;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Get a module from Moodle.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModule
     * @param {Number} moduleId    The module ID.
     * @param {Number} [courseId]  The course ID. Recommended to speed up the process and minimize data usage.
     * @param {Number} [sectionId] The section ID.
     * @return {Promise}
     */
    self.getModule = function(moduleId, courseId, sectionId) {

        if (!moduleId) {
            return $q.reject();
        }

        var promise;

        if (!courseId) {
            // No courseId passed, try to retrieve it.
            promise = self.getModuleBasicInfo(moduleId).then(function(module) {
                return module.course;
            });
        } else {
            promise = $q.when(courseId);
        }

        return promise.then(function(courseId) {
            // We have courseId, we can use core_course_get_contents for compatibility.
            $log.debug('Getting module ' + moduleId + ' in course ' + courseId);

            params = {
                courseid: courseId,
                options: [
                    {
                        name: 'cmid',
                        value: moduleId
                    }
                ]
            };
            preSets = {
                cacheKey: getModuleCacheKey(moduleId)
            };

            if (sectionId) {
                params.options.push({
                    name: 'sectionid',
                    value: sectionId
                });
            }

            return $mmSite.read('core_course_get_contents', params, preSets).catch(function() {
                // Error getting the module. Try to get all contents (without filtering).
                params.options = [];
                preSets.cacheKey = getSectionsCacheKey(courseId);
                return $mmSite.read('core_course_get_contents', params, preSets);
            }).then(function(sections) {
                var section,
                    module;

                for (var i = 0; i < sections.length; i++) {
                    section = sections[i];
                    for (var j = 0; j < section.modules.length; j++) {
                        module = section.modules[j];
                        if (module.id == moduleId) {
                            module.course = courseId;
                            return addContentsIfNeeded(module);
                        }
                    }
                }
                return $q.reject();
            });
        });
    };

    /**
     * Get cache key for module WS calls.
     *
     * @param {Number} id     Instance ID.
     * @param {String} module Name of the module. E.g. 'glossary'.
     * @return {String}       Cache key.
     */
    function getModuleByInstanceCacheKey(id, module) {
        return 'mmCourse:moduleByInstance:' + module + ':' + id;
    }

    /**
     * Get cache key for module WS calls.
     *
     * @param {Number} moduleid Module ID.
     * @return {String}         Cache key.
     */
    function getModuleCacheKey(moduleid) {
        return 'mmCourse:module:' + moduleid;
    }

    /**
     * Returns the source to a module icon.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleIconSrc
     * @param {String} moduleName The module name.
     * @return {String} The IMG src.
     */
    self.getModuleIconSrc = function(moduleName) {
        if (mods.indexOf(moduleName) < 0) {
            moduleName = "external-tool";
        }

        return "img/mod/" + moduleName + ".svg";
    };

    /**
     * Get the section ID a module belongs to.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleSectionId
     * @param {Number} moduleId   The module ID.
     * @param {Number} [courseId] The course ID. Required if Moodle site is prior to 3.0.
     * @param {String} [siteId]   Site ID. If not defined, current site.
     * @return {Promise}
     */
    self.getModuleSectionId = function(moduleId, courseId, siteId) {

        if (!moduleId) {
            return $q.reject();
        }

        // Try to get the section using getModuleBasicInfo.
        return self.getModuleBasicInfo(moduleId, siteId).then(function(module) {
            return module.section;
        }).catch(function() {
            if (!courseId) {
                // It failed and we don't have courseId, reject.
                return $q.reject();
            }

            // Get all the sections in the course and iterate over them to find it.
            return self.getSections(courseId, {}, siteId).then(function(sections) {
                sections.forEach(function(section) {
                    section.modules.forEach(function(module) {
                        if (module.id == moduleId) {
                            return section.id;
                        }
                    });
                });
                // Not found.
                return $q.reject();
            });
        });
    };

    /**
     * Return a specific section.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getSection
     * @param {Number} courseid The course ID.
     * @param {Number} sectionid The section ID.
     * @return {Promise} The reject contains the error message, else contains the section.
     */
    self.getSection = function(courseid, sectionid) {
        var deferred = $q.defer();

        if (sectionid < 0) {
            deferred.reject('Invalid section ID');
            return deferred.promise;
        }

        self.getSections(courseid).then(function(sections) {
            for (var i = 0; i < sections.length; i++) {
                if (sections[i].id == sectionid) {
                    deferred.resolve(sections[i]);
                    return;
                }
            }
            deferred.reject('Unkown section');
        }, function(error) {
            deferred.reject(error);
        });

        return deferred.promise;
    };

    /**
     * Get the course sections.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getSections
     * @param {Number} courseid  The course ID.
     * @param {Object} [preSets] Optional. Presets to use.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise} The reject contains the error message, else contains the sections.
     */
    self.getSections = function(courseid, preSets, siteId) {
        preSets = preSets || {};
        siteId = siteId || $mmSite.getId();
        preSets.cacheKey = getSectionsCacheKey(courseid);

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.read('core_course_get_contents', {
                courseid: courseid,
                options: []
            }, preSets).then(function(sections) {
                angular.forEach(sections, function(section) {
                    angular.forEach(section.modules, function(module) {
                        addContentsIfNeeded(module);
                    });
                });
                return sections;
            });
        });
    };

    /**
     * Get cache key for section WS call.
     *
     * @param  {Number} courseid Course ID.
     * @return {String}          Cache key.
     */
    function getSectionsCacheKey(courseid) {
        return 'mmCourse:sections:' + courseid;
    }

    /**
     * Invalidates module WS call.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#invalidateModule
     * @param {Number} moduleid Module ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateModule = function(moduleid) {
        return $mmSite.invalidateWsCacheForKey(getModuleCacheKey(moduleid));
    };

    /**
     * Invalidates module WS call.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#invalidateModuleByInstance
     * @param {Number} id     Instance ID.
     * @param {String} module Name of the module. E.g. 'glossary'.
     * @return {Promise}      Promise resolved when the data is invalidated.
     */
    self.invalidateModuleByInstance = function(id, module) {
        return $mmSite.invalidateWsCacheForKey(getModuleByInstanceCacheKey(id, module));
    };

    /**
     * Invalidates sections WS call.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#invalidateSections
     * @param {Number} courseid  Course ID.
     * @param  {Number} [userid] User ID. If not defined, current user.
     * @return {Promise}         Promise resolved when the data is invalidated.
     */
    self.invalidateSections = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();

        var p1 = $mmSite.invalidateWsCacheForKey(getSectionsCacheKey(courseid)),
            p2 = $mmSite.invalidateWsCacheForKey(getActivitiesCompletionCacheKey(courseid, userid));
        return $q.all([p1, p2]);
    };

    /**
     * Translate a module name to current language.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#translateModuleName
     * @param {String} moduleName The module name.
     * @return {Promise}          Promise resolved with the translated name.
     */
    self.translateModuleName = function(moduleName) {
        if (mods.indexOf(moduleName) < 0) {
            moduleName = "external-tool";
        }

        var langkey = 'mm.core.mod_'+moduleName;
        return $translate(langkey).then(function(translated) {
            return translated !== langkey ? translated : moduleName;
        });
    };


    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Courses nav handler.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseCoursesNavHandler
 */
.factory('$mmCourseCoursesNavHandler', function() {
    return {

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        isEnabled: function() {
            return true;
        },

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean}          True if handler is enabled, false otherwise.
         */
        isEnabledForCourse: function() {
            return true;
        },

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        getController: function(courseId) {
            return function($scope, $state) {
                $scope.icon = 'ion-briefcase';
                $scope.title = 'mm.course.contents';

                $scope.action = function(e, course) {
                    $state.go('site.mm_course', {courseid: course.id});
                    e.preventDefault();
                    e.stopPropagation();
                };
            };
        }
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Delegate to register content handlers.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseDelegate
 * @description
 *
 * To register a content handler:
 *
 * .config($mmCourseDelegate, function() {
 *     $mmCourseDelegate.registerContentHandler('mmaYourAddon', 'moduleName', 'handlerName');
 *     $mmCourseDelegate.registerContentHandler('mmaModPage', 'page', '$mmaModPageCourseContentHandler');
 * })
 *
 * The content handler must provide two methods.
 *
 * 1/ isEnabled() which will be called once in a while to check if the plugin works on the current site.
 * 2/ getController(module, courseid) which should return a controller object
 *
 * The controller has its own scope inheriting the parent one. Though you should not use the
 * parent scope. To find out more what scope variables are expected look at the template
 * core/components/course/templates/section.html and at existing content handlers.
 */
.provider('$mmCourseDelegate', function() {
    var contentHandlers = {},
        self = {};

    /**
     * Register a content handler. If module is not supported in current site, handler should return undefined.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseDelegate#registerContentHandler
     * @param {String} addon The addon's name (mmaLabel, mmaForum, ...)
     * @param {String} handles The module this handler handles, e.g. forum, label. This value will be compared with
     *                         the value contained in module.modname from the Webservice core_course_get_contents.
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean) Whether or not the handler is enabled on a site level.
     *                             - getController(module, courseid) (Function) Returns the function that will act as controller.
     *                                                                See core/components/course/templates/section.html
     *                                                                for the list of scope variables expected.
     */
    self.registerContentHandler = function(addon, handles, handler) {
        if (typeof contentHandlers[handles] !== 'undefined') {
            console.log("$mmCourseDelegateProvider: Addon '" + contentHandlers[handles].addon + "' already registered as handler for '" + handles + "'");
            return false;
        }
        console.log("$mmCourseDelegateProvider: Registered addon '" + addon + "' as course content handler.");
        contentHandlers[handles] = {
            addon: addon,
            handler: handler,
            instance: undefined
        };
        return true;
    };

    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", "$mmCourseContentHandler", function($q, $log, $mmSite, $mmUtil, $mmCourseContentHandler) {
        var enabledHandlers = {},
            self = {};

        $log = $log.getInstance('$mmCourseDelegate');

        /**
         * Get the controller a content handler provides.
         *
         * This will first get the default data, then call the handler if any and override
         * the default data with the new data from the handler. That means that a handler
         * should always override any existing attribute if they want to change the defaults.
         *
         * @module mm.core.course
         * @ngdoc method
         * @name $mmCourseDelegate#getContentHandlerControllerFor
         * @param {String} handles   The module to work on
         * @param {Object} module    The module data
         * @param {Number} courseid  The course ID.
         * @param {Number} sectionid The section ID.
         * @return {Object}
         */
        self.getContentHandlerControllerFor = function(handles, module, courseid, sectionid) {
            if (typeof enabledHandlers[handles] !== 'undefined') {
                return enabledHandlers[handles].getController(module, courseid, sectionid);
            }
            return $mmCourseContentHandler.getController(module, courseid, sectionid);
        };

        /**
         * Update the enabled handlers for the current site.
         *
         * @module mm.core.course
         * @ngdoc method
         * @name $mmCourseDelegate#updateContentHandler
         * @param {String} handles The module this handler handles, e.g. forum, label. This value will be compared with
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateContentHandler = function(handles, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledHandlers[handles] = handlerInfo.instance;
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledHandlers[handles];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core.course
         * @ngdoc method
         * @name $mmCourseDelegate#updateContentHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateContentHandlers = function() {
            var promises = [],
                enabledHandlers = {};

            $log.debug('Updating content handlers for current site.');

            // Loop over all the content handlers.
            angular.forEach(contentHandlers, function(handlerInfo, handles) {
                promises.push(self.updateContentHandler(handles, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            });
        };

        return self;
    }];


    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Helper to gather some common course functions.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseHelper
 */
.factory('$mmCourseHelper', ["$q", "$mmCoursePrefetchDelegate", "$mmFilepool", "$mmUtil", "$mmCourse", "$mmSite", "$state", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreDownloading", "mmCoreCourseAllSectionsId", function($q, $mmCoursePrefetchDelegate, $mmFilepool, $mmUtil, $mmCourse, $mmSite, $state,
            mmCoreNotDownloaded, mmCoreOutdated, mmCoreDownloading, mmCoreCourseAllSectionsId) {

    var self = {};

    /**
     * Calculate the status of a section.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#calculateSectionStatus
     * @param {Object[]} section          Section to calculate its status. Can't be "All sections".
     * @param  {Number} courseid          Course ID the section belongs to.
     * @param {Boolean} restoreDownloads  True if it should restore downloads. It will try to restore this section downloads.
     * @param {Boolean} refresh           True if it shouldn't use module status cache (slower).
     * @param {Promise[]} [dwnpromises]   If section download is restored, a promise will be added to this array. Required
     *                                    if restoreDownloads=true.
     * @return {Promise}         Promise resolved when the state is calculated.
     */
    self.calculateSectionStatus = function(section, courseid, restoreDownloads, refresh, dwnpromises) {

        if (section.id !== mmCoreCourseAllSectionsId) {
            // Get the status of this section.
            return $mmCoursePrefetchDelegate.getModulesStatus(section.id, section.modules, courseid, refresh, restoreDownloads)
                    .then(function(result) {

                // Check if it's being downloaded. We can't trust status 100% because downloaded books are always outdated.
                var downloadid = self.getSectionDownloadId(section);
                if ($mmCoursePrefetchDelegate.isBeingDownloaded(downloadid)) {
                    result.status = mmCoreDownloading;
                }

                // Set this section data.
                section.showDownload = result.status === mmCoreNotDownloaded;
                section.showRefresh = result.status === mmCoreOutdated;

                if (result.status !== mmCoreDownloading) {
                    section.isDownloading = false;
                    section.total = 0;
                } else if (!restoreDownloads) {
                    // Set download data.
                    section.count = 0;
                    section.total = result[mmCoreOutdated].length + result[mmCoreNotDownloaded].length +
                                    result[mmCoreDownloading].length;
                    section.isDownloading = true;
                } else {
                    // Restore or re-start the prefetch.
                    var promise = self.startOrRestorePrefetch(section, result, courseid).then(function() {
                        // Re-calculate the status of this section once finished.
                        return self.calculateSectionStatus(section, courseid);
                    });
                    if (dwnpromises) {
                        dwnpromises.push(promise);
                    }
                }

                return result;
            });
        }
        return $q.reject();
    };

    /**
     * Calculate the status of a list of sections, setting attributes to determine the icons/data to be shown.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#calculateSectionsStatus
     * @param {Object[]} sections         Sections to calculate their status.
     * @param  {Number} courseid          Course ID the sections belong to.
     * @param {Boolean} restoreDownloads  True if it should restore downloads. It will try to restore section downloads
     * @param {Boolean} refresh           True if it shouldn't use module status cache (slower).
     * @return {Promise}                  Promise resolved when the states are calculated. Returns an array of download promises
     *                                    with the restored downloads (only if restoreDownloads=true).
     */
    self.calculateSectionsStatus = function(sections, courseid, restoreDownloads, refresh) {

        var allsectionssection,
            allsectionsstatus,
            downloadpromises = [],
            statuspromises = [];

        angular.forEach(sections, function(section) {
            if (section.id === mmCoreCourseAllSectionsId) {
                // "All sections" section status is calculated using the status of the rest of sections.
                allsectionssection = section;
            } else {
                statuspromises.push(self.calculateSectionStatus(section, courseid, restoreDownloads, refresh, downloadpromises)
                        .then(function(result) {

                    // Calculate "All sections" status.
                    allsectionsstatus = $mmFilepool.determinePackagesStatus(allsectionsstatus, result.status);
                }));
            }
        });

        return $q.all(statuspromises).then(function() {
            if (allsectionssection) {
                // Set "All sections" data.
                allsectionssection.showDownload = allsectionsstatus === mmCoreNotDownloaded;
                allsectionssection.showRefresh = allsectionsstatus === mmCoreOutdated;
                allsectionssection.isDownloading = allsectionsstatus === mmCoreDownloading;
            }
            return downloadpromises;
        });
    };

    /**
     * Calculate the size of the download and show a confirm modal if needed.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#confirmDownloadSize
     * @param {Number} courseid   Course ID the section belongs to.
     * @param {Object} section    Section.
     * @param {Object[]} sections List of sections. Used when downloading all the sections.
     * @return {Promise}          Promise resolved if the user confirms or there's no need to confirm.
     */
    self.confirmDownloadSize = function(courseid, section, sections) {
        var sizePromise;

        // Calculate the size of the download.
        if (section.id != mmCoreCourseAllSectionsId) {
            sizePromise = $mmCoursePrefetchDelegate.getDownloadSize(section.modules, courseid);
        } else {
            var promises = [],
                size = 0;
            angular.forEach(sections, function(s) {
                if (s.id != mmCoreCourseAllSectionsId) {
                    promises.push($mmCoursePrefetchDelegate.getDownloadSize(s.modules, courseid).then(function(sectionsize) {
                        size = size + sectionsize;
                    }));
                }
            });
            sizePromise = $q.all(promises).then(function() {
                return size;
            });
        }

        return sizePromise.then(function(size) {
            // Show confirm modal if needed.
            return $mmUtil.confirmDownloadSize(size);
        });
    };

    /**
     * Get the course ID from a module, showing an error message if it can't be retrieved.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#getModuleCourseId
     * @param {Number} id        Instance ID.
     * @param {String} module    Name of the module. E.g. 'glossary'.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the module's course ID.
     */
    self.getModuleCourseIdByInstance = function(id, module, siteId) {
        return $mmCourse.getModuleBasicInfoByInstance(id, module, siteId).then(function(cm) {
            return cm.course;
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.errorgetmodule', true);
            }
            return $q.reject();
        });
    };

    /**
     * Get the download ID of a section. It's used to interact with $mmCoursePrefetchDelegate.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#getSectionDownloadId
     * @param {Object} section Section.
     * @return {String}        Section download ID.
     */
    self.getSectionDownloadId = function(section) {
        return 'Section-'+section.id;
    };

    /**
     * Retrieves the courseId of the module and navigates to it.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#navigateToModule
     * @param  {Number} moduleId    Module's ID.
     * @param  {String} [siteId]    Site ID. If not defined, current site.
     * @param  {Number} [courseId]  Course ID. If not defined we'll try to retrieve it from the site.
     * @param  {Number} [sectionId] Section the module belongs to. If not defined we'll try to retrieve it from the site.
     * @return {Promise}            Promise resolved when the state changes.
     */
    self.navigateToModule = function(moduleId, siteId, courseId, sectionId) {
        siteId = siteId || $mmSite.getId();
        var modal = $mmUtil.showModalLoading(),
            promise;

        return $mmCourse.canGetModuleWithoutCourseId(siteId).then(function(enabled) {
            if (courseId && sectionId) {
                // No need to retrieve more data.
                promise = $q.when();
            } else if (!courseId && !enabled) {
                // We don't have enough data and we can't retrieve it.
                promise = $q.reject();
            } else if (!courseId) {
                // We don't have courseId but WS is enabled.
                promise = $mmCourse.getModuleBasicInfo(moduleId, siteId).then(function(module) {
                    courseId = module.course;
                    sectionId = module.section;
                });
            } else {
                // We don't have sectionId but we have courseId.
                promise = $mmCourse.getModuleSectionId(moduleId, courseId, siteId).then(function(id) {
                    sectionId = id;
                });
            }

            return promise.then(function() {
                return $state.go('redirect', {
                    siteid: siteId,
                    state: 'site.mm_course',
                    params: {
                        courseid: courseId,
                        moduleid: moduleId,
                        sid: sectionId
                    }
                });
            });
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.errorgetmodule', true);
            }
            return $q.reject();
        }).finally(function() {
            modal.dismiss();
        });
    };

    /**
     * Prefetch or restore the prefetch of one section or all the sections.
     * If the section is "All sections" it will prefetch all the sections.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#prefetch
     * @param  {Object} section    Section.
     * @param  {Number} courseid   Course ID the section belongs to.
     * @param  {Object[]} sections List of sections. Used when downloading all the sections.
     * @return {promise}           Promise resolved when the prefetch is finished.
     */
    self.prefetch = function(section, courseid, sections) {

        if (section.id != mmCoreCourseAllSectionsId) {
            // Download only this section.
            return self.prefetchSection(section, courseid, true, sections);
        } else {
            // Download all the sections except "All sections".
            // In case of a failure, we want that ALL promises have finished before rejecting the promise.
            var promises = [];

            section.isDownloading = true;
            angular.forEach(sections, function(s) {
                if (s.id != mmCoreCourseAllSectionsId) {
                    promises.push(self.prefetchSection(s, courseid, false, sections).then(function() {
                        // Calculate only the section that finished.
                        return self.calculateSectionStatus(s, courseid);
                    }));
                }
            });

            return $mmUtil.allPromises(promises);
        }
    };

    /**
     * Prefetch or restore the prefetch of a certain section if it needs to be prefetched.
     * If the section is "All sections" it will be ignored.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#prefetchSection
     * @param  {Object} section         Section to prefetch.
     * @param  {Number} courseid        Course ID the section belongs to.
     * @param  {Boolean} singleDownload True if user is only downloading this section, false if user is downloading all sections.
     * @param {Object[]} [sections]     List of sections. Used only if singleDownload is true.
     * @return {Promise}                Promise resolved when the section is prefetched.
     */
    self.prefetchSection = function(section, courseid, singleDownload, sections) {

        if (section.id == mmCoreCourseAllSectionsId) {
            return $q.when();
        }

        section.isDownloading = true;

        // Validate the section needs to be downloaded and calculate amount of modules that need to be downloaded.
        return $mmCoursePrefetchDelegate.getModulesStatus(section.id, section.modules, courseid).then(function(result) {
            if (result.status === mmCoreNotDownloaded || result.status === mmCoreOutdated || result.status === mmCoreDownloading) {
                var promise = self.startOrRestorePrefetch(section, result, courseid);
                if (singleDownload) {
                    // Re-calculate status to determine the right status for the "All sections" section.
                    self.calculateSectionsStatus(sections, courseid, false);
                }
                return promise;
            }
        }, function() {
            // This shouldn't happen.
            section.isDownloading = false;
            return $q.reject();
        });
    };

    /**
     * Start or restore the prefetch of a section.
     * If the section is "All sections" it will be ignored.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#startOrRestorePrefetch
     * @param {Object} section Section to download.
     * @param {Object} status  Result of $mmCoursePrefetchDelegate#getModulesStatus for this section.
     * @return {Promise}       Promise resolved when the section has been prefetched.
     */
    self.startOrRestorePrefetch = function(section, status, courseid) {

        if (section.id == mmCoreCourseAllSectionsId) {
            return $q.when();
        }

        // We only download modules with status notdownloaded, downloading or outdated.
        var modules = status[mmCoreOutdated].concat(status[mmCoreNotDownloaded]).concat(status[mmCoreDownloading]),
            downloadid = self.getSectionDownloadId(section),
            moduleids;

        moduleids = modules.map(function(m) {
            return m.id;
        });

        // Set download data.
        section.count = 0;
        section.total = modules.length;
        section.isDownloading = true;

        // We prefetch all the modules to prevent incoeherences in the download count
        // and also to download stale data that might not be marked as outdated.
        return $mmCoursePrefetchDelegate.prefetchAll(downloadid, modules, courseid).then(function() {}, function() {
            // Return a rejected promise so errors are handled outside of this function.
            return $q.reject();
        }, function(id) {
            // Progress. Check that the module downloaded is one of the expected ones.
            var index = moduleids.indexOf(id);
            if (index > -1) {
                // It's one of the modules we were expecting to download.
                moduleids.splice(index, 1);
                section.count++;
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Delegate to register prefetch handlers.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmCoursePrefetchDelegate
 * @description
 *
 * To register a prefetch handler:
 *
 * .config(function($mmCoursePrefetchDelegateProvider) {
 *     $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaYourAddon', 'moduleName', 'handlerName');
 * })
 *
 * To see the methods that must provide the prefetch handler see {@link $mmCoursePrefetchDelegateProvider#registerPrefetchHandler}.
 */
.provider('$mmCoursePrefetchDelegate', function() {
    var prefetchHandlers = {},
        self = {};

    /**
     * Register a prefetch handler.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmCoursePrefetchDelegateProvider#registerPrefetchHandler
     * @param {String} addon The addon's name (mmaLabel, mmaForum, ...)
     * @param {String} handles The module this handler handles, e.g. forum, label.
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these properties. See {@link $mmUtil#resolveObject}.
     *                             - component (String) Handler's component.
     *                             - getDownloadSize(module, courseid) (Number|Promise) Get the download size of a module.
     *                             - isEnabled() (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                             - prefetch(module, courseid) (Promise) Prefetches a module.
     *                             - (Optional) getFiles(module, courseid) (Object[]|Promise) Get list of files. If not defined,
     *                                                                      we'll assume they're in module.contents.
     *                             - (Optional) determineStatus(status) (String) Returns status to show based on current. E.g. for
     *                                                                 books we'll show "outdated" even if state is "downloaded".
     *                             - (Optional) getRevision(module, courseid) (String|Number|Promise) Returns the module revision.
     *                                                                 If not defined we'll calculate it using module files.
     *                             - (Optional) getTimemodified(module, courseid) (Number|Promise) Returns the module timemodified.
     *                                                                 If not defined we'll calculate it using module files.
     */
    self.registerPrefetchHandler = function(addon, handles, handler) {
        if (typeof prefetchHandlers[handles] !== 'undefined') {
            console.log("$mmCoursePrefetchDelegateProvider: Addon '" + prefetchHandlers[handles].addon +
                            "' already registered as handler for '" + handles + "'");
            return false;
        }
        console.log("$mmCoursePrefetchDelegateProvider: Registered addon '" + addon + "' as prefetch handler.");
        prefetchHandlers[handles] = {
            addon: addon,
            handler: handler,
            instance: undefined
        };
        return true;
    };

    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", "$mmFilepool", "$mmEvents", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreNotDownloadable", "mmCoreEventSectionStatusChanged", function($q, $log, $mmSite, $mmUtil, $mmFilepool, $mmEvents, mmCoreDownloaded, mmCoreDownloading,
                mmCoreNotDownloaded, mmCoreOutdated, mmCoreNotDownloadable, mmCoreEventSectionStatusChanged) {
        var enabledHandlers = {},
            self = {},
            deferreds = {},
            statusCache = {}; // To speed up the getModulesStatus function.

        $log = $log.getInstance('$mmCoursePrefetchDelegate');

        /**
         * Clear the status cache (memory object).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#clearStatusCache
         * @return {Void}
         */
        self.clearStatusCache = function() {
            statusCache = {};
        };

        /**
         * Determines a module status based on current status, restoring downloads if needed.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#determineModuleStatus
         * @param  {Object} module           Module.
         * @param  {String} status           Current status.
         * @param {Boolean} restoreDownloads True if it should restore downloads if needed.
         * @return {String}                  Module status.
         */
        self.determineModuleStatus = function(module, status, restoreDownloads) {
            var handler = enabledHandlers[module.modname];

            if (handler) {
                if (status == mmCoreDownloading && restoreDownloads) {
                    // Check if the download is being handled.
                    if (!$mmFilepool.getPackageDownloadPromise($mmSite.getId(), handler.component, module.id)) {
                        // Not handled, the app was probably restarted or something weird happened.
                        // Re-start download (files already on queue or already downloaded will be skipped).
                        handler.prefetch(module);
                    }
                } else if (handler.determineStatus) {
                    // The handler implements a determineStatus function. Apply it.
                    return handler.determineStatus(status);
                }
            }
            return status;
        };

        /**
         * Get modules download size. Only treat the modules with status not downloaded or outdated.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getDownloadSize
         * @param  {Object[]} modules List of modules.
         * @param  {Number} courseid  Course ID the modules belong to.
         * @return {Promise}          Promise resolved with the download size.
         */
        self.getDownloadSize = function(modules, courseid) {
            var size = 0,
                promises = [];

            angular.forEach(modules, function(module) {
                // Prevent null contents.
                module.contents = module.contents || [];

                // Check if the module has a prefetch handler.
                var handler = enabledHandlers[module.modname];
                if (handler) {
                    // Check if the file will be downloaded.
                    promises.push(self.getModuleStatus(module, courseid).then(function(modstatus) {
                        if (modstatus === mmCoreNotDownloaded || modstatus === mmCoreOutdated) {
                            return $q.when(handler.getDownloadSize(module, courseid)).then(function(modulesize) {
                                // Add the size of the downloadable files.
                                size = size + modulesize;
                            }).catch(function() {
                                // Ignore errors.
                            });
                        }
                    }));
                }
            });

            return $q.all(promises).then(function() {
                return size;
            });
        };

        /**
         * Get the module status.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getModuleStatus
         * @param {Object} module         Module.
         * @param {Number} courseid       Course ID the module belongs to.
         * @param {Number} [revision]     Module's revision. If not defined, it will be calculated using module data.
         * @param {Number} [timemodified] Module's timemodified. If not defined, it will be calculated using module data.
         * @return {Promise}              Promise resolved with the status.
         */
        self.getModuleStatus = function(module, courseid, revision, timemodified) {
            var handler = enabledHandlers[module.modname],
                siteid = $mmSite.getId();
            module.contents = module.contents || [];

            if (handler) {
                // If the handler doesn't define a function to get the files, use module.contents.
                var promise = handler.getFiles ? $q.when(handler.getFiles(module, courseid)) : $q.when(module.contents);

                return promise.then(function(files) {

                    if (files.length === 0) { // No files, treat is as downloaded.
                        return $q.when(mmCoreDownloaded);
                    }

                    // Get revision and timemodified if they aren't defined.
                    // If handler doesn't define a function to get them, get them from file list.
                    var promises = [];

                    if (typeof revision == 'undefined') {
                        if (handler.getRevision) {
                            promises.push($q.when(handler.getRevision(module, courseid)).then(function(rev) {
                                revision = rev;
                            }));
                        } else {
                            revision = $mmFilepool.getRevisionFromFileList(files);
                        }
                    }

                    if (typeof timemodified == 'undefined') {
                        if (handler.getTimemodified) {
                            promises.push($q.when(handler.getTimemodified(module, courseid)).then(function(timemod) {
                                timemodified = timemod;
                            }));
                        } else {
                            timemodified = $mmFilepool.getTimemodifiedFromFileList(files);
                        }
                    }

                    return $q.all(promises).then(function() {
                        // Now get the status.
                        return $mmFilepool.getPackageStatus(siteid, handler.component, module.id, revision, timemodified)
                                .then(function(status) {
                            return self.determineModuleStatus(module, status, true);
                        });
                    });
                });
            }

            return $q.reject();
        };

        /**
         * Get the status of a list of modules, along with the lists of modules for each status.
         * @see {@link $mmFilepool#determinePackagesStatus}
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getModulesStatus
         * @param  {String} sectionid         ID of the section the modules belong to.
         * @param  {Object[]} modules         List of modules to prefetch.
         * @param  {Number} courseid          Course ID the modules belong to.
         * @param  {Boolean} refresh          True if it should always check the DB (slower).
         * @param {Boolean} restoreDownloads  True if it should restore downloads. It's only used if refresh=false,
         *                                    if refresh=true then it always tries to restore downloads.
         * @return {Promise}                  Promise resolved with an object with the following properties:
         *                                            - status (String) Status of the module.
         *                                            - total (Number) Number of modules.
         *                                            - mmCoreNotDownloaded (Object[]) Modules with state mmCoreNotDownloaded.
         *                                            - mmCoreDownloaded (Object[]) Modules with state mmCoreDownloaded.
         *                                            - mmCoreDownloading (Object[]) Modules with state mmCoreDownloading.
         *                                            - mmCoreOutdated (Object[]) Modules with state mmCoreOutdated.
         */
        self.getModulesStatus = function(sectionid, modules, courseid, refresh, restoreDownloads) {

            var promises = [],
                status = mmCoreNotDownloadable,
                result = {};

            // Init result.
            result[mmCoreNotDownloaded] = [];
            result[mmCoreDownloaded] = [];
            result[mmCoreDownloading] = [];
            result[mmCoreOutdated] = [];
            result.total = 0;

            angular.forEach(modules, function(module) {
                // Check if the module has a prefetch handler.
                var handler = enabledHandlers[module.modname],
                    promise;
                // Prevent null contents.
                module.contents = module.contents || [];

                if (handler) {
                    var packageId = $mmFilepool.getPackageId(handler.component, module.id);
                    if (!refresh && statusCache[packageId] && statusCache[packageId].status) {
                        promise = $q.when(self.determineModuleStatus(module, statusCache[packageId].status, restoreDownloads));
                    } else {
                        promise = self.getModuleStatus(module, courseid);
                    }

                    promises.push(promise.then(function(modstatus) {
                        // Update status cache.
                        statusCache[packageId] = {
                            status: modstatus,
                            sectionid: sectionid
                        };
                        status = $mmFilepool.determinePackagesStatus(status, modstatus);
                        result[modstatus].push(module);
                        result.total++;
                    }));
                }
            });

            return $q.all(promises).then(function() {
                result.status = status;
                return result;
            });
        };

        /**
         * Get a prefetch handler.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getPrefetchHandlerFor
         * @param {String} handles The module to work on.
         * @return {Object}        Prefetch handler.
         */
        self.getPrefetchHandlerFor = function(handles) {
            return enabledHandlers[handles];
        };

        /**
         * Check if a list of modules is being downloaded.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#isBeingDownloaded
         * @param  {String} id An ID to identify the download.
         * @return {Boolean}   True if it's being downloaded, false otherwise.
         */
        self.isBeingDownloaded = function(id) {
            return deferreds[$mmSite.getId()] && deferreds[$mmSite.getId()][id];
        };

        /**
         * Prefetches a list of modules using their prefetch handlers.
         * If a prefetch already exists for this site and id, returns the current promise.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getPrefetchHandlerFor
         * @param  {String} siteid    Site ID.
         * @param  {String} id        An ID to identify the download. It can be used to retrieve the download promise.
         * @param  {Object[]} modules List of modules to prefetch.
         * @param  {Number} courseid  Course ID the modules belong to.
         * @return {Promise}          Promise resolved when all modules have been prefetched. Notify is called everytime
         *                            a module is prefetched, passing the module id as param.
         */
        self.prefetchAll = function(id, modules, courseid) {

            var siteid = $mmSite.getId();

            if (deferreds[siteid] && deferreds[siteid][id]) {
                // There's a prefetch ongoing, return the current promise.
                return deferreds[siteid][id].promise;
            }

            var deferred = $q.defer(),
                promises = [];

            // Store the deferred.
            if (!deferreds[siteid]) {
                deferreds[siteid] = {};
            }
            deferreds[siteid][id] = deferred;

            angular.forEach(modules, function(module) {
                // Prevent null contents.
                module.contents = module.contents || [];

                // Check if the module has a prefetch handler.
                var handler = enabledHandlers[module.modname];
                if (handler) {
                    promises.push(handler.prefetch(module, courseid).then(function() {
                        deferred.notify(module.id);
                    }));
                }
            });

            $q.all(promises).then(function() {
                delete deferreds[siteid][id]; // Remove from array before resolving.
                deferred.resolve();
            }, function() {
                delete deferreds[siteid][id]; // Remove from array before rejecting.
                deferred.reject();
            });

            return deferred.promise;
        };

        /**
         * Update the enabled handlers for the current site.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#updatePrefetchHandler
         * @param {String} handles The module this handler handles, e.g. forum, label.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updatePrefetchHandler = function(handles, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the prefetch is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledHandlers[handles] = handlerInfo.instance;
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledHandlers[handles];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#updatePrefetchHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updatePrefetchHandlers = function() {
            var promises = [];

            $log.debug('Updating prefetch handlers for current site.');

            // Loop over all the prefetch handlers.
            angular.forEach(prefetchHandlers, function(handlerInfo, handles) {
                promises.push(self.updatePrefetchHandler(handles, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            });
        };

        /**
         * Update the status of a module in the "cache".
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#updateStatusCache
         * @return {Void}
         */
        self.updateStatusCache = function(component, componentId, status) {
            var notify = false,
                packageid = $mmFilepool.getPackageId(component, componentId);

            if (statusCache[packageid]) {
                // If the status has changed, notify that the section has changed.
                notify = statusCache[packageid].status !== status;
            } else {
                statusCache[packageid] = {};
            }
            statusCache[packageid].status = status;

            if (notify) {
                $mmEvents.trigger(mmCoreEventSectionStatusChanged, {
                    sectionid: statusCache[packageid].sectionid,
                    siteid: $mmSite.getId()
                });
            }
        };

        return self;
    }];


    return self;
})

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmCoursePrefetchDelegate", "$mmSite", "mmCoreEventPackageStatusChanged", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmCoursePrefetchDelegate, $mmSite,
            mmCoreEventPackageStatusChanged) {
    $mmEvents.on(mmCoreEventLogin, $mmCoursePrefetchDelegate.updatePrefetchHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCoursePrefetchDelegate.updatePrefetchHandlers);
    $mmEvents.on(mmCoreEventLogout, $mmCoursePrefetchDelegate.clearStatusCache);
    $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
        if (data.siteid === $mmSite.getId()) {
            $mmCoursePrefetchDelegate.updateStatusCache(data.component, data.componentId, data.status);
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar', [])

.constant('mmaCalendarDaysInterval', 30)
.constant('mmaCalendarDefaultNotifTime', 60)
.constant('mmaCalendarComponent', 'mmaCalendarEvents')
.constant('mmaCalendarPriority', 400)

.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaCalendarPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaCalendarPriority) {

    $stateProvider
        .state('site.calendar', {
            url: '/calendar',
            views: {
                'site': {
                    controller: 'mmaCalendarListCtrl',
                    templateUrl: 'addons/calendar/templates/list.html'
                }
            },
            params: {
                eventid: null,
                clear: false
            }
        })

        .state('site.calendar-event', {
            url: '/calendar-event/:id', // We need to add ID to the URL to make ng-href work.
            views: {
                'site': {
                    controller: 'mmaCalendarEventCtrl',
                    templateUrl: 'addons/calendar/templates/event.html'
                }
            }
        });

    // Register side menu addon.
    // FYI: Comment this out to disable from side menu
    $mmSideMenuDelegateProvider.registerNavHandler('mmaCalendar', '$mmaCalendarHandlers.sideMenuNav', mmaCalendarPriority);

}])

.run(["$mmaCalendar", "$mmLocalNotifications", "$state", "$ionicPlatform", "$mmApp", "mmaCalendarComponent", function($mmaCalendar, $mmLocalNotifications, $state, $ionicPlatform, $mmApp, mmaCalendarComponent) {

    // Listen for notification clicks.
    $mmLocalNotifications.registerClick(mmaCalendarComponent, function(data) {
        if (data.eventid) {
            $mmApp.ready().then(function() {
                $state.go('redirect', {siteid: data.siteid, state: 'site.calendar', params: {eventid: data.eventid}});
            });
        }
    });

    $ionicPlatform.ready(function() {
        $mmaCalendar.scheduleAllSitesEventsNotifications();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion', [])

.constant('mmaCourseCompletionPriority', 200)
.constant('mmaCourseCompletionViewCompletionPriority', 200)

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "mmaCourseCompletionPriority", "mmaCourseCompletionViewCompletionPriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, mmaCourseCompletionPriority,
            mmaCourseCompletionViewCompletionPriority) {

    $stateProvider

    .state('site.course-completion', {
        url: '/course-completion',
        views: {
            'site': {
                templateUrl: 'addons/coursecompletion/templates/report.html',
                controller: 'mmaCourseCompletionReportCtrl'
            }
        },
        params: {
            course: null,
            userid: null
        }
    });

    // Register plugin on user profile.
    $mmUserDelegateProvider.registerProfileHandler('mmaCourseCompletion:viewCompletion',
            '$mmaCourseCompletionHandlers.viewCompletion', mmaCourseCompletionViewCompletionPriority);

    // Register courses handler.
    $mmCoursesDelegateProvider.registerNavHandler('mmaCourseCompletion',
            '$mmaCourseCompletionHandlers.coursesNav', mmaCourseCompletionPriority);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files', ['mm.core'])

.constant('mmaFilesUploadStateName', 'site.files-upload')
.constant('mmaFilesSharedFilesStore', 'shared_files')
.constant('mmaFilesMyComponent', 'mmaFilesMy')
.constant('mmaFilesSiteComponent', 'mmaFilesSite')
.constant('mmaFilesPriority', 200)

.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaFilesUploadStateName", "mmaFilesPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaFilesUploadStateName, mmaFilesPriority) {

    $stateProvider
        .state('site.files', {
            url: '/files',
            views: {
                'site': {
                    controller: 'mmaFilesIndexController',
                    templateUrl: 'addons/files/templates/index.html'
                }
            }
        })

        .state('site.files-list', {
            url: '/list',
            params: {
                path: false,
                root: false,
                title: false
            },
            views: {
                'site': {
                    controller: 'mmaFilesListController',
                    templateUrl: 'addons/files/templates/list.html'
                }
            }
        })

        .state(mmaFilesUploadStateName, {
            url: '/upload',
            params: {
                path: false,
                root: false
            },
            views: {
                'site': {
                    controller: 'mmaFilesUploadCtrl',
                    templateUrl: 'addons/files/templates/upload.html'
                }
            }
        })

        .state('site.files-choose-site', {
            url: '/choose-site',
            params: {
                file: null
            },
            views: {
                'site': {
                    controller: 'mmaFilesChooseSiteCtrl',
                    templateUrl: 'addons/files/templates/choosesite.html'
                }
            }
        });

    // Register side menu addon.
    $mmSideMenuDelegateProvider.registerNavHandler('mmaFiles', '$mmaFilesHandlers.sideMenuNav', mmaFilesPriority);

}])

.run(["$mmaFiles", "$state", "$mmSitesManager", "$mmUtil", "$mmaFilesHelper", "$ionicPlatform", "$mmApp", function($mmaFiles, $state, $mmSitesManager, $mmUtil, $mmaFilesHelper, $ionicPlatform, $mmApp) {

    // Search for new files shared with the upload (to upload).
    if (ionic.Platform.isIOS()) {
        // In iOS we need to manually check if there are new files in the app Inbox folder.
        function searchToUpload() {
            $mmApp.ready().then(function() {
                $mmaFiles.checkIOSNewFiles().then(function(fileEntry) {
                    $mmSitesManager.getSites().then(function(sites) {
                        if (sites.length == 0) {
                            $mmUtil.showErrorModal('mma.files.errorreceivefilenosites', true);
                        } else if (sites.length == 1) {
                            $mmaFilesHelper.showConfirmAndUploadInSite(fileEntry, sites[0].id);
                        } else {
                            $state.go('site.files-choose-site', {file: fileEntry});
                        }
                    });
                });
            });
        }
        // We want to check it at app start and when the app is resumed.
        $ionicPlatform.on('resume', searchToUpload);
        searchToUpload();
    }

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.frontpage', [])

.constant('mmaFrontpagePriority', 1000)

.config(["$mmSideMenuDelegateProvider", "mmaFrontpagePriority", function($mmSideMenuDelegateProvider, mmaFrontpagePriority) {
    // Register side menu addon.
    //$mmSideMenuDelegateProvider.registerNavHandler('mmaFrontpage', '$mmaFrontPageHandlers.sideMenuNav', mmaFrontpagePriority);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades', [])

.constant('mmaGradesPriority', 400)
.constant('mmaGradesViewGradesPriority', 400)

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "$mmContentLinksDelegateProvider", "mmaGradesPriority", "mmaGradesViewGradesPriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, $mmContentLinksDelegateProvider,
            mmaGradesPriority, mmaGradesViewGradesPriority) {

    $stateProvider

    .state('site.grades', {
        url: '/grades',
        views: {
            'site': {
                templateUrl: 'addons/grades/templates/table.html',
                controller: 'mmaGradesTableCtrl'
            }
        },
        params: {
            course: null,
            userid: null
        }
    });


    // Register plugin on user profile.
    $mmUserDelegateProvider.registerProfileHandler('mmaGrades:viewGrades', '$mmaGradesHandlers.viewGrades', mmaGradesViewGradesPriority);

    // Register courses content plugin.
    $mmCoursesDelegateProvider.registerNavHandler('mmaGrades', '$mmaGradesHandlers.coursesNav', mmaGradesPriority);

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaGrades', '$mmaGradesHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages', ['mm.core'])

.constant('mmaMessagesDiscussionLoadedEvent', 'mma_messages_discussion_loaded')
.constant('mmaMessagesDiscussionLeftEvent', 'mma_messages_discussion_left')
.constant('mmaMessagesPollInterval', 5000)
.constant('mmaMessagesPriority', 600)
.constant('mmaMessagesSendMessagePriority', 1000)
.constant('mmaMessagesAddContactPriority', 800)
.constant('mmaMessagesBlockContactPriority', 600)
.constant('mmaMessagesNewMessageEvent', 'mma-messages_new_message')

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmSideMenuDelegateProvider", "mmaMessagesSendMessagePriority", "mmaMessagesAddContactPriority", "mmaMessagesBlockContactPriority", "mmaMessagesPriority", "$mmContentLinksDelegateProvider", function($stateProvider, $mmUserDelegateProvider, $mmSideMenuDelegateProvider, mmaMessagesSendMessagePriority,
            mmaMessagesAddContactPriority, mmaMessagesBlockContactPriority, mmaMessagesPriority, $mmContentLinksDelegateProvider) {

    $stateProvider

    .state('site.messages', {
        url: '/messages',
        views: {
            'site': {
                templateUrl: 'addons/messages/templates/index.html',
                controller: 'mmaMessagesIndexCtrl'
            }
        }
    })

    .state('site.messages-discussion', {
        url: '/messages-discussion',
        params: {
            userId: null,
            userFullname: null
        },
        views: {
            'site': {
                templateUrl: 'addons/messages/templates/discussion.html',
                controller: 'mmaMessagesDiscussionCtrl'
            }
        }
    });

    // Register side menu addon.
    $mmSideMenuDelegateProvider.registerNavHandler('mmaMessages', '$mmaMessagesHandlers.sideMenuNav', mmaMessagesPriority);

    // Register user profile addons.
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:sendMessage', '$mmaMessagesHandlers.sendMessage', mmaMessagesSendMessagePriority);
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:addContact', '$mmaMessagesHandlers.addContact', mmaMessagesAddContactPriority);
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:blockContact', '$mmaMessagesHandlers.blockContact', mmaMessagesBlockContactPriority);

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaMessages', '$mmaMessagesHandlers.linksHandler');
}])

.run(["$mmaMessages", "$mmEvents", "$state", "$mmAddonManager", "$mmUtil", "mmCoreEventLogin", function($mmaMessages, $mmEvents, $state, $mmAddonManager, $mmUtil, mmCoreEventLogin) {

    // Invalidate messaging enabled WS calls.
    $mmEvents.on(mmCoreEventLogin, function() {
        $mmaMessages.invalidateEnabledCache();
    });

    // Register push notification clicks.
    var $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate');
    if ($mmPushNotificationsDelegate) {
        $mmPushNotificationsDelegate.registerHandler('mmaMessages', function(notification) {
            if ($mmUtil.isFalseOrZero(notification.notif)) {
                $mmaMessages.isMessagingEnabledForSite(notification.site).then(function() {
                    $mmaMessages.invalidateDiscussionsCache().finally(function() {
                        $state.go('redirect', {siteid: notification.site, state: 'site.messages'});
                    });
                });
                return true;
            }
        });
    }

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign', ['mm.core'])

.constant('mmaModAssignComponent', 'mmaModAssign')
.constant('mmaModAssignSubmissionComponent', 'mmaModAssignSubmission')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_assign', {
        url: '/mod_assign',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignIndexCtrl',
                templateUrl: 'addons/mod_assign/templates/index.html'
            }
        }
    })

    .state('site.mod_assign-submission', {
        url: '/mod_assign-submission',
        params: {
            submission: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignSubmissionCtrl',
                templateUrl: 'addons/mod_assign/templates/submission.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModAssign', 'assign', '$mmaModAssignHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModAssign', '$mmaModAssignHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book', ['mm.core'])

.constant('mmaModBookComponent', 'mmaModBook')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_book', {
      url: '/mod_book',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModBookIndexCtrl',
          templateUrl: 'addons/mod_book/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModBook', 'book', '$mmaModBookHandlers.courseContentHandler');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModBook', 'book', '$mmaModBookPrefetchHandler');

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModBook', '$mmaModBookHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat', [])

.constant('mmaChatPollInterval', 4000)

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_chat', {
        url: '/mod_chat',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModChatIndexCtrl',
                templateUrl: 'addons/mod_chat/templates/index.html'
            }
        }
    })

    .state('site.mod_chat-chat', {
        url: '/mod_chat-chat',
        params: {
            chatid: null,
            courseid: null,
            title: null
        },
        views: {
            'site': {
                controller: 'mmaModChatChatCtrl',
                templateUrl: 'addons/mod_chat/templates/chat.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModChat', 'chat', '$mmaModChatHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModChat', '$mmaModChatHandlers.linksHandler');
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice', [])

.constant('mmaModChoiceResultsNot', 0)
.constant('mmaModChoiceResultsAfterAnswer', 1)
.constant('mmaModChoiceResultsAfterClose', 2)
.constant('mmaModChoiceResultsAlways', 3)

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_choice', {
        url: '/mod_choice',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModChoiceIndexCtrl',
                templateUrl: 'addons/mod_choice/templates/index.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModChoice', 'choice', '$mmaModChoiceHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModChoice', '$mmaModChoiceHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder', ['mm.core'])

.constant('mmaModFolderComponent', 'mmaModFolder')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_folder', {
      url: '/mod_folder',
      params: {
        module: null,
        courseid: null,
        sectionid: null,
        path: null // For subfolders. Use the path instead of a boolean so Angular detects them as different states.
      },
      views: {
        'site': {
          controller: 'mmaModFolderIndexCtrl',
          templateUrl: 'addons/mod_folder/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModFolder', 'folder', '$mmaModFolderHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModFolder', 'folder', '$mmaModFolderPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModFolder', '$mmaModFolderHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum', [])

.constant('mmaModForumDiscPerPage', 10) // Max of discussions per page.
.constant('mmaModForumComponent', 'mmaModForum')
.constant('mmaModForumNewDiscussionEvent', 'mma-mod_forum_new_discussion')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_forum', {
        url: '/mod_forum',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModForumDiscussionsCtrl',
                templateUrl: 'addons/mod_forum/templates/discussions.html'
            }
        }
    })

    .state('site.mod_forum-discussion', {
        url: '/mod_forum-discussion',
        params: {
            discussionid: null,
            cid: null // Not naming it courseid because it collides with 'site.mod_forum' param in split-view.
        },
        views: {
            'site': {
                controller: 'mmaModForumDiscussionCtrl',
                templateUrl: 'addons/mod_forum/templates/discussion.html'
            }
        }
    })

    .state('site.mod_forum-newdiscussion', {
        url: '/mod_forum-newdiscussion',
        params: {
            cid: null, // Not naming it courseid because it collides with 'site.mod_forum' param in split-view.
            forumid: null,
            cmid: null
        },
        views: {
            'site': {
                controller: 'mmaModForumNewDiscussionCtrl',
                templateUrl: 'addons/mod_forum/templates/newdiscussion.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModForum', 'forum', '$mmaModForumHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModForum', '$mmaModForumHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary', ['mm.core'])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_glossary', {
      url: '/mod_glossary',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModGlossaryIndexCtrl',
          templateUrl: 'addons/mod_glossary/templates/index.html'
        }
      }
    })

    .state('site.mod_glossary-entry', {
      url: '/mod_glossary-entry',
      params: {
        cid: null, // Not naming it courseid because it collides with 'site.mod_glossary' param in split-view.
        entry: null
      },
      views: {
        'site': {
          controller: 'mmaModGlossaryEntryCtrl',
          templateUrl: 'addons/mod_glossary/templates/entry.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModGlossary', 'glossary', '$mmaModGlossaryHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModGlossary', '$mmaModGlossaryHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp', ['mm.core'])

.constant('mmaModImscpComponent', 'mmaModImscp')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_imscp', {
      url: '/mod_imscp',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModImscpIndexCtrl',
          templateUrl: 'addons/mod_imscp/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModImscp', 'imscp', '$mmaModImscpHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModImscp', 'imscp', '$mmaModImscpPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModImscp', '$mmaModImscpHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_label', ['mm.core'])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider
    .state('site.mod_label', {
        url: '/mod_label',
        params: {
            description: null
        },
        views: {
            'site': {
                templateUrl: 'addons/mod_label/templates/index.html',
                controller: 'mmaModLabelIndexCtrl'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModLabel', 'label', '$mmaModLabelHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModLabel', '$mmaModLabelHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti', [])

.constant('mmaModLtiComponent', 'mmaModLti')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_lti', {
        url: '/mod_lti',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModLtiIndexCtrl',
                templateUrl: 'addons/mod_lti/templates/index.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModLti', 'lti', '$mmaModLtiHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModLti', '$mmaModLtiHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page', ['mm.core'])

.constant('mmaModPageComponent', 'mmaModPage')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_page', {
      url: '/mod_page',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModPageIndexCtrl',
          templateUrl: 'addons/mod_page/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModPage', 'page', '$mmaModPageHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModPage', 'page', '$mmaModPagePrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModPage', '$mmaModPageHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource', ['mm.core'])

.constant('mmaModResourceComponent', 'mmaModResource')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_resource', {
      url: '/mod_resource',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModResourceIndexCtrl',
          templateUrl: 'addons/mod_resource/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModResource', 'resource', '$mmaModResourceHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModResource', 'resource', '$mmaModResourcePrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModResource', '$mmaModResourceHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm', ['mm.core'])

.constant('mmaModScormComponent', 'mmaModScorm')
.constant('mmaModScormEventLaunchNextSco', 'mma_mod_scorm_launch_next_sco')
.constant('mmaModScormEventLaunchPrevSco', 'mma_mod_scorm_launch_prev_sco')
.constant('mmaModScormEventUpdateToc', 'mma_mod_scorm_update_toc')
.constant('mmaModScormEventGoOffline', 'mma_mod_scorm_go_offline')
.constant('mmaModScormEventAutomSynced', 'mma_mod_scorm_autom_synced')
.constant('mmaModScormSyncTime', 200000) // In milliseconds.

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_scorm', {
      url: '/mod_scorm',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModScormIndexCtrl',
          templateUrl: 'addons/mod_scorm/templates/index.html'
        }
      }
    })

    .state('site.mod_scorm-player', {
      url: '/mod_scorm-player',
      params: {
        scorm: null,
        mode: null,
        newAttempt: false,
        organizationId: null,
        scoId: null
      },
      views: {
        'site': {
          controller: 'mmaModScormPlayerCtrl',
          templateUrl: 'addons/mod_scorm/templates/player.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModScorm', 'scorm', '$mmaModScormHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModScorm', 'scorm', '$mmaModScormPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModScorm', '$mmaModScormHandlers.linksHandler');
}])

.run(["$timeout", "$mmaModScormSync", "$mmApp", "$mmEvents", "$mmSite", "mmCoreEventLogin", function($timeout, $mmaModScormSync, $mmApp, $mmEvents, $mmSite, mmCoreEventLogin) {
    var lastExecution = 0,
        executing = false,
        allSitesCalled = false;

    function syncScorms(allSites) {
        var now = new Date().getTime();

        if (!allSites && !$mmSite.isLoggedIn()) {
            return;
        }

        // Prevent consecutive and simultaneous executions. A sync process shouldn't take more than a few minutes,
        // so if it's been more than 5 minutes since the last execution we'll ignore the executing value.
        if (now - 5000 > lastExecution && (!executing || now - 300000 > lastExecution)) {
            lastExecution = new Date().getTime();
            executing = true;

            $timeout(function() { // Minor delay just to make sure network is fully established.
                $mmaModScormSync.syncAllScorms(allSites ? undefined : $mmSite.getId()).finally(function() {
                    executing = false;
                });
            }, 1000);
        }
    }

    $mmApp.ready().then(function() {
        document.addEventListener('online', function() {
            syncScorms(false);
        }, false); // Cordova event.
        window.addEventListener('online', function() {
            syncScorms(false);
        }, false); // HTML5 event.

        if (!$mmSite.isLoggedIn()) {
            // App was started without any site logged in. Try to sync all sites.
            allSitesCalled = true;
            if ($mmApp.isOnline()) {
                syncScorms(true);
            }
        }
    });

    $mmEvents.on(mmCoreEventLogin, function() {
        var allSites = false;
        if (!allSitesCalled) {
            // App started with a site logged in. Try to sync all sites.
            allSitesCalled = true;
            allSites = true;
        }

        if ($mmApp.isOnline()) {
            syncScorms(allSites);
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_survey', {
        url: '/mod_survey',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModSurveyIndexCtrl',
                templateUrl: 'addons/mod_survey/templates/index.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModSurvey', 'survey', '$mmaModSurveyHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModSurvey', '$mmaModSurveyHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url', ['mm.core'])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_url', {
      url: '/mod_url',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModUrlIndexCtrl',
          templateUrl: 'addons/mod_url/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModUrl', 'url', '$mmaModUrlHandlers.courseContentHandler');

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModUrl', '$mmaModUrlHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes', [])

.constant('mmaNotesPriority', 200)
.constant('mmaNotesAddNotePriority', 200)

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "mmaNotesPriority", "mmaNotesAddNotePriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, mmaNotesPriority, mmaNotesAddNotePriority) {

    $stateProvider

    .state('site.notes-types', {
        url: '/notes-types',
        views: {
            'site': {
                templateUrl: 'addons/notes/templates/types.html',
                controller: 'mmaNotesTypesCtrl'
            }
        },
        params: {
            course: null
        }
    })

    .state('site.notes-list', {
        url: '/notes-list',
        views: {
            'site': {
                templateUrl: 'addons/notes/templates/list.html',
                controller: 'mmaNotesListCtrl'
            }
        },
        params: {
            courseid: null,
            type: null
        }
    });

    // Register plugin on user profile.
    $mmUserDelegateProvider.registerProfileHandler('mmaNotes:addNote', '$mmaNotesHandlers.addNote', mmaNotesAddNotePriority);

    // Register courses handler.
    $mmCoursesDelegateProvider.registerNavHandler('mmaNotes', '$mmaNotesHandlers.coursesNav', mmaNotesPriority);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications', [])

.constant('mmaNotificationsListLimit', 20) // Max of notifications to retrieve in each WS call.
.constant('mmaNotificationsPriority', 800)

.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaNotificationsPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaNotificationsPriority) {

    $stateProvider

    .state('site.notifications', {
        url: '/notifications',
        views: {
            'site': {
                templateUrl: 'addons/notifications/templates/list.html',
                controller: 'mmaNotificationsListCtrl'
            }
        }
    });

    // Register side menu addon.
    $mmSideMenuDelegateProvider.registerNavHandler('mmaNotifications', '$mmaNotificationsHandlers.sideMenuNav', mmaNotificationsPriority);
}])

.run(["$log", "$mmaNotifications", "$mmUtil", "$state", "$mmAddonManager", function($log, $mmaNotifications, $mmUtil, $state, $mmAddonManager) {
    $log = $log.getInstance('mmaNotifications');

    // Register push notification clicks.
    var $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate');
    if ($mmPushNotificationsDelegate) {
        $mmPushNotificationsDelegate.registerHandler('mmaNotifications', function(notification) {
            if ($mmUtil.isTrueOrOne(notification.notif)) {
                $mmaNotifications.isPluginEnabledForSite(notification.site).then(function() {
                    $mmaNotifications.invalidateNotificationsList().finally(function() {
                        $state.go('redirect', {siteid: notification.site, state: 'site.notifications'});
                    });
                });
                return true;
            }
        });
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants', [])

.constant('mmaParticipantsListLimit', 50) // Max of participants to retrieve in each WS call.
.constant('mmaParticipantsPriority', 600)

.config(["$stateProvider", "$mmCoursesDelegateProvider", "$mmContentLinksDelegateProvider", "mmaParticipantsPriority", function($stateProvider, $mmCoursesDelegateProvider, $mmContentLinksDelegateProvider, mmaParticipantsPriority) {

    $stateProvider
        .state('site.participants', {
            url: '/participants',
            views: {
                'site': {
                    controller: 'mmaParticipantsListCtrl',
                    templateUrl: 'addons/participants/templates/list.html'
                }
            },
            params: {
                course: null
            }
        });

    $mmCoursesDelegateProvider.registerNavHandler('mmaParticipants', '$mmaParticipantsHandlers.coursesNavHandler',
                mmaParticipantsPriority);

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaParticipants', '$mmaParticipantsHandlers.linksHandler');

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.pushnotifications', [])

.constant('mmaPushNotificationsComponent', 'mmaPushNotifications')

.run(["$mmaPushNotifications", "$ionicPlatform", "$rootScope", "$mmEvents", "$mmLocalNotifications", "mmCoreEventLogin", "mmaPushNotificationsComponent", "mmCoreEventSiteDeleted", function($mmaPushNotifications, $ionicPlatform, $rootScope, $mmEvents, $mmLocalNotifications, mmCoreEventLogin,
            mmaPushNotificationsComponent, mmCoreEventSiteDeleted) {

    // Register device on GCM or APNS server.
    $ionicPlatform.ready(function() {
        $mmaPushNotifications.registerDevice();
    });

    // Notification received.
    $rootScope.$on('$cordovaPush:notificationReceived', function(e, notification) {
        if (ionic.Platform.isAndroid()) {
            $mmaPushNotifications.onGCMReceived(notification);
        } else if (ionic.Platform.isIOS()) {
            $mmaPushNotifications.onMessageReceived(notification);
        }
    });

    // Register device on Moodle site when login.
    $mmEvents.on(mmCoreEventLogin, function() {
        $mmaPushNotifications.registerDeviceOnMoodle();
    });

    $mmEvents.on(mmCoreEventSiteDeleted, function(site) {
        $mmaPushNotifications.unregisterDeviceOnMoodle(site);
    });

    // Listen for local notification clicks (generated by the app).
    $mmLocalNotifications.registerClick(mmaPushNotificationsComponent, $mmaPushNotifications.notificationClicked);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.remotestyles', [])

.constant('mmaRemoteStylesComponent', 'mmaRemoteStyles')

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventLogout", "mmCoreEventSiteAdded", "mmCoreEventSiteUpdated", "$mmaRemoteStyles", "$mmSite", function($mmEvents, mmCoreEventLogin, mmCoreEventLogout, mmCoreEventSiteAdded, mmCoreEventSiteUpdated, $mmaRemoteStyles,
            $mmSite) {

    $mmEvents.on(mmCoreEventSiteAdded, $mmaRemoteStyles.load);
    $mmEvents.on(mmCoreEventSiteUpdated, function(siteid) {
        // Load only if current site was updated.
        if (siteid === $mmSite.getId()) {
            $mmaRemoteStyles.load();
        }
    });
    $mmEvents.on(mmCoreEventLogin, $mmaRemoteStyles.load);

    // Remove added styles on logout.
    $mmEvents.on(mmCoreEventLogout, $mmaRemoteStyles.clear);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

/**
 * Controller to handle an event.
 *
 * @module mm.addons.calendar
 * @ngdoc controller
 * @name mmaCalendarEventCtrl
 */
.controller('mmaCalendarEventCtrl', ["$scope", "$log", "$stateParams", "$mmaCalendar", "$mmUtil", "$mmCourse", "$mmCourses", "$mmLocalNotifications", function($scope, $log, $stateParams, $mmaCalendar, $mmUtil, $mmCourse, $mmCourses,
        $mmLocalNotifications) {

    $log = $log.getInstance('mmaCalendarEventCtrl');

    var eventid = parseInt($stateParams.id);

    // Convenience function that fetches the event and updates the scope.
    function fetchEvent(refresh) {
        return $mmaCalendar.getEvent(eventid, refresh).then(function(e) {
            $mmaCalendar.formatEventData(e);
            $scope.event = e;
            $scope.title = e.name;

            if (e.moduleicon) {
                // It's a module event, translate the module name to the current language.
                $mmCourse.translateModuleName(e.modulename).then(function(name) {
                    if (name.indexOf('mm.core.mod') === -1) {
                        e.modulename = name;
                    }
                });
            }

            if (e.courseid > 1) {
                // It's a course event, retrieve the course name.
                $mmCourses.getUserCourse(e.courseid, true).then(function(course) {
                    $scope.coursename = course.fullname;
                });
            }

        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.calendar.errorloadevent', true);
            }
        });
    }

    // Get event.
    fetchEvent().finally(function() {
        $scope.eventLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshEvent = function() {
        fetchEvent(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.notificationsEnabled = $mmLocalNotifications.isAvailable();
    if ($scope.notificationsEnabled) {

        $mmaCalendar.getEventNotificationTime(eventid).then(function(notificationtime) {
            $scope.notification = { // Use an object, otherwise changes are not reflected.
                time: String(notificationtime)
            };
        });

        $scope.updateNotificationTime = function() {
            var time = parseInt($scope.notification.time);
            if (!isNaN(time) && $scope.event && $scope.event.id) {
                $mmaCalendar.updateNotificationTime($scope.event, time);
            }
        };
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

/**
 * Controller to handle calendar events.
 *
 * @module mm.addons.calendar
 * @ngdoc controller
 * @name mmaCalendarListCtrl
 */
.controller('mmaCalendarListCtrl', ["$scope", "$stateParams", "$log", "$state", "$mmaCalendar", "$mmUtil", "$ionicHistory", "mmaCalendarDaysInterval", function($scope, $stateParams, $log, $state, $mmaCalendar, $mmUtil, $ionicHistory,
        mmaCalendarDaysInterval) {

    $log = $log.getInstance('mmaCalendarListCtrl');

    var daysLoaded,
        emptyEventsTimes; // Variable to identify consecutive calls returning 0 events.

    if ($stateParams.eventid) {
        // We arrived here via notification click, let's clear history and redirect to event details.
        $ionicHistory.clearHistory();
        $state.go('site.calendar-event', {id: $stateParams.eventid});
    }

    // Convenience function to initialize variables.
    function initVars() {
        daysLoaded = 0;
        emptyEventsTimes = 0;
        $scope.events = [];
    }

    // Convenience function that fetches the events and updates the scope.
    function fetchEvents(refresh) {
        if (refresh) {
            initVars();
        }
        $scope.canLoadMore = false; // Set it to false to prevent consecutive calls.

        return $mmaCalendar.getEvents(daysLoaded, mmaCalendarDaysInterval, refresh).then(function(events) {
            daysLoaded += mmaCalendarDaysInterval;

            if (events.length === 0) {
                emptyEventsTimes++;
                if (emptyEventsTimes > 5) { // Stop execution if we retrieve empty list 6 consecutive times.
                    $scope.canLoadMore = false;
                    $scope.eventsLoaded = true;
                } else {
                    // No events returned, load next events.
                    return fetchEvents();
                }
            } else {
                angular.forEach(events, $mmaCalendar.formatEventData);
                if (refresh) {
                    $scope.events = events;
                } else {
                    $scope.events = $scope.events.concat(events);
                }
                $scope.count = $scope.events.length;
                $scope.eventsLoaded = true;
                $scope.canLoadMore = true;

                // Schedule notifications for the events retrieved (might have new events).
                $mmaCalendar.scheduleEventsNotifications(events);
            }
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.calendar.errorloadevents', true);
            }
            $scope.eventsLoaded = true;
        });
    }

    initVars();
    $scope.count = 0;

    // Get first events.
    fetchEvents();

    // Load more events.
    $scope.loadMoreEvents = function() {
        fetchEvents().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };

    // Pull to refresh.
    $scope.refreshEvents = function() {
        $mmaCalendar.invalidateEventsList().finally(function() {
            fetchEvents(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

.constant('mmaCalendarEventsStore', 'calendar_events')

.config(["$mmSitesFactoryProvider", "mmaCalendarEventsStore", function($mmSitesFactoryProvider, mmaCalendarEventsStore) {
    var stores = [
        {
            name: mmaCalendarEventsStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'notificationtime'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Service to handle calendar events.
 *
 * @module mm.addons.calendar
 * @ngdoc service
 * @name $mmaCalendar
 */
.factory('$mmaCalendar', ["$log", "$q", "$mmSite", "$mmUtil", "$mmCourses", "$mmGroups", "$mmCourse", "$mmLocalNotifications", "$mmSitesManager", "mmCoreSecondsDay", "mmaCalendarDaysInterval", "mmaCalendarEventsStore", "mmaCalendarDefaultNotifTime", "mmaCalendarComponent", function($log, $q, $mmSite, $mmUtil, $mmCourses, $mmGroups, $mmCourse, $mmLocalNotifications,
        $mmSitesManager, mmCoreSecondsDay, mmaCalendarDaysInterval, mmaCalendarEventsStore, mmaCalendarDefaultNotifTime,
        mmaCalendarComponent) {

    $log = $log.getInstance('$mmaCalendar');

    var self = {},
        calendarImgPath = 'addons/calendar/img/',
        eventicons = {
            'course': calendarImgPath + 'courseevent.svg',
            'group': calendarImgPath + 'groupevent.svg',
            'site': calendarImgPath + 'siteevent.svg',
            'user': calendarImgPath + 'userevent.svg'
        };

    /**
     * Get cache key for events list WS calls.
     *
     * @param {Number} daysToStart  Number of days from now to start getting events.
     * @param {Number} daysInterval Number of days between timestart and timeend.
     * @return {String} Cache key.
     */
    function getEventsListCacheKey(daysToStart, daysInterval) {
        return 'mmaCalendar:events:' + daysToStart + ':' + daysInterval;
    }

    /**
     * Get cache key for a single event WS call.
     *
     * @param {Number} id Event ID.
     * @return {String} Cache key.
     */
    function getEventCacheKey(id) {
        return 'mmaCalendar:events:' + id;
    }

    /**
     * Get the common part of the cache keys for events WS calls. Invalidate the whole list also invalidates all the
     * single events.
     *
     * @return {String} Cache key.
     */
    function getEventsCommonCacheKey() {
        return 'mmaCalendar:events:';
    }

    /**
     * Store events in local DB.
     *
     * @param {Object[]} events  Events to store.
     * @param  {String} [siteid] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise}         Promise resolved when the events are stored.
     */
    function storeEventsInLocalDB(events, siteid) {
        siteid = siteid || $mmSite.getId();

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var promises = [],
                db = site.getDb();

            angular.forEach(events, function(event) {
                // Get the event notification time to prevent overriding it in DB.
                var promise = self.getEventNotificationTime(event.id, siteid).then(function(time) {
                    event.notificationtime = time;
                    return db.insert(mmaCalendarEventsStore, event);
                });
                promises.push(promise);
            });

            return $q.all(promises);
        });
    }

    /**
     * Convenience function to format some event data to be rendered. Adds properties 'start', 'end', 'icon'
     * and (if it's a module event) 'moduleicon'.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#formatEventData
     * @param {Object} e Event to format.
     */
    self.formatEventData = function(e) {
        var icon = self.getEventIcon(e.eventtype);
        if (icon === '') {
            // It's a module event.
            icon = $mmCourse.getModuleIconSrc(e.modulename);
            e.moduleicon = icon;
        }
        e.icon = icon;
    };

    /**
     * Get a calendar event from server or cache. If the server request fails and data is not cached,
     * try to get it from local DB.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEvent
     * @param {Number}  id        Event ID.
     * @param {Boolean} [refresh] True when we should update the event data.
     * @return {Promise}          Promise resolved when the event data is retrieved.
     */
    self.getEvent = function(id, refresh) {
        var presets = {},
            data = {
                "options[userevents]": 0,
                "options[siteevents]": 0,
                "events[eventids][0]": id
            };

        presets.cacheKey = getEventCacheKey(id);
        if (refresh) {
            presets.getFromCache = false;
        }
        return $mmSite.read('core_calendar_get_calendar_events', data, presets).then(function(response) {
            var e = response.events[0];
            if (e) {
                return e;
            } else {
                return self.getEventFromLocalDb(id);
            }
        }, function() {
            return self.getEventFromLocalDb(id);
        });
    };

    /**
     * Get a calendar event from local Db.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEventFromLocalDb
     * @param {Number}  id Event ID.
     * @return {Promise}   Promise resolved when the event data is retrieved.
     */
    self.getEventFromLocalDb = function(id) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }
        return $mmSite.getDb().get(mmaCalendarEventsStore, id);
    };

    /**
     * Get event icon name based on event type.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEventIcon
     * @param  {String} type Event type.
     * @return {String}      Event icon name. If type not valid, return empty string.
     */
    self.getEventIcon = function(type) {
        return eventicons[type] || '';
    };

    /**
     * Get event notification time.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEventNotificationTime
     * @param  {Number} id       Event ID.
     * @param  {String} [siteid] ID of the site the event belongs to. If not defined, use current site.
     * @return {String}          Event icon name. If type not valid, return empty string.
     */
    self.getEventNotificationTime = function(id, siteid) {
        siteid = siteid || $mmSite.getId();

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var db = site.getDb();

            return db.get(mmaCalendarEventsStore, id).then(function(e) {
                if (typeof e.notificationtime != 'undefined') {
                    return e.notificationtime;
                }
                return mmaCalendarDefaultNotifTime;
            }, function(err) {
                return mmaCalendarDefaultNotifTime;
            });
        });
    };

    /**
     * Get calendar events in a certain period.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEvents
     * @param {Number} [daysToStart=0]   Number of days from now to start getting events.
     * @param {Number} [daysInterval=30] Number of days between timestart and timeend.
     * @param {Boolean} [refresh]        True when we should not get the value from the cache.
     * @param {String} [siteid]          Site to get the events from. If not defined, use current site.
     * @return {Promise}                 Promise to be resolved when the participants are retrieved.
     * @description
     * Get the events in a certain period. The period is calculated like this:
     *     start time: now + daysToStart
     *     end time: start time + daysInterval
     * E.g. using $mmaCalendar.getEvents(30, 30) is going to get the events starting after 30 days from now
     * and ending before 60 days from now.
     */
    self.getEvents = function(daysToStart, daysInterval, refresh, siteid) {
        daysToStart = daysToStart || 0;
        daysInterval = daysInterval || mmaCalendarDaysInterval;
        siteid = siteid || $mmSite.getId();

         var now = $mmUtil.timestamp(),
            start = now + (mmCoreSecondsDay * daysToStart),
            end = start + (mmCoreSecondsDay * daysInterval);

        // The core_calendar_get_calendar_events needs all the current user courses and groups.
        var data = {
            "options[userevents]": 1,
            "options[siteevents]": 1,
            "options[timestart]": start,
            "options[timeend]": end
        };

        return $mmCourses.getUserCourses(false, siteid).then(function(courses) {
            courses.push({id: 1}); // Add front page.
            angular.forEach(courses, function(course, index) {
                data["events[courseids][" + index + "]"] = course.id;
            });

            return $mmGroups.getUserGroups(courses, refresh, siteid).then(function(groups) {
                angular.forEach(groups, function(group, index) {
                    data["events[groupids][" + index + "]"] = group.id;
                });

                return $mmSitesManager.getSite(siteid).then(function(site) {

                    // We need to retrieve cached data using cache key because we have timestamp in the params.
                    var preSets = {
                        cacheKey: getEventsListCacheKey(daysToStart, daysInterval),
                        getCacheUsingCacheKey: true
                    };
                    return site.read('core_calendar_get_calendar_events', data, preSets).then(function(response) {
                        storeEventsInLocalDB(response.events, siteid);
                        return response.events;
                    });
                });
            });

        });
    };

    /**
     * Invalidates events list and all the single events.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#invalidateEventsList
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateEventsList = function() {
        var p1 = $mmCourses.invalidateUserCourses(),
            p2 = $mmSite.invalidateWsCacheForKeyStartingWith(getEventsCommonCacheKey());
        return $q.all([p1, p2]);
    };

    /**
     * Check if calendar events WS is available.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#isAvailable
     * @return {Boolean} True if calendar events WS is available, false otherwise.
     */
    self.isAvailable = function() {
        return $mmSite.wsAvailable('core_calendar_get_calendar_events');
    };

    /**
     * Get the next events for all the sites and schedules their notifications.
     * If an event notification time is 0, cancel its scheduled notification (if any).
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#scheduleAllSitesEventsNotifications
     * @param  {Object[]} events Events to schedule.
     * @return {Promise}         Promise resolved when all the notifications have been scheduled.
     */
    self.scheduleAllSitesEventsNotifications = function() {

        if ($mmLocalNotifications.isAvailable()) {
            return $mmSitesManager.getSitesIds().then(function(siteids) {

                var promises = [];
                angular.forEach(siteids, function(siteid) {
                    // Get first events.
                    var promise = self.getEvents(undefined, undefined, false, siteid).then(function(events) {
                        return self.scheduleEventsNotifications(events, siteid);
                    });
                    promises.push(promise);
                });

                return $q.all(promises);
            });
        } else {
            var deferred = $q.defer();
            deferred.resolve();
            return deferred.promise;
        }
    };

    /**
     * Schedules an event notification. If time is 0, cancel scheduled notification if any.
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#scheduleEventNotification
     * @param  {Object} event    Event to schedule.
     * @param  {Number} time     Notification setting time (in minutes). E.g. 10 means "notificate 10 minutes before start".
     * @param  {String} [siteid] Site ID the event belongs to. If not defined, use current site.
     * @return {Promise}       Promise resolved when the notification is scheduled.
     */
    self.scheduleEventNotification = function(event, time, siteid) {
        siteid = siteid || $mmSite.getId();

        if ($mmLocalNotifications.isAvailable()) {
            if (time === 0) {
                return $mmLocalNotifications.cancel(event.id, mmaCalendarComponent, siteid); // Cancel if it was scheduled.
            } else {
                var timeend = (event.timestart + event.timeduration) * 1000;
                if (timeend <= new Date().getTime()) {
                    // The event has finished already, don't schedule it.
                    return $q.when();
                }

                var dateTriggered = new Date((event.timestart - (time * 60)) * 1000),
                    startDate = new Date(event.timestart * 1000),
                    notification = {
                        id: event.id,
                        title: event.name,
                        message: startDate.toLocaleString(),
                        at: dateTriggered,
                        smallIcon: 'res://icon',
                        data: {
                            eventid: event.id,
                            siteid: siteid
                        }
                    };

                return $mmLocalNotifications.schedule(notification, mmaCalendarComponent, siteid);
            }
        } else {
            return $q.when();
        }
    };

    /**
     * Schedules the notifications for a list of events.
     * If an event notification time is 0, cancel its scheduled notification (if any).
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#scheduleEventsNotifications
     * @param  {Object[]} events Events to schedule.
     * @param  {String} [siteid] ID of the site the events belong to. If not defined, use current site.
     * @return {Promise}         Promise resolved when all the notifications have been scheduled.
     */
    self.scheduleEventsNotifications = function(events, siteid) {
        siteid = siteid || $mmSite.getId();
        var promises = [];

        if ($mmLocalNotifications.isAvailable()) {
            angular.forEach(events, function(e) {
                var promise = self.getEventNotificationTime(e.id, siteid).then(function(time) {
                    return self.scheduleEventNotification(e, time, siteid);
                });
                promises.push(promise);
            });
        }

        return $q.all(promises);
    };

    /**
     * Updates an event notification time and schedule a new notification.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#updateNotificationTime
     * @param  {Object} event Event to update its notification time.
     * @param  {Number} time  New notification setting time (in minutes). E.g. 10 means "notificate 10 minutes before start".
     * @return {Promise}      Promise resolved when the notification is updated.
     */
    self.updateNotificationTime = function(event, time) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }

        var db = $mmSite.getDb();

        event.notificationtime = time;

        return db.insert(mmaCalendarEventsStore, event).then(function() {
            return self.scheduleEventNotification(event, time);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

/**
 * Calendar handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.calendar
 * @ngdoc service
 * @name $mmaCalendarHandlers
 */
.factory('$mmaCalendarHandlers', ["$log", "$mmaCalendar", function($log, $mmaCalendar) {
    $log = $log.getInstance('$mmaCalendarHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendarHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaCalendar.isAvailable();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.calendar
             * @ngdoc controller
             * @name $mmaCalendarHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-calendar';
                $scope.title = 'mma.calendar.calendarevents';
                $scope.state = 'site.calendar';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion')

/**
 * Controller to handle course completion report.
 *
 * @module mm.addons.coursecompletion
 * @ngdoc controller
 * @name mmaCourseCompletionReportCtrl
 */
.controller('mmaCourseCompletionReportCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaCourseCompletion", "$mmSite", "$ionicPlatform", function($scope, $stateParams, $mmUtil, $mmaCourseCompletion, $mmSite,
            $ionicPlatform) {

    var course = $stateParams.course,
        userid = $stateParams.userid || $mmSite.getUserId();

    $scope.isTablet = $ionicPlatform.isTablet();

    function fetchCompletion() {
        return $mmaCourseCompletion.getCompletion(course.id, userid).then(function(completion) {

            completion.statusText = $mmaCourseCompletion.getCompletedStatusText(completion);

            $scope.completion = completion;
            $scope.showSelfComplete = $mmaCourseCompletion.isSelfCompletionAvailable() &&
                                        $mmaCourseCompletion.canMarkSelfCompleted(userid, completion);
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.coursecompletion.couldnotloadreport', true);
            }
        });
    }

    fetchCompletion().finally(function() {
        $scope.completionLoaded = true;
    });

    // Convenienve function to refresh completion data.
    function refreshCompletion() {
        return $mmaCourseCompletion.invalidateCourseCompletion(course.id, userid).finally(function() {
            return fetchCompletion();
        });
    }

    $scope.refreshCompletion = function() {
        refreshCompletion().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.completeCourse = function() {
        var modal = $mmUtil.showModalLoading('mm.core.sending', true);
        $mmaCourseCompletion.markCourseAsSelfCompleted(course.id).then(function() {
            return refreshCompletion();
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
        }).finally(function() {
            modal.dismiss();
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion')

/**
 * Course completion factory.
 *
 * @module mm.addons.coursecompletion
 * @ngdoc service
 * @name $mmaCourseCompletion
 */
.factory('$mmaCourseCompletion', ["$mmSite", "$log", "$q", "$mmCourses", function($mmSite, $log, $q, $mmCourses) {
    $log = $log.getInstance('$mmaCourseCompletion');

    var self = {};

    /**
     * Returns whether or not the user can mark a course as self completed.
     * It can if it's configured in the course and it hasn't been completed yet.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#canMarkSelfCompleted
     * @param {Number} userid     User ID.
     * @param {Object} completion Course completion.
     * @return {Boolean}          True if user can mark course as self completed, false otherwise.
     */
    self.canMarkSelfCompleted = function(userid, completion) {
        var selfCompletionActive = false,
            alreadyMarked = false;

        if ($mmSite.getUserId() != userid) {
            return false;
        }

        angular.forEach(completion.completions, function(criteria) {
            if (criteria.type === 1) {
                // Self completion criteria found.
                selfCompletionActive = true;
                alreadyMarked = criteria.complete;
            }
        });

        return selfCompletionActive && !alreadyMarked;
    };

    /**
     * Get completed status text. The language code returned is meant to be translated.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#getCompletedStatusText
     * @param {Object} completion Course completion.
     * @return {Promise}          Language code of the text to show.
     */
    self.getCompletedStatusText = function(completion) {
        if (completion.completed) {
            return 'mma.coursecompletion.completed';
        } else {
            // Let's calculate status.
            var hasStarted = false;
            angular.forEach(completion.completions, function(criteria) {
                if (criteria.timecompleted || criteria.complete) {
                    hasStarted = true;
                }
            });
            if (hasStarted) {
                return 'mma.coursecompletion.inprogress';
            } else {
                return 'mma.coursecompletion.notyetstarted';
            }
        }
    };

    /**
     * Get course completion status for a certain course and user.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#getCompletion
     * @param {Number} courseid Course ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise}        Promise to be resolved when the completion is retrieved.
     */
    self.getCompletion = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();

        $log.debug('Get completion for course ' + courseid + ' and user ' + userid);

        var data = {
                courseid : courseid,
                userid: userid
            },
            preSets = {
                cacheKey: getCompletionCacheKey(courseid, userid)
            };

        return $mmSite.read('core_completion_get_course_completion_status', data, preSets).then(function(data) {
            if (data.completionstatus) {
                return data.completionstatus;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for get completion WS calls.
     *
     * @param {Number} courseid Course ID.
     * @param {Number} userid   User ID.
     * @return {String}         Cache key.
     */
    function getCompletionCacheKey(courseid, userid) {
        return 'mmaCourseCompletion:view:' + courseid + ':' + userid;
    }

    /**
     * Invalidates view course completion WS call.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#invalidateCourseCompletion
     * @param {Number} courseid Course ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateCourseCompletion = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();
        return $mmSite.invalidateWsCacheForKey(getCompletionCacheKey(courseid, userid));
    };

    /**
     * Returns whether or not the view course completion plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#isPluginViewEnabled
     * @return {Boolean} True if plugin enabled, false otherwise.
     */
    self.isPluginViewEnabled = function() {
        if (!$mmSite.isLoggedIn()) {
            return false;
        } else if (!$mmSite.wsAvailable('core_completion_get_course_completion_status')) {
            return false;
        }

        return true;
    };

    /**
     * Returns whether or not the view course completion plugin is enabled for a certain course.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#isPluginViewEnabledForCourse
     * @param {Number} courseId Course ID.
     * @return {Promise}        Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginViewEnabledForCourse = function(courseId) {
        if (!courseId) {
            return $q.reject();
        }

        return $mmCourses.getUserCourse(courseId, true).then(function(course) {
            if (course && typeof course.enablecompletion != 'undefined' && !course.enablecompletion) {
                return false;
            }
            return true;
        });
    };

    /**
     * Returns whether or not the self completion is available in current site.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#isSelfCompletionAvailable
     * @return {Boolean} True if self completion is available, false otherwise.
     */
    self.isSelfCompletionAvailable = function() {
        return $mmSite.wsAvailable('core_completion_mark_course_self_completed');
    };

    /**
     * Mark a course as self completed.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#markCourseAsSelfCompleted
     * @param {Number} courseid Course ID.
     * @return {Promise}        Resolved on success.
     */
    self.markCourseAsSelfCompleted = function(courseid) {
        var params = {
            courseid: courseid
        };

        return $mmSite.write('core_completion_mark_course_self_completed', params).then(function(response) {
            if (!response.status) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion')

/**
 * Course completion handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.coursecompletion
 * @ngdoc service
 * @name $mmaCourseCompletionHandlers
 */
.factory('$mmaCourseCompletionHandlers', ["$mmaCourseCompletion", "$state", "mmCoursesAccessMethods", function($mmaCourseCompletion, $state, mmCoursesAccessMethods) {

    var self = {};

    /**
     * View user completion handler.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletionHandlers#viewCompletion
     */
    self.viewCompletion = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaCourseCompletion.isPluginViewEnabled();
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User to check.
         * @param {Number} courseId Course ID.
         * @return {Boolean}        True if handler is enabled, false otherwise.
         */
        self.isEnabledForUser = function(user, courseId) {
            return $mmaCourseCompletion.isPluginViewEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Object} user     Course ID.
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(user, courseId) {

            /**
             * View course completion handler controller.
             *
             * @module mm.addons.coursecompletion
             * @ngdoc controller
             * @name $mmaCourseCompletionHandlers#viewCompletion:controller
             */
            return function($scope) {

                // Button title.
                $scope.title = 'mma.coursecompletion.viewcoursereport';

                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.course-completion', {
                        userid: user.id,
                        course: {id: courseId}
                    });

                };
            };

        };

        return self;
    };

    /**
     * Course nav handler.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletionHandlers#coursesNav
     */
    self.coursesNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaCourseCompletion.isPluginViewEnabled();
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean}          True if handler is enabled, false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return $mmaCourseCompletion.isPluginViewEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(courseId) {

            /**
             * Courses nav handler controller.
             *
             * @module mm.addons.coursecompletion
             * @ngdoc controller
             * @name $mmaCourseCompletionHandlers#coursesNav:controller
             */
            return function($scope, $state) {
                $scope.icon = 'ion-android-checkbox-outline';
                $scope.title = 'mma.coursecompletion.coursecompletion';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.course-completion', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Controller to upload any kind of file on iOS. Lets the user choose the site he wants to upload the file to.
 *
 * @module mm.addons.files
 * @ngdoc controller
 * @name mmaFilesChooseSiteCtrl
 */
.controller('mmaFilesChooseSiteCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmaFilesHelper", "$ionicHistory", function($scope, $state, $stateParams, $mmSitesManager, $mmaFilesHelper, $ionicHistory) {

    var fileEntry = $stateParams.file || {};
    $scope.filename = fileEntry.name;

    $mmSitesManager.getSites().then(function(sites) {
        $scope.sites = sites;
    });

    $scope.uploadInSite = function(siteid) {
        $mmaFilesHelper.showConfirmAndUploadInSite(fileEntry, siteid).then(function() {
            $ionicHistory.nextViewOptions({
                disableBack: true
            });
            $state.go('site.mm_courses');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.controller('mmaFilesIndexController', ["$scope", "$mmaFiles", "$mmSite", "$mmUtil", "$mmApp", "$state", function($scope, $mmaFiles, $mmSite, $mmUtil, $mmApp, $state) {

    $scope.canAccessFiles = $mmaFiles.canAccessFiles;
    $scope.showPrivateFiles = function() {
        return $mmaFiles.canAccessFiles() && $mmSite.canAccessMyFiles();
    };
    $scope.showUpload = function() {
        // Show upload in this page if user can upload but he can't see the My Files option.
        return !$mmaFiles.canAccessFiles() && $mmSite.canAccessMyFiles() && $mmSite.canUploadFiles();
    };
    $scope.canDownload = $mmSite.canDownloadFiles;

    $scope.add = function() {
        if (!$mmApp.isOnline()) {
            $mmUtil.showErrorModal('mma.files.errormustbeonlinetoupload', true);
        } else {
            $state.go('site.files-upload');
        }
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.controller('mmaFilesListController', ["$q", "$scope", "$stateParams", "$mmaFiles", "$mmSite", "$translate", "$mmUtil", "$ionicHistory", "mmaFilesUploadStateName", "$state", "$mmApp", "mmaFilesMyComponent", "mmaFilesSiteComponent", function($q, $scope, $stateParams, $mmaFiles, $mmSite, $translate, $mmUtil,
        $ionicHistory, mmaFilesUploadStateName, $state, $mmApp, mmaFilesMyComponent, mmaFilesSiteComponent) {

    var path = $stateParams.path,
        root = $stateParams.root,
        title,
        promise;

    // We're loading the files.
    $scope.count = -1;
    $scope.component = root === 'my' ? mmaFilesMyComponent : mmaFilesSiteComponent;

    // Convenience function that fetches the files and updates the scope.
    function fetchFiles(root, path) {
        if (!path) {
            // The path is unknown, the user must be requesting a root.
            if (root === 'site') {
                promise = $mmaFiles.getSiteFiles();
                title = $translate('mma.files.sitefiles');
            } else if (root === 'my') {
                promise = $mmaFiles.getMyFiles();
                title = $translate('mma.files.myprivatefiles');
            } else {
                // Upon error we create a fake promise that is rejected.
                promise = $q.reject();
                title = (function() {
                    var q = $q.defer();
                    q.resolve('');
                    return q.promise;
                })();
            }
        } else {
            // Serve the files the user requested.
            pathdata = JSON.parse(path);
            promise = $mmaFiles.getFiles(pathdata);

            // Put the title in a promise to act like translate does.
            title = (function() {
                var q = $q.defer();
                q.resolve($stateParams.title);
                return q.promise;
            })();
        }

        return $q.all([promise, title]).then(function(data) {
            var files = data[0],
                title = data[1];

            $scope.files = files.entries;
            $scope.count = files.count;
            $scope.title = title;
        }, function() {
            $mmUtil.showErrorModal('mma.files.couldnotloadfiles', true);
        });
    }

    fetchFiles(root, path).finally(function() {
        $scope.filesLoaded = true;
    });

    $scope.refreshFiles = function() {
        $mmaFiles.invalidateDirectory(root, path).finally(function() {
            fetchFiles(root, path).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    // Update list if we come from upload page (we don't know if user upoaded a file or not).
    // List is invalidated in upload state after uploading a file.
    $scope.$on('$ionicView.enter', function(e) {
        var forwardView = $ionicHistory.forwardView();
        if (forwardView && forwardView.stateName === mmaFilesUploadStateName) {
            $scope.filesLoaded = false;
            fetchFiles(root, path).finally(function() {
                $scope.filesLoaded = true;
            });
        }
    });

    $scope.showUpload = function() {
        return (root === 'my' && !path && $mmSite.canUploadFiles());
    };

    // When we are in the root of the private files we can add more files.
    $scope.add = function() {
        if (!$mmApp.isOnline()) {
            $mmUtil.showErrorModal('mma.files.errormustbeonlinetoupload', true);
        } else {
            $state.go('site.files-upload', {root: root, path: path});
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Controller to upload any kind of file.
 *
 * @module mm.addons.files
 * @ngdoc controller
 * @name mmaFilesUploadCtrl
 */
.controller('mmaFilesUploadCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaFilesHelper", "$ionicHistory", "$mmaFiles", "$mmApp", function($scope, $stateParams, $mmUtil, $mmaFilesHelper, $ionicHistory, $mmaFiles, $mmApp) {

    var uploadMethods = {
            album: $mmaFilesHelper.uploadImageFromAlbum,
            camera: $mmaFilesHelper.uploadImageFromCamera,
            audio: $mmaFilesHelper.uploadAudio,
            video: $mmaFilesHelper.uploadVideo
        },
        path = $stateParams.path,
        root = $stateParams.root;

    $scope.isAndroid = ionic.Platform.isAndroid();

    // Function called when a file is uploaded.
    function successUploading() {
        $mmaFiles.invalidateDirectory(root, path).finally(function() {
            $mmUtil.showModal('mm.core.success', 'mma.files.fileuploaded');
            $ionicHistory.goBack();
        });
    }

    // Function called when a file upload fails.
    function errorUploading(err) {
        if (err) {
            $mmUtil.showErrorModal(err);
        }
    }

    $scope.upload = function(type) {
        if (!$mmApp.isOnline()) {
            $mmUtil.showErrorModal('mma.files.errormustbeonlinetoupload', true);
        } else {
            if (typeof(uploadMethods[type]) !== 'undefined') {
                uploadMethods[type]().then(successUploading, errorUploading);
            }
        }
    };

    $scope.uploadFile = function(evt) {
        var input = evt.srcElement;
        var file = input.files[0];
        input.value = ''; // Unset input.
        if (file) {
            $mmaFilesHelper.confirmUploadFile(file.size).then(function() {
                // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
                $mmaFilesHelper.copyAndUploadFile(file).then(successUploading, errorUploading);
            }, errorUploading);
        }
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Directive to detect chanegs on file inputs (ng-Change doesn't work in that type of input).
 *
 * @module mm.addons.files
 * @ngdoc directive
 * @name mmaFilesOnChange
 */
.directive('mmaFilesOnChange', function() {
  return {
    restrict: 'A',
    link: function (scope, element, attrs) {
      var onChangeHandler = scope.$eval(attrs.mmaFilesOnChange);
      element.bind('change', onChangeHandler);
    }
  };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.config(["$mmAppProvider", "mmaFilesSharedFilesStore", function($mmAppProvider, mmaFilesSharedFilesStore) {
    var stores = [
        {
            name: mmaFilesSharedFilesStore,
            keyPath: 'id'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

.factory('$mmaFiles', ["$mmSite", "$mmFS", "$q", "$timeout", "$log", "$mmSitesManager", "$mmApp", "md5", "mmaFilesSharedFilesStore", function($mmSite, $mmFS, $q, $timeout, $log, $mmSitesManager, $mmApp, md5,
            mmaFilesSharedFilesStore) {

    $log = $log.getInstance('$mmaFiles');

    var self = {},
        defaultParams = {
            "contextid": 0,
            "component": "",
            "filearea": "",
            "itemid": 0,
            "filepath": "",
            "filename": ""
        };

    /**
     * Check if core_files_get_files WS call is available.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#canAccessFiles
     * @return {Boolean} True if WS is available, false otherwise.
     */
    self.canAccessFiles = function() {
        return $mmSite.wsAvailable('core_files_get_files');
    };

    /**
     * Checks if there is a new file received in iOS. If more than one file is found, treat only the first one.
     * The file returned is marked as "treated" and will be deleted in the next execution.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#checkIOSNewFiles
     * @return {Promise} Promise resolved with a new file to be treated. If no new files found, promise is rejected.
     */
    self.checkIOSNewFiles = function() {

        var deferred = $q.defer();

        $log.debug('Search for new files on iOS');
        $mmFS.getDirectoryContents('Inbox').then(function(entries) {

            if (entries.length > 0) {

                var promises = [];
                angular.forEach(entries, function(entry) {

                    var fileDeferred = $q.defer(),
                        fileId = md5.createHash(entry.name);

                    // Check if file was already treated.
                    $mmApp.getDB().get(mmaFilesSharedFilesStore, fileId).then(function() {
                        // File already treated. Delete it.
                        $log.debug('Delete already treated file: ' + entry.name);
                        fileDeferred.resolve();

                        entry.remove(function() {
                            $log.debug('File deleted: ' + entry.name);
                            $mmApp.getDB().remove(mmaFilesSharedFilesStore, fileId).then(function() {
                                $log.debug('"Treated" mark removed from file: ' + entry.name);
                            }, function() {
                                $log.debug('Error deleting "treated" mark from file: ' + entry.name);
                            });
                        }, function() {
                            $log.debug('Error deleting file in Inbox: ' + entry.name);
                        });

                    }, function() {
                        // File not treated before, send it to resolve so it's a candidate to be notified.
                        $log.debug('Found new file ' + entry.name + ' shared with the app.');
                        fileDeferred.resolve(entry);
                    });

                    promises.push(fileDeferred.promise);
                });

                $q.all(promises).then(function(responses) {
                    var fileToReturn,
                        fileId;
                    for (var i = 0; i < responses.length; i++) {
                        if (typeof(responses[i]) !== 'undefined') {
                            // Found new entry to treat.
                            fileToReturn = responses[i];
                            break;
                        }
                    }
                    if (fileToReturn) {
                        fileId = md5.createHash(fileToReturn.name);
                        // Mark it as "treated".
                        $mmApp.getDB().insert(mmaFilesSharedFilesStore, {id: fileId}).then(function() {
                            $log.debug('File marked as "treated": ' + fileToReturn.name);
                            deferred.resolve(fileToReturn);
                        }, function() {
                            $log.debug('Error marking file as "treated": ' + fileToReturn.name);
                            deferred.reject();
                        });
                    } else {
                        deferred.reject();
                    }
                }, deferred.reject);
            } else {
                deferred.reject();
            }
        });

        return deferred.promise;
    };

    /**
     * Get the list of files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#getFiles
     * @param  {Object} params A list of parameters accepted by the Web service.
     * @return {Object}        An object containing the files in the key 'entries', and 'count'.
     *                         Additional properties is added to the entries, such as:
     *                          - imgpath: The path to the icon.
     *                          - link: The JSON string of params to get to the file.
     *                          - linkId: A hash of the file parameters.
     */
    self.getFiles = function(params) {
        var deferred = $q.defer(),
            options = {};

        options.cacheKey = getFilesListCacheKey(params);

        $mmSite.read('core_files_get_files', params, options).then(function(result) {
            var data = {
                entries: [],
                count: 0
            };

            if (typeof result.files == 'undefined') {
                deferred.reject();
                return;
            }

            angular.forEach(result.files, function(entry) {
                entry.link = {};
                entry.link.contextid = (entry.contextid) ? entry.contextid : "";
                entry.link.component = (entry.component) ? entry.component : "";
                entry.link.filearea = (entry.filearea) ? entry.filearea : "";
                entry.link.itemid = (entry.itemid) ? entry.itemid : 0;
                entry.link.filepath = (entry.filepath) ? entry.filepath : "";
                entry.link.filename = (entry.filename) ? entry.filename : "";

                if (entry.component && entry.isdir) {
                    // Delete unused elements that may break the request.
                    entry.link.filename = "";
                }

                if (entry.isdir) {
                    entry.imgpath = $mmFS.getFolderIcon();
                } else {
                    entry.imgpath = $mmFS.getFileIcon(entry.filename);
                }

                entry.link = JSON.stringify(entry.link);
                entry.linkId = md5.createHash(entry.link);
                // entry.localpath = "";

                // if (!entry.isdir && entry.url) {
                //     // TODO Check $mmSite.
                //     var uniqueId = $mmSite.id + "-" + md5.createHash(entry.url);
                //     var path = MM.db.get("files", uniqueId);
                //     if (path) {
                //         entry.localpath = path.get("localpath");
                //     }
                // }

                data.count += 1;
                data.entries.push(entry);
            });

            deferred.resolve(data);
        }, function() {
            deferred.reject();
        });

        return deferred.promise;
    };

    /**
     * Get cache key for file list WS calls.
     *
     * @param  {Object} params Params of the directory to get.
     * @return {String}        Cache key.
     */
    function getFilesListCacheKey(params) {
        var root = params.component === '' ? 'site' : 'my';
        return 'mmaFiles:list:' + root + ':' + params.contextid + ':' + params.filepath;
    }

    /**
     * Get the private files of the current user.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#getMyFiles
     * @return {Object} See $mmaFiles#getFiles
     */
    self.getMyFiles = function() {
        var params = getMyFilesRootParams();
        return self.getFiles(params);
    };

    /**
     * Get the common part of the cache keys for private files WS calls.
     *
     * @return {String} Cache key.
     */
    function getMyFilesListCommonCacheKey() {
        return 'mmaFiles:list:my';
    }

    /**
     * Get params to get root private files directory.
     *
     * @return {Object} Params.
     */
    function getMyFilesRootParams() {
        var params = angular.copy(defaultParams, {});
        params.component = "user";
        params.filearea = "private";
        params.contextid = -1;
        params.contextlevel = "user";
        params.instanceid = $mmSite.getUserId();
        return params;
    }

    /**
     * Get the site files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#getSiteFiles
     * @return {Object} See $mmaFiles#getFiles
     */
    self.getSiteFiles = function() {
        var params = angular.copy(defaultParams, {});
        return self.getFiles(params);
    };

    /**
     * Get the common part of the cache keys for site files WS calls.
     *
     * @return {String} Cache key.
     */
    function getSiteFilesListCommonCacheKey() {
        return 'mmaFiles:list:site';
    }

    /**
     * Invalidates list of files in a certain directory.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#invalidateDirectory
     * @param  {String} root     Root of the directory ('my' for private files, 'site' for site files).
     * @param  {String} path     Path to the directory.
     * @param  {String} [siteid] Id of the site to invalidate. If not defined, use current site.
     * @return {Promise}         Promise resolved when the list is invalidated.
     */
    self.invalidateDirectory = function(root, path, siteid) {
        siteid = siteid || $mmSite.getId();

        var params = {};
        if (!path) {
            if (root === 'site') {
                params = angular.copy(defaultParams, {});
            } else if (root === 'my') {
                params = getMyFilesRootParams();
            }
        } else {
            params = JSON.parse(path);
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {
            site.invalidateWsCacheForKey(getFilesListCacheKey(params));
        });
    };

    /**
     * Invalidates list of private files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#invalidateMyFiles
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateMyFiles = function() {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getMyFilesListCommonCacheKey());
    };

    /**
     * Invalidates list of site files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#invalidateSiteFiles
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateSiteFiles = function() {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getSiteFilesListCommonCacheKey());
    };

    /**
     * Return whether or not the plugin is enabled. Plugin is enabled if:
     *     - Site supports core_files_get_files
     *     or
     *     - User has capability moodle/user:manageownfiles and WS allows uploading files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#isPluginEnabled
     * @return {Boolean}
     */
    self.isPluginEnabled = function() {
        var canAccessFiles = self.canAccessFiles(),
            canAccessMyFiles = $mmSite.canAccessMyFiles(),
            canUploadFiles = $mmSite.canUploadFiles();

        return canAccessFiles || (canUploadFiles && canAccessMyFiles);
    };

    /**
     * Upload a file.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadFile
     * @param  {Object} uri      File URI.
     * @param  {Object} options  Options for the upload.
     *                           - {Boolean} deleteAfterUpload Whether or not to delete the original after upload.
     *                           - {String} fileKey
     *                           - {String} fileName
     *                           - {String} mimeType
     * @param  {String} [siteid] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}
     */
    self.uploadFile = function(uri, options, siteid) {
        options = options || {};
        siteid = siteid || $mmSite.getId();

        var deleteAfterUpload = options.deleteAfterUpload,
            deferred = $q.defer(),
            ftOptions = {
                fileKey: options.fileKey,
                fileName: options.fileName,
                mimeType: options.mimeType
            };

        function deleteFile() {
            $timeout(function() {
                // Use set timeout, otherwise in Node-Webkit the upload threw an error sometimes.
                $mmFS.removeExternalFile(uri);
            }, 500);
        }

        $mmSitesManager.getSite(siteid).then(function(site) {
            site.uploadFile(uri, ftOptions).then(deferred.resolve, deferred.reject, deferred.notify).finally(function() {
                if (deleteAfterUpload) {
                    deleteFile();
                }
            });
        }, function() {
            if (deleteAfterUpload) {
                deleteFile();
            }
            deferred.reject(error);
        });

        return deferred.promise;
    };

    /**
     * Upload image.
     * @todo Handle Node Webkit.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadImage
     * @param  {String}  uri         File URI.
     * @param  {Boolean} isFromAlbum True if the image was taken from album, false if it's a new image taken with camera.
     * @return {Promise}
     */
    self.uploadImage = function(uri, isFromAlbum) {
        $log.debug('Uploading an image');
        var d = new Date(),
            options = {};

        if (typeof(uri) === 'undefined' || uri === ''){
            // In Node-Webkit, if you successfully upload a picture and then you open the file picker again
            // and cancel, this function is called with an empty uri. Let's filter it.
            $log.debug('Received invalid URI in $mmaFiles.uploadImage()');
            return $q.reject();
        }

        options.deleteAfterUpload = !isFromAlbum;
        options.fileKey = "file";
        options.fileName = "image_" + d.getTime() + ".jpg";
        options.mimeType = "image/jpeg";

        return self.uploadFile(uri, options);
    };

    /**
     * Upload media.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadMedia
     * @param  {Array} mediaFiles Array of file objects.
     * @return {Array} Array of promises.
     */
    self.uploadMedia = function(mediaFiles) {
        $log.debug('Uploading media');
        var promises = [];
        angular.forEach(mediaFiles, function(mediaFile, index) {
            var options = {};
            options.fileKey = null;
            options.fileName = mediaFile.name;
            options.mimeType = null;
            options.deleteAfterUpload = true;
            promises.push(self.uploadFile(mediaFile.fullPath, options));
        });
        return promises;
    };

    /**
     * Upload a file of any type.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadGenericFile
     * @param  {String} uri      File URI.
     * @param  {String} name     File name.
     * @param  {String} type     File type.
     * @param  {String} [siteid] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}     Promise resolved when the file is uploaded.
     */
    self.uploadGenericFile = function(uri, name, type, siteid) {
        var options = {};
        options.fileKey = null;
        options.fileName = name;
        options.mimeType = type;
        // Don't delete the file on iOS, it's going to be deleted on $mmaFiles#checkIOSNewFiles.
        options.deleteAfterUpload = !ionic.Platform.isIOS();

        return self.uploadFile(uri, options, siteid);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Files handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.files
 * @ngdoc service
 * @name $mmaFilesHandlers
 */
.factory('$mmaFilesHandlers', ["$log", "$mmaFiles", function($log, $mmaFiles) {
    $log = $log.getInstance('$mmaFilesHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaFiles.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.files
             * @ngdoc controller
             * @name $mmaFilesHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-folder';
                $scope.title = 'mma.files.myfiles';
                $scope.state = 'site.files';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.constant('mmaFilesFileSizeWarning', 5242880)

.factory('$mmaFilesHelper', ["$q", "$mmUtil", "$mmApp", "$log", "$translate", "$window", "$mmaFiles", "$cordovaCamera", "$cordovaCapture", "$mmLang", "$mmFS", "$mmText", "mmaFilesFileSizeWarning", function($q, $mmUtil, $mmApp, $log, $translate, $window,
        $mmaFiles, $cordovaCamera, $cordovaCapture, $mmLang, $mmFS, $mmText, mmaFilesFileSizeWarning) {

    $log = $log.getInstance('$mmaFilesHelper');

    var self = {};

    /**
     * Convenient helper for the user to upload an image from an album.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadImageFromAlbum
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadImageFromAlbum = function() {
        $log.debug('Trying to get a image from albums');
        var deferred = $q.defer();

        var width  =  $window.innerWidth  - 200;
        var height =  $window.innerHeight - 200;

        // iPad popOver, see https://tracker.moodle.org/browse/MOBILE-208
        var popover = new CameraPopoverOptions(10, 10, width, height, Camera.PopoverArrowDirection.ARROW_ANY);
        $cordovaCamera.getPicture({
            quality: 50,
            destinationType: navigator.camera.DestinationType.FILE_URI,
            sourceType: navigator.camera.PictureSourceType.PHOTOLIBRARY,
            popoverOptions : popover
        }).then(function(img) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $mmaFiles.uploadImage(img, true).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatImageError(error, deferred, 'mma.files.errorgettingimagealbum');
        });

        return deferred.promise;
    };

    /**
     * Convenient helper for the user to take an image with the camera and upload it.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadImageFromCamera
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadImageFromCamera = function() {
        $log.debug('Trying to capture an image with camera');
        var deferred = $q.defer();

        $cordovaCamera.getPicture({
            quality: 50,
            destinationType: navigator.camera.DestinationType.FILE_URI
        }).then(function(img) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $mmaFiles.uploadImage(img, false).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatImageError(error, deferred, 'mma.files.errorcapturingimage');
        });

        return deferred.promise;
    };

    /**
     * Convenient helper for the user to record and upload an audio.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadAudio
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadAudio = function() {
        $log.debug('Trying to record an audio file');
        var deferred = $q.defer();

        $cordovaCapture.captureAudio({limit: 1}).then(function(medias) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $q.all($mmaFiles.uploadMedia(medias)).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatCaptureError(error, deferred, 'mma.files.errorcapturingaudio');
        });

        return deferred.promise;
    };

    /**
     * Convenient helper for the user to record and upload a video.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadVideo
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadVideo = function() {
        $log.debug('Trying to record a video file');
        var deferred = $q.defer();

        $cordovaCapture.captureVideo({limit: 1}).then(function(medias) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $q.all($mmaFiles.uploadMedia(medias)).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatCaptureError(error, deferred, 'mma.files.errorcapturingvideo');
        });

        return deferred.promise;
    };

    /**
     * Show a confirmation modal to the user if he is using a limited connection or the file size is higher than 5MB.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#confirmUploadFile
     * @param  {Number} size File's size.
     * @return {Promise}     Promise resolved when the user confirms or if there's no need to show a modal.
     */
    self.confirmUploadFile = function(size) {
        if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mma.files.errormustbeonlinetoupload');
        }

        if ($mmApp.isNetworkAccessLimited() || size >= mmaFilesFileSizeWarning) {
             var size = $mmText.bytesToSize(size, 2);
            return $mmUtil.showConfirm($translate('mma.files.confirmuploadfile', {size: size}));
        } else {
            var deferred = $q.defer();
            deferred.resolve();
            return deferred.promise;
        }
    };

    /**
     * Create a temporary copy of a file and upload it.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#copyAndUploadFile
     * @param {Object} file File to copy and upload.
     * @return {Promise}    Promise resolved when the file is uploaded.
     */
    self.copyAndUploadFile = function(file) {
        var deferred = $q.defer();

        var modal = $mmUtil.showModalLoading('mma.files.readingfile', true);

        // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
        $mmFS.readFileData(file, $mmFS.FORMATARRAYBUFFER).then(function(data) {

            var filepath = $mmFS.getTmpFolder() + '/' + file.name;

            $mmFS.writeFile(filepath, data).then(function(fileEntry) {
                modal.dismiss();
                self.uploadGenericFile(fileEntry.toURL(), file.name, file.type).then(deferred.resolve, deferred.reject);
            }, function(error) {
                $log.error('Error writing file to upload: '+JSON.stringify(error));
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorreadingfile');
                modal.dismiss();
            });

        }, function(error) {
            $log.error('Error reading file to upload: '+JSON.stringify(error));
            $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorreadingfile');
            modal.dismiss();
        });

        return deferred.promise;
    };

    /**
     * Uploads a file of any type.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadGenericFile
     * @param  {String} uri      File URI.
     * @param  {String} name     File name.
     * @param  {String} type     File type.
     * @param  {String} [siteid] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}         Promise resolved when the file is uploaded.
     */
    self.uploadGenericFile = function(uri, name, type, siteid) {
        var deferred = $q.defer();

        if (!$mmApp.isOnline()) {
            $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errormustbeonlinetoupload');
            return deferred.promise;
        }

        var modal = $mmUtil.showModalLoading('mma.files.uploading', true);

        $mmaFiles.uploadGenericFile(uri, name, type, siteid).then(deferred.resolve, function(error) {
            $log.error('Error uploading file: '+JSON.stringify(error));
            $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
        }).finally(function() {
            modal.dismiss();
        });

        return deferred.promise;
    };

    /**
     * Convenience function to upload a file on a certain site, showing a confirm if needed.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#showConfirmAndUploadInSite
     * @param  {String} fileEntry FileEntry of the file to upload.
     * @param  {String} [siteid]  Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}          Promise resolved when the file is uploaded.
     */
    self.showConfirmAndUploadInSite = function(fileEntry, siteid) {
        return $mmFS.getFileObjectFromFileEntry(fileEntry).then(function(file) {
            return self.confirmUploadFile(file.size).then(function() {
                return self.uploadGenericFile(fileEntry.toURL(), file.name, file.type, siteid).then(function() {
                    // Invalidate my files root dir so the list is refreshed when the user goes in.
                    return $mmaFiles.invalidateDirectory('my', undefined, siteid).finally(function() {
                        $mmUtil.showModal('mm.core.success', 'mma.files.fileuploaded');
                    });
                }, function(err) {
                    if (err) {
                        $mmUtil.showErrorModal(err);
                    }
                    return $q.reject();
                });
            }, function(err) {
                if (err) {
                    $mmUtil.showErrorModal(err);
                }
                return $q.reject();
            });
        }, function() {
            $mmUtil.showErrorModal('mma.files.errorreadingfile', true);
            return $q.reject();
        });
    }

    /**
     * Treat a capture image or browse album error.
     *
     * @param  {String} error          Error returned by the Cordova plugin.
     * @param  {Promise} deferred      Promise to reject.
     * @param  {String} defaultMessage Key of the default message to show.
     */
    function treatImageError(error, deferred, defaultMessage) {
        // Cancelled, or error. If cancelled, error is a string with "Selection cancelled." or "Camera cancelled.".
        if (error) {
            if (typeof(error) === 'string') {
                if (error.toLowerCase().indexOf("error") > -1 || error.toLowerCase().indexOf("unable") > -1) {
                    $log.error('Error getting image: ' + error);
                    deferred.reject(error);
                } else {
                    $log.debug('Cancelled');
                    deferred.reject();
                }
            } else {
                $mmLang.translateAndRejectDeferred(deferred, defaultMessage);
            }
        } else {
            deferred.reject();
        }
    }

    /**
     * Treat a capture audio/video error.
     *
     * @param  {Mixed} error           Error returned by the Cordova plugin. Can be a string or an object.
     * @param  {Promise} deferred      Promise to reject.
     * @param  {String} defaultMessage Key of the default message to show.
     */
    function treatCaptureError(error, deferred, defaultMessage) {
        // Cancelled, or error. If cancelled, error is an object with code = 3.
        if (error) {
            if (typeof(error) === 'string') {
                $log.error('Error while recording audio/video: ' + error);
                if (error.indexOf('No Activity found') > -1) {
                    // User doesn't have an app to do this.
                    $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errornoapp');
                } else {
                    $mmLang.translateAndRejectDeferred(deferred, defaultMessage);
                }
            } else {
                if (error.code != 3) {
                    // Error, not cancelled.
                    $log.error('Error while recording audio/video: ' + JSON.stringify(error));
                    $mmLang.translateAndRejectDeferred(deferred, defaultMessage);
                } else {
                    $log.debug('Cancelled');
                    deferred.reject();
                }
            }
        } else {
            deferred.reject();
        }
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.frontpage')

/**
 * Frontpage factory.
 *
 * @module mm.addons.frontpage
 * @ngdoc service
 * @name $mmaFrontpage
 */
.factory('$mmaFrontpage', ["$mmSite", "$log", "$q", "$mmCourse", function($mmSite, $log, $q, $mmCourse) {
    $log = $log.getInstance('$mmaFrontpage');

    var self = {};

    /**
     * Returns whether or not the plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.frontpage
     * @ngdoc method
     * @name $mmaFrontpage#isPluginEnabled
     * @return {Boolean}
     */
    self.isPluginEnabled = function() {

        if (!$mmSite.isLoggedIn()) {
            return false;
        }

        return true;
    };

    /**
     * Returns whether or not the frontpage is available for the current site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @module mm.addons.frontpage
     * @ngdoc method
     * @name $mmaFrontpage#isFrontpageAvailable
     * @return {Promise} Resolved when enabled, otherwise rejected.
     */
    self.isFrontpageAvailable = function() {

        // On older version we cannot check other than calling a WS. If the request
        // fails there is a very high chance that frontpage is not available.
        $log.debug('Using WS call to check if frontpage is available.');
        return $mmCourse.getSections(1, {emergencyCache: false}).then(function(data) {
            if (!angular.isArray(data) || data.length == 0) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.frontpage')

/**
 * Front page handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.frontpage
 * @ngdoc service
 * @name $mmaFrontPageHandlers
 */
.factory('$mmaFrontPageHandlers', ["$log", "$mmaFrontpage", function($log, $mmaFrontpage) {
    $log = $log.getInstance('$mmaFrontPageHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.frontpage
     * @ngdoc method
     * @name $mmaFrontPageHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Promise|Boolean} If handler is enabled returns a resolved promise. If it's not it can return a
         *                           rejected promise or false.
         */
        self.isEnabled = function() {
            if ($mmaFrontpage.isPluginEnabled()) {
                return $mmaFrontpage.isFrontpageAvailable().then(function() {
                    return true;
                });
            }
            return false;
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.frontpage
             * @ngdoc controller
             * @name $mmaFrontPageHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-home';
                $scope.title = 'mma.frontpage.sitehome';
                $scope.state = 'site.mm_course-section';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades')

/**
 * Controller to handle course grades.
 *
 * @module mm.addons.grades
 * @ngdoc controller
 * @name mmaGradesTableCtrl
 */
.controller('mmaGradesTableCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaGrades", "$mmSite", function($scope, $stateParams, $mmUtil, $mmaGrades, $mmSite) {

    var course = $stateParams.course || {},
        courseid = course.id,
        userid = $stateParams.userid || $mmSite.getUserId();

    function fetchGrades(refresh) {
        return $mmaGrades.getGradesTable(courseid, userid, refresh).then(function(table) {
            $scope.gradesTable = table;
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.errormessage = message;
        });
    }
    fetchGrades().then(function() {
        // Add log in Moodle.
        $mmSite.write('gradereport_user_view_grade_report', {
            courseid: courseid,
            userid: userid
        });
    })
    .finally(function() {
        $scope.gradesLoaded = true;
    });

    $scope.refreshGrades = function() {
        fetchGrades(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades')

/**
 * Service to handle grades.
 *
 * @module mm.addons.grades
 * @ngdoc service
 * @name $mmaGrades
 */
.factory('$mmaGrades', ["$q", "$log", "$mmSite", "$mmText", "$ionicPlatform", "$translate", "$mmCourse", "$mmCourses", "$mmSitesManager", function($q, $log, $mmSite, $mmText, $ionicPlatform, $translate, $mmCourse, $mmCourses, $mmSitesManager) {

    $log = $log.getInstance('$mmaGrades');

    var self = {};

    /**
     * Formats the response of gradereport_user_get_grades_table to be rendered.
     *
     * @param  {Object}  table      JSON object representing a table with data.
     * @param  {Boolean} showSimple True if simple table should be shown, false for full table.
     * @return {Object}             Formatted HTML table.
     */
    function formatGradesTable(table, showSimple) {
        var formatted = {
            columns: [],
            rows: []
        };

        if (!table || !table.tables) {
            return formatted;
        }

        // Columns, by order.
        var columns = [ "itemname", "weight", "grade", "range", "percentage", "lettergrade", "rank",
                        "average", "feedback", "contributiontocoursetotal"];
        var returnedColumns = [];

        var tabledata = [];
        var maxDepth = 0;
        // Check columns returned (maybe some of the above).
        if (table.tables && table.tables[0] && table.tables[0]['tabledata']) {
            tabledata = table.tables[0]['tabledata'];
            maxDepth = table.tables[0]['maxdepth'];
            for (var el in tabledata) {
                // This is a typical row.
                if (!angular.isArray(tabledata[el]) && typeof(tabledata[el]["leader"]) === "undefined") {
                    for (var col in tabledata[el]) {
                        returnedColumns.push(col);
                    }
                    break;
                }
            }
        }

        if (returnedColumns.length > 0) {

            // Reduce the returned columns for phone version.
            if (showSimple) {
                returnedColumns = ["itemname", "grade"];
            }

            for (var el in columns) {
                var colName = columns[el];
                if (returnedColumns.indexOf(colName) > -1) {
                    var width = colName == "itemname" ? maxDepth : 1;
                    var column = {
                        id: colName,
                        name: colName,
                        width: width
                    };
                    formatted.columns.push(column);
                }
            }

            var name, rowspan, tclass, colspan, content, celltype, id, headers,j, img, colspanVal;

            var len = tabledata.length;
            for (var i = 0; i < len; i++) {
                var row = '';
                if (typeof(tabledata[i]['leader']) != "undefined") {
                    rowspan = tabledata[i]['leader']['rowspan'];
                    tclass = tabledata[i]['leader']['class'];
                    row += '<td class="' + tclass + '" rowspan="' + rowspan + '"></td>';
                }
                for (el in returnedColumns) {
                    name = returnedColumns[el];

                    if (typeof(tabledata[i][name]) != "undefined") {
                        tclass = (typeof(tabledata[i][name]['class']) != "undefined")? tabledata[i][name]['class'] : '';
                        colspan = (typeof(tabledata[i][name]['colspan']) != "undefined")? "colspan='"+tabledata[i][name]['colspan']+"'" : '';
                        content = (typeof(tabledata[i][name]['content']) != "undefined")? tabledata[i][name]['content'] : null;
                        celltype = (typeof(tabledata[i][name]['celltype']) != "undefined")? tabledata[i][name]['celltype'] : 'td';
                        id = (typeof(tabledata[i][name]['id']) != "undefined")? "id='" + tabledata[i][name]['id'] +"'" : '';
                        headers = (typeof(tabledata[i][name]['headers']) != "undefined")? "headers='" + tabledata[i][name]['headers'] + "'" : '';

                        if (typeof(content) != "undefined") {
                            img = getImgHTML(content);
                            content = content.replace(/<\/span>/gi, "\n");
                            content = $mmText.cleanTags(content);
                            content = content.replace("\n", "<br />");
                            content = img + " " + content;

                            row += "<" + celltype + " " + id + " " + headers + " " + "class='"+ tclass +"' " + colspan +">";
                            row += content;
                            row += "</" + celltype + ">";
                        }
                    }
                }
                formatted.rows.push(row);
            }
        }

        return formatted;
    }

    /**
     * Gets the HTML code to render the contents img.
     *
     * @param  {String} text HTML where the image will be rendered.
     * @return {String}      HTML code to render the image.
     */
    function getImgHTML(text) {
        var img = '';

        if (text.indexOf("/agg_mean") > -1) {
            img = '<img src="addons/grades/img/agg_mean.png" width="16">';
        } else if (text.indexOf("/agg_sum") > -1) {
            img = '<img src="addons/grades/img/agg_sum.png" width="16">';
        } else if (text.indexOf("/outcomes") > -1) {
            img = '<img src="addons/grades/img/outcomes.png" width="16">';
        } else if (text.indexOf("i/folder") > -1) {
            img = '<img src="addons/grades/img/folder.png" width="16">';
        } else if (text.indexOf("/manual_item") > -1) {
            img = '<img src="addons/grades/img/manual_item.png" width="16">';
        } else if (text.indexOf("/mod/") > -1) {
            var module = text.match(/mod\/([^\/]*)\//);
            if (typeof module[1] != "undefined") {
                var moduleSrc = $mmCourse.getModuleIconSrc(module[1]);
                img = '<img src="' + moduleSrc + '" width="16">';
            }
        }
        if (img) {
            img = '<span class="app-ico">' + img + '</span>';
        }
        return img;
    }

    /**
     * Translates the names of the grades table columns.
     *
     * @param  {Object} table Grades table.
     * @return {Promise}      Promise to be resolved with the translated table.
     */
    function translateGradesTable(table) {
        var columns = angular.copy(table.columns),
            promises = [];

        columns.forEach(function(column) {
            var promise = $translate('mma.grades.'+column.name).then(function(translated) {
                column.name = translated;
            });
            promises.push(promise);
        });

        return $q.all(promises).then(function() {
            return {
                columns: columns,
                rows: table.rows
            };
        });
    };

    /**
     * Returns whether or not the plugin is enabled for a certain site.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGrades#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Boolean}         True if plugin is enabled, false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('gradereport_user_get_grades_table');
        });
    };

    /**
     * Returns whether or not the grade addon is enabled for a certain course.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGrades#isPluginEnabledForCourse
     * @param {Number} courseId  Course ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabledForCourse = function(courseId, siteId) {
        if (!courseId) {
            return $q.reject();
        }

        return $mmCourses.getUserCourse(courseId, true, siteId).then(function(course) {
            if (course && typeof course.showgrades != 'undefined' && !course.showgrades) {
                return false;
            }
            return true;
        });
    };

    /**
     * Get the grades for a certain course.
     * For now we only support gradereport_user_get_grades_table. It returns the complete grades table.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGrades#getGradesTable
     * @param {Number} courseid ID of the course to get the grades from.
     * @param {Number} userid   ID of the user to get the grades from.
     * @param {Boolean} refresh True when we should not get the value from the cache.
     * @return {Promise}        Promise to be resolved when the grades table is retrieved.
     */
    self.getGradesTable = function(courseid, userid, refresh) {

        $log.debug('Get grades for course ' + courseid + ' and user ' + userid);

        var data = {
                courseid : courseid,
                userid   : userid
            },
            presets = {};
        if (refresh) {
            presets.getFromCache = false;
        }

        return $mmSite.read('gradereport_user_get_grades_table', data, presets).then(function(table) {
            table = formatGradesTable(table, !$ionicPlatform.isTablet());
            return translateGradesTable(table);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades')

/**
 * Grades handlers factory.
 *
 * @module mm.addons.grades
 * @ngdoc service
 * @name $mmaGradesHandlers
 */
.factory('$mmaGradesHandlers', ["$mmaGrades", "$state", "$mmUtil", "$mmContentLinksHelper", "mmCoursesAccessMethods", function($mmaGrades, $state, $mmUtil, $mmContentLinksHelper, mmCoursesAccessMethods) {

    var self = {};

    /**
     * Course nav handler.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGradesHandlers#coursesNav
     */
    self.coursesNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Promise} Promise resolved with true if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaGrades.isPluginEnabled();
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Promise}          Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return $mmaGrades.isPluginEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function() {

            /**
             * Courses nav handler controller.
             *
             * @module mm.addons.grades
             * @ngdoc controller
             * @name $mmaGradesHandlers#coursesNav:controller
             */
            return function($scope, $state) {
                $scope.icon = 'ion-stats-bars';
                $scope.title = 'mma.grades.grades';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.grades', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    /**
     * View grades handler.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGradesHandlers#viewGrades
     */
    self.viewGrades = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Promise} Promise resolved with true if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaGrades.isPluginEnabled();
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User to check.
         * @param {Number} courseId Course ID.
         * @return {Promise}        Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
         */
        self.isEnabledForUser = function(user, courseId) {
            return $mmaGrades.isPluginEnabledForCourse(courseId);
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User.
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(user, courseId) {

            /**
             * View grades handler controller.
             *
             * @module mm.addons.grades
             * @ngdoc controller
             * @name $mmaGradesHandlers#viewGrades:controller
             */
            return function($scope) {
                $scope.title = 'mma.grades.viewgrades';

                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.grades', {
                        userid: user.id,
                        course: {id: courseId}
                    });
                };
            };

        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGradesHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site and course.
         *
         * @param  {String} siteId   Site ID.
         * @param  {Number} courseId Course ID.
         * @return {Promise}         Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaGrades.isPluginEnabled(siteId).then(function(enabled) {
                if (enabled) {
                    return $mmaGrades.isPluginEnabledForCourse(courseId, siteId);
                }
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        Promise resolved with the list of actions.
         *                           See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a grade URL.
            if (url.indexOf('/grade/report/user/index.php') > -1) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    var courseId = parseInt(params.id, 10);
                    // Pass false because all sites should have the same siteurl.
                    return $mmContentLinksHelper.filterSupportedSites(siteIds, isEnabled, false, courseId).then(function(ids) {
                        if (!ids.length) {
                            return [];
                        } else {
                            // Return actions.
                            return [{
                                message: 'mm.core.view',
                                icon: 'ion-eye',
                                sites: ids,
                                action: function(siteId) {
                                    var stateParams = {
                                        course: {id: courseId},
                                        userid: parseInt(params.userid, 10)
                                    };
                                    $mmContentLinksHelper.goInSite('site.grades', stateParams, siteId);
                                }
                            }];
                        }
                    });
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Contacts controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesContactsCtrl
 */
.controller('mmaMessagesContactsCtrl', ["$scope", "$mmaMessages", "$mmSite", "$mmUtil", "$mmApp", "mmUserProfileState", function($scope, $mmaMessages, $mmSite, $mmUtil, $mmApp, mmUserProfileState) {

    var currentUserId = $mmSite.getUserId();

    $scope.loaded = false;
    $scope.contactTypes = ['online', 'offline', 'blocked', 'strangers', 'search'];
    $scope.searchType = 'search';
    $scope.hasContacts = false;
    $scope.canSearch = $mmaMessages.isSearchEnabled;
    $scope.formData = {
        searchString: ''
    };
    $scope.userStateName = mmUserProfileState;

    $scope.refresh = function() {
        $mmaMessages.invalidateAllContactsCache(currentUserId).then(function() {
            return fetchContacts(true).then(function() {
                $scope.formData.searchString = '';
            });
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.search = function(query) {
        if (query.length < 3) {
            // The view should handle this case, but adding this check here to document that
            // we do not want users to query on less than 3 characters as they could retrieve
            // too many users!
            return;
        }

        $mmApp.closeKeyboard();

        $scope.loaded = false;
        return $mmaMessages.searchContacts(query).then(function(result) {
            $scope.hasContacts = result.length > 0;
            $scope.contacts = {
                search: result
            };
        }).catch(function(error) {
            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.errorwhileretrievingcontacts', true);
            }
        }).finally(function() {
            $scope.loaded = true;
        });
    };

    $scope.clearSearch = function() {
        $scope.loaded = false;
        fetchContacts().finally(function() {
            $scope.loaded = true;
        });
    };

    function fetchContacts() {
        return $mmaMessages.getAllContacts().then(function(contacts) {
            $scope.contacts = contacts;

            angular.forEach(contacts, function(contact) {
                if (contact.length > 0) {
                    $scope.hasContacts = true;
                }
            });
        }, function(error) {
            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.errorwhileretrievingcontacts', true);
            }
        });
    }
    fetchContacts().finally(function() {
        $scope.loaded = true;
    });
}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Discussion controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesDiscussionCtrl
 */
.controller('mmaMessagesDiscussionCtrl', ["$scope", "$stateParams", "$mmApp", "$mmaMessages", "$mmSite", "$timeout", "$mmEvents", "$window", "$ionicScrollDelegate", "mmUserProfileState", "$mmUtil", "mmaMessagesPollInterval", "$interval", "$log", "$ionicHistory", "$ionicPlatform", "mmCoreEventKeyboardShow", "mmCoreEventKeyboardHide", "mmaMessagesDiscussionLoadedEvent", "mmaMessagesDiscussionLeftEvent", "$mmUser", function($scope, $stateParams, $mmApp, $mmaMessages, $mmSite, $timeout, $mmEvents, $window,
        $ionicScrollDelegate, mmUserProfileState, $mmUtil, mmaMessagesPollInterval, $interval, $log, $ionicHistory, $ionicPlatform,
        mmCoreEventKeyboardShow, mmCoreEventKeyboardHide, mmaMessagesDiscussionLoadedEvent, mmaMessagesDiscussionLeftEvent,
        $mmUser) {

    $log = $log.getInstance('mmaMessagesDiscussionCtrl');

    var userId = $stateParams.userId,
        userFullname = $stateParams.userFullname,
        messagesBeingSent = 0,
        polling,
        backView = $ionicHistory.backView(),
        lastMessage,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaMessagesScroll');

    $scope.loaded = false;
    $scope.messages = [];
    $scope.userId = userId;
    $scope.currentUserId = $mmSite.getUserId();
    $scope.profileLink = true;

    if (userFullname) {
        $scope.title = userFullname;
    } else if (userId) {
        // We don't have the fullname, try to get it.
        $mmUser.getProfile(userId).then(function(user) {
            if (!$scope.title) {
                $scope.title = user.fullname;
            }
        });
    }

    // Disable the profile button if we're coming from a profile. It is safer to prevent forbid the access
    // to the full profile (we do not know the course ID they came from) as some users cannot view the full
    // profile of other users.
    if (backView && backView.stateName === mmUserProfileState) {
        $scope.profileLink = false;
    }

    $scope.isAppOffline = function() {
        return !$mmApp.isOnline();
    };

    $scope.showDate = function(message, prevMessage) {
        if (!prevMessage) {
            return true;
        }

        // Check if day has changed.
        return !moment(message.timecreated * 1000).isSame(prevMessage.timecreated * 1000, 'day');
    };

    $scope.sendMessage = function(text) {
        var message;
        if (!$mmApp.isOnline()) {
            // Silent error, the view should prevent this.
            return;
        } else if (!text.trim()) {
            // Silent error.
            return;
        }

        text = text.replace(/(?:\r\n|\r|\n)/g, '<br />');
        message = {
            sending: true,
            useridfrom: $scope.currentUserId,
            smallmessage: text,
            timecreated: ((new Date()).getTime() / 1000)
        };
        $scope.messages.push(message);

        messagesBeingSent++;
        $mmaMessages.sendMessage(userId, text).then(function() {
            message.sending = false;
            notifyNewMessage();
        }, function(error) {

            // Only close the keyboard if an error happens, we want the user to be able to send multiple
            // messages withoutthe keyboard being closed.
            $mmApp.closeKeyboard();

            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.messagenotsent', true);
            }
            $scope.messages.splice($scope.messages.indexOf(message), 1);
        }).finally(function() {
            messagesBeingSent--;
        });
    };

    // Fetch the messages for the first time.
    $mmaMessages.getDiscussion(userId).then(function(messages) {
        $scope.messages = $mmaMessages.sortMessages(messages);
        if (!userFullname && messages && messages.length > 0) {
            // When we did not receive the fullname via argument. Also it is possible that
            // we cannot resolve the name when no messages were yet exchanged.
            if (messages[0].useridto != $scope.currentUserId) {
                $scope.title = messages[0].usertofullname || '';
            } else {
                $scope.title = messages[0].userfromfullname || '';
            }
        }
        notifyNewMessage();
    }, function(error) {
        if (typeof error === 'string') {
            $mmUtil.showErrorModal(error);
        } else {
            $mmUtil.showErrorModal('mma.messages.errorwhileretrievingmessages', true);
        }
    }).finally(function() {
        $scope.loaded = true;
    });

    $scope.scrollAfterRender = function(scope) {
        if (scope.$last === true) {
            // Need a timeout to leave time to the view to be rendered.
            $timeout(function() {
                scrollView.scrollBottom();
                setScrollWithKeyboard();
            });
        }
    };

    // Set a polling to get new messages every certain time.
    function setPolling() {
        if (polling) {
            // We already have the polling in place.
            return;
        }

        // Start polling.
        polling = $interval(function() {
            $log.debug('Polling new messages for discussion with user ' + userId);
            if (messagesBeingSent > 0) {
                // We do not poll while a message is being sent or we could confuse the user
                // as his message would disappear from the list, and he'd have to wait for the
                // interval to check for new messages.
                return;
            } else if (!$mmApp.isOnline()) {
                // Obviously we cannot check for new messages when the app is offline.
                return;
            }

            // Invalidate the cache before fetching.
            $mmaMessages.invalidateDiscussionCache(userId);
            $mmaMessages.getDiscussion(userId).then(function(messages) {
                if (messagesBeingSent > 0) {
                    // Ignore polling if due to a race condition.
                    return;
                }
                $scope.messages = $mmaMessages.sortMessages(messages);
                notifyNewMessage();
            });
        }, mmaMessagesPollInterval);
    }

    // Unset polling.
    function unsetPolling() {
        if (polling) {
            $log.debug('Cancelling polling for conversation with user ' + userId);
            $interval.cancel(polling);
            polling = undefined;
        }
    }

    if ($ionicPlatform.isTablet()) {
        // Listen for events to set/unset the polling in tablet. We use angular events because we cannot use ionic events
        // (we use ui-view). The behavior is the same, since scope is destroyed on tablet view when navigating to subviews.
        $scope.$on('$viewContentLoaded', function(){
            setPolling();
        });
        $scope.$on('$destroy', function(){
            unsetPolling();
        });
    } else {
        // Listen for events to set/unset the polling in phones. We can use ionic events.
        $scope.$on('$ionicView.enter', function() {
            setPolling();
        });
        $scope.$on('$ionicView.leave', function(e) {
            unsetPolling();
        });

    }

    // Notify the last message found so discussions list controller can tell if last message should be updated.
    function notifyNewMessage() {
        var last = $scope.messages[$scope.messages.length - 1];
        if (last && last.smallmessage !== lastMessage) {
            lastMessage = last.smallmessage;
            $mmEvents.trigger($mmaMessages.getDiscussionEventName(userId), {
                message: lastMessage,
                timecreated: last.timecreated
            });
        }
    }

    // Scroll when keyboard is hide/shown to keep the user scroll. This is only needed for Android.
    function setScrollWithKeyboard() {
        if (ionic.Platform.isAndroid()) {
            $timeout(function() { // Use a $timeout to wait for scroll to correctly measure height.
                var obsShow,
                    obsHide,
                    keyboardHeight,
                    maxInitialScroll = scrollView.getScrollView().__contentHeight - scrollView.getScrollView().__clientHeight,
                    initialHeight = $window.innerHeight;

                obsShow = $mmEvents.on(mmCoreEventKeyboardShow, function(e) {
                    $timeout(function() {
                        // Try to calculate keyboard height ourselves since e.keyboardHeight is not reliable.
                        var heightDifference = initialHeight - $window.innerHeight,
                            newKeyboardHeight = heightDifference > 50 ? heightDifference : e.keyboardHeight;
                        if (newKeyboardHeight) {
                            keyboardHeight = newKeyboardHeight;
                            scrollView.scrollBy(0, newKeyboardHeight);
                        }
                    });
                });

                obsHide = $mmEvents.on(mmCoreEventKeyboardHide, function(e) {
                    if (!scrollView || !scrollView.getScrollPosition()) {
                        return; // Can't get scroll position, stop.
                    }

                    if (scrollView.getScrollPosition().top >= maxInitialScroll) {
                        // scrollBy(0,0) would automatically reset at maxInitialScroll. We need to apply the difference
                        // from there to scroll to the right point.
                        scrollView.scrollBy(0, scrollView.getScrollPosition().top - keyboardHeight - maxInitialScroll);
                    } else {
                        scrollView.scrollBy(0, - keyboardHeight);
                    }
                });

                $scope.$on('$destroy', function() {
                    obsShow && obsShow.off && obsShow.off();
                    obsHide && obsHide.off && obsHide.off();
                });
            });
        }
    }

    if ($ionicPlatform.isTablet()) {
        $mmEvents.trigger(mmaMessagesDiscussionLoadedEvent, userId);
    }
    $scope.$on('$destroy', function() {
        if ($ionicPlatform.isTablet()) {
            $mmEvents.trigger(mmaMessagesDiscussionLeftEvent);
        }
    });

}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Discussions controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesDiscussionsCtrl
 */
.controller('mmaMessagesDiscussionsCtrl', ["$q", "$state", "$scope", "$mmUtil", "$mmaMessages", "$rootScope", "$mmEvents", "mmCoreSplitViewLoad", function($q, $state, $scope, $mmUtil, $mmaMessages, $rootScope, $mmEvents,
            mmCoreSplitViewLoad) {
    var observers = [];

    $scope.loaded = false;

    // Set observers to watch for new messages on discussions. If a user sees a new message in a discussion, we'll update
    // the discussion's last message in discussions list.
    function setObservers(discussions) {
        clearObservers();

        angular.forEach(discussions, function(discussion) {
            observers.push($mmEvents.on($mmaMessages.getDiscussionEventName(discussion.message.user), function(data) {
                if (data && data.timecreated > discussion.message.timecreated) {
                    discussion.message.message = data.message;
                    discussion.message.timecreated = data.timecreated;
                }
            }));
        });
    }

    // Clear observers.
    function clearObservers() {
        angular.forEach(observers, function(observer) {
            if (observer && observer.off) {
                observer.off();
            }
        });
    }

    function fetchDiscussions() {
        return $mmaMessages.getDiscussions().then(function(discussions) {
            // Convert to an array for sorting.
            var array = [];
            angular.forEach(discussions, function(v) {
                array.push(v);
            });
            $scope.discussions = array;
            setObservers(array);
        }, function(error) {
            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.errorwhileretrievingdiscussions', true);
            }
        });
    }

    $scope.refresh = function() {
        $mmaMessages.invalidateDiscussionsCache().then(function() {
            return fetchDiscussions();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    fetchDiscussions().finally(function() {
        $scope.loaded = true;
        // Tell mm-split-view that it can load the first link now in tablets. We need to do it
        // like this because the directive doesn't have access to $scope.loaded variable (because of tabs).
        $rootScope.$broadcast(mmCoreSplitViewLoad);
    });

    $scope.$on('$destroy', function() {
        clearObservers();
    });
}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Messages index controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesIndexCtrl
 */
.controller('mmaMessagesIndexCtrl', ["$scope", "$mmEvents", "$ionicPlatform", "$ionicTabsDelegate", "mmaMessagesDiscussionLoadedEvent", "mmaMessagesDiscussionLeftEvent", function($scope, $mmEvents, $ionicPlatform, $ionicTabsDelegate,
            mmaMessagesDiscussionLoadedEvent, mmaMessagesDiscussionLeftEvent) {
    // Listen for discussion loaded event to show user profile link in tablet view.
    var obsLoaded = $mmEvents.on(mmaMessagesDiscussionLoadedEvent, function(userId) {
        $scope.profileLink = $ionicPlatform.isTablet() && $ionicTabsDelegate.selectedIndex() == 0;
        $scope.userId = userId;
    });

    // Listen for discussion loaded event to show user profile link in tablet view.
    var obsLeft = $mmEvents.on(mmaMessagesDiscussionLeftEvent, function() {
        $scope.profileLink = false;
    });

    $scope.$on('$destroy', function() {
        if (obsLoaded && obsLoaded.off) {
            obsLoaded.off();
        }
        if (obsLeft && obsLeft.off) {
            obsLeft.off();
        }
    });
}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Filter to format a message.
 *
 * @module mma.messages
 * @ngdoc filter
 * @name mmaMessagesFormat
 */
.filter('mmaMessagesFormat', ["$mmText", function($mmText) {
  return function(text) {
    text = text.replace(/-{4,}/ig, '');
    text = text.replace(/<br \/><br \/>/ig, "<br />");
    text = $mmText.replaceNewLines(text, '<br />');
    return text;
  };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Messages handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.messages
 * @ngdoc service
 * @name $mmaMessagesHandlers
 */
.factory('$mmaMessagesHandlers', ["$log", "$mmaMessages", "$mmSite", "$state", "$mmUtil", "$mmContentLinksHelper", function($log, $mmaMessages, $mmSite, $state, $mmUtil, $mmContentLinksHelper) {
    $log = $log.getInstance('$mmaMessagesHandlers');

    var self = {};

    /**
     * Add contact handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#addContact
     */
    self.addContact = function() {

        var self = {};

        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        self.isEnabledForUser = function(user, courseId) {
            return user.id != $mmSite.getUserId();
        };

        /**
         * Add contact handler controller.
         *
         * @module mm.addons.messages
         * @ngdoc controller
         * @name $mmaMessagesHandlers#blockContact:controller
         */
        self.getController = function(user, courseid) {

            return function($scope, $rootScope) {
                var disabled = false;

                function updateTitle() {
                    return $mmaMessages.isContact(user.id).then(function(isContact) {
                        if (isContact) {
                            $scope.title = 'mma.messages.removecontact';
                        } else {
                            $scope.title = 'mma.messages.addcontact';
                        }
                    }).catch(function() {
                        // This fails for some reason, let's just hide the button.
                        $scope.hidden = true;
                    });
                }

                $scope.title = '';
                $scope.spinner = false;
                $scope.action = function($event) {
                    if (disabled) {
                        return;
                    }
                    disabled = true;
                    $scope.spinner = true;
                    $mmaMessages.isContact(user.id).then(function(isContact) {
                        if (isContact) {
                            return $mmaMessages.removeContact(user.id);
                        } else {
                            return $mmaMessages.addContact(user.id);
                        }
                    }).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    }).finally(function() {
                        $rootScope.$broadcast('mmaMessagesHandlers:addUpdated');
                        updateTitle().finally(function() {
                            disabled = false;
                            $scope.spinner = false;
                        });
                    });
                };

                $scope.$on('mmaMessagesHandlers:blockUpdated', function() {
                    updateTitle();
                });

                updateTitle();

            };

        };

        return self;
    };

    /**
     * Block contact handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#blockContact
     */
    self.blockContact = function() {

        var self = {};

        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        self.isEnabledForUser = function(user, courseId) {
            return user.id != $mmSite.getUserId();
        };

        self.getController = function(user, courseid) {

            /**
             * Block contact handler controller.
             *
             * @module mm.addons.messages
             * @ngdoc controller
             * @name $mmaMessagesHandlers#blockContact:controller
             */
            return function($scope, $rootScope) {
                var disabled = false;

                function updateTitle() {
                    return $mmaMessages.isBlocked(user.id).then(function(isBlocked) {
                        if (isBlocked) {
                            $scope.title = 'mma.messages.unblockcontact';
                        } else {
                            $scope.title = 'mma.messages.blockcontact';
                        }
                    }).catch(function() {
                        // This fails for some reason, let's just hide the button.
                        $scope.hidden = true;
                    });
                }

                $scope.title = '';
                $scope.spinner = false;
                $scope.action = function($event) {
                    if (disabled) {
                        return;
                    }
                    disabled = true;
                    $scope.spinner = true;
                    $mmaMessages.isBlocked(user.id).then(function(isBlocked) {
                        if (isBlocked) {
                            return $mmaMessages.unblockContact(user.id);
                        } else {
                            return $mmaMessages.blockContact(user.id);
                        }
                    }).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    }).finally(function() {
                        $rootScope.$broadcast('mmaMessagesHandlers:blockUpdated');
                        updateTitle().finally(function() {
                            disabled = false;
                            $scope.spinner = false;
                        });
                    });
                };

                $scope.$on('mmaMessagesHandlers:addUpdated', function() {
                    updateTitle();
                });

                updateTitle();

            };

        };

        return self;
    };

    /**
     * Send message handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#blockContact
     */
    self.sendMessage = function() {

        var self = {};

        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        self.isEnabledForUser = function(user, courseId) {
            return user.id != $mmSite.getUserId();
        };

        self.getController = function(user, courseid) {

            /**
             * Send message handler controller.
             *
             * @module mm.addons.messages
             * @ngdoc controller
             * @name $mmaMessagesHandlers#sendMessage:controller
             */
            return function($scope) {
                $scope.title = 'mma.messages.sendmessage';
                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.messages-discussion', {
                        userId: user.id,
                        userFullname: user.fullname
                    });
                };
            };

        };

        return self;
    };

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.messages
             * @ngdoc controller
             * @name $mmaMessagesHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-chatbox';
                $scope.title = 'mma.messages.messages';
                $scope.state = 'site.messages';
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId Site ID.
         * @return {Promise}       Promise resolved with true if enabled.
         */
        function isEnabledForSite(siteId) {
            return $mmaMessages.isPluginEnabled(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        Promise resolved with the list of actions.
         *                           See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a messages URL.
            if (url.indexOf('/message/index.php') > -1) {
                // Pass false because all sites should have the same siteurl.
                return $mmContentLinksHelper.filterSupportedSites(siteIds, isEnabledForSite, false).then(function(ids) {
                    if (!ids.length) {
                        return [];
                    } else {
                        // Return actions.
                        var params = $mmUtil.extractUrlParams(url);
                        return [{
                            message: 'mm.core.view',
                            icon: 'ion-eye',
                            sites: ids,
                            action: function(siteId) {
                                var stateName,
                                    stateParams;

                                if (typeof params.user1 != 'undefined' && typeof params.user2 != 'undefined') {
                                    // Check if the current user is in the conversation.
                                    if ($mmSite.getUserId() == params.user1) {
                                        stateName = 'site.messages-discussion';
                                        stateParams = {userId: parseInt(params.user2, 10)};
                                    } else if ($mmSite.getUserId() == params.user2) {
                                        stateName = 'site.messages-discussion';
                                        stateParams = {userId: parseInt(params.user1, 10)};
                                    } else {
                                        // He isn't, open in browser.
                                        $mmUtil.openInBrowser(url);
                                        return;
                                    }
                                } else if (typeof params.id != 'undefined') {
                                    stateName = 'site.messages-discussion';
                                    stateParams = {userId: parseInt(params.id, 10)};
                                }

                                if (!stateName) {
                                    // Go to messaging index page. We use redirect state to view the side menu.
                                    $state.go('redirect', {
                                        siteid: siteId,
                                        state: 'site.messages',
                                        params: {}
                                    });
                                } else {
                                    $mmContentLinksHelper.goInSite(stateName, stateParams, siteId);
                                }
                            }
                        }];
                    }
                });
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Messages factory.
 *
 * @module mm.addons.messages
 * @ngdoc service
 * @name $mmaMessages
 */
.factory('$mmaMessages', ["$mmSite", "$mmSitesManager", "$log", "$q", "$mmUser", "mmaMessagesNewMessageEvent", function($mmSite, $mmSitesManager, $log, $q, $mmUser, mmaMessagesNewMessageEvent) {
    $log = $log.getInstance('$mmaMessages');

    var self = {};

    /**
     * Add a contact.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#addContact
     * @param {Number} to User ID of the person to add.
     * @return {Promise}
     */
    self.addContact = function(userId) {
        return $mmSite.write('core_message_create_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };

    /**
     * Block a contact.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#blockContact
     * @param {Number} to User ID of the person to block.
     * @return {Promise}
     */
    self.blockContact = function(userId) {
        return $mmSite.write('core_message_block_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };

    /**
     * Get all the contacts of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getAllContacts
     * @return {Promise} Resolved with the WS data.
     */
    self.getAllContacts = function() {
        return self.getContacts().then(function(contacts) {
            return self.getBlockedContacts().then(function(blocked) {
                contacts.blocked = blocked.users;
                storeUsersFromAllContacts(contacts);
                return contacts;
            }, function() {
                // The WS for blocked contacts might not be available yet, but we still want the contacts.
                contacts.blocked = [];
                storeUsersFromAllContacts(contacts);
                return contacts;
            });
        });
    };

    /**
     * Get all the blocked contacts of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getBlockedContacts
     * @return {Promise} Resolved with the WS data.
     */
    self.getBlockedContacts = function() {
        var params = {
                userid: $mmSite.getUserId()
            },
            presets = {
                cacheKey: self._getCacheKeyForBlockedContacts($mmSite.getUserId())
            },
            deferred;

        if (!$mmSite.wsAvailable('core_message_get_blocked_users')) {
            // If the WS is not available, we mock an empty response.
            deferred = $q.defer();
            deferred.resolve({users: [], warnings: []});
            return deferred.promise;
        }

        return $mmSite.read('core_message_get_blocked_users', params, presets);
    };

    /**
     * Get the cache key for contacts.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForContacts
     * @return {String}
     * @protected
     */
    self._getCacheKeyForContacts = function() {
        // Note: the contacts WS does not take arguments, so we do not need any here.
        return 'mmaMessages:contacts';
    };

    /**
     * Get the cache key for blocked contacts.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForBlockedContacts
     * @param {Number} userId The user who's contacts we're looking for.
     * @return {String}
     * @protected
     */
    self._getCacheKeyForBlockedContacts = function(userId) {
        return 'mmaMessages:blockedContacts:' + userId;
    };

    /**
     * Get the cache key for a discussion.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForDiscussion
     * @param {Number} userId The other person with whom the current user is having the discussion.
     * @return {String}
     * @protected
     */
    self._getCacheKeyForDiscussion = function(userId) {
        return 'mmaMessages:discussion:' + userId;
    };

    /**
     * Get the cache key for the list of discussions.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForDiscussions
     * @return {String}
     * @protected
     */
    self._getCacheKeyForDiscussions = function() {
        return 'mmaMessages:discussions';
    };

    /**
     * Get the cache key for the messaging enabled call.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForEnabled
     * @return {String}
     * @protected
     */
    self._getCacheKeyForEnabled = function() {
        return 'mmaMessages:enabled';
    };

    /**
     * Get the contacts of the current user.
     *
     * This excludes the blocked users.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getContacts
     * @return {Promise} Resolved with the WS data.
     */
    self.getContacts = function() {
        var presets = {
                cacheKey: self._getCacheKeyForContacts()
            };
        return $mmSite.read('core_message_get_contacts', undefined, presets);
    };

    /**
     * Get the name of the events of a discussion.
     *
     * @param  {Number} userid User ID of the discussion.
     * @return {String}        Name of the event.
     */
    self.getDiscussionEventName = function(userid) {
        return mmaMessagesNewMessageEvent + '_' + $mmSite.getUserId() + '_' + userid;
    }

    /**
     * Return the current user's discussion with another user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getDiscussion
     * @param {Number} userId The ID of the other user.
     * @return {Promise}
     */
    self.getDiscussion = function(userId) {
        var messages,
            presets = {
                cacheKey: self._getCacheKeyForDiscussion(userId)
            },
            params = {
                useridto: $mmSite.getUserId(),
                useridfrom: userId,
                limitfrom: 0,
                limitnum: 50
            };

        return self._getRecentMessages(params, presets).then(function(response) {
            messages = response;
            params.useridto = userId;
            params.useridfrom = $mmSite.getUserId();

            return self._getRecentMessages(params, presets).then(function(response) {
                return messages.concat(response);
            });
        });
    };

    /**
     * Get the discussions of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getDiscussions
     * @return {Promise} Resolved with an object where the keys are the user ID of the other user.
     */
    self.getDiscussions = function() {
        var discussions = {},
            presets = {
                cacheKey: self._getCacheKeyForDiscussions()
            },
            promise;

        return self._getRecentMessages({
            useridto: $mmSite.getUserId(),
            useridfrom: 0,
            limitfrom: 0,
            limitnum: 50
        }, presets).then(function(messages) {

            // Extract the discussions by filtering same senders.
            angular.forEach(messages, function(message) {
                if (typeof discussions[message.useridfrom] === 'undefined') {
                    discussions[message.useridfrom] = {
                        fullname: message.userfromfullname,
                        profileimageurl: ""
                    };

                    if (!message.timeread) {
                        discussions[message.useridfrom].unread = true;
                    }
                }

                // Extract the most recent message.
                if (typeof discussions[message.useridfrom].message === 'undefined' ||
                        discussions[message.useridfrom].message.timecreated < message.timecreated) {

                    discussions[message.useridfrom].message = {
                        user: message.useridfrom,
                        message: message.smallmessage,
                        timecreated: message.timecreated
                    };
                }
            });

            // Now get the last messages sent from which we might not have received a reply yet.
            return self._getRecentMessages({
                useridfrom: $mmSite.getUserId(),
                useridto: 0,
                limitfrom: 0,
                limitnum: 50
            }, presets).then(function(messages) {

                // Extract the discussions by filtering same senders.
                angular.forEach(messages, function(message) {
                    if (typeof discussions[message.useridto] === 'undefined') {
                        discussions[message.useridto] = {
                            fullname: message.usertofullname,
                            profileimageurl: ""
                        };

                        if (!message.timeread) {
                            discussions[message.useridto].unread = true;
                        }
                    }

                    // Extract the most recent message.
                    if (typeof discussions[message.useridto].message === 'undefined' ||
                            discussions[message.useridto].message.timecreated < message.timecreated) {

                        discussions[message.useridto].message = {
                            user: message.useridto,
                            message: message.smallmessage,
                            timecreated: message.timecreated
                        };
                    }
                });

                // Now get the contacts
                return self.getContacts().then(function(contacts) {
                    var types = ['online', 'offline', 'strangers'];

                    angular.forEach(types, function(type) {
                        if (contacts[type] && contacts[type].length > 0) {
                            angular.forEach(contacts[type], function(contact) {

                                if (typeof discussions[contact.id] === 'undefined' && contact.unread) {
                                    // It's a contact with unread messages. Contacts without unread messages are not used.
                                    discussions[contact.id] = {
                                        fullname: contact.fullname,
                                        profileimageurl: "",
                                        message: {
                                            user: contact.id,
                                            message: "...",
                                            timecreated: 0,
                                        }
                                    };
                                }

                                if (typeof discussions[contact.id] !== 'undefined') {
                                    // The contact is used in a discussion.
                                    if (contact.profileimageurl) {
                                        discussions[contact.id].profileimageurl = contact.profileimageurl;
                                    }
                                    if (typeof contact.unread !== 'undefined') {
                                        discussions[contact.id].unread = contact.unread;
                                    }
                                }
                            });
                        }
                    });

                    return self.getDiscussionsUserImg(discussions).then(function(discussions) {
                        storeUsersFromDiscussions(discussions);
                        return discussions;
                    });
                });
            });
        });
    };

    /**
     * Get user images for all the discussions that don't have one already.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getDiscussionsUserImg
     * @param {Object[]} discussions List of discussions.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted discussions.
     */
    self.getDiscussionsUserImg = function(discussions) {
        var promises = [];

        angular.forEach(discussions, function(discussion) {
            if (!discussion.profileimageurl) {
                // We don't have the user image. Try to retrieve it.
                var promise = $mmUser.getProfile(discussion.message.user, 1, true).then(function(user) {
                    discussion.profileimageurl = user.profileimageurl;
                }, function() {
                    // Error getting profile, resolve promise without adding any extra data.
                });
                promises.push(promise);
            }
        });
        return $q.all(promises).then(function() {
            return discussions;
        });
    };

    /**
     * Get messages according to the params.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getMessages
     * @param {Object} params Parameters to pass to the WS.
     * @param {Object} presets Set of presets for the WS.
     * @return {Promise}
     * @protected
     */
    self._getMessages = function(params, presets) {
        params = angular.extend(params, {
            type: 'conversations',
            newestfirst: 1,
        });

        return $mmSite.read('core_message_get_messages', params, presets);
    };

    /**
     * Get the most recent messages.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getRecentMessages
     * @param {Object} params Parameters to pass to the WS.
     * @param {Object} presets Set of presets for the WS.
     * @return {Promise}
     * @protected
     */
    self._getRecentMessages = function(params, presets) {
        params = angular.extend(params, {
            read: 0
        });

        return self._getMessages(params, presets).then(function(response) {
            var messages = response.messages;
            if (messages) {
                if (messages.length >= params.limitnum) {
                    return messages;
                }

                // We need to fetch more messages.
                params.limitnum = params.limitnum - messages.length;
                params.read = 1;

                return self._getMessages(params, presets).then(function(response) {
                    if (response.messages) {
                        messages = messages.concat(response.messages);
                    }
                    return messages;
                }, function() {
                    return messages;
                });

            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Invalidate all contacts cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateAllContactsCache
     * @param {Number} userId The user ID.
     * @return {Promise}
     */
    self.invalidateAllContactsCache = function(userId) {
        return self.invalidateContactsCache().then(function() {
            return self.invalidateBlockedContactsCache(userId);
        });
    };

    /**
     * Invalidate blocked contacts cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateBlockedContactsCache
     * @param {Number} userId The user ID.
     * @return {Promise}
     */
    self.invalidateBlockedContactsCache = function(userId) {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForBlockedContacts(userId));
    };


    /**
     * Invalidate contacts cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateContactsCache
     * @return {Promise}
     */
    self.invalidateContactsCache = function() {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForContacts());
    };

    /**
     * Invalidate discussion cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateDiscussionCache
     * @param {Number} userId The user ID with whom the current user is having the discussion.
     * @return {Promise}
     */
    self.invalidateDiscussionCache = function(userId) {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForDiscussion(userId));
    };

    /**
     * Invalidate discussions cache.
     *
     * Note that {@link $mmaMessages#getDiscussions} uses the contacts, so we need to invalidate contacts too.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateDiscussionsCache
     * @return {Promise}
     */
    self.invalidateDiscussionsCache = function(userId) {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForDiscussions()).then(function(){
            return self.invalidateContactsCache();
        });
    };

    /**
     * Invalidate messaging enabled cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateEnabledCache
     * @return {Promise}
     */
    self.invalidateEnabledCache = function() {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForEnabled());
    };

    /**
     * Checks if the a user is blocked by the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isBlocked
     * @param {Number} userId The user ID to check against.
     * @return {Promise} Resolved with boolean, rejected when we do not know.
     */
    self.isBlocked = function(userId) {
        return self.getBlockedContacts().then(function(blockedContacts) {
            var blocked = false;
            if (!blockedContacts.users || blockedContacts.users.length < 1) {
                return blocked;
            }
            angular.forEach(blockedContacts.users, function(user) {
                if (userId == user.id) {
                    blocked = true;
                }
            });
            return blocked;
        });
    };

    /**
     * Checks if the a user is a contact of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isContact
     * @param {Number} userId The user ID to check against.
     * @return {Promise} Resolved with boolean, rejected when we do not know.
     */
    self.isContact = function(userId) {
        return self.getContacts().then(function(contacts) {
            var isContact = false,
                types = ['online', 'offline'];

            angular.forEach(types, function(type) {
                if (contacts[type] && contacts[type].length > 0) {
                    angular.forEach(contacts[type], function(user) {
                        if (userId == user.id) {
                            isContact = true;
                        }
                    });
                }
            });

            return isContact;
        });
    };

    /**
     * Returns whether or not messaging is enabled for the current site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_isMessagingEnabled
     * @return {Promise} Resolved when enabled, otherwise rejected.
     * @protected
     */
    self._isMessagingEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var enabled = site.canUseAdvancedFeature('messaging', 'unknown');

            if (enabled === 'unknown') {
                // On older version we cannot check other than calling a WS. If the request
                // fails there is a very high chance that messaging is disabled.
                $log.debug('Using WS call to check if messaging is enabled.');
                return site.read('core_message_search_contacts', {
                    searchtext: 'CheckingIfMessagingIsEnabled',
                    onlymycourses: 0
                }, {
                    emergencyCache: false,
                    cacheKey: self._getCacheKeyForEnabled()
                });
            }

            if (enabled) {
                return true;
            }
            return $q.reject();
        });
    };

   /**
     * Returns whether or not messaging is enabled for a certain site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isMessagingEnabledForSite
     * @param {String} siteid Site ID.
     * @return {Promise}      Resolved when enabled, otherwise rejected.
     */
    self.isMessagingEnabledForSite = function(siteid) {
        return $mmSitesManager.getSite(siteid).then(function(site) {
            if (!site.canUseAdvancedFeature('messaging') || !site.wsAvailable('core_message_get_messages')) {
                return $q.reject();
            }

            // On older version we cannot check other than calling a WS. If the request
            // fails there is a very high chance that messaging is disabled.
            $log.debug('Using WS call to check if messaging is enabled.');
            return site.read('core_message_search_contacts', {
                searchtext: 'CheckingIfMessagingIsEnabled',
                onlymycourses: 0
            }, {
                emergencyCache: false,
                cacheKey: self._getCacheKeyForEnabled()
            });
        });
    };

    /**
     * Returns whether or not the plugin is enabled in a certain site.
     *
     * Do not abuse this method.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canUseAdvancedFeature('messaging')) {
                return false;
            } else if (!site.wsAvailable('core_message_get_messages')) {
                return false;
            } else {
                return self._isMessagingEnabled(siteId).then(function() {
                    return true;
                });
            }
        });
    };

    /**
     * Returns whether or not we can search contacts.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isSearchEnabled
     * @return {Boolean}
     */
    self.isSearchEnabled = function() {
        return $mmSite.wsAvailable('core_message_search_contacts');
    };

    /**
     * Remove a contact.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#removeContact
     * @param {Number} to User ID of the person to remove.
     * @return {Promise}
     */
    self.removeContact = function(userId) {
        return $mmSite.write('core_message_delete_contacts', {
            userids: [ userId ]
        }, {
            responseExpected: false
        }).then(function() {
            return self.invalidateContactsCache();
        });
    };

    /**
     * Search for contacts.
     *
     * By default this only returns the first 100 contacts, but note that the WS can return thousands
     * of results which would take a while to process. The limit here is just a convenience to
     * prevent viewed to crash because too many DOM elements are created.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#searchContacts
     * @param {String} query The query string.
     * @param {Number} [limit=100] The number of results to return, 0 for none.
     * @return {Promise}
     */
    self.searchContacts = function(query, limit) {
        var data = {
                searchtext: query,
                onlymycourses: 0
            };
        limit = typeof limit === 'undefined' ? 100 : limit;
        return $mmSite.read('core_message_search_contacts', data).then(function(contacts) {
            if (limit && contacts.length > limit) {
                contacts = contacts.splice(0, limit);
            }
            $mmUser.storeUsers(contacts);
            return contacts;
        });
    };

    /**
     * Send a message to someone.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#sendMessage
     * @param {Number} to User ID to send the message to.
     * @param {String} message The message to send
     * @return {Promise}
     */
    self.sendMessage = function(to, message) {
        return $mmSite.write('core_message_send_instant_messages', {
            messages: [
                {
                    touserid: to,
                    text: message,
                    textformat: 1
                }
            ]
        }).then(function(response) {
            if (response && response[0] && response[0].msgid === -1) {
                // There was an error, and it should be translated already.
                return $q.reject(response[0].errormessage);
            }
            return self.invalidateDiscussionCache(to);
        });
    };

    /**
     * Helper method to sort messages by time.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#sortMessages
     * @param {Object[]} messages Array of messages containing the key 'timecreated'.
     * @return {Object[]} Messages sorted with most recent last.
     */
    self.sortMessages = function(messages) {
        return messages.sort(function (a, b) {
            a = parseInt(a.timecreated, 10);
            b = parseInt(b.timecreated, 10);
            return a >= b ? 1 : -1;
        });
    };

    /**
     * Store user data from contacts in local DB.
     *
     * @param {Object[]} contactTypes List of contacts grouped in types.
     */
    function storeUsersFromAllContacts(contactTypes) {
        angular.forEach(contactTypes, function(contacts) {
            $mmUser.storeUsers(contacts);
        });
    }

    /**
     * Store user data from discussions in local DB.
     *
     * @param {Object[]} discussions List of discussions.
     */
    function storeUsersFromDiscussions(discussions) {
        angular.forEach(discussions, function(discussion, userid) {
            if (typeof userid != 'undefined' && !isNaN(parseInt(userid))) {
                $mmUser.storeUser(userid, discussion.fullname, discussion.profileimageurl);
            }
        });
    }

    /**
     * Unblock a user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#unblockContact
     * @param {Number} to User ID of the person to unblock.
     * @return {Promise}
     */
    self.unblockContact = function(userId) {
        return $mmSite.write('core_message_unblock_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Assign index controller.
 *
 * @module mm.addons.mod_assign
 * @ngdoc controller
 * @name mmaModAssignIndexCtrl
 */
.controller('mmaModAssignIndexCtrl', ["$scope", "$stateParams", "$mmaModAssign", "$mmUtil", "$translate", "mmaModAssignComponent", "mmaModAssignSubmissionComponent", function($scope, $stateParams, $mmaModAssign, $mmUtil, $translate,
        mmaModAssignComponent, mmaModAssignSubmissionComponent) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.assigncomponent = mmaModAssignComponent;
    $scope.submissioncomponent = mmaModAssignSubmissionComponent;
    $scope.assignurl = module.url;
    $scope.courseid = courseid;

    function fetchAssignment(refresh) {
        // Get assignment data.
        return $mmaModAssign.getAssignment(courseid, module.id, refresh).then(function(assign) {
            $scope.title = assign.name || $scope.title;
            $scope.description = assign.intro || $scope.description;
            $scope.assign = assign;

            // Get assignment submissions.
            return $mmaModAssign.getSubmissions(assign.id, refresh).then(function(data) {
                $scope.canviewsubmissions = data.canviewsubmissions;

                if (data.canviewsubmissions) {
                    // We want to show the user data on each submission.
                    return $mmaModAssign.getSubmissionsUserData(data.submissions, courseid).then(function(submissions) {
                        angular.forEach(submissions, function(submission) {
                            submission.text = $mmaModAssign.getSubmissionText(submission);
                            submission.attachments = $mmaModAssign.getSubmissionAttachments(submission);
                        });
                        $scope.submissions = submissions;
                    });
                }
            }, function() {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $translate('mm.core.error').then(function(error) {
                        $mmUtil.showErrorModal(error + ': get_assignment_submissions');
                    });
                }
            });
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $translate('mm.core.error').then(function(error) {
                    $mmUtil.showErrorModal(error + ': get_assignment');
                });
            }
        });
    }

    fetchAssignment().finally(function() {
        $scope.assignmentLoaded = true;
    });

    $scope.refreshAssignment = function() {
        fetchAssignment(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Assign submission controller.
 *
 * @module mm.addons.mod_assign
 * @ngdoc controller
 * @name mmaModAssignSubmissionCtrl
 */
.controller('mmaModAssignSubmissionCtrl', ["$scope", "$stateParams", "mmaModAssignSubmissionComponent", function($scope, $stateParams, mmaModAssignSubmissionComponent) {
    var submission = $stateParams.submission || {};

    $scope.title = submission.userfullname;
    $scope.submission = submission;
    $scope.component = mmaModAssignSubmissionComponent;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Assignments service.
 *
 * @module mm.addons.mod_assign
 * @ngdoc controller
 * @name $mmaModAssign
 */
.factory('$mmaModAssign', ["$mmSite", "$q", "$mmUser", "$mmSitesManager", function($mmSite, $q, $mmUser, $mmSitesManager) {
    var self = {};

    /**
     * Get an assignment.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getAssignment
     * @param {Number} courseid   Course ID the assignment belongs to.
     * @param {Number} cmid       Assignment module ID.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @return {Promise}          Promise resolved with the assignment.
     */
    self.getAssignment = function(courseid, cmid, refresh) {
        var params = {
                "courseids": [courseid]
            },
            preSets = {};

        if (refresh) {
            preSets.getFromCache = false;
        }

        return $mmSite.read('mod_assign_get_assignments', params, preSets).then(function(response) {
            if (response.courses && response.courses.length) {
                var assignments = response.courses[0].assignments;
                for (var i = 0; i < assignments.length; i++) {
                    if (assignments[i].cmid == cmid) {
                        return assignments[i];
                    }
                }
                return $q.reject();
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Get attachments of a submission.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissionAttachments
     * @param {Object} submission Submission.
     * @return {Object[]}         Submission attachments.
     */
    self.getSubmissionAttachments = function(submission) {
        var files = [];
        if (submission.plugins) {
            submission.plugins.forEach(function(plugin) {
                if (plugin.type === 'file' && plugin.fileareas && plugin.fileareas[0] && plugin.fileareas[0].files) {
                    files = plugin.fileareas[0].files;
                    angular.forEach(files, function(file) {
                        file.filename = file.filepath;
                    });
                }
            });
        }
        return files;
    };

    /**
     * Get text of a submission.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissionText
     * @param {Object} submission Submission.
     * @return {String}           Submission text.
     */
    self.getSubmissionText = function(submission) {
        var text = '';
        if (submission.plugins) {
            angular.forEach(submission.plugins, function(plugin) {
                if (plugin.type === 'onlinetext' && plugin.editorfields) {
                    text = plugin.editorfields[0].text;

                    // Online text contains '@@PLUGINFILE@@' for each embedded file. Replace those with the right URL.
                    if (plugin.fileareas && plugin.fileareas[0] && plugin.fileareas[0].files && plugin.fileareas[0].files[0]) {
                        var fileURL =  plugin.fileareas[0].files[0].fileurl;
                        fileURL = fileURL.substr(0, fileURL.lastIndexOf('/')).replace('pluginfile.php/', 'pluginfile.php?file=/');
                        text = text.replace(/@@PLUGINFILE@@/g, fileURL);
                    }
                }
            });
        }
        return text;
    };

    /**
     * Get an assignment submissions.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissions
     * @param {Number}  id        Assignment id.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @return {Promise}          Promise resolved with:
     *                                    - canviewsubmissions: True if user can view submissions, false otherwise.
     *                                    - submissions: Array of submissions.
     */
    self.getSubmissions = function(id, refresh) {
        var params = {
                "assignmentids": [id]
            },
            preSets = {};

        if (refresh) {
            preSets.getFromCache = false;
        }

        return $mmSite.read('mod_assign_get_submissions', params, preSets).then(function(response) {
            // Check if we can view submissions, with enough permissions.
            if (response.warnings.length > 0 && response.warnings[0].warningcode == 1) {
                return {canviewsubmissions: false};
            } else {
                if (response.assignments && response.assignments.length) {
                    return {
                        canviewsubmissions: true,
                        submissions: response.assignments[0].submissions
                    };
                } else {
                    return $q.reject();
                }
            }
        });
    };

    /**
     * Get user data for submissions since they only have userid.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissionsUserData
     * @param {Object[]} submissions Submissions to get the data for.
     * @param {Number}   courseid    ID of the course the submissions belong to.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted submissions.
     */
    self.getSubmissionsUserData = function(submissions, courseid) {
        var promises = [];

        angular.forEach(submissions, function(submission) {
            var promise = $mmUser.getProfile(submission.userid, courseid, true).then(function(user) {
                submission.userfullname = user.fullname;
                submission.userprofileimageurl = user.profileimageurl;
            }, function() {
                // Error getting profile, resolve promise without adding any extra data.
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return submissions;
        });
    };

    /**
     * Check if assignments plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('mod_assign_get_assignments') && site.wsAvailable('mod_assign_get_submissions');
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Mod assign handlers.
 *
 * @module mm.addons.mod_assign
 * @ngdoc service
 * @name $mmaModAssignHandlers
 */
.factory('$mmaModAssignHandlers', ["$mmCourse", "$mmaModAssign", "$state", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModAssign, $state, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssignHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for the site.
         *
         * @return {Promise}
         */
        self.isEnabled = function() {
            return $mmaModAssign.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('assign');
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_assign', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssignHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModAssign.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's an assign URL.
            if (url.indexOf('/mod/assign/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Book index controller.
 *
 * @module mm.addons.mod_book
 * @ngdoc controller
 * @name mmaModBookIndexCtrl
 */
.controller('mmaModBookIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModBook", "$log", "mmaModBookComponent", "$ionicPopover", "$mmApp", "$q", "$mmCourse", "$ionicScrollDelegate", function($scope, $stateParams, $mmUtil, $mmaModBook, $log, mmaModBookComponent,
            $ionicPopover, $mmApp, $q, $mmCourse, $ionicScrollDelegate) {
    $log = $log.getInstance('mmaModBookIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        currentChapter;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModBookComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;

    var chapters = $mmaModBook.getTocList(module.contents);
    currentChapter = $mmaModBook.getFirstChapter(chapters);

    // Convenience function to load a book chapter.
    function loadChapter(chapterId) {
        currentChapter = chapterId;
        $ionicScrollDelegate.scrollTop();
        return $mmaModBook.getChapterContent(module.contents, chapterId, module.id).then(function(content) {
            $scope.content = content;
            $scope.previousChapter = $mmaModBook.getPreviousChapter(chapters, chapterId);
            $scope.nextChapter = $mmaModBook.getNextChapter(chapters, chapterId);
        }).catch(function() {
            $mmUtil.showErrorModal('mma.mod_book.errorchapter', true);
            return $q.reject();
        }).finally(function() {
            $scope.loaded = true;
            $ionicScrollDelegate.resize(); // Call resize to recalculate scroll area.
        });
    }

    // Convenience function to download book contents and load the current chapter.
    function fetchContent(chapterId) {
        var downloadFailed = false;
        return $mmaModBook.downloadAllContent(module).catch(function() {
            // Mark download as failed but go on since the main files could have been downloaded.
            downloadFailed = true;
        }).finally(function() {
            // Show chapter.
            return loadChapter(chapterId).then(function() {
                if (downloadFailed && $mmApp.isOnline()) {
                    // We could load the main file but the download failed. Show error message.
                    $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                }
            });
        });
    }

    $scope.doRefresh = function() {
        $mmaModBook.invalidateContent(module.id).then(function() {
            return fetchContent(currentChapter);
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Function to load a chapter.
    $scope.loadChapter = function(chapterId) {
        $scope.popover.hide();
        $scope.loaded = false;
        loadChapter(chapterId);
    };

    // Menu popover.
    $scope.toc = chapters;
    $ionicPopover.fromTemplateUrl('addons/mod_book/templates/toc.html', {
        scope: $scope,
    }).then(function(popover) {
        $scope.popover = popover;
    });


    fetchContent(currentChapter).then(function() {
        $mmaModBook.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Directive to navigate to previous/next chapter in a book.
 *
 * @module mm.addons.mod_book
 * @ngdoc directive
 * @name mmaModBookArrows
 * @description
 * This directive will show two arrows at the left and right of the screen to navigate to previous/next book chapter when
 * clicked. If no previous/next chapter is defined, that arrow won't be shown.
 *
 * @param {Number}   previous ID of the previous chapter.
 * @param {Number}   next     ID of the next chapter.
 * @param {Function} action   Function to call when an arrow is clicked. Will receive as a param the chapterId to load.
 */
.directive('mmaModBookArrows', function() {
    return {
        restrict: 'E',
        scope: {
            previous: '=?',
            next: '=?',
            action: '=?'
        },
        templateUrl: 'addons/mod_book/templates/arrows.html'
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Book factory.
 *
 * @module mm.addons.mod_book
 * @ngdoc service
 * @name $mmaModBook
 */
.factory('$mmaModBook', ["$mmFilepool", "$mmSite", "$mmFS", "$http", "$log", "$q", "$mmSitesManager", "mmaModBookComponent", function($mmFilepool, $mmSite, $mmFS, $http, $log, $q, $mmSitesManager, mmaModBookComponent) {
    $log = $log.getInstance('$mmaModBook');

    var self = {};

    /**
     * Download all the content.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModBookComponent, module.id, revision, timemod);
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get the book toc as an array.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getToc
     * @param  {array} contents The module contents.
     * @return {Array}          The toc.
     * @protected
     */
    self.getToc = function(contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return JSON.parse(contents[0].content);
    };

    /**
     * Get the book toc as an array of chapters (no nested).
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getTocList
     * @param  {array} contents The module contents.
     * @return {Array}          The toc as a list.
     * @protected
     */
    self.getTocList = function(contents) {
        var chapters = [];
        var toc = self.getToc(contents);
        angular.forEach(toc, function(el) {
            var chapterId = el.href.replace('/index.html', '');
            chapters.push({id: chapterId, title: el.title, level: el.level});
            angular.forEach(el.subitems, function(sel) {
                chapterId = sel.href.replace('/index.html', '');
                chapters.push({id: chapterId, title: sel.title, level: sel.level});
            });
        });
        return chapters;
    };

    /**
     * Get the first chapter of a book.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getFirstChapter
     * @param  {array} chapters  The chapters list.
     * @return {String}          The chapter id.
     * @protected
     */
    self.getFirstChapter = function(chapters) {
        if (!chapters || !chapters.length) {
            return;
        }
        return chapters[0].id;
    };

    /**
     * Get the previous chapter to the given one.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getPreviousChapter
     * @param  {array} chapters     The chapters list.
     * @param  {String} chapterId   The current chapter.
     * @return {String}             The previous chapter id.
     * @protected
     */
    self.getPreviousChapter = function(chapters, chapterId) {
        var previous = 0;

        for (var i = 0, len = chapters.length; i < len; i++) {
            if (chapters[i].id == chapterId) {
                break;
            }
            previous = chapters[i].id;
        }

        return previous;
    };

    /**
     * Get the next chapter to the given one.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getNextChapter
     * @param  {array} chapters     The chapters list.
     * @param  {String} chapterId   The current chapter.
     * @return {String}             The next chapter id.
     * @protected
     */
    self.getNextChapter = function(chapters, chapterId) {
        var next = 0;

        for (var i = 0, len = chapters.length; i < len; i++) {
            if (chapters[i].id == chapterId) {
                if (typeof chapters[i + 1] != 'undefined') {
                    next = chapters[i + 1].id;
                    break;
                }
            }
        }
        return next;
    };

    /**
     * Gets a chapter contents from the book.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getChapterContent
     * @param {Object} contents     The module contents.
     * @param {String} chapterId    Chapter to retrieve.
     * @param {Integer} moduleId    The module ID.
     * @return {Promise}
     */
    self.getChapterContent = function(contents, chapterId, moduleId) {
        var indexUrl,
            paths = {},
            promise;

        // Extract the information about paths from the module contents.
        angular.forEach(contents, function(content) {
            if (self.isFileDownloadable(content)) {
                var key,
                    url = content.fileurl;

                if (!indexUrl && content.filename == 'index.html') {
                    // First chapter, we don't have a chapter id.
                    if (content.filepath == "/" + chapterId + "/") {
                        indexUrl = url;
                    }
                } else {
                    key = content.filename;
                    paths[key] = url;
                }
            }
        });

        // Promise handling when we are in a browser.
        promise = (function() {
            var deferred;
            if (!indexUrl) {
                // If ever that happens.
                $log.debug('Could not locate the index chapter');
                return $q.reject();
            } else if ($mmFS.isAvailable()) {
                // The file system is available.
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModBookComponent, moduleId);
            } else {
                // We return the live URL.
                deferred = $q.defer();
                deferred.resolve($mmSite.fixPluginfileURL(indexUrl));
                return deferred.promise;
            }
        })();

        return promise.then(function(url) {
            // Fetch the URL content.
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    // Now that we have the content, we update the SRC to point back to
                    // the external resource. That will be caught by mm-format-text.
                    var html = angular.element('<div>');
                    html.html(response.data);
                    angular.forEach(html.find('img'), function(img) {
                        var src = paths[decodeURIComponent(img.getAttribute('src'))];
                        if (typeof src !== 'undefined') {
                            img.setAttribute('src', src);
                        }
                    });
                    // We do the same for links.
                    angular.forEach(html.find('a'), function(anchor) {
                        var href = paths[decodeURIComponent(anchor.getAttribute('href'))];
                        if (typeof href !== 'undefined') {
                            anchor.setAttribute('href', href);
                        }
                    });
                    return html.html();
                }
            });
        });
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#invalidateContent
     * @param {Object} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModBookComponent, moduleId);
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Return whether or not the plugin is enabled.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var version = site.getInfo().version;
            // Require Moodle 2.9.
            return version && (parseInt(version) >= 2015051100) && site.canDownloadFiles();
        });
    };

    /**
     * Report a book as being viewed.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                bookid: id
            };
            return $mmSite.write('mod_book_view_book', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModBookComponent, module.id, revision, timemod);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Mod book handlers.
 *
 * @module mm.addons.mod_book
 * @ngdoc service
 * @name $mmaModBookHandlers
 */
.factory('$mmaModBookHandlers', ["$mmCourse", "$mmaModBook", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreDownloaded", "mmCoreEventPackageStatusChanged", "mmaModBookComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModBook, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreDownloaded,
            mmCoreEventPackageStatusChanged, mmaModBookComponent, $mmContentLinksHelper, $q) {

    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookHandlers#courseContentHandler
     */
    self.courseContentHandler = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModBook.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModBook.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();

                        $mmaModBook.invalidateContent(module.id).finally(function() {
                            $mmaModBook.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('book');
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_book', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        // Always show refresh button if a book is downloaded because revision and timemodified aren't reliable.
                        refreshBtn.hidden = status !== mmCoreOutdated && status !== mmCoreDownloaded;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModBookComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModBook.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a book URL.
            if (url.indexOf('/mod/book/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Mod book prefetch handler.
 *
 * @module mm.addons.mod_book
 * @ngdoc service
 * @name $mmaModBookPrefetchHandler
 */
.factory('$mmaModBookPrefetchHandler', ["$mmaModBook", "mmCoreDownloaded", "mmCoreOutdated", "mmaModBookComponent", function($mmaModBook, mmCoreDownloaded, mmCoreOutdated, mmaModBookComponent) {

    var self = {};

    self.component = mmaModBookComponent;

    /**
     * Determine the status of a module based on the current status detected.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#determineStatus
     * @param {String} status Current status.
     * @return {String}       Status to show.
     */
    self.determineStatus = function(status) {
        if (status === mmCoreDownloaded) {
            // Books are always treated as outdated since revision and timemodified aren't reliable.
            return mmCoreOutdated;
        } else {
            return status;
        }
    };

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModBook.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmaModBook.isPluginEnabled();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModBook.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Chat controller.
 *
 * @module mm.addons.mod_chat
 * @ngdoc controller
 * @name mmaModChatChatCtrl
 */
.controller('mmaModChatChatCtrl', ["$scope", "$stateParams", "$mmApp", "$mmaModChat", "$log", "$ionicModal", "$mmUtil", "$ionicHistory", "$ionicScrollDelegate", "$timeout", "$mmSite", "$interval", "mmaChatPollInterval", function($scope, $stateParams, $mmApp, $mmaModChat, $log, $ionicModal, $mmUtil, $ionicHistory,
            $ionicScrollDelegate, $timeout, $mmSite, $interval, mmaChatPollInterval) {

    $log = $log.getInstance('mmaModChatChatCtrl');

    var chatId = $stateParams.chatid,
        courseId = $stateParams.courseid,
        title = $stateParams.title,
        polling;

    $scope.loaded = false;
    $scope.title = title;
    $scope.currentUserId = $mmSite.getUserId();
    $scope.currentUserBeep = 'beep ' + $scope.currentUserId;
    $scope.messages = [];
    $scope.chatUsers = [];

    // We use an object because it works better with forms.
    $scope.newMessage = {
        text: ''
    };
    chatLastTime = 0;

    // Chat users modal.
    $ionicModal.fromTemplateUrl('addons/mod_chat/templates/users.html', {
        scope: $scope,
        animation: 'slide-in-up'
    }).then(function(m) {
        $scope.modal = m;
    });

    // Close the chat users modal.
    $scope.closeModal = function(){
        $scope.modal.hide();
    };

    // Display the chat users modal.
    $scope.showChatUsers = function() {
        $scope.usersLoaded = false;
        $scope.modal.show();
        $mmaModChat.getChatUsers($scope.chatsid).then(function(data) {
            $scope.chatUsers = data.users;
        }).catch(function(error) {
            showError(error, 'mma.mod_chat.errorwhilegettingchatusers');
        }).finally(function() {
            $scope.usersLoaded = true;
        });
    };

    // Add To "user":
    $scope.talkTo = function(user) {
        $scope.newMessage.text = "To " + user + ": ";
        $scope.modal.hide();
    };

    // Beep a user.
    $scope.beepTo = function(userId) {
        $scope.sendMessage('', userId);
        $scope.modal.hide();
    };

    // Check is the app is offline.
    $scope.isAppOffline = function() {
        return !$mmApp.isOnline();
    };

    // Show error modal.
    function showError(error, defaultMessage) {
        if (typeof error === 'string') {
            $mmUtil.showErrorModal(error);
        } else {
            $mmUtil.showErrorModal(defaultMessage, true);
        }
    }

    // Check if the date should be displayed between messages (when the day changes at midnight for example).
    $scope.showDate = function(message, prevMessage) {
        if (!prevMessage) {
            return true;
        }

        // Check if day has changed.
        return !moment(message.timestamp * 1000).isSame(prevMessage.timestamp * 1000, 'day');
    };

    // Send a message to the chat.
    $scope.sendMessage = function(text, beep) {
        beep = beep || '';

        if (!$mmApp.isOnline()) {
            // Silent error, the view should prevent this.
            return;
        } else if (beep === '' && !text.trim()) {
            // Silent error.
            return;
        }
        text = text.replace(/(?:\r\n|\r|\n)/g, '<br />');

        $mmaModChat.sendMessage($scope.chatsid, text, beep).then(function() {
            if (beep === '') {
                $scope.newMessage.text = '';
            }
        }, function(error) {
            // Only close the keyboard if an error happens, we want the user to be able to send multiple
            // messages withoutthe keyboard being closed.
            $mmApp.closeKeyboard();

            showError(error, 'mma.mod_chat.errorwhilesendingmessage');
        });
    };

    // Login the user.
    $mmaModChat.loginUser(chatId).then(function(chatsid) {
        return $mmaModChat.getLatestMessages(chatsid, 0).then(function(messagesInfo) {
            $scope.chatsid = chatsid;
            chatLastTime = messagesInfo.chatnewlasttime;
            return $mmaModChat.getMessagesUserData(messagesInfo.messages, courseId).then(function(messages) {
                $scope.messages = $scope.messages.concat(messages);
            });
        }).catch(function(message) {
            showError(message, 'mma.mod_chat.errorwhileretrievingmessages');
        });
    }, function(error) {
        showError(error, 'mma.mod_chat.errorwhileconnecting');
        $ionicHistory.goBack();
    }).finally(function() {
        $scope.loaded = true;
    });

    // Scroll to the bottom.
    $scope.scrollAfterRender = function(scope) {
        if (scope.$last === true) {
            // Need a timeout to leave time to the view to be rendered.
            $timeout(function() {
                var scrollView = $ionicScrollDelegate.$getByHandle('mmaChatScroll');
                scrollView.scrollBottom();
            });
        }
    };

    // Set up the polling on a view enter, this allows for the user to go back and resume the polling.
    $scope.$on('$ionicView.enter', function() {
        // Strange case, we already have the polling in place.
        if (polling) {
            return;
        }

        // Start polling.
        polling = $interval(function() {
            $log.debug('Polling for messages');
            if (!$mmApp.isOnline()) {
                // Obviously we cannot check for new messages when the app is offline.
                return;
            }

            $mmaModChat.getLatestMessages($scope.chatsid, chatLastTime).then(function(data) {
                chatLastTime = data.chatnewlasttime;
                $mmaModChat.getMessagesUserData(data.messages, courseId).then(function(messages) {
                    $scope.messages = $scope.messages.concat(messages);
                });
            }, function(error) {
                $interval.cancel(polling);
                showError(error, 'mma.mod_chat.errorwhileretrievingmessages');
            });

        }, mmaChatPollInterval);
    });

    // Removing the polling as we leave the page.
    $scope.$on('$ionicView.leave', function(e) {
        if (polling) {
            $log.debug('Cancelling polling for conversation');
            $interval.cancel(polling);
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Chat index controller.
 *
 * @module mm.addons.mod_chat
 * @ngdoc controller
 * @name mmaModChatIndexCtrl
 */
.controller('mmaModChatIndexCtrl', ["$scope", "$stateParams", "$mmaModChat", "$mmUtil", "$q", "$mmCourse", function($scope, $stateParams, $mmaModChat, $mmUtil, $q, $mmCourse) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        chat;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;

    // Convenience function to get chat data.
    function fetchChatData(refresh) {
        return $mmaModChat.getChat(courseid, module.id, refresh).then(function(chatdata) {
            chat = chatdata;
            $scope.title = chat.name || $scope.title;
            $scope.description = chat.intro || $scope.description;
            $scope.chatId = chat.id;
            $scope.chatScheduled = '';

            var now = $mmUtil.timestamp();
            var span = chat.chattime - now;

            if (chat.chattime && chat.schedule > 0 && span > 0) {
                $mmUtil.formatTime(span).then(function(time) {
                    $scope.chatScheduled = time;
                });
            }

        }, function(error) {
            if (!refresh) {
                // Get chat failed, retry without using cache since it might be a new activity.
                return fetchChatData(true);
            }

            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.mod_chat.errorwhilegettingchatdata', true);
            }
            return $q.reject();
        });
    }

    fetchChatData().then(function() {
        $mmaModChat.logView(chat.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.chatLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshChat = function() {
        fetchChatData(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Chat service.
 *
 * @module mm.addons.mod_chat
 * @ngdoc service
 * @name $mmaModChat
 */
.factory('$mmaModChat', ["$q", "$mmSite", "$mmUser", "$mmSitesManager", function($q, $mmSite, $mmUser, $mmSitesManager) {
    var self = {};


    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the chat WS are available.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_chat_get_chats_by_courses') &&
                    site.wsAvailable('mod_chat_login_user') &&
                    site.wsAvailable('mod_chat_get_chat_users') &&
                    site.wsAvailable('mod_chat_send_chat_message') &&
                    site.wsAvailable('mod_chat_get_chat_latest_messages');
        });
    };

    /**
     * Get a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#getChat
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @return {Promise}        Promise resolved when the chat is retrieved.
     */
    self.getChat = function(courseid, cmid, refresh) {
        var params = {
            courseids: [courseid]
            },
            preSets = {};

        if (refresh) {
            preSets.getFromCache = false;
        }

        return $mmSite.read('mod_chat_get_chats_by_courses', params, preSets).then(function(response) {
            if (response.chats) {
                var currentChat;
                angular.forEach(response.chats, function(chat) {
                    if (chat.coursemodule == cmid) {
                        currentChat = chat;
                    }
                });
                if (currentChat) {
                    return currentChat;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#loginUser
     * @param {Number} chatId   Chat instance ID.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.loginUser = function(chatId) {
        var params = {
            chatid: chatId
        };

        return $mmSite.write('mod_chat_login_user', params).then(function(response) {
            if (response.chatsid) {
                return response.chatsid;
            }
            return $q.reject();
        });
    };

    /**
     * Report a chat as being viewed.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                chatid: id
            };
            return $mmSite.write('mod_chat_view_chat', params);
        }
        return $q.reject();
    };

    /**
     * Send a message to a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#sendMessage
     * @param {Number} chatsid  Chat sessiond ID.
     * @param {String} message  Message text.
     * @param {Number} beep     Beep user ID.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.sendMessage = function(chatsid, message, beep) {
        var params = {
            chatsid: chatsid,
            messagetext: message,
            beepid: beep
        };

        return $mmSite.write('mod_chat_send_chat_message', params).then(function(response) {
            if (response.messageid) {
                return response.messageid;
            }
            return $q.reject();
        });
    };

    /**
     * Get the latest messages from a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#getLatestMessages
     * @param {Number} chatsid  Chat sessiond ID.
     * @param {Number} lasttime Last time when messages were retrieved.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.getLatestMessages = function(chatsid, lasttime) {
        var params = {
            chatsid: chatsid,
            chatlasttime: lasttime
        };
        var preSets = {
            getFromCache: false
        };

        return $mmSite.read('mod_chat_get_chat_latest_messages', params, preSets);
    };

    /**
     * Get user data for messages since they only have userid.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaModChat#getMessagesUserData
     * @param {Object[]} messages    Messages to get the data for.
     * @param {Number}   courseid    ID of the course the messages belong to.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted messages.
     */
    self.getMessagesUserData = function(messages, courseid) {
        var promises = [];

        angular.forEach(messages, function(message) {
            var promise = $mmUser.getProfile(message.userid, courseid, true).then(function(user) {
                message.userfullname = user.fullname;
                message.userprofileimageurl = user.profileimageurl;
            }, function() {
                // Error getting profile. Set default data.
                message.userfullname = message.userid;
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return messages;
        });
    };

    /**
     * Get the actives users of a current chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#getChatUsers
     * @param {Number} chatsid  Chat sessiond ID.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.getChatUsers = function(chatsid) {
        var params = {
            chatsid: chatsid
        };
        var preSets = {
            getFromCache: false
        };

        return $mmSite.read('mod_chat_get_chat_users', params, preSets);
    };

    return self;
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Mod chat handlers.
 *
 * @module mm.addons.mod_chat
 * @ngdoc service
 * @name $mmaModChatHandlers
 */
.factory('$mmaModChatHandlers', ["$mmCourse", "$mmaModChat", "$state", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModChat, $state, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChatHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModChat.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('chat');
                $scope.action = function(e) {
                    $state.go('site.mod_chat', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChatHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModChat.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a chat URL.
            if (url.indexOf('/mod/chat/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice')

/**
 * Choice index controller.
 *
 * @module mm.addons.mod_choice
 * @ngdoc controller
 * @name mmaModChoiceIndexCtrl
 * @todo Delete answer if user can update the answer, show selected if choice is closed (WS returns empty options).
 */
.controller('mmaModChoiceIndexCtrl', ["$scope", "$stateParams", "$mmaModChoice", "$mmUtil", "$q", "$mmCourse", "$translate", function($scope, $stateParams, $mmaModChoice, $mmUtil, $q, $mmCourse, $translate) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        choice,
        hasAnswered = false;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;

    $scope.d3_options = {
        chart: {
            type: 'discreteBarChart',
            height:250,
            margin : {
                top: 20,
                right: 20,
                bottom: 180,
                left: 55
            },
            x: function(d){ return d.label; },
            y: function(d){ return d.value; },
            showValues: true,
            valueFormat: function(d){
                return d3.format('')(d);
            },
            //staggerLabels: true,
            transitionDuration: 500,
            xAxis: {
                //axisLabel: 'Options',
                rotateLabels: -45,
            },
            yAxis: {
                //axisLabel: 'Y Axis',
                axisLabelDistance: 0,
                tickFormat: function(d){ return d3.format(',f')(d) }
            },
            // https://nvd3-community.github.io/nvd3/examples/documentation.html#tooltip
            tooltip: {
                contentGenerator: function(obj) {
                    console.log(obj);
                    return d3.format('.1%')(obj.data.percent);
                }
            }
        }
    };

    // Convenience function to get choice data.
    function fetchChoiceData(refresh) {
        $scope.now = new Date().getTime();
        return $mmaModChoice.getChoice(courseid, module.id).then(function(choicedata) {
            choice = choicedata;
            choice.timeopen = parseInt(choice.timeopen) * 1000;
            choice.openTimeReadable = moment(choice.timeopen).format('LLL');
            choice.timeclose = parseInt(choice.timeclose) * 1000;
            choice.closeTimeReadable = moment(choice.timeclose).format('LLL');

            $scope.title = choice.name || $scope.title;
            $scope.description = choice.intro || $scope.description;
            $scope.choice = choice;

            // We need fetchOptions to finish before calling fetchResults because it needs hasAnswered variable.
            return fetchOptions().then(function() {
                return fetchResults();
            });
        }).catch(function(message) {
            if (!refresh) {
                // Some call failed, retry without using cache since it might be a new activity.
                return refreshAllData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_choice.errorgetchoice', true);
            }
            return $q.reject();
        });
    }

    // Convenience function to get choice options.
    function fetchOptions() {
        return $mmaModChoice.getOptions(choice.id).then(function(options) {
            var isOpen = isChoiceOpen();
            hasAnswered = false;
            $scope.selectedOption = {id: -1}; // Single choice model.
            angular.forEach(options, function(option) {
                if (option.checked) {
                    hasAnswered = true;
                    if (!choice.allowmultiple) {
                        $scope.selectedOption.id = option.id;
                    }
                }
            });
            $scope.canEdit = isOpen && (choice.allowupdate || !hasAnswered);
            $scope.canDelete = $mmaModChoice.isDeleteResponsesEnabled() && isOpen && choice.allowupdate && hasAnswered;
            $scope.options = options;
        });
    }

    // Convenience function to get choice results.
    function fetchResults() {
        return $mmaModChoice.getResults(choice.id).then(function(results) {
            var hasVotes = false;
            var data     = [];
            angular.forEach(results, function(result) {
                if (result.numberofuser > 0) {
                    hasVotes = true;
                }
                result.percentageamount = parseFloat(result.percentageamount).toFixed(1);
                data.push({
                    'label': result.text,
                    'value': result.numberofuser,
                    'percent': result.percentageamount / 100 });
            });
            $scope.canSeeResults = hasVotes || $mmaModChoice.canStudentSeeResults(choice, hasAnswered);
            $scope.results = results;
            $scope.data = [{
                //key: "Some key to the data?",
                values: data
            }];
        });
    }

    /**
     * Check if a choice is open.
     *
     * @return {Boolean} True if choice is open, false otherwise.
     */
    function isChoiceOpen() {
        return (choice.timeopen === 0 || choice.timeopen <= $scope.now) &&
                (choice.timeclose === 0 || choice.timeclose > $scope.now);
    }

    // Convenience function to refresh all the data.
    function refreshAllData() {
        var p1 = $mmaModChoice.invalidateChoiceData(courseid),
            p2 = choice ? $mmaModChoice.invalidateOptions(choice.id) : $q.when(),
            p3 = choice ? $mmaModChoice.invalidateResults(choice.id) : $q.when();

        return $q.all([p1, p2, p3]).finally(function() {
            return fetchChoiceData(true);
        });
    }

    fetchChoiceData().then(function() {
        $mmaModChoice.logView(choice.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.choiceLoaded = true;
    });

    // Save options selected.
    $scope.save = function() {
        // Only show confirm if choice doesn't allow update.
        var promise = choice.allowupdate ? $q.when() : $mmUtil.showConfirm($translate('mm.core.areyousure'));
        promise.then(function() {
            var responses = [];
            if (choice.allowmultiple) {
                angular.forEach($scope.options, function(option) {
                    if (option.checked) {
                        responses.push(option.id);
                    }
                });
            } else {
                responses.push($scope.selectedOption.id);
            }

            var modal = $mmUtil.showModalLoading('mm.core.sending', true);
            $mmaModChoice.submitResponse(choice.id, responses).then(function() {
                // Success! Let's refresh the data.
                return refreshAllData();
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_choice.cannotsubmit', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };

    // Delete options selected.
    $scope.delete = function() {
        $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
            var modal = $mmUtil.showModalLoading('mm.core.sending', true);
            $mmaModChoice.deleteResponses(choice.id).then(function() {
                // Success! Let's refresh the data.
                return refreshAllData();
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_choice.cannotsubmit', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };

    // Pull to refresh.
    $scope.refreshChoice = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice')

/**
 * Choice service.
 *
 * @module mm.addons.mod_choice
 * @ngdoc service
 * @name $mmaModChoice
 */
.factory('$mmaModChoice', ["$q", "$mmSite", "$mmSitesManager", "mmaModChoiceResultsAfterAnswer", "mmaModChoiceResultsAfterClose", "mmaModChoiceResultsAlways", function($q, $mmSite, $mmSitesManager, mmaModChoiceResultsAfterAnswer, mmaModChoiceResultsAfterClose,
            mmaModChoiceResultsAlways) {
    var self = {};

    /**
     * Check if results can be seen by a student. The student can see the results if:
     *     - they're always published, OR
     *     - they're published after the choice is closed and it's closed, OR
     *     - they're published after answering and the user has answered.
     *
     * @param {Object}  choice      Choice to check.
     * @param {Boolean} hasAnswered True if user has answered the choice, false otherwise.
     * @return {Boolean} [description]
     */
    self.canStudentSeeResults = function(choice, hasAnswered) {
        var now = new Date().getTime();
        return  choice.showresults === mmaModChoiceResultsAlways ||
                choice.showresults === mmaModChoiceResultsAfterClose && choice.timeclose !== 0 && choice.timeclose <= now ||
                choice.showresults === mmaModChoiceResultsAfterAnswer && hasAnswered;
    };

    /**
     * Delete responses from a choice.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#deleteResponses
     * @param {Number} choiceid      Choice ID.
     * @param {Number[]} [responses] IDs of the answers. If not defined, delete all the answers of the current user.
     * @return {Promise}             Promise resolved when the options are deleted.
     */
    self.deleteResponses = function(choiceid, responses) {
        responses = responses || [];
        var params = {
            choiceid: choiceid,
            responses: responses
        };
        return $mmSite.write('mod_choice_delete_choice_responses', params).then(function(response) {
            if (!response || response.status === false) {
                return $q.reject();
            }
        });
    };

    /**
     * Get cache key for choice data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getChoiceDataCacheKey(courseid) {
        return 'mmaModChoice:choice:' + courseid;
    }

    /**
     * Get cache key for choice options WS calls.
     *
     * @param {Number} choiceid Choice ID.
     * @return {String}     Cache key.
     */
    function getChoiceOptionsCacheKey(choiceid) {
        return 'mmaModChoice:options:' + choiceid;
    }

    /**
     * Get cache key for choice results WS calls.
     *
     * @param {Number} choiceid Choice ID.
     * @return {String}     Cache key.
     */
    function getChoiceResultsCacheKey(choiceid) {
        return 'mmaModChoice:results:' + choiceid;
    }

    /**
     * Returns if current site supports deleting choice responses.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#isDeleteResponsesEnabled
     * @return {Boolean} True if supported, false otherwise.
     */
    self.isDeleteResponsesEnabled = function() {
        return $mmSite.wsAvailable('mod_choice_delete_choice_responses');
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the choice WS are available.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_choice_get_choice_options') &&
                    site.wsAvailable('mod_choice_get_choice_results') &&
                    site.wsAvailable('mod_choice_get_choices_by_courses') &&
                    site.wsAvailable('mod_choice_submit_choice_response');
        });
    };

    /**
     * Get a choice.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#getChoice
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the choice is retrieved.
     */
    self.getChoice = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getChoiceDataCacheKey(courseid)
            };

        return $mmSite.read('mod_choice_get_choices_by_courses', params, preSets).then(function(response) {
            if (response.choices) {
                var currentChoice;
                angular.forEach(response.choices, function(choice) {
                    if (choice.coursemodule == cmid) {
                        currentChoice = choice;
                    }
                });
                if (currentChoice) {
                    return currentChoice;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get a choice options.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#getOptions
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved with choice options.
     */
    self.getOptions = function(choiceid) {
        var params = {
                choiceid: choiceid
            },
            preSets = {
                cacheKey: getChoiceOptionsCacheKey(choiceid)
            };

        return $mmSite.read('mod_choice_get_choice_options', params, preSets).then(function(response) {
            if (response.options) {
                return response.options;
            }
            return $q.reject();
        });
    };

    /**
     * Get a choice results.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#getResults
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved with choice results.
     */
    self.getResults = function(choiceid) {
        var params = {
                choiceid: choiceid
            },
            preSets = {
                cacheKey: getChoiceResultsCacheKey(choiceid)
            };

        return $mmSite.read('mod_choice_get_choice_results', params, preSets).then(function(response) {
            if (response.options) {
                return response.options;
            }
            return $q.reject();
        });
    };

    /**
     * Invalidates choice data.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#invalidateChoiceData
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateChoiceData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getChoiceDataCacheKey(courseid));
    };

    /**
     * Invalidates options.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#invalidateOptions
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateOptions = function(choiceid) {
        return $mmSite.invalidateWsCacheForKey(getChoiceOptionsCacheKey(choiceid));
    };

    /**
     * Invalidates results.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#invalidateResults
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateResults = function(choiceid) {
        return $mmSite.invalidateWsCacheForKey(getChoiceResultsCacheKey(choiceid));
    };

    /**
     * Report the choice as being viewed.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#logView
     * @param {String} id Choice ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                choiceid: id
            };
            return $mmSite.write('mod_choice_view_choice', params);
        }
        return $q.reject();
    };

    /**
     * Send a response to a choice to Moodle.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#submitResponse
     * @param {Number} choiceid    Choice ID.
     * @param {Number[]} responses IDs of selected options.
     * @return {Promise}           Promise resolved when results are successfully submitted.
     */
    self.submitResponse = function(choiceid, responses) {
        var params = {
            choiceid: choiceid,
            responses: responses
        };
        return $mmSite.write('mod_choice_submit_choice_response', params);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice')

/**
 * Mod choice handlers.
 *
 * @module mm.addons.mod_choice
 * @ngdoc service
 * @name $mmaModChoiceHandlers
 */
.factory('$mmaModChoiceHandlers', ["$mmCourse", "$mmaModChoice", "$state", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModChoice, $state, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoiceHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModChoice.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('choice');
                $scope.action = function(e) {
                    $state.go('site.mod_choice', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoiceHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModChoice.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a choice URL.
            if (url.indexOf('/mod/choice/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Folder index controller.
 *
 * @module mm.addons.mod_folder
 * @ngdoc controller
 * @name mmaModFolderIndexCtrl
 */
.controller('mmaModFolderIndexCtrl', ["$scope", "$stateParams", "$mmaModFolder", "$mmCourse", "$mmUtil", "$q", function($scope, $stateParams, $mmaModFolder, $mmCourse, $mmUtil, $q) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        sectionid = $stateParams.sectionid,
        path = $stateParams.path;

    // Convenience function to set scope data using module.
    function showModuleData(module) {
        $scope.title = module.name;
        $scope.description = module.description;
        if (path) {
            // Subfolder.
            $scope.contents = module.contents;
        } else {
            $scope.contents = $mmaModFolder.formatContents(module.contents);
            $scope.moduleurl = module.url;
        }
    }

    // Convenience function to fetch folder data from Moodle.
    function fetchFolder() {
        return $mmCourse.getModule(module.id, courseid, sectionid).then(function(module) {
            showModuleData(module);
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.mod_folder.errorwhilegettingfolder', true);
            }

            if (!$scope.title) {
                // Error getting data from server. Use module param.
                showModuleData(module);
            }
            return $q.reject();
        });
    }

    if (path) {
        // Subfolder. Use module param.
        showModuleData(module);
        $scope.folderLoaded = true;
        $scope.canReload = false;
    } else {
        fetchFolder().then(function() {
            $mmaModFolder.logView(module.instance).then(function() {
                $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
            });
        }).finally(function() {
            $scope.folderLoaded = true;
            $scope.canReload = true;
        });
    }

    $scope.refreshFolder = function() {
        $mmCourse.invalidateModule(module.id).finally(function() {
            fetchFolder().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Folder service.
 *
 * @module mm.addons.mod_folder
 * @ngdoc service
 * @name $mmaModFolder
 * @todo Adding a new file in a folder updates the revision of all the files, so they're all shown as outdated.
 *       To ignore revision in folders we'll have to modify $mmCoursePrefetchDelegate, mm-file and $mmFilepool.
 */
.factory('$mmaModFolder', ["$mmSite", "$mmCourse", "$q", "$mmFilepool", "mmaModFolderComponent", function($mmSite, $mmCourse, $q, $mmFilepool, mmaModFolderComponent) {
    var self = {};

    /**
     * Download all the content.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModFolderComponent, module.id, revision, timemod);
    };

    /**
     * Format folder contents, creating directory structure.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#formatContents
     * @param {Object[]} contents Folder contents.
     * @return {Object[]}         Formatted contents.
     * @description
     * Format folder contents, creating directory structure.
     * Folders found in filepaths are added to the array. Each folder has the properties: name, fileicon,
     * type (folder), filepath and contents (array with files and subfolders).
     */
    self.formatContents = function(contents) {
        var files = [],
            folders = [],
            foldericon = $mmCourse.getModuleIconSrc('folder');

        angular.forEach(contents, function(entry) {
            if (entry.filepath !== '/') {
                // It's a file in a subfolder. Lets treat the path to add the subfolders to the array.
                var directories,
                    currentList = folders, // Start at root level.
                    path = entry.filepath,
                    subpath = '';

                // Remove first and last slash if needed.
                if (path.substr(0, 1) === '/') {
                    path = path.substr(1);
                }
                if (path.substr(path.length - 1) === '/') {
                    path = path.slice(0, -1);
                }

                directories = path.split('/');

                angular.forEach(directories, function(directory) {
                    subpath = subpath + '/' + directory;
                    // Search if the directory is already stored in folders array.
                    var found = false;
                    for (var i = 0; i < currentList.length; i++) {
                        if (currentList[i].name === directory) {
                            currentList = currentList[i].contents;
                            found = true;
                            break;
                        }
                    }
                    // Directory not found. Add it to the array.
                    if (!found) {
                        var newFolder = {
                            name: directory,
                            fileicon: foldericon,
                            contents: [],
                            filepath: subpath,
                            type: 'folder'
                        };
                        currentList.push(newFolder);
                        currentList = newFolder.contents;
                    }
                });

                currentList.push(entry);
            } else {
                files.push(entry);
            }
        });

        return folders.concat(files);
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Report a folder as being viewed.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                folderid: id
            };
            return $mmSite.write('mod_folder_view_folder', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#prefetchContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModFolderComponent, module.id, revision, timemod);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Mod Folder handlers.
 *
 * @module mm.addons.mod_folder
 * @ngdoc service
 * @name $mmaModFolderHandlers
 */
.factory('$mmaModFolderHandlers', ["$mmCourse", "$mmaModFolder", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModFolderComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModFolder, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModFolderComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @module mm.addons.mod_folder
         * @ngdoc method
         * @name $mmaModFolderCourseContentHandler#isEnabled
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Get the controller.
         *
         * @module mm.addons.mod_folder
         * @ngdoc method
         * @name $mmaModFolderCourseContentHandler#getController
         * @param {Object} module    The module info.
         * @param {Number} courseid  Course ID.
         * @param {Number} sectionid Section ID.
         * @return {Function}
         */
        self.getController = function(module, courseid, sectionid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                // Prefetch folder contents.
                function prefetchFolder(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    $mmaModFolder.prefetchContent(module).catch(function() {
                        if (!$scope.$$destroyed) {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: prefetchFolder
                };

                refreshBtn = {
                    hidden: true,
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    action: prefetchFolder
                };

                $scope.icon = $mmCourse.getModuleIconSrc('folder');
                $scope.title = module.name;
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_folder', {module: module, courseid: courseid, sectionid: sectionid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModFolderComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            if (courseId) {
                return $q.when(true);
            }
            return $mmCourse.canGetModuleWithoutCourseId(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a folder URL.
            if (url.indexOf('/mod/folder/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Mod folder prefetch handler.
 *
 * @module mm.addons.mod_folder
 * @ngdoc service
 * @name $mmaModFolderPrefetchHandler
 */
.factory('$mmaModFolderPrefetchHandler', ["$mmaModFolder", "$mmSite", "mmaModFolderComponent", function($mmaModFolder, $mmSite, mmaModFolderComponent) {

    var self = {};

    self.component = mmaModFolderComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderPrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModFolder.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return true;
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderPrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModFolder.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Forum discussion controller.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name mmaModForumDiscussionCtrl
 */
.controller('mmaModForumDiscussionCtrl', ["$q", "$scope", "$stateParams", "$mmaModForum", "$mmSite", "$mmUtil", "$translate", "$ionicScrollDelegate", "mmaModForumComponent", function($q, $scope, $stateParams, $mmaModForum, $mmSite, $mmUtil, $translate,
            $ionicScrollDelegate, mmaModForumComponent) {

    var discussionid = $stateParams.discussionid,
        courseid = $stateParams.cid,
        scrollView;

    $scope.component = mmaModForumComponent;
    $scope.courseid = courseid;
    $scope.newpost = {
        replyingto: undefined,
        subject: '',
        message: ''
    };

    // Convenience function to get forum discussions.
    function fetchPosts() {
        return $mmaModForum.getDiscussionPosts(discussionid).then(function(posts) {
            $scope.discussion = $mmaModForum.extractStartingPost(posts);
            $scope.posts = posts;

            // Set default reply subject.
            return $translate('mma.mod_forum.re').then(function(strReplyPrefix) {
                $scope.defaultSubject = strReplyPrefix + ' ' + $scope.discussion.subject;
                $scope.newpost.subject = $scope.defaultSubject;
            });
        }, function(message) {
            $mmUtil.showErrorModal(message);
            return $q.reject();
        });
    }

    // Refresh posts.
    function refreshPosts() {
        return $mmaModForum.invalidateDiscussionPosts(discussionid).finally(function() {
            return fetchPosts();
        });
    }

    fetchPosts().then(function() {
        // Add log in Moodle.
        $mmSite.write('mod_forum_view_forum_discussion', {
            discussionid: discussionid
        });
    }).finally(function() {
        $scope.discussionLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshPosts = function() {
        refreshPosts().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // New post added.
    $scope.newPostAdded = function() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmaModForumPostsScroll');
        }
        scrollView && scrollView.scrollTop && scrollView.scrollTop();

        $scope.newpost.replyingto = undefined;
        $scope.newpost.subject = $scope.defaultSubject;
        $scope.newpost.message = '';

        $scope.discussionLoaded = false;
        refreshPosts().finally(function() {
            $scope.discussionLoaded = true;
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Forum discussion list controller.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name mmaModForumDiscussionsCtrl
 */
.controller('mmaModForumDiscussionsCtrl', ["$q", "$scope", "$stateParams", "$mmaModForum", "$mmCourse", "$mmUtil", "$mmGroups", "$mmEvents", "$ionicScrollDelegate", "$ionicPlatform", "mmUserProfileState", "mmaModForumNewDiscussionEvent", function($q, $scope, $stateParams, $mmaModForum, $mmCourse, $mmUtil, $mmGroups,
            $mmEvents, $ionicScrollDelegate, $ionicPlatform, mmUserProfileState, mmaModForumNewDiscussionEvent) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        forum,
        page = 0,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaModForumDiscussionsScroll'),
        shouldScrollTop = false,
        usesGroups = false;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;
    $scope.userStateName = mmUserProfileState;
    $scope.isCreateEnabled = $mmaModForum.isCreateDiscussionEnabled();

    // Convenience function to get forum data and discussions.
    function fetchForumDataAndDiscussions(refresh) {
        return $mmaModForum.getForum(courseid, module.id).then(function(forumdata) {
            forum = forumdata;

            $scope.title = forum.name || $scope.title;
            $scope.description = forum.intro || $scope.description;
            $scope.forum = forum;

            return $mmGroups.getActivityGroupMode(forum.cmid).then(function(mode) {
                usesGroups = mode === $mmGroups.SEPARATEGROUPS || mode === $mmGroups.VISIBLEGROUPS;
            }).finally(function() {
                return fetchDiscussions(refresh);
            });
        }, function(message) {
            if (!refresh) {
                // Get forum failed, retry without using cache since it might be a new activity.
                return refreshData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_forum.errorgetforum', true);
            }
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
            return $q.reject();
        });
    }

    // Convenience function to get forum discussions.
    function fetchDiscussions(refresh) {
        if (refresh) {
            page = 0;
        }

        return $mmaModForum.getDiscussions(forum.id, page).then(function(response) {
            var promise = usesGroups ?
                    $mmaModForum.formatDiscussionsGroups(forum.cmid, response.discussions) : $q.when(response.discussions);
            return promise.then(function(discussions) {
                if (page == 0) {
                    $scope.discussions = discussions;
                } else {
                    $scope.discussions = $scope.discussions.concat(discussions);
                }

                $scope.count = $scope.discussions.length;
                $scope.canLoadMore = response.canLoadMore;
                page++;

                preFetchDiscussionsPosts(discussions);
            });
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
            return $q.reject();
        });
    }

    // Convenience function to prefetch the posts of each discussion, so they're available in offline mode.
    function preFetchDiscussionsPosts(discussions) {
        angular.forEach(discussions, function(discussion) {
            var discussionid = discussion.discussion;
            $mmaModForum.getDiscussionPosts(discussionid);
        });
    }

    // Refresh forum data and discussions list.
    function refreshData() {
        var promises = [];
        promises.push($mmaModForum.invalidateForumData(courseid));
        if (forum) {
            promises.push($mmaModForum.invalidateDiscussionsList(forum.id));
            promises.push($mmGroups.invalidateActivityGroupMode(forum.cmid));
        }
        return $q.all(promises).finally(function() {
            return fetchForumDataAndDiscussions(true);
        });
    }

    fetchForumDataAndDiscussions().then(function() {
        $mmaModForum.logView(forum.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.discussionsLoaded = true;
    });

    // Load more discussions.
    $scope.loadMoreDiscussions = function() {
        fetchDiscussions().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };

    // Pull to refresh.
    $scope.refreshDiscussions = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Listen for discussions added. When a discussion is added, we reload the data.
    var obsNewDisc = $mmEvents.on(mmaModForumNewDiscussionEvent, function(data) {
        if ((forum && forum.id === data.forumid) || data.cmid === module.id) {
            if ($ionicPlatform.isTablet()) {
                scrollView.scrollTop();
            } else {
                // We can't scroll top inmediately because the scroll is not seen.
                shouldScrollTop = true;
            }
            $scope.discussionsLoaded = false;
            refreshData().finally(function() {
                $scope.discussionsLoaded = true;
            });
        }
    });

    // Scroll top if needed.
    $scope.$on('$ionicView.enter', function() {
        if (shouldScrollTop) {
            shouldScrollTop = false;
            scrollView.scrollTop();
        }
    });

    $scope.$on('$destroy', function(){
        if (obsNewDisc && obsNewDisc.off) {
            obsNewDisc.off();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Add new discussion controller.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name mmaModForumNewDiscussionCtrl
 */
.controller('mmaModForumNewDiscussionCtrl', ["$scope", "$stateParams", "$mmGroups", "$q", "$mmaModForum", "$mmEvents", "$ionicPlatform", "$mmUtil", "$ionicHistory", "$translate", "mmaModForumNewDiscussionEvent", function($scope, $stateParams, $mmGroups, $q, $mmaModForum, $mmEvents, $ionicPlatform,
            $mmUtil, $ionicHistory, $translate, mmaModForumNewDiscussionEvent) {

    var courseid = $stateParams.cid,
        forumid = $stateParams.forumid,
        cmid = $stateParams.cmid;

    $scope.newdiscussion = {
        subject: '',
        message: '',
        subscribe: true
    };

    // Fetch if forum uses groups and the groups it uses.
    function fetchGroups(refresh) {
        return $mmGroups.getActivityGroupMode(cmid).then(function(mode) {
            if (mode === $mmGroups.SEPARATEGROUPS || mode === $mmGroups.VISIBLEGROUPS) {
                return $mmGroups.getActivityAllowedGroups(cmid).then(function(forumgroups) {
                    var promise;
                    if (mode === $mmGroups.VISIBLEGROUPS) {
                        // We need to check which of the returned groups the user can post to.
                        promise = validateVisibleGroups(forumgroups, refresh);
                    } else {
                        // WS already filters groups, no need to do it ourselves.
                        promise = $q.when(forumgroups);
                    }

                    return promise.then(function(forumgroups) {
                        if (forumgroups.length > 0) {
                            $scope.groups = forumgroups;
                            $scope.newdiscussion.groupid = forumgroups[0].id;
                            $scope.showGroups = true;
                            $scope.showForm = true;
                        } else {
                            var message = mode === $mmGroups.SEPARATEGROUPS ?
                                                'mma.mod_forum.cannotadddiscussionall' : 'mma.mod_forum.cannotadddiscussion';
                            return $q.reject($translate.instant(message));
                        }
                    });
                });
            } else {
                $scope.showGroups = false;
                $scope.showForm = true;
            }
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_forum.errorgetgroups', true);
            }
            $scope.showForm = false;
            return $q.reject();
        });
    }

    // Validate which of the groups returned by getActivityAllowedGroups in visible groups should be shown to post to.
    function validateVisibleGroups(forumgroups, refresh) {
        if ($mmaModForum.isCanAddDiscussionAvailable()) {
            // Use the canAddDiscussion function to filter the groups.
            // We first check if the user can post to all the groups.
            return $mmaModForum.canAddDiscussionToAll(forumid).catch(function() {
                // The call failed, let's assume he can't.
                return false;
            }).then(function(canAdd) {
                if (canAdd) {
                    // The user can post to all groups, return them all.
                    return forumgroups;
                } else {
                    // The user can't post to all groups, let's check which groups he can post to.
                    var promises = [],
                        filtered = [];

                    angular.forEach(forumgroups, function(group) {
                        promises.push($mmaModForum.canAddDiscussion(forumid, group.id).catch(function() {
                            // The call failed, let's return true so the group is shown. If the user can't post to
                            // it an error will be shown when he tries to add the discussion.
                            return true;
                        }).then(function(canAdd) {
                            if (canAdd) {
                                filtered.push(group);
                            }
                        }));
                    });

                    return $q.all(promises).then(function() {
                        return filtered;
                    });
                }
            });
        } else {
            // We can't check it using WS. We'll get the groups the user belongs to and use them to
            // filter the groups to post.
            return $mmGroups.getUserGroupsInCourse(courseid, refresh).then(function(usergroups) {
                if (usergroups.length === 0) {
                    // User doesn't belong to any group, probably a teacher. Let's return all groups,
                    // if the user can't post to some of them it will be filtered by add discussion WS.
                    return forumgroups;
                }
                return filterGroups(forumgroups, usergroups);
            });
        }
    }

    // Filter forumgroups, returning only those that are inside usergroups.
    function filterGroups(forumgroups, usergroups) {
        var filtered = [],
            usergroupsids = usergroups.map(function(g) {
                return g.id;
            });

        angular.forEach(forumgroups, function(fg) {
            if (usergroupsids.indexOf(fg.id) > -1) {
                filtered.push(fg);
            }
        });

        return filtered;
    }

    fetchGroups().finally(function() {
        $scope.groupsLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshGroups = function() {
        var p1 = $mmGroups.invalidateActivityGroupMode(cmid),
            p2 = $mmGroups.invalidateActivityAllowedGroups(cmid),
            p3 = $mmaModForum.invalidateCanAddDiscussion(forumid);

        $q.all([p1, p2]).finally(function() {
            fetchGroups(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    // Add a new discussion.
    $scope.add = function() {
        var subject = $scope.newdiscussion.subject,
            message = $scope.newdiscussion.message,
            subscribe = $scope.newdiscussion.subscribe,
            groupid = $scope.newdiscussion.groupid;

        if (!subject) {
            $mmUtil.showErrorModal('mma.mod_forum.erroremptysubject', true);
            return;
        }
        if (!message) {
            $mmUtil.showErrorModal('mma.mod_forum.erroremptymessage', true);
            return;
        }
        message = '<p>' + message + '<p>';

        $mmaModForum.addNewDiscussion(forumid, subject, message, subscribe, groupid).then(function(discussionid) {
            var data = {
                forumid: forumid,
                discussionid: discussionid,
                cmid: cmid
            };
            $mmEvents.trigger(mmaModForumNewDiscussionEvent, data);

            if ($ionicPlatform.isTablet()) {
                // Empty form.
                $scope.newdiscussion.subject = '';
                $scope.newdiscussion.message = '';
            } else {
                // Go back to discussions list.
                $ionicHistory.goBack();
            }
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_forum.cannotcreatediscussion', true);
            }
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Directive to show a discussion post, its attachments and the action buttons allowed (reply, etc.).
 *
 * @module mm.addons.mod_forum
 * @ngdoc directive
 * @name mmaForumDiscussionPost
 * @description
 * This directive will show a forum post if the right data is supplied. Attributes:
 *
 * @param {Object} post             Post.
 * @param {Number} courseid         Post's course ID.
 * @param {String} title            Post's title.
 * @param {String} subject          Post's subject.
 * @param {String} component        Component this post belong to.
 * @param {Object} newpost          Object with the new post data. Usually shared between posts.
 * @param {Boolean} showdivider     True if it should have a list divider before the post.
 * @param {Boolean} titleimportant  True if title should be "important" (bold).
 * @oaram {Function} [postadded]    Function to call when a new post is added.
 * @param {String} [defaultsubject] Default subject to set to new posts.
 */
.directive('mmaModForumDiscussionPost', ["$mmaModForum", "$mmUtil", "$translate", "$q", function($mmaModForum, $mmUtil, $translate, $q) {
    return {
        restrict: 'E',
        scope: {
            post: '=',
            courseid: '=',
            title: '=',
            subject: '=',
            component: '=',
            newpost: '=',
            showdivider: '=?',
            titleimportant: '=?',
            postadded: '&?',
            defaultsubject: '=?'
        },
        templateUrl: 'addons/mod_forum/templates/discussionpost.html',
        transclude: true,
        link: function(scope) {
            scope.isReplyEnabled = $mmaModForum.isReplyPostEnabled();

            // Set this post as being replied to.
            scope.showReply = function() {
                scope.newpost.replyingto = scope.post.id;
            };

            // Reply to this post.
            scope.reply = function() {
                if (!scope.newpost.subject) {
                    $mmUtil.showErrorModal('mma.mod_forum.erroremptysubject', true);
                    return;
                }
                if (!scope.newpost.message) {
                    $mmUtil.showErrorModal('mma.mod_forum.erroremptymessage', true);
                    return;
                }

                var message = '<p>' + scope.newpost.message.replace(/\n/g, '<br>') + '</p>',
                    modal = $mmUtil.showModalLoading('mm.core.sending', true);

                $mmaModForum.replyPost(scope.newpost.replyingto, scope.newpost.subject, message).then(function() {
                    if (scope.postadded) {
                        scope.postadded();
                    }
                }).catch(function(message) {
                    if (message) {
                        $mmUtil.showErrorModal(message);
                    } else {
                        $mmUtil.showErrorModal('mma.mod_forum.couldnotadd', true);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            };

            // Cancel reply.
            scope.cancel = function() {
                var promise;
                if (!scope.newpost.subject && !scope.newpost.message) {
                    promise = $q.when(); // Nothing written, cancel right away.
                } else {
                    promise = $mmUtil.showConfirm($translate('mm.core.areyousure'));
                }

                promise.then(function() {
                    scope.newpost.replyingto = undefined;
                    scope.newpost.subject = scope.defaultsubject || '';
                    scope.newpost.message = '';
                });
            };
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Forum service.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name $mmaModForum
 */
.factory('$mmaModForum', ["$q", "$mmSite", "$mmUser", "$mmGroups", "$translate", "$mmSitesManager", "mmaModForumDiscPerPage", function($q, $mmSite, $mmUser, $mmGroups, $translate, $mmSitesManager, mmaModForumDiscPerPage) {
    var self = {};

    /**
     * Get cache key for can add discussion WS calls.
     *
     * @param  {Number} forumid Forum ID.
     * @param  {Number} groupid Group ID.
     * @return {String}         Cache key.
     */
    function getCanAddDiscussionCacheKey(forumid, groupid) {
        return getCommonCanAddDiscussionCacheKey(forumid) + ':' + groupid;
    }

    /**
     * Get common part of cache key for can add discussion WS calls.
     *
     * @param  {Number} forumid Forum ID.
     * @return {String}         Cache key.
     */
    function getCommonCanAddDiscussionCacheKey(forumid) {
        return 'mmaModForum:canadddiscussion:' + forumid;
    }

    /**
     * Get cache key for forum data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getForumDataCacheKey(courseid) {
        return 'mmaModForum:forum:' + courseid;
    }

    /**
     * Get cache key for forum discussion posts WS calls.
     *
     * @param  {Number} discussionid Discussion ID.
     * @return {String}              Cache key.
     */
    function getDiscussionPostsCacheKey(discussionid) {
        return 'mmaModForum:discussion:' + discussionid;
    }

    /**
     * Get cache key for forum discussions list WS calls.
     *
     * @param  {Number} forumid Forum ID.
     * @return {String}         Cache key.
     */
    function getDiscussionsListCacheKey(forumid) {
        return 'mmaModForum:discussions:' + forumid;
    }

    /**
     * Add a new discussion.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#addNewDiscussion
     * @param {Number} forumid   Forum ID.
     * @param {String} subject   New discussion's subject.
     * @param {String} message   New discussion's message.
     * @param {String} subscribe True if should subscribe to the discussion, false otherwise.
     * @param {String} [groupid] Group this discussion belongs to.
     * @return {Promise}         Promise resolved when the discussion is created.
     */
    self.addNewDiscussion = function(forumid, subject, message, subscribe, groupid) {
        var params = {
            forumid: forumid,
            subject: subject,
            message: message,
            options: [
                {
                    name: 'discussionsubscribe',
                    value: !!subscribe
                }
            ]
        };
        if (groupid) {
            params.groupid = groupid;
        }

        return $mmSite.write('mod_forum_add_discussion', params).then(function(response) {
            if (!response || !response.discussionid) {
                return $q.reject();
            } else {
                return response.discussionid;
            }
        });
    };

    /**
     * Check if a user can post to a certain group.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#canAddDiscussion
     * @param  {Number} forumid Forum ID.
     * @param  {Number} groupid Group ID.
     * @return {Promise}        Promise resolved with a boolean: true if can add discussion, false otherwise.
     */
    self.canAddDiscussion = function(forumid, groupid) {
        var params = {
                forumid: forumid,
                groupid: groupid
            },
            preSets = {
                cacheKey: getCanAddDiscussionCacheKey(forumid, groupid)
            };

        return $mmSite.read('mod_forum_can_add_discussion', params, preSets).then(function(result) {
            if (result) {
                return !!result.status;
            }
            return $q.reject();
        });
    };

    /**
     * Check if a user can post to all groups.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#canAddDiscussionToAll
     * @param  {Number} forumid Forum ID.
     * @return {Promise}        Promise resolved with a boolean: true if can add discussion to all, false otherwise.
     */
    self.canAddDiscussionToAll = function(forumid) {
        return self.canAddDiscussion(forumid, -1);
    };

    /**
     * Extract the starting post of a discussion from a list of posts. The post is removed from the array passed as a parameter.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getStartingPost
     * @param  {Object[]} posts Posts to search.
     * @return {Object}         Starting post.
     */
    self.extractStartingPost = function(posts) {
        // Check the last post first, since they'll usually be ordered by create time.
        var lastPost = posts[posts.length - 1];
        if (lastPost.parent == 0) {
            posts.pop(); // Remove it from the array.
            return lastPost;
        }

        // Last post wasn't the starting one. Let's search all the posts until we find the first one.
        for (var i = 0; i < posts.length; i++) {
            if (posts[i].parent == 0) {
                array.splice(i, 1); // Remove it from the array.
                return posts[i];
            }
        }

        return undefined;
    };

    /**
     * Check if canAddDiscussion is available.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isCanAddDiscussionAvailable
     * @return {Boolean} True if available, false otherwise.
     */
    self.isCanAddDiscussionAvailable = function() {
        return $mmSite.wsAvailable('mod_forum_can_add_discussion');
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the forum WS are available.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_forum_get_forums_by_courses') &&
                    site.wsAvailable('mod_forum_get_forum_discussions_paginated') &&
                    site.wsAvailable('mod_forum_get_forum_discussion_posts');
        });
    };

    /**
     * Format discussions, setting groupname if the discussion group is valid.
     *
     * @param  {Number} cmid          Forum cmid.
     * @param  {Object[]} discussions List of discussions to format.
     * @return {Promise}              Promise resolved with the formatted discussions.
     */
    self.formatDiscussionsGroups = function(cmid, discussions) {
        discussions = angular.copy(discussions);
        return $translate('mm.core.allparticipants').then(function(strAllParts) {
            return $mmGroups.getActivityAllowedGroups(cmid).then(function(forumgroups) {
                // Turn groups into an object where each group is identified by id.
                var groups = {};
                angular.forEach(forumgroups, function(fg) {
                    groups[fg.id] = fg;
                });

                // Format discussions.
                angular.forEach(discussions, function(disc) {
                    if (disc.groupid === -1) {
                        disc.groupname = strAllParts;
                    } else {
                        var group = groups[disc.groupid];
                        if (group) {
                            disc.groupname = group.name;
                        }
                    }
                });
                return discussions;
            });
        }).catch(function() {
            return discussions;
        });
    };

    /**
     * Get a forum.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getForum
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the forum is retrieved.
     */
    self.getForum = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getForumDataCacheKey(courseid)
            };

        return $mmSite.read('mod_forum_get_forums_by_courses', params, preSets).then(function(forums) {
            var currentForum;
            angular.forEach(forums, function(forum) {
                if (forum.cmid == cmid) {
                    currentForum = forum;
                }
            });
            if (currentForum) {
                return currentForum;
            }
            return $q.reject();
        });
    };

    /**
     * Get forum discussion posts.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getDiscussionPosts
     * @param {Number} discussionid Discussion ID.
     * @return {Promise}            Promise resolved with forum discussions.
     */
    self.getDiscussionPosts = function(discussionid) {
        var params = {
                discussionid: discussionid
            },
            preSets = {
                cacheKey: getDiscussionPostsCacheKey(discussionid)
            };

        return $mmSite.read('mod_forum_get_forum_discussion_posts', params, preSets).then(function(response) {
            if (response) {
                storeUserData(response.posts);
                return response.posts;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Get forum discussions.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getDiscussions
     * @param {Number} forumid Forum ID.
     * @param {Number} page    Page.
     * @return {Promise}       Promise resolved with forum discussions.
     */
    self.getDiscussions = function(forumid, page) {
        page = page || 0;

        var params = {
                forumid: forumid,
                sortby:  'timemodified',
                sortdirection:  'DESC',
                page: page,
                perpage: mmaModForumDiscPerPage
            },
            preSets = {
                cacheKey: getDiscussionsListCacheKey(forumid)
            };

        return $mmSite.read('mod_forum_get_forum_discussions_paginated', params, preSets).then(function(response) {
            if (response) {
                var canLoadMore = response.discussions.length >= mmaModForumDiscPerPage;
                storeUserData(response.discussions);
                return {discussions: response.discussions, canLoadMore: canLoadMore};
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Invalidates can add discussion WS calls.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateCanAddDiscussion
     * @param  {Number} forumid Forum ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateCanAddDiscussion = function(forumid) {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getCommonCanAddDiscussionCacheKey(forumid));
    };

    /**
     * Invalidates forum discussion posts.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateDiscussionPosts
     * @param {Number} discussionid Discussion ID.
     * @return {Promise}            Promise resolved when the data is invalidated.
     */
    self.invalidateDiscussionPosts = function(discussionid) {
        return $mmSite.invalidateWsCacheForKey(getDiscussionPostsCacheKey(discussionid));
    };

    /**
     * Invalidates discussion list.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateDiscussionsList
     * @param  {Number} forumid Forum ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateDiscussionsList = function(forumid) {
        return $mmSite.invalidateWsCacheForKey(getDiscussionsListCacheKey(forumid));
    };

    /**
     * Invalidates forum data.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateForumData
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateForumData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getForumDataCacheKey(courseid));
    };

    /**
     * Check if the current site allows creating new discussions.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isCreateDiscussionEnabled
     * @return {Boolean} True if enabled, false otherwise.
     */
    self.isCreateDiscussionEnabled = function() {
        return $mmSite.wsAvailable('core_group_get_activity_groupmode') &&
                $mmSite.wsAvailable('core_group_get_activity_allowed_groups') &&
                $mmSite.wsAvailable('mod_forum_add_discussion');
    };

    /**
     * Check if the current site allows replying to posts.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isReplyPostEnabled
     * @return {Boolean} True if enabled, false otherwise.
     */
    self.isReplyPostEnabled = function() {
        return $mmSite.wsAvailable('mod_forum_add_discussion_post');
    };

    /**
     * Report a forum as being viewed.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                forumid: id
            };
            return $mmSite.write('mod_forum_view_forum', params);
        }
        return $q.reject();
    };

    /**
     * Reply to a certain post.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#replyPost
     * @param {Number} postid  ID of the post being replied.
     * @param {String} subject New post's subject.
     * @param {String} message New post's message.
     * @return {Promise}       Promise resolved when the post is created.
     */
    self.replyPost = function(postid, subject, message) {
        var params = {
            postid: postid,
            subject: subject,
            message: message
        };

        return $mmSite.write('mod_forum_add_discussion_post', params).then(function(response) {
            if (!response || !response.postid) {
                return $q.reject();
            } else {
                return response.postid;
            }
        });
    };

    /**
     * Store the users data from a discussions/posts list.
     *
     * @param {Object[]} list Array of posts or discussions.
     */
    function storeUserData(list) {
        var ids = [];
        angular.forEach(list, function(entry) {
            var id = parseInt(entry.userid);
            if (!isNaN(id) && ids.indexOf(id) === -1) {
                ids.push(id);
                $mmUser.storeUser(id, entry.userfullname, entry.userpictureurl);
            }
            if (typeof entry.usermodified != 'undefined') {
                id = parseInt(entry.usermodified);
                if(!isNaN(id) && ids.indexOf(id) === -1) {
                    ids.push(id);
                    $mmUser.storeUser(id, entry.usermodifiedfullname, entry.usermodifiedpictureurl);
                }
            }
        });
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Mod forum handlers.
 *
 * @module mm.addons.mod_forum
 * @ngdoc service
 * @name $mmaModForumHandlers
 */
.factory('$mmaModForumHandlers', ["$mmCourse", "$mmaModForum", "$state", "$mmUtil", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModForum, $state, $mmUtil, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForumHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @module mm.addons.mod_forum
         * @ngdoc method
         * @name $mmaModForumCourseContentHandler#isEnabled
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModForum.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @module mm.addons.mod_forum
         * @ngdoc method
         * @name $mmaModForumCourseContentHandler#isEnabled
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('forum');
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_forum', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForumHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isIndexEnabled(siteId, courseId) {
            return $mmaModForum.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId Site ID.
         * @return {Promise}       Promise resolved with true if enabled.
         */
        function isDiscEnabled(siteId) {
            // We don't check courseId because it's only needed for user profile links, we can afford not passing it.
            return $mmaModForum.isPluginEnabled(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a forum URL.
            if (url.indexOf('/mod/forum/view.php') > -1) {
                // Forum index.
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isIndexEnabled, courseId);
            } else if (url.indexOf('/mod/forum/discuss.php') > -1) {
                // Forum discussion.
                var params = $mmUtil.extractUrlParams(url);
                if (params.d != 'undefined') {
                    // Pass false because all sites should have the same siteurl.
                    return $mmContentLinksHelper.filterSupportedSites(siteIds, isDiscEnabled, false, courseId).then(function(ids) {
                        if (!ids.length) {
                            return [];
                        } else {
                            // Return actions.
                            return [{
                                message: 'mm.core.view',
                                icon: 'ion-eye',
                                sites: ids,
                                action: function(siteId) {
                                    var stateParams = {
                                        discussionid: parseInt(params.d, 10),
                                        cid: courseId
                                    };
                                    $mmContentLinksHelper.goInSite('site.mod_forum-discussion', stateParams, siteId);
                                }
                            }];
                        }
                    });
                }
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Glossary entry controller.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc controller
 * @name mmaModGlossaryEntryCtrl
 */
.controller('mmaModGlossaryEntryCtrl', ["$scope", "$stateParams", "$mmaModGlossary", "$translate", "mmUserProfileState", function($scope, $stateParams, $mmaModGlossary, $translate,
        mmUserProfileState) {
    var entry = $stateParams.entry || {},
        courseid = $stateParams.cid || 0,
        glossary;

    // This is a coding error, for now the course ID is required here as we need it for the author link.
    if (!courseid) {
        notifyErrorOccured();
        return;
    }

    $scope.refreshEntry = function() {
        refreshEntry().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Load the glossary first.
    $mmaModGlossary.getGlossaryById(courseid, entry.glossaryid).then(function(gloss) {
        glossary = gloss;
        var displayFormat = glossary.displayformat;

        $scope.title = entry.concept;
        $scope.entry = entry;
        $scope.courseid = courseid;
        $scope.userStateName = mmUserProfileState;

        if (displayFormat == 'fullwithauthor' || displayFormat == 'encyclopedia') {
            $scope.showAuthor = true;
            $scope.showDate = true;

        } else if (displayFormat == 'fullwithoutauthor') {
            $scope.showAuthor = false;
            $scope.showDate = true;

        // Default, and faq, simple, entrylist, continuous.
        } else {
            $scope.showAuthor = false;
            $scope.showDate = false;
        }

        $scope.loaded = true;

        // Log that the entry was viewed.
        $mmaModGlossary.logEntryView(entry.id);

    }).catch(function() {
        notifyErrorOccured();
    });

    function fetchEntry() {
        return $mmaModGlossary.getEntry(entry.id).then(function(result) {
            $scope.entry = result.entry;
            $scope.title = result.entry.concept;
        });
    }

    function refreshEntry() {
        return $mmaModGlossary.invalidateEntry(entry.id).then(function() {
            return fetchEntry();
        });
    }

    function notifyErrorOccured() {
        $scope.title = $translate.instant('mm.core.error');
        $scope.entry = false;
        $scope.loaded = true;
    }

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Glossary index controller.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc controller
 * @name mmaModGlossaryIndexCtrl
 */
.controller('mmaModGlossaryIndexCtrl', ["$q", "$scope", "$stateParams", "$ionicPopover", "$mmUtil", "$mmaModGlossary", "$ionicScrollDelegate", function($q, $scope, $stateParams, $ionicPopover, $mmUtil, $mmaModGlossary,
        $ionicScrollDelegate) {

    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        glossary,
        noop = function(){},
        limitFrom = 0,
        limitNum = 25,
        popover,
        viewMode,   // The archetype of view (letter, date, author, cat).
        fetchMode = 'letter_all',       // Default.
        fetchFunction,
        fetchInvalidate,
        fetchArguments,
        popoverScope = $scope.$new(true),
        browseModes = [
            {
                key: 'letter_all',
                langkey: 'mma.mod_glossary.byalphabet'
            },
            {
                key: 'search',
                langkey: 'mma.mod_glossary.bysearch'
            }
        ];

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.externalUrl = module.url;
    $scope.courseid = courseId;
    $scope.loaded = false;
    $scope.entries = [];
    $scope.getDivider = noop;
    $scope.showDivider = noop;
    $scope.canLoadMore = false;
    $scope.searchData = {
        searchQuery: ''
    };

    $scope.loadMoreEntries = function() {
        loadMoreEntries().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
    $scope.refreshEntries = function() {
        refreshEntries().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.pickMode = function(e) {
        popoverScope.data.selectedMode = fetchMode;
        popover.show(e);
    };

    $scope.search = function(query) {
        fetchArguments = [glossary.id, query, 1, 'CONCEPT', 'ASC'];
        fetchEntries();
    };

    $scope.trackBy = function(entry) {
        return fetchMode + ':' + entry.id;
    };

    // Controller run.
    $mmaModGlossary.getGlossary(courseId, module.id).then(function(mod) {
        glossary = mod;

        // Preparing browse modes.
        if (glossary.browsemodes.indexOf('date') >= 0) {
            browseModes.push({key: 'newest_first', langkey: 'mma.mod_glossary.bynewestfirst'});
            browseModes.push({key: 'recently_updated', langkey: 'mma.mod_glossary.byrecentlyupdated'});
        }
        if (glossary.browsemodes.indexOf('author') >= 0) {
            browseModes.push({key: 'author_all', langkey: 'mma.mod_glossary.byauthor'});
        }

        // Preparing the popover.
        popoverScope.modes = browseModes;
        popoverScope.modePicked = function(mode) {
            $ionicScrollDelegate.$getByHandle('mmaModGlossaryIndex').scrollTop(false);
            if (switchMode(mode)) {
                $scope.loaded = false;
                fetchEntries().finally(function() {
                    $scope.loaded = true;
                });
            } else {
                // If it's not an instant search, then we reset the values.
                $scope.loaded = true;
                $scope.entries = [];
                $scope.canLoadMore = false;
                $scope.showNoEntries = false;
            }
            popover.hide();
        };
        popoverScope.data = { selectedMode: '' };
        $ionicPopover.fromTemplateUrl('addons/mod_glossary/templates/mode_picker.html', {
            scope: popoverScope
        }).then(function(po) {
            popover = po;
        });
        $scope.$on('$destroy', function() {
            popover.remove();
            popoverScope.$destroy();
        });

        // Preparing the initial mode.
        switchMode();

        // Do not return the promise here, the error modal is already handled.
        fetchEntries().then(function() {
            // After a successful fetch, the glossary can be considered as 'viewed'.
            $mmaModGlossary.logView(glossary.id, viewMode);
        }).finally(function() {
            $scope.loaded = true;
        });
    }).catch(function() {
        $mmUtil.showErrorModal('mma.mod_glossary.errorloadingglossary', true);
        $scope.loaded = true;
    });

    // Controller library.
    function fetchEntries(append) {
        if (!append) {
            limitFrom = 0;
        }
        var args = angular.extend([], fetchArguments);
        args.push(limitFrom);
        args.push(limitNum);

        return fetchFunction.apply(this, args).then(function(result) {
            if (append) {
                $scope.entries = $scope.entries.concat(result.entries);
            } else {
                $scope.entries = result.entries;
            }
            $scope.canLoadMore = (limitFrom + limitNum) < result.count;
            $scope.showNoEntries = result.count <= 0;
        }).catch(function() {
            $mmUtil.showErrorModal('mma.mod_glossary.errorloadingentries', true);
            return $q.reject();
        });
    }

    function refreshEntries() {
        if (fetchMode == 'search' && !$scope.searchQuery) {
            // Ignore search mode that is not set yet.
            return $q.when();
        }
        var args = angular.extend([], fetchArguments);
        return fetchInvalidate.apply(this, args).then(function() {
            limitFrom = 0;
            return fetchEntries();
        });
    }

    function loadMoreEntries() {
        limitFrom += limitNum;
        return fetchEntries(true);
    }

    function switchMode(mode) {
        if (mode == fetchMode) {
            return false;
        }

        var instantFetch = true;
        fetchMode = mode;
        $scope.isSearch = false;

        // Browse by author.
        if (mode == 'author_all') {
            viewMode = 'author';
            fetchFunction = $mmaModGlossary.getEntriesByAuthor;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByAuthor;
            fetchArguments = [glossary.id, 'ALL', 'LASTNAME', 'ASC'];
            $scope.getDivider = function(entry) {
                return entry.userfullname;
            };
            $scope.showDivider = function(entry, previous) {
                if (typeof previous === 'undefined') {
                    return true;
                }
                return entry.userid != previous.userid;
            };

        // Newest first.
        } else if (mode == 'newest_first') {
            viewMode = 'date';
            fetchFunction = $mmaModGlossary.getEntriesByDate;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByDate;
            fetchArguments = [glossary.id, 'CREATION', 'DESC'];
            $scope.getDivider = noop;
            $scope.showDivider = function() { return false; };

        // Recently updated.
        } else if (mode == 'recently_updated') {
            viewMode = 'date';
            fetchFunction = $mmaModGlossary.getEntriesByDate;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByDate;
            fetchArguments = [glossary.id, 'UPDATE', 'DESC'];
            $scope.getDivider = noop;
            $scope.showDivider = function() { return false; };

        // Search for entries.
        } else if (mode == 'search') {
            viewMode = 'search';
            fetchFunction = $mmaModGlossary.getEntriesBySearch;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesBySearch;
            fetchArguments = false; // Dynamically set later.
            $scope.isSearch = true;
            $scope.getDivider = noop;
            $scope.showDivider = function() { return false; };
            instantFetch = false;

        // Consider it is 'letter_all'.
        } else {
            viewMode = 'letter';
            fetchMode = 'letter_all';
            fetchFunction = $mmaModGlossary.getEntriesByLetter;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByLetter;
            fetchArguments = [glossary.id, 'ALL'];
            $scope.getDivider = function(entry) {
                return entry.concept.substr(0, 1).toUpperCase();
            };
            $scope.showDivider = function(entry, previous) {
                if (typeof previous === 'undefined') {
                    return true;
                }
                return $scope.getDivider(entry) != $scope.getDivider(previous);
            };
        }

        return instantFetch;
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Glossary service.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc service
 * @name $mmaModGlossary
 */
.factory('$mmaModGlossary', ["$mmSite", "$q", "$mmSitesManager", function($mmSite, $q, $mmSitesManager) {
    var self = {};

    /**
     * Get the course glossary cache key.
     *
     * @param  {Number} courseId
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getCourseGlossariesCacheKey
     */
    self._getCourseGlossariesCacheKey = function(courseId) {
        return 'mmaModGlossary:courseGlossaries:' + courseId;
    };

    /**
     * Get all the glossaries in a course.
     *
     * @param  {Number} courseId
     * @return {Promise} resolved with the glossaries
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getCourseGlossaries
     */
    self.getCourseGlossaries = function(courseId) {
        var params = {
                courseids: [courseId]
            },
            preSets = {
                cacheKey: self._getCourseGlossariesCacheKey(courseId)
            };
        return $mmSite.read('mod_glossary_get_glossaries_by_courses', params, preSets).then(function(result) {
            return result.glossaries;
        });
    };

    /**
     * Get the course glossary cache key.
     *
     * @param  {Number} courseId
     * @return {Promise}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateCourseGlossaries
     */
    self.invalidateCourseGlossaries = function(courseId) {
        var key = self._getCourseGlossariesCacheKey(courseId);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by author cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @param  {String} sort
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesByAuthorCacheKey
     */
    self._getEntriesByAuthorCacheKey = function(glossaryId, letter, field, sort) {
        return 'mmaModGlossary:entriesByAuthor:' + glossaryId + ":" + letter + ":" + field + ":" + sort;
    };

    /**
     * Get entries by author.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @param  {String} sort
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesByAuthor
     */
    self.getEntriesByAuthor = function(glossaryId, letter, field, sort, from, limit) {
        var params = {
                id: glossaryId,
                letter: letter,
                field: field,
                sort: sort,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesByAuthorCacheKey(glossaryId, letter, field, sort)
            };

        return $mmSite.read('mod_glossary_get_entries_by_author', params, preSets);
    };

    /**
     * Invalidate cache of entries by author.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @param  {String} sort
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesByAuthor
     */
    self.invalidateEntriesByAuthor = function(glossaryId, letter, field, sort) {
        var key = self._getEntriesByAuthorCacheKey(glossaryId, letter, field, sort);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by date cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} order
     * @param  {String} sort
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesByDateCacheKey
     */
    self._getEntriesByDateCacheKey = function(glossaryId, order, sort) {
        return 'mmaModGlossary:entriesByDate:' + glossaryId + ":" + order + ":" + sort;
    };

    /**
     * Get entries by date.
     *
     * @param  {Number} glossaryId
     * @param  {String} order
     * @param  {String} sort
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesByDate
     */
    self.getEntriesByDate = function(glossaryId, order, sort, from, limit) {
        var params = {
                id: glossaryId,
                order: order,
                sort: sort,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesByDateCacheKey(glossaryId, order, sort)
            };

        return $mmSite.read('mod_glossary_get_entries_by_date', params, preSets);
    };

    /**
     * Invalidate cache of entries by date.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesByDate
     */
    self.invalidateEntriesByDate = function(glossaryId, order, sort) {
        var key = self._getEntriesByDateCacheKey(glossaryId, order, sort);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by letter cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesByLetterCacheKey
     */
    self._getEntriesByLetterCacheKey = function(glossaryId, letter) {
        return 'mmaModGlossary:entriesByLetter:' + glossaryId + ":" + letter;
    };

    /**
     * Get entries by letter.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesByLetter
     */
    self.getEntriesByLetter = function(glossaryId, letter, from, limit) {
        var params = {
                id: glossaryId,
                letter: letter,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesByLetterCacheKey(glossaryId, letter)
            };

        return $mmSite.read('mod_glossary_get_entries_by_letter', params, preSets);
    };

    /**
     * Invalidate cache of entries by letter.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesByLetter
     */
    self.invalidateEntriesByLetter = function(glossaryId, letter) {
        var key = self._getEntriesByLetterCacheKey(glossaryId, letter);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by search cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} query
     * @param  {Boolean} fullsearch
     * @param  {String} order
     * @param  {String} sort
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesBySearchCacheKey
     */
    self._getEntriesBySearchCacheKey = function(glossaryId, query, fullsearch, order, sort) {
        return 'mmaModGlossary:entriesBySearch:' + glossaryId + ":" + fullsearch + ":" + order + ":" + sort + ":" + query;
    };

    /**
     * Get entries by search.
     *
     * @param  {Number} glossaryId
     * @param  {String} query
     * @param  {Boolean} fullsearch
     * @param  {String} order
     * @param  {String} sort
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesBySearch
     */
    self.getEntriesBySearch = function(glossaryId, query, fullsearch, order, sort, from, limit) {
        var params = {
                id: glossaryId,
                query: query,
                fullsearch: fullsearch,
                order: order,
                sort: sort,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesBySearchCacheKey(glossaryId, query, fullsearch, order, sort)
            };

        return $mmSite.read('mod_glossary_get_entries_by_search', params, preSets);
    };

    /**
     * Invalidate cache of entries by search.
     *
     * @param  {Number} glossaryId
     * @param  {String} query
     * @param  {Boolean} fullsearch
     * @param  {String} order
     * @param  {String} sort
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesBySearch
     */
    self.invalidateEntriesBySearch = function(glossaryId, query, fullsearch, order, sort) {
        var key = self._getEntriesBySearchCacheKey(glossaryId, query, fullsearch, order, sort);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get an entry by ID cache key.
     *
     * @param  {Number} id
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntryCacheKey
     */
    self._getEntryCacheKey = function(id) {
        return 'mmaModGlossary:getEntry:' + id;
    };

    /**
     * Get one entry by ID.
     *
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntry
     * @param  {Number} id       Entry ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the entry.
     */
    self.getEntry = function(id, siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    id: id
                },
                preSets = {
                    cacheKey: self._getEntryCacheKey(id)
                };

            return site.read('mod_glossary_get_entry_by_id', params, preSets);
        });
    };

    /**
     * Invalidate cache of entry by ID.
     *
     * @param  {Number} id
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntry
     */
    self.invalidateEntry = function(id) {
        var key = self._getEntryCacheKey(id);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get one glossary by cmID.
     *
     * @param  {Number} courseId
     * @param  {Number} cmid
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getGlossary
     */
    self.getGlossary = function(courseId, cmid) {
        return self.getCourseGlossaries(courseId).then(function(glossaries) {
            var result = $q.reject();
            angular.forEach(glossaries, function(glossary) {
                if (glossary.coursemodule == cmid) {
                    result = glossary;
                }
            });
            return result;
        });
    };

    /**
     * Get one glossary by glossary ID.
     *
     * @param  {Number} courseId
     * @param  {Number} id
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getGlossaryById
     */
    self.getGlossaryById = function(courseId, id) {
        return self.getCourseGlossaries(courseId).then(function(glossaries) {
            var result = $q.reject();
            angular.forEach(glossaries, function(glossary) {
                if (glossary.id == id) {
                    result = glossary;
                }
            });
            return result;
        });
    };

    /**
     * Check if glossary plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossary#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            // This function was introduced along with all the other required ones.
            return site.wsAvailable('mod_glossary_get_glossaries_by_courses');
        });
    };

    /**
     * Report a glossary as being viewed.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossary#logView
     * @param {Number} id Glossary ID.
     * @param {String} mode The mode in which the glossary was viewed.
     * @return {Promise} Promise resolved when the WS call is successful.
     */
    self.logView = function(id, mode) {
        var params = {
            id: id,
            mode: mode
        };
        return $mmSite.write('mod_glossary_view_glossary', params);
    };

    /**
     * Report a glossary entry as being viewed.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossary#logEntryView
     * @param {Number} id Entry ID.
     * @return {Promise} Promise resolved when the WS call is successful.
     */
    self.logEntryView = function(id) {
        var params = {
            id: id
        };
        return $mmSite.write('mod_glossary_view_entry', params);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Mod glossary handlers.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc service
 * @name $mmaModGlossaryHandlers
 */
.factory('$mmaModGlossaryHandlers', ["$mmCourse", "$mmaModGlossary", "$state", "$q", "$mmContentLinksHelper", "$mmUtil", "$mmCourseHelper", function($mmCourse, $mmaModGlossary, $state, $q, $mmContentLinksHelper, $mmUtil,
            $mmCourseHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossaryHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModGlossary.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.icon = $mmCourse.getModuleIconSrc('glossary');
                $scope.title = module.name;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_glossary', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossaryHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled to see glossary index for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isIndexEnabled(siteId, courseId) {
            return $mmaModGlossary.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Whether or not the handler is enabled to see glossary entry for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEntryEnabled(siteId, courseId) {
            return $mmaModGlossary.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleByInstance(siteId);
            });
        }

        function getEntry(entryId, siteId) {
            return $mmaModGlossary.getEntry(entryId, siteId).then(function(result) {
                return result.entry;
            }).catch(function(error) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $mmUtil.showErrorModal('mma.mod_glossary.errorloadingentry', true);
                }
                return $q.reject();
            });
        }

        /**
         * Treat a glossary entry link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         */
        function treatEntryLink(siteIds, url, courseId) {
            var params = $mmUtil.extractUrlParams(url);
            if (params.eid != 'undefined') {
                // Pass false because all sites should have the same siteurl.
                return $mmContentLinksHelper.filterSupportedSites(siteIds, isEntryEnabled, false, courseId).then(function(ids) {
                    if (!ids.length) {
                        return [];
                    }

                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: ids,
                        action: function(siteId) {
                            var modal = $mmUtil.showModalLoading();
                            return getEntry(parseInt(params.eid, 10), siteId).then(function(entry) {
                                var promise;
                                if (courseId) {
                                    promise = $q.when(courseId);
                                } else {
                                    promise = $mmCourseHelper.getModuleCourseIdByInstance(entry.glossaryid, 'glossary', siteId);
                                }
                                return promise.then(function(courseId) {
                                    var stateParams = {
                                        entry: entry,
                                        cid: courseId
                                    };
                                    $mmContentLinksHelper.goInSite('site.mod_glossary-entry', stateParams, siteId);
                                });
                            }).finally(function() {
                                modal.dismiss();
                            });
                        }
                    }];
                });
            }
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a glossary URL.
            if (url.indexOf('/mod/glossary/view.php') > -1) {
                // Glossary index.
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isIndexEnabled, courseId);
            } else if (url.indexOf('/mod/glossary/showentry.php') > -1) {
                // Glossary entry.
                return treatEntryLink(siteIds, url, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * IMSCP index controller.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc controller
 * @name mmaModImscpIndexCtrl
 */
.controller('mmaModImscpIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModImscp", "$log", "mmaModImscpComponent", "$ionicPopover", "$timeout", "$q", "$mmCourse", "$mmApp", function($scope, $stateParams, $mmUtil, $mmaModImscp, $log, mmaModImscpComponent,
            $ionicPopover, $timeout, $q, $mmCourse, $mmApp) {
    $log = $log.getInstance('mmaModImscpIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        currentItem;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModImscpComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;

    // Initialize empty previous/next to prevent showing arrows for an instant before they're hidden.
    $scope.previousItem = '';
    $scope.nextItem = '';

    $scope.items = $mmaModImscp.createItemList(module.contents);
    if ($scope.items.length) {
        currentItem = $scope.items[0].href;
    }

    function loadItem(itemId) {
        currentItem = itemId;
        $scope.previousItem = $mmaModImscp.getPreviousItem($scope.items, itemId);
        $scope.nextItem = $mmaModImscp.getNextItem($scope.items, itemId);
        var src = $mmaModImscp.getFileSrc(module, itemId);
        if ($scope.src && src.toString() == $scope.src.toString()) {
            // Re-loading same page. Set it to empty and then re-set the src in the next digest so it detects it has changed.
            $scope.src = '';
            $timeout(function() {
                $scope.src = src;
            });
        } else {
            $scope.src = src;
        }
    }

    function fetchContent() {
        if (module.contents && module.contents.length) {
            var downloadFailed = false;
            return $mmaModImscp.downloadAllContent(module).catch(function() {
                // Mark download as failed but go on since the main files could have been downloaded.
                downloadFailed = true;
            }).finally(function() {
                return $mmaModImscp.getIframeSrc(module).then(function() {
                    loadItem(currentItem);

                    if (downloadFailed && $mmApp.isOnline()) {
                        // We could load the main file but the download failed. Show error message.
                        $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                    }
                }).catch(function() {
                    $mmUtil.showErrorModal('mma.mod_imscp.deploymenterror', true);
                    return $q.reject();
                }).finally(function() {
                    $scope.loaded = true;
                });
            });
        } else {
            $mmUtil.showErrorModal('mma.mod_imscp.deploymenterror', true);
            return $q.reject();
        }
    }

    $scope.doRefresh = function() {
        $mmaModImscp.invalidateContent(module.id).then(function() {
            return fetchContent();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.loadItem = function(itemId) {
        $scope.popover.hide();
        loadItem(itemId);
    };

    $scope.getNumberForPadding = function(n) {
        return new Array(n);
    };

    $ionicPopover.fromTemplateUrl('addons/mod_imscp/templates/toc.html', {
        scope: $scope,
    }).then(function(popover) {
        $scope.popover = popover;
    });

    fetchContent().then(function() {
        $mmaModImscp.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * Mod IMSCP handlers.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc service
 * @name $mmaModImscpHandlers
 */
.factory('$mmaModImscpHandlers', ["$mmCourse", "$mmaModImscp", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModImscpComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModImscp, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModImscpComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @module mm.addons.mod_imscp
         * @ngdoc method
         * @name $mmaModImscpCourseContentHandler#isEnabled
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModImscp.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @module mm.addons.mod_imscp
         * @ngdoc method
         * @name $mmaModImscpCourseContentHandler#getController
         * @param {Object} module   The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModImscp.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModImscp.invalidateContent(module.id).then(function() {
                            $mmaModImscp.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('imscp');
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_imscp', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModImscpComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModImscp.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's an IMSCP URL.
            if (url.indexOf('/mod/imscp/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * IMSCP factory.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc service
 * @name $mmaModImscp
 */
.factory('$mmaModImscp', ["$mmFilepool", "$mmSite", "$mmFS", "$log", "$q", "$sce", "$mmApp", "$mmSitesManager", "mmaModImscpComponent", function($mmFilepool, $mmSite, $mmFS, $log, $q, $sce, $mmApp, $mmSitesManager, mmaModImscpComponent) {
    $log = $log.getInstance('$mmaModImscp');

    var self = {},
        currentDirPath; // Directory path of the current IMSCP.

    /**
     * Get the IMSCP toc as an array.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getToc
     * @param  {array} contents The module contents.
     * @return {Array}          The toc.
     * @protected
     */
    self.getToc = function(contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return JSON.parse(contents[0].content);
    };

    /**
     * Get the imscp toc as an array of items (no nested) to build the navigation tree.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#createItemList
     * @param  {array} contents The module contents.
     * @return {Array}          The toc as a list.
     * @protected
     */
    self.createItemList = function(contents) {
        var items = [];
        var toc = self.getToc(contents);
        angular.forEach(toc, function(el) {
            items.push({href: el.href, title: el.title, level: el.level});
            angular.forEach(el.subitems, function(sel) {
                items.push({href: sel.href, title: sel.title, level: sel.level});
            });
        });
        return items;
    };

    /**
     * Get the previous item to the given one.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getPreviousItem
     * @param  {array} items     The items list.
     * @param  {String} itemId   The current item.
     * @return {String}          The previous item id.
     * @protected
     */
    self.getPreviousItem = function(items, itemId) {
        var previous = '';

        for (var i = 0, len = items.length; i < len; i++) {
            if (items[i].href == itemId) {
                break;
            }
            previous = items[i].href;
        }

        return previous;
    };

    /**
     * Get the next item to the given one.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getNextItem
     * @param  {array} items     The items list.
     * @param  {String} itemId   The current item.
     * @return {String}           The next item id.
     * @protected
     */
    self.getNextItem = function(items, itemId) {
        var next = '';

        for (var i = 0, len = items.length; i < len; i++) {
            if (items[i].href == itemId) {
                if (typeof items[i + 1] != 'undefined') {
                    next = items[i + 1].href;
                    break;
                }
            }
        }
        return next;
    };


    /**
     * Check if we should ommit the file download.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#checkSpecialFiles
     * @param {String} fileName The file name
     * @return {Boolean}        True if we should ommit the file
     * @protected
     */
    self.checkSpecialFiles = function(fileName) {
        return fileName == 'imsmanifest.xml';
    };

    /**
     * Download all the content. All the files are downloaded inside a folder in filepool, keeping their folder structure.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        return $mmFilepool.getFilePathByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModImscpComponent, module.id, revision, timemod, dirPath);
        });
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }

            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Given a filepath, get a certain fileurl from module contents.
     *
     * @param {Object[]} contents     Module contents.
     * @param {String} targetFilepath Filepath of the searched file.
     * @return {String}               Fileurl.
     * @protected
     */
    self._getFileUrlFromContents = function(contents, targetFilepath) {
        var indexUrl;
        angular.forEach(contents, function(content) {
            if (content.type == 'file' && !indexUrl) {
                var filepath = $mmFS.concatenatePaths(content.filepath, content.filename),
                    filepathalt = filepath.charAt(0) === '/' ? filepath.substr(1) : '/' + filepath;
                // Check if it's main file.
                if (filepath === targetFilepath || filepathalt === targetFilepath) {
                    indexUrl = content.fileurl;
                }
            }
        });
        return indexUrl;
    };

    /**
     * Download all the files needed and returns the src of the iframe.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getIframeSrc
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved with the iframe src.
     */
    self.getIframeSrc = function(module) {
        var toc = self.getToc(module.contents),
            mainFilePath;
        if (!toc.length) {
            return $q.reject();
        }
        mainFilePath = toc[0].href;

        return $mmFilepool.getDirectoryUrlByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            currentDirPath = dirPath;
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, mainFilePath));
        }, function() {
            // Error getting directory, there was an error downloading or we're in browser. Return online URL if connected.
            if ($mmApp.isOnline()) {
                var indexUrl = self._getFileUrlFromContents(module.contents, mainFilePath);
                if (indexUrl) {
                    // This URL is going to be injected in an iframe, we need this to make it work.
                    return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(indexUrl));
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get src of a imscp item.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getFileSrc
     * @param {Object} module    The module object.
     * @param {String} itemId    Item to get the src.
     * @return {String}          Item src.
     */
    self.getFileSrc = function(module, itemId) {
        if (currentDirPath) {
            // IMSCP successfully loaded.
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(currentDirPath, itemId));
        } else {
            // Error loading IMSCP. Let's get online URL.
            if ($mmApp.isOnline()) {
                var indexUrl = self._getFileUrlFromContents(module.contents, itemId);
                if (indexUrl) {
                    // This URL is going to be injected in an iframe, we need this to make it work.
                    return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(indexUrl));
                }
            }
        }
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#invalidateContent
     * @param {Number} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModImscpComponent, moduleId);
    };

    /**
     * Check if a file is downloadable. The file param must have 'type' and 'filename' attributes
     * like in core_course_get_contents response.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file' && !self.checkSpecialFiles(file.filename);
    };

    /**
     * Return whether or not the plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var version = site.getInfo().version;
            // Require Moodle 2.9.
            return version && (parseInt(version) >= 2015051100) && site.canDownloadFiles();
        });
    };

    /**
     * Report a IMSCP as being viewed.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                imscpid: id
            };
            return $mmSite.write('mod_imscp_view_imscp', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content. All the files are downloaded inside a folder in filepool, keeping their folder structure.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        return $mmFilepool.getFilePathByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModImscpComponent, module.id, revision, timemod, dirPath);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * Mod imscp prefetch handler.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc service
 * @name $mmaModImscpPrefetchHandler
 */
.factory('$mmaModImscpPrefetchHandler', ["$mmaModImscp", "mmaModImscpComponent", function($mmaModImscp, mmaModImscpComponent) {

    var self = {};

    self.component = mmaModImscpComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpPrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModImscp.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmaModImscp.isPluginEnabled();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpPrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModImscp.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Label index controller.
 *
 * @module mm.addons.mod_label
 * @ngdoc controller
 * @name mmaModLabelIndexCtrl
 */
.controller('mmaModLabelIndexCtrl', ["$scope", "$stateParams", "$log", function($scope, $stateParams, $log) {
    $log = $log.getInstance('mmaModLabelIndexCtrl');
    $scope.description = $stateParams.description;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_label')

/**
 * Mod label handlers.
 *
 * @module mm.addons.mod_label
 * @ngdoc service
 * @name $mmaModLabelHandlers
 */
.factory('$mmaModLabelHandlers', ["$mmText", "$translate", "$state", "$mmContentLinksHelper", "$q", "$mmCourse", function($mmText, $translate, $state, $mmContentLinksHelper, $q, $mmCourse) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_label
     * @ngdoc method
     * @name $mmaModLabelHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @return {Function}
         */
        self.getController = function(module) {
            return function($scope) {
                var title = $mmText.shortenText($mmText.cleanTags(module.description).trim(), 128);
                if (title.length <= 0) {
                    $translate('mma.mod_label.taptoview').then(function(taptoview) {
                        $scope.title = '<span class="mma-mod_label-empty">' + taptoview + '</span>';
                    });
                } else {
                    $scope.title = title;
                }

                $scope.icon = false;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_label', {description: module.description});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_label
     * @ngdoc method
     * @name $mmaModLabelHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            if (courseId) {
                return $q.when(true);
            }
            return $mmCourse.canGetModuleWithoutCourseId(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a label URL.
            if (url.indexOf('/mod/label/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti')

/**
 * LTI index controller.
 *
 * @module mm.addons.mod_lti
 * @ngdoc controller
 * @name mmaModLtiIndexCtrl
 */
.controller('mmaModLtiIndexCtrl', ["$scope", "$stateParams", "$mmaModLti", "$mmUtil", "$q", "$mmCourse", function($scope, $stateParams, $mmaModLti, $mmUtil, $q, $mmCourse) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        lti;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.courseid = courseid;

    // Convenience function to get LTI data.
    function fetchLTI(refresh) {
        return $mmaModLti.getLti(courseid, module.id).then(function(ltidata) {
            lti = ltidata;

            return $mmaModLti.getLtiLaunchData(lti.id).then(function(launchdata) {
                lti.launchdata = launchdata;
                $scope.title = lti.name || $scope.title;
                $scope.description = lti.intro || $scope.description;
                $scope.isValidUrl = $mmUtil.isValidURL(launchdata.endpoint);
            });
        }).catch(function(message) {
            if (!refresh) {
                // Some call failed, retry without using cache since it might be a new activity.
                return refreshAllData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_lti.errorgetlti', true);
            }
            return $q.reject();
        });
    }

    // Convenience function to refresh all the data.
    function refreshAllData() {
        var p1 = $mmaModLti.invalidateLti(courseid),
            p2 = lti ? $mmaModLti.invalidateLtiLaunchData(lti.id) : $q.when();

        return $q.all([p1, p2]).finally(function() {
            return fetchLTI(true);
        });
    }

    fetchLTI().finally(function() {
        $scope.ltiLoaded = true;
    });

    // Pull to refresh.
    $scope.doRefresh = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Launch the LTI.
    $scope.launch = function() {
        // "View" LTI.
        $mmaModLti.logView(lti.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });

        // Launch LTI.
        $mmaModLti.launch(lti.launchdata.endpoint, lti.launchdata.parameters).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            }
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti')

/**
 * Mod LTI handler.
 *
 * @module mm.addons.mod_lti
 * @ngdoc service
 * @name $mmaModLtiHandlers
 */
.factory('$mmaModLtiHandlers', ["$mmCourse", "$mmaModLti", "$state", "$mmSite", "$mmFilepool", "$mmApp", "$mmUtil", "mmaModLtiComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModLti, $state, $mmSite, $mmFilepool, $mmApp, $mmUtil,
            mmaModLtiComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLtiHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModLti.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('lti'); // Get LTI default icon for now.
                $scope.action = function() {
                    $state.go('site.mod_lti', {module: module, courseid: courseid});
                };

                // Get LTI data.
                var promise = $mmaModLti.getLti(courseid, module.id);

                // Handle custom icons.
                promise.then(function(ltidata) {
                    var icon = ltidata.secureicon || ltidata.icon;
                    if (icon) {
                        $mmFilepool.downloadUrl($mmSite.getId(), icon, false, mmaModLtiComponent, module.id).then(function(url) {
                            $scope.icon = url;
                        }).catch(function() {
                            // Error downloading. If we're online we'll set the online url.
                            if ($mmApp.isOnline()) {
                                $scope.icon = icon;
                            }
                        });
                    }
                });

                // Button to launch the LTI.
                $scope.buttons = [{
                    icon: 'ion-link',
                    label: 'mma.mod_lti.launchactivity',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();

                        var modal = $mmUtil.showModalLoading('mm.core.loading', true);
                        // Get LTI and launch data.
                        promise.then(function(ltidata) {
                            return $mmaModLti.getLtiLaunchData(ltidata.id).then(function(launchdata) {
                                // "View" LTI.
                                $mmaModLti.logView(ltidata.id).then(function() {
                                    $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                                });

                                // Launch LTI.
                                return $mmaModLti.launch(launchdata.endpoint, launchdata.parameters);
                            });
                        }).catch(function(message) {
                            if (message) {
                                $mmUtil.showErrorModal(message);
                            } else {
                                $mmUtil.showErrorModal('mma.mod_lti.errorgetlti', true);
                            }
                        }).finally(function() {
                            modal.dismiss();
                        });
                    }
                }];
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLtiHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModLti.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a LTI URL.
            if (url.indexOf('/mod/lti/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti')

/**
 * LTI service.
 *
 * @module mm.addons.mod_lti
 * @ngdoc service
 * @name $mmaModLti
 */
.factory('$mmaModLti', ["$q", "$mmSite", "$mmFS", "$mmText", "$mmUtil", "$mmLang", "$mmSitesManager", function($q, $mmSite, $mmFS, $mmText, $mmUtil, $mmLang, $mmSitesManager) {
    var self = {},
        launcherFileName = 'lti_launcher.html';

    /**
     * Delete launcher.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#deleteLauncher
     * @return {Promise} Promise resolved when the launcher file is deleted.
     */
    self.deleteLauncher = function() {
        return $mmFS.removeFile(launcherFileName);
    };

    /**
     * Generates a launcher file.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#generateLauncher
     * @param {String} url      Launch URL.
     * @param {Object[]} params Launch params.
     * @return {Promise}        Promise resolved with the file URL.
     */
    self.generateLauncher = function(url, params) {

        if (!$mmFS.isAvailable()) {
            return $q.when(url);
        }

        // Generate a form with the params.
        var text = '<form action="' + url + '" name="ltiLaunchForm" ' +
                    'method="post" encType="application/x-www-form-urlencoded">\n';
        angular.forEach(params, function(p) {
            if (p.name == 'ext_submit') {
                text += '    <input type="submit"';
            } else {
                text += '    <input type="hidden" name="' + $mmText.escapeHTML(p.name) + '"';
            }
            text += ' value="' + $mmText.escapeHTML(p.value) + '"/>\n';
        });
        text += '</form>\n';

        // Add an in-line script to automatically submit the form.
        text += '<script type="text/javascript"> \n' +
            '    document.ltiLaunchForm.submit(); \n' +
            '</script> \n';

        return $mmFS.writeFile(launcherFileName, text).then(function(entry) {
            return entry.toURL();
        });
    };

    /**
     * Get a LTI.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#getLti
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the LTI is retrieved.
     */
    self.getLti = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getLtiCacheKey(courseid)
            };

        return $mmSite.read('mod_lti_get_ltis_by_courses', params, preSets).then(function(response) {
            if (response.ltis) {
                var currentLti;
                angular.forEach(response.ltis, function(lti) {
                    if (lti.coursemodule == cmid) {
                        currentLti = lti;
                    }
                });
                if (currentLti) {
                    return currentLti;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for LTI data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getLtiCacheKey(courseid) {
        return 'mmaModLti:lti:' + courseid;
    }

    /**
     * Get a LTI launch data.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#getLtiLaunchData
     * @param {Number} id LTI ID.
     * @return {Promise}  Promise resolved when the launch data is retrieved.
     */
    self.getLtiLaunchData = function(id) {
        var params = {
                toolid: id
            },
            preSets = {
                cacheKey: getLtiLaunchDataCacheKey(id)
            };

        return $mmSite.read('mod_lti_get_tool_launch_data', params, preSets).then(function(response) {
            if (response.endpoint) {
                return response;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for LTI launch data WS calls.
     *
     * @param {Number} id LTI ID.
     * @return {String}   Cache key.
     */
    function getLtiLaunchDataCacheKey(id) {
        return 'mmaModLti:launch:' + id;
    }

    /**
     * Invalidates LTI data.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#invalidateLti
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateLti = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getLtiCacheKey(courseid));
    };

    /**
     * Invalidates options.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#invalidateLtiLaunchData
     * @param {Number} id LTI ID.
     * @return {Promise}  Promise resolved when the data is invalidated.
     */
    self.invalidateLtiLaunchData = function(id) {
        return $mmSite.invalidateWsCacheForKey(getLtiLaunchDataCacheKey(id));
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the lti WS are available.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_lti_get_ltis_by_courses') &&
                    site.wsAvailable('mod_lti_get_tool_launch_data');
        });
    };

    /**
     * Launch LTI.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#launch
     * @param {String} url      Launch URL.
     * @param {Object[]} params Launch params.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.launch = function(url, params) {
        if (!$mmUtil.isValidURL(url)) {
            return $mmLang.translateAndReject('mma.mod_lti.errorinvalidlaunchurl');
        }

        // Generate launcher and open it.
        return self.generateLauncher(url, params).then(function(url) {
            $mmUtil.openInApp(url);
        });
    };

    /**
     * Report the LTI as being viewed.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#logView
     * @param {String} id LTI ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                ltiid: id
            };
            return $mmSite.write('mod_lti_view_lti', params);
        }
        return $q.reject();
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Page index controller.
 *
 * @module mm.addons.mod_page
 * @ngdoc controller
 * @name mmaModPageIndexCtrl
 */
.controller('mmaModPageIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModPage", "$mmCourse", "$q", "$log", "$mmApp", "mmaModPageComponent", function($scope, $stateParams, $mmUtil, $mmaModPage, $mmCourse, $q, $log, $mmApp,
            mmaModPageComponent) {
    $log = $log.getInstance('mmaModPageIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModPageComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;

    function fetchContent() {
        var downloadFailed = false;
        // Prefetch the content so ALL files are downloaded, not just the ones shown in the page.
        return $mmaModPage.downloadAllContent(module).catch(function(err) {
            // Mark download as failed but go on since the main files could have been downloaded.
            downloadFailed = true;
        }).then(function() {
            return $mmaModPage.getPageHtml(module.contents, module.id).then(function(content) {
                $scope.content = content;

                if (downloadFailed && $mmApp.isOnline()) {
                    // We could load the main file but the download failed. Show error message.
                    $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                }
            }).catch(function() {
                $mmUtil.showErrorModal('mma.mod_page.errorwhileloadingthepage', true);
                return $q.reject();
            }).finally(function() {
                $scope.loaded = true;
            });
        });
    }

    $scope.doRefresh = function() {
        $mmaModPage.invalidateContent(module.id).then(function() {
            return fetchContent();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    fetchContent().then(function() {
        $mmaModPage.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Mod page handlers.
 *
 * @module mm.addons.mod_page
 * @ngdoc service
 * @name $mmaModPageHandlers
 */
.factory('$mmaModPageHandlers', ["$mmCourse", "$mmaModPage", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModPageComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModPage, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModPageComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPageHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModPage.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModPage.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModPage.invalidateContent(module.id).finally(function() {
                            $mmaModPage.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('page');
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_page', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModPageComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPageHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModPage.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a page URL.
            if (url.indexOf('/mod/page/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Page factory.
 *
 * @module mm.addons.mod_page
 * @ngdoc service
 * @name $mmaModPage
 */
.factory('$mmaModPage', ["$mmFilepool", "$mmSite", "$mmFS", "$http", "$log", "$q", "$mmSitesManager", "mmaModPageComponent", function($mmFilepool, $mmSite, $mmFS, $http, $log, $q, $mmSitesManager, mmaModPageComponent) {
    $log = $log.getInstance('$mmaModPage');

    var self = {};

    /**
     * Download all the content.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModPageComponent, module.id, revision, timemod);
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Gets the page HTML.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getPageHtml
     * @param {Object} contents The module contents.
     * @param {Object} moduleId The module ID.
     * @return {Promise}
     */
    self.getPageHtml = function(contents, moduleId) {
        var indexUrl,
            paths = {},
            promise;

        // Extract the information about paths from the module contents.
        angular.forEach(contents, function(content) {
            var key,
                url = content.fileurl;

            if (self._isMainPage(content)) {
                // This seems to be the most reliable way to spot the index page.
                indexUrl = url;
            } else {
                key = content.filename;
                if (content.filepath !== '/') {
                    // Add the folders without the leading slash.
                    key = content.filepath.substr(1) + key;
                }
                paths[key] = url;
            }
        });

        // Promise handling when we are in a browser.
        promise = (function() {
            var deferred;
            if (!indexUrl) {
                // If ever that happens.
                $log.debug('Could not locate the index page');
                return $q.reject();
            } else if ($mmFS.isAvailable()) {
                // The file system is available.
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModPageComponent, moduleId);
            } else {
                // We return the live URL.
                deferred = $q.defer();
                deferred.resolve($mmSite.fixPluginfileURL(indexUrl));
                return deferred.promise;
            }
        })();

        return promise.then(function(url) {
            // Fetch the URL content.
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    // Now that we have the content, we update the SRC to point back to
                    // the external resource. That will be caught by mm-format-text.
                    var html = angular.element('<div>');
                    html.html(response.data);
                    angular.forEach(html.find('img'), function(img) {
                        var src = paths[decodeURIComponent(img.getAttribute('src'))];
                        if (typeof src !== 'undefined') {
                            img.setAttribute('src', src);
                        }
                    });
                    // We do the same for links.
                    angular.forEach(html.find('a'), function(anchor) {
                        var href = paths[decodeURIComponent(anchor.getAttribute('href'))];
                        if (typeof href !== 'undefined') {
                            anchor.setAttribute('href', href);
                        }
                    });
                    return html.html();
                }
            });
        });
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#invalidateContent
     * @param {Object} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModPageComponent, moduleId);
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Returns whether the file is the main page of the module.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#_isMainPage
     * @param {Object} file An object returned from WS containing file info.
     * @return {Boolean}
     * @protected
     */
    self._isMainPage = function(file) {
        var filename = file.filename || undefined,
            fileurl = file.fileurl || '',
            url = '/mod_page/content/index.html',
            encodedUrl = encodeURIComponent(url);

        return (filename === 'index.html' && (fileurl.indexOf(url) > 0 || fileurl.indexOf(encodedUrl) > 0 ));
    };

    /**
     * Check if page plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.canDownloadFiles();
        });
    };

    /**
     * Report a page as being viewed.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                pageid: id
            };
            return $mmSite.write('mod_page_view_page', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModPageComponent, module.id, revision, timemod);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Mod page prefetch handler.
 *
 * @module mm.addons.mod_page
 * @ngdoc service
 * @name $mmaModPagePrefetchHandler
 */
.factory('$mmaModPagePrefetchHandler', ["$mmaModPage", "$mmSite", "mmaModPageComponent", function($mmaModPage, $mmSite, mmaModPageComponent) {

    var self = {};

    self.component = mmaModPageComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPagePrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModPage.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPagePrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmSite.canDownloadFiles();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPagePrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModPage.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Resource index controller.
 *
 * @module mm.addons.mod_resource
 * @ngdoc controller
 * @name mmaModResourceIndexCtrl
 */
.controller('mmaModResourceIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModResource", "$log", "$mmApp", "$mmCourse", "$timeout", "mmaModResourceComponent", function($scope, $stateParams, $mmUtil, $mmaModResource, $log, $mmApp, $mmCourse, $timeout,
            mmaModResourceComponent) {
    $log = $log.getInstance('mmaModResourceIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModResourceComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.mode = false;
    $scope.loaded = false;

    function fetchContent() {
        if (module.contents && module.contents.length) {
            if ($mmaModResource.isDisplayedInIframe(module)) {
                $scope.mode = 'iframe';
                var downloadFailed = false;
                return $mmaModResource.downloadAllContent(module).catch(function(err) {
                    // Mark download as failed but go on since the main files could have been downloaded.
                    downloadFailed = true;
                }).finally(function() {
                    $mmaModResource.getIframeSrc(module).then(function(src) {
                        if ($scope.src && src.toString() == $scope.src.toString()) {
                            // Re-loading same page. Set it to empty and then re-set the src
                            // in the next digest so it detects it has changed.
                            $scope.src = '';
                            $timeout(function() {
                                $scope.src = src;
                            });
                        } else {
                            $scope.src = src;
                        }
                        $mmaModResource.logView(module.instance).then(function() {
                            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                        });
                        if (downloadFailed && $mmApp.isOnline()) {
                            // We could load the main file but the download failed. Show error message.
                            $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                        }
                    }).catch(function() {
                        $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
                    }).finally(function() {
                        $scope.loaded = true;
                    });
                });
            } else if ($mmaModResource.isDisplayedInline(module)) {
                var downloadFailed = false;
                $mmaModResource.downloadAllContent(module).catch(function(err) {
                    // Mark download as failed but go on since the main files could have been downloaded.
                    downloadFailed = true;
                }).finally(function() {
                    $mmaModResource.getResourceHtml(module.contents, module.id).then(function(content) {
                        $scope.mode = 'inline';
                        $scope.content = content;
                        $mmaModResource.logView(module.instance).then(function() {
                            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                        });

                        if (downloadFailed && $mmApp.isOnline()) {
                            // We could load the main file but the download failed. Show error message.
                            $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                        }
                    }).catch(function() {
                        $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
                    }).finally(function() {
                        $scope.loaded = true;
                    });
                });
            } else {
                $scope.loaded = true;
                $scope.mode = 'external';

                $scope.open = function() {
                    var modal = $mmUtil.showModalLoading('mm.core.downloading', true);

                    $mmaModResource.openFile(module.contents, module.id).then(function() {
                        $mmaModResource.logView(module.instance).then(function() {
                            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                        });
                    }).catch(function(error) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
                        }
                    }).finally(function() {
                        modal.dismiss();
                    });
                };
            }
        } else {
            $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
        }
    }

    // Event sent by the directive mmaModResourceHtmlLink when we click an HTML link.
    $scope.$on('mmaModResourceHtmlLinkClicked', function(e, target) {
        $scope.loaded = false;
        $mmaModResource.getResourceHtml(module.contents, module.id, target).then(function(content) {
            $scope.content = content;
        }).catch(function() {
            $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
        }).finally(function() {
            $scope.loaded = true;
        });
    });

    $scope.doRefresh = function() {
        $mmaModResource.invalidateContent(module.id).then(function() {
            return fetchContent();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    fetchContent();
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Directive to open a link in external browser.
 *
 * @module mm.addons.mod_resource
 * @ngdoc directive
 * @name mmaModResourceHtmlLink
 */
.directive('mmaModResourceHtmlLink', function() {
    return {
        restrict: 'A',
        priority: 99,   // Must be lower than mm-browser, or anything listening for a click event.
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                var href = element[0].getAttribute('data-href');
                if (!href) {
                    return;
                }

                // Prevent any other directive from catching the event.
                event.stopImmediatePropagation();
                event.preventDefault();

                // Notify the scope which must handle this click, we do not support bubbling.
                scope.$emit('mmaModResourceHtmlLinkClicked', href);
            });
        }
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Mod resource handlers.
 *
 * @module mm.addons.mod_resource
 * @ngdoc service
 * @name $mmaModResourceHandlers
 */
.factory('$mmaModResourceHandlers', ["$mmCourse", "$mmaModResource", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmCoursePrefetchDelegate", "$mmFilepool", "$mmFS", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModResourceComponent", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModResource, $mmEvents, $state, $mmSite, $mmUtil,
            $mmCoursePrefetchDelegate, $mmFilepool, $mmFS, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated,
            mmCoreEventPackageStatusChanged, mmaModResourceComponent, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourceHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModResource.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module   The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModResource.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModResource.invalidateContent(module.id).finally(function() {
                            $mmaModResource.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;

                if (module.contents.length) {
                    var filename = module.contents[0].filename,
                        extension = $mmFS.getFileExtension(filename);
                    if (module.contents.length == 1 || (extension != "html" && extension != "htm")) {
                        $scope.icon = $mmFS.getFileIcon(filename);
                    } else {
                        $scope.icon = $mmCourse.getModuleIconSrc('resource');
                    }
                } else {
                    $scope.icon = $mmCourse.getModuleIconSrc('resource');
                }
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_resource', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModResourceComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourceHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModResource.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a resource URL.
            if (url.indexOf('/mod/resource/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Mod resource prefetch handler.
 *
 * @module mm.addons.mod_resource
 * @ngdoc service
 * @name $mmaModResourcePrefetchHandler
 */
.factory('$mmaModResourcePrefetchHandler', ["$mmaModResource", "$mmSite", "mmaModResourceComponent", function($mmaModResource, $mmSite, mmaModResourceComponent) {

    var self = {};

    self.component = mmaModResourceComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourcePrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModResource.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourcePrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmSite.canDownloadFiles();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourcePrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModResource.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Resource factory.
 *
 * @module mm.addons.mod_resource
 * @ngdoc service
 * @name $mmaModResource
 */
.factory('$mmaModResource', ["$mmFilepool", "$mmSite", "$mmUtil", "$mmFS", "$http", "$log", "$q", "$sce", "$mmApp", "$mmSitesManager", "mmaModResourceComponent", function($mmFilepool, $mmSite, $mmUtil, $mmFS, $http, $log, $q, $sce, $mmApp, $mmSitesManager,
            mmaModResourceComponent) {
    $log = $log.getInstance('$mmaModResource');

    var self = {};

    /**
     * Download all the content. All the files are downloaded inside a folder in filepool, keeping their folder structure.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            siteid = $mmSite.getId(),
            promise,
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        if (self.isDisplayedInIframe(module)) {
            // Get path of the module folder in filepool.
            promise = $mmFilepool.getFilePathByUrl(siteid, module.url);
        } else {
            promise = $q.when();
        }

        return promise.then(function(dirPath) {
            return $mmFilepool.downloadPackage(siteid, files, mmaModResourceComponent, module.id, revision, timemod, dirPath);
        });
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModresource#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Download all the files needed and returns the src of the iframe.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getIframeSrc
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved with the iframe src.
     */
    self.getIframeSrc = function(module) {
        if (!module.contents.length) {
            return $q.reject();
        }

        var mainFile = module.contents[0],
            mainFilePath = mainFile.filename;

        if (mainFile.filepath !== '/') {
            mainFilePath = mainFile.filepath.substr(1) + mainFilePath;
        }

        return $mmFilepool.getDirectoryUrlByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, mainFilePath));
        }, function() {
            // Error getting directory, there was an error downloading or we're in browser. Return online URL.
            if ($mmApp.isOnline() && mainFile.fileurl) {
                // This URL is going to be injected in an iframe, we need this to make it work.
                return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(mainFile.fileurl));
            }
            return $q.reject();
        });
    };

    /**
     * Gets the resource HTML.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getResourceHtml
     * @param {Object[]} contents Array of content objects.
     * @param {Number} moduleId The module ID.
     * @param {String} [target] The HTML file that the user wants to open, if not defined uses the main file.
     * @return {Promise}
     */
    self.getResourceHtml = function(contents, moduleId, target) {
        var indexUrl,
            paths = {},
            promise;

        // Extract the information about paths from the module contents.
        angular.forEach(contents, function(content, index) {
            var url = content.fileurl,
                fullpath = content.filename;

            if (content.filepath !== '/') {
                fullpath = content.filepath.substr(1) + fullpath;
            }

            if (typeof target !== 'undefined' && target == fullpath) {
                // We use another index.
                indexUrl = url;
            } else if (typeof target === 'undefined' && index === 0) {
                // We use the main page, it should always be the first one.
                indexUrl = url;
            } else {
                // Any other file in the resource.
                paths[fullpath] = url;
            }
        });

        // Promise handling when we are in a browser.
        promise = (function() {
            if (!indexUrl) {
                // If ever that happens.
                $log.debug('Could not locate the index page');
                return $q.reject();
            }
            if ($mmFS.isAvailable()) {
                // The file system is available.
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModResourceComponent, moduleId);
            } else {
                // We return the live URL.
                return $q.when($mmSite.fixPluginfileURL(indexUrl));
            }
        })();

        return promise.then(function(url) {
            // Fetch the URL content.
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    // Now that we have the content, we update the SRC to point back to
                    // the external resource. That will be caught by mm-format-text.
                    var html = angular.element('<div>');
                        html.append(response.data);

                    angular.forEach(html.find('img'), function(img) {
                        var src = paths[decodeURIComponent(img.getAttribute('src'))];
                        if (typeof src !== 'undefined') {
                            img.setAttribute('src', src);
                        }
                    });
                    // We do the same for links.
                    angular.forEach(html.find('a'), function(anchor) {
                        var href = decodeURIComponent(anchor.getAttribute('href')),
                            url = paths[href],
                            ext = $mmFS.getFileExtension(href);
                        if (typeof url !== 'undefined') {
                            anchor.setAttribute('href', url);
                            if (ext == 'html' || ext == 'html') {
                                anchor.setAttribute('mma-mod-resource-html-link', 1);
                                anchor.setAttribute('data-href', href);
                            }
                        }
                    });

                    return html.html();
                }
            });
        });
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#invalidateContent
     * @param {Number} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModResourceComponent, moduleId);
    };

    /**
     * Whether the resource has to be displayed in an iframe.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isDisplayedInIframe
     * @param {Object} module The module object.
     * @return {Boolean}
     */
    self.isDisplayedInIframe = function(module) {
        var inline = self.isDisplayedInline(module);

        if (inline && $mmFS.isAvailable()) {
            for (var i = 0; i < module.contents.length; i++) {
                var ext = $mmFS.getFileExtension(module.contents[i].filename);
                if (ext == 'js' || ext == 'swf' || ext == 'css') {
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * Whether the resource is to be displayed inline (HTML).
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isDisplayedInline
     * @param {Object} module The module object.
     * @return {Boolean}
     */
    self.isDisplayedInline = function(module) {
        if (!module.contents.length) {
            return false;
        }
        var ext = $mmFS.getFileExtension(module.contents[0].filename);
        return ext === 'htm' || ext === 'html';
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Check if resource plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.canDownloadFiles();
        });
    };

    /**
     * Report the resource as being viewed.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                resourceid: id
            };
            return $mmSite.write('mod_resource_view_resource', params);
        }
        return $q.reject();
    };

    /**
     * Download and open the file from the resource.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#openFile
     * @param {Object[]} contents Array of content objects.
     * @param {Number} moduleId The module ID.
     * @return {Promise}
     */
    self.openFile = function(contents, moduleId) {
        if (!contents || !contents.length) {
            return $q.reject();
        }

        var url = contents[0].fileurl,
            promise;

        if ($mmFS.isAvailable()) {
            // The file system is available.
            promise = $mmFilepool.downloadUrl($mmSite.getId(), url, false, mmaModResourceComponent, moduleId);
        } else {
            // We use the live URL.
            promise = $q.when($mmSite.fixPluginfileURL(url));
        }

        return promise.then(function(localUrl) {
            return $mmUtil.openFile(localUrl);
        });
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            siteid = $mmSite.getId(),
            promise,
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        if (self.isDisplayedInIframe(module)) {
            // Get path of the module folder in filepool.
            promise = $mmFilepool.getFilePathByUrl(siteid, module.url);
        } else {
            promise = $q.when();
        }

        return promise.then(function(dirPath) {
            return $mmFilepool.prefetchPackage(siteid, files, mmaModResourceComponent, module.id, revision, timemod, dirPath);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM index controller.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc controller
 * @name mmaModScormIndexCtrl
 */
.controller('mmaModScormIndexCtrl', ["$scope", "$stateParams", "$mmaModScorm", "$mmUtil", "$q", "$mmCourse", "$ionicScrollDelegate", "$mmCoursePrefetchDelegate", "$mmaModScormHelper", "$mmEvents", "$mmSite", "$state", "mmCoreOutdated", "mmCoreNotDownloaded", "mmCoreDownloading", "mmaModScormComponent", "mmCoreEventPackageStatusChanged", "$ionicHistory", "mmaModScormEventAutomSynced", "$mmaModScormSync", "$timeout", function($scope, $stateParams, $mmaModScorm, $mmUtil, $q, $mmCourse, $ionicScrollDelegate,
            $mmCoursePrefetchDelegate, $mmaModScormHelper, $mmEvents, $mmSite, $state, mmCoreOutdated, mmCoreNotDownloaded,
            mmCoreDownloading, mmaModScormComponent, mmCoreEventPackageStatusChanged, $ionicHistory, mmaModScormEventAutomSynced,
            $mmaModScormSync, $timeout) {

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        scorm,
        statusObserver,
        currentStatus,
        lastAttempt,
        lastOffline = false,
        attempts,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaModScormIndexScroll');

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.currentOrganization = {};
    $scope.scormOptions = {
        mode: $mmaModScorm.MODENORMAL
    };

    $scope.modenormal = $mmaModScorm.MODENORMAL;
    $scope.modebrowse = $mmaModScorm.MODEBROWSE;

    // Convenience function to get SCORM data.
    function fetchScormData(refresh) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scormData) {
            scorm = scormData;

            $scope.title = scorm.name || $scope.title;
            $scope.description = scorm.intro || $scope.description;
            $scope.scorm = scorm;

            var result = $mmaModScorm.isScormSupported(scorm);
            if (result === true) {
                $scope.errorMessage = '';
            } else {
                $scope.errorMessage = result;
            }

            if (scorm.warningmessage) {
                return; // SCORM is closed or not open yet, we can't get more data.
            }

            return syncScorm(!refresh, false).catch(function() {
                // Ignore errors, keep getting data even if sync fails.
            }).then(function() {

                // No need to return this promise, it should be faster than the rest.
                $mmaModScormHelper.getScormReadableSyncTime(scorm.id).then(function(syncTime) {
                    $scope.syncTime = syncTime;
                });

                // Get the number of attempts and check if SCORM is incomplete.
                return $mmaModScorm.getAttemptCount(scorm.id).then(function(attemptsData) {
                    attempts = attemptsData;
                    $scope.showSyncButton = attempts.offline.length; // Show sync button only if there are offline attempts.

                    // Determine the attempt that will be continued or reviewed.
                    return $mmaModScormHelper.determineAttemptToContinue(scorm, attempts).then(function(attempt) {
                        lastAttempt = attempt.number;
                        lastOffline = attempt.offline;
                        if (lastAttempt != attempts.lastAttempt.number) {
                            $scope.attemptToContinue = lastAttempt;
                        } else {
                            delete $scope.attemptToContinue;
                        }

                        return $mmaModScorm.isAttemptIncomplete(scorm.id, lastAttempt, lastOffline).then(function(incomplete) {
                            var promises = [];

                            scorm.incomplete = incomplete;
                            scorm.numAttempts = attempts.total;
                            scorm.grademethodReadable = $mmaModScorm.getScormGradeMethod(scorm);
                            scorm.attemptsLeft = $mmaModScorm.countAttemptsLeft(scorm, attempts.lastAttempt.number);
                            if (scorm.forceattempt && scorm.incomplete) {
                                $scope.scormOptions.newAttempt = true;
                            }

                            promises.push(getReportedGrades());

                            promises.push(fetchStructure());

                            if (!scorm.packagesize && $scope.errorMessage === '') {
                                // SCORM is supported but we don't have package size. Try to calculate it.
                                promises.push($mmaModScorm.calculateScormSize(scorm).then(function(size) {
                                    scorm.packagesize = size;
                                }));
                            }

                            // Handle status. We don't add getStatus to promises because it should be fast.
                            setStatusListener();
                            getStatus().then(showStatus);

                            return $q.all(promises);
                        });
                    });
                }).catch(function(message) {
                    return showError(message);
                });

            });

        }, function(message) {
            if (!refresh) {
                // Get scorm failed, retry without using cache since it might be a new activity.
                return refreshData();
            }
            return showError(message);
        });
    }

    // Show error message and return a rejected promise.
    function showError(message, defaultMessage) {
        defaultMessage = defaultMessage || 'mma.mod_scorm.errorgetscorm';
        if (message) {
            $mmUtil.showErrorModal(message);
        } else {
            $mmUtil.showErrorModal(defaultMessage, true);
        }
        return $q.reject();
    }

    // Get the grades of each attempt and the grade of the SCORM.
    function getReportedGrades() {
        var promises = [];
        scorm.onlineAttempts = {};
        scorm.offlineAttempts = {};
        // Calculate the grade for each attempt.
        attempts.online.forEach(function(attempt) {
            // Check that attempt isn't in offline to prevent showing the same attempt twice. Offline should be more recent.
            if (attempts.offline.indexOf(attempt) == -1) {
                promises.push(getAttemptGrade(scorm, attempt));
            }
        });
        attempts.offline.forEach(function(attempt) {
            promises.push(getAttemptGrade(scorm, attempt, true));
        });

        return $q.all(promises).then(function() {

            // Calculate the grade of the whole SCORM. We only use online attempts to calculate this data.
            scorm.grade = $mmaModScorm.calculateScormGrade(scorm, scorm.onlineAttempts);

            // Now format the grades.
            angular.forEach(scorm.onlineAttempts, function(attempt) {
                attempt.grade = $mmaModScorm.formatGrade(scorm, attempt.grade);
            });
            angular.forEach(scorm.offlineAttempts, function(attempt) {
                attempt.grade = $mmaModScorm.formatGrade(scorm, attempt.grade);
            });
            scorm.grade = $mmaModScorm.formatGrade(scorm, scorm.grade);
        });
    }

    // Convenience function to get the grade of an attempt and add it to the scorm attempts list.
    function getAttemptGrade(scorm, attempt, offline) {
        return $mmaModScorm.getAttemptGrade(scorm, attempt, offline).then(function(grade) {
            var entry = {
                number: attempt,
                grade: grade
            };
            if (offline) {
                scorm.offlineAttempts[attempt] = entry;
            } else {
                scorm.onlineAttempts[attempt] = entry;
            }
        });
    }

    // Fetch the structure of the SCORM (TOC).
    function fetchStructure() {
        return $mmaModScorm.getOrganizations(scorm.id).then(function(organizations) {
            $scope.organizations = organizations;

            if (!$scope.currentOrganization.identifier) {
                // Load first organization (if any).
                if (organizations.length) {
                    $scope.currentOrganization.identifier = organizations[0].identifier;
                } else {
                    $scope.currentOrganization.identifier = '';
                }
            }

            return loadOrganizationToc($scope.currentOrganization.identifier);
        });
    }

    // Load the TOC of a certain organization.
    function loadOrganizationToc(organizationId) {
        if (!scorm.displaycoursestructure) {
            // TOC is not displayed, no need to load it.
            return $q.when();
        }

        $scope.loadingToc = true;
        return $mmaModScorm.getOrganizationToc(scorm.id, organizationId, lastAttempt, lastOffline).then(function(toc) {
            $scope.toc = $mmaModScorm.formatTocToArray(toc);
            // Get images for each SCO.
            angular.forEach($scope.toc, function(sco) {
                sco.image = $mmaModScorm.getScoStatusIcon(sco, scorm.incomplete);
            });
            // Search organization title.
            angular.forEach($scope.organizations, function(org) {
                if (org.identifier == organizationId) {
                    $scope.currentOrganization.title = org.title;
                }
            });
            // Resize scroll to prevent empty spaces if new TOC is shorter than previous TOC.
            $ionicScrollDelegate.resize();
        }).finally(function() {
            $scope.loadingToc = false;
        });
    }

    // Get status of the SCORM.
    function getStatus() {
        return $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, scorm.sha1hash, 0);
    }

    // Set a listener to monitor changes on this SCORM status to show a message to the user.
    function setStatusListener() {
        if (typeof statusObserver !== 'undefined') {
            return; // Already set.
        }

        // Listen for changes on this module status to show a message to the user.
        statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
            if (data.siteid === $mmSite.getId() && data.componentId === scorm.coursemodule &&
                    data.component === mmaModScormComponent) {
                showStatus(data.status);
            }
        });
    }

    // Showing or hide a status message depending on the SCORM status.
    function showStatus(status) {
        currentStatus = status;

        if (status == mmCoreOutdated) {
            $scope.statusMessage = 'mma.mod_scorm.scormstatusoutdated';
        } else if (status == mmCoreNotDownloaded) {
            $scope.statusMessage = 'mma.mod_scorm.scormstatusnotdownloaded';
        } else if (status == mmCoreDownloading) {
            if (!$scope.downloading) {
                // It's being downloaded right now but the view isn't tracking it. "Restore" the download.
                downloadScormPackage(true);
            }
        } else {
            $scope.statusMessage = '';
        }
    }

    // Refreshes data.
    function refreshData(dontForceSync) {
        var promises = [];
        promises.push($mmaModScorm.invalidateScormData(courseid));
        if (scorm) {
            promises.push($mmaModScorm.invalidateAllScormData(scorm.id));
        }

        return $q.all(promises).finally(function() {
            return fetchScormData(!dontForceSync);
        });
    }

    // Download a SCORM package or restores an ongoing download.
    function downloadScormPackage() {
        $scope.downloading = true;
        return $mmaModScorm.download(scorm).then(undefined, undefined, function(progress) {

            if (!progress) {
                return;
            }

            if (progress.packageDownload) { // Downloading package.
                if (scorm.packagesize) {
                    $scope.percentage = (parseFloat(progress.loaded / scorm.packagesize) * 100).toFixed(1);
                }
            } else if (progress.message) { // Show a message.
                $scope.progressMessage = progress.message;
            } else if (progress.loaded && progress.total) { // Unzipping package.
                $scope.percentage = (parseFloat(progress.loaded / progress.total) * 100).toFixed(1);
            } else {
                $scope.percentage = undefined;
            }

        }).finally(function() {
            $scope.progressMessage = undefined;
            $scope.percentage = undefined;
            $scope.downloading = false;
        });
    }

    // Open a SCORM package.
    function openScorm(scoId) {
        $state.go('site.mod_scorm-player', {
            scorm: scorm,
            mode: $scope.scormOptions.mode,
            newAttempt: !!$scope.scormOptions.newAttempt,
            organizationId: $scope.currentOrganization.identifier,
            scoId: scoId
        });
    }

    // Tries to synchronize the current SCORM.
    function syncScorm(checkTime, showErrors) {
        var promise = checkTime ? $mmaModScormSync.syncScormIfNeeded(scorm) : $mmaModScormSync.syncScorm(scorm);
        return promise.then(function(warnings) {
            var message = $mmaModScormHelper.buildWarningsMessage(warnings);
            if (message) {
                $mmUtil.showErrorModal(message);
            }
        }).catch(function(err) {
            if (showErrors) {
                return showError(err, 'mma.mod_scorm.errorsyncscorm');
            }
            return $q.reject();
        });
    }

    // Fetch the SCORM data.
    fetchScormData().then(function() {
        $mmaModScorm.logView(scorm.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.scormLoaded = true;
    });

    // Load a organization's TOC.
    $scope.loadOrg = function() {
        loadOrganizationToc($scope.currentOrganization.identifier).catch(function(message) {
            return showError(message);
        });
    };

    $scope.refreshScorm = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Open a SCORM. It will download the SCORM package if it's not downloaded or it has changed.
    // The scoId param indicates the SCO that needs to be loaded when the SCORM is opened. If not defined, load first SCO.
    $scope.open = function(e, scoId) {
        e.preventDefault();
        e.stopPropagation();

        if ($scope.downloading) {
            // Scope is being downloaded, abort.
            return;
        }

        if (currentStatus == mmCoreOutdated || currentStatus == mmCoreNotDownloaded) {
            // SCORM needs to be downloaded.
            $mmaModScormHelper.confirmDownload(scorm).then(function() {
                // Invalidate file if SCORM is outdated.
                var promise = currentStatus == mmCoreOutdated ? $mmaModScorm.invalidateContent(scorm.coursemodule) : $q.when();
                promise.finally(function() {
                    downloadScormPackage().then(function() {
                        // Success downloading, open scorm if user hasn't left the view.
                        if (!$scope.$$destroyed) {
                            openScorm(scoId);
                        }
                    }).catch(function() {
                        if (!$scope.$$destroyed) {
                            $mmaModScormHelper.showDownloadError(scorm);
                        }
                    });
                });
            });
        } else {
            openScorm(scoId);
        }
    };

    // Synchronize the SCORM.
    $scope.sync = function() {
        var modal = $mmUtil.showModalLoading('mm.settings.synchronizing', true);
        syncScorm(false, true).then(function() {
            // Refresh the data.
            $scope.scormLoaded = false;
            scrollView.scrollTop();
            refreshData(true).finally(function() {
                $scope.scormLoaded = true;
            });
        }).finally(function() {
            modal.dismiss();
        });
    };

    // Update data when we come back from the player since it's probable that it has changed.
    // We want to skip the first $ionicView.enter event because it's when the view is created.
    var skip = true;
    $scope.$on('$ionicView.enter', function() {
        if (skip) {
            skip = false;
            return;
        }

        $scope.scormOptions.newAttempt = false; // Uncheck new attempt.

        var forwardView = $ionicHistory.forwardView();
        if (forwardView && forwardView.stateName === 'site.mod_scorm-player') {
            $scope.scormLoaded = false;
            scrollView.scrollTop();
            // Add a delay to make sure the player has started the last writing calls so we can detect conflicts.
            $timeout(function() {
                refreshData().finally(function() {
                    $scope.scormLoaded = true;
                });
            }, 500);
        }
    });

    // Refresh data if this SCORM is synchronized automatically.
    var syncObserver = $mmEvents.on(mmaModScormEventAutomSynced, function(data) {
        if (data && data.siteid == $mmSite.getId() && data.scormid == scorm.id) {
            $scope.scormLoaded = false;
            scrollView.scrollTop();
            fetchScormData().finally(function() {
                $scope.scormLoaded = true;
            });
        }
    });

    $scope.$on('$destroy', function() {
        statusObserver && statusObserver.off && statusObserver.off();
        syncObserver && syncObserver.off && syncObserver.off();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM player controller.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc controller
 * @name mmaModScormPlayerCtrl
 */
.controller('mmaModScormPlayerCtrl', ["$scope", "$stateParams", "$mmaModScorm", "$mmUtil", "$ionicPopover", "$mmaModScormHelper", "$mmEvents", "$timeout", "$q", "mmaModScormEventUpdateToc", "mmaModScormEventLaunchNextSco", "mmaModScormEventLaunchPrevSco", "$mmaModScormDataModel12", "mmaModScormEventGoOffline", "$mmaModScormSync", function($scope, $stateParams, $mmaModScorm, $mmUtil, $ionicPopover, $mmaModScormHelper,
            $mmEvents, $timeout, $q, mmaModScormEventUpdateToc, mmaModScormEventLaunchNextSco, mmaModScormEventLaunchPrevSco,
            $mmaModScormDataModel12, mmaModScormEventGoOffline, $mmaModScormSync) {

    var scorm = $stateParams.scorm || {},
        mode = $stateParams.mode || $mmaModScorm.MODENORMAL,
        newAttempt = $stateParams.newAttempt,
        organizationId = $stateParams.organizationId,
        currentSco,
        attempt,
        userData,
        apiInitialized = false,
        offline = false;

    $scope.title = scorm.name; // We use SCORM name at start, later we'll use the SCO title.
    $scope.scorm = scorm;
    $scope.loadingToc = true;

    if (scorm.popup) {
        // If we receive a value <= 100 we need to assume it's a percentage.
        if (scorm.width <= 100) {
            scorm.width = scorm.width + '%';
        }
        if (scorm.height <= 100) {
            scorm.height = scorm.height + '%';
        }
    }

    // Fetch data needed to play the SCORM.
    function fetchData() {
        // Wait for any ongoing sync to finish. We won't sync a SCORM while it's being played.
        return $mmaModScormSync.waitForSync(scorm.id).then(function() {
            // Get attempts data.
            return $mmaModScorm.getAttemptCount(scorm.id).then(function(attemptsData) {
                return determineAttemptAndMode(attemptsData).then(function() {
                    // Fetch TOC and get user data.
                    var promises = [];
                    promises.push(fetchToc());
                    promises.push($mmaModScorm.getScormUserData(scorm.id, attempt, offline).then(function(data) {
                        userData = data;
                    }));

                    return $q.all(promises);
                });
            }).catch(showError);
        });
    }

    // Determine the attempt to use, the mode (normal/preview) and if it's offline or online.
    function determineAttemptAndMode(attemptsData) {
        return $mmaModScormHelper.determineAttemptToContinue(scorm, attemptsData).then(function(data) {
            attempt = data.number;
            offline = data.offline;
            if (attempt != attemptsData.lastAttempt.number) {
                $scope.attemptToContinue = attempt;
            }

            // Check if current attempt is incomplete.
            var promise;
            if (attempt > 0) {
                promise = $mmaModScorm.isAttemptIncomplete(scorm.id, attempt, offline);
            } else {
                // User doesn't have attempts. Last attempt is not incomplete (since he doesn't have any).
                promise = $q.when(false);
            }

            return promise.then(function(incomplete) {
                // Determine mode and attempt to use.
                var result = $mmaModScorm.determineAttemptAndMode(scorm, mode, attempt, newAttempt, incomplete);

                if (result.attempt > attempt) {
                    // We're creating a new attempt.
                    if (offline) {
                        // Last attempt was offline, so we'll create a new offline attempt.
                        promise = $mmaModScormHelper.createOfflineAttempt(scorm, result.attempt, attemptsData.online.length);
                    } else {
                        // Last attempt was online, verify that we can create a new online attempt. We ignore cache.
                        promise = $mmaModScorm.getScormUserData(scorm.id, result.attempt, false, undefined, undefined, true)
                                    .catch(function() {
                            // Cannot communicate with the server, create an offline attempt.
                            offline = true;
                            return $mmaModScormHelper.createOfflineAttempt(scorm, result.attempt, attemptsData.online.length);
                        });
                    }
                } else {
                    promise = $q.when();
                }

                return promise.then(function() {
                    mode = result.mode;
                    newAttempt = result.newAttempt;
                    attempt = result.attempt;
                    $scope.isBrowse = mode === $mmaModScorm.MODEBROWSE;
                    $scope.isReview = mode === $mmaModScorm.MODEREVIEW;
                });
            });
        });
    }

    // Show error and reject.
    function showError(message) {
        if (message) {
            $mmUtil.showErrorModal(message);
        } else {
            $mmUtil.showErrorModal('mma.mod_scorm.errorgetscorm', true);
        }
        return $q.reject();
    }

    // Fetch TOC.
    function fetchToc() {
        $scope.loadingToc = true;
        // We need to check incomplete again: attempt number might have changed in determineAttemptAndMode,
        // or attempt status might have changed due to an action in the current SCO.
        return $mmaModScorm.isAttemptIncomplete(scorm.id, attempt, offline).then(function(incomplete) {
            scorm.incomplete = incomplete;

            // Get TOC.
            return $mmaModScorm.getOrganizationToc(scorm.id, organizationId, attempt, offline).then(function(toc) {
                $scope.toc = $mmaModScorm.formatTocToArray(toc);
                // Get images for each SCO.
                angular.forEach($scope.toc, function(sco) {
                    sco.image = $mmaModScorm.getScoStatusIcon(sco, scorm.incomplete);
                });
                // Determine current SCO if param is set.
                if ($stateParams.scoId > 0) {
                    // SCO set by parameter, get it from TOC.
                    currentSco = $mmaModScormHelper.getScoFromToc($scope.toc, $stateParams.scoId);
                }

                if (!currentSco) {
                    // No SCO defined. Get the first valid one.
                    return $mmaModScormHelper.getFirstSco(scorm.id, $scope.toc, organizationId, attempt, offline)
                            .then(function(sco) {
                        if (sco) {
                            currentSco = sco;
                        } else {
                            // We couldn't find a SCO to load: they're all inactive or without launch URL.
                            $scope.errorMessage = 'mma.mod_scorm.errornovalidsco';
                        }
                    });
                }
            });
        }).finally(function() {
            $scope.loadingToc = false;
        });
    }

    // Calculate the next and previous SCO.
    function calculateNextAndPreviousSco(scoId) {
        $scope.previousSco = $mmaModScormHelper.getPreviousScoFromToc($scope.toc, scoId);
        $scope.nextSco = $mmaModScormHelper.getNextScoFromToc($scope.toc, scoId);
    }

    // Load a SCO.
    function loadSco(sco) {
        // Setup API.
        if (!apiInitialized) {
            $mmaModScormDataModel12.initAPI(scorm, sco.id, attempt, userData, mode, offline);
            apiInitialized = true;
        } else {
            $mmaModScormDataModel12.loadSco(sco.id);
        }

        currentSco = sco;
        $scope.title = sco.title || scorm.name; // Try to use SCO title.
        calculateNextAndPreviousSco(sco.id);
        $mmaModScorm.getScoSrc(scorm, sco).then(function(src) {
            if ($scope.src && src.toString() == $scope.src.toString()) {
                // Re-loading same page. Set it to empty and then re-set the src in the next digest so it detects it has changed.
                $scope.src = '';
                $timeout(function() {
                    $scope.src = src;
                });
            } else {
                $scope.src = src;
            }
        });

        if (sco.scormtype == 'asset') {
            // Mark the asset as completed.
            var tracks = [{
                element: 'cmi.core.lesson_status',
                value: 'completed'
            }];
            $mmaModScorm.saveTracks(sco.id, attempt, tracks, offline, scorm).catch(function() {
                // Error saving data. We'll go offline if we're online and the asset is not marked as completed already.
                if (!offline) {
                    return $mmaModScorm.getScormUserData(scorm.id, attempt, offline).then(function(data) {
                        if (!data[sco.id] || data[sco.id].userdata['cmi.core.lesson_status'] != 'completed') {
                            // Go offline.
                            return $mmaModScormHelper.convertAttemptToOffline(scorm, attempt).then(function() {
                                offline = true;
                                $mmaModScormDataModel12.setOffline(true);
                                return $mmaModScorm.saveTracks(sco.id, attempt, tracks, offline, scorm);
                            }).catch(showError);
                        }
                    });
                }
            }).then(function() {
                // Refresh TOC, some prerequisites might have changed.
                refreshToc();
            });
        }

        // Trigger SCO launch event.
        $mmaModScorm.logLaunchSco(scorm.id, sco.id);
    }

    // Refresh the TOC.
    function refreshToc() {
        $mmaModScorm.invalidateAllScormData(scorm.id).finally(function() {
            fetchToc().catch(showError);
        });
    }

    // Set SCORM start time.
    function setStartTime(scoId) {
        var tracks = [{
            element: 'x.start.time',
            value: $mmUtil.timestamp()
        }];
        return $mmaModScorm.saveTracks(scoId, attempt, tracks, offline, scorm).then(function() {
            if (!offline) {
                // New online attempt created, update cached data about online attempts.
                $mmaModScorm.getAttemptCount(scorm.id, undefined, undefined, false, true);
            }
        });
    }

    $scope.showToc = $mmaModScorm.displayTocInPlayer(scorm);
    if ($scope.showToc) {
        // Setup TOC popover.
        $ionicPopover.fromTemplateUrl('addons/mod_scorm/templates/toc.html', {
            scope: $scope,
        }).then(function(popover) {
            $scope.popover = popover;
        });
    }

    // Fetch the SCORM data.
    fetchData().then(function() {
        if (currentSco) {
            // Set start time if it's a new attempt.
            var promise = newAttempt ? setStartTime(currentSco.id) : $q.when();
            return promise.catch(showError).finally(function() {
                // Load SCO.
                loadSco(currentSco);
            });
        }
    }).finally(function() {
        $scope.loaded = true;
    });

    $scope.loadSco = function(sco) {
        if (!sco.prereq || !sco.isvisible || !sco.launch) {
            return;
        }

        $scope.popover.hide();
        loadSco(sco);
    };

    // Listen for events to update the TOC and navigate through SCOs.
    var tocObserver = $mmEvents.on(mmaModScormEventUpdateToc, function(data) {
        if (data.scormid === scorm.id) {
            if (offline) {
                // Wait a bit to make sure data is stored.
                $timeout(refreshToc, 100);
            } else {
                refreshToc();
            }
        }
    });

    var launchNextObserver = $mmEvents.on(mmaModScormEventLaunchNextSco, function(data) {
        if (data.scormid === scorm.id && $scope.nextSco) {
            loadSco($scope.nextSco);
        }
    });

    var launchPrevObserver = $mmEvents.on(mmaModScormEventLaunchPrevSco, function(data) {
        if (data.scormid === scorm.id && $scope.previousSco) {
            loadSco($scope.previousSco);
        }
    });

    var goOfflineObserver = $mmEvents.on(mmaModScormEventGoOffline, function(data) {
        if (data.scormid === scorm.id && !offline) {
            offline = true;
            $timeout(function() {
                // Wait a bit to prevent collisions between this store and SCORM API's store.
                $mmaModScormHelper.convertAttemptToOffline(scorm, attempt).catch(showError).finally(function() {
                    refreshToc();
                });
            }, 200);
        }
    });

    // Empty src when leaving the state so unload event is triggered in the iframe.
    $scope.$on('$ionicView.beforeLeave', function() {
        $scope.src = '';
    });

    $scope.$on('$destroy', function() {
        tocObserver && tocObserver.off && tocObserver.off();
        launchNextObserver && launchNextObserver.off && launchNextObserver.off();
        launchPrevObserver && launchPrevObserver.off && launchPrevObserver.off();
        goOfflineObserver && goOfflineObserver.off && goOfflineObserver.off();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM data model implementation for version 1.2.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormDataModel12
 */
.factory('$mmaModScormDataModel12', ["$mmaModScorm", "$mmEvents", "$window", "mmaModScormEventLaunchNextSco", "mmaModScormEventLaunchPrevSco", "mmaModScormEventUpdateToc", "mmaModScormEventGoOffline", function($mmaModScorm, $mmEvents, $window, mmaModScormEventLaunchNextSco,
            mmaModScormEventLaunchPrevSco, mmaModScormEventUpdateToc, mmaModScormEventGoOffline) {
    var self = {};

    /**
     * Initialize the global SCORM API class.
     *
     * @param  {Object} scorm    The SCORM object.
     * @param  {Number} scoId    The SCO id.
     * @param  {Number} attempt  The attempt number.
     * @param  {Object} userData The user default data.
     * @param  {String} mode     Mode. One of $mmaModScorm#MODE constants.
     * @param  {Boolean} offline True if attempt is offline, false otherwise.
     */
    function SCORMAPI(scorm, scoId, attempt, userData, mode, offline) {

        // Contains all the current values for all the data model elements for each SCO.
        var currentUserData = {},
            self = this;

        // Current SCO Id.
        self.scoId = scoId;
        self.offline = offline;

        // Convenience function to trigger events.
        function triggerEvent(name) {
            $mmEvents.trigger(name, {
                scormid: scorm.id,
                scoid: self.scoId,
                attempt: attempt
            });
        }

        // Standard Data Type Definition.
        var CMIString256 = '^[\\u0000-\\uFFFF]{0,255}$';
        var CMIString4096 = '^[\\u0000-\\uFFFF]{0,4096}$';
        var CMITime = '^([0-2]{1}[0-9]{1}):([0-5]{1}[0-9]{1}):([0-5]{1}[0-9]{1})(\.[0-9]{1,2})?$';
        var CMITimespan = '^([0-9]{2,4}):([0-9]{2}):([0-9]{2})(\.[0-9]{1,2})?$';
        var CMIInteger = '^\\d+$';
        var CMISInteger = '^-?([0-9]+)$';
        var CMIDecimal = '^-?([0-9]{0,3})(\.[0-9]*)?$';
        var CMIIdentifier = '^[\\u0021-\\u007E]{0,255}$';
        var CMIFeedback = CMIString256; // This must be redefined.
        var CMIIndex = '[._](\\d+).';

        // Vocabulary Data Type Definition.
        var CMIStatus = '^passed$|^completed$|^failed$|^incomplete$|^browsed$';
        var CMIStatus2 = '^passed$|^completed$|^failed$|^incomplete$|^browsed$|^not attempted$';
        var CMIExit = '^time-out$|^suspend$|^logout$|^$';
        var CMIType = '^true-false$|^choice$|^fill-in$|^matching$|^performance$|^sequencing$|^likert$|^numeric$';
        var CMIResult = '^correct$|^wrong$|^unanticipated$|^neutral$|^([0-9]{0,3})?(\.[0-9]*)?$';
        var NAVEvent = '^previous$|^continue$';

        // Children lists.
        var cmi_children = 'core,suspend_data,launch_data,comments,objectives,student_data,student_preference,interactions';
        var core_children = 'student_id,student_name,lesson_location,credit,lesson_status,entry,score,total_time,lesson_mode,exit,session_time';
        var score_children = 'raw,min,max';
        var comments_children = 'content,location,time';
        var objectives_children = 'id,score,status';
        var correct_responses_children = 'pattern';
        var student_data_children = 'mastery_score,max_time_allowed,time_limit_action';
        var student_preference_children = 'audio,language,speed,text';
        var interactions_children = 'id,objectives,time,type,correct_responses,weighting,student_response,result,latency';

        // Data ranges.
        var score_range = '0#100';
        var audio_range = '-1#100';
        var speed_range = '-100#100';
        var weighting_range = '-100#100';
        var text_range = '-1#1';

        // Prepare the definition array containing the default values.
        var def = {};
        // We need an extra object that will contain the objectives and interactions data (all the .n. elements).
        var defExtra = {};

        angular.forEach(userData, function(sco) {
            def[sco.scoid] = sco.defaultdata;
            defExtra[sco.scoid] = sco.userdata;
        });

        // The SCORM 1.2 data model.
        // Set up data model for each sco.
        var datamodel = {};
        for (var scoid in def) {
            datamodel[scoid] = {
                'cmi._children':{'defaultvalue':cmi_children, 'mod':'r', 'writeerror':'402'},
                'cmi._version':{'defaultvalue':'3.4', 'mod':'r', 'writeerror':'402'},
                'cmi.core._children':{'defaultvalue':core_children, 'mod':'r', 'writeerror':'402'},
                'cmi.core.student_id':{'defaultvalue':def[scoid]['cmi.core.student_id'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.student_name':{'defaultvalue':def[scoid]['cmi.core.student_name'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_location':{'defaultvalue':def[scoid]['cmi.core.lesson_location'], 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.credit':{'defaultvalue':def[scoid]['cmi.core.credit'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_status':{'defaultvalue':def[scoid]['cmi.core.lesson_status'], 'format':CMIStatus, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.entry':{'defaultvalue':def[scoid]['cmi.core.entry'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.score._children':{'defaultvalue':score_children, 'mod':'r', 'writeerror':'402'},
                'cmi.core.score.raw':{'defaultvalue':def[scoid]['cmi.core.score.raw'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.score.max':{'defaultvalue':def[scoid]['cmi.core.score.max'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.score.min':{'defaultvalue':def[scoid]['cmi.core.score.min'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.total_time':{'defaultvalue':def[scoid]['cmi.core.total_time'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_mode':{'defaultvalue':def[scoid]['cmi.core.lesson_mode'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.exit':{'defaultvalue':def[scoid]['cmi.core.exit'], 'format':CMIExit, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.core.session_time':{'format':CMITimespan, 'mod':'w', 'defaultvalue':'00:00:00', 'readerror':'404', 'writeerror':'405'},
                'cmi.suspend_data':{'defaultvalue':def[scoid]['cmi.suspend_data'], 'format':CMIString4096, 'mod':'rw', 'writeerror':'405'},
                'cmi.launch_data':{'defaultvalue':def[scoid]['cmi.launch_data'], 'mod':'r', 'writeerror':'403'},
                'cmi.comments':{'defaultvalue':def[scoid]['cmi.comments'], 'format':CMIString4096, 'mod':'rw', 'writeerror':'405'},
                // Deprecated evaluation attributes.
                'cmi.evaluation.comments._count':{'defaultvalue':'0', 'mod':'r', 'writeerror':'402'},
                'cmi.evaluation.comments._children':{'defaultvalue':comments_children, 'mod':'r', 'writeerror':'402'},
                'cmi.evaluation.comments.n.content':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.evaluation.comments.n.location':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.evaluation.comments.n.time':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMITime, 'mod':'rw', 'writeerror':'405'},
                'cmi.comments_from_lms':{'mod':'r', 'writeerror':'403'},
                'cmi.objectives._children':{'defaultvalue':objectives_children, 'mod':'r', 'writeerror':'402'},
                'cmi.objectives._count':{'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.objectives.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score._children':{'pattern':CMIIndex, 'mod':'r', 'writeerror':'402'},
                'cmi.objectives.n.score.raw':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score.min':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score.max':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.status':{'pattern':CMIIndex, 'format':CMIStatus2, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_data._children':{'defaultvalue':student_data_children, 'mod':'r', 'writeerror':'402'},
                'cmi.student_data.mastery_score':{'defaultvalue':def[scoid]['cmi.student_data.mastery_score'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_data.max_time_allowed':{'defaultvalue':def[scoid]['cmi.student_data.max_time_allowed'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_data.time_limit_action':{'defaultvalue':def[scoid]['cmi.student_data.time_limit_action'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_preference._children':{'defaultvalue':student_preference_children, 'mod':'r', 'writeerror':'402'},
                'cmi.student_preference.audio':{'defaultvalue':def[scoid]['cmi.student_preference.audio'], 'format':CMISInteger, 'range':audio_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.language':{'defaultvalue':def[scoid]['cmi.student_preference.language'], 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.speed':{'defaultvalue':def[scoid]['cmi.student_preference.speed'], 'format':CMISInteger, 'range':speed_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.text':{'defaultvalue':def[scoid]['cmi.student_preference.text'], 'format':CMISInteger, 'range':text_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.interactions._children':{'defaultvalue':interactions_children, 'mod':'r', 'writeerror':'402'},
                'cmi.interactions._count':{'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.objectives._count':{'pattern':CMIIndex, 'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.objectives.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.time':{'pattern':CMIIndex, 'format':CMITime, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.type':{'pattern':CMIIndex, 'format':CMIType, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.correct_responses._count':{'pattern':CMIIndex, 'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.correct_responses.n.pattern':{'pattern':CMIIndex, 'format':CMIFeedback, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.weighting':{'pattern':CMIIndex, 'format':CMIDecimal, 'range':weighting_range, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.student_response':{'pattern':CMIIndex, 'format':CMIFeedback, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.result':{'pattern':CMIIndex, 'format':CMIResult, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.latency':{'pattern':CMIIndex, 'format':CMITimespan, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'nav.event':{'defaultvalue':'', 'format':NAVEvent, 'mod':'w', 'readerror':'404', 'writeerror':'405'}
            };

            currentUserData[scoid] = {};

            // Load default values.
            for (var element in datamodel[scoid]) {
                if (element.match(/\.n\./) === null) {
                    if (typeof datamodel[scoid][element].defaultvalue != 'undefined') {
                        currentUserData[scoid][element] = datamodel[scoid][element].defaultvalue;
                    }
                }
            }

            // Load initial user data for current SCO.
            for (element in def[scoid]) {
                if (element.match(/\.n\./) === null) {
                    if (typeof datamodel[scoid][element].defaultvalue != 'undefined') {
                        currentUserData[scoid][element] = datamodel[scoid][element].defaultvalue;
                    } else if (typeof defExtra[scoid][element] != 'undefined') {
                        // Check in user data values.
                        currentUserData[scoid][element] = defExtra[scoid][element];
                    } else {
                        currentUserData[scoid][element] = '';
                    }
                }
            }

            // Load interactions and objectives, and init the counters.
            var expression = new RegExp(CMIIndex,'g');
            var elementDotFormat, counterElement, currentCounterIndex, currentN;
            for (element in defExtra[scoid]) {
                counterElement = '';
                currentCounterIndex = 0;
                // This check for an indexed element. cmi.objectives.1.id or cmi.objectives_1.id.
                if (element.match(expression)) {
                    // Normalize to the expected value according the standard.
                    // Moodle stores this values using _n. instead .n.
                    elementDotFormat = element.replace(expression, ".$1.");
                    currentUserData[scoid][elementDotFormat] = defExtra[scoid][element];

                    // Get the correct counter and current index.
                    if (elementDotFormat.indexOf("cmi.evaluation.comments") === 0) {
                        counterElement = "cmi.evaluation.comments._count";
                        currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                    } else if (elementDotFormat.indexOf("cmi.objectives") === 0) {
                        counterElement = "cmi.objectives._count";
                        currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                    } else if (elementDotFormat.indexOf("cmi.interactions") === 0) {
                        if (elementDotFormat.indexOf(".objectives.") > 0) {
                            currentN = elementDotFormat.match(/cmi.interactions.(\d+)./)[1];
                            currentCounterIndex = elementDotFormat.match(/objectives.(\d+)./)[1];
                            counterElement = "cmi.interactions." + currentN + ".objectives._count";
                        } else if (elementDotFormat.indexOf(".correct_responses.") > 0) {
                            currentN = elementDotFormat.match(/cmi.interactions.(\d+)./)[1];
                            currentCounterIndex = elementDotFormat.match(/correct_responses.(\d+)./)[1];
                            counterElement = "cmi.interactions." + currentN + ".correct_responses._count";
                        } else {
                            counterElement = "cmi.interactions._count";
                            currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                        }
                    }

                    if (counterElement) {
                        if (typeof currentUserData[scoid][counterElement] == "undefined") {
                            currentUserData[scoid][counterElement] = 0;
                        }
                        // Check if we need to sum.
                        if (parseInt(currentCounterIndex) == parseInt(currentUserData[scoid][counterElement])) {
                            currentUserData[scoid][counterElement] = parseInt(currentUserData[scoid][counterElement]) + 1;
                        }
                        if (parseInt(currentCounterIndex) > parseInt(currentUserData[scoid][counterElement])) {
                            currentUserData[scoid][counterElement] = parseInt(currentCounterIndex) - 1;
                        }
                    }

                }
            }

            // Set default status.
            if (currentUserData[scoid]['cmi.core.lesson_status'] === '') {
                currentUserData[scoid]['cmi.core.lesson_status'] = 'not attempted';
            }

            // Define mode and credit.
            currentUserData[scoid]['cmi.core.credit'] = mode == $mmaModScorm.MODENORMAL ? 'credit' : 'no-credit';
            currentUserData[scoid]['cmi.core.lesson_mode'] = mode;
        }

        // API helper methods.

        /**
         * Get the value of the given element from the non-persistent (current) user data.
         *
         * @param  {String} el The element
         * @return {String}    The element value
         */
        function getEl(el) {
            if (typeof currentUserData[self.scoId] != 'undefined' && typeof currentUserData[self.scoId][el] != 'undefined') {
                return currentUserData[self.scoId][el];
            }
            return '';
        }

        /**
         * Set the value of the given element in the non-persistent (current) user data.
         *
         * @param  {String} el The element
         * @param  {String} value The value
         */
        function setEl(el, value) {
            if (typeof currentUserData[self.scoId] == 'undefined') {
                currentUserData[self.scoId] = {};
            }
            currentUserData[self.scoId][el] = value;
        }

        /**
         * Utility function for cloning an object
         *
         * @param {Object} obj The object to  be cloned
         * @return {Object} The object cloned
         */
        function CloneObj(obj){
            if(obj == null || typeof(obj) != 'object') {
                return obj;
            }

            var temp = new obj.constructor(); // Changed (twice).
            for(var key in obj) {
                temp[key] = CloneObj(obj[key]);
            }

            return temp;
        }

        /**
         * Utility function for adding two times in format hh:mm:ss.
         *
         * @param {String} first  First time.
         * @param {String} second Second time.
         * @return {String}       Total time.
         */
        function AddTime (first, second) {
            var sFirst = first.split(":");
            var sSecond = second.split(":");
            var cFirst = sFirst[2].split(".");
            var cSecond = sSecond[2].split(".");
            var change = 0;

            FirstCents = 0;  //Cents
            if (cFirst.length > 1) {
                FirstCents = parseInt(cFirst[1],10);
            }
            SecondCents = 0;
            if (cSecond.length > 1) {
                SecondCents = parseInt(cSecond[1],10);
            }
            var cents = FirstCents + SecondCents;
            change = Math.floor(cents / 100);
            cents = cents - (change * 100);
            if (Math.floor(cents) < 10) {
                cents = "0" + cents.toString();
            }

            var secs = parseInt(cFirst[0],10) + parseInt(cSecond[0],10) + change;  //Seconds
            change = Math.floor(secs / 60);
            secs = secs - (change * 60);
            if (Math.floor(secs) < 10) {
                secs = "0" + secs.toString();
            }

            mins = parseInt(sFirst[1],10) + parseInt(sSecond[1],10) + change;   //Minutes
            change = Math.floor(mins / 60);
            mins = mins - (change * 60);
            if (mins < 10) {
                mins = "0" + mins.toString();
            }

            hours = parseInt(sFirst[0],10) + parseInt(sSecond[0],10) + change;  //Hours
            if (hours < 10) {
                hours = "0" + hours.toString();
            }

            if (cents != '0') {
                return hours + ":" + mins + ":" + secs + '.' + cents;
            } else {
                return hours + ":" + mins + ":" + secs;
            }
        }

        /**
         * Utility function for calculating the total time spent in the SCO.
         */
        function TotalTime() {
            total_time = AddTime(getEl('cmi.core.total_time'), getEl('cmi.core.session_time'));
            return {'element': 'cmi.core.total_time', value: total_time};
        }

        /**
         * Persist the current user data (this is usually called by LMSCommit)
         *
         * @param {Bool} storetotaltime If true, we need to calculate the total time too
         * @return {Bool} [description]
         */
        function StoreData(storetotaltime) {
            if (storetotaltime) {
                if (getEl('cmi.core.lesson_status') == 'not attempted') {
                    setEl('cmi.core.lesson_status', 'completed');
                }
                if (getEl('cmi.core.lesson_mode') == $mmaModScorm.MODENORMAL) {
                    if (getEl('cmi.core.credit') == 'credit') {
                        if (getEl('cmi.student_data.mastery_score') !== '' && getEl('cmi.core.score.raw') !== '') {
                            if (parseFloat(getEl('cmi.core.score.raw')) >= parseFloat(getEl('cmi.student_data.mastery_score'))) {
                                setEl('cmi.core.lesson_status', 'passed');
                            } else {
                                setEl('cmi.core.lesson_status', 'failed');
                            }
                        }
                    }
                }
                if (getEl('cmi.core.lesson_mode') == $mmaModScorm.MODEBROWSE) {
                    if (datamodel[self.scoId]['cmi.core.lesson_status'].defaultvalue == '' && getEl('cmi.core.lesson_status') == 'not attempted') {
                        setEl('cmi.core.lesson_status', 'browsed');
                    }
                }
                tracks = CollectData();
                tracks.push(TotalTime());
            } else {
                tracks = CollectData();
            }
            var success = $mmaModScorm.saveTracksSync(self.scoId, attempt, tracks, self.offline, scorm, currentUserData);
            if (!self.offline && !success) {
                // Failure storing data in online. Go offline.
                self.offline = true;
                triggerEvent(mmaModScormEventGoOffline);
                return $mmaModScorm.saveTracksSync(self.scoId, attempt, tracks, self.offline, scorm, currentUserData);
            }
            return success;
        }

        /**
         * Collect all the user tracking data that must be persisted in the system, this is usually called by LMSCommit().
         *
         */
        function CollectData() {
            var data = [];
            for (var element in currentUserData[self.scoId]) {
                // Ommit for example the nav. elements.
                if (element.substr(0, 3) == 'cmi') {
                    expression = new RegExp(CMIIndex,'g');

                    // Get the generic name for this element (e.g. convert 'cmi.interactions.1.id' to 'cmi.interactions.n.id')
                    elementmodel = String(element).replace(expression,'.n.');

                    // Ignore the session time element.
                    if (element != "cmi.core.session_time") {

                        // Check if this specific element is not defined in the datamodel,
                        // but the generic element name is.
                        if (typeof datamodel[self.scoId][element] == "undefined" &&
                                typeof datamodel[self.scoId][elementmodel] != "undefined") {

                            // Add this specific element to the data model (by cloning
                            // the generic element) so we can track changes to it.
                            datamodel[self.scoId][element] = CloneObj(datamodel[self.scoId][elementmodel]);
                        }

                        // Check if the current element exists in the datamodel.
                        if (typeof datamodel[self.scoId][element] != "undefined") {

                            // Make sure this is not a read only element.
                            if (datamodel[self.scoId][element].mod != 'r') {

                                var el = {
                                    // Moodle stores the organizations and interactions using _n. instead .n.
                                    'element': element.replace(expression, "_$1."),
                                    'value': getEl(element)
                                };

                                // Check if the element has a default value.
                                if (typeof datamodel[self.scoId][element].defaultvalue != "undefined") {

                                    // Check if the default value is different from the current value.
                                    if (datamodel[self.scoId][element].defaultvalue != el['value'] ||
                                            typeof datamodel[self.scoId][element].defaultvalue != typeof(el['value'])) {

                                        data.push(el);

                                        // Update the element default to reflect the current committed value.
                                        datamodel[self.scoId][element].defaultvalue = el['value'];
                                    }
                                } else {
                                    data.push(el);
                                    // No default value for the element, so set it now.
                                    datamodel[self.scoId][element].defaultvalue = el['value'];
                                }
                            }
                        }
                    }
                }

            }
            return data;
        }

        // API methods now.
        var initialized = false;
        var errorCode;
        var timeout;

        self.LMSInitialize = function(param) {
            errorCode = "0";
            if (param == "") {
                if (!initialized) {
                    initialized = true;
                    errorCode = "0";
                    return "true";
                } else {
                    errorCode = "101";
                }
            } else {
                errorCode = "201";
            }

            return "false";
        };

        self.LMSFinish = function(param) {
            errorCode = "0";
            if (param == "") {
                if (initialized) {
                    initialized = false;
                    result = StoreData(true);
                    if (getEl('nav.event') != '') {
                        if (getEl('nav.event') == 'continue') {
                            triggerEvent(mmaModScormEventLaunchNextSco);
                        } else {
                            triggerEvent(mmaModScormEventLaunchPrevSco);
                        }
                    } else {
                        if (scorm.auto == '1') {
                            triggerEvent(mmaModScormEventLaunchNextSco);
                        }
                    }
                    errorCode = (result) ? '0' : '101';

                    // Trigger TOC update.
                    triggerEvent(mmaModScormEventUpdateToc);
                    return result;
                } else {
                    errorCode = "301";
                }
            } else {
                errorCode = "201";
            }
            return "false";
        };

        self.LMSGetValue = function(element) {
            errorCode = "0";
            if (initialized) {
                if (element != "") {
                    expression = new RegExp(CMIIndex,'g');
                    elementmodel = String(element).replace(expression,'.n.');
                    if (typeof datamodel[self.scoId][elementmodel] != "undefined") {
                        if (datamodel[self.scoId][elementmodel].mod != 'w') {
                            errorCode = "0";
                            return getEl(element);
                        } else {
                            errorCode = datamodel[self.scoId][elementmodel].readerror;
                        }
                    } else {
                        childrenstr = '._children';
                        countstr = '._count';
                        if (elementmodel.substr(elementmodel.length - childrenstr.length,elementmodel.length) == childrenstr) {
                            parentmodel = elementmodel.substr(0,elementmodel.length - childrenstr.length);
                            if (typeof datamodel[self.scoId][parentmodel] != "undefined") {
                                errorCode = "202";
                            } else {
                                errorCode = "201";
                            }
                        } else if (elementmodel.substr(elementmodel.length - countstr.length,elementmodel.length) == countstr) {
                            parentmodel = elementmodel.substr(0,elementmodel.length - countstr.length);
                            if (typeof datamodel[self.scoId][parentmodel] != "undefined") {
                                errorCode = "203";
                            } else {
                                errorCode = "201";
                            }
                        } else {
                            errorCode = "201";
                        }
                    }
                } else {
                    errorCode = "201";
                }
            } else {
                errorCode = "301";
            }
            return "";
        };

        self.LMSSetValue = function(element, value) {
            errorCode = "0";
            if (initialized) {
                if (element != "") {
                    expression = new RegExp(CMIIndex,'g');
                    elementmodel = String(element).replace(expression,'.n.');
                    if (typeof datamodel[self.scoId][elementmodel] != "undefined") {
                        if (datamodel[self.scoId][elementmodel].mod != 'r') {
                            expression = new RegExp(datamodel[self.scoId][elementmodel].format);
                            value = value + '';
                            matches = value.match(expression);
                            if (matches != null) {
                                // Create dynamic data model element.
                                if (element != elementmodel) {

                                    // Init default counters and values.
                                    if (element.indexOf("cmi.objectives") === 0) {
                                        currentN = element.match(/cmi.objectives.(\d+)./)[1];
                                        counterElement = "cmi.objectives." + currentN + ".score";
                                        if (typeof currentUserData[self.scoId][counterElement + '._children'] == "undefined") {
                                            setEl(currentUserData[self.scoId][counterElement + '._children'], score_children);
                                            setEl(currentUserData[self.scoId][counterElement + '.raw'], '');
                                            setEl(currentUserData[self.scoId][counterElement + '.min'], '');
                                            setEl(currentUserData[self.scoId][counterElement + '.max'], '');
                                        }

                                    } else if (element.indexOf("cmi.interactions") === 0) {
                                        currentN = element.match(/cmi.interactions.(\d+)./)[1];

                                        counterElement = "cmi.interactions." + currentN + ".objectives._count";
                                        if (typeof currentUserData[self.scoId][counterElement] == "undefined") {
                                            setEl(counterElement, 0);
                                        }
                                        counterElement = "cmi.interactions." + currentN + ".correct_responses._count";
                                        if (typeof currentUserData[self.scoId][counterElement] == "undefined") {
                                            setEl(counterElement, 0);
                                        }
                                    }

                                    elementIndexes = element.split('.');
                                    subelement = 'cmi';
                                    for (i = 1; i < elementIndexes.length - 1; i++) {
                                        elementIndex = elementIndexes[i];
                                        if (elementIndexes[i + 1].match(/^\d+$/)) {
                                            if (typeof currentUserData[self.scoId][subelement + '.' + elementIndex + '._count'] == "undefined") {
                                                setEl(subelement + '.' + elementIndex + '._count', 0);
                                            }
                                            if (elementIndexes[i + 1] == getEl(subelement + '.' + elementIndex + '._count')) {
                                                var count = getEl(subelement + '.' + elementIndex + '._count');
                                                setEl(subelement + '.' + elementIndex + '._count', parseInt(count) + 1);
                                            }
                                            if (elementIndexes[i + 1] > getEl(subelement + '.' + elementIndex + '._count')) {
                                                errorCode = "201";
                                            }
                                            subelement = subelement.concat('.' + elementIndex + '.' + elementIndexes[i + 1]);
                                            i++;
                                        } else {
                                            subelement = subelement.concat('.' + elementIndex);
                                        }
                                    }
                                    element = subelement.concat('.' + elementIndexes[elementIndexes.length - 1]);
                                }
                                //Store data
                                if (errorCode == "0") {
                                    if (scorm.autocommit && !(timeout)) {
                                        timeout = setTimeout(self.LMSCommit, 60000, [""]);
                                    }
                                    if (typeof datamodel[self.scoId][elementmodel].range != "undefined") {
                                        range = datamodel[self.scoId][elementmodel].range;
                                        ranges = range.split('#');
                                        value = value * 1.0;
                                        if ((value >= ranges[0]) && (value <= ranges[1])) {
                                            setEl(element, value);
                                            errorCode = "0";
                                            return "true";
                                        } else {
                                            errorCode = datamodel[self.scoId][elementmodel].writeerror;
                                        }
                                    } else {
                                        if (element == 'cmi.comments') {
                                            setEl('cmi.comments', getEl('cmi.comments') + value);
                                        } else {
                                            setEl(element, value);
                                        }
                                        errorCode = "0";
                                        return "true";
                                    }
                                }
                            } else {
                                errorCode = datamodel[self.scoId][elementmodel].writeerror;
                            }
                        } else {
                            errorCode = datamodel[self.scoId][elementmodel].writeerror;
                        }
                    } else {
                        errorCode = "201";
                    }
                } else {
                    errorCode = "201";
                }
            } else {
                errorCode = "301";
            }
            return "false";
        };

        self.LMSCommit = function(param) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            errorCode = "0";
            if (param == "") {
                if (initialized) {
                    result = StoreData(false);
                    // Trigger TOC update.
                    triggerEvent(mmaModScormEventUpdateToc);

                    errorCode = result ? '0' : '101';
                    return result;
                } else {
                    errorCode = "301";
                }
            } else {
                errorCode = "201";
            }
            return "false";
        };

        self.LMSGetLastError = function() {
            return errorCode;
        };

        var errorString = [];
        errorString["0"] = "No error";
        errorString["101"] = "General exception";
        errorString["201"] = "Invalid argument error";
        errorString["202"] = "Element cannot have children";
        errorString["203"] = "Element not an array - cannot have count";
        errorString["301"] = "Not initialized";
        errorString["401"] = "Not implemented error";
        errorString["402"] = "Invalid set value, element is a keyword";
        errorString["403"] = "Element is read only";
        errorString["404"] = "Element is write only";
        errorString["405"] = "Incorrect data type";

        self.LMSGetErrorString = function(param) {
            if (param != "") {
                return errorString[param];
            } else {
               return "";
            }
        };

        self.LMSGetDiagnostic = function(param) {
            if (param == "") {
                param = errorCode;
            }
            return param;
        };
    }


    /**
     * Prepare the datamodel for SCORM 1.2 populating all the required data.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormDataModel12#initAPI
     * @param  {Object} scorm    The SCORM object.
     * @param  {Number} scoId    The SCO id.
     * @param  {Number} attempt  The attempt number.
     * @param  {Object} userData The user default data.
     * @param  {String} [mode]   Mode. One of $mmaModScorm#MODE constants. By default, MODENORMAL.
     * @param  {Boolean} offline True if attempt is offline, false otherwise.
     */
    self.initAPI = function(scorm, scoId, attempt, userData, mode, offline) {
        mode = mode || $mmaModScorm.MODENORMAL;
        $window.API = new SCORMAPI(scorm, scoId, attempt, userData, mode, offline);
    };

    /**
     * Set a different SCO id for the current API object.
     * The scoId is like a pointer to be able to retrieve the SCO default values and set the new ones in the overall SCORM data structure
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormDataModel12#loadSco
     * @param  {Number} scoId The new SCO id.
     */
    self.loadSco = function(scoId) {
        $window.API.scoId = scoId;
    };

    /**
     * Set offline mode to true or false.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormDataModel12#setOffline
     * @param  {Boolean} offline True if offline, false otherwise.
     */
    self.setOffline = function(offline) {
        $window.API.offline = offline;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Mod scorm handlers.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormHandlers
 */
.factory('$mmaModScormHandlers', ["$mmCourse", "$mmaModScorm", "$mmEvents", "$state", "$mmSite", "$mmaModScormHelper", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModScormComponent", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModScorm, $mmEvents, $state, $mmSite, $mmaModScormHelper,
        $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
        mmaModScormComponent, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModScorm.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn;

                // Create the buttons without action yet. This is to prevent a glitch in the view.
                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download',
                    label: 'mm.core.download'
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true
                };

                $scope.icon = $mmCourse.getModuleIconSrc('scorm');
                $scope.title = module.name;
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_scorm', {module: module, courseid: courseid});
                };

                // Retrieve SCORM to calculate the rest of data.
                $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
                    var revision = scorm.sha1hash,
                        timemodified = 0;

                    function download() {
                        $mmaModScormHelper.confirmDownload(scorm).then(function() {
                            $mmaModScorm.prefetch(scorm).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmaModScormHelper.showDownloadError(scorm);
                                }
                            });
                        });
                    }

                    // Now add the action to the buttons.
                    downloadBtn.action = function(e) {
                        if (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        download();
                    };

                    refreshBtn.action = function(e) {
                        if (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        $mmaModScorm.invalidateContent(scorm.coursemodule).finally(function() {
                            download();
                        });
                    };

                    // Show buttons according to module status.
                    function showStatus(status) {
                        if (status) {
                            $scope.spinner = status === mmCoreDownloading;
                            downloadBtn.hidden = status !== mmCoreNotDownloaded;
                            refreshBtn.hidden = status !== mmCoreOutdated;
                        }
                    }

                    // Listen for changes on this module status.
                    var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                        if (data.siteid === $mmSite.getId() && data.componentId === scorm.coursemodule &&
                                data.component === mmaModScormComponent) {
                            showStatus(data.status);
                        }
                    });

                    // Get current status to decide which icon should be shown.
                    $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                    $scope.$on('$destroy', function() {
                        statusObserver && statusObserver.off && statusObserver.off();
                    });
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModScorm.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a SCORM URL.
            if (url.indexOf('/mod/scorm/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Helper to gather some common SCORM functions.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmCourseHelper
 */
.factory('$mmaModScormHelper', ["$mmaModScorm", "$mmUtil", "$translate", "$q", "$mmaModScormOffline", "$mmaModScormSync", "$mmSite", function($mmaModScorm, $mmUtil, $translate, $q, $mmaModScormOffline, $mmaModScormSync, $mmSite) {

    var self = {},
        elementsToIgnore = ['status', 'score_raw', 'total_time', 'session_time', 'student_id', 'student_name', 'credit',
                            'mode', 'entry']; // List of elements we want to ignore when copying attempts (they're calculated).

    /**
     * Build message to show warnings.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#buildWarningsMessage
     * @param  {String[]} warnings Warnings to show.
     * @return {String}            Message with all the warnings.
     */
    self.buildWarningsMessage = function(warnings) {
        var message = '';
        angular.forEach(warnings, function(warning) {
            if (warning) {
                message = message + '<p>' + warning + '</p>';
            }
        });
        return message;
    };

    /**
     * Creates a new offline attempt based on an existing online attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#convertAttemptToOffline
     * @param  {Object} scorm   SCORM.
     * @param  {Number} attempt Number of the online attempt.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the attempt is created.
     */
    self.convertAttemptToOffline = function(scorm, attempt, siteId) {
        siteId = siteId || $mmSite.getId();

        // Get data from the online attempt.
        return $mmaModScorm.getScormUserData(scorm.id, attempt, false, siteId).then(function(onlineData) {
            // The SCORM API might have written some data to the offline attempt already.
            // We don't want to override it with cached online data.
            return $mmaModScormOffline.getScormUserData(siteId, scorm.id, attempt).catch(function() {
                // Ignore errors.
            }).then(function(offlineData) {
                var dataToStore = angular.copy(onlineData);
                // Filter the data to copy.
                angular.forEach(dataToStore, function(sco) {
                    // Delete calculated data.
                    elementsToIgnore.forEach(function(el) {
                        delete sco.userdata[el];
                    });

                    // Don't override offline data.
                    if (offlineData && offlineData[sco.scoid] && offlineData[sco.scoid].userdata) {
                        var scoUserData = {};
                        angular.forEach(sco.userdata, function(value, element) {
                            if (!offlineData[sco.scoid].userdata[element]) {
                                // This element is not stored in offline, we can save it.
                                scoUserData[element] = value;
                            }
                        });
                        sco.userdata = scoUserData;
                    }
                });

                return $mmaModScormOffline.createNewAttempt(siteId, scorm, undefined, attempt, dataToStore, onlineData);
            });
        }).catch(function() {
            // Shouldn't happen.
            return $q.reject($translate.instant('mma.mod_scorm.errorcreateofflineattempt'));
        });
    };

    /**
     * Creates a new offline attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#createOfflineAttempt
     * @param  {Object} scorm      SCORM.
     * @param  {Number} newAttempt Number of the new attempt.
     * @param  {Number} lastOnline Number of the last online attempt.
     * @param {String} [siteId]    Site ID. If not defined, current site.
     * @return {Promise}           Promise resolved when the attempt is created.
     */
    self.createOfflineAttempt = function(scorm, newAttempt, lastOnline, siteId) {
        siteId = siteId || $mmSite.getId();
        // Try to get data from online attempts.
        return self.searchOnlineAttemptUserData(scorm.id, lastOnline, siteId).then(function(userData) {
            // We're creating a new attempt, remove all the user data that is not needed for a new attempt.
            // We need to get the SCO data from here because WS get_scoes doesn't return sco_data in Moodle 3.0.
            angular.forEach(userData, function(sco) {
                var filtered = {};
                angular.forEach(sco.userdata, function(value, element) {
                    if (element.indexOf('.') == -1 && elementsToIgnore.indexOf(element) == -1) {
                        // The element doesn't use a dot notation, probably SCO data.
                        filtered[element] = value;
                    }
                });
                sco.userdata = filtered;
            });
            return $mmaModScormOffline.createNewAttempt(siteId, scorm, undefined, newAttempt, userData);
        }).catch(function() {
            return $q.reject($translate.instant('mma.mod_scorm.errorcreateofflineattempt'));
        });
    };

    /**
     * Show a confirm dialog if needed. If SCORM doesn't have size, try to calculate it.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#confirmDownload
     * @param {Object} scorm SCORM to download.
     * @return {Promise}     Promise resolved if the user confirms or no confirmation needed.
     */
    self.confirmDownload = function(scorm) {
        var promise;
        if (!scorm.packagesize) {
            // We don't have package size, try to calculate it.
            promise = $mmaModScorm.calculateScormSize(scorm).then(function(size) {
                // Store it so we don't have to calculate it again when using the same object.
                scorm.packagesize = size;
                return size;
            });
        } else {
            promise = $q.when(scorm.packagesize);
        }

        return promise.then(function(size) {
            return $mmUtil.confirmDownloadSize(size);
        });
    };

    /**
     * Determines the attempt to continue/review. It will be:
     * - The last incomplete online attempt if it hasn't been continued in offline and all offline attempts are complete.
     * - The attempt with highest number without surpassing max attempts otherwise.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#determineAttemptToContinue
     * @param  {Object} scorm    SCORM.
     * @param  {Object} attempts Result of $mmaModScorm#getAttemptCount.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with an object with 2 properties: 'number' and 'offline'.
     */
    self.determineAttemptToContinue = function(scorm, attempts, siteId) {
        siteId = siteId || $mmSite.getId();
        var lastOnline,
            result = {
                number: 0,
                offline: false
            };

        // Get the last attempt. It'll be the highest number as long as it doesn't surpass the max number of attempts.
        function getLastBeforeMax() {
            if (scorm.maxattempt != 0 && attempts.lastAttempt.number > scorm.maxattempt) {
                result.number = scorm.maxattempt;
                result.offline = attempts.offline.indexOf(scorm.maxattempt) > -1;
            } else {
                result.number = attempts.lastAttempt.number;
                result.offline = attempts.lastAttempt.offline;
            }
        }

        // Get last online attempt.
        if (attempts.online.length) {
            lastOnline = Math.max.apply(Math, attempts.online);
        }

        if (lastOnline) {
            // Check if last online incomplete.
            var hasOffline = attempts.offline.indexOf(lastOnline) > -1;
            return $mmaModScorm.isAttemptIncomplete(scorm.id, lastOnline, hasOffline, false, siteId).then(function(incomplete) {
                if (incomplete) {
                    result.number = lastOnline;
                    result.offline = hasOffline;
                } else {
                    getLastBeforeMax();
                }
                return result;
            });
        } else {
            getLastBeforeMax();
            return $q.when(result);
        }
    };

    /**
     * Get the first SCO to load in a SCORM. If a non-empty TOC is provided, it will be the first valid SCO in the TOC.
     * Otherwise, it will be the first valid SCO returned by $mmaModScorm#getScos.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getFirstSco
     * @param {String} scormId        Scorm ID.
     * @param {Object[]} [toc]        SCORM's TOC.
     * @param {String} [organization] Organization to use.
     * @param {Number} attempt        Attempt number.
     * @param {Boolean} offline       True if attempt is offline, false otherwise.
     * @param {String} [siteId]       Site ID. If not defined, current site.
     * @return {Promise}              Promise resolved with the first SCO.
     */
    self.getFirstSco = function(scormId, toc, organization, attempt, offline, siteId) {
        siteId = siteId || $mmSite.getId();
        var promise;
        if (toc && toc.length) {
            promise = $q.when(toc);
        } else {
            // SCORM doesn't have a TOC. Get all the scos.
            promise = $mmaModScorm.getScosWithData(scormId, organization, attempt, offline, false, siteId);
        }

        return promise.then(function(scos) {
            // Search the first valid SCO.
            for (var i = 0; i < scos.length; i++) {
                var sco = scos[i];
                if (sco.isvisible && sco.prereq && sco.launch) {
                    return sco;
                }
            }
        });
    };

    /**
     * Given a TOC in array format (@see $mmaModScorm#formatTocToArray) and a scoId, return the next available SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getNextScoFromToc
     * @param  {Object[]} toc SCORM's TOC.
     * @param  {Number} scoId SCO ID.
     * @return {Object}       Next SCO.
     */
    self.getNextScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                // We found the current SCO. Now let's search the next visible SCO with fulfilled prerequisites.
                for (var j = i + 1; j < len; j++) {
                    if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {
                        return toc[j];
                    }
                }
                break;
            }
        }
    };

    /**
     * Given a TOC in array format (@see $mmaModScorm#formatTocToArray) and a scoId, return the previous available SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getPreviousScoFromToc
     * @param  {Object[]} toc SCORM's TOC.
     * @param  {Number} scoId SCO ID.
     * @return {Object}       Previous SCO.
     */
    self.getPreviousScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                // We found the current SCO. Now let's search the previous visible SCO with fulfilled prerequisites.
                for (var j = i - 1; j >= 0; j--) {
                    if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {
                        return toc[j];
                    }
                }
                break;
            }
        }
    };

    /**
     * Given a TOC in array format (@see $mmaModScorm#formatTocToArray) and a scoId, return the SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getScoFromToc
     * @param  {Object[]} toc SCORM's TOC.
     * @param  {Number} scoId SCO ID.
     * @return {Object}       SCO.
     */
    self.getScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                return toc[i];
            }
        }
    };

    /**
     * Get SCORM sync time in a human readable format.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getScormReadableSyncTime
     * @param  {Number} scormId SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the readable time.
     */
    self.getScormReadableSyncTime = function(scormId, siteId) {
        return $mmaModScormSync.getScormSyncTime(scormId, siteId).then(function(time) {
            if (time == 0) {
                return $translate('mm.core.none');
            } else {
                return moment(time).format('LLL');
            }
        });
    };

    /**
     * Searches user data for an online attempt. If the data can't be retrieved,
     * re-try with the previous online attempt (if exists).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#searchOnlineAttemptUserData
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Online attempt to get the data.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with user data.
     */
    self.searchOnlineAttemptUserData = function(scormId, attempt, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId).catch(function() {
            if (attempt > 0) {
                // We couldn't retrieve the data. Try again with the previous online attempt.
                return self.searchOnlineAttemptUserData(scormId, attempt - 1, siteId);
            } else {
                // No more attempts to try. Reject
                return $q.reject();
            }
        });
    };

    /**
     * Show error because a SCORM download failed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#showDownloadError
     * @param {Object} scorm SCORM downloaded.
     * @return {Void}
     */
    self.showDownloadError = function(scorm) {
        $translate('mma.mod_scorm.errordownloadscorm', {name: scorm.name}).then(function(message) {
            $mmUtil.showErrorModal(message);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Mod SCORM prefetch handler.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormPrefetchHandler
 */
.factory('$mmaModScormPrefetchHandler', ["$mmaModScorm", "mmaModScormComponent", function($mmaModScorm, mmaModScormComponent) {

    var self = {};

    self.component = mmaModScormComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getDownloadSize
     * @param {Object} module   Module to get the size.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Promise}        Promise resolved with the size.
     */
    self.getDownloadSize = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            if ($mmaModScorm.isScormSupported(scorm) !== true) {
                return 0;
            } else if (!scorm.packagesize) {
                // We don't have package size, try to calculate it.
                return $mmaModScorm.calculateScormSize(scorm);
            } else {
                return scorm.packagesize;
            }
        });
    };

    /**
     * Get the list of downloadable files.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getFiles
     * @param {Object} module   Module to get the files.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Promise}         Size.
     */
    self.getFiles = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return $mmaModScorm.getScormFileList(scorm);
        }).catch(function() {
            // SCORM not found, return empty list.
            return [];
        });
    };

    /**
     * Get revision of a SCORM (sha1hash).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getRevision
     * @param {Object} module   Module to get the revision.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Number}         Timemodified.
     */
    self.getRevision = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return scorm.sha1hash;
        });
    };

    /**
     * Get timemodified of a SCORM. It always return 0, we don't use timemodified for SCORM packages.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getTimemodified
     * @param {Object} module   Module to get the timemodified.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Number}         Timemodified.
     */
    self.getTimemodified = function(module, courseid) {
        return 0;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmaModScorm.isPluginEnabled();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#prefetch
     * @param {Object} module   The module object returned by WS.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Promise}        Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return $mmaModScorm.prefetch(scorm);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM service.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScorm
 */
.factory('$mmaModScorm', ["$mmSite", "$q", "$translate", "$mmLang", "$mmFilepool", "$mmFS", "$mmWS", "$sce", "$mmaModScormOnline", "$state", "$mmaModScormOffline", "$mmUtil", "$log", "$mmSitesManager", "mmaModScormComponent", "mmCoreNotDownloaded", function($mmSite, $q, $translate, $mmLang, $mmFilepool, $mmFS, $mmWS, $sce, $mmaModScormOnline, $state,
            $mmaModScormOffline, $mmUtil, $log, $mmSitesManager, mmaModScormComponent, mmCoreNotDownloaded) {
    $log = $log.getInstance('$mmaModScorm');

    var self = {},
        statuses = ['notattempted', 'passed', 'completed', 'failed', 'incomplete', 'browsed', 'suspend'],
        downloadPromises = {}; // Store download promises to be able to restore them.

    // Constants.
    self.GRADESCOES     = 0;
    self.GRADEHIGHEST   = 1;
    self.GRADEAVERAGE   = 2;
    self.GRADESUM       = 3;

    self.HIGHESTATTEMPT = 0;
    self.AVERAGEATTEMPT = 1;
    self.FIRSTATTEMPT   = 2;
    self.LASTATTEMPT    = 3;

    self.MODEBROWSE = 'browse';
    self.MODENORMAL = 'normal';
    self.MODEREVIEW = 'review';

    /**
     * Calculates the SCORM grade based on the grading method and the list of attempts scores.
     * We only treat online attempts to calculate a SCORM grade.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#calculateScormGrade
     * @param  {Object} scorm           SCORM.
     * @param  {Object} onlineAttempts  Online attempts. Each attempt must have a property called "grade".
     * @return {Number}                 Grade. -1 if no grade.
     */
    self.calculateScormGrade = function(scorm, onlineAttempts) {
        if (!onlineAttempts || !Object.keys(onlineAttempts).length) {
            return -1;
        }

        switch (scorm.whatgrade) {
            case self.FIRSTATTEMPT:
                return onlineAttempts[1] ? onlineAttempts[1].grade : -1;
            case self.LASTATTEMPT:
                var max = 0;
                angular.forEach(Object.keys(onlineAttempts), function(number) {
                    max = Math.max(number, max);
                });
                if (max > 0) {
                    return onlineAttempts[max].grade;
                }
                return -1;
            case self.HIGHESTATTEMPT:
                var grade = 0;
                angular.forEach(onlineAttempts, function(attempt) {
                    grade = Math.max(attempt.grade, grade);
                });
                return grade;
            case self.AVERAGEATTEMPT:
                var sumgrades = 0,
                    total = 0;
                angular.forEach(onlineAttempts, function(attempt) {
                    sumgrades += attempt.grade;
                    total++;
                });
                return Math.round(sumgrades / total);
        }

        return -1;
    };

    /**
     * Calculates the size of a SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#calculateScormSize
     * @param {Object} scorm SCORM.
     * @return {Promise}     Promise resolved with the SCORM size.
     */
    self.calculateScormSize = function(scorm) {
        if (scorm.packagesize) {
            return $q.when(scorm.packagesize);
        }

        return $mmWS.getRemoteFileSize(self.getPackageUrl(scorm));
    };

    /**
     * Count the attempts left for the given scorm.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#countAttemptsLeft
     * @param {Object} scorm         SCORM.
     * @param {Number} attemptsCount Number of attempts performed.
     * @return {Number}              Number of attempts left.
     */
    self.countAttemptsLeft = function(scorm, attemptsCount) {
        if (scorm.maxattempt == 0) {
            return Number.MAX_VALUE; // Unlimited attempts.
        }

        attemptsCount = parseInt(attemptsCount, 10);
        if (isNaN(attemptsCount)) {
            return -1;
        }
        return scorm.maxattempt - attemptsCount;
    };

    /**
     * Returns the mode and attempt number to use based on mode selected and SCORM data.
     * This function is based on Moodle's scorm_check_mode.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#determineAttemptAndMode
     * @param {Object} scorm       SCORM.
     * @param {String} mode        Selected mode.
     * @param {Number} attempt     Current attempt.
     * @param {Boolean} newAttempt True if should start a new attempt, false otherwise.
     * @param {Boolean} incomplete True if current attempt is incomplete, false otherwise.
     * @return {Object}            Object with properties: 'mode', 'attempt' and 'newAttempt'.
     */
    self.determineAttemptAndMode = function(scorm, mode, attempt, newAttempt, incomplete) {
        if (mode == self.MODEBROWSE) {
            if (scorm.hidebrowse) {
                // Prevent Browse mode if hidebrowse is set.
                mode = self.MODENORMAL;
            } else {
                // We don't need to check attempts as browse mode is set.
                if (attempt == 0) {
                    attempt = 1;
                    newAttempt = true;
                }

                return {
                    mode: mode,
                    attempt: attempt,
                    newAttempt: newAttempt
                };
            }
        }

        // Validate user request to start a new attempt.
        if (attempt == 0) {
            newAttempt = true;
        } else if (incomplete) {
            // The option to start a new attempt should never have been presented. Force false.
            newAttempt = false;
        } else if (scorm.forcenewattempt) {
            // A new attempt should be forced for already completed attempts.
            newAttempt = true;
        }

        if (newAttempt && (scorm.maxattempt == 0 || attempt < scorm.maxattempt)) {
            // Create a new attempt. Force mode normal.
            attempt++;
            mode = self.MODENORMAL;
        } else {
            if (incomplete) {
                // We can't review an incomplete attempt.
                mode = self.MODENORMAL;
            } else {
                // We aren't starting a new attempt and the current one is complete, force review mode.
                mode = self.MODEREVIEW;
            }
        }

        return {
            mode: mode,
            attempt: attempt,
            newAttempt: newAttempt
        };
    };

    /**
     * Check if TOC should be displayed in the player.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#displayTocInPlayer
     * @param {Object} scorm SCORM.
     * @return {Boolean}     True if should display TOC, false otherwise.
     */
    self.displayTocInPlayer = function(scorm) {
        return scorm.hidetoc !== 3;
    };

    /**
     * Download and unzips the SCORM package.
     * @see $mmaModScorm#_downloadOrPrefetch
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#download
     * @param {Object} scorm SCORM object returned by $mmaModScorm#getScorm.
     * @return {Promise}     Promise resolved when the package is downloaded and unzipped.
     */
    self.download = function(scorm) {
        return self._downloadOrPrefetch(scorm, false);
    };

    /**
     * Downloads/Prefetches and unzips the SCORM package.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#_downloadOrPrefetch
     * @param {Object} scorm     SCORM object returned by $mmaModScorm#getScorm.
     * @param {Boolean} prefetch True if prefetch, false otherwise.
     * @return {Promise}         Promise resolved when the package is downloaded and unzipped. It will call notify in these cases:
     *                                   -File download in progress. Notify object will have these properties:
     *                                       packageDownload {Boolean} Always true.
     *                                       loaded {Number} Number of bytes of the package loaded.
     *                                       fileProgress {Object} FileTransfer's notify param for the current file.
     *                                   -Download or unzip starting. Notify object will have these properties:
     *                                       message {String} Message code related to the starting operation.
     *                                   -File unzip in progress. Notify object will have these properties:
     *                                       loaded {Number} Number of bytes unzipped.
     *                                       total {Number} Total of bytes of the ZIP file.
     * @protected
     */
    self._downloadOrPrefetch = function(scorm, prefetch) {
        var result = self.isScormSupported(scorm),
            siteId = $mmSite.getId();
        if (result !== true) {
            return $mmLang.translateAndReject(result);
        }

        if (downloadPromises[siteId] && downloadPromises[siteId][scorm.id]) {
            // There's already a download ongoing for this package, return the promise.
            return downloadPromises[siteId][scorm.id];
        } else if (!downloadPromises[siteId]) {
            downloadPromises[siteId] = {};
        }

        var files = self.getScormFileList(scorm),
            revision = scorm.sha1hash, // We use sha1hash instead of revision number.
            dirPath,
            deferred = $q.defer(), // We use a deferred to be able to notify.
            fn = prefetch ? $mmFilepool.prefetchPackage : $mmFilepool.downloadPackage;

        downloadPromises[siteId][scorm.id] = deferred.promise; // Store promise to be able to restore it later.

        // Get the folder where the unzipped files will be.
        self.getScormFolder(scorm.moduleurl).then(function(path) {
            dirPath = path;
            // Download the ZIP file to the filepool.
            // Using undefined for success & fail will pass the success/failure to the parent promise.
            deferred.notify({message: 'mm.core.downloading'});
            return fn(siteId, files, mmaModScormComponent, scorm.coursemodule, revision, 0)
                                                        .then(undefined, undefined, deferred.notify);
        }).then(function() {
            // Remove the destination folder to prevent having old unused files.
            return $mmFS.removeDir(dirPath).catch(function() {
                // Ignore errors, it might have failed because the folder doesn't exist.
            });
        }).then(function() {
            // Get the ZIP file path.
            return $mmFilepool.getFilePathByUrl(siteId, self.getPackageUrl(scorm));
        }).then(function(zippath) {
            // Unzip and delete the zip when finished.
            deferred.notify({message: 'mm.core.unzipping'});
            return $mmFS.unzipFile(zippath, dirPath).then(function() {
                return $mmFilepool.removeFileByUrl(siteId, self.getPackageUrl(scorm)).catch(function() {
                    // Ignore errors.
                });
            }, function(error) {
                // Error unzipping. Set status as not downloaded and reject.
                return $mmFilepool.storePackageStatus(siteId, mmaModScormComponent, scorm.coursemodule,
                                            mmCoreNotDownloaded, revision, 0).then(function() {
                    return $q.reject(error);
                });
            }, deferred.notify);
        }).then(deferred.resolve, deferred.reject).finally(function() {
            delete downloadPromises[siteId][scorm.id]; // Delete stored promise.
        });

        return deferred.promise;
    };

    /**
     * This is a little language parser for AICC_SCRIPT.
     * Evaluates the expression and returns a boolean answer.
     * See 2.3.2.5.1. Sequencing/Navigation Today  - from the SCORM 1.2 spec (CAM).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#evalPrerequisites
     * @param  {String} prerequisites The AICC_SCRIPT prerequisites expression.
     * @param  {Object} trackData     The tracked user data of each SCO.
     * @return {Boolean}              True if prerequisites are fulfilled, false otherwise.
     */
    self.evalPrerequisites = function(prerequisites, trackData) {

        var stack = [],
            statuses = {
                'passed': 'passed',
                'completed': 'completed',
                'failed': 'failed',
                'incomplete': 'incomplete',
                'browsed': 'browsed',
                'not attempted': 'notattempted',
                'p': 'passed',
                'c': 'completed',
                'f': 'failed',
                'i': 'incomplete',
                'b': 'browsed',
                'n': 'notattempted'
            };

        // Expand the amp entities.
        prerequisites = prerequisites.replace(/&amp;/gi, '&');
        // Find all my parsable tokens.
        prerequisites = prerequisites.replace(/(&|\||\(|\)|\~)/gi, '\t$1\t');
        // Expand operators.
        prerequisites = prerequisites.replace(/&/gi, '&&');
        prerequisites = prerequisites.replace(/\|/gi, '||');
        // Now - grab all the tokens.
        var elements = prerequisites.trim().split('\t');

        // Process each token to build an expression to be evaluated.
        angular.forEach(elements, function(element) {
            element = element.trim();
            if (!element) {
                return;
            }
            if (!element.match(/^(&&|\|\||\(|\))$/gi)) {
                // Create each individual expression.
                // Search for ~ = <> X*{} .

                var re = /^(\d+)\*\{(.+)\}$/, // Sets like 3*{S34, S36, S37, S39}.
                    reOther = /^(.+)(\=|\<\>)(.+)$/, // Other symbols.
                    matches;

                if (re.test(element)) {
                    matches = element.match(re);

                    var repeat = matches[1],
                        set = matches[2].split(','),
                        count = 0;
                    angular.forEach(set, function(setelement) {
                        setelement = setelement.trim();
                        if (typeof trackData[setelement] != 'undefined' &&
                                (trackData[setelement].status == 'completed' || trackData[setelement].status == 'passed')) {
                            count++;
                        }
                    });
                    if (count >= repeat) {
                        element = 'true';
                    } else {
                        element = 'false';
                    }
                } else if (element == '~') {
                    // Not maps ~.
                    element = '!';
                } else if (reOther.test(element)) {
                    // Other symbols = | <> .
                    matches = element.match(reOther);
                    element = matches[1].trim();
                    if (typeof trackData[element] != 'undefined') {
                        value = matches[3].trim().replace(/(\'|\")/gi);
                        if (typeof statuses[value] != 'undefined') {
                            value = statuses[value];
                        }
                        if (matches[2] == '<>') {
                            oper = '!=';
                        } else {
                            oper = '==';
                        }
                        element = '(\'' + trackData[element].status + '\' ' + oper + ' \'' + value + '\')';
                    } else {
                        element = 'false';
                    }
                } else {
                    // Everything else must be an element defined like S45 ...
                    if (typeof trackData[element] != 'undefined' &&
                            (trackData[element].status == 'completed' || trackData[element].status == 'passed')) {
                        element = 'true';
                    } else {
                        element = 'false';
                    }
                }

            }
            stack.push(' ' + element + ' ');
        });

        return eval(stack.join('') + ';');
    };

    /**
     * Formats a grade to be displayed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#formatGrade
     * @param  {Object} scorm SCORM.
     * @param  {Number} grade Grade.
     * @return {String}       Grade to display.
     */
    self.formatGrade = function(scorm, grade) {
        if (typeof grade == 'undefined' || grade == -1) {
            return $translate.instant('mm.core.none');
        }
        if (scorm.grademethod !== self.GRADESCOES && scorm.maxgrade > 0) {
            grade = (grade / scorm.maxgrade) * 100;
            return $translate.instant('mm.core.percentagenumber', {$a: $mmUtil.roundToDecimals(grade, 2)});
        }
        return grade;
    };

    /**
     * Formats a tree-like TOC into an array.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#formatTocToArray
     * @param {Object[]} toc     SCORM's TOC (tree format).
     * @param {Number} [level=0] The level of the TOC we're right now. 0 by default.
     * @return {Object[]}        SCORM's TOC (array format).
     */
    self.formatTocToArray = function(toc, level) {
        if (!toc || !toc.length) {
            return [];
        }

        if (typeof level == 'undefined') {
            level = 0;
        }

        var formatted = [];
        angular.forEach(toc, function(node) {
            node.level = level;
            formatted.push(node);
            formatted = formatted.concat(self.formatTocToArray(node.children, level + 1));
        });

        return formatted;
    };

    /**
     * Get the number of attempts done by a user in the given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getAttemptCount
     * @param {Number} scormId        SCORM ID.
     * @param {String} [siteId]       Site ID. If not defined, current site.
     * @param {Number} [userId]       User ID. If not defined use site's current user.
     * @param {Boolean} ignoreMissing True if it should ignore attempts without grade/completion. Only for online attempts.
     * @param {Boolean} ignoreCache   True if it should ignore cached data for online attempts.
     * @return {Promise}              Promise resolved when the attempt count is retrieved. It returns an object with
     *                                online attempts, offline attempts, total number of attempts and last attempt.
     */
    self.getAttemptCount = function(scormId, siteId, userId, ignoreMissing, ignoreCache) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var result = {
                    lastAttempt: {
                        number: 0,
                        offline: false
                    }
                },
                promises = [];

            promises.push($mmaModScormOnline.getAttemptCount(siteId, scormId, userId, ignoreMissing, ignoreCache)
                        .then(function(count) {
                // Calculate numbers of online attempts.
                result.online = [];
                for (var i = 1; i <= count; i++) {
                    result.online.push(i);
                }
                // Calculate last attempt.
                if (count > result.lastAttempt.number) {
                    result.lastAttempt.number = count;
                    result.lastAttempt.offline = false;
                }
            }));

            promises.push($mmaModScormOffline.getAttempts(siteId, scormId, userId).then(function(attempts) {
                // Get only attempt numbers.
                result.offline = attempts.map(function(entry) {
                    // Calculate last attempt. We use >= to prioritize offline events if an attempt is both online and offline.
                    if (entry.attempt >= result.lastAttempt.number) {
                        result.lastAttempt.number = entry.attempt;
                        result.lastAttempt.offline = true;
                    }
                    return entry.attempt;
                });
            }));

            return $q.all(promises).then(function() {
                var total = result.online.length;
                result.offline.forEach(function(attempt) {
                    // Check if this attempt also exists in online, it might have been copied to local.
                    if (result.online.indexOf(attempt) == -1) {
                        total++;
                    }
                });
                result.total = total;
                return result;
            });
        });
    };

    /**
     * Get the grade for a certain SCORM and attempt.
     * Based on Moodle's scorm_grade_user_attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getAttemptGrade
     * @param {Number} scormid  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Boolean} offline True if attempt is offline, false otherwise.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the grade. If the attempt hasn't reported grade/completion, grade will be -1.
     */
    self.getAttemptGrade = function(scorm, attempt, offline, siteId) {
        var attemptscore = {
            scos: 0,
            values: 0,
            max: 0,
            sum: 0
        };

        return self.getScormUserData(scorm.id, attempt, offline, siteId).then(function(data) {
            angular.forEach(data, function(scodata) {
                var userdata = scodata.userdata;
                if (userdata.status == 'completed' || userdata.status == 'passed') {
                    attemptscore.scos++;
                }

                if (userdata.score_raw || (typeof scorm.scormtype != 'undefined' &&
                            scorm.scormtype == 'sco' && typeof userdata.score_raw != 'undefined')) {
                    var scoreraw = parseFloat(userdata.score_raw);
                    attemptscore.values++;
                    attemptscore.sum += scoreraw;
                    attemptscore.max = Math.max(scoreraw, attemptscore.max);
                }
            });

            var score = 0;
            switch (scorm.grademethod) {
                case self.GRADEHIGHEST:
                    score = attemptscore.max;
                break;
                case self.GRADEAVERAGE:
                    if (attemptscore.values > 0) {
                        score = attemptscore.sum / attemptscore.values;
                    } else {
                        score = 0;
                    }
                break;
                case self.GRADESUM:
                    score = attemptscore.sum;
                break;
                case self.GRADESCOES:
                    score = attemptscore.scos;
                break;
                default:
                    score = attemptscore.max;   // Remote Learner GRADEHIGHEST is default.
            }

            return score;
        });
    };

    /**
     * Get the list of a organizations defined in a SCORM package.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getOrganizations
     * @param  {Number} scormId SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the list of organizations.
     */
    self.getOrganizations = function(scormId, siteId) {
        return self.getScos(scormId, siteId).then(function(scos) {
            var organizations = [];
            angular.forEach(scos, function(sco) {
                // Is an organization entry?
                if (sco.organization == '' && sco.parent == '/' && sco.scormtype == '') {
                    organizations.push({
                        identifier: sco.identifier,
                        title: sco.title,
                        sortorder: sco.sortorder
                    });
                }
            });
            return organizations;
        });
    };

    /**
     * Get the organization Toc object
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getOrganizationToc
     * @param  {Number} scormId      SCORM ID.
     * @param  {String} organization Organization identifier.
     * @param  {Number} attempt      The attempt number (to populate SCO track data).
     * @param {Boolean} offline      True if attempt is offline, false otherwise.
     * @param {String} [siteId]      Site ID. If not defined, current site.
     * @return {Promise}             Promise resolved with the toc object.
     */
    self.getOrganizationToc = function(scormId, organization, attempt, offline, siteId) {

        return self.getScosWithData(scormId, organization, attempt, offline, false, siteId).then(function(scos) {
            var map = {},
                rootScos = [];

            angular.forEach(scos, function(sco, index) {
                sco.children = [];
                map[sco.identifier] = index;
                if (sco.parent !== '/') {
                    if (sco.parent == organization) {
                        // It's a root SCO, add it to the root array.
                        rootScos.push(sco);
                    } else {
                        // Add this sco to the parent.
                        scos[map[sco.parent]].children.push(sco);
                    }
                }
            });

            return rootScos;
        });
    };

    /**
     * Get the package URL of a given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getPackageUrl
     * @param  {Object} scorm SCORM.
     * @return {String}       Package URL.
     */
    self.getPackageUrl = function(scorm) {
        if (scorm.packageurl) {
            return scorm.packageurl;
        }
        if (scorm.reference) {
            return scorm.reference;
        }
        return '';
    };

    /**
     * Get the user data for a certain SCORM and attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormUserData
     * @param {Number} scormId      SCORM ID.
     * @param {Number} attempt      Attempt number.
     * @param {Boolean} offline     True if attempt is offline, false otherwise.
     * @param {String} [siteId]     Site ID. If not defined, current site.
     * @param {Object[]} [scos]     SCOs returned by $mmaModScorm#getScos. Recommended if offline=true.
     * @param {Boolean} ignoreCache True if it should ignore cached data for online attempts.
     * @return {Promise}            Promise resolved when the user data is retrieved.
     */
    self.getScormUserData = function(scormId, attempt, offline, siteId, scos, ignoreCache) {
        siteId = siteId || $mmSite.getId();
        if (offline) {
            var promise = scos ? $q.when(scos) : self.getScos(scormId, siteId);
            return promise.then(function(scos) {
                return $mmaModScormOffline.getScormUserData(siteId, scormId, attempt, undefined, scos);
            });
        } else {
            return $mmaModScormOnline.getScormUserData(siteId, scormId, attempt, ignoreCache);
        }
    };

    /**
     * Get cache key for get SCORM scos WS calls.
     *
     * @param  {Number} scormId SCORM ID.
     * @return {String}         Cache key.
     */
    function getScosCacheKey(scormId) {
        return 'mmaModScorm:scos:' + scormId;
    }

    /**
     * Retrieves the list of SCO objects for a given SCORM and organization.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScos
     * @param  {Number} scormId        SCORM ID.
     * @param  {String} [siteId]       Site ID. If not defined, current site.
     * @param  {String} [organization] Organization ID.
     * @param  {Boolean} ignoreCache   True if it should ignore cached data (it will always fail if offline or server down).
     * @return {Promise}               Promise resolved with a list of SCO objects.
     */
    self.getScos = function(scormId, siteId, organization, ignoreCache) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            organization = organization || '';

            // Don't send the organization to the WS, we'll filter them locally.
            var params = {
                    scormid: scormId
                },
                preSets = {
                    cacheKey: getScosCacheKey(scormId)
                };

            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }

            return site.read('mod_scorm_get_scorm_scoes', params, preSets).then(function(response) {
                if (response && response.scoes) {
                    var scos = [];
                    if (organization) {
                        // Filter SCOs by organization.
                        angular.forEach(response.scoes, function(sco) {
                            if (sco.organization == organization) {
                                scos.push(sco);
                            }
                        });
                    } else {
                        scos = response.scoes;
                    }
                    return scos;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Retrieves the list of SCO objects for a given SCORM and organization, including data about
     * a certain attempt (status, isvisible, ...).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScosWithData
     * @param  {Number} scormId      SCORM ID.
     * @param  {String} organization Organization ID.
     * @param  {Number} attempt      Attempt number.
     * @param  {Boolean} offline     True if attempt is offline, false otherwise.
     * @param  {Boolean} ignoreCache True if it should ignore cached data for online attempts.
     * @param  {String} [siteId]     Site ID. If not defined, current site.
     * @return {Promise}             Promise resolved with a list of SCO objects.
     */
    self.getScosWithData = function(scormId, organization, attempt, offline, ignoreCache, siteId) {
        // Get organization SCOs.
        return self.getScos(scormId, siteId, organization, ignoreCache).then(function(scos) {
            // Get the track data for all the SCOs in the organization for the given attempt.
            // We'll use this data to set SCO data like isvisible, status and so.
            return self.getScormUserData(scormId, attempt, offline, siteId, scos, ignoreCache).then(function(data) {

                var trackDataBySCO = {};

                // First populate trackDataBySCO to index by SCO identifier.
                angular.forEach(scos, function(sco) {
                    trackDataBySCO[sco.identifier] = data[sco.id].userdata;
                });

                angular.forEach(scos, function(sco) {
                    // Add specific SCO information (related to tracked data).
                    var scodata = data[sco.id].userdata;
                    if (!scodata) {
                        return;
                    }
                    // Check isvisible attribute.
                    sco.isvisible = typeof scodata.isvisible != 'undefined' ?
                                            scodata.isvisible && scodata.isvisible !== 'false' : true;
                    // Check pre-requisites status.
                    sco.prereq = typeof scodata.prerequisites == 'undefined' ||
                                            self.evalPrerequisites(scodata.prerequisites, trackDataBySCO);
                    // Add status.
                    sco.status = (typeof scodata.status == 'undefined' || scodata.status === '') ?
                                            'notattempted' : scodata.status;
                    // Exit var.
                    sco.exitvar = typeof scodata.exitvar == 'undefined' ? 'cmi.core.exit' : scodata.exitvar;
                    sco.exitvalue = scodata[sco.exitvar];
                });

                return scos;
            });
        });
    };

    /**
     * Given a SCORM and a SCO, returns the full launch URL for the SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScoSrc
     * @param  {Object} scorm   SCORM.
     * @param  {Object} sco     SCO.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the URL.
     */
    self.getScoSrc = function(scorm, sco, siteId) {
        if (sco.launch.match(/http(s)?:\/\//)) {
            // It's an online URL.
            return $q.when($sce.trustAsResourceUrl(sco.launch));
        }

        siteId = siteId || $mmSite.getId();

        return $mmFilepool.getDirectoryUrlByUrl(siteId, scorm.moduleurl).then(function(dirPath) {
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, sco.launch));
        });
    };

    /**
     * Get the path to the folder where a SCORM is downloaded.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormFolder
     * @param  {String} moduleUrl Module URL (returned by get_course_contents).
     * @param {String} [siteId]   Site ID. If not defined, current site.
     * @return {Promise}          Promise resolved with the folder path.
     */
    self.getScormFolder = function(moduleUrl, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmFilepool.getFilePathByUrl(siteId, moduleUrl);
    };

    /**
     * Gets a list of files to downlaod for a SCORM, using a format similar to module.contents from get_course_contents.
     * It will only return one file: the ZIP package.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormFileList
     * @param  {Object} scorm SCORM.
     * @return {Object[]}     File list.
     */
    self.getScormFileList = function(scorm) {
        var files = [];
        if (self.isScormSupported(scorm) === true && !scorm.warningmessage) {
            files.push({
                fileurl: self.getPackageUrl(scorm),
                filepath: '/',
                filename: scorm.reference,
                filesize: scorm.packagesize,
                type: 'file',
                timemodified: 0
            });
        }
        return files;
    };

    /**
     * Get the URL and description of the status icon.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScoStatusIcon
     * @param {Object} sco         SCO.
     * @param {Boolean} incomplete True if SCORM is incomplete, false otherwise.
     * @return {Object}            Image URL and description.
     */
    self.getScoStatusIcon = function(sco, incomplete) {
        var imagename = '',
            descname = '',
            status;

        if (sco.scormtype == 'sco') {
            // Not an asset, calculate image using status.
            status = sco.status;
            if (statuses.indexOf(status) < 0) {
                // Status empty or not valid, use 'notattempted'.
                status = 'notattempted';
            }
            if (!incomplete) {
                // Check if SCO is completed or not. If SCORM is incomplete there's no need to check SCO.
                incomplete = self.isStatusIncomplete(status);
            }

            if (incomplete && sco.exitvalue == 'suspend') {
                imagename = 'suspend';
                descname = 'suspended';
            } else {
                imagename = sco.status;
                descname = sco.status;
            }
        } else {
            imagename = 'asset';
            descname = (!sco.status || sco.status == 'notattempted') ? 'asset' : 'assetlaunched';
        }

        return {
            url: 'addons/mod_scorm/img/' + imagename + '.gif',
            description: $translate.instant('mma.mod_scorm.' + descname)
        };
    };

    /**
     * Get cache key for SCORM data WS calls.
     *
     * @param {Number} courseId Course ID.
     * @return {String}         Cache key.
     */
    function getScormDataCacheKey(courseId) {
        return 'mmaModScorm:scorm:' + courseId;
    }

    /**
     * Get a SCORM with key=value. If more than one is found, only the first will be returned.
     *
     * @param  {String} siteId    Site ID.
     * @param  {Number} courseId  Course ID.
     * @param  {String} key       Name of the property to check.
     * @param  {Mixed} value      Value to search.
     * @param  {String} moduleUrl Module URL.
     * @return {Promise}          Promise resolved when the SCORM is retrieved.
     */
    function getScorm(siteId, courseId, key, value, moduleUrl) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getScormDataCacheKey(courseId)
                };

            return site.read('mod_scorm_get_scorms_by_courses', params, preSets).then(function(response) {
                if (response && response.scorms) {
                    var currentScorm;
                    angular.forEach(response.scorms, function(scorm) {
                        if (!currentScorm && scorm[key] == value) {
                            currentScorm = scorm;
                        }
                    });
                    if (currentScorm) {
                        // If the SCORM isn't available the WS returns a warning and it doesn't return timeopen and timeclosed.
                        if (typeof currentScorm.timeopen == 'undefined') {
                            angular.forEach(response.warnings, function(warning) {
                                if (warning.itemid === currentScorm.id) {
                                    currentScorm.warningmessage = warning.message;
                                }
                            });
                        }
                        currentScorm.moduleurl = moduleUrl;
                        return currentScorm;
                    }
                }
                return $q.reject();
            });
        });
    }

    /**
     * Get a SCORM by module ID.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScorm
     * @param {Number} courseId  Course ID.
     * @param {Number} cmid      Course module ID.
     * @parma {String} moduleUrl Module URL.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when the SCORM is retrieved.
     */
    self.getScorm = function(courseId, cmid, moduleUrl, siteId) {
        siteId = siteId || $mmSite.getId();
        return getScorm(siteId, courseId, 'coursemodule', cmid, moduleUrl);
    };

    /**
     * Get a SCORM by SCORM ID.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormById
     * @param {Number} courseId  Course ID.
     * @param {Number} cmid      Course module ID.
     * @parma {String} moduleUrl Module URL.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when the SCORM is retrieved.
     */
    self.getScormById = function(courseId, id, moduleUrl, siteId) {
        siteId = siteId || $mmSite.getId();
        return getScorm(siteId, courseId, 'id', id, moduleUrl);
    };

    /**
     * Get a readable SCORM grade method.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormGradingMethod
     * @param {Object} scorm SCORM.
     * @return {String}      Grading method.
     */
    self.getScormGradeMethod = function(scorm) {
        if (scorm.maxattempt == 1) {
            switch (parseInt(scorm.grademethod, 10)) {
                case self.GRADEHIGHEST:
                    return $translate.instant('mma.mod_scorm.gradehighest');
                case self.GRADEAVERAGE:
                    return $translate.instant('mma.mod_scorm.gradeaverage');
                case self.GRADESUM:
                    return $translate.instant('mma.mod_scorm.gradesum');
                case self.GRADESCOES:
                    return $translate.instant('mma.mod_scorm.gradescoes');
            }
        } else {
            switch (parseInt(scorm.whatgrade, 10)) {
                case self.HIGHESTATTEMPT:
                    return $translate.instant('mma.mod_scorm.highestattempt');
                case self.AVERAGEATTEMPT:
                    return $translate.instant('mma.mod_scorm.averageattempt');
                case self.FIRSTATTEMPT:
                    return $translate.instant('mma.mod_scorm.firstattempt');
                case self.LASTATTEMPT:
                    return $translate.instant('mma.mod_scorm.lastattempt');
            }
        }
    };

    /**
     * Invalidates all the data related to a certain SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateAllScormData
     * @param {Number} scormId  SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateAllScormData = function(scormId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        promises.push($mmaModScormOnline.invalidateAttemptCount(siteId, scormId, userId));
        promises.push(self.invalidateScos(scormId, siteId));
        promises.push($mmaModScormOnline.invalidateScormUserData(siteId, scormId));
        return $q.all(promises);
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateContent
     * @param {Object} moduleId The module ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmFilepool.invalidateFilesByComponent(siteId, mmaModScormComponent, moduleId);
    };

    /**
     * Invalidates SCORM scos for all organizations.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateScos
     * @param {Number} scormId SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}       Promise resolved when the data is invalidated.
     */
    self.invalidateScos = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getScosCacheKey(scormId));
        });
    };

    /**
     * Invalidates SCORM data.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateScormData
     * @param {Number} courseId Course ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateScormData = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getScormDataCacheKey(courseId));
        });
    };

    /**
     * Check if a SCORM's attempt is incomplete.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isAttemptIncomplete
     * @param {Object} scormId      SCORM ID.
     * @param {Number} attempt      Attempt.
     * @param {Boolean} offline     True if attempt is offline, false otherwise.
     * @param {Boolean} ignoreCache True if it should ignore cached data for online attempts.
     * @param {String} [siteId]     Site ID. If not defined, current site.
     * @return {Promise}            Promise resolved with a boolean: true if incomplete, false otherwise.
     */
    self.isAttemptIncomplete = function(scormId, attempt, offline, ignoreCache, siteId) {
        return self.getScosWithData(scormId, undefined, attempt, offline, ignoreCache, siteId).then(function(scos) {
            var incomplete = false;

            angular.forEach(scos, function(sco) {
                // Ignore SCOs not visible or without launch URL.
                if (sco.isvisible && sco.launch) {
                    if (self.isStatusIncomplete(sco.status)) {
                        incomplete = true;
                    }
                }
            });

            return incomplete;
        });
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the scorm WS are available.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_scorm_get_scorm_attempt_count') &&
                    site.wsAvailable('mod_scorm_get_scorm_sco_tracks') &&
                    site.wsAvailable('mod_scorm_get_scorm_scoes') &&
                    site.wsAvailable('mod_scorm_get_scorm_user_data') &&
                    site.wsAvailable('mod_scorm_get_scorms_by_courses') &&
                    site.wsAvailable('mod_scorm_insert_scorm_tracks');
        });
    };

    /**
     * Check if a SCORM is being played right now.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormBeingPlayed
     * @param  {Number}  scormId SCORM ID.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Boolean}         True if it's being played, false otherwise.
     */
    self.isScormBeingPlayed = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSite.getId() == siteId && $state.current.name == 'site.mod_scorm-player' &&
                        $state.params.scorm && $state.params.scorm.id == scormId;
    };

    /**
     * Check if the given SCORM is closed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormClosed
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is closed, false if it hasn't closed yet.
     */
    self.isScormClosed = function(scorm) {
        var timeNow = $mmUtil.timestamp();
        if (scorm.timeclose > 0 && timeNow > scorm.timeclose) {
            return true;
        }
        return false;
    };

    /**
     * Check if the given SCORM is downloadable.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormDownloadable
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is downloadable, false otherwise.
     */
    self.isScormDownloadable = function(scorm) {
        return typeof scorm.protectpackagedownloads != 'undefined' && scorm.protectpackagedownloads === false;
    };

    /**
     * Check if the given SCORM is open.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormOpen
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is open, false if it hasn't opened yet.
     */
    self.isScormOpen = function(scorm) {
        var timeNow = $mmUtil.timestamp();
        if (scorm.timeopen > 0 && scorm.timeopen > timeNow) {
            return false;
        }
        return true;
    };

    /**
     * Check if a SCORM is supported in the app. If it's not, returns the error code to show.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormSupported
     * @param {Object} scorm    SCORM to check.
     * @return {Boolean|String} True if SCORM is supported, string with error code otherwise.
     */
    self.isScormSupported = function(scorm) {
        if (!self.isScormValidVersion(scorm)) {
            return 'mma.mod_scorm.errorinvalidversion';
        } else if (!self.isScormDownloadable(scorm)) {
            return 'mma.mod_scorm.errornotdownloadable';
        } else if (!self.isValidPackageUrl(self.getPackageUrl(scorm))) {
            return 'mma.mod_scorm.errorpackagefile';
        }

        return true;
    };

    /**
     * Check if it's a valid SCORM 1.2.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormValidVersion
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is valid, false otherwise.
     */
    self.isScormValidVersion = function(scorm) {
        return scorm.version == 'SCORM_1.2';
    };

    /**
     * Check if a SCO status is incomplete.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isStatusIncomplete
     * @param  {String}  status SCO status.
     * @return {Boolean}        True if incomplete, false otherwise.
     */
    self.isStatusIncomplete = function(status) {
        return !status || status == 'notattempted' || status == 'incomplete' || status == 'browsed';
    };

    /**
     * Check if a package URL is valid.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isValidPackageUrl
     * @param  {String}  packageUrl Package URL.
     * @return {Boolean}            True if valid, false otherwise.
     */
    self.isValidPackageUrl = function(packageUrl) {
        if (!packageUrl) {
            return false;
        }
        if (packageUrl.indexOf('imsmanifest.xml') > -1) {
            return false;
        }
        return true;
    };

    /**
     * Report a SCORM as being viewed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#logView
     * @param {String} id       Module ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the WS call is successful.
     */
    self.logView = function(id, siteId) {
        siteId = siteId || $mmSite.getId();
        if (id) {
            return $mmSitesManager.getSite(siteId).then(function(site) {
                var params = {
                    scormid: id
                };
                return site.write('mod_scorm_view_scorm', params);
            });
        }
        return $q.reject();
    };

    /**
     * Report a SCO as being launched.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#logLaunchSco
     * @param {Number} scormId  SCORM ID.
     * @param {Number} scoId    SCO ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the WS call is successful.
     */
    self.logLaunchSco = function(scormId, scoId, siteId) {
        siteId = siteId || $mmSite.getId();
        var params = {
            scormid: scormId,
            scoid: scoId
        };
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.write('mod_scorm_launch_sco', params).then(function(response) {
                if (!response || !response.status) {
                    return $q.reject();
                }
            });
        });
    };

    /**
     * Prefetches and unzips the SCORM package, and also prefetches some WS calls.
     * @see $mmaModScorm#_downloadOrPrefetch
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#prefetch
     * @param {Object} scorm SCORM object returned by $mmaModScorm#getScorm.
     * @return {Promise}     Promise resolved when prefetch is done. Resolve param is a warning message (if needed).
     */
    self.prefetch = function(scorm) {
        var promises = [];

        promises.push(self.prefetchPackage(scorm));

        promises.push(self.prefetchData(scorm).catch(function() {
            // If prefetchData fails we don't want to fail the whole downloaded, so we'll ignore the error for now.
            // @todo Implement a warning system so the user knows which SCORMs have failed.
        }));

        return $q.all(promises);
    };

    /**
     * Prefetches some WS data for a SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#prefetchData
     * @param {Object} scorm    SCORM object returned by $mmaModScorm#getScorm.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the data is prefetched.
     */
    self.prefetchData = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];

        // Prefetch number of attempts (including not completed).
        promises.push($mmaModScormOnline.getAttemptCount(siteId, scorm.id).catch(function() {
            // If it fails, assume we have no attempts.
            return 0;
        }).then(function(numAttempts) {
            if (numAttempts > 0) {
                // Get user data for each attempt.
                var datapromises = [],
                    attempts = [];

                // Fill an attempts array to be able to use forEach and prevent problems with attempt variable changing.
                for (var i = 1; i <= numAttempts; i++) {
                    attempts.push(i);
                }

                attempts.forEach(function(attempt) {
                    datapromises.push($mmaModScormOnline.getScormUserData(siteId, scorm.id, attempt).catch(function(err) {
                        // Ignore failures of all the attempts that aren't the last one.
                        if (attempt == numAttempts) {
                            return $q.reject(err);
                        }
                    }));
                });

                return $q.all(datapromises);
            } else {
                // No attempts. We'll still try to get user data to be able to identify SCOs not visible and so.
                return $mmaModScormOnline.getScormUserData(siteId, scorm.id, 0);
            }
        }));

        // Prefetch SCOs.
        promises.push(self.getScos(scorm.id, siteId));

        return $q.all(promises);
    };

    /**
     * Prefetches and unzips the SCORM package.
     * @see $mmaModScorm#_downloadOrPrefetch
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#prefetchPackage
     * @param {Object} scorm SCORM object returned by $mmaModScorm#getScorm.
     * @return {Promise}     Promise resolved when the package is prefetched and unzipped.
     */
    self.prefetchPackage = function(scorm) {
        return self._downloadOrPrefetch(scorm, true);
    };

    /**
     * Saves a SCORM tracking record.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#saveTracks
     * @param  {Number} scoId      Sco ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Object[]} tracks   Tracking data to store.
     * @param  {Boolean} offline   True if attempt is offline, false otherwise.
     * @param  {Object} scorm      SCORM.
     * @param  {Object} [userData] User data for this attempt and SCO. If not defined, it will be retrieved from DB. Recommended.
     * @param  {String} [siteId]   Site ID. If not defined, current site.
     * @return {Promise}           Promise resolved when data is saved.
     */
    self.saveTracks = function(scoId, attempt, tracks, offline, scorm, userData, siteId) {
        siteId = siteId || $mmSite.getId();
        if (offline) {
            var promise = userData ? $q.when(userData) : self.getScormUserData(scorm.id, attempt, offline, siteId);
            return promise.then(function(userData) {
                return $mmaModScormOffline.saveTracks(siteId, scorm, scoId, attempt, tracks, userData);
            });
        } else {
            return $mmaModScormOnline.saveTracks(siteId, scorm.id, scoId, attempt, tracks);
        }
    };

    /**
     * Saves a SCORM tracking record using a synchronous call.
     * Please use this function only if synchronous is a must. It's recommended to use $mmaModScorm#saveTracks.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#saveTracksSync
     * @param  {Number} scoId      Sco ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Object[]} tracks   Tracking data to store.
     * @param  {Boolean} offline   True if attempt is offline, false otherwise.
     * @param  {Object} [scorm]    SCORM. Required if offline=true.
     * @param  {Object} [userData] User data for this attempt and SCO. Required if offline=true.
     * @return {Boolean}           In online returns true if data is inserted, false otherwise.
     *                             In offline returns true if data to insert is valid, false otherwise. True doesn't mean that the
     *                             data has been stored, this function can return true but the insertion can still fail somehow.
     */
    self.saveTracksSync = function(scoId, attempt, tracks, offline, scorm, userData) {
        if (offline) {
            return $mmaModScormOffline.saveTracksSync(scorm, scoId, attempt, tracks, userData);
        } else {
            return $mmaModScormOnline.saveTracksSync(scoId, attempt, tracks);
        }
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

.constant('mmaModScormOfflineAttemptsStore', 'mod_scorm_offline_attempts')
.constant('mmaModScormOfflineTracksStore', 'mod_scorm_offline_scos_tracks')

.config(["$mmSitesFactoryProvider", "mmaModScormOfflineAttemptsStore", "mmaModScormOfflineTracksStore", function($mmSitesFactoryProvider, mmaModScormOfflineAttemptsStore, mmaModScormOfflineTracksStore) {
    var stores = [
        {
            name: mmaModScormOfflineAttemptsStore,
            keyPath: ['scormid', 'userid', 'attempt'],
            indexes: [
                {
                    name: 'attempt' // Attempt number.
                },
                {
                    name: 'userid'
                },
                {
                    name: 'scormid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'timemodified'
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'scormAndUser',
                    generator: function(obj) {
                        return [obj.scormid, obj.userid];
                    }
                }
            ]
        },
        {
            name: mmaModScormOfflineTracksStore,
            keyPath: ['userid', 'scormid', 'scoid', 'attempt', 'element'],
            indexes: [
                {
                    name: 'userid'
                },
                {
                    name: 'scormid'
                },
                {
                    name: 'scoid'
                },
                {
                    name: 'attempt'
                },
                {
                    name: 'element'
                },
                {
                    name: 'synced'
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'scormUserAttempt',
                    generator: function(obj) {
                        return [obj.scormid, obj.userid, obj.attempt];
                    }
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'scormUserAttemptSynced',
                    generator: function(obj) {
                        return [obj.scormid, obj.userid, obj.attempt, obj.synced];
                    }
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Service to handle SCORM offline features.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormOffline
 */
.factory('$mmaModScormOffline', ["$mmSite", "$mmUtil", "$q", "$log", "$mmSitesManager", "mmaModScormOfflineAttemptsStore", "mmaModScormOfflineTracksStore", function($mmSite, $mmUtil, $q, $log, $mmSitesManager, mmaModScormOfflineAttemptsStore,
            mmaModScormOfflineTracksStore) {
    $log = $log.getInstance('$mmaModScormOffline');

    var self = {},
        blockedScorms = {};

    /**
     * Changes an attempt number in the data stored in offline.
     * This function is used to convert attempts into new attempts, so the stored snapshot will be removed and
     * entries will be marked as not synced.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#changeAttemptNumber
     * @param {String} siteId     Site ID.
     * @param {Object} scormId    SCORM ID.
     * @param {Number} attempt    Number of the attempt to change.
     * @param {Number} newAttempt New attempt number.
     * @param {Number} [userId]   User ID. If not defined use site's current user.
     * @return {Promise}          Promise resolved when the attempt number changes.
     */
    self.changeAttemptNumber = function(siteId, scormId, attempt, newAttempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Change attempt number from ' + attempt + ' to ' + newAttempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            var db = site.getDb(),
                newEntry = {
                    scormid: scormId,
                    userid: userId,
                    attempt: newAttempt,
                    timemodified: $mmUtil.timestamp()
                };

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            blockedScorms[siteId][scormId] = true; // Block the SCORM so it can't be synced.

            // Get current data.
            return db.get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).then(function(entry) {
                newEntry.timecreated = entry.timecreated;
                newEntry.courseid = entry.courseid;

                // Insert new attempt.
                return db.insert(mmaModScormOfflineAttemptsStore, newEntry).then(function() {
                    // Copy tracking data to the new attempt.
                    return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                        var promises = [];
                        angular.forEach(entries, function(entry) {
                            entry.attempt = newAttempt;
                            entry.synced = 0;
                            promises.push(db.insert(mmaModScormOfflineTracksStore, entry));
                        });

                        return $mmUtil.allPromises(promises).then(function() {
                            // All entries inserted. Delete the old attempt.
                            return self.deleteAttempt(siteId, scormId, attempt).catch(function() {
                                // The delete failed, it shouldn't happen. Let's retry once.
                                return self.deleteAttempt(siteId, scormId, attempt).catch(function() {});
                            });
                        });
                    }).catch(function() {
                        // Failed to get the data, remove the new attempt.
                        return self.deleteAttempt(siteId, scormId, newAttempt).then(function() {
                            return $q.reject();
                        });
                    });
                });
            }).finally(function() {
                blockedScorms[siteId][scormId] = false; // Unblock the SCORM.
            });
        });
    };

    /**
     * Clear blocked SCORMs.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#clearBlockedScorms
     * @param {String} [siteId] If set, clear the blocked SCORMs only for this site. Otherwise clear all SCORMs.
     * @return {Void}
     */
    self.clearBlockedScorms = function(siteId) {
        if (siteId) {
            delete blockedScorms[siteId];
        } else {
            blockedScorms = {};
        }
    };

    /**
     * Creates a new offline attempt. It can be created from scratch or as a copy of another attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#createNewAttempt
     * @param {String} siteId     Site ID.
     * @param {Object} scorm      SCORM.
     * @param {Number} [userId]   User ID. If not defined use site's current user.
     * @param {Number} attempt    Number of the new attempt.
     * @param {Object} userData   User data to store in the attempt.
     * @param {Object} [snapshot] Optional. Snapshot to store in the attempt.
     * @return {Promise}          Promise resolved when the new attempt is created.
     */
    self.createNewAttempt = function(siteId, scorm, userId, attempt, userData, snapshot) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Creating new offline attempt ' + attempt + ' in SCORM ' + scorm.id);
            userId = userId || site.getUserId();

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            blockedScorms[siteId][scorm.id] = true; // Block the SCORM so it can't be synced.

            // Create attempt in DB.
            var db = site.getDb(),
                entry = {
                    scormid: scorm.id,
                    userid: userId,
                    attempt: attempt,
                    courseid: scorm.course,
                    timecreated: $mmUtil.timestamp(),
                    timemodified: $mmUtil.timestamp()
                };

            if (snapshot) {
                // Save a snapshot of the data we had when we created the attempt.
                // Remove the default data, we don't want to store it.
                entry.snapshot = removeDefaultData(snapshot);
            }

            return db.insert(mmaModScormOfflineAttemptsStore, entry).then(function() {
                // Store all the data in userData.
                var promises = [];
                angular.forEach(userData, function(sco) {
                    var tracks = [];
                    angular.forEach(sco.userdata, function(value, element) {
                        tracks.push({element: element, value: value});
                    });
                    promises.push(self.saveTracks(siteId, scorm, sco.scoid, attempt, tracks, userData));
                });
                return $q.all(promises);
            }).finally(function() {
                blockedScorms[siteId][scorm.id] = false; // Unblock the SCORM.
            });
        });
    };

    /**
     * Delete all the stored data from an attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#deleteAttempt
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when all the data has been deleted.
     */
    self.deleteAttempt = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Delete offline attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                var promises = [],
                    db = site.getDb();

                // Delete all the tracks.
                angular.forEach(entries, function(entry) {
                    var entryId = [entry.userid, entry.scormid, entry.scoid, entry.attempt, entry.element];
                    promises.push(db.remove(mmaModScormOfflineTracksStore, entryId));
                });

                // Delete the attempt.
                promises.push(db.remove(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]));

                return $q.all(promises);
            });
        });
    };

    /**
     * Helper function to return a formatted list of interactions for reports.
     * This function is based in Moodle's scorm_format_interactions.
     *
     * @param  {Object} scoUserData Userdata from a certain SCO.
     * @return {Object}             Formatted userdata.
     */
    function formatInteractions(scoUserData) {
        var formatted = {};

        // Defined in order to unify scorm1.2 and scorm2004.
        formatted.score_raw = '';
        formatted.status = '';
        formatted.total_time = '00:00:00';
        formatted.session_time = '00:00:00';

        angular.forEach(scoUserData, function(value, element) {
            // Ignore elements that are calculated.
            if (element == 'score_raw' || element == 'status' || element == 'total_time' || element == 'session_time') {
                return;
            }

            formatted[element] = value;
            switch (element) {
                case 'cmi.core.lesson_status':
                case 'cmi.completion_status':
                    if (value == 'not attempted') {
                        value = 'notattempted';
                    }
                    formatted.status = value;
                    break;
                case 'cmi.core.score.raw':
                case 'cmi.score.raw':
                    formatted.score_raw = $mmUtil.roundToDecimals(value, 2); // Round to 2 decimals max.
                    break;
                case 'cmi.core.session_time':
                case 'cmi.session_time':
                    formatted.session_time = value;
                    break;
                case 'cmi.core.total_time':
                case 'cmi.total_time':
                    formatted.total_time = value;
                    break;
            }
        });

        return formatted;
    }

    /**
     * Get launch URLs from a list of SCOs, indexing them by SCO ID.
     *
     * @param  {Object[]} scos List of SCOs. Each SCO needs to have 'id' and 'launch' properties.
     * @return {Object}        Launch URLs indexed by SCO ID.
     */
    function getLaunchUrlsFromScos(scos) {
        var response = {};
        angular.forEach(scos, function(sco) {
            response[sco.id] = sco.launch;
        });
        return response;
    }

    /**
     * Get all the offline attempts in a certain site.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAllAttempts
     * @param {String} [siteId] Site ID. If not set, use current site.
     * @return {Promise}        Promise resolved when the offline attempts are retrieved.
     */
    self.getAllAttempts = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            if (!db) {
                return $q.reject();
            }

            return db.getAll(mmaModScormOfflineAttemptsStore);
        });
    };

    /**
     * Get the offline attempts done by a user in the given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAttempts
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when the offline attempts are retrieved.
     */
    self.getAttempts = function(siteId, scormId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var db = site.getDb();
            return db.whereEqual(mmaModScormOfflineAttemptsStore, 'scormAndUser', [scormId, userId]).then(function(attempts) {
                return attempts;
            });
        });
    };

    /**
     * Get the snapshot of an attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAttemptSnapshot
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved with the snapshot or undefined if no snapshot.
     */
    self.getAttemptSnapshot = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).catch(function() {
                return {}; // Attempt not found.
            }).then(function(entry) {
                return entry.snapshot;
            });
        });
    };

    /**
     * Get the creation time of an attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAttemptCreationTime
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved with time the attempt was created.
     */
    self.getAttemptCreationTime = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).catch(function() {
                return {}; // Attempt not found.
            }).then(function(entry) {
                return entry.timecreated;
            });
        });
    };

    /**
     * Get data stored in local DB for a certain scorm and attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getScormStoredData
     * @param {String} siteId            Site ID.
     * @param {Number} scormId           SCORM ID.
     * @param {Number} attempt           Attempt number.
     * @param {Number} [userId]          User ID. If not defined use site's current user.
     * @param {Boolean} excludeSynced    True if it should only return not synced entries.
     * @param {Boolean} excludeNotSynced True if it should only return synced entries.
     * @return {Promise}                 Promise resolved with the entries.
     */
    self.getScormStoredData = function(siteId, scormId, attempt, userId, excludeSynced, excludeNotSynced) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var where;

            if (excludeSynced && excludeNotSynced) {
                return $q.when([]);
            } else if (excludeSynced || excludeNotSynced) {
                where = ['scormUserAttemptSynced', '=', [scormId, userId, attempt, excludeNotSynced ? 1 : 0]];
            } else {
                where = ['scormUserAttempt', '=', [scormId, userId, attempt]];
            }
            return site.getDb().query(mmaModScormOfflineTracksStore, where);
        });
    };

    /**
     * Get the user data for a certain SCORM and offline attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getScormUserData
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @param {Object[]} scos   SCOs returned by $mmaModScorm#getScos. Required.
     * @return {Promise}        Promise resolved when the user data is retrieved.
     */
    self.getScormUserData = function(siteId, scormId, attempt, userId, scos) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            // Get user data. Ordering when using a compound index is complex, so we won't order by scoid.
            return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                var response = {},
                    launchUrls = getLaunchUrlsFromScos(scos),
                    userId = site.getUserId(),
                    username = site.getInfo().username,
                    fullName = site.getInfo().fullname;

                // Gather user data retrieved from DB, grouping it by scoid.
                angular.forEach(entries, function(entry) {
                    var scoid = entry.scoid;
                    if (!response[scoid]) {
                        // Initialize SCO.
                        response[scoid] = {
                            scoid: scoid,
                            userdata: {
                                userid: userId,
                                scoid: scoid,
                                timemodified: 0
                            }
                        };
                    }
                    response[scoid].userdata[entry.element] = entry.value;
                    if (entry.timemodified > response[scoid].userdata.timemodified) {
                        response[scoid].userdata.timemodified = entry.timemodified;
                    }
                });

                // Format each user data retrieved.
                angular.forEach(response, function(sco) {
                    sco.userdata = formatInteractions(sco.userdata);
                });

                // Create empty entries for the SCOs without user data stored.
                angular.forEach(scos, function(sco) {
                    if (!response[sco.id]) {
                        response[sco.id] = {
                            scoid: sco.id,
                            userdata: {
                                status: '',
                                score_raw: ''
                            }
                        };
                    }
                });

                // Calculate defaultdata.
                angular.forEach(response, function(sco) {
                    sco.defaultdata = {};
                    sco.defaultdata['cmi.core.student_id'] = username;
                    sco.defaultdata['cmi.core.student_name'] = fullName;
                    sco.defaultdata['cmi.core.lesson_mode'] = 'normal'; // Overridden in player.
                    sco.defaultdata['cmi.core.credit'] = 'credit'; // Overridden in player.
                    if (sco.userdata.status === '') {
                        sco.defaultdata['cmi.core.entry'] = 'ab-initio';
                    } else if (sco.userdata['cmi.core.exit'] === 'suspend') {
                        sco.defaultdata['cmi.core.entry'] = 'resume';
                    } else {
                        sco.defaultdata['cmi.core.entry'] = '';
                    }
                    sco.defaultdata['cmi.student_data.mastery_score'] = scormIsset(sco.userdata, 'masteryscore');
                    sco.defaultdata['cmi.student_data.max_time_allowed'] = scormIsset(sco.userdata, 'max_time_allowed');
                    sco.defaultdata['cmi.student_data.time_limit_action'] = scormIsset(sco.userdata, 'time_limit_action');
                    sco.defaultdata['cmi.core.total_time'] = scormIsset(sco.userdata, 'cmi.core.total_time', '00:00:00');
                    sco.defaultdata['cmi.launch_data'] = launchUrls[sco.scoid];

                    // Now handle standard userdata items.
                    sco.defaultdata['cmi.core.lesson_location'] = scormIsset(sco.userdata, 'cmi.core.lesson_location');
                    sco.defaultdata['cmi.core.lesson_status'] = scormIsset(sco.userdata, 'cmi.core.lesson_status');
                    sco.defaultdata['cmi.core.score.raw'] = scormIsset(sco.userdata, 'cmi.core.score.raw');
                    sco.defaultdata['cmi.core.score.max'] = scormIsset(sco.userdata, 'cmi.core.score.max');
                    sco.defaultdata['cmi.core.score.min'] = scormIsset(sco.userdata, 'cmi.core.score.min');
                    sco.defaultdata['cmi.core.exit'] = scormIsset(sco.userdata, 'cmi.core.exit');
                    sco.defaultdata['cmi.suspend_data'] = scormIsset(sco.userdata, 'cmi.suspend_data');
                    sco.defaultdata['cmi.comments'] = scormIsset(sco.userdata, 'cmi.comments');
                    sco.defaultdata['cmi.student_preference.language'] = scormIsset(sco.userdata, 'cmi.student_preference.language');
                    sco.defaultdata['cmi.student_preference.audio'] = scormIsset(sco.userdata, 'cmi.student_preference.audio', '0');
                    sco.defaultdata['cmi.student_preference.speed'] = scormIsset(sco.userdata, 'cmi.student_preference.speed', '0');
                    sco.defaultdata['cmi.student_preference.text'] = scormIsset(sco.userdata, 'cmi.student_preference.text', '0');

                    // Some data needs to be both in default data and user data.
                    sco.userdata.student_id = username;
                    sco.userdata.student_name = fullName;
                    sco.userdata.mode = sco.defaultdata['cmi.core.lesson_mode'];
                    sco.userdata.credit = sco.defaultdata['cmi.core.credit'];
                    sco.userdata.entry = sco.defaultdata['cmi.core.entry'];
                });

                return response;
            });
        });
    };

    /**
     * Function to insert a track in the DB. Please do not use it directly, use insertTrack instead.
     *
     * @param  {Object} db           Site's DB.
     * @param  {Number} userId       User ID.
     * @param  {Number} scormId      SCORM ID.
     * @param  {Number} scoId        SCO ID.
     * @param  {Number} attempt      Attempt number.
     * @param  {String} element      Name of the element to insert.
     * @param  {Mixed} value         Value of the element to insert.
     * @param  {Boolean} synchronous True if insert should NOT return a promise. Please use it only if synchronous is a must.
     * @return {Boolean|Promise}     Returns a promise if synchronous=false, otherwise returns a boolean.
     */
    function insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, synchronous) {
        var entry = {
            userid: userId,
            scormid: scormId,
            scoid: scoId,
            attempt: attempt,
            element: element,
            value: value,
            timemodified: $mmUtil.timestamp(),
            synced: 0
        };
        if (synchronous) {
            return db.insertSync(mmaModScormOfflineTracksStore, entry);
        } else {
            return db.insert(mmaModScormOfflineTracksStore, entry);
        }
    }

    /**
     * Insert a track in the offline tracks store.
     * This function is based on Moodle's scorm_insert_track.
     *
     * @param {String} siteId           Site ID.
     * @param  {Number} [userId]        User ID. If not set use site's current user.
     * @param  {Number} scormId         SCORM ID.
     * @param  {Number} scoId           SCO ID.
     * @param  {Number} attempt         Attempt number.
     * @param  {String} element         Name of the element to insert.
     * @param  {Mixed} value            Value of the element to insert.
     * @param  {Boolean} forceCompleted True if SCORM forces completed.
     * @param  {Object} [scoData]       User data for the given SCO.
     * @return {Promise}                Promise resolved when the insert is done.
     */
    function insertTrack(siteId, userId, scormId, scoId, attempt, element, value, forceCompleted, scoData) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            scoData = scoData || {};

            var promises = [], // List of promises for actions previous to the real insert.
                lessonStatusInserted = false,
                scoUserData = scoData.userdata || {},
                db = site.getDb();

            if (forceCompleted) {
                if (element == 'cmi.core.lesson_status' && value == 'incomplete') {
                    if (scoUserData['cmi.core.score.raw']) {
                        value = 'completed';
                    }
                }
                if (element == 'cmi.core.score.raw') {
                    if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {
                        lessonStatusInserted = true;
                        promises.push(insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed'));
                    }
                }
            }

            return $q.all(promises).then(function() {
                // Don't update x.start.time, keep the original value.
                if (!scoUserData[element] || element != 'x.start.time') {

                    return insertTrackToDB(db, userId, scormId, scoId, attempt, element, value).catch(function() {
                        if (lessonStatusInserted) {
                            // Rollback previous insert.
                            return insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete')
                                    .then(function() {
                                return $q.reject();
                            });
                        }
                        return $q.reject();
                    });
                }
            });
        });
    }

    /**
     * Insert a track in the offline tracks store, returning a synchronous value.
     * Please use this function only if synchronous is a must. It's recommended to use insertTrack.
     * This function is based on Moodle's scorm_insert_track.
     *
     * @param  {Number} [userId]        User ID. If not set use current user.
     * @param  {Number} scormId         SCORM ID.
     * @param  {Number} scoId           SCO ID.
     * @param  {Number} attempt         Attempt number.
     * @param  {String} element         Name of the element to insert.
     * @param  {Mixed} value            Value of the element to insert.
     * @param  {Boolean} forceCompleted True if SCORM forces completed.
     * @param  {Object} [scoData]       User data for the given SCO.
     * @return {Promise}                Promise resolved when the insert is done.
     */
    function insertTrackSync(userId, scormId, scoId, attempt, element, value, forceCompleted, scoData) {
        userId = userId || $mmSite.getUserId();
        scoData = scoData || {};

        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return false;
        }

        var lessonStatusInserted = false,
            scoUserData = scoData.userdata || {},
            db = $mmSite.getDb();

        if (forceCompleted) {
            if (element == 'cmi.core.lesson_status' && value == 'incomplete') {
                if (scoUserData['cmi.core.score.raw']) {
                    value = 'completed';
                }
            }
            if (element == 'cmi.core.score.raw') {
                if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {
                    lessonStatusInserted = true;
                    if (!insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed', true)) {
                        return false;
                    }
                }
            }
        }

        // Don't update x.start.time, keep the original value.
        if (!scoUserData[element] || element != 'x.start.time') {
            if (!insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, true)) {
                // Insert failed.
                if (lessonStatusInserted) {
                    // Rollback previous insert.
                    insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete', true);
                }
                return false;
            }
            return true;
        }
    }

    /**
     * Check if a SCORM is blocked by a writing function.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#isScormBlocked
     * @param  {String} siteId   Site ID.
     * @param  {Number} scormId  SCORM ID.
     * @return {Boolean}         True if blocked, false otherwise.
     */
    self.isScormBlocked = function(siteId, scormId) {
        if (!blockedScorms[siteId]) {
            return false;
        }
        return !!blockedScorms[siteId][scormId];
    };

    /**
     * Mark all the entries from a SCO and attempt as synced.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#markAsSynced
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @param {Number} scoId    SCO ID.
     * @return {Promise}        Promise resolved when marked.
     */
    self.markAsSynced = function(siteId, scormId, attempt, userId, scoId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Mark SCO ' + scoId + ' as synced for attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            return self.getScormStoredData(siteId, scormId, attempt, userId, true).then(function(entries) {
                var promises = [],
                    db = site.getDb();

                angular.forEach(entries, function(entry) {
                    if (entry.scoid == scoId) {
                        entry.synced = 1;
                        promises.push(db.insert(mmaModScormOfflineTracksStore, entry));
                    }
                });

                return $q.all(promises);
            });
        });
    };

    /**
     * Removes the default data form user data.
     *
     * @param  {Object} userData User data returned by $mmaModScorm#getScormUserData.
     * @return {Object}          User data without default data.
     */
    function removeDefaultData(userData) {
        var result = angular.copy(userData);
        angular.forEach(result, function(sco) {
            delete sco.defaultdata;
        });
        return result;
    }

    /**
     * Saves a SCORM tracking record in offline.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#saveTracks
     * @param {String} siteId      Site ID.
     * @param  {Object} scorm      SCORM.
     * @param  {Number} scoId      Sco ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Object[]} tracks   Tracking data to store.
     * @param  {Object} userData   User data for this attempt and SCO.
     * @return {Promise}           Promise resolved when data is saved.
     */
    self.saveTracks = function(siteId, scorm, scoId, attempt, tracks, userData) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var userId = site.getUserId(),
                initialBlocked;

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            initialBlocked = !!blockedScorms[siteId][scorm.id]; // Save initial blocked state.
            blockedScorms[siteId][scorm.id] = true; // Block the SCORM so it can't be synced.

            // Insert all the tracks.
            var promises = [];
            angular.forEach(tracks, function(track) {
                promises.push(insertTrack(siteId, userId, scorm.id, scoId, attempt,
                                            track.element, track.value, scorm.forcecompleted, userData[scoId]));
            });
            return $q.all(promises).finally(function() {
                if (!initialBlocked) {
                    blockedScorms[siteId][scorm.id] = false; // Unblock the SCORM only if it wasn't blocked by another function.
                }
            });
        });
    };

    /**
     * Saves a SCORM tracking record in offline returning a synchronous value.
     * Please use this function only if synchronous is a must. It's recommended to use $mmaModScormOffline#saveTracks.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#saveTracksSync
     * @param  {Object} scorm    SCORM.
     * @param  {Number} scoId    Sco ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {Object[]} tracks Tracking data to store.
     * @param  {Object} userData User data for this attempt and SCO.
     * @return {Boolean}         True if data to insert is valid, false otherwise. Returning true doesn't mean that the data
     *                           has been stored, this function can return true but the insertion can still fail somehow.
     */
    self.saveTracksSync = function(scorm, scoId, attempt, tracks, userData) {
        var userId = $mmSite.getUserId(),
            success = true;

        angular.forEach(tracks, function(track) {
            if (!insertTrackSync(userId, scorm.id, scoId, attempt, track.element, track.value,
                                    scorm.forcecompleted, userData[scoId])) {
                success = false;
            }
        });
        return success;
    };

    /**
     * Check for a parameter in userdata and return it if it's set or return 'ifempty' if it's empty.
     * Based on Moodle's scorm_isset function.
     *
     * @param  {Object} userdata  Contains user's data.
     * @param  {String} param     Name of parameter that should be checked.
     * @param  {Mixed}  [ifempty] Value to be replaced with if param is not set.
     * @return {Mixed}            Value from userdata[param] if set, ifempty otherwise.
     */
    function scormIsset(userdata, param, ifempty) {
        if (typeof ifempty == 'undefined') {
            ifempty = '';
        }

        if (typeof userdata[param] != 'undefined') {
            return userdata[param];
        }
        return ifempty;
    }

    /**
     * Set an attempt's snapshot.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#setAttemptSnapshot
     * @param {String} siteId      Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Object} userData User data to store as snapshot.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when snapshot has been stored.
     */
    self.setAttemptSnapshot = function(siteId, scormId, attempt, userData, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Set snapshot for attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).then(function(entry) {
                entry.snapshot = removeDefaultData(userData);
                entry.timemodified = $mmUtil.timestamp();
                return site.getDb().insert(mmaModScormOfflineAttemptsStore, entry);
            });
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Service to handle SCORM online features.
 * This service holds getters and setters that have some kind of equivalent feature in $mmaModScormOffline.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormOnline
 */
.factory('$mmaModScormOnline', ["$mmSitesManager", "$mmSite", "$q", "$mmWS", "$log", "mmCoreWSPrefix", function($mmSitesManager, $mmSite, $q, $mmWS, $log, mmCoreWSPrefix) {
    $log = $log.getInstance('$mmaModScormOnline');

    var self = {},
        blockedScorms = {};

    /**
     * Clear blocked SCORMs.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#clearBlockedScorms
     * @param {String} [siteId] If set, clear the blocked SCORMs only for this site. Otherwise clear all SCORMs.
     * @return {Void}
     */
    self.clearBlockedScorms = function(siteId) {
        if (siteId) {
            delete blockedScorms[siteId];
        } else {
            blockedScorms = {};
        }
    };

    /**
     * Get cache key for SCORM attempt count WS calls.
     *
     * @param {Number} scormId  SCORM ID.
     * @param {Number} [userId] User ID. If not defined, current user.
     * @return {String}         Cache key.
     */
    function getAttemptCountCacheKey(scormId, userId) {
        userId = userId || $mmSite.getUserId();
        return 'mmaModScorm:attemptcount:' + scormId + ':' + userId;
    }

    /**
     * Get the number of attempts done by a user in the given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#getAttemptCount
     * @param {String} siteId         Site ID.
     * @param {Number} scormId        SCORM ID.
     * @param {Number} [userId]       User ID. If not defined use site's current user.
     * @param {Boolean} ignoreMissing True if it should ignore attempts that haven't reported a grade/completion.
     * @param {Boolean} ignoreCache   True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise}              Promise resolved when the attempt count is retrieved.
     */
    self.getAttemptCount = function(siteId, scormId, userId, ignoreMissing, ignoreCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var params = {
                    scormid: scormId,
                    userid: userId,
                    ignoremissingcompletion: ignoreMissing ? 1 : 0
                },
                preSets = {
                    cacheKey: getAttemptCountCacheKey(scormId, userId)
                };

            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }

            return site.read('mod_scorm_get_scorm_attempt_count', params, preSets).then(function(response) {
                if (response && typeof response.attemptscount != 'undefined') {
                    return response.attemptscount;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Get cache key for SCORM user data WS calls.
     *
     * @param {Number} scormId SCORM ID.
     * @param {Number} attempt Attempt number.
     * @return {String}        Cache key.
     */
    function getScormUserDataCacheKey(scormId, attempt) {
        return getScormUserDataCommonCacheKey(scormId) + ':' + attempt;
    }

    /**
     * Get common cache key for SCORM user data WS calls.
     *
     * @param {Number} scormId SCORM ID.
     * @return {String}        Cache key.
     */
    function getScormUserDataCommonCacheKey(scormId) {
        return 'mmaModScorm:userdata:' + scormId;
    }

    /**
     * Get the user data for a certain SCORM and attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#getScormUserData
     * @param {String} siteId       Site ID.
     * @param {Number} scormId      SCORM ID.
     * @param {Number} attempt      Attempt number.
     * @param {Boolean} ignoreCache True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise}            Promise resolved when the user data is retrieved.
     */
    self.getScormUserData = function(siteId, scormId, attempt, ignoreCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    scormid: scormId,
                    attempt: attempt
                },
                preSets = {
                    cacheKey: getScormUserDataCacheKey(scormId, attempt)
                };

            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }

            return site.read('mod_scorm_get_scorm_user_data', params, preSets).then(function(response) {
                if (response && response.data) {
                    // Format the response.
                    var data = {};
                    angular.forEach(response.data, function(sco) {
                        var formattedDefaultData = {},
                            formattedUserData = {};

                        angular.forEach(sco.defaultdata, function(entry) {
                            formattedDefaultData[entry.element] = entry.value;
                        });
                        angular.forEach(sco.userdata, function(entry) {
                            formattedUserData[entry.element] = entry.value;
                        });

                        sco.defaultdata = formattedDefaultData;
                        sco.userdata = formattedUserData;

                        data[sco.scoid] = sco;
                    });
                    return data;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Invalidates attempt count.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#invalidateAttemptCount
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateAttemptCount = function(siteId, scormId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(getAttemptCountCacheKey(scormId, userId));
        });
    };

    /**
     * Invalidates SCORM user data for all attempts.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#invalidateScormUserData
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateScormUserData = function(siteId, scormId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getScormUserDataCommonCacheKey(scormId));
        });
    };

    /**
     * Check if a SCORM is blocked by a writing function.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#isScormBlocked
     * @param  {String} siteId   Site ID. If not set, use current site.
     * @param  {Number} scormId  SCORM ID.
     * @return {Boolean}         True if blocked, false otherwise.
     */
    self.isScormBlocked = function(siteId, scormId) {
        if (!blockedScorms[siteId]) {
            return false;
        }
        return !!blockedScorms[siteId][scormId];
    };

    /**
     * Saves a SCORM tracking record.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#saveTracks
     * @param  {String} siteId   Site ID. If not set, use current site.
     * @param  {Number} scormId  SCORM ID.
     * @param  {Number} scoId    Sco ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {Object[]} tracks Tracking data.
     * @return {Promise}         Promise resolved when data is saved.
     */
    self.saveTracks = function(siteId, scormId, scoId, attempt, tracks) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                scoid: scoId,
                attempt: attempt,
                tracks: tracks
            };

            if (!tracks || !tracks.length) {
                return $q.when(); // Nothing to save.
            }

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            blockedScorms[siteId][scormId] = true;

            return site.write('mod_scorm_insert_scorm_tracks', params).then(function(response) {
                if (response && response.trackids) {
                    return response.trackids;
                }
                return $q.reject();
            }).finally(function() {
                blockedScorms[siteId][scormId] = false;
            });
        });
    };

    /**
     * Saves a SCORM tracking record using a synchronous call.
     * Please use this function only if synchronous is a must. It's recommended to use $mmaModScorm#saveTracks.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#saveTracksSync
     * @param  {Number} scoId    Sco ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {Object[]} tracks Tracking data.
     * @return {Boolean}         True if success, false otherwise.
     */
    self.saveTracksSync = function(scoId, attempt, tracks) {
        var params = {
                scoid: scoId,
                attempt: attempt,
                tracks: tracks
            },
            preSets = {
                siteurl: $mmSite.getURL(),
                wstoken: $mmSite.getToken()
            },
            wsFunction = $mmSite.getCompatibleFunction('mod_scorm_insert_scorm_tracks'),
            response;

        if (!tracks || !tracks.length) {
            return true; // Nothing to save.
        }

        // Check if the method is available, use a prefixed version if possible.
        if (!$mmSite.wsAvailable(wsFunction, false)) {
            if ($mmSite.wsAvailable(mmCoreWSPrefix + wsFunction, false)) {
                wsFunction = mmCoreWSPrefix + wsFunction;
            } else {
                $log.error("WS function '" + wsFunction + "' is not available, even in compatibility mode.");
                return false;
            }
        }

        response = $mmWS.syncCall(wsFunction, params, preSets);
        if (response && !response.error && response.trackids) {
            return true;
        }
        return false;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

.constant('mmaModScormSynchronizationStore', 'mod_scorm_sync')

.config(["$mmSitesFactoryProvider", "mmaModScormSynchronizationStore", function($mmSitesFactoryProvider, mmaModScormSynchronizationStore) {
    var stores = [
        {
            name: mmaModScormSynchronizationStore,
            keyPath: 'scormid',
            indexes: []
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * SCORM synchronization service.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormSync
 */
.factory('$mmaModScormSync', ["$mmaModScorm", "$mmSite", "$q", "$translate", "$mmaModScormOnline", "$mmaModScormOffline", "$mmUtil", "$log", "mmaModScormSynchronizationStore", "mmaModScormSyncTime", "$mmConfig", "mmCoreSettingsSyncOnlyOnWifi", "$mmApp", "$mmEvents", "mmaModScormEventAutomSynced", "$mmSitesManager", function($mmaModScorm, $mmSite, $q, $translate, $mmaModScormOnline, $mmaModScormOffline, $mmUtil,
            $log, mmaModScormSynchronizationStore, mmaModScormSyncTime, $mmConfig, mmCoreSettingsSyncOnlyOnWifi, $mmApp,
            $mmEvents, mmaModScormEventAutomSynced, $mmSitesManager) {
    $log = $log.getInstance('$mmaModScormSync');

    var self = {},
        syncPromises = {}; // Store sync promises.

    /**
     * Get the synchronization time of a SCORM. Returns 0 if no time stored.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#getScormSyncTime
     * @param {Number} scormId  SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the time.
     */
    self.getScormSyncTime = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            return db.get(mmaModScormSynchronizationStore, scormId).then(function(entry) {
                return entry.time;
            }).catch(function() {
                return 0;
            });
        });
    };

    /**
     * Set the synchronization time of a SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#setScormSyncTime
     * @param {Number} scormId  SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @param {Number} [time]   Time to set. If not defined, current time.
     * @return {Promise}        Promise resolved when the time is set.
     */
    self.setScormSyncTime = function(scormId, siteId, time) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            if (typeof time == 'undefined') {
                time = new Date().getTime();
            }
            return db.insert(mmaModScormSynchronizationStore, {scormid: scormId, time: time});
        });
    };

    /**
     * Try to synchronize all SCORMs from current site that need it and haven't been synchronized in a while.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#syncAllScorms
     * @param {String} [siteId] Site ID to sync. If not defined, sync all sites.
     * @return {Promise}        Promise resolved when the sync is done.
     */
    self.syncAllScorms = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all SCORMs because device is offline.');
            return $q.reject();
        }

        // We first check sync settings and current connection to see if we can sync.
        return $mmConfig.get(mmCoreSettingsSyncOnlyOnWifi, true).then(function(syncOnlyOnWifi) {

            if (syncOnlyOnWifi && $mmApp.isNetworkAccessLimited()) {
                $log.debug('Cannot sync all SCORMs because device isn\'t using a WiFi network.');
                return $q.reject();
            }

            var promise;
            if (!siteId) {
                // No site ID defined, sync all sites.
                $log.debug('Try to sync SCORMs in all sites.');
                promise = $mmSitesManager.getSitesIds();
            } else {
                $log.debug('Try to sync SCORMs in site ' + siteId);
                promise = $q.when([siteId]);
            }

            return promise.then(function(siteIds) {
                var sitePromises = [];

                angular.forEach(siteIds, function(siteId) {
                    sitePromises.push($mmaModScormOffline.getAllAttempts(siteId).then(function(attempts) {
                        var scorms = [],
                            ids = [], // To prevent duplicates.
                            promises = [];

                        // Get the IDs of all the SCORMs that have something to be synced.
                        angular.forEach(attempts, function(attempt) {
                            if (ids.indexOf(attempt.scormid) == -1) {
                                ids.push(attempt.scormid);
                                scorms.push({
                                    id: attempt.scormid,
                                    courseid: attempt.courseid
                                });
                            }
                        });

                        // Sync all SCORMs that haven't been synced for a while and that aren't played right now.
                        angular.forEach(scorms, function(scorm) {
                            if (!$mmaModScorm.isScormBeingPlayed(scorm.id, siteId)) {
                                promises.push($mmaModScorm.getScormById(scorm.courseid, scorm.id, '', siteId).then(function(scorm) {
                                    return self.syncScormIfNeeded(scorm, siteId).then(function(warnings) {
                                        if (typeof warnings != 'undefined') {
                                            // We tried to sync. Send event.
                                            $mmEvents.trigger(mmaModScormEventAutomSynced, {
                                                siteid: siteId,
                                                scormid: scorm.id
                                            });
                                        }
                                    });
                                }));
                            }
                        });

                        return $q.all(promises);
                    }));
                });

                return $q.all(sitePromises);
            });
        });
    };

    /**
     * Send data from a SCORM offline attempt to the site.
     * Reserved for core use, please use $mmaModScormSync#syncScorm to synchronize SCORM data.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#_syncAttempt
     * @param  {Number} scormId  SCORM ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when the attempt is successfully synced.
     * @protected
     */
    self._syncAttempt = function(scormId, attempt, siteId) {
        siteId = siteId || $mmSite.getId();
        $log.debug('Try to sync attempt ' + attempt + ' in SCORM ' + scormId + ' and site ' + siteId);
        // Get only not synced entries.
        return $mmaModScormOffline.getScormStoredData(siteId, scormId, attempt, undefined, true).then(function(entries) {
            var scos = {},
                promises = [],
                somethingSynced = false;

            // Get data to send (only elements with dots like cmi.core.exit, in Mobile we store more data to make offline work).
            angular.forEach(entries, function(entry) {
                if (entry.element.indexOf('.') > -1) {
                    if (!scos[entry.scoid]) {
                        scos[entry.scoid] = [];
                    }
                    scos[entry.scoid].push({
                        element: entry.element,
                        value: entry.value
                    });
                }
            });

            angular.forEach(scos, function(tracks, scoId) {
                promises.push($mmaModScormOnline.saveTracks(siteId, scormId, scoId, attempt, tracks).then(function() {
                    // Sco data successfully sent. Mark them as synced. This is needed because some SCOs sync might fail.
                    return $mmaModScormOffline.markAsSynced(siteId, scormId, attempt, undefined, scoId).catch(function() {
                        // Ignore errors.
                    }).then(function() {
                        somethingSynced = true;
                    });
                }));
            });

            return $mmUtil.allPromises(promises).then(function() {
                // Attempt has been sent. Let's delete it from local.
                return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                    // Failed to delete (shouldn't happen). Let's retry once.
                    return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                        // Maybe there's something wrong with the data or the storage implementation.
                        $log.error('After sync: error deleting attempt ' + attempt + ' in SCORM ' + scormId);
                    });
                });
            }).catch(function() {
                if (somethingSynced) {
                    // Some SCOs have been synced and some not. We'll try to store a snapshot of the current state
                    // to be able to re-try the synchronization later.
                    $log.error('Error synchronizing some SCOs for attempt ' + attempt + ' in SCORM ' + scormId + '. Saving snapshot.');
                    return saveSyncSnapshot(scormId, attempt, siteId).then(function() {
                        return $q.reject();
                    });
                } else {
                    $log.error('Error synchronizing attempt ' + attempt + ' in SCORM ' + scormId);
                }
                return $q.reject();
            });
        });
    };

    /**
     * Save a snapshot from a synchronization.
     *
     * @param  {Number} scormId SCORM ID.
     * @param  {Number} attempt Attemot number.
     * @param  {String} siteId  Site ID.
     * @return {Promise}        Promise resolved when the snapshot is stored.
     */
    function saveSyncSnapshot(scormId, attempt, siteId) {
        // Try to get current state from Moodle.
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, true).then(function(data) {
            return $mmaModScormOffline.setAttemptSnapshot(siteId, scormId, attempt, data);
        }, function() {
            // Error getting user data from Moodle. We'll have to build it ourselves.
            // Let's try to get cached data about the attempt.
            return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId).catch(function() {
                // No cached data, Moodle has no data stored.
                return {};
            }).then(function(data) {
                // We need to add the synced data to the snapshot.
                return $mmaModScormOffline.getScormStoredData(siteId, scormId, attempt, undefined, false, true)
                            .then(function(synced) {
                    angular.forEach(synced, function(entry) {
                        if (!data[entry.scoid]) {
                            data[entry.scoid] = {
                                scoid: entry.scoid,
                                userdata: {}
                            };
                        }
                        data[entry.scoid].userdata[entry.element] = entry.value;
                    });
                    return $mmaModScormOffline.setAttemptSnapshot(siteId, scormId, attempt, data);
                });
            });
        });
    }

    /**
     * Sync a SCORM only if a certain time has passed since the last time.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#syncScormIfNeeded
     * @param {Object} scorm    SCORM downloaded.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the SCORM is synced or if it doesn't need to be synced.
     */
    self.syncScormIfNeeded = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.getScormSyncTime(scorm.id, siteId).then(function(time) {
            if (new Date().getTime() - mmaModScormSyncTime >= time) {
                return self.syncScorm(scorm, siteId);
            }
        });
    };

    /**
     * Try to synchronize a SCORM's attempts.
     * The promise returned will be resolved with an array with warnings if the synchronization is successful. A successful
     * synchronization doesn't mean that all the data has been sent to the site, it's possible that some attempt can't be sent.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#syncScorm
     * @param  {Object} scorm   SCORM to sync.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with warnings in success, rejected if synchronization fails.
     */
    self.syncScorm = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        var warnings = [],
            syncPromise,
            deleted = false;

        if (syncPromises[siteId] && syncPromises[siteId][scorm.id]) {
            // There's already a sync ongoing for this SCORM, return the promise.
            return syncPromises[siteId][scorm.id];
        } else if (!syncPromises[siteId]) {
            syncPromises[siteId] = {};
        }

        if ($mmaModScormOnline.isScormBlocked(siteId, scorm.id) || $mmaModScormOffline.isScormBlocked(siteId, scorm.id)) {
            $log.debug('Cannot sync SCORM ' + scorm.id + ' because it is blocked.');
            return $q.reject();
        }

        $log.debug('Try to sync SCORM ' + scorm.id + ' in site ' + siteId);

        // Prefetches data , set sync time and return warnings.
        function finishSync() {
            return $mmaModScorm.invalidateAllScormData(scorm.id, siteId).catch(function() {}).then(function() {
                return $mmaModScorm.prefetchData(scorm, siteId).then(function() {
                    return self.setScormSyncTime(scorm.id, siteId).catch(function() {
                        // Ignore errors.
                    }).then(function() {
                        return warnings; // No offline attempts, nothing to sync.
                    });
                });
            });
        }

        // Get attempts data. We ignore cache for online attempts, so this call will fail if offline or server down.
        syncPromise = $mmaModScorm.getAttemptCount(scorm.id, siteId, undefined, false, true).then(function(attemptsData) {
            if (!attemptsData.offline || !attemptsData.offline.length) {
                return finishSync();
            }

            var collisions = [],
                lastOnline = 0,
                promise;

            // Check if there are collisions between offline and online attempts (same number).
            angular.forEach(attemptsData.online, function(attempt) {
                lastOnline = Math.max(lastOnline, attempt);
                if (attemptsData.offline.indexOf(attempt) > -1) {
                    collisions.push(attempt);
                }
            });

            // Check if last online attempt is finished. Ignore cache.
            promise = lastOnline > 0 ? $mmaModScorm.isAttemptIncomplete(scorm.id, lastOnline, false, true, siteId) : $q.when(false);

            return promise.then(function(incomplete) {
                if (!collisions.length && !incomplete) {
                    // No collisions and last attempt is complete. Send offline attempts to Moodle.
                    var promises = [];
                    angular.forEach(attemptsData.offline, function(attempt) {
                        if (scorm.maxattempt == 0 || attempt <= scorm.maxattempt) {
                            promises.push(self._syncAttempt(scorm.id, attempt, siteId));
                        }
                    });
                    return $q.all(promises).then(function() {
                        return finishSync();
                    });

                } else if (collisions.length) {
                    // We have collisions, treat them.
                    return treatCollisions(scorm.id, siteId, collisions, lastOnline, attemptsData.offline).then(function(warns) {
                        warnings = warnings.concat(warns);

                        // The offline attempts might have changed since some collisions can be converted to new attempts.
                        return $mmaModScormOffline.getAttempts(siteId, scorm.id).then(function(entries) {
                            var promises = [],
                                cannotSyncSome = false;

                            entries = entries.map(function(entry) {
                                return entry.attempt; // Get only the attempt number.
                            });
                            if (incomplete && entries.indexOf(lastOnline) > -1) {
                                // Last online was incomplete, but it was continued in offline.
                                incomplete = false;
                            }

                            angular.forEach(entries, function(attempt) {
                                // We'll always sync attempts previous to lastOnline (failed sync or continued in offline).
                                // We'll only sync new attemps if last online attempt is completed.
                                if (!incomplete || attempt <= lastOnline) {
                                    if (scorm.maxattempt == 0 || attempt <= scorm.maxattempt) {
                                        promises.push(self._syncAttempt(scorm.id, attempt, siteId));
                                    }
                                } else {
                                    cannotSyncSome = true;
                                }
                            });
                            return $q.all(promises).then(function() {
                                if (cannotSyncSome) {
                                    warnings.push($translate.instant('mma.mod_scorm.warningsynconlineincomplete'));
                                }
                                return finishSync();
                            });
                        });
                    });
                } else {
                    // No collisions, but last online attempt is incomplete so we can't send offline attempts.
                    warnings.push($translate.instant('mma.mod_scorm.warningsynconlineincomplete'));
                    return finishSync();
                }
            });
        }).finally(function() {
            deleted = true;
            delete syncPromises[siteId][scorm.id];
        });

        if (!deleted) {
            syncPromises[siteId][scorm.id] = syncPromise;
        }
        return syncPromise;
    };

    /**
     * Treat collisions found in a SCORM synchronization process.
     *
     * @param  {Number} scormId           SCORM ID.
     * @param  {String} siteId            Site ID.
     * @param  {Number[]} collisions      Numbers of attempts that exist both in online and offline.
     * @param  {Number} lastOnline        Last online attempt.
     * @param  {Number[]} offlineAttempts Numbers of offline attempts.
     * @return {Promise}                  Promise resolved when the collisions have been treated. It returns warnings array.
     * @description
     *
     * Treat collisions found in a SCORM synchronization process. A collision is when an attempt exists both in offline
     * and online. A collision can be:
     *
     * - Two different attempts.
     * - An online attempt continued in offline.
     * - A failure in a previous sync.
     *
     * This function will move into new attempts the collisions that can't be merged. It will usually keep the order of the
     * offline attempts EXCEPT if the offline attempt was created after the last offline attempt (edge case).
     *
     * Edge case: A user creates offline attempts and when he syncs we retrieve an incomplete online attempt, so the offline
     * attempts cannot be synced. Then the user continues that online attempt and goes offline, so a collision is created.
     * When we perform the next sync we detect that this collision cannot be merged, so this offline attempt needs to be
     * created as a new attempt. Since this attempt was created after the last offline attempt, it will be added ot the end
     * of the list if the last attempt is completed. If the last attempt is not completed then the offline data will de deleted
     * because we can't create a new attempt.
     */
    function treatCollisions(scormId, siteId, collisions, lastOnline, offlineAttempts) {
        var warnings = [],
            promises = [],
            newAttemptsSameOrder = [], // Attempts that will be created as new attempts but keeping the current order.
            newAttemptsAtEnd = {}, // Attempts that will be created at the end of the list of attempts (should be max 1 attempt).
            lastCollision = Math.max.apply(Math, collisions),
            lastOffline = Math.max.apply(Math, offlineAttempts),
            lastOfflineIncomplete,
            lastOfflineCreated;

        // Get the creation time and the status (complete/incomplete) of the last offline attempt.
        function getLastOfflineAttemptData() {
            // Check if last offline attempt is incomplete.
            return $mmaModScorm.isAttemptIncomplete(scormId, lastOffline, true, false, siteId).then(function(incomplete) {
                lastOfflineIncomplete = incomplete;
                return $mmaModScormOffline.getAttemptCreationTime(siteId, scormId, lastOffline).then(function(time) {
                    lastOfflineCreated = time;
                });
            });
        }

        // Add an attempt to the right new attempts array if possible.
        // If the attempt cannot be created as a new attempt then it will be deleted.
        function addToNewOrDelete(attempt) {
            if (attempt == lastOffline) {
                newAttemptsSameOrder.push(attempt);
                return $q.when();
            }

            return $mmaModScormOffline.getAttemptCreationTime(siteId, scormId, attempt).then(function(time) {
                if (time > lastOfflineCreated) {
                    // This attempt was created after the last offline attempt, we'll add it to the end of the list if possible.
                    if (lastOfflineIncomplete) {
                        // It can't be added because the last offline attempt is incomplete, delete it.
                        $log.debug('Try to delete attempt ' + attempt + ' because it cannot be created as a new attempt.');
                        return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).then(function() {
                            warnings.push($translate.instant('mma.mod_scorm.warningofflinedatadeleted', {number: attempt}));
                        }).catch(function() {
                            // Maybe there's something wrong with the data or the storage implementation.
                        });
                    } else {
                        newAttemptsAtEnd[time] = attempt;
                    }

                } else {
                    newAttemptsSameOrder.push(attempt);
                }
            });
        }

        // Get needed data from the last offline attempt.
        return getLastOfflineAttemptData().then(function() {

            collisions.forEach(function(attempt) {
                // First get synced entries to detect if it was a failed synchronization.
                var getDataFn = $mmaModScormOffline.getScormStoredData,
                    promise = getDataFn(siteId, scormId, attempt, undefined, false, true).then(function(synced) {
                    if (synced && synced.length) {
                        // The attempt has synced entries, it seems to be a failed synchronization.
                        // Let's get the entries that haven't been synced, maybe it just failed to delete the attempt.
                        return getDataFn(siteId, scormId, attempt, undefined, true).then(function(entries) {
                            var hasDataToSend = false;
                            angular.forEach(entries, function(entry) {
                                if (entry.element.indexOf('.') > -1) {
                                    hasDataToSend = true;
                                }
                            });

                            if (hasDataToSend) {
                                // There are elements to sync. We need to check if it's possible to sync them or not.
                                return canRetrySync(scormId, siteId, attempt, lastOnline).catch(function() {
                                    // Cannot retry sync, we'll create a new offline attempt if possible.
                                    return addToNewOrDelete(attempt);
                                });
                            } else {
                                // Nothing to sync, delete the attempt.
                                return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                                    // Maybe there's something wrong with the data or the storage implementation.
                                });
                            }
                        });
                    } else {
                        // It's not a failed synchronization. Check if it's an attempt continued in offline.
                        return $mmaModScormOffline.getAttemptSnapshot(siteId, scormId, attempt).then(function(snapshot) {
                            if (snapshot && Object.keys(snapshot).length) {
                                // It has a snapshot, it means it continued an online attempt. We need to check if they've diverged.
                                // If it's the last attempt we don't need to ignore cache because we already did it.
                                var refresh = lastOnline != attempt;
                                return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, refresh)
                                            .then(function(data) {
                                    if (!snapshotEquals(snapshot, data)) {
                                        // Snapshot has diverged, it will be converted into a new attempt if possible.
                                        return addToNewOrDelete(attempt);
                                    }
                                });
                            } else {
                                // No snapshot, it's a different attempt.
                                newAttemptsSameOrder.push(attempt);
                            }
                        });
                    }
                });
                promises.push(promise);
            });

            return $q.all(promises).then(function() {
                return moveNewAttempts(scormId, siteId, newAttemptsSameOrder, lastOnline, lastCollision, offlineAttempts).then(function() {
                    // The new attempts that need to keep the order have been created. Now we'll create the new attempts
                    // at the end of the list of offline attempts. It should only be 1 attempt max.
                    lastOffline = lastOffline + newAttemptsSameOrder.length;
                    return createNewAttemptsAtEnd(scormId, siteId, newAttemptsAtEnd, lastOffline).then(function() {
                        return warnings;
                    });
                });
            });
        });
    }

    /**
     * Change the number of some offline attempts. We need to move all offline attempts after the collisions
     * too, otherwise we would overwrite data.
     * Example: We have offline attempts 1, 2 and 3. #1 and #2 have collisions. #1 can be synced, but #2 needs
     * to be a new attempt. #3 will now be #4, and #2 will now be #3.
     *
     * @param  {Number} scormId           SCORM ID.
     * @param  {String} siteId            Site ID.
     * @param  {Number[]} newAttempts     Attempts that need to be converted into new attempts.
     * @param  {Number} lastOnline        Last online attempt.
     * @param  {Number} lastCollision     Last attempt with collision (exists in online and offline).
     * @param  {Number[]} offlineAttempts Numbers of offline attempts.
     * @return {Promise}                  Promise resolved when attempts have been moved.
     */
    function moveNewAttempts(scormId, siteId, newAttempts, lastOnline, lastCollision, offlineAttempts) {
        if (!newAttempts.length) {
            return $q.when();
        }

        var promise = $q.when(),
            lastSuccessful;

        // Sort offline attempts in DESC order.
        offlineAttempts = offlineAttempts.sort(function(a, b) {
            return parseInt(a, 10) < parseInt(b, 10);
        });

        // First move the offline attempts after the collisions;
        angular.forEach(offlineAttempts, function(attempt) {
            if (attempt > lastCollision) {
                // We use a chain of promises because we need to move them in order.
                promise = promise.then(function() {
                    var newNumber = attempt + newAttempts.length;
                    return $mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, newNumber).then(function() {
                        lastSuccessful = attempt;
                    });
                });
            }
        });

        return promise.then(function() {
            var promises = [],
                successful = [];

            // Sort newAttempts in ASC order.
            newAttempts = newAttempts.sort(function(a, b) {
                return parseInt(a, 10) > parseInt(b, 10);
            });

            // Now move the attempts in newAttempts.
            angular.forEach(newAttempts, function(attempt, index) {
                // No need to use chain of promises.
                var newNumber = lastOnline + index + 1;
                promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, newNumber).then(function() {
                    successful.push(attempt);
                }));
            });

            return $q.all(promises).catch(function() {
                // Moving the new attempts failed (it shouldn't happen). Let's undo the new attempts move.
                promises = [];
                angular.forEach(successful, function(attempt) {
                    var newNumber = lastOnline + newAttempts.indexOf(attempt) + 1;
                    promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, newNumber, attempt));
                });
                return $mmUtil.allPromises(promises).then(function() {
                    return $q.reject(); // It will now enter the .catch that moves offline attempts after collisions.
                });
            });

        }).catch(function() {
            // Moving offline attempts after collisions failed (it shouldn't happen). Let's undo the changes.
            if (!lastSuccessful) {
                return $q.reject();
            }

            promise = $q.when();

            var attemptsToUndo = [];
            for (var i = lastSuccessful; offlineAttempts.indexOf(i) != -1; i++) {
                attemptsToUndo.push(i);
            }
            attemptsToUndo.forEach(function(attempt) {
                promise = promise.then(function() {
                    // Move it back.
                    return $mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt + newAttempts.length, attempt);
                });
            });
            return promise.then(function() {
                return $q.reject();
            });
        });
    }

    /**
     * Create new attempts at the end of the offline attempts list.
     *
     * @param  {Number} scormId     SCORM ID.
     * @param  {String} siteId      Site ID.
     * @param  {Object} newAttempts Attempts to create. The keys are the timecreated, the values are the attempt number.
     * @param  {Number} lastOffline Number of last offline attempt.
     * @return {Promise}            Promise resolved when the creation is finished.
     */
    function createNewAttemptsAtEnd(scormId, siteId, newAttempts, lastOffline) {
        var times = Object.keys(newAttempts).sort(), // Sort in ASC order.
            promises = [];

        if (!times.length) {
            return $q.when();
        }

        angular.forEach(times, function(time, index) {
            var attempt = newAttempts[time];
            promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, lastOffline + index + 1));
        });
        return $mmUtil.allPromises(promises);
    }

    /**
     * Check if can retry an attempt synchronization.
     *
     * @param  {Number} scormId    SCORM ID.
     * @param  {String} siteId     Site ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Number} lastOnline Last online attempt number.
     * @return {Promise}           Promise resolved if can retry the synchronization, false otherwise.
     */
    function canRetrySync(scormId, siteId, attempt, lastOnline) {
        // If it's the last attempt we don't need to ignore cache because we already did it.
        var refresh = lastOnline != attempt;
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, refresh).then(function(siteData) {
            // Get synchronization snapshot (if sync fails it should store a snapshot).
            return $mmaModScormOffline.getAttemptSnapshot(siteId, scormId, attempt).then(function(snapshot) {
                if (!snapshot || !Object.keys(snapshot).length || !snapshotEquals(snapshot, siteData)) {
                    // No snapshot or it doesn't match, we can't retry the synchronization.
                    return $q.reject();
                }
            });
        });
    }

    /**
     * Compares an attempt's snapshot with the data retrieved from the site.
     * It only compares elements with dot notation. This means that, if some SCO has been added to Moodle web
     * but the user hasn't generated data for it, then the snapshot will be detected as equal.
     *
     * @param  {Object} snapshot Attempt's snapshot.
     * @param  {Object} userData Data retrieved from the site.
     * @return {Boolean}         True if snapshot is equal to the user data, false otherwise.
     */
    function snapshotEquals(snapshot, userData) {
        var scoId,
            element,
            siteSco,
            snapshotSco;

        // Check that snapshot contains the data from the site.
        for (scoId in userData) {
            siteSco = userData[scoId];
            snapshotSco = snapshot[scoId];

            for (element in siteSco.userdata) {
                if (element.indexOf('.') > -1) {
                    if (!snapshotSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {
                        return false;
                    }
                }
            }
        }

        // Now check the opposite way: site userData contains the data from the snapshot.
        for (scoId in snapshot) {
            siteSco = userData[scoId];
            snapshotSco = snapshot[scoId];

            for (element in snapshotSco.userdata) {
                if (element.indexOf('.') > -1) {
                    if (!siteSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    /**
     * If there's an ongoing sync for a certain SCORM, wait for it to end.
     * If there's no sync ongoing the promise will be resolved right away.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#waitForSync
     * @param  {Number} scormId  SCORM to check.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when there's no sync going on for the SCORM.
     */
    self.waitForSync = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        if (syncPromises[siteId] && syncPromises[siteId][scormId]) {
            // There's a sync ongoing for this SCORM.
            return syncPromises[siteId][scormId].catch(function() {});
        }
        return $q.when();
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey')

/**
 * Survey index controller.
 *
 * @module mm.addons.mod_survey
 * @ngdoc controller
 * @name mmaModSurveyIndexCtrl
 */
.controller('mmaModSurveyIndexCtrl', ["$scope", "$stateParams", "$mmaModSurvey", "$mmUtil", "$q", "$mmCourse", "$translate", "$ionicPlatform", "$ionicScrollDelegate", function($scope, $stateParams, $mmaModSurvey, $mmUtil, $q, $mmCourse, $translate,
            $ionicPlatform, $ionicScrollDelegate) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        survey,
        scrollView;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;
    $scope.answers = {};
    $scope.isTablet = $ionicPlatform.isTablet();

    // Convenience function to get survey data.
    function fetchSurveyData(refresh) {
        return $mmaModSurvey.getSurvey(courseid, module.id).then(function(surveydata) {
            survey = surveydata;

            $scope.title = survey.name || $scope.title;
            $scope.description = survey.intro || $scope.description;
            $scope.survey = survey;

            if (!survey.surveydone) {
                return fetchQuestions();
            }
        }).catch(function(message) {
            if (!refresh) {
                // Some call failed, retry without using cache since it might be a new activity.
                return refreshAllData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_survey.errorgetsurvey', true);
            }
            return $q.reject();
        });
    }

    // Convenience function to get survey questions.
    function fetchQuestions() {
        return $mmaModSurvey.getQuestions(survey.id).then(function(questions) {
            return $mmaModSurvey.formatQuestions(questions).then(function(formatted) {
                $scope.questions = formatted;

                // Init answers object.
                angular.forEach(formatted, function(q) {
                    if (q.name) {
                        var isTextArea = q.multi && q.multi.length === 0 && q.type === 0;
                        $scope.answers[q.name] = q.required ? -1 : (isTextArea ? '' : '0');
                    }
                });
            });
        });
    }

    // Convenience function to refresh all the data.
    function refreshAllData() {
        var p1 = $mmaModSurvey.invalidateSurveyData(courseid),
            p2 = survey ? $mmaModSurvey.invalidateQuestions(survey.id) : $q.when();

        return $q.all([p1, p2]).finally(function() {
            return fetchSurveyData(true);
        });
    }

    fetchSurveyData().then(function() {
        $mmaModSurvey.logView(survey.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.surveyLoaded = true;
    });

    // Check if answers are valid to be submitted.
    $scope.isValidResponse = function() {
        var valid = true;
        angular.forEach($scope.answers, function(a) {
            if (a === -1) {
                valid = false;
            }
        });
        return valid;
    };

    // Save options selected.
    $scope.submit = function() {
        $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
            var answers = [],
                modal = $mmUtil.showModalLoading('mm.core.sending', true);

            angular.forEach($scope.answers, function(value, key) {
                answers.push({
                    key: key,
                    value: value
                });
            });

            $mmaModSurvey.submitAnswers(survey.id, answers).then(function() {
                if (!scrollView) {
                    scrollView = $ionicScrollDelegate.$getByHandle('mmaModSurveyScroll');
                }
                scrollView && scrollView.scrollTop && scrollView.scrollTop();
                return refreshAllData();
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_survey.cannotsubmitsurvey', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };

    // Pull to refresh.
    $scope.refreshSurvey = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey')

/**
 * Mod survey handlers.
 *
 * @module mm.addons.mod_survey
 * @ngdoc service
 * @name $mmaModSurveyHandlers
 */
.factory('$mmaModSurveyHandlers', ["$mmCourse", "$mmaModSurvey", "$state", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModSurvey, $state, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurveyHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModSurvey.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('survey');
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_survey', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurveyHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModSurvey.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a survey URL.
            if (url.indexOf('/mod/survey/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey')

/**
 * Survey service.
 *
 * @module mm.addons.mod_survey
 * @ngdoc service
 * @name $mmaModSurvey
 */
.factory('$mmaModSurvey', ["$q", "$mmSite", "$translate", "$mmSitesManager", function($q, $mmSite, $translate, $mmSitesManager) {
    var self = {};

    /**
     * Turns a string with values separated by commas into an array.
     *
     * @param {String} value Value to convert.
     * @return {Array}       Array.
     */
    function commaStringToArray(value) {
        if (typeof value == 'string') {
            if (value !== '') {
                return value.split(',');
            } else {
                return [];
            }
        } else {
            return value;
        }
    }

    /**
     * Format a questions list, turning "multi" and "options" strings into arrays and adding the properties
     * 'num' and 'name'.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#formatQuestions
     * @param {Object[]} questions Questions.
     * @return {Promise}           Promise resolved with the formatted questions.
     */
    self.formatQuestions = function(questions) {
        var stringkeys = [
            'mma.mod_survey.ipreferthat',
            'mma.mod_survey.ifoundthat',
            'mm.core.choose'
        ];

        return $translate(stringkeys).then(function(translates) {
            var stripreferthat = translates[stringkeys[0]],
                strifoundthat = translates[stringkeys[1]],
                strchoose = translates[stringkeys[2]],
                formatted = [],
                parents = self.getParentQuestions(questions),
                num = 1;

            questions = angular.copy(questions); // Copy the array to prevent modifying the original.

            angular.forEach(questions, function(question) {
                var parent = parents[question.parent];

                // Turn multi and options into arrays.
                question.multi = commaStringToArray(question.multi);
                question.options = commaStringToArray(question.options);

                if (parent) {
                    // It's a sub-question.
                    question.required = true;

                    if (parent.type === 1 || parent.type === 2) {
                        // One answer question. Set its name and add it to the returned array.
                        question.name = 'q' + (parent.type == 2 ? 'P' : '') + question.id;
                        question.num = num++;
                    } else {
                        // Two answers per question (COLLES P&A). We'll add two questions.
                        var q2 = angular.copy(question);

                        question.text = stripreferthat + ' ' + question.text;
                        question.name = 'qP' + question.id;
                        question.num = num++;
                        formatted.push(question);

                        q2.text = strifoundthat + ' ' + q2.text;
                        q2.name = 'q' + question.id;
                        q2.num = num++;
                        formatted.push(q2);

                        return;
                    }
                } else if (question.multi && question.multi.length === 0) {
                    // It's a single question.
                    question.name = 'q' + question.id;
                    question.num = num++;
                    if (question.type > 0) { // Add "choose" option since this question is not required.
                        question.options.unshift(strchoose);
                    }
                }

                formatted.push(question);
            });

            return formatted;
        });
    };

    /**
     * Gets the parent questions and puts them in an object: ID -> question.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#getParentQuestions
     * @param {Object[]} questions Questions.
     * @return {Object}            Object with parent questions.
     */
    self.getParentQuestions = function(questions) {
        var parents = {};

        angular.forEach(questions, function(question) {
            if (question.parent === 0) {
                parents[question.id] = question;
            }
        });

        return parents;
    };

    /**
     * Get a survey's questions.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#getQuestions
     * @param {Number} id Survey ID.
     * @return {Promise}  Promise resolved when the questions are retrieved.
     */
    self.getQuestions = function(id) {
        var params = {
                surveyid: id
            },
            preSets = {
                cacheKey: getQuestionsCacheKey(id)
            };

        return $mmSite.read('mod_survey_get_questions', params, preSets).then(function(response) {
            if (response.questions) {
                return response.questions;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for survey questions WS calls.
     *
     * @param {Number} id Survey ID.
     * @return {String}   Cache key.
     */
    function getQuestionsCacheKey(id) {
        return 'mmaModSurvey:questions:' + id;
    }

    /**
     * Get a survey.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#getSurvey
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the survey is retrieved.
     */
    self.getSurvey = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getSurveyDataCacheKey(courseid)
            };

        return $mmSite.read('mod_survey_get_surveys_by_courses', params, preSets).then(function(response) {
            if (response.surveys) {
                var currentSurvey;
                angular.forEach(response.surveys, function(survey) {
                    if (survey.coursemodule == cmid) {
                        currentSurvey = survey;
                    }
                });
                if (currentSurvey) {
                    return currentSurvey;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for survey data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getSurveyDataCacheKey(courseid) {
        return 'mmaModSurvey:survey:' + courseid;
    }

    /**
     * Invalidates survey questions.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#invalidateQuestions
     * @param {Number} id Survey ID.
     * @return {Promise}  Promise resolved when the data is invalidated.
     */
    self.invalidateQuestions = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getQuestionsCacheKey(courseid));
    };

    /**
     * Invalidates survey data.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#invalidateSurveyData
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateSurveyData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getSurveyDataCacheKey(courseid));
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the survey WS are available.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_survey_get_questions') &&
                    site.wsAvailable('mod_survey_get_surveys_by_courses') &&
                    site.wsAvailable('mod_survey_submit_answers');
        });
    };

    /**
     * Report the survey as being viewed.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#logView
     * @param {String} id Survey ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                surveyid: id
            };
            return $mmSite.write('mod_survey_view_survey', params);
        }
        return $q.reject();
    };

    /**
     * Send survey answers to Moodle.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#submitAnswers
     * @param {Number} surveyid  urvey ID.
     * @param {Object[]} answers Answers.
     * @return {Promise}         Promise resolved when answers are successfully submitted.
     */
    self.submitAnswers = function(surveyid, answers) {
        var params = {
            surveyid: surveyid,
            answers: answers
        };
        return $mmSite.write('mod_survey_submit_answers', params).then(function(response) {
            if (!response.status) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url')

/**
 * URL index controller.
 *
 * @module mm.addons.mod_url
 * @ngdoc controller
 * @name mmaModUrlIndexCtrl
 */
.controller('mmaModUrlIndexCtrl', ["$scope", "$stateParams", "$mmaModUrl", "$mmCourse", function($scope, $stateParams, $mmaModUrl, $mmCourse) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.url = (module.contents && module.contents[0] && module.contents[0].fileurl) ? module.contents[0].fileurl : undefined;

    $scope.go = function() {
        $mmaModUrl.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
        $mmaModUrl.open($scope.url);
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url')

/**
 * Mod URL handlers.
 *
 * @module mm.addons.mod_url
 * @ngdoc service
 * @name $mmaModUrlHandlers
 */
.factory('$mmaModUrlHandlers', ["$mmCourse", "$mmaModUrl", "$state", "$mmUtil", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModUrl, $state, $mmUtil, $mmContentLinksHelper, $q) {

    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrlHandlers#courseContentHandler
     */
    self.courseContentHandler = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.icon = $mmCourse.getModuleIconSrc('url');
                $scope.title = module.name;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_url', {module: module, courseid: courseid});
                };

                if (module.contents && module.contents[0] && module.contents[0].fileurl) {
                    $scope.buttons = [{
                        icon: 'ion-link',
                        label: 'mm.core.openinbrowser',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            $mmaModUrl.logView(module.instance).then(function() {
                                $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                            });
                            $mmaModUrl.open(module.contents[0].fileurl);
                        }
                    }];
                }
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrlHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            if (courseId) {
                return $q.when(true);
            }
            return $mmCourse.canGetModuleWithoutCourseId(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a mod_url URL.
            if (url.indexOf('/mod/url/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url')

/**
 * URL service.
 *
 * @module mm.addons.mod_url
 * @ngdoc service
 * @name $mmaModUrl
 */
.factory('$mmaModUrl', ["$mmSite", "$mmUtil", "$q", function($mmSite, $mmUtil, $q) {
    var self = {};

    /**
     * Report a URL as being viewed.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrl#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                urlid: id
            };
            return $mmSite.write('mod_url_view_url', params);
        }
        return $q.reject();
    };

    /**
     * Opens a URL.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrl#open
     * @param {String} url The URL to go to.
     */
    self.open = function(url) {
        $mmUtil.openInBrowser(url);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Controller to handle notes.
 *
 * @module mm.addons.notes
 * @ngdoc controller
 * @name mmaNotesListCtrl
 */
.controller('mmaNotesListCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaNotes", "$mmSite", "$translate", function($scope, $stateParams, $mmUtil, $mmaNotes, $mmSite, $translate) {

    var courseid = $stateParams.courseid,
        type = $stateParams.type;

    $scope.courseid = courseid;
    $scope.type = type;

    $translate('mma.notes.' + type + 'notes').then(function(string) {
        $scope.title = string;
    });

    function fetchNotes(refresh) {
        return $mmaNotes.getNotes(courseid, refresh).then(function(notes) {
            notes = notes[type + 'notes'];

            return $mmaNotes.getNotesUserData(notes, courseid).then(function(notes) {
                $scope.notes = notes;
            });

        }, function(message) {
            $mmUtil.showErrorModal(message);
        });
    }

    fetchNotes().then(function() {
        // Add log in Moodle.
        $mmSite.write('core_notes_view_notes', {
            courseid: courseid,
            userid: 0
        });
    })
    .finally(function() {
        $scope.notesLoaded = true;
    });

    $scope.refreshNotes = function() {
        fetchNotes(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Note types view controller.
 *
 * @module mm.addons.notes
 * @ngdoc controller
 * @name mmaNotesTypesCtrl
 */
.controller('mmaNotesTypesCtrl', ["$scope", "$stateParams", function($scope, $stateParams) {
    var course = $stateParams.course,
        courseid = course.id;
    $scope.courseid = courseid;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Notes handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.notes
 * @ngdoc service
 * @name $mmaNotesHandlers
 */
.factory('$mmaNotesHandlers', ["$mmaNotes", "$mmSite", "$mmApp", "$ionicModal", "$mmUtil", "mmCoursesAccessMethods", function($mmaNotes, $mmSite, $mmApp, $ionicModal, $mmUtil, mmCoursesAccessMethods) {

    var self = {};

    /**
     * Add a note handler.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotesHandlers#addNote
     */
    self.addNote = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaNotes.isPluginAddNoteEnabled();
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User to check.
         * @param {Number} courseId Course ID.
         * @return {Boolean}        True if handler is enabled, false otherwise.
         */
        self.isEnabledForUser = function(user, courseId) {
            // Active course required.
            return courseId && user.id != $mmSite.getUserId();
        };

        /**
         * Get the controller.
         *
         * @param {Object} user     Course ID.
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(user, courseid) {

            /**
             * Add note handler controller.
             *
             * @module mm.addons.notes
             * @ngdoc controller
             * @name $mmaNotesHandlers#addNote:controller
             */
            return function($scope) {

                // Button title.
                $scope.title = 'mma.notes.addnewnote';

                $ionicModal.fromTemplateUrl('addons/notes/templates/add.html', {
                    scope: $scope,
                    animation: 'slide-in-up'
                }).then(function(m) {
                    $scope.modal = m;
                });

                $scope.closeModal = function(){
                    $scope.modal.hide();
                };

                $scope.addNote = function(){

                    $mmApp.closeKeyboard();

                    var loadingModal = $mmUtil.showModalLoading('mm.core.sending', true);
                    // Freeze the add note button.
                    $scope.processing = true;

                    $mmaNotes.addNote(user.id, courseid, $scope.note.publishstate, $scope.note.text).then(function() {
                        $mmUtil.showModal('mm.core.success', 'mma.notes.eventnotecreated');
                        $scope.closeModal();
                    }, function(error) {
                        $mmUtil.showErrorModal(error);
                        $scope.processing = false;
                    }).finally(function() {
                        loadingModal.dismiss();
                    });
                };

                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();

                    $scope.note = {
                        publishstate: 'personal',
                        text: ''
                    };
                    $scope.processing = false;

                    $scope.modal.show();

                };
            };

        };

        return self;
    };

    /**
     * Course nav handler.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotesHandlers#coursesNav
     */
    self.coursesNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaNotes.isPluginViewNotesEnabled();
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean}          True if handler is enabled, false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return true;
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(courseId) {

            /**
             * Courses nav handler controller.
             *
             * @module mm.addons.notes
             * @ngdoc controller
             * @name $mmaNotesHandlers#coursesNav:controller
             */
            return function($scope, $state) {
                $scope.icon = 'ion-ios-list';
                $scope.title = 'mma.notes.notes';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.notes-types', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Notes factory.
 *
 * @module mm.addons.notes
 * @ngdoc service
 * @name $mmaNotes
 */
.factory('$mmaNotes', ["$mmSite", "$log", "$q", "$mmUser", "$translate", function($mmSite, $log, $q, $mmUser, $translate) {
    $log = $log.getInstance('$mmaNotes');

    var self = {};

    /**
     * Add a note.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#addNote
     * @param {Number} userId       User ID of the person to add the note.
     * @param {Number} courseId     Course ID where the note belongs.
     * @param {String} publishState Personal, Site or Course.
     * @param {String} noteText     The note text.
     * @return {Promise}
     */
    self.addNote = function(userId, courseId, publishState, noteText) {
        var data = {
            "notes[0][userid]" : userId,
            "notes[0][publishstate]": publishState,
            "notes[0][courseid]": courseId,
            "notes[0][text]": noteText,
            "notes[0][format]": 1
        };
        return $mmSite.write('core_notes_create_notes', data);
    };

    /**
     * Returns whether or not the add note plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#isPluginAddNoteEnabled
     * @return {Boolean}
     */
    self.isPluginAddNoteEnabled = function() {
        var infos;

        if (!$mmSite.isLoggedIn()) {
            return false;
        } else if (!$mmSite.canUseAdvancedFeature('enablenotes')) {
            return false;
        } else if (!$mmSite.wsAvailable('core_notes_create_notes')) {
            return false;
        }

        return true;
    };

    /**
     * Returns whether or not the read notes plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#isPluginViewNotesEnabled
     * @return {Boolean}
     */
    self.isPluginViewNotesEnabled = function() {
        var infos;

        if (!$mmSite.isLoggedIn()) {
            return false;
        } else if (!$mmSite.canUseAdvancedFeature('enablenotes')) {
            return false;
        } else if (!$mmSite.wsAvailable('core_notes_get_course_notes')) {
            return false;
        }

        return true;
    };

    /**
     * Get users notes for a certain site, course and personal notes.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#getNotes
     * @param {Number} courseid ID of the course to get the notes from.
     * @param {Boolean} refresh True when we should not get the value from the cache.
     * @return {Promise}        Promise to be resolved when the notes are retrieved.
     */
    self.getNotes = function(courseid, refresh) {

        $log.debug('Get notes for course ' + courseid);

        var data = {
                courseid : courseid
            },
            presets = {};
        if (refresh) {
            presets.getFromCache = false;
        }

        return $mmSite.read('core_notes_get_course_notes', data, presets);
    };

    /**
     * Get user data for notes since they only have userid.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#getNotesUserData
     * @param {Object[]} notes       Notes to get the data for.
     * @param {Number}   courseid    ID of the course the notes belong to.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted notes.
     */
    self.getNotesUserData = function(notes, courseid) {
        var promises = [];

        angular.forEach(notes, function(note) {
            var promise = $mmUser.getProfile(note.userid, courseid, true).then(function(user) {
                note.userfullname = user.fullname;
                note.userprofileimageurl = user.profileimageurl;
            }, function() {
                // Error getting profile. Set default data.
                return $translate('mma.notes.userwithid', {id: note.userid}).then(function(str) {
                    note.userfullname = str;
                });
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return notes;
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Controller to handle notification list.
 *
 * @module mm.addons.notifications
 * @ngdoc controller
 * @name mmaNotificationsListCtrl
 */
.controller('mmaNotificationsListCtrl', ["$scope", "$mmUtil", "$mmaNotifications", "mmaNotificationsListLimit", function($scope, $mmUtil, $mmaNotifications, mmaNotificationsListLimit) {

    var readCount = 0,
        unreadCount = 0;

    $scope.notifications = [];

    // Convenience function to get notifications. Get unread notifications first.
    function fetchNotifications(refresh) {

        if (refresh) {
            readCount = 0;
            unreadCount = 0;
        }

        return $mmaNotifications.getUnreadNotifications(unreadCount, mmaNotificationsListLimit).then(function(unread) {
            // Don't add the unread notifications to $scope.notifications yet. If there are no unread notifications
            // that causes that the "There are no notifications" message is shown in pull to refresh.
            unreadCount += unread.length;

            if (unread.length < mmaNotificationsListLimit) {
                // Limit not reached. Get read notifications until reach the limit.
                var readLimit = mmaNotificationsListLimit - unread.length;
                return $mmaNotifications.getReadNotifications(readCount, readLimit).then(function(read) {
                    readCount += read.length;
                    if (refresh) {
                        $scope.notifications = unread.concat(read);
                    } else {
                        $scope.notifications = $scope.notifications.concat(unread).concat(read);
                    }
                    $scope.canLoadMore = read.length >= readLimit;
                }, function(error) {
                    if (unread.length == 0) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mma.notifications.errorgetnotifications', true);
                        }
                        $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
                    }
                });
            } else {
                if (refresh) {
                    $scope.notifications = unread;
                } else {
                    $scope.notifications = $scope.notifications.concat(unread);
                }
                $scope.canLoadMore = true;
            }
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.notifications.errorgetnotifications', true);
            }
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
        });
    }
    fetchNotifications().finally(function() {
        $scope.notificationsLoaded = true;
    });

    $scope.refreshNotifications = function() {
        $mmaNotifications.invalidateNotificationsList().finally(function() {
            fetchNotifications(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    $scope.loadMoreNotifications = function(){
        fetchNotifications().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Notification action directive.
 *
 * @module mm.addons.notifications
 * @ngdoc directive
 * @name mmaNotificationsActions
 */
.directive('mmaNotificationsActions', ["$log", "$mmContentLinksDelegate", function($log, $mmContentLinksDelegate) {
    $log = $log.getInstance('mmaNotificationsActions');

    // Directive link function.
    function link(scope) {
        if (scope.contexturl) {
            $mmContentLinksDelegate.getActionsFor(scope.contexturl, scope.courseid).then(function(actions) {
                scope.actions = actions;
            });
        }
    }

    return {
        link: link,
        restrict: 'E',
        scope: {
            contexturl: '=',
            courseid: '='
        },
        templateUrl: 'addons/notifications/templates/actions.html',
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Filter to format a notification.
 *
 * @module mm.addons.notifications
 * @ngdoc filter
 * @name mmaNotificationsFormat
 */
.filter('mmaNotificationsFormat', ["$mmText", function($mmText) {
  return function(text) {
    text = text.replace(/-{4,}/ig, '');
    text = $mmText.replaceNewLines(text, '<br />');
    return text;
  };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Notifications handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.notifications
 * @ngdoc service
 * @name $mmaNotificationsHandlers
 */
.factory('$mmaNotificationsHandlers', ["$log", "$mmaNotifications", function($log, $mmaNotifications) {
    $log = $log.getInstance('$mmaNotificationsHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotificationsHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaNotifications.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.notifications
             * @ngdoc controller
             * @name $mmaNotificationsHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-ios-bell';
                $scope.title = 'mma.notifications.notifications';
                $scope.state = 'site.notifications';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Service to handle notifications (messages).
 *
 * @module mm.addons.notifications
 * @ngdoc service
 * @name $mmaNotifications
 */
.factory('$mmaNotifications', ["$q", "$log", "$mmSite", "$mmSitesManager", "mmaNotificationsListLimit", function($q, $log, $mmSite, $mmSitesManager, mmaNotificationsListLimit) {

    $log = $log.getInstance('$mmaNotifications');

    var self = {};

    // Function to format notification data.
    function formatNotificationsData(notifications) {
        angular.forEach(notifications, function(notification) {
            // Set message to show.
            if (notification.contexturl && notification.contexturl.indexOf('/mod/forum/')) {
                notification.mobiletext = notification.smallmessage;
            } else {
                notification.mobiletext = notification.fullmessage;
            }

            // Try to set courseid the notification belongs to.
            var cid = notification.fullmessagehtml.match(/course\/view\.php\?id=([^"]*)/);
            if (cid && cid[1]) {
                notification.courseid = cid[1];
            }
        });
    }

    /**
     * Get cache key for notification list WS calls.
     *
     * @return {String} Cache key.
     */
    function getNotificationsCacheKey() {
        return 'mmaNotifications:list';
    };

    /**
     * Get notifications from site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#getNotifications
     * @param {Boolean} read       True if should get read notifications, false otherwise.
     * @param {Number} limitFrom   Position of the first notification to get.
     * @param {Number} limitNumber Number of notifications to get.
     * @return {Promise}           Promise resolved with notifications.
     */
    self.getNotifications = function(read, limitFrom, limitNumber) {
        limitFrom = limitFrom || 0;
        limitNumber = limitNumber || mmaNotificationsListLimit;

        $log.debug('Get ' + (read ? 'read' : 'unread') + ' notifications from ' + limitFrom + '. Limit: ' + limitNumber);

        var data = {
            useridto: $mmSite.getUserId(),
            useridfrom: 0,
            type: 'notifications',
            read: read ? 1 : 0,
            newestfirst: 1,
            limitfrom: limitFrom,
            limitnum: limitNumber
        };
        var preSets = {
            cacheKey: getNotificationsCacheKey()
        };

        // Get unread notifications.
        return $mmSite.read('core_message_get_messages', data, preSets).then(function(response) {
            if (response.messages) {
                var notifications = response.messages;
                formatNotificationsData(notifications);
                return notifications;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Get read notifications from site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#getReadNotifications
     * @param {Number} limitFrom   Position of the first notification to get.
     * @param {Number} limitNumber Number of notifications to get.
     * @return {Promise}           Promise resolved with notifications.
     */
    self.getReadNotifications = function(limitFrom, limitNumber) {
        return self.getNotifications(true, limitFrom, limitNumber);
    };

    /**
     * Get unread notifications from site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#getUnreadNotifications
     * @param {Number} limitFrom   Position of the first notification to get.
     * @param {Number} limitNumber Number of notifications to get.
     * @return {Promise}           Promise resolved with notifications.
     */
    self.getUnreadNotifications = function(limitFrom, limitNumber) {
        return self.getNotifications(false, limitFrom, limitNumber);
    };

    /**
     * Invalidates notifications list WS calls.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#invalidateNotificationsList
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateNotificationsList = function() {
        return $mmSite.invalidateWsCacheForKey(getNotificationsCacheKey());
    };

    /**
     * Check if plugin is available.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#isPluginEnabled
     * @return {Boolean} True if plugin is available, false otherwise.
     */
    self.isPluginEnabled = function() {
        return $mmSite.wsAvailable('core_message_get_messages');
    };

    /**
     * Check if plugin is available for a certain site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#isPluginEnabledForSite
     * @param {String} siteid Site ID.
     * @return {Promise}      Resolved when enabled, otherwise rejected.
     */
    self.isPluginEnabledForSite = function(siteid) {
        return $mmSitesManager.getSite(siteid).then(function(site) {
            if (!site.wsAvailable('core_message_get_messages')) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants')

/**
 * Controller to handle course participants.
 *
 * @module mm.addons.participants
 * @ngdoc controller
 * @name mmaParticipantsListCtrl
 */
.controller('mmaParticipantsListCtrl', ["$scope", "$state", "$stateParams", "$mmUtil", "$mmaParticipants", "$ionicPlatform", "$mmSite", "mmUserProfileState", function($scope, $state, $stateParams, $mmUtil, $mmaParticipants, $ionicPlatform, $mmSite,
            mmUserProfileState) {
    var course = $stateParams.course,
        courseid = course.id;

    $scope.participants = [];
    $scope.courseid = courseid;
    $scope.userStateName = mmUserProfileState;

    function fetchParticipants(refresh) {
        var firstToGet = refresh ? 0 : $scope.participants.length;
        return $mmaParticipants.getParticipants(courseid, firstToGet).then(function(data) {
            if (refresh) {
                $scope.participants = data.participants;
            } else {
                $scope.participants = $scope.participants.concat(data.participants);
            }
            $scope.canLoadMore = data.canLoadMore;
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
        });
    }

    // Get first participants.
    fetchParticipants(true).then(function() {
        // Add log in Moodle.
        $mmSite.write('core_user_view_user_list', {
            courseid: courseid
        });
    }).finally(function() {
        $scope.participantsLoaded = true;
    });

    // Load more participants.
    $scope.loadMoreParticipants = function(){
        fetchParticipants().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };

    $scope.refreshParticipants = function() {
        $mmaParticipants.invalidateParticipantsList(courseid).finally(function() {
            fetchParticipants(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants')

/**
 * Participants handlers.
 *
 * @module mm.addons.participants
 * @ngdoc service
 * @name $mmaParticipantsHandlers
 */
.factory('$mmaParticipantsHandlers', ["$mmaParticipants", "mmCoursesAccessMethods", "$mmUtil", "$mmContentLinksHelper", function($mmaParticipants, mmCoursesAccessMethods, $mmUtil, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course nav handler.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipantsHandlers#coursesNavHandler
     */
    self.coursesNavHandler = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean|Promise}  Promise resolved  with true if handler is enabled,
         *                            false or promise rejected or resolved with false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return $mmaParticipants.isPluginEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(courseId) {
            return function($scope, $state) {
                $scope.icon = 'ion-person-stalker';
                $scope.title = 'mma.participants.participants';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.participants', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipantsHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        List of actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a user URL.
            if (url.indexOf('grade/report/user') == -1 && url.indexOf('/user/index.php') > -1) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: siteIds,
                        action: function(siteId) {
                            var stateParams = {
                                course: {id: parseInt(params.id, 10)}
                            };
                            $mmContentLinksHelper.goInSite('site.participants', stateParams, siteId);
                        }
                    }];
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants')

/**
 * Service to handle course participants.
 *
 * @module mm.addons.participants
 * @ngdoc service
 * @name $mmaParticipants
 */
.factory('$mmaParticipants', ["$log", "$mmSite", "$mmUser", "mmaParticipantsListLimit", function($log, $mmSite, $mmUser, mmaParticipantsListLimit) {

    $log = $log.getInstance('$mmaParticipants');

    var self = {};

    /**
     * Get cache key for participant list WS calls.
     *
     * @param  {Number} courseid Course ID.
     * @return {String}          Cache key.
     */
    function getParticipantsListCacheKey(courseid) {
        return 'mmaParticipants:list:'+courseid;
    }

    /**
     * Get participants for a certain course.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipants#getParticipants
     * @param {String} courseid    ID of the course.
     * @param {Number} limitFrom   Position of the first participant to get.
     * @param {Number} limitNumber Number of participants to get.
     * @return {Promise}           Promise to be resolved when the participants are retrieved.
     */
    self.getParticipants = function(courseid, limitFrom, limitNumber) {

        if (typeof limitFrom == 'undefined') {
            limitFrom = 0;
        }
        if (typeof limitNumber == 'undefined') {
            limitNumber = mmaParticipantsListLimit;
        }

        $log.debug('Get participants for course ' + courseid + ' starting at ' + limitFrom);

        var wsName,
            data = {
                courseid: courseid
            }, preSets = {
                cacheKey: getParticipantsListCacheKey(courseid)
            };

        if ($mmSite.wsAvailable('core_enrol_get_enrolled_users')) {
            wsName = 'core_enrol_get_enrolled_users';
            data.options = [
                {
                    name: 'limitfrom',
                    value: limitFrom
                },
                {
                    name: 'limitnumber',
                    value: limitNumber
                },
                {
                    name: 'sortby',
                    value: 'siteorder'
                }
            ];
        } else {
            wsName = 'moodle_enrol_get_enrolled_users';
            limitNumber = 9999999999; // Set a big limitNumber so canLoadMore is always false (WS not paginated).
        }

        return $mmSite.read(wsName, data, preSets).then(function(users) {
            // Format user data, moodle_enrol_get_enrolled_users returns some attributes with a different name.
            angular.forEach(users, function(user) {
                if (typeof user.id == 'undefined' && typeof user.userid != 'undefined') {
                    user.id = user.userid;
                }
                if (typeof user.profileimageurl == 'undefined' && typeof user.profileimgurl != 'undefined') {
                    user.profileimageurl = user.profileimgurl;
                }
            });

            var canLoadMore = users.length >= limitNumber;
            $mmUser.storeUsers(users);
            return {participants: users, canLoadMore: canLoadMore};
        });
    };

    /**
     * Invalidates participant list for a certain course.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipants#invalidateParticipantsList
     * @param  {Number} courseid Course ID.
     * @return {Promise}         Promise resolved when the list is invalidated.
     */
    self.invalidateParticipantsList = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getParticipantsListCacheKey(courseid));
    };

    /**
     * Returns whether or not the participants addon is enabled for a certain course.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipants#isPluginEnabledForCourse
     * @param {Number} courseId Course ID.
     * @return {Promise}        Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabledForCourse = function(courseId) {
        if (!courseId) {
            return $q.reject();
        }

        // Retrieving one participant will fail if browsing users is disabled by capabilities.
        return self.getParticipants(courseId, 0, 1).then(function(parcitipants) {
            return true;
        }).catch(function(error) {
            return false;
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.pushnotifications')

/**
 * Service to handle push notifications clicks.
 *
 * @module mm.addons.pushnotifications
 * @ngdoc service
 * @name $mmPushNotificationsDelegate
 */
.factory('$mmPushNotificationsDelegate', ["$log", function($log) {

    $log = $log.getInstance('$mmPushNotificationsDelegate');

    var handlers = {},
        self = {};

    /**
     * Function called when a push notification is clicked. Sends notification to handlers.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmPushNotificationsDelegate#clicked
     * @param {Object} notification Notification clicked.
     * @return {Void}
     */
    self.clicked = function(notification) {
        for (var name in handlers) {
            var callback = handlers[name];
            if (typeof callback == 'function') {
                var treated = callback(notification);
                if (treated) {
                    return; // Stop execution when notification is treated.
                }
            }
        }
    };

    /**
     * Register a push notifications handler. The handler will receive a notification to treat.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmPushNotificationsDelegate#registerHandler
     * @param {String} name       Handler's name.
     * @param {Function} callback The callback function. Will get as parameter the URL to handle.
     * @description
     * The handler should return true if the notification is the one expected, false otherwise.
     * @see {@link $mmPushNotificationsDelegate#clicked}
     */
    self.registerHandler = function(name, callback) {
        $log.debug("Registered handler '" + name + "' as push notification handler.");
        handlers[name] = callback;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.pushnotifications')

/**
 * Push notifications factory.
 *
 * @module mm.addons.pushnotifications
 * @ngdoc service
 * @name $mmaPushNotifications
 */
.factory('$mmaPushNotifications', ["$mmSite", "$log", "$cordovaPush", "$mmText", "$q", "$cordovaDevice", "$mmUtil", "mmCoreConfigConstants", "$mmApp", "$mmLocalNotifications", "$mmPushNotificationsDelegate", "$mmSitesManager", "mmaPushNotificationsComponent", function($mmSite, $log, $cordovaPush, $mmText, $q, $cordovaDevice, $mmUtil, mmCoreConfigConstants,
            $mmApp, $mmLocalNotifications, $mmPushNotificationsDelegate, $mmSitesManager, mmaPushNotificationsComponent) {
    $log = $log.getInstance('$mmaPushNotifications');

    var self = {},
        pushID;

    /**
     * Returns whether or not the plugin is enabled for the current site.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#isPluginEnabled
     * @return {Boolean} True if enabled, false otherwise.
     */
    self.isPluginEnabled = function() {
        return $mmSite.wsAvailable('core_user_add_user_device')
                && $mmSite.wsAvailable('message_airnotifier_is_system_configured')
                && $mmSite.wsAvailable('message_airnotifier_are_notification_preferences_configured');
    };

    /**
     * Function called when a push notification is clicked. Redirect the user to the right state.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#notificationClicked
     * @param {Object} data Notification data.
     */
    self.notificationClicked = function(data) {
        $mmApp.ready().then(function() {
            $mmPushNotificationsDelegate.clicked(data);
        });
    };

    /**
     * This function is called from the PushPlugin when we receive a Notification from GCM.
     * The app can be in foreground or background,
     * if we are in background this code is executed when we open the app clicking in the notification bar.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#onGCMReceived
     * @param {Object} notification Notification data.
     */
    self.onGCMReceived = function(notification) {
        $log.debug('GCM notification received. Type: '+notification.event);

        switch (notification.event) {
            case 'registered':
                if (notification.regid.length > 0) {
                    pushID = notification.regid;
                    return self.registerDeviceOnMoodle();
                } else {
                    $log.debug('Device NOT registered in GCM, invalid regid');
                    break;
                }

            case 'message':
                notification.payload.foreground = notification.foreground;
                return self.onMessageReceived(notification.payload);

            case 'error':
                $log.debug('Push messages error');
                break;

            default:
                $log.debug('Push unknown message');
        }
    };

    /**
     * This function is called when we receive a Notification from APNS or a message notification from GCM.
     * The app can be in foreground or background,
     * if we are in background this code is executed when we open the app clicking in the notification bar.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#onMessageReceived
     * @param {Object} data Notification data.
     */
    self.onMessageReceived = function(data) {
        var promise;

        if (data && data.site) {
            promise = $mmSitesManager.getSite(data.site); // Check if site exists.
        } else {
            promise = $q.when(); // No site specified, resolve.
        }

        promise.then(function() {
            if ($mmUtil.isTrueOrOne(data.foreground)) {
                // If the app is in foreground when the notification is received, it's not shown. Let's show it ourselves.
                if ($mmLocalNotifications.isAvailable()) {
                    // Apply formatText to title and message.
                    $mmText.formatText(data.title, true, true).then(function(formattedTitle) {
                        $mmText.formatText(data.message, true, true).then(function(formattedMessage) {
                            var localNotif = {
                                id: 1,
                                title: formattedTitle,
                                message: formattedMessage,
                                at: new Date(),
                                smallIcon: 'res://icon',
                                data: {
                                    notif: data.notif,
                                    site: data.site
                                }
                            };
                            $mmLocalNotifications.schedule(localNotif, mmaPushNotificationsComponent, data.site);
                        });
                    });
                }
            } else {
                self.notificationClicked(data);
            }
        });
    };

    /**
     * Register a device in Apple APNS or Google GCM.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#registerDevice
     * @return {Promise} Promise resolved when the device is registered.
     */
    self.registerDevice = function() {
        try {
            if (ionic.Platform.isIOS()) {
                return self._registerDeviceAPNS();
            } else if (ionic.Platform.isAndroid()) {
                return self._registerDeviceGCM();
            }
        } catch(ex) {}

        return $q.reject();
    };

    /**
     * Register a device in Apple APNS (Apple Push Notificaiton System) using the Phonegap PushPlugin.
     * It also registers the device in the Moodle site using the core_user_add_user_device WebService.
     * We need the device registered in Moodle so we can connect the device with the message output Moode plugin airnotifier.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#_registerDeviceAPNS
     * @return {Promise} Promise resolved when the device is registered.
     * @protected
     */
    self._registerDeviceAPNS = function() {
        var options = {
            alert: 'true',
            badge: 'true',
            sound: 'true'
        };
        return $cordovaPush.register(options).then(function(token) {
            pushID = token;
            return self.registerDeviceOnMoodle();
        }, function(error) {
            return $q.reject();
        });
    };

    /**
     * Register a device in Google GCM using the Phonegap PushPlugin.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#_registerDeviceGCM
     * @return {Promise} Promise resolved when the device is registered.
     * @protected
     */
    self._registerDeviceGCM = function() {
        if (mmCoreConfigConstants.gcmpn) {
            return $cordovaPush.register({
                senderID: mmCoreConfigConstants.gcmpn
            });
        }
        return $q.reject();
    };

    /**
     * Registers a device on current Moodle site.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#registerDeviceOnMoodle
     * @return {Promise}      Promise resolved when device is registered.
     */
    self.registerDeviceOnMoodle = function() {
        $log.debug('Register device on Moodle.');

        if (!$mmSite.isLoggedIn() || !pushID || !$mmApp.isDevice()) {
            return $q.reject();
        }

        var data = {
            appid:      mmCoreConfigConstants.app_id,
            name:       ionic.Platform.device().name || '',
            model:      $cordovaDevice.getModel(),
            platform:   $cordovaDevice.getPlatform(),
            version:    $cordovaDevice.getVersion(),
            pushid:     pushID,
            uuid:       $cordovaDevice.getUUID()
        };
        return $mmSite.write('core_user_add_user_device', data);
    };

    /**
     * Unregisters a device from a certain Moodle site.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#unregisterDeviceOnMoodle
     * @param {Object} site Site to unregister from.
     * @return {Promise}    Promise resolved when device is unregistered.
     */
    self.unregisterDeviceOnMoodle = function(site) {

        if (!site || !$mmApp.isDevice()) {
            return $q.reject();
        }

        $log.debug('Unregister device on Moodle: ' + site.id);

        var data = {
            appid: mmCoreConfigConstants.app_id,
            uuid:  $cordovaDevice.getUUID()
        };
        return site.write('core_user_remove_user_device', data).then(function(response) {
            if (!response || !response.removed) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.remotestyles')

/**
 * Service to handle remote styles.
 *
 * @module mm.addons.remotestyles
 * @ngdoc service
 * @name $mmaRemoteStyles
 */
.factory('$mmaRemoteStyles', ["$log", "$q", "$mmSite", "$mmSitesManager", "$mmFilepool", "$http", "$mmFS", "mmaRemoteStylesComponent", "mmCoreNotDownloaded", function($log, $q, $mmSite, $mmSitesManager, $mmFilepool, $http, $mmFS, mmaRemoteStylesComponent,
            mmCoreNotDownloaded) {

    $log = $log.getInstance('$mmaRemoteStyles');

    var self = {},
        remoteStylesEl = angular.element(document.querySelector('#mobilecssurl'));

    /**
     * Clear remote styles added to the DOM.
     *
     * @module mm.addons.remotestyles
     * @ngdoc method
     * @name $mmaRemoteStyles#clear
     */
    self.clear = function() {
        remoteStylesEl.html('');
    };

    /**
     * Get remote styles of a certain site.
     *
     * @module mm.addons.remotestyles
     * @ngdoc method
     * @name $mmaRemoteStyles#get
     * @param {String} siteid Site ID.
     * @return {Promise}      Promise resolved with the styles.
     */
    self.get = function(siteid) {
        var promise;

        siteid = siteid || $mmSite.getId();
        if (!siteid) {
            return $q.reject();
        }

        // Downloads a CSS file and remove old files if needed.
        function downloadFileAndRemoveOld(url) {
            return $mmFilepool.getFileStateByUrl(siteid, url).then(function(state) {
                return state !== mmCoreNotDownloaded;
            }).catch(function() {
                return true; // An error occurred while getting state (shouldn't happen). Don't delete downloaded file.
            }).then(function(isDownloaded) {
                if (!isDownloaded) {
                    // File not downloaded, URL has changed or first time. Delete downloaded CSS files.
                    return $mmFilepool.removeFilesByComponent(siteid, mmaRemoteStylesComponent, 1);
                }
            }).then(function() {
                return $mmFilepool.downloadUrl(siteid, url, false, mmaRemoteStylesComponent, 1);
            });
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var infos = site.getInfo();
            if (infos && infos.mobilecssurl) {
                if ($mmFS.isAvailable()) {
                    // The file system is available. Download the file and remove old CSS files if needed.
                    return downloadFileAndRemoveOld(infos.mobilecssurl);
                } else {
                    // We return the online URL. We're probably on browser.
                    return infos.mobilecssurl;
                }
            } else {
                if (infos.mobilecssurl === '') {
                    // CSS URL is empty. Delete downloaded files (if any).
                    $mmFilepool.removeFilesByComponent(siteid, mmaRemoteStylesComponent, 1)
                }
                return $q.reject();
            }
        }).then(function(url) {
            $log.debug('Loading styles from: '+url);
            return $http.get(url);
        }).then(function(response) {
            if (typeof response.data == 'string') {
                return response.data;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Load styles for current site.
     *
     * @module mm.addons.remotestyles
     * @ngdoc method
     * @name $mmaRemoteStyles#load
     */
    self.load = function() {
        var siteid = $mmSite.getId();
        if (siteid) {
            self.get(siteid).then(function(styles) {
                if (siteid === $mmSite.getId()) { // Make sure it hasn't logout while retrieving styles.
                    remoteStylesEl.html(styles);
                }
            });
        }
    };

    return self;
}]);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5qcyIsIm1haW4uanMiLCJhZGRvbm1hbmFnZXIuanMiLCJhbmd1bGFyLWlvczktdWl3ZWJ2aWV3LnBhdGNoLmpzIiwiY29uZmlnLmpzIiwiZGIuanMiLCJlbXVsYXRvci5qcyIsImV2ZW50cy5qcyIsImZpbGVwb29sLmpzIiwiZnMuanMiLCJncm91cHMuanMiLCJpbml0LmpzIiwiaW9uaWMtaW9zOS1yYWRpby1maXguanMiLCJsYW5nLmpzIiwibG9jYWxub3RpZi5qcyIsImxvZy5qcyIsInNpdGUuanMiLCJzaXRlc2ZhY3RvcnkuanMiLCJzaXRlc21hbmFnZXIuanMiLCJ0ZXh0LmpzIiwidXBkYXRlbWFuYWdlci5qcyIsInVybGRlbGVnYXRlLmpzIiwidXRpbC5qcyIsIndzLmpzIiwiYnl0ZXN0b3NpemUuanMiLCJjcmVhdGVsaW5rcy5qcyIsImRhdGVfZGF5X29yX3RpbWUuanMiLCJmb3JtYXRkYXRlLmpzIiwibm90YWdzLmpzIiwidGltZWFnby5qcyIsInRvbG9jYWxlc3RyaW5nLmpzIiwiYXV0b2ZvY3VzLmpzIiwiYnJvd3Nlci5qcyIsImNvbXBsZXRpb24uanMiLCJleHRlcm5hbF9jb250ZW50LmpzIiwiZmlsZS5qcyIsImZvcm1hdHRleHQuanMiLCJpZnJhbWUuanMiLCJpbWFnZXZpZXdlci5qcyIsImxvYWRpbmcuanMiLCJuYXZpZ2F0aW9uYmFyLmpzIiwibm9pbnB1dHZhbGlkYXRpb24uanMiLCJzcGxpdHZpZXcuanMiLCJzcGxpdHZpZXdsaW5rLmpzIiwiY29udGVudGxpbmtzL21haW4uanMiLCJjb3Vyc2UvbWFpbi5qcyIsImNvdXJzZXMvbWFpbi5qcyIsImxvZ2luL21haW4uanMiLCJzZXR0aW5ncy9tYWluLmpzIiwic2lkZW1lbnUvbWFpbi5qcyIsInRleHR2aWV3ZXIvbWFpbi5qcyIsInVzZXIvbWFpbi5qcyIsImNvbnRlbnRsaW5rcy9jb250cm9sbGVycy9jaG9vc2VzaXRlLmpzIiwiY29udGVudGxpbmtzL3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwiY29udGVudGxpbmtzL3NlcnZpY2VzL2hlbHBlci5qcyIsImNvdXJzZXMvY29udHJvbGxlcnMvbGlzdC5qcyIsImNvdXJzZXMvY29udHJvbGxlcnMvc2VhcmNoLmpzIiwiY291cnNlcy9jb250cm9sbGVycy92aWV3cmVzdWx0LmpzIiwiY291cnNlcy9zZXJ2aWNlcy9jb3Vyc2VzLmpzIiwiY291cnNlcy9zZXJ2aWNlcy9kZWxlZ2F0ZS5qcyIsImNvdXJzZXMvc2VydmljZXMvaGFuZGxlcnMuanMiLCJsb2dpbi9jb250cm9sbGVycy9jcmVkZW50aWFscy5qcyIsImxvZ2luL2NvbnRyb2xsZXJzL2luaXQuanMiLCJsb2dpbi9jb250cm9sbGVycy9yZWNvbm5lY3QuanMiLCJsb2dpbi9jb250cm9sbGVycy9zaXRlLmpzIiwibG9naW4vY29udHJvbGxlcnMvc2l0ZXMuanMiLCJsb2dpbi9zZXJ2aWNlcy9oZWxwZXIuanMiLCJzZXR0aW5ncy9jb250cm9sbGVycy9hYm91dC5qcyIsInNldHRpbmdzL2NvbnRyb2xsZXJzL2dlbmVyYWwuanMiLCJzZXR0aW5ncy9jb250cm9sbGVycy9zcGFjZS11c2FnZS5qcyIsInNldHRpbmdzL2NvbnRyb2xsZXJzL3N5bmNocm9uaXphdGlvbi5qcyIsInNpZGVtZW51L2NvbnRyb2xsZXJzL21lbnUuanMiLCJzaWRlbWVudS9zZXJ2aWNlcy9kZWxlZ2F0ZS5qcyIsInRleHR2aWV3ZXIvY29udHJvbGxlcnMvaW5kZXguanMiLCJ1c2VyL2NvbnRyb2xsZXJzL3Byb2ZpbGUuanMiLCJ1c2VyL2RpcmVjdGl2ZXMvdXNlcmxpbmsuanMiLCJ1c2VyL3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwidXNlci9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsInVzZXIvc2VydmljZXMvdXNlci5qcyIsImNvdXJzZS9jb250cm9sbGVycy9tb2Rjb250ZW50LmpzIiwiY291cnNlL2NvbnRyb2xsZXJzL3NlY3Rpb24uanMiLCJjb3Vyc2UvY29udHJvbGxlcnMvc2VjdGlvbnMuanMiLCJjb3Vyc2UvZGlyZWN0aXZlcy9tb2RfZGVzY3JpcHRpb24uanMiLCJjb3Vyc2Uvc2VydmljZXMvY29udGVudF9oYW5kbGVyLmpzIiwiY291cnNlL3NlcnZpY2VzL2NvdXJzZS5qcyIsImNvdXJzZS9zZXJ2aWNlcy9jb3Vyc2VzX25hdl9oYW5kbGVyLmpzIiwiY291cnNlL3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwiY291cnNlL3NlcnZpY2VzL2hlbHBlci5qcyIsImNvdXJzZS9zZXJ2aWNlcy9wcmVmZXRjaGRlbGVnYXRlLmpzIiwiY2FsZW5kYXIvbWFpbi5qcyIsImNvdXJzZWNvbXBsZXRpb24vbWFpbi5qcyIsImZpbGVzL21haW4uanMiLCJmcm9udHBhZ2UvbWFpbi5qcyIsImdyYWRlcy9tYWluLmpzIiwibWVzc2FnZXMvbWFpbi5qcyIsIm1vZF9hc3NpZ24vbWFpbi5qcyIsIm1vZF9ib29rL21haW4uanMiLCJtb2RfY2hhdC9tYWluLmpzIiwibW9kX2Nob2ljZS9tYWluLmpzIiwibW9kX2ZvbGRlci9tYWluLmpzIiwibW9kX2ZvcnVtL21haW4uanMiLCJtb2RfZ2xvc3NhcnkvbWFpbi5qcyIsIm1vZF9pbXNjcC9tYWluLmpzIiwibW9kX2xhYmVsL21haW4uanMiLCJtb2RfbHRpL21haW4uanMiLCJtb2RfcGFnZS9tYWluLmpzIiwibW9kX3Jlc291cmNlL21haW4uanMiLCJtb2Rfc2Nvcm0vbWFpbi5qcyIsIm1vZF9zdXJ2ZXkvbWFpbi5qcyIsIm1vZF91cmwvbWFpbi5qcyIsIm5vdGVzL21haW4uanMiLCJub3RpZmljYXRpb25zL21haW4uanMiLCJwYXJ0aWNpcGFudHMvbWFpbi5qcyIsInB1c2hub3RpZmljYXRpb25zL21haW4uanMiLCJyZW1vdGVzdHlsZXMvbWFpbi5qcyIsImNhbGVuZGFyL2NvbnRyb2xsZXJzL2V2ZW50LmpzIiwiY2FsZW5kYXIvY29udHJvbGxlcnMvbGlzdC5qcyIsImNhbGVuZGFyL3NlcnZpY2VzL2NhbGVuZGFyLmpzIiwiY2FsZW5kYXIvc2VydmljZXMvaGFuZGxlcnMuanMiLCJjb3Vyc2Vjb21wbGV0aW9uL2NvbnRyb2xsZXJzL3JlcG9ydC5qcyIsImNvdXJzZWNvbXBsZXRpb24vc2VydmljZXMvY291cnNlY29tcGxldGlvbi5qcyIsImNvdXJzZWNvbXBsZXRpb24vc2VydmljZXMvaGFuZGxlcnMuanMiLCJmaWxlcy9jb250cm9sbGVycy9jaG9vc2VzaXRlLmpzIiwiZmlsZXMvY29udHJvbGxlcnMvaW5kZXguanMiLCJmaWxlcy9jb250cm9sbGVycy9saXN0LmpzIiwiZmlsZXMvY29udHJvbGxlcnMvdXBsb2FkLmpzIiwiZmlsZXMvZGlyZWN0aXZlcy9vbmNoYW5nZS5qcyIsImZpbGVzL3NlcnZpY2VzL2ZpbGVzLmpzIiwiZmlsZXMvc2VydmljZXMvaGFuZGxlcnMuanMiLCJmaWxlcy9zZXJ2aWNlcy9oZWxwZXIuanMiLCJmcm9udHBhZ2Uvc2VydmljZXMvZnJvbnRwYWdlLmpzIiwiZnJvbnRwYWdlL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwiZ3JhZGVzL2NvbnRyb2xsZXJzL3RhYmxlLmpzIiwiZ3JhZGVzL3NlcnZpY2VzL2dyYWRlcy5qcyIsImdyYWRlcy9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1lc3NhZ2VzL2NvbnRyb2xsZXJzL2NvbnRhY3RzLmpzIiwibWVzc2FnZXMvY29udHJvbGxlcnMvZGlzY3Vzc2lvbi5qcyIsIm1lc3NhZ2VzL2NvbnRyb2xsZXJzL2Rpc2N1c3Npb25zLmpzIiwibWVzc2FnZXMvY29udHJvbGxlcnMvaW5kZXguanMiLCJtZXNzYWdlcy9maWx0ZXJzL2Zvcm1hdC5qcyIsIm1lc3NhZ2VzL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibWVzc2FnZXMvc2VydmljZXMvbWVzc2FnZXMuanMiLCJtb2RfYXNzaWduL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX2Fzc2lnbi9jb250cm9sbGVycy9zdWJtaXNzaW9uLmpzIiwibW9kX2Fzc2lnbi9zZXJ2aWNlcy9hc3NpZ24uanMiLCJtb2RfYXNzaWduL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX2Jvb2svY29udHJvbGxlcnMvaW5kZXguanMiLCJtb2RfYm9vay9kaXJlY3RpdmVzL2Fycm93cy5qcyIsIm1vZF9ib29rL3NlcnZpY2VzL2Jvb2suanMiLCJtb2RfYm9vay9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9ib29rL3NlcnZpY2VzL3ByZWZldGNoX2hhbmRsZXIuanMiLCJtb2RfY2hhdC9jb250cm9sbGVycy9jaGF0LmpzIiwibW9kX2NoYXQvY29udHJvbGxlcnMvaW5kZXguanMiLCJtb2RfY2hhdC9zZXJ2aWNlcy9jaGF0LmpzIiwibW9kX2NoYXQvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfY2hvaWNlL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX2Nob2ljZS9zZXJ2aWNlcy9jaG9pY2UuanMiLCJtb2RfY2hvaWNlL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX2ZvbGRlci9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9mb2xkZXIvc2VydmljZXMvZm9sZGVyLmpzIiwibW9kX2ZvbGRlci9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9mb2xkZXIvc2VydmljZXMvcHJlZmV0Y2hfaGFuZGxlci5qcyIsIm1vZF9mb3J1bS9jb250cm9sbGVycy9kaXNjdXNzaW9uLmpzIiwibW9kX2ZvcnVtL2NvbnRyb2xsZXJzL2Rpc2N1c3Npb25zLmpzIiwibW9kX2ZvcnVtL2NvbnRyb2xsZXJzL25ld2Rpc2N1c3Npb24uanMiLCJtb2RfZm9ydW0vZGlyZWN0aXZlcy9kaXNjdXNzaW9ucG9zdC5qcyIsIm1vZF9mb3J1bS9zZXJ2aWNlcy9mb3J1bS5qcyIsIm1vZF9mb3J1bS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9nbG9zc2FyeS9jb250cm9sbGVycy9lbnRyeS5qcyIsIm1vZF9nbG9zc2FyeS9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9nbG9zc2FyeS9zZXJ2aWNlcy9nbG9zc2FyeS5qcyIsIm1vZF9nbG9zc2FyeS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9pbXNjcC9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9pbXNjcC9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9pbXNjcC9zZXJ2aWNlcy9pbXNjcC5qcyIsIm1vZF9pbXNjcC9zZXJ2aWNlcy9wcmVmZXRjaF9oYW5kbGVyLmpzIiwibW9kX2xhYmVsL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX2xhYmVsL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX2x0aS9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9sdGkvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfbHRpL3NlcnZpY2VzL2x0aS5qcyIsIm1vZF9wYWdlL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX3BhZ2Uvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfcGFnZS9zZXJ2aWNlcy9wYWdlLmpzIiwibW9kX3BhZ2Uvc2VydmljZXMvcHJlZmV0Y2hfaGFuZGxlci5qcyIsIm1vZF9yZXNvdXJjZS9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9yZXNvdXJjZS9kaXJlY3RpdmVzL2h0bWxfbGluay5qcyIsIm1vZF9yZXNvdXJjZS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9yZXNvdXJjZS9zZXJ2aWNlcy9wcmVmZXRjaF9oYW5kbGVyLmpzIiwibW9kX3Jlc291cmNlL3NlcnZpY2VzL3Jlc291cmNlLmpzIiwibW9kX3Njb3JtL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX3Njb3JtL2NvbnRyb2xsZXJzL3BsYXllci5qcyIsIm1vZF9zY29ybS9zZXJ2aWNlcy9kYXRhX21vZGVsXzEyLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL2hlbHBlci5qcyIsIm1vZF9zY29ybS9zZXJ2aWNlcy9wcmVmZXRjaF9oYW5kbGVyLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL3Njb3JtLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL3Njb3JtX29mZmxpbmUuanMiLCJtb2Rfc2Nvcm0vc2VydmljZXMvc2Nvcm1fb25saW5lLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL3Njb3JtX3N5bmMuanMiLCJtb2Rfc3VydmV5L2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX3N1cnZleS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9zdXJ2ZXkvc2VydmljZXMvc3VydmV5LmpzIiwibW9kX3VybC9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF91cmwvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfdXJsL3NlcnZpY2VzL3VybC5qcyIsIm5vdGVzL2NvbnRyb2xsZXJzL2xpc3QuanMiLCJub3Rlcy9jb250cm9sbGVycy90eXBlcy5qcyIsIm5vdGVzL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibm90ZXMvc2VydmljZXMvbm90ZXMuanMiLCJub3RpZmljYXRpb25zL2NvbnRyb2xsZXJzL2xpc3QuanMiLCJub3RpZmljYXRpb25zL2RpcmVjdGl2ZXMvYWN0aW9ucy5qcyIsIm5vdGlmaWNhdGlvbnMvZmlsdGVycy9mb3JtYXQuanMiLCJub3RpZmljYXRpb25zL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibm90aWZpY2F0aW9ucy9zZXJ2aWNlcy9ub3RpZmljYXRpb25zLmpzIiwicGFydGljaXBhbnRzL2NvbnRyb2xsZXJzL2xpc3QuanMiLCJwYXJ0aWNpcGFudHMvc2VydmljZXMvaGFuZGxlcnMuanMiLCJwYXJ0aWNpcGFudHMvc2VydmljZXMvcGFydGljaXBhbnRzLmpzIiwicHVzaG5vdGlmaWNhdGlvbnMvc2VydmljZXMvZGVsZWdhdGUuanMiLCJwdXNobm90aWZpY2F0aW9ucy9zZXJ2aWNlcy9wdXNobm90aWZpY2F0aW9ucy5qcyIsInJlbW90ZXN0eWxlcy9zZXJ2aWNlcy9yZW1vdGVzdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsUUFBUSxPQUFPLE1BQU0sQ0FBQyxTQUFTLGFBQWEsZUFBZSwwQkFBMEIsVUFBVSx3QkFBd0I7O0NBRXRILHVCQUFJLFNBQVMs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

angular.module('mm.core')

.constant('mmCoreConfigConstants', {
    "app_id" : "uk.ac.bbk.moodle",
    "versioncode" : "2009",
    "versionname" : "0.0.1",
    "cache_expiration_time" : 300000,
    "default_lang" : "en",
    "languages": {"ar": "عربي", "bg": "Български", "ca": "Català", "cs": "Čeština", "de": "Deutsch","en": "English", "es": "Español", "es-mx": "Español - México", "eu": "Euskara", "fa": "فارسی", "fr" : "Français", "he" : "עברית", "hu": "magyar", "it": "Italiano", "ja": "日本語","nl": "Nederlands", "pl": "Polski", "pt-br": "Português - Brasil", "ru": "Русский", "sv": "Svenska", "tr" : "Türkçe", "zh-cn" : "简体中文", "zh-tw" : "正體中文"},
    "wsservice" : "moodle_mobile_app",
    "wsextservice" : "local_mobile",
    "gcmpn": "694767596569"
}
);