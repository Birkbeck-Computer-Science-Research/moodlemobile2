// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Dependencies will be automatically added here, the following line must declare ionic as first dependency
// and should not be split into multiple lines, see gulpfile.js.
angular.module('mm', ['ionic', 'mm.core', 'mm.core.contentlinks', 'mm.core.course', 'mm.core.courses', 'mm.core.login', 'mm.core.settings', 'mm.core.sidemenu', 'mm.core.textviewer', 'mm.core.user', 'mm.addons.calendar', 'mm.addons.coursecompletion', 'mm.addons.files', 'mm.addons.frontpage', 'mm.addons.grades', 'mm.addons.messages', 'mm.addons.mod_assign', 'mm.addons.mod_book', 'mm.addons.mod_chat', 'mm.addons.mod_choice', 'mm.addons.mod_folder', 'mm.addons.mod_forum', 'mm.addons.mod_glossary', 'mm.addons.mod_imscp', 'mm.addons.mod_label', 'mm.addons.mod_lti', 'mm.addons.mod_page', 'mm.addons.mod_resource', 'mm.addons.mod_scorm', 'mm.addons.mod_survey', 'mm.addons.mod_url', 'mm.addons.notes', 'mm.addons.notifications', 'mm.addons.participants', 'mm.addons.pushnotifications', 'mm.addons.remotestyles', 'ngCordova', 'angular-md5', 'pascalprecht.translate', 'ngAria', 'ngIOS9UIWebViewPatch', 'nvd3'])

.run(["$ionicPlatform", function($ionicPlatform) {
  $ionicPlatform.ready(function() {
    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
    }
    if (window.StatusBar) {
      StatusBar.styleDefault();
    }
  });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core', ['pascalprecht.translate'])

.constant('mmCoreSessionExpired', 'mmCoreSessionExpired')
.constant('mmCoreUserDeleted', 'mmCoreUserDeleted')
.constant('mmCoreSecondsYear', 31536000)
.constant('mmCoreSecondsDay', 86400)
.constant('mmCoreSecondsHour', 3600)
.constant('mmCoreSecondsMinute', 60)

// States for downloading files/modules.
.constant('mmCoreDownloaded', 'downloaded')
.constant('mmCoreDownloading', 'downloading')
.constant('mmCoreNotDownloaded', 'notdownloaded')
.constant('mmCoreOutdated', 'outdated')
.constant('mmCoreNotDownloadable', 'notdownloadable')

.constant('mmCoreWifiDownloadThreshold', 104857600) // 100MB.
.constant('mmCoreDownloadThreshold', 10485760) // 10MB.

.config(["$stateProvider", "$provide", "$ionicConfigProvider", "$httpProvider", "$mmUtilProvider", "$mmLogProvider", "$compileProvider", "$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($stateProvider, $provide, $ionicConfigProvider, $httpProvider, $mmUtilProvider,
        $mmLogProvider, $compileProvider, $mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {

    // Set tabs to bottom on Android.
    $ionicConfigProvider.platform.android.tabs.position('bottom');

    // Decorate $ionicPlatform.
    $provide.decorator('$ionicPlatform', ['$delegate', '$window', function($delegate, $window) {
        $delegate.isTablet = function() {
            var mq = 'only screen and (min-width: 768px) and (-webkit-min-device-pixel-ratio: 1)';
            return $window.matchMedia(mq).matches;
        };
        return $delegate;
    }]);

    /**
     * Decorate $log. Usage:
     * $log = $log.getInstance('MyFactory')
     * $log.debug('My message') -> "dd/mm/aaaa hh:mm:ss MyFactory: My message"
     */
    $provide.decorator('$log', ['$delegate', $mmLogProvider.logDecorator]);

    $stateProvider
        .state('redirect', {
            url: '/redirect',
            params: {
                siteid: null,
                state: null,
                params: null
            },
            cache: false,
            controller: ["$scope", "$state", "$stateParams", "$mmSite", "$mmSitesManager", "$ionicHistory", function($scope, $state, $stateParams, $mmSite, $mmSitesManager, $ionicHistory) {

                $ionicHistory.nextViewOptions({disableBack: true});

                function loadSiteAndGo() {
                    $mmSitesManager.loadSite($stateParams.siteid).then(function() {
                        $state.go($stateParams.state, $stateParams.params);
                    }, function() {
                        // Site doesn't exist.
                        $state.go('mm_login.sites');
                    });
                }

                $scope.$on('$ionicView.enter', function() {
                    if ($mmSite.isLoggedIn()) {
                        if ($stateParams.siteid && $stateParams.siteid != $mmSite.getId()) {
                            // Notification belongs to a different site. Change site.
                            $mmSitesManager.logout().then(function() {
                                loadSiteAndGo();
                            });
                        } else {
                            $state.go($stateParams.state, $stateParams.params);
                        }
                    } else {
                        if ($stateParams.siteid) {
                            loadSiteAndGo();
                        } else {
                            $state.go('mm_login.sites');
                        }
                    }
                });
            }]
        });

    // This code is to be able to get data sent with $http.post using $_POST variable.
    // Otherwise all the data ends up in php://input and seems like local/mobile/check.php doesn't like it.
    $httpProvider.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8';
    $httpProvider.defaults.transformRequest = [function(data) {
        return angular.isObject(data) && String(data) !== '[object File]' ? $mmUtilProvider.param(data) : data;
    }];

    // Add some protocols to safe protocols.
    function addProtocolIfMissing(list, protocol) {
        if (list.indexOf(protocol) == -1) {
            list = list.replace('https?', 'https?|' + protocol);
        }
        return list;
    }

    var hreflist = $compileProvider.aHrefSanitizationWhitelist().source,
        imglist = $compileProvider.imgSrcSanitizationWhitelist().source;

    hreflist = addProtocolIfMissing(hreflist, 'file');
    hreflist = addProtocolIfMissing(hreflist, 'tel');
    hreflist = addProtocolIfMissing(hreflist, 'mailto');
    hreflist = addProtocolIfMissing(hreflist, 'geo');
    hreflist = addProtocolIfMissing(hreflist, 'filesystem'); // For HTML5 FileSystem.
    imglist = addProtocolIfMissing(imglist, 'filesystem'); // For HTML5 FileSystem.

    $compileProvider.aHrefSanitizationWhitelist(hreflist);
    $compileProvider.imgSrcSanitizationWhitelist(imglist);

    // Register the core init process, this should be the very first thing.
    $mmInitDelegateProvider.registerProcess('mmAppInit', '$mmApp.initProcess', mmInitDelegateMaxAddonPriority + 400, true);

    // Register upgrade check process, this should happen almost before everything else.
    $mmInitDelegateProvider.registerProcess('mmUpdateManager', '$mmUpdateManager.check', mmInitDelegateMaxAddonPriority + 300, true);
}])

.run(["$ionicPlatform", "$ionicBody", "$window", "$mmEvents", "$mmInitDelegate", "mmCoreEventKeyboardShow", "mmCoreEventKeyboardHide", function($ionicPlatform, $ionicBody, $window, $mmEvents, $mmInitDelegate, mmCoreEventKeyboardShow, mmCoreEventKeyboardHide) {
    // Execute all the init processes.
    $mmInitDelegate.executeInitProcesses();

    // When the platform is ready.
    $ionicPlatform.ready(function() {
        var checkTablet = function() {
            $ionicBody.enableClass($ionicPlatform.isTablet(), 'tablet');
        };
        ionic.on('resize', checkTablet, $window);
        checkTablet();

        // Listen for keyboard events. We don't use $cordovaKeyboard because it doesn't support keyboardHeight property.
        $window.addEventListener('native.keyboardshow', function(e) {
            $mmEvents.trigger(mmCoreEventKeyboardShow, e);
        });
        $window.addEventListener('native.keyboardhide', function(e) {
            $mmEvents.trigger(mmCoreEventKeyboardHide, e);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmAddonManager
 * @module mm.core
 * @description
 * This service provides functions related to addons, like checking if an addon is available.
 */
.factory('$mmAddonManager', ["$log", "$injector", function($log, $injector) {

    $log = $log.getInstance('$mmAddonManager');

    var self = {},
        instances = {};

    /**
     * Get a service instance if it's available.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmAddonManager#get
     * @param  {String} name Service name.
     * @return {Object}      Service instance.
     */
    self.get = function(name) {
        if (self.isAvailable(name)) {
            return instances[name];
        }
    };

    /**
     * Check if a service is available.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmAddonManager#isAvailable
     * @param  {String} name Service name.
     * @return {Boolean}     True if available, false otherwise.
     */
    self.isAvailable = function(name) {
        if (!name) {
            return false;
        }

        if (instances[name]) {
            return true;
        }

        try {
            instances[name] = $injector.get(name);
            return true;
        } catch(ex) {
            $log.warn('Service not available: '+name);
            return false;
        }
    };

    return self;
}]);

/**
 * ==================  angular-ios9-uiwebview.patch.js v1.1.0 ==================
 *
 * This patch works around iOS9 UIWebView regression that causes infinite digest
 * errors in Angular.
 *
 * The patch can be applied to Angular 1.2.0 – 1.4.5. Newer versions of Angular
 * have the workaround baked in.
 *
 * To apply this patch load/bundle this file with your application and add a
 * dependency on the "ngIOS9Patch" module to your main app module.
 *
 * For example:
 *
 * ```
 * angular.module('myApp', ['ngRoute'])`
 * ```
 *
 * becomes
 *
 * ```
 * angular.module('myApp', ['ngRoute', 'ngIOS9UIWebViewPatch'])
 * ```
 *
 *
 * More info:
 * - https://openradar.appspot.com/22186109
 * - https://github.com/angular/angular.js/issues/12241
 * - https://github.com/driftyco/ionic/issues/4082
 *
 *
 * @license AngularJS
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */

angular.module('ngIOS9UIWebViewPatch', ['ng']).config(["$provide", function($provide) {
  $provide.decorator('$browser', ['$delegate', '$window', function($delegate, $window) {

    if (isIOS9UIWebView($window.navigator.userAgent)) {
      return applyIOS9Shim($delegate);
    }

    return $delegate;

    function isIOS9UIWebView(userAgent) {
      return /(iPhone|iPad|iPod).* OS 9_\d/.test(userAgent) && !/Version\/9\./.test(userAgent);
    }

    function applyIOS9Shim(browser) {
      var pendingLocationUrl = null;
      var originalUrlFn= browser.url;

      browser.url = function() {
        if (arguments.length) {
          pendingLocationUrl = arguments[0];
          return originalUrlFn.apply(browser, arguments);
        }

        return pendingLocationUrl || originalUrlFn.apply(browser, arguments);
      };

      window.addEventListener('popstate', clearPendingLocationUrl, false);
      window.addEventListener('hashchange', clearPendingLocationUrl, false);

      function clearPendingLocationUrl() {
        pendingLocationUrl = null;
      }

      return browser;
    }
  }]);
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Factory to provide some global functionalities, like access to the global app database.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmApp
 * @description
 * This provider is the interface with the app database. The modules that need to store
 * information here need to register their stores.
 *
 * Example:
 *
 * .config(function($mmAppProvider) {
 *      $mmAppProvider.registerStore({
 *          name: 'settings',
 *          keyPath: 'name'
 *      });
 *  })
 */
.provider('$mmApp', ["$stateProvider", function($stateProvider) {

    /** Define the app storage schema. */
    var DBNAME = 'MoodleMobile',
        dbschema = {
            stores: []
        },
        dboptions = {
            autoSchema: true
        };

    /**
     * Register a store schema.
     *
     * @param  {Object} store The store object definition.
     * @return {Void}
     */
    this.registerStore = function(store) {
        if (typeof(store.name) === 'undefined') {
            console.log('$mmApp: Error: store name is undefined.');
            return;
        } else if (storeExists(store.name)) {
            console.log('$mmApp: Error: store ' + store.name + ' is already defined.');
            return;
        }
        dbschema.stores.push(store);
    };

    /**
     * Register multiple stores at once.
     *
     * @param  {Array} stores Array of store objects.
     * @return {Void}
     */
    this.registerStores = function(stores) {
        var self = this;
        angular.forEach(stores, function(store) {
            self.registerStore(store);
        });
    };

    /**
     * Check if a store is already defined.
     *
     * @param  {String} name The name of the store.
     * @return {Boolean} True when the store was already defined.
     */
    function storeExists(name) {
        var exists = false;
        angular.forEach(dbschema.stores, function(store) {
            if (store.name === name) {
                exists = true;
            }
        });
        return exists;
    }

    this.$get = ["$mmDB", "$cordovaNetwork", "$log", "$injector", "$ionicPlatform", function($mmDB, $cordovaNetwork, $log, $injector, $ionicPlatform) {

        $log = $log.getInstance('$mmApp');

        var db,
            self = {};

        /**
         * Create a new state in the UI-router.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#createState
         * @param {String} name   State name.
         * @param {Object} config State config.
         */
        self.createState = function(name, config) {
            $log.debug('Adding new state: '+name);
            $stateProvider.state(name, config);
        };

        /**
         * Closes the keyboard if plugin is available.
         *
         * @return {Boolean} True if plugin is available, false otherwise.
         */
        self.closeKeyboard = function() {
            if (typeof cordova != 'undefined' && cordova.plugins && cordova.plugins.Keyboard && cordova.plugins.Keyboard.close) {
                cordova.plugins.Keyboard.close();
                return true;
            }
            return false;
        };

        /**
         * Get the application global database.
         * @return {Object} App's DB.
         */
        self.getDB = function() {
            if (typeof db == 'undefined') {
                db = $mmDB.getDB(DBNAME, dbschema, dboptions);
            }

            return db;
        };

        /**
         * Get the database schema.
         *
         * Do not use this method to modify the schema. Use $mmAppProvider#registerStore instead.
         *
         * @return {Object} The schema.
         */
        self.getSchema = function() {
            return dbschema;
        };

        /**
         * Core init process for the app.
         *
         * @description
         * This should be the first init process of all, no other process should run until we
         * are certain that the cordova plugins are loaded, which is what $ionicPlatform tells us.
         * There should not be any logic acting on the database here as the upgrade is
         * another process and has not run yet at this point.
         *
         * Keep this fast.
         *
         * Reserved for core use, do not call directly.
         *
         * @module mm.core
         * @ngdoc service
         * @name $mmApp#initProcess
         * @protected
         * @return {Promise}
         */
        self.initProcess = function() {
            return $ionicPlatform.ready();
        };

        /**
         * Checks if the app is running in a real device with cordova-plugin-device installed.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#isDevice
         * @return {Bool} True if device is defined, false otherwise.
         */
        self.isDevice = function() {
            return !!window.device;
        };

        /**
         * Returns whether we are online.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#isOnline
         * @return {Bool} True when we are.
         * @description
         * This methods returns whether the app is online or not.
         * Note that a browser is always considered being online.
         */
        self.isOnline = function() {
            var online = typeof navigator.connection === 'undefined' || $cordovaNetwork.isOnline();
            // Double check we are not online because we cannot rely 100% in Cordova APIs.
            if (!online && navigator.onLine) {
                online = true;
            }
            return online;
        };

        /*
         * Check if device uses a limited connection.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#isNetworkAccessLimited
         * @return {Boolean} True if device used a limited connection, false otherwise.
         * @description
         * This method allows for us to first check if cordova is loaded,
         * otherwise exceptions can be thrown when trying on a browser.
         */
        self.isNetworkAccessLimited = function() {
            if (typeof navigator.connection === 'undefined') {
                // Plugin not defined, probably in browser.
                return false;
            }
            var type = $cordovaNetwork.getNetwork();
            var limited = [Connection.CELL_2G, Connection.CELL_3G, Connection.CELL_4G, Connection.CELL];
            return limited.indexOf(type) > -1;
        };

        /**
         * Instantly returns if the app is ready.
         *
         * To be notified when the app is ready, refer to {@link $mmApp#ready}.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#ready
         * @return {Boolean} True when it is, false when not.
         */
        self.isReady = function() {
            var promise = $injector.get('$mmInitDelegate').ready();
            return promise.$$state.status === 1;
        };

        /**
         * Open the keyboard if plugin is available.
         *
         * @return {Boolean} True if plugin is available, false otherwise.
         */
        self.openKeyboard = function() {
            if (typeof cordova != 'undefined' && cordova.plugins && cordova.plugins.Keyboard && cordova.plugins.Keyboard.show) {
                cordova.plugins.Keyboard.show();
                return true;
            }
            return false;
        };

        /**
         * Resolves when the app is ready.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmApp#ready
         * @description
         * This returns a promise that is resolved when the app is initialised.
         *
         * Usage:
         *
         *    $mmApp.ready().then(function() {
         *        // What you want to do.
         *    });
         *
         * @return {Promise} Resolved when the app is initialised. Never rejected.
         */
        self.ready = function() {
            // Injects to prevent circular dependencies.
            return $injector.get('$mmInitDelegate').ready();
        };

        return self;
    }];
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreConfigStore', 'config')

.config(["$mmAppProvider", "mmCoreConfigStore", function($mmAppProvider, mmCoreConfigStore) {
    var stores = [
        {
            name: mmCoreConfigStore,
            keyPath: 'name'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

/**
 * Factory to provide access to dynamic and permanent config and settings.
 * It should not be abused into a temporary storage.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmConfig
 * @description
 * Provides access to the app settings.
 */
.factory('$mmConfig', ["$q", "$log", "$mmApp", "mmCoreConfigStore", function($q, $log, $mmApp, mmCoreConfigStore) {

    $log = $log.getInstance('$mmConfig');

    var self = {};

    /**
     * Get an app setting.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmConfig#get
     * @param {String} name           The config name.
     * @param {Mixed}  [defaultValue] Default value to use if the entry is not found.
     * @return {Promise}              Resolves upon success along with the config data. Reject on failure.
     * @description
     * Get an app setting.
     */
    self.get = function(name, defaultValue) {
        return $mmApp.getDB().get(mmCoreConfigStore, name).then(function(entry) {
            return entry.value;
        }).catch(function() {
            if (typeof defaultValue != 'undefined') {
                return defaultValue;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Set an app setting.
     *
     * @module mm.core
     * @ngdoc service
     * @name $mmConfig#set
     * @param {String} name The config name.
     * @param {Mixed} value The config value.
     * @return {Promise}    Promise which resolves on success, providing no data.
     * @description
     * Set an app setting.
     */
    self.set = function(name, value) {
        return $mmApp.getDB().insert(mmCoreConfigStore, {name: name, value: value});
    };

    /**
     * Deletes an app setting.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmConfig#delete
     * @param {String} name The config name.
     * @return {Promise}    Promise which resolves on success, providing no data.
     * @description
     * Delete an app setting.
     */
    self.delete = function(name) {
        return $mmApp.getDB().remove(mmCoreConfigStore, name);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmDB
 * @module mm.core
 * @description
 * This service allows to interact with the local database to store and retrieve data.
 */
.factory('$mmDB', ["$q", "$log", function($q, $log) {

    $log = $log.getInstance('$mmDB');

    var self = {},
        dbInstances = {};

    /**
     * Convenient helper to apply an order to a query.
     *
     * @param  {Object}  [query]   A query object.
     * @param  {String}  [order]   The field to order on.
     * @param  {Boolean} [reverse] Whether to reverse the results.
     * @return {Object}  The updated query object (or initial one).
     */
    function applyOrder(query, order, reverse) {
        if (order) {
            query = query.order(order);
            if (reverse) {
                query = query.reverse();
            }
        }
        return query;
    }

    /**
     * Convenient helper to apply a where condition to a query.
     *
     * @param  {Object} [query]   A query object.
     * @param  {Array}  [where]   Array of parameters, in order:
     *                            - The field to filter on
     *                            - The operator: <, <=, =, >, >=, ^ (starts with)
     *                            - The value
     *                            - An additional operator
     *                            - An additional value
     * @return {Object} The updated query object (or initial one).
     */
    function applyWhere(query, where) {
        if (where && where.length > 0) {
            query = query.where.apply(query, where);
        }
        return query;
    }

    /**
     * Call a DB simple function.
     * @param  {Object}  db      DB to use.
     * @param  {String}  func    Name of the function to call.
     * @return {Promise}         Promise to be resolved when the operation finishes.
     */
    function callDBFunction(db, func) {
        var deferred = $q.defer();

        try {
            if (typeof(db) != 'undefined') {
                db[func].apply(db, Array.prototype.slice.call(arguments, 2)).then(function(result) {
                    if (typeof(result) == 'undefined') {
                        deferred.reject();
                    } else {
                        deferred.resolve(result);
                    }
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error executing function '+func+' to DB '+db.getName());
            $log.error(ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Retrieve the count of entries matching certain conditions.
     * @param  {Object}  db         DB to use.
     * @param  {String}  store      Name of the store to get the entries from.
     * @param  {Array}   where      Array of where conditions, see applyWhere.
     * @return {Promise}
     */
    function callCount(db, store, where) {
        var deferred = $q.defer(),
            query;

        try {
            if (typeof(db) != 'undefined') {
                query = db.from(store);
                query = applyWhere(query, where);
                query.count().then(function(count) {
                    deferred.resolve(count);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying db '+db.getName()+'. '+ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Retrieve the list of entries matching certain conditions.
     * @param  {Object}  db         DB to use.
     * @param  {String}  store      Name of the store to get the entries from.
     * @param  {String}  field_name Name of the field that should match the conditions.
     * @param  {String}  op         First operator symbol. One of '<', '<=', '=', '>', '>=', '^'.
     * @param  {String}  value      Value for the first operator.
     * @param  {String}  op2        Second operator symbol.
     * @param  {String}  value2     Value for the second operator.
     * @return {Promise}            Promise to be resolved when the list is retrieved.
     */
    function callWhere(db, store, field_name, op, value, op2, value2) {
        var deferred = $q.defer();

        try {
            if (typeof(db) != 'undefined') {
                db.from(store).where(field_name, op, value, op2, value2).list().then(function(list) {
                    deferred.resolve(list);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying db '+db.getName()+'. '+ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Retrieve the list of entries where a certain field is equal to a certain value.
     * Important: the field must be an index.
     * @param  {Object}  db         DB to use.
     * @param  {String}  store      Name of the store to get the entries from.
     * @param  {String}  field_name Name of the field to check.
     * @param  {String}  value      Value the field should be equal to.
     * @return {Promise}            Promise to be resolved when the list is retrieved.
     */
    function callWhereEqual(db, store, field_name, value) {
        var deferred = $q.defer();

        try {
            if (typeof(db) != 'undefined') {
                db.from(store).where(field_name, '=', value).list().then(function(list) {
                    deferred.resolve(list);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error getting where equal from db '+db.getName()+'. '+ex.name+': '+ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Performs an operation with every entry in a certain store.
     * @param  {Object}   db       DB to use.
     * @param  {String}   store    Name of the store to get the entries from.
     * @param  {Function} callback Function to call with each entry.
     * @return {Promise}           Promise to be resolved when the the operation has been applied to all entries.
     */
    function callEach(db, store, callback) {
        var deferred = $q.defer();

        callDBFunction(db, 'values', store, undefined, 99999999).then(function(entries) {
            for (var i = 0; i < entries.length; i++) {
                callback(entries[i]);
            }
            deferred.resolve();
        }, function() {
            deferred.reject();
        });

        return deferred.promise;
    }

    /**
     * Retrieve the list of entries matching certain conditions.
     *
     * @param  {Object}  db      DB to use.
     * @param  {String}  store   Name of the store to get the entries from.
     * @param  {Array}   where   Array of where conditions, see applyWhere.
     * @param  {Array}   order   The key to order on.
     * @param  {Boolean} reverse Whether to reverse the order.
     * @param  {Number}  limit   The number of result to return.
     * @return {Promise}
     */
    function doQuery(db, store, where, order, reverse, limit) {
        var deferred = $q.defer(),
            query;

        try {
            if (typeof(db) != 'undefined') {
                query = db.from(store);
                query = applyWhere(query, where);
                query = applyOrder(query, order, reverse);
                query.list(limit).then(function(list) {
                    deferred.resolve(list);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying ' + store + ' on ' + db.getName() + '. ' + ex.name + ': ' + ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Update a list of entries matching conditions.
     *
     * @param  {Object}  db      DB to use.
     * @param  {String}  store   Name of the store to get the entries from.
     * @param  {Object}  values  The values to set.
     * @param  {Array}   where   An array of where() parameters.
     * @return {Promise}
     */
    function doUpdate(db, store, values, where) {
        var deferred = $q.defer(),
            query;

        try {
            if (typeof(db) != 'undefined') {
                query = db.from(store);
                query = applyWhere(query, where);
                query.patch(values).then(function(count) {
                    deferred.resolve(count);
                }, function() {
                    deferred.reject();
                });
            } else {
                deferred.reject();
            }
        } catch(ex) {
            $log.error('Error querying ' + store + ' on ' + db.getName() + '. ' + ex.name + ': ' + ex.message);
            deferred.reject();
        }

        return deferred.promise;
    }

    /**
     * Create a new database object.
     *
     * The database objects are cached statically.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmDB#getDB
     * @param  {String} name    DB name.
     * @param  {Object} schema  DB schema.
     * @param  {Object} options DB options.
     * @return {Object}         DB.
     */
    self.getDB = function(name, schema, options) {
        if (typeof dbInstances[name] === 'undefined') {

            var isSafari = !ionic.Platform.isIOS() && !ionic.Platform.isAndroid() && navigator.userAgent.indexOf('Safari') != -1
                            && navigator.userAgent.indexOf('Chrome') == -1 && navigator.userAgent.indexOf('Firefox') == -1;
            if (typeof IDBObjectStore == 'undefined' || typeof IDBObjectStore.prototype.count == 'undefined' || isSafari) {
                // IndexedDB not implemented or not fully implemented (Galaxy S4 Mini). Use WebSQL.
                if (typeof options.mechanisms == 'undefined') {
                    options.mechanisms = ['websql', 'sqlite', 'localstorage', 'sessionstorage', 'userdata', 'memory'];
                } else {
                    var position = options.mechanisms.indexOf('indexeddb');
                    if (position != -1) {
                        options.mechanisms.splice(position, 1);
                    }
                }
            }

            var db = new ydn.db.Storage(name, schema, options);

            dbInstances[name] = {
                /**
                 * Get DB name.
                 *
                 * @return {String} DB name.
                 */
                getName: function() {
                    return db.getName();
                },
                /**
                 * Get an entry from a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Mixed}  id    Entry's identifier (primary key / keyPath).
                 * @return {Promise}     Promise resolved when the entry is retrieved. Resolve param: DB entry (object).
                 */
                get: function(store, id) {
                    return callDBFunction(db, 'get', store, id);
                },
                /**
                 * Get all the entries from a store.
                 *
                 * @param {String} store Name of the store.
                 * @return {Promise}     Promise resolved when the entries are retrieved. Resolve param: DB entries (array).
                 */
                getAll: function(store) {
                    return callDBFunction(db, 'values', store, undefined, 99999999);
                },
                /**
                 * Count the number of entries in a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Array} [where] Array of where conditions, see applyWhere.
                 * @return {Promise}     Promise resolved when the count is done. Resolve param: number of entries.
                 */
                count: function(store, where) {
                    return callCount(db, store, where);
                },
                /**
                 * Add an entry to a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Object} value Object to store. Primary key (keyPath) is required.
                 * @param {IDbKey} id The key when needed.
                 * @return {Promise}     Promise resolved when the entry is inserted. Resolve param: new entry's primary key.
                 */
                insert: function(store, value, id) {
                    return callDBFunction(db, 'put', store, value, id);
                },
                /**
                 * Add an entry to a store, returning a synchronous value.
                 * Please use this function only if synchronous is a must, you should always use $mmDB#insert.
                 * Take into account that the value will be returned BEFORE the value is actually stored. The value of the
                 * boolean returned only indicates if it has passed the first validation.
                 *
                 * @param {String} store Name of the store.
                 * @param {Object} value Object to store. Primary key (keyPath) is required.
                 * @return {Boolean}     True if data to insert is valid, false otherwise. Returning true doesn't mean that the
                 *                       data has been stored, this function can return true but the insertion can still fail.
                 */
                insertSync: function(store, value) {
                    if (db) {
                        try {
                            db.put(store, value);
                            return true;
                        } catch(ex) {
                            $log.error('Error executing function sync put to DB '+db.getName());
                            $log.error(ex.name+': '+ex.message);
                        }
                    }

                    return false;
                },
                /**
                 * Query the database.
                 *
                 * @param {String} store Name of the store.
                 * @param {Array} [where] Array of where conditions, see applyWhere.
                 * @param {String} [order] The key to sort the results with.
                 * @param {Boolean} [reverse=false] Whether to reverse the results.
                 * @param {Number} [limit] The number of results to return.
                 * @return {Promise} Promise resolved with an array of entries.
                 */
                query: function(store, where, order, reverse, limit) {
                    return doQuery(db, store, where, order, reverse, limit);
                },
                /**
                 * Removes an entry from a store.
                 *
                 * @param {String} store Name of the store.
                 * @param {Mixed}  id    Entry's identifier (primary key / keyPath).
                 * @return {Promise}     Promise resolved when the entry is deleted. Resolve param: number of entries deleted.
                 */
                remove: function(store, id) {
                    return callDBFunction(db, 'remove', store, id);
                },
                /**
                 * Removes all entries from a store.
                 *
                 * @param {String} store Name of the store.
                 * @return {Promise}     Promise resolved when the entries are deleted.
                 */
                removeAll: function(store) {
                    return callDBFunction(db, 'clear', store);
                },
                /**
                 * Update records matching.
                 *
                 * @param {String} store Name of the store.
                 * @param {Object} values The values to update.
                 * @param {Array} [where] Array of where conditions, see applyWhere.
                 * @return {Promise}
                 */
                update: function(store, values, where) {
                    return doUpdate(db, store, values, where);
                },
                /**
                 * Get the entries where a field match certain conditions.
                 *
                 * @param {String} store      Name of the store.
                 * @param {String} field_name Name of the field to match.
                 * @param {String} op         First operator to apply to the field. <, <=, =, >, >=, ^ (start with).
                 * @param {Mixed}  value      Value to compare using the first operator.
                 * @param {String} op2        Second operator to apply to the field. Optional.
                 * @param {Mixed}  value2     Value to compare using the second operator. Optional.
                 * @return {Promise}          Promise resolved when the entries are retrieved. Resolve param: entries (array).
                 */
                where: function(store, field_name, op, value, op2, value2) {
                    return callWhere(db, store, field_name, op, value, op2, value2);
                },
                /**
                 * Get the entries where a field is equal to a certain value.
                 *
                 * @param {String} store      Name of the store.
                 * @param {String} field_name Name of the field to match.
                 * @param {Mixed}  value      Value to compare to the field.
                 * @return {Promise}          Promise resolved when the entries are retrieved. Resolve param: entries (array).
                 */
                whereEqual: function(store, field_name, value) {
                    return callWhereEqual(db, store, field_name, value);
                },
                /**
                 * Call a function with each of the entries from a store.
                 *
                 * @param {String} store      Name of the store.
                 * @param {Function} callback Function to call with each entry.
                 * @return {Promise}          Promise resolved when the function is called for all entries. No resolve params.
                 */
                each: function(store, callback) {
                    return callEach(db, store, callback);
                },
                /**
                 * Close the database.
                 */
                close: function() {
                    db.close();
                    db = undefined;
                },
                /**
                 * Call a callback once DB is ready.
                 *
                 * @param {Function} cb Callback to call.
                 */
                onReady: function(cb) {
                    db.onReady(cb);
                },
                /**
                 * Get storage type.
                 *
                 * @return {String} Storage type.
                 */
                getType: function() {
                    return db.getType();
                }
            };
        }
        return dbInstances[name];
    };

    /**
     * Delete a DB.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmDB#deleteDB
     * @param  {String} name   DB name.
     * @return {Promise}       Promise to be resolved when the site DB is deleted.
     */
    self.deleteDB = function(name) {
        var deferred = $q.defer();

        function deleteDB() {
            delete dbInstances[name];
            $q.when(ydn.db.deleteDatabase(name)).then(deferred.resolve, deferred.reject);
        }

        if (typeof dbInstances[name] != 'undefined') {
            // We have a DB instance. Wait for it to be ready before deleting the DB.
            dbInstances[name].onReady(deleteDB);
        } else {
            deleteDB();
        }

        return deferred.promise;
    };

    return self;

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmEmulatorManager
 * @module mm.core
 * @description
 * This service handles the emulation of Cordova plugins in other environments like browser.
 */
.factory('$mmEmulatorManager', ["$log", "$q", "$http", "$mmFS", "$window", function($log, $q, $http, $mmFS, $window) {

    $log = $log.getInstance('$mmEmulatorManager');

    var self = {};

    /**
     * Loads HTML API to simulate Cordova APIs. Reserved for core use.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEmulatorManager#loadHTMLAPI
     * @return {Promise} Promise resolved when the API is loaded.
     * @protected
     */
    self.loadHTMLAPI = function() {

        if ($mmFS.isAvailable()) {
            $log.debug('Stop loading HTML API, it was already loaded or the environment doesn\'t need it.');
            return $q.when();
        }

        var deferred = $q.defer(),
            basePath;

        $log.debug('Loading HTML API.');

        // File API.
        $window.requestFileSystem  = $window.requestFileSystem || $window.webkitRequestFileSystem;
        $window.resolveLocalFileSystemURL = $window.resolveLocalFileSystemURL || $window.webkitResolveLocalFileSystemURL;

        $window.LocalFileSystem = {
            PERSISTENT: 1
        };

        // FileTransfer API.
        $window.FileTransfer = function() {};

        $window.FileTransfer.prototype.download = function(url, filePath, successCallback, errorCallback) {
            $http.get(url, {responseType: 'blob'}).then(function(data) {
                if (!data || !data.data) {
                    errorCallback();
                } else {
                    filePath = filePath.replace(basePath, ''); // Remove basePath from the filePath.
                    $mmFS.writeFile(filePath, data.data).then(function(e) {
                        successCallback(e);
                    }).catch(function(error) {
                        errorCallback(error);
                    });
                }
            }).catch(function(error) {
                errorCallback(error);
            });
        };

        // Cordova ZIP plugin.
        $window.zip = {
            unzip: function(source, destination, callback, progressCallback) {
                // Remove basePath from the source and destination.
                source = source.replace(basePath, '');
                destination = destination.replace(basePath, '');

                $mmFS.readFile(source, $mmFS.FORMATARRAYBUFFER).then(function(data) {
                    var zip = new JSZip(data),
                        promises = [];

                    angular.forEach(zip.files, function(file, name) {
                        var filepath = $mmFS.concatenatePaths(destination, name),
                            type;

                        if (!file.dir) {
                            // It's a file. Get the mimetype and write the file.
                            type = $mmFS.getMimeType($mmFS.getFileExtension(name));
                            promises.push($mmFS.writeFile(filepath, new Blob([file.asArrayBuffer()], {type: type})));
                        } else {
                            // It's a folder, create it if it doesn't exist.
                            promises.push($mmFS.createDir(filepath));
                        }
                    });

                    return $q.all(promises).then(function() {
                        // Success.
                        callback(0);
                    });
                }).catch(function() {
                    // Error.
                    callback(-1);
                });
            }
        };

        // @todo: Implement FileTransfer.upload.

        // Request 500MB.
        $window.webkitStorageInfo.requestQuota(PERSISTENT, 500 * 1024 * 1024, function(granted) {
            $window.requestFileSystem(PERSISTENT, granted, function(entry) {
                basePath = entry.root.toURL();
                $mmFS.setHTMLBasePath(basePath);
                deferred.resolve();
            }, deferred.reject);
        }, deferred.reject);

        return deferred.promise;
    };

    return self;
}])

.config(["$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {
    if (!ionic.Platform.isWebView()) {
        $mmInitDelegateProvider.registerProcess('mmEmulator', '$mmEmulatorManager.loadHTMLAPI',
                mmInitDelegateMaxAddonPriority + 500, true);
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreEventKeyboardShow', 'keyboard_show')
.constant('mmCoreEventKeyboardHide', 'keyboard_hide')
.constant('mmCoreEventSessionExpired', 'session_expired')
.constant('mmCoreEventLogin', 'login')
.constant('mmCoreEventLogout', 'logout')
.constant('mmCoreEventLanguageChanged', 'language_changed')
.constant('mmCoreEventSiteAdded', 'site_added')
.constant('mmCoreEventSiteUpdated', 'site_updated')
.constant('mmCoreEventSiteDeleted', 'site_deleted')
.constant('mmCoreEventQueueEmpty', 'filepool_queue_empty')
.constant('mmCoreEventCompletionModuleViewed', 'completion_module_viewed')
.constant('mmCoreEventUserDeleted', 'user_deleted')
.constant('mmCoreEventPackageStatusChanged', 'filepool_package_status_changed')
.constant('mmCoreEventSectionStatusChanged', 'section_status_changed')

/**
 * Service to send and listen to events.
 *
 * @ngdoc service
 * @name $mmEvents
 * @module mm.core
 * @description
 * This service allows sending and listening to events in the Moodle Mobile app.
 */
.factory('$mmEvents', ["$log", "md5", function($log, md5) {

    $log = $log.getInstance('$mmEvents');

    var self = {},
        observers = {},
        uniqueEvents = {},
        uniqueEventsData = {};

    /**
     * Adds an observer for a certain event.
     * To deregister the event:
     * var observer = $mmEvents.on('something', myCallBack);
     * observer.off();
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEvents#on
     * @param  {String}   eventName  Name of the event to listen to.
     * @param  {Function} callBack   Function to call when the event is triggered.
     * @return {Object}              Object to deregister the observer. Undefined if it's an already triggered unique event.
     */
    self.on = function(eventName, callBack) {

        // If it's a unique event and has been triggered already, call the callBack.
        // We don't need to store the observer because the event won't be triggered again.
        if (uniqueEvents[eventName]) {
            callBack(uniqueEventsData[eventName]);
            // Return a fake observer to prevent errors.
            return {
                id: -1,
                off: function() {}
            };
        }

        var observerID;

        if (typeof(observers[eventName]) === 'undefined') {
            observers[eventName] = {};
        }

        while (typeof(observerID) === 'undefined') {
            var candidateID = md5.createHash(Math.random().toString());
            if (typeof(observers[eventName][candidateID]) === 'undefined') {
                observerID = candidateID;
            }
        }
        $log.debug('Observer ' + observerID + ' listening to event '+eventName);

        observers[eventName][observerID] = callBack;

        // Create observer object to deregister the listener.
        var observer = {
            id: observerID,
            off: function() {
                $log.debug('Disable observer ' + observerID + ' for event '+eventName);
                delete observers[eventName][observerID];
            }
        };
        return observer;
    };

    /**
     * Triggers an event, notifying all the observers.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEvents#trigger
     * @param {String} event Name of the event to trigger.
     * @param {Mixed}  data  Data to pass to the observers.
     */
    self.trigger = function(eventName, data) {
        $log.debug('Event ' + eventName + ' triggered.');
        var affected = observers[eventName];
        for (var observerName in affected) {
            if (typeof(affected[observerName]) === 'function') {
                affected[observerName](data);
            }
        }
    };

    /**
     * Triggers a unique event, notifying all the observers. If the event has already been triggered, don't do anything.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmEvents#trigger
     * @param {String} event Name of the event to trigger.
     * @param {Mixed}  data  Data to pass to the observers.
     */
    self.triggerUnique = function(eventName, data) {
        if (uniqueEvents[eventName]) {
            $log.debug('Unique event ' + eventName + ' ignored because it was already triggered.');
        } else {
            $log.debug('Unique event ' + eventName + ' triggered.');
            uniqueEvents[eventName] = true;
            uniqueEventsData[eventName] = data;
            var affected = observers[eventName];
            angular.forEach(affected, function(callBack) {
                if (typeof callBack === 'function') {
                    callBack(data);
                }
            });
        }
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmFilepoolQueueProcessInterval', 0)
.constant('mmFilepoolFolder', 'filepool')
.constant('mmFilepoolStore', 'filepool')
.constant('mmFilepoolQueueStore', 'files_queue')
.constant('mmFilepoolLinksStore', 'files_links')
.constant('mmFilepoolPackagesStore', 'filepool_packages')

.config(["$mmAppProvider", "$mmSitesFactoryProvider", "mmFilepoolStore", "mmFilepoolLinksStore", "mmFilepoolQueueStore", "mmFilepoolPackagesStore", function($mmAppProvider, $mmSitesFactoryProvider, mmFilepoolStore, mmFilepoolLinksStore, mmFilepoolQueueStore,
            mmFilepoolPackagesStore) {
    var siteStores = [
        {
            // File store.
            //
            // Each entry should contain:
            // - fileId: A hash of the file info.
            // - url: URL to download the file.
            // - modified: The time at which the file was last downloaded.
            // - stale: When true, it means that the file should be redownloaded.
            // - etag: Store the ETAG code of the file.
            name: mmFilepoolStore,
            keyPath: 'fileId',
            indexes: []
        },
        {
            // Associations between files and components.
            //
            // Each entry should contain:
            // - fileId: Hash used in the file store.
            // - component: The component name (e.g. mmaModPage).
            // - componentId: An ID that can be used by the component. -1 when not provided.
            name: mmFilepoolLinksStore,
            keyPath: ['fileId', 'component', 'componentId'],
            indexes: [
                {
                    name: 'fileId',
                },
                {
                    name: 'component',
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'componentAndId',
                    generator: function(obj) {
                        return [obj.component, obj.componentId];
                    }
                }
            ]
        },
        {
            // Packages store.
            //
            // Each entry should contain:
            // - id: The package ID. See {@link $mmFilepool#getPackageId}
            // - component: Package's component.
            // - componentId: Package's componentId.
            // - status: The package status: mmCoreDownloaded, mmCoreDownloading, etc.
            // - previous: (optional) The package previous status.
            // - revision: The package revision.
            // - timemodified: The package timemodified.
            // - updated: When was the entry updated for the last time.
            name: mmFilepoolPackagesStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'component',
                },
                {
                    name: 'componentId',
                },
                {
                    name: 'status',
                }
            ]
        }
    ];
    var appStores = [
        {
            // Files queue.
            //
            // Each entry should contain:
            // - siteId: The site ID.
            // - fileId: A hash of the file info.
            // - url: URL to download the file.
            // - added: Timestamp (in milliseconds) at which the file was added to the queue.
            // - priority: Indicates which files should be treated first. Maximum value is 999.
            // - links: Array of objects containing component and ID to create links once the file has been processed.
            name: mmFilepoolQueueStore,
            keyPath: ['siteId', 'fileId'],
            indexes: [
                {
                    name: 'siteId',
                },
                {
                    name: 'sortorder',
                    generator: function(obj) {
                        // Creates an index to sort the queue items by priority, sort is ascending.
                        // The oldest are considered to be the most important ones.
                        // The additional priority argument allows to bump any queue item on top of the queue.
                        // The index will look as follow:
                        //    [999 - priority] + "-" + timestamp
                        //    "999-1431491086913": item without priority.
                        //    "900-1431491086913": item with priority of 99.
                        //    "000-1431491086913": item with max priority.

                        var sortorder = parseInt(obj.added, 10),
                            priority = 999 - Math.max(0, Math.min(parseInt(obj.priority || 0, 10), 999)),
                            padding = "000";

                        // Convert to strings.
                        sortorder = "" + sortorder;
                        priority = "" + priority;

                        // Final format.
                        priority = padding.substring(0, padding.length - priority.length) + priority;
                        sortorder = priority + '-' + sortorder;

                        return sortorder;
                    }
                }
            ]
        }
    ];
    $mmAppProvider.registerStores(appStores);
    $mmSitesFactoryProvider.registerStores(siteStores);
}])

/**
 * Factory for handling the files in the pool.
 *
 * @module mm.core
 * @ngdoc factory
 * @name $mmFilepool
 * @todo Use transactions (e.g. when querying, then updating)
 * @todo Setting files as stale after a certain time
 * @todo Use ETAGs
 * @todo Do not download on limited network
 * @description
 *
 * This factory is responsible for handling external content.
 *
 * It will always try to get a file from the filepool and return it, when the file is not
 * found it will be added to a queue to be downloaded later. The two main goals of this
 * is to keep the content available offline, and improve the user experience by caching
 * the content locally.
 *
 * The filepool has a very limited understanding of pluginfiles, you should always call
 * {@link $mmUtil#fixPluginfileURL} prior to passing the URL. The reason for this is to
 * allow for any type of URL to be handled here. We can download and cache content
 * that is not served by Moodle. The only little handling of pluginfile is located in
 * {@link $mmFilepool#_getFileIdByUrl}.
 */
.factory('$mmFilepool', ["$q", "$log", "$timeout", "$mmApp", "$mmFS", "$mmWS", "$mmSitesManager", "$mmEvents", "md5", "mmFilepoolStore", "mmFilepoolLinksStore", "mmFilepoolQueueStore", "mmFilepoolFolder", "mmFilepoolQueueProcessInterval", "mmCoreEventQueueEmpty", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreNotDownloadable", "mmFilepoolPackagesStore", "mmCoreEventPackageStatusChanged", function($q, $log, $timeout, $mmApp, $mmFS, $mmWS, $mmSitesManager, $mmEvents, md5, mmFilepoolStore,
        mmFilepoolLinksStore, mmFilepoolQueueStore, mmFilepoolFolder, mmFilepoolQueueProcessInterval, mmCoreEventQueueEmpty,
        mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreNotDownloadable, mmFilepoolPackagesStore,
        mmCoreEventPackageStatusChanged) {

    $log = $log.getInstance('$mmFilepool');

    var self = {},
        extensionRegex = new RegExp('^[a-z0-9]+$'),
        tokenRegex = new RegExp('(\\?|&)token=([A-Za-z0-9]+)'),
        queueState,
        urlAttributes = [
            tokenRegex,
            new RegExp('(\\?|&)forcedownload=[0-1]')
        ],
        revisionRegex = new RegExp('/content/([0-9]+)/'),
        queueDeferreds = {}, // To handle file downloads using the queue.
        packagesPromises = {}, // To prevent downloading packages twice at the same time.
        filePromises = {}; // To prevent downloading files twice at the same time.

    // Queue status codes.
    var QUEUE_RUNNING = 'mmFilepool:QUEUE_RUNNING',
        QUEUE_PAUSED = 'mmFilepool:QUEUE_PAUSED';

    // Error codes.
    var ERR_QUEUE_IS_EMPTY = 'mmFilepoolError:ERR_QUEUE_IS_EMPTY',
        ERR_FS_OR_NETWORK_UNAVAILABLE = 'mmFilepoolError:ERR_FS_OR_NETWORK_UNAVAILABLE',
        ERR_QUEUE_ON_PAUSE = 'mmFilepoolError:ERR_QUEUE_ON_PAUSE';

    /**
     * Files states. Deprecated, please use core constants instead: mmCoreDownloaded, mmCoreDownloading, ...
     * @deprecated since version 2.6
     */
    self.FILEDOWNLOADED = 'downloaded';
    self.FILEDOWNLOADING = 'downloading';
    self.FILENOTDOWNLOADED = 'notdownloaded';
    self.FILEOUTDATED = 'outdated';

    /**
     * Convenient site DB getter.
     */
    function getSiteDb(siteId) {
        return $mmSitesManager.getSiteDb(siteId);
    }

    /**
     * Link a file with a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_addFileLink
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._addFileLink = function(siteId, fileId, component, componentId) {
        if (!component) {
            return $q.reject();
        }

        componentId = self._fixComponentId(componentId);
        return getSiteDb(siteId).then(function(db) {
            return db.insert(mmFilepoolLinksStore, {
                fileId: fileId,
                component: component,
                componentId: componentId
            });
        });
    };

    /**
     * Link a file with a component by URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#addFileLinkByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file Url.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @description
     * Use this method to create a link between a URL and a component. You usually do not need to call
     * this manually as adding a file to queue allows you to do so. Note that this method
     * does not check if the file exists in the pool, so you probably want to use is after
     * a successful {@link $mmFilepool#downloadUrl}.
     */
    self.addFileLinkByUrl = function(siteId, fileUrl, component, componentId) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._addFileLink(siteId, fileId, component, componentId);
        });
    };

    /**
     * Link a file with a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_addFileLinks
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @param {Object[]} links Array of objects containing the link component and optionally componentId.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._addFileLinks = function(siteId, fileId, links) {
        var promises = [];
        angular.forEach(links, function(link) {
            promises.push(self._addFileLink(siteId, fileId, link.component, link.componentId));
        });
        return $q.all(promises);
    };

    /**
     * Add a file to the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_addFileToPool
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @param {Object} data Additional information to store about the file (timemodified, url, ...). See mmFilepoolStore schema.
     * @return {Promise}
     * @protected
     * @description
     * Note that this method will override any existing entry with the same key.
     * That is the only way to update an entry.
     */
    self._addFileToPool = function(siteId, fileId, data) {
        var values = angular.copy(data) || {};
        values.fileId = fileId;
        return getSiteDb(siteId).then(function(db) {
            return db.insert(mmFilepoolStore, values);
        });
    };

    /**
     * Add an entry to queue using a URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#addToQueueByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} [component] The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component (optional).
     * @param {Number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {String} [filePath]       Filepath to download the file to.
     * @param {Number} [priority=0] The priority this file should get in the queue (range 0-999).
     * @return {Promise} Resolved on success. The returned value can be inconsistent, do not use.
     */
    self.addToQueueByUrl = function(siteId, fileUrl, component, componentId, timemodified, filePath, priority) {
        var db = $mmApp.getDB(),
            fileId,
            now = new Date(),
            link,
            revision,
            queueDeferred;

        if (!$mmFS.isAvailable()) {
            return $q.reject();
        }

        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {

            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            fileId = self._getFileIdByUrl(fileUrl);
            priority = priority || 0;

            // Set up the component.
            if (typeof component !== 'undefined') {
                link = {
                    component: component,
                    componentId: componentId
                };
            }

            // Retrieve the queue deferred now if it exists to prevent errors if file is removed from queue
            // while we're checking if the file is in queue.
            queueDeferred = self._getQueueDeferred(siteId, fileId, false);

            return db.get(mmFilepoolQueueStore, [siteId, fileId]).then(function(fileObject) {
                var foundLink = false,
                    update = false;

                if (fileObject) {
                    // We already have the file in queue, we update the priority and links.
                    if (fileObject.priority < priority) {
                        update = true;
                        fileObject.priority = priority;
                    }
                    if (revision && fileObject.revision !== revision) {
                        update = true;
                        fileObject.revision = revision;
                    }
                    if (timemodified && fileObject.timemodified !== timemodified) {
                        update = true;
                        fileObject.timemodified = timemodified;
                    }
                    if (filePath && fileObject.path !== filePath) {
                        update = true;
                        fileObject.path = filePath;
                    }

                    if (link) {
                        // We need to add the new link if it does not exist yet.
                        angular.forEach(fileObject.links, function(fileLink) {
                            if (fileLink.component == link.component && fileLink.componentId == link.componentId) {
                                foundLink = true;
                            }
                        });
                        if (!foundLink) {
                            update = true;
                            fileObject.links.push(link);
                        }
                    }

                    if (update) {
                        // Update only when required.
                        $log.debug('Updating file ' + fileId + ' which is already in queue');
                        return db.insert(mmFilepoolQueueStore, fileObject).then(function() {
                            return self._getQueuePromise(siteId, fileId);
                        });
                    }

                    $log.debug('File ' + fileId + ' already in queue and does not require update');
                    if (queueDeferred) {
                        // If we were able to retrieve the queue deferred before we use that one, since the file download
                        // might have finished now and the deferred wouldn't be in the array anymore.
                        return queueDeferred.promise;
                    } else {
                        return self._getQueuePromise(siteId, fileId);
                    }
                } else {
                    return addToQueue();
                }
            }, function() {
                // Unsure why we could not get the record, let's add to the queue anyway.
                return addToQueue();
            });

            function addToQueue() {
                $log.debug('Adding ' + fileId + ' to the queue');
                return db.insert(mmFilepoolQueueStore, {
                    siteId: siteId,
                    fileId: fileId,
                    added: now.getTime(),
                    priority: priority,
                    url: fileUrl,
                    revision: revision,
                    timemodified: timemodified,
                    path: filePath,
                    links: link ? [link] : []
                }).then(function() {
                    // Check if the queue is running.
                    self.checkQueueProcessing();
                    return self._getQueuePromise(siteId, fileId);
                });
            }
        });
    };

    /**
     * Check the queue processing.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#checkQueueProcessing
     * @return {Void}
     * @description
     * In mose cases, this will enable the queue processing if it was paused.
     * Though, this will disable the queue if we are missing network or if the file system
     * is not accessible. Also, this will have no effect if the queue is already running.
     *
     * Do not use directly, it is reserved for core use.
     */
    self.checkQueueProcessing = function() {

        if (!$mmFS.isAvailable() || !$mmApp.isOnline()) {
            queueState = QUEUE_PAUSED;
            return;

        } else if (queueState === QUEUE_RUNNING) {
            return;
        }

        queueState = QUEUE_RUNNING;
        self._processQueue();
    };

    /**
     * Clear all packages status in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#clearAllPackagesStatus
     * @param {String} siteId Site ID.
     * @return {Promise}      Promise resolved when all status are cleared.
     */
    self.clearAllPackagesStatus = function(siteId) {
        var promises = [];
        $log.debug('Clear all packages status for site ' + siteId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb();
            return db.getAll(mmFilepoolPackagesStore).then(function(entries) {
                angular.forEach(entries, function(entry) {
                    promises.push(db.remove(mmFilepoolPackagesStore, entry.id).then(function() {
                        // Trigger module status changed, setting it as not downloaded.
                        self._triggerPackageStatusChanged(siteId, entry.component, entry.componentId, mmCoreNotDownloaded);
                    }));
                });
                return $q.all(promises);
            });
        });
    };

    /**
     * Clears the filepool. Use it only when all the files from a site are deleted.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#clearFilepool
     * @param  {String} siteId ID of the site to clear.
     * @return {Promise}       Promise resolved when the filepool is cleared.
     */
    self.clearFilepool = function(siteId) {
        return getSiteDb(siteId).then(function(db) {
            return db.removeAll(mmFilepoolStore);
        });
    };

    /**
     * Returns whether a component has files in the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#componentHasFiles
     * @param {String} siteId The site ID.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved means yes, rejected means no.
     */
    self.componentHasFiles = function(siteId, component, componentId) {
        return getSiteDb(siteId).then(function(db) {
            var where;
            if (typeof componentId !== 'undefined') {
                where = ['componentAndId', '=', [component, self._fixComponentId(componentId)]];
            } else {
                where = ['component', '=', component];
            }
            return db.count(mmFilepoolLinksStore, where).then(function(count) {
                if (count > 0) {
                    return true;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Given the current status of a list of packages and the status of one of the packages,
     * determine the new status for the list of packages. The status of a list of packages is:
     *     - mmCoreNotDownloadable if there are no downloadable packages.
     *     - mmCoreNotDownloaded if at least 1 package has status mmCoreNotDownloaded.
     *     - mmCoreDownloaded if ALL the downloadable packages have status mmCoreDownloaded.
     *     - mmCoreDownloading if ALL the downloadable packages have status mmCoreDownloading or mmCoreDownloaded,
     *                                     with at least 1 package with mmCoreDownloading.
     *     - mmCoreOutdated if ALL the downloadable packages have status mmCoreOutdated or mmCoreDownloaded or
     *                                     mmCoreDownloading, with at least 1 package with mmCoreOutdated.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#determinePackagesStatus
     * @param {String} current       Current status of the list of packages.
     * @param {String} packagestatus Status of one of the packages.
     * @return {String}              New status for the list of packages;
     */
    self.determinePackagesStatus = function(current, packagestatus) {
        if (!current) {
            current = mmCoreNotDownloadable;
        }

        if (packagestatus === mmCoreNotDownloaded) {
            // If 1 package is not downloaded the status of the whole list will always be not downloaded.
            return mmCoreNotDownloaded;
        } else if (packagestatus === mmCoreDownloaded && current === mmCoreNotDownloadable) {
            // If all packages are downloaded or not downloadable with at least 1 downloaded, status will be downloaded.
            return mmCoreDownloaded;
        } else if (packagestatus === mmCoreDownloading && (current === mmCoreNotDownloadable || current === mmCoreDownloaded)) {
            // If all packages are downloading/downloaded/notdownloadable with at least 1 downloading, status will be downloading.
            return mmCoreDownloading;
        } else if (packagestatus === mmCoreOutdated && current !== mmCoreNotDownloaded) {
            // If there are no packages notdownloaded and there is at least 1 outdated, status will be outdated.
            return mmCoreOutdated;
        }

        // Status remains the same.
        return current;
    };

    /**
     * Downloads or prefetches a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_downloadOrPrefetchPackage
     * @param {String} siteId        The site ID.
     * @param  {Object[]} fileList   List of files to download.
     * @param  {Boolean} prefetch    True if should prefetch the contents (queue), false if they should be downloaded right now.
     * @param {String} component     The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [revision]    Package's revision. If not defined, it will be calculated using the list of files.
     * @param {Number} [timemod]     Package's timemodified. If not defined, it will be calculated using the list of files.
     * @param {String} [dirPath]     Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                               the files directly inside the filepool folder.
     * @return {Promise}             Promise resolved when all files are downloaded.
     * @protected
     */
    self._downloadOrPrefetchPackage = function(siteId, fileList, prefetch, component, componentId, revision, timemod, dirPath) {

        var packageId = self.getPackageId(component, componentId);

        if (packagesPromises[siteId] && packagesPromises[siteId][packageId]) {
            // There's already a download ongoing for this package, return the promise.
            return packagesPromises[siteId][packageId];
        } else if (!packagesPromises[siteId]) {
            packagesPromises[siteId] = {};
        }

        revision = revision || self.getRevisionFromFileList(fileList);
        timemod = timemod || self.getTimemodifiedFromFileList(fileList);

        var dwnPromise,
            deleted = false;

        // Set package as downloading.
        dwnPromise = self.storePackageStatus(siteId, component, componentId, mmCoreDownloading, revision, timemod).then(function() {
            var promises = [],
                deferred = $q.defer(),
                packageLoaded = 0; // Use a deferred to be able to use notify.

            angular.forEach(fileList, function(file) {
                var path,
                    promise,
                    fileLoaded = 0;

                if (dirPath) {
                    // Calculate the path to the file.
                    path = file.filename;
                    if (file.filepath !== '/') {
                        path = file.filepath.substr(1) + path;
                    }
                    path = $mmFS.concatenatePaths(dirPath, path);
                }

                if (prefetch) {
                    promise = self.addToQueueByUrl(siteId, file.fileurl, component, componentId, file.timemodified, path);
                } else {
                    promise = self.downloadUrl(siteId, file.fileurl, false, component, componentId, file.timemodified, path);
                }

                // Using undefined for success & fail will pass the success/failure to the parent promise.
                promises.push(promise.then(undefined, undefined, function(progress) {
                    if (progress && progress.loaded) {
                        // Add the new size loaded to the package loaded.
                        packageLoaded = packageLoaded + (progress.loaded - fileLoaded);
                        fileLoaded = progress.loaded;
                        deferred.notify({
                            packageDownload: true,
                            loaded: packageLoaded,
                            fileProgress: progress
                        });
                    }
                }));
            });

            $q.all(promises).then(function() {
                // Success prefetching, store package as downloaded.
                return self.storePackageStatus(siteId, component, componentId, mmCoreDownloaded, revision, timemod);
            }).catch(function() {
                // Error downloading, go back to previous status and reject the promise.
                return self.setPackagePreviousStatus(siteId, component, componentId).then(function() {
                    return $q.reject();
                });
            }).then(deferred.resolve, deferred.reject);

            return deferred.promise;
        }).finally(function() {
            // Download finished, delete the promise.
            delete packagesPromises[siteId][packageId];
            deleted = true;
        });

        if (!deleted) { // In case promise was finished immediately.
            packagesPromises[siteId][packageId] = dwnPromise;
        }
        return dwnPromise;
    };

    /**
     * Downloads a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#downloadPackage
     * @param {String} siteId         The site ID.
     * @param  {Object[]} fileList    List of files to download.
     * @param {String} component      The component to link the file to.
     * @param {Number} componentId    An ID to identify the download. Must be unique.
     * @param {Number} [revision]     Package's revision. If not defined, it will be calculated using the list of files.
     * @param {Number} [timemodified] Package's timemodified. If not defined, it will be calculated using the list of files.
     * @param {String} [dirPath]      Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                                the files directly inside the filepool folder.
     * @return {Promise}              Promise resolved when all files are downloaded.
     */
    self.downloadPackage = function(siteId, fileList, component, componentId, revision, timemodified, dirPath) {
        return self._downloadOrPrefetchPackage(siteId, fileList, false, component, componentId, revision, timemodified, dirPath);
    };

    /**
     * Downloads a file on the spot.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#downloadUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @param {Boolean} [ignoreStale] True if 'stale' should be ignored.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {String} [filePath]       Filepath to download the file to.
     * @return {Promise} Resolved with internal URL on success, rejected otherwise.
     * @description
     * Downloads a file on the spot.
     *
     * This will also take care of adding the file to the pool if it's missing.
     * However, please note that this will not force a file to be re-downloaded
     * if it is already part of the pool. You should mark a file as stale using
     * {@link $mmFilepool#invalidateFileByUrl} to trigger a download.
     *
     * See {@link $mmFilepool#_getInternalUrlById} for the type of local URL returned.
     */
    self.downloadUrl = function(siteId, fileUrl, ignoreStale, component, componentId, timemodified, filePath) {
        var fileId,
            revision,
            promise;

        if ($mmFS.isAvailable()) {
            return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
                timemodified = timemodified || 0;
                revision = self.getRevisionFromUrl(fileUrl);
                fileId = self._getFileIdByUrl(fileUrl);

                return self._hasFileInPool(siteId, fileId).then(function(fileObject) {

                    if (typeof fileObject === 'undefined') {
                        // We do not have the file, download and add to pool.
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath);

                    } else if (self._isFileOutdated(fileObject, revision, timemodified) && $mmApp.isOnline() && !ignoreStale) {
                        // The file is outdated, force the download and update it.
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject);
                    }

                    // Everything is fine, return the file on disk.
                    if (filePath) {
                        promise = self._getInternalUrlByPath(filePath);
                    } else {
                        promise = self._getInternalUrlById(siteId, fileId);
                    }
                    return promise.then(function(response) {
                        return response;
                    }, function() {
                        // The file was not found in the pool, weird.
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject);
                    });

                }, function() {
                    // The file is not in the pool just yet.
                    return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath);
                })
                .then(function(response) {
                    if (typeof component !== 'undefined') {
                        self._addFileLink(siteId, fileId, component, componentId);
                    }
                    self._notifyFileDownloaded(siteId, fileId);
                    return response;
                }, function(err) {
                    self._notifyFileDownloadError(siteId, fileId);
                    return $q.reject(err);
                });
            });
        } else {
            return $q.reject();
        }
    };

    /**
     * Downloads a URL and update or add it to the pool.
     *
     * This uses the file system, you should always make sure that it is
     * accessible before calling this method.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_downloadForPoolByUrl
     * @param {String} siteId           The site ID.
     * @param {String} fileUrl          The file URL.
     * @param {Number} [revision]       File revision number.
     * @param {Number} [timemodified]   The time this file was modified. Can be used to check file state.
     * @param {String} [filePath]       Filepath to download the file to.
     * @param {Object} [poolFileObject] When set, the object will be updated, a new entry will not be created.
     * @return {Promise} Resolved with internal URL on success, rejected otherwise.
     * @protected
     */
    self._downloadForPoolByUrl = function(siteId, fileUrl, revision, timemodified, filePath, poolFileObject) {
        var fileId = self._getFileIdByUrl(fileUrl);
        filePath = filePath || self._getFilePath(siteId, fileId);

        if (poolFileObject && poolFileObject.fileId !== fileId) {
            $log.error('Invalid object to update passed');
            return $q.reject();
        }

        var downloadId = self.getFileDownloadId(fileUrl, filePath),
            deleted = false,
            promise;

        if (filePromises[siteId] && filePromises[siteId][downloadId]) {
            // There's already a download ongoing for this file in this location, return the promise.
            return filePromises[siteId][downloadId];
        } else if (!filePromises[siteId]) {
            filePromises[siteId] = {};
        }

        promise = $mmSitesManager.getSite(siteId).then(function(site) {

            if (!site.canDownloadFiles()) {
                return $q.reject();
            }

            return $mmWS.downloadFile(fileUrl, filePath).then(function(fileEntry) {
                var now = new Date(),
                    data = poolFileObject || {};

                data.downloaded = now.getTime();
                data.stale = false;
                data.url = fileUrl;
                data.revision = revision;
                data.timemodified = timemodified;
                data.path = filePath;

                return self._addFileToPool(siteId, fileId, data).then(function() {
                    return fileEntry.toURL();
                });
            });
        }).finally(function() {
            // Download finished, delete the promise.
            delete filePromises[siteId][downloadId];
            deleted = true;
        });

        if (!deleted) { // In case promise was finished immediately.
            filePromises[siteId][downloadId] = promise;
        }
        return promise;
    };

    /**
     * Fix a component ID to always be a Number.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_fixComponentId
     * @param {String|Number|undefined} The component ID.
     * @return {Number} The normalised component ID. -1 when undefined was passed.
     * @protected
     */
    self._fixComponentId = function(componentId) {
        var id = parseInt(componentId, 10);
        if (isNaN(id)) {
            return -1;
        }
        return id;
    };

    /**
     * Add the wstoken url and points to the correct script.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_fixPluginfileURL
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise}       Resolved with fixed URL on success, rejected otherwise.
     * @protected
     */
    self._fixPluginfileURL = function(siteId, fileUrl) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.fixPluginfileURL(fileUrl);
        });
    };

    /**
     * Get the ID of a file download. Used to keep track of filePromises.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileDownloadId
     * @param {String} fileUrl  The file URL.
     * @param {String} filePath The file destination path.
     * @return {String}         File download ID.
     * @protected
     */
    self.getFileDownloadId = function(fileUrl, filePath) {
        return md5.createHash(fileUrl + '###' + filePath);
    };

    /**
     * Get the name of the event used to notify download events ($mmEvents).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileEventName
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {String}       Event name.
     * @protected
     */
    self._getFileEventName = function(siteId, fileId) {
        return 'mmFilepoolFile:'+siteId+':'+fileId;
    };

    /**
     * Get the name of the event used to notify download events ($mmEvents).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileEventNameByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @return {Promise}       Promise resolved with event name.
     */
    self.getFileEventNameByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._getFileEventName(siteId, fileId);
        });
    };

    /**
     * Get a download promise. If the promise is not set, return undefined.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackageDownloadPromise
     * @param {String} siteId        Site ID.
     * @param {String} component     The component of the package.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {String}             Download promise or undefined.
     */
    self.getPackageDownloadPromise = function(siteId, component, componentId) {
        var packageId = self.getPackageId(component, componentId);
        if (packagesPromises[siteId] && packagesPromises[siteId][packageId]) {
            return packagesPromises[siteId][packageId];
        }
    };

    /**
     * Get the ID of a package.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackageId
     * @param {String} component     Package's component.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {String}              Package ID.
     */
    self.getPackageId = function(component, componentId) {
        return md5.createHash(component + '#' + self._fixComponentId(componentId));
    };

    /**
     * Get a package previous status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackagePreviousStatus
     * @param {String} siteId           Site ID.
     * @param {String} component        Package's component.
     * @param {Number} [componentId]    An ID to use in conjunction with the component.
     * @return {Promise}                Promise resolved with the status.
     */
    self.getPackagePreviousStatus = function(siteId, component, componentId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                return entry.previous || mmCoreNotDownloaded;
            }, function() {
                return mmCoreNotDownloaded;
            });
        });
    };

    /**
     * Get a package status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getPackageStatus
     * @param {String} siteId              Site ID.
     * @param {String} component           Package's component.
     * @param {Number} [componentId]       An ID to use in conjunction with the component.
     * @param {Number|String} [revision=0] Package's revision.
     * @param {Number} [timemodified=0]    Package's timemodified.
     * @return {Promise}                   Promise resolved with the status.
     */
    self.getPackageStatus = function(siteId, component, componentId, revision, timemodified) {
        revision = revision || 0;
        timemodified = timemodified || 0;
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);

            // Get status.
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                if (entry.status === mmCoreDownloaded) {
                    if (revision != entry.revision || timemodified > entry.timemodified) {
                        // File is outdated. Let's change its status.
                        entry.status = mmCoreOutdated;
                        entry.updated = new Date().getTime();
                        db.insert(mmFilepoolPackagesStore, entry).then(function() {
                            // Success inserting, trigger event.
                            self._triggerPackageStatusChanged(siteId, component, componentId, mmCoreOutdated);
                        });
                    }
                } else if (entry.status === mmCoreOutdated) {
                    if (revision === entry.revision && timemodified === entry.timemodified) {
                        // File isn't outdated anymore. Let's change its status.
                        entry.status = mmCoreDownloaded;
                        entry.updated = new Date().getTime();
                        db.insert(mmFilepoolPackagesStore, entry).then(function() {
                            // Success inserting, trigger event.
                            self._triggerPackageStatusChanged(siteId, component, componentId, mmCoreDownloaded);
                        });
                    }
                }
                return entry.status;
            }, function() {
                return mmCoreNotDownloaded;
            });
        });
    };

    /**
     * Get the deferred object for a file in the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getQueueDeferred
     * @param {String} siteId         The site ID.
     * @param {String} fileId         The file ID.
     * @param {Boolean} [create=true] True if it should create a new deferred if it doesn't exist.
     * @return {Object}               Deferred.
     * @protected
     */
    self._getQueueDeferred = function(siteId, fileId, create) {
        if (typeof create == 'undefined') {
            create = true;
        }

        if (!queueDeferreds[siteId]) {
            if (!create) {
                return;
            }
            queueDeferreds[siteId] = {};
        }
        if (!queueDeferreds[siteId][fileId]) {
            if (!create) {
                return;
            }
            queueDeferreds[siteId][fileId] = $q.defer();
        }
        return queueDeferreds[siteId][fileId];
    };

    /**
     * Get the promise for a file in the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getQueuePromise
     * @param {String} siteId         The site ID.
     * @param {String} fileId         The file ID.
     * @param {Boolean} [create=true] True if it should create a new promise if it doesn't exist.
     * @return {Promise}              Promise.
     * @protected
     */
    self._getQueuePromise = function(siteId, fileId, create) {
        return self._getQueueDeferred(siteId, fileId, create).promise;
    };

    /**
     * Is the file already in the pool?
     *
     * This does not check if the file is on the disk.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_hasFileInPool
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Resolved with file object from DB on success, rejected otherwise.
     * @protected
     */
    self._hasFileInPool = function(siteId, fileId) {
        return getSiteDb(siteId).then(function(db) {
            return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                if (typeof fileObject === 'undefined') {
                    return $q.reject();
                }
                return fileObject;
            });
        });
    };

    /**
     * Is the file in queue?
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_hasFileInQueue
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Resolved with file object from DB on success, rejected otherwise.
     * @protected
     */
    self._hasFileInQueue = function(siteId, fileId) {
        return $mmApp.getDB().get(mmFilepoolQueueStore, [siteId, fileId]).then(function(fileObject) {
            if (typeof fileObject === 'undefined') {
                return $q.reject();
            }
            return fileObject;
        });
    };

    /**
     * Returns the local URL of a drectory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getInternalUrlByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise}       Resolved with the URL. Rejected otherwise.
     * @protected
     */
    self.getDirectoryUrlByUrl = function(siteId, fileUrl) {
        if ($mmFS.isAvailable()) {
            return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
                var fileId = self._getFileIdByUrl(fileUrl);
                return $mmFS.getDir(self._getFilePath(siteId, fileId)).then(function(dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return $q.reject();
    };

    /**
     * Creates a unique ID based on a URL.
     *
     * This has a minimal handling of pluginfiles in order to generate a clean
     * file ID which will not change if pointing to the same pluginfile URL even
     * if the token or extra attributes have changed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getFileIdByUrl
     * @param {String} fileUrl The absolute URL to the file.
     * @return {Promise} The file ID.
     * @protected
     */
    self._getFileIdByUrl = function(fileUrl) {
        var url = self._removeRevisionFromUrl(fileUrl),
            candidate,
            extension = '';

        if (url.indexOf('/webservice/pluginfile') !== -1) {
            // Remove attributes that do not matter.
            angular.forEach(urlAttributes, function(regex) {
                url = url.replace(regex, '');
            });

            // For now only guesses the extension of the plugin files. We need the extension
            // for the inAppBrowser to open the files properly, e.g. the extension needs to be
            // part of the file name. Also, we need the mimetype to open the file with
            // web intents. The easiest way to provide such information is to keep the extension
            // in the file ID. Developers should not care about it, but as we are using the
            // file ID in the file path, devs and system can guess it.
            candidate = self._guessExtensionFromUrl(url);
            if (candidate && candidate !== 'php') {
                extension = '.' + candidate;
            }
        }
        return md5.createHash('url:' + url) + extension;
    };

    /**
     * Returns an absolute URL to access the file URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getFileUrlByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified=0] The time this file was modified.
     * @return {Promise} Resolved with the URL to use. When rejected, nothing could be done.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     *
     * This handles the queue and validity of the file. When we have a local copy of the file
     * we will assess whether or not it is still valid. If it is not valid, or we did not find
     * the file, we will add it to the queue to be downloaded later and we will return the URL
     * we received. When the file is valid we return a local URL to it.
     *
     * When the file cannot be found, and we are offline, then we reject the promise because
     * there was nothing we could do.
     */
    self._getFileUrlByUrl = function(siteId, fileUrl, mode, component, componentId, timemodified) {
        var fileId,
            revision;

        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._hasFileInPool(siteId, fileId).then(function(fileObject) {
                var response,
                    addToQueue = false,
                    fn;

                if (typeof fileObject === 'undefined') {
                    // We do not have the file, add it to the queue, and return real URL.
                    self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                    response = fileUrl;

                } else if (self._isFileOutdated(fileObject, revision, timemodified) && $mmApp.isOnline()) {
                    // The file is outdated, we add to the queue and return real URL.
                    self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                    response = fileUrl;

                } else {
                    // We found the file entry, now look for the file on disk.

                    if (mode === 'src') {
                        fn = self._getInternalSrcById;
                    } else {
                        fn = self._getInternalUrlById;
                    }

                    response = fn(siteId, fileId).then(function(internalUrl) {
                        // Perfect, the file is on disk.
                        // For the time being we assume that the component link already exists.
                        return internalUrl;
                    }, function() {
                        // We have a problem here, we could not retrieve the file though we thought
                        // we had it, we will delete the entries associated with that ID.
                        $log.debug('File ' + fileId + ' not found on disk');
                        self._removeFileById(siteId, fileId);
                        self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);

                        if ($mmApp.isOnline()) {
                            // We still have a chance to serve the right content.
                            return fileUrl;
                        }

                        return $q.reject();
                    });
                }

                return response;
            }, function() {
                // We do not have the file in store yet.
                self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                return fileUrl;
            });
        });
    };

    /**
     * Get the path to a file.
     *
     * This does not check if the file exists or not.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getFilePath
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {String} The path to the file relative to storage root.
     * @protected
     */
    self._getFilePath = function(siteId, fileId) {
        return $mmFS.getSiteFolder(siteId) + '/' + mmFilepoolFolder + '/' + fileId;
    };

    /**
     * Get the path to a file from its URL.
     *
     * This does not check if the file exists or not.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFilePathByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Promise resolved with the path to the file relative to storage root.
     */
    self.getFilePathByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._getFilePath(siteId, fileId);
        });
    };

    /**
     * Returns the file state: mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded or mmCoreOutdated.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getFileStateByUrl
     * @param {String} siteId           The site ID.
     * @param {String} fileUrl          File URL.
     * @param {Number} [timemodified=0] The time this file was modified.
     * @return {Promise}                Promise resolved with the file state.
     */
    self.getFileStateByUrl = function(siteId, fileUrl, timemodified) {
        var fileId,
            revision;

        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            fileId = self._getFileIdByUrl(fileUrl);

            return self._hasFileInQueue(siteId, fileId).then(function() {
                return mmCoreDownloading;
            }, function() {
                return self._hasFileInPool(siteId, fileId).then(function(fileObject) {
                    if (self._isFileOutdated(fileObject, revision, timemodified)) {
                        return mmCoreOutdated;
                    } else {
                        return mmCoreDownloaded;
                    }
                }, function() {
                    return mmCoreNotDownloaded;
                });
            });
        });
    };

    /**
     * Returns the internal SRC of a file.
     *
     * The returned URL from this method is typically used with IMG tags.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getInternalSrcById
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved with the internal URL. Rejected otherwise.
     * @protected
     */
    self._getInternalSrcById = function(siteId, fileId) {
        if ($mmFS.isAvailable()) {
            return $mmFS.getFile(self._getFilePath(siteId, fileId)).then(function(fileEntry) {
                // We use toInternalURL so images are loaded in iOS8 using img HTML tags,
                // with toURL the OS is unable to find the image files.
                return $mmFS.getInternalURL(fileEntry);
            });
        }
        return $q.reject();
    };

    /**
     * Returns the local URL of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getInternalUrlById
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved with the URL. Rejected otherwise.
     * @protected
     */
    self._getInternalUrlById = function(siteId, fileId) {
        if ($mmFS.isAvailable()) {
            return $mmFS.getFile(self._getFilePath(siteId, fileId)).then(function(fileEntry) {
                return fileEntry.toURL();
            });
        }
        return $q.reject();
    };

    /**
     * Returns the local URL of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getInternalUrlByPath
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved with the URL. Rejected otherwise.
     * @protected
     */
    self._getInternalUrlByPath = function(filePath) {
        if ($mmFS.isAvailable()) {
            return $mmFS.getFile(filePath).then(function(fileEntry) {
                return fileEntry.toURL();
            });
        }
        return $q.reject();
    };

    /**
     * Get package revision number from a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getRevisionFromFileList
     * @param {Object[]} files Package files.
     * @return {Number}        Package revision.
     */
    self.getRevisionFromFileList = function(files) {
        var revision = 0;

        angular.forEach(files, function(file) {
            if (file.fileurl) {
                var r = self.getRevisionFromUrl(file.fileurl);
                if (r > revision) {
                    revision = r;
                }
            }
        });

        return revision;
    };

    /**
     * Get the revision number from a file URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_getRevisionFromUrl
     * @param {String} url URL to get the revision number.
     * @return {String}    Revision number.
     * @protected
     */
    self.getRevisionFromUrl = function(url) {
        var matches = url.match(revisionRegex);
        if (matches && typeof matches[1] != 'undefined') {
            return parseInt(matches[1]);
        }
    };

    /**
     * Returns an absolute URL to use in IMG tags.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getSrcByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified] The time this file was modified.
     * @return {Promise} Resolved with the URL to use. When rejected, nothing could be done,
     *                   which means that you should not even use the fileUrl passed.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with IMG tags.
     * See {@link $mmFilepool#_getFileUrlByUrl} for more details.
     */
    self.getSrcByUrl = function(siteId, fileUrl, component, componentId, timemodified) {
        return self._getFileUrlByUrl(siteId, fileUrl, 'src', component, componentId, timemodified);
    };

    /**
     * Get package timemodified from a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getTimemodifiedFromFileList
     * @param {Object[]} files Package files.
     * @return {Number}        Package time modified.
     */
    self.getTimemodifiedFromFileList = function(files) {
        var timemod = 0;

        angular.forEach(files, function(file) {
            if (file.timemodified > timemod) {
                timemod = file.timemodified;
            }
        });

        return timemod;
    };

    /**
     * Returns an absolute URL to access the file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#getUrlByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The absolute URL to the file.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {Number} [timemodified] The time this file was modified.
     * @return {Promise} Resolved with the URL to use. When rejected, nothing could be done,
     *                   which means that you should not even use the fileUrl passed.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with a local browser.
     * See {@link $mmFilepool#_getFileUrlByUrl} for more details.
     */
    self.getUrlByUrl = function(siteId, fileUrl, component, componentId, timemodified) {
        return self._getFileUrlByUrl(siteId, fileUrl, 'url', component, componentId, timemodified);
    };

    /**
     * Guess the extension of a file from its URL.
     *
     * This is very weak and unreliable.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_guessExtensionFromUrl
     * @param {String} fileUrl The file URL.
     * @return {String} The lowercased extension without the dot, or undefined.
     * @protected
     */
    self._guessExtensionFromUrl = function(fileUrl) {
        var split = fileUrl.split('.'),
            candidate,
            extension;

        if (split.length > 1) {
            candidate = split.pop().toLowerCase();
            if (extensionRegex.test(candidate)) {
                extension = candidate;
            }
        }

        return extension;
    };

    /**
     * Invalidate all the files in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#invalidateAllFiles
     * @param {String} siteId The site ID.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to ignore a failure.
     * @description
     * Invalidates all files by marking it stale. See {@link $mmFilepool#invalidateFileByUrl} for more details.
     */
    self.invalidateAllFiles = function(siteId) {
        return getSiteDb(siteId).then(function(db) {
            return db.getAll(mmFilepoolStore).then(function(items) {
                var promises = [];
                angular.forEach(items, function(item) {
                    item.stale = true;
                    promises.push(db.insert(mmFilepoolStore, item));
                });
                return $q.all(promises);
            });
        });
    };

    /**
     * Invalidate a file by URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#invalidateFileByUrl
     * @param {String} siteId The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to ignore a failure.
     * @description
     * Invalidates a file by marking it stale. It will not be added to the queue automatically,
     * but the next time this file will be requested it will be added to the queue. This is to allow
     * for cache invalidation without necessarily re-triggering downloads.
     * You can manully call {@link $mmFilepool#addToQueueByUrl} to counter this behaviour.
     * Please note that when a file is marked as stale, the user will be presented the stale file
     * only if they do not have network access.
     */
    self.invalidateFileByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return getSiteDb(siteId).then(function(db) {
                return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                    if (!fileObject) {
                        // Nothing to do, we do not have the file in store.
                        return;
                    }
                    fileObject.stale = true;
                    return db.insert(mmFilepoolStore, fileObject);
                });
            });
        });
    };

    /**
     * Invalidate all the matching files from a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#invalidateFilesByComponent
     * @param {String} siteId The site ID.
     * @param {String} component The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to ignore a failure.
     * @description
     * Invalidates a file by marking it stale. See {@link $mmFilepool#invalidateFileByUrl} for more details.
     */
    self.invalidateFilesByComponent = function(siteId, component, componentId) {
        var values = { stale: true },
            where;
        if (typeof componentId !== 'undefined') {
            where = ['componentAndId', '=', [component, self._fixComponentId(componentId)]];
        } else {
            where = ['component', '=', component];
        }

        return getSiteDb(siteId).then(function(db) {
            return db.query(mmFilepoolLinksStore, where).then(function(items) {
                var promise,
                    promises = [];

                angular.forEach(items, function(item) {
                    promise = db.get(mmFilepoolStore, item.fileId).then(function(fileEntry) {
                        if (!fileEntry) {
                            return;
                        }
                        fileEntry.stale = true;
                        return db.insert(mmFilepoolStore, fileEntry);
                    });
                    promises.push(promise);
                });

                return $q.all(promises);
            });
        });
    };

    /**
     * Check if a file is downloading.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#isFileDownloadingByUrl
     * @param {String} siteId           The site ID.
     * @param {String} fileUrl          File URL.
     * @param {Promise}                 Promise resolved if file is downloading, false otherwise.
     */
    self.isFileDownloadingByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            fileId = self._getFileIdByUrl(fileUrl);
            return self._hasFileInQueue(siteId, fileId);
        });
    };

    /**
     * Check if a file is outdated.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_isFileOutdated
     * @param {Object} fileObject     File object.
     * @param {Number} [revision]     File revision number.
     * @param {Number} [timemodified] The time this file was modified.
     * @param {Boolean}               True if file is outdated, false otherwise.
     */
    self._isFileOutdated = function(fileObject, revision, timemodified) {
        return fileObject.stale || revision > fileObject.revision || timemodified > fileObject.timemodified;
    };

    /**
     * Notify a file has been downloaded.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_notifyFileDownloaded
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     */
    self._notifyFileDownloaded = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {success: true});
    };

    /**
     * Notify error occurred while downloading a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_notifyFileDownloadError
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     */
    self._notifyFileDownloadError = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {success: false});
    };

    /**
     * Prefetches a list of files.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#prefetchPackage
     * @param {String} siteId         The site ID.
     * @param  {Object[]} fileList    List of files to download.
     * @param {String} component      The component to link the file to.
     * @param {Number} componentId    An ID to identify the download. Must be unique.
     * @param {Number} [revision]     Package's revision. If not defined, it will be calculated using the list of files.
     * @param {Number} [timemodified] Package's timemodified. If not defined, it will be calculated using the list of files.
     * @param {String} [dirPath]      Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                                the files directly inside the filepool folder.
     * @return {Promise}              Promise resolved when all files are downloaded.
     */
    self.prefetchPackage = function(siteId, fileList, component, componentId, revision, timemodified, dirPath) {
        return self._downloadOrPrefetchPackage(siteId, fileList, true, component, componentId, revision, timemodified, dirPath);
    };

    /**
     * Process the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_processQueue
     * @return {Void}
     * @description
     * Processes the queue.
     *
     * This loops over itself to keep on processing the queue in the background.
     * The queue process is site agnostic.
     */
    self._processQueue = function() {
        var deferred = $q.defer(),
            promise;

        if (queueState !== QUEUE_RUNNING) {
            // Silently ignore, the queue is on pause.
            deferred.reject(ERR_QUEUE_ON_PAUSE);
            promise = deferred.promise;

        } else if (!$mmFS.isAvailable() || !$mmApp.isOnline()) {
            deferred.reject(ERR_FS_OR_NETWORK_UNAVAILABLE);
            promise = deferred.promise;

        } else {
            promise = self._processImportantQueueItem();
        }

        promise.then(function() {
            // All good, we schedule next execution.
            $timeout(self._processQueue, mmFilepoolQueueProcessInterval);

        }, function(error) {

            // We had an error, in which case we pause the processing.
            if (error === ERR_FS_OR_NETWORK_UNAVAILABLE) {
                $log.debug('Filesysem or network unavailable, pausing queue processing.');

            } else if (error === ERR_QUEUE_IS_EMPTY) {
                $log.debug('Queue is empty, pausing queue processing.');
                $mmEvents.trigger(mmCoreEventQueueEmpty);
            }

            queueState = QUEUE_PAUSED;
        });
    };

    /**
     * Process the most important queue item.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_processImportantQueueItem
     * @return {Promise} Resolved on success. Rejected on failure.
     */
    self._processImportantQueueItem = function() {
        return $mmApp.getDB().query(mmFilepoolQueueStore, undefined, 'sortorder', undefined, 1)
        .then(function(items) {
            var item = items.pop();
            if (!item) {
                return $q.reject(ERR_QUEUE_IS_EMPTY);
            }
            return self._processQueueItem(item);
        }, function() {
            return $q.reject(ERR_QUEUE_IS_EMPTY);
        });
    };

    /**
     * Process a queue item.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_processQueueItem
     * @param {Object} item The object from the queue store.
     * @return {Promise} Resolved on success. Rejected on failure.
     * @protected
     */
    self._processQueueItem = function(item) {
        var siteId = item.siteId,
            fileId = item.fileId,
            fileUrl = item.url,
            revision = item.revision,
            timemodified = item.timemodified,
            filePath = item.path,
            links = item.links || [];

        $log.debug('Processing queue item: ' + siteId + ', ' + fileId);
        return getSiteDb(siteId).then(function(db) {
            return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                if (fileObject && !self._isFileOutdated(fileObject, revision, timemodified)) {
                    // We have the file, it is not stale, we can update links and remove from queue.
                    $log.debug('Queued file already in store, ignoring...');
                    self._addFileLinks(siteId, fileId, links);
                    self._removeFromQueue(siteId, fileId).finally(function() {
                        self._treatQueueDeferred(siteId, fileId, true);
                    });
                    self._notifyFileDownloaded(siteId, fileId);
                    return;
                }
                // The file does not exist, or is stale, ... download it.
                return download(siteId, fileUrl, fileObject, links);
            }, function() {
                // The file does not exist, download it.
                return download(siteId, fileUrl, undefined, links);
            });
        }, function() {
            // Couldn't get site DB, site was probably deleted.
            $log.debug('Item dropped from queue due to site DB not retrieved: ' + fileUrl);
            return self._removeFromQueue(siteId, fileId).catch(function() {}).finally(function() {
                self._treatQueueDeferred(siteId, fileId, false);
                self._notifyFileDownloadError(siteId, fileId);
            });
        });

        /**
         * Download helper to avoid code duplication.
         */
        function download(siteId, fileUrl, fileObject, links) {
            return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject).then(function() {
                var promise;

                // Success, we add links and remove from queue.
                self._addFileLinks(siteId, fileId, links);
                promise = self._removeFromQueue(siteId, fileId);

                self._treatQueueDeferred(siteId, fileId, true);
                self._notifyFileDownloaded(siteId, fileId);

                // Wait for the item to be removed from queue before resolving the promise.
                // If the item could not be removed from queue we still resolve the promise.
                return promise.catch(function() {});

            }, function(errorObject) {
                // Whoops, we have an error...
                var dropFromQueue = false;

                if (typeof errorObject !== 'undefined' && errorObject.source === fileUrl) {
                    // This is most likely a $cordovaFileTransfer error.

                    if (errorObject.code === 1) { // FILE_NOT_FOUND_ERR.
                        // The file was not found, most likely a 404, we remove from queue.
                        dropFromQueue = true;

                    } else if (errorObject.code === 2) { // INVALID_URL_ERR.
                        // The URL is invalid, we drop the file from the queue.
                        dropFromQueue = true;

                    } else if (errorObject.code === 3) { // CONNECTION_ERR.
                        // If there was an HTTP status, then let's remove from the queue.
                        dropFromQueue = true;
                    } else if (errorObject.code === 4) { // ABORTED_ERR.
                        // The transfer was aborted, we will keep the file in queue.
                    } else if (errorObject.code === 5) { // NOT_MODIFIED_ERR.
                        // We have the latest version of the file, HTTP 304 status.
                        dropFromQueue = true;
                    } else {
                        // Unknown error, let's remove the file from the queue to avoid
                        // locking down the queue because of one file.
                        dropFromQueue = true;
                    }
                } else {
                    dropFromQueue = true;
                }

                if (dropFromQueue) {
                    var promise;

                    $log.debug('Item dropped from queue due to error: ' + fileUrl);
                    promise = self._removeFromQueue(siteId, fileId);

                    // Consider this as a silent error, never reject the promise here.
                    return promise.catch(function() {}).finally(function() {
                        self._treatQueueDeferred(siteId, fileId, false);
                        self._notifyFileDownloadError(siteId, fileId);
                    });
                } else {
                    // We considered the file as legit but did not get it, failure.
                    self._treatQueueDeferred(siteId, fileId, false);
                    self._notifyFileDownloadError(siteId, fileId);
                    return $q.reject();
                }

            }, function(progress) {
                // Send the progress object to the queue deferred.
                if (queueDeferreds[siteId] && queueDeferreds[siteId][fileId]) {
                    queueDeferreds[siteId][fileId].notify(progress);
                }
            });
        }

    };

    /**
     * Remove a file from the queue.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_removeFromQueue
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._removeFromQueue = function(siteId, fileId) {
        return $mmApp.getDB().remove(mmFilepoolQueueStore, [siteId, fileId]);
    };

    /**
     * Remove a file from the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_removeFileById
     * @param {String} siteId The site ID.
     * @param {String} fileId The file ID.
     * @return {Promise} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     * @protected
     */
    self._removeFileById = function(siteId, fileId) {
        return getSiteDb(siteId).then(function(db) {
            var p1, p2, p3;
            p1 = db.remove(mmFilepoolStore, fileId);
            p2 = db.where(mmFilepoolLinksStore, 'fileId', '=', fileId).then(function(entries) {
                return $q.all(entries.map(function(entry) {
                    return db.remove(mmFilepoolLinksStore, [entry.fileId, entry.component, entry.componentId]);
                }));
            });
            p3 = $mmFS.isAvailable() ? $mmFS.removeFile(self._getFilePath(siteId, fileId)) : $q.when();
            return $q.all([p1, p2, p3]);
        });
    };

    /**
     * Delete all the matching files from a component.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#removeFilesByComponent
     * @param {String} siteId        The site ID.
     * @param {String} component     The component to link the file to.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise}             Resolved on success. Rejected on failure.
     */
    self.removeFilesByComponent = function(siteId, component, componentId) {
        var where;
        if (typeof componentId !== 'undefined') {
            where = ['componentAndId', '=', [component, self._fixComponentId(componentId)]];
        } else {
            where = ['component', '=', component];
        }

        return getSiteDb(siteId).then(function(db) {
            return db.query(mmFilepoolLinksStore, where);
        }).then(function(items) {
            return $q.all(items.map(function(item) {
                return self._removeFileById(siteId, item.fileId);
            }));
        });
    };

    /**
     * Remove a file from the pool.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#removeFileByUrl
     * @param {String} siteId  The site ID.
     * @param {String} fileUrl The file URL.
     * @return {Promise}       Resolved on success, rejected on failure. It is advised to silently ignore failures.
     */
    self.removeFileByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._removeFileById(siteId, fileId);
        });
    };

    /**
     * Removes the revision number from a file URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_removeRevisionFromUrl
     * @param {String} url URL to remove the revision number.
     * @return {String}    URL without revision number.
     * @protected
     * @description
     * The revision is used to know if a file has changed. We remove it from the URL to prevent storing a file per revision.
     */
    self._removeRevisionFromUrl = function(url) {
        return url.replace(revisionRegex, '/content/0/');
    };

    /**
     * Change the package status, setting it to the previous status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#setPackagePreviousStatus
     * @param {String} siteId        Site ID.
     * @param {String} component     Package's component.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise}             Promise resolved when the status is changed. Resolve param: new status.
     */
    self.setPackagePreviousStatus = function(siteId, component, componentId) {
        $log.debug('Set previous status for package ' + component + ' ' + componentId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);

            // Get current stored data, we'll only update 'status' and 'updated' fields.
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                entry.status = entry.previous || mmCoreNotDownloaded;
                entry.updated = new Date().getTime();
                $log.debug('Set status \'' + entry.status + '\' for package ' + component + ' ' + componentId);

                return db.insert(mmFilepoolPackagesStore, entry).then(function() {
                    // Success updating, trigger event.
                    self._triggerPackageStatusChanged(siteId, component, componentId, entry.status);
                    return entry.status;
                });
            });
        });
    };

    /**
     * Store package status.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#storePackageStatus
     * @param {String} siteId           Site ID.
     * @param {String} component        Package's component.
     * @param {Number} [componentId]    An ID to use in conjunction with the component.
     * @param {String} status           New package status.
     * @param {Number} [revision=0]     Package's revision.
     * @param {Number} [timemodified=0] Package's timemodified.
     * @return {Promise}                Promise resolved when status is stored.
     */
    self.storePackageStatus = function(siteId, component, componentId, status, revision, timemodified) {
        $log.debug('Set status \'' + status + '\' for package ' + component + ' ' + componentId);
        revision = revision || 0;
        timemodified = timemodified || 0;

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);

            // Search current status to set it as previous status.
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                return entry.status;
            }, function() {
                return undefined; // No previous status.
            }).then(function(previousStatus) {
                var promise;
                if (previousStatus === status) {
                    // The package already has this status, no need to change it.
                    promise = $q.when();
                } else {
                    promise = db.insert(mmFilepoolPackagesStore, {
                        id: packageId,
                        component: component,
                        componentId: componentId,
                        status: status,
                        previous: previousStatus,
                        revision: revision,
                        timemodified: timemodified,
                        updated: new Date().getTime()
                    });
                }

                return promise.then(function() {
                    // Success inserting, trigger event.
                    self._triggerPackageStatusChanged(siteId, component, componentId, status);
                });
            });
        });
    };

    /**
     * Resolves or rejects a queue deferred and removes it from the list.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_treatQueueDeferred
     * @param {String} siteId   The site ID.
     * @param {String} fileId   The file ID.
     * @param {Boolean} resolve True if promise should be resolved, false if it should be rejected.
     * @return {Object}         Deferred.
     * @protected
     */
    self._treatQueueDeferred = function(siteId, fileId, resolve) {
        if (queueDeferreds[siteId] && queueDeferreds[siteId][fileId]) {
            if (resolve) {
                queueDeferreds[siteId][fileId].resolve();
            } else {
                queueDeferreds[siteId][fileId].reject();
            }
            delete queueDeferreds[siteId][fileId];
        }
    };

    /**
     * Trigger mmCoreEventPackageStatusChanged with the right data.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFilepool#_triggerPackageStatusChanged
     * @param {String} siteId        Site ID.
     * @param {String} component     Package's component.
     * @param {Number} [componentId] An ID to use in conjunction with the component.
     * @param {String} status        New package status.
     * @return {Void}
     * @protected
     */
    self._triggerPackageStatusChanged = function(siteId, component, componentId, status) {
        var data = {
            siteid: siteId,
            component: component,
            componentId: componentId,
            status: status
        };
        $mmEvents.trigger(mmCoreEventPackageStatusChanged, data);
    };

    return self;
}])

.run(["$log", "$ionicPlatform", "$timeout", "$mmFilepool", function($log, $ionicPlatform, $timeout, $mmFilepool) {
    $log = $log.getInstance('$mmFilepool');

    $ionicPlatform.ready(function() {
        // Waiting for the platform to be ready, and a few more before we start processing the queue.
        $timeout($mmFilepool.checkQueueProcessing, 1000);
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmFsSitesFolder', 'sites')
.constant('mmFsTmpFolder', 'tmp')

/**
 * @ngdoc service
 * @name $mmFS
 * @module mm.core
 * @description
 * This service handles the interaction with the FileSystem.
 */
.factory('$mmFS', ["$ionicPlatform", "$cordovaFile", "$log", "$q", "$http", "$cordovaZip", "mmFsSitesFolder", "mmFsTmpFolder", function($ionicPlatform, $cordovaFile, $log, $q, $http, $cordovaZip, mmFsSitesFolder, mmFsTmpFolder) {

    $log = $log.getInstance('$mmFS');

    var self = {},
        initialized = false,
        basePath = '',
        isHTMLAPI = false,
        mimeTypes = {};

    // Loading all the mimetypes.
    $http.get('core/assets/mimetypes.json').then(function(response) {
        mimeTypes = response.data;
    }, function() {
        // It failed, never mind...
    });

    // Formats to read a file.
    self.FORMATTEXT         = 0;
    self.FORMATDATAURL      = 1;
    self.FORMATBINARYSTRING = 2;
    self.FORMATARRAYBUFFER  = 3;

    /**
     * Sets basePath to use with HTML API. Reserved for core use.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#setHTMLBasePath
     * @param {String} path Base path to use.
     */
    self.setHTMLBasePath = function(path) {
        isHTMLAPI = true;
        basePath = path;
    };

    /**
     * Checks if we're using HTML API.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#usesHTMLAPI
     * @return {Boolean} True if uses HTML API, false otherwise.
     */
    self.usesHTMLAPI = function() {
        return isHTMLAPI;
    };

    /**
     * Initialize basePath based on the OS if it's not initialized already.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#init
     * @return {Promise} Promise to be resolved when the initialization is finished.
     */
    self.init = function() {

        var deferred = $q.defer();

        if (initialized) {
            deferred.resolve();
            return deferred.promise;
        }

        $ionicPlatform.ready(function() {

            if (ionic.Platform.isAndroid()) {
                basePath = cordova.file.externalApplicationStorageDirectory;
            } else if (ionic.Platform.isIOS()) {
                basePath = cordova.file.documentsDirectory;
            } else if (!self.isAvailable() || basePath === '') {
                $log.error('Error getting device OS.');
                deferred.reject();
                return;
            }

            initialized = true;
            $log.debug('FS initialized: '+basePath);
            deferred.resolve();
        });

        return deferred.promise;
    };

    /**
     * Check if the plugin is available.
     *
     * @return {Boolean} True when cordova is initialised.
     */
    self.isAvailable = function() {
        return typeof window.resolveLocalFileSystemURL !== 'undefined' && typeof FileTransfer !== 'undefined';
    };

    /**
     * Get a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFile
     * @param  {String}  path Relative path to the file.
     * @return {Promise}      Promise to be resolved when the file is retrieved.
     */
    self.getFile = function(path) {
        return self.init().then(function() {
            $log.debug('Get file: '+path);
            return $cordovaFile.checkFile(basePath, path);
        });
    };

    /**
     * Get a directory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getDir
     * @param  {String}  path Relative path to the directory.
     * @return {Promise}      Promise to be resolved when the directory is retrieved.
     */
    self.getDir = function(path) {
        return self.init().then(function() {
            $log.debug('Get directory: '+path);
            return $cordovaFile.checkDir(basePath, path);
        });
    };

    /**
     * Get site folder path.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getSiteFolder
     * @param  {String} siteId Site ID.
     * @return {String}        Site folder path.
     */
    self.getSiteFolder = function(siteId) {
        return mmFsSitesFolder + '/' + siteId;
    };

    /**
     * Create a directory or a file.
     *
     * @param  {Boolean} isDirectory  True if a directory should be created, false if it should create a file.
     * @param  {String}  path         Relative path to the dir/file.
     * @param  {Boolean} failIfExists True if it should fail if the dir/file exists, false otherwise.
     * @param  {String}  base         Base path to create the dir/file in. If not set, use basePath.
     * @return {Promise}              Promise to be resolved when the dir/file is created.
     */
    function create(isDirectory, path, failIfExists, base) {
        return self.init().then(function() {
            base = base || basePath;

            if (path.indexOf('/') == -1) {
                if (isDirectory) {
                    $log.debug('Create dir ' + path + ' in ' + base);
                    return $cordovaFile.createDir(base, path, !failIfExists);
                } else {
                    $log.debug('Create file ' + path + ' in ' + base);
                    return $cordovaFile.createFile(base, path, !failIfExists);
                }
            } else {
                // $cordovaFile doesn't allow creating more than 1 level at a time (e.g. tmp/folder).
                // We need to create them 1 by 1.
                var firstDir = path.substr(0, path.indexOf('/'));
                var restOfPath = path.substr(path.indexOf('/') + 1);

                $log.debug('Create dir ' + firstDir + ' in ' + base);

                return $cordovaFile.createDir(base, firstDir, true).then(function(newDirEntry) {
                    return create(isDirectory, restOfPath, failIfExists, newDirEntry.toURL());
                }, function(error) {
                    $log.error('Error creating directory ' + firstDir + ' in ' + base);
                    return $q.reject(error);
                });
            }
        });
    }

    /**
     * Create a directory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#createDir
     * @param  {String}  path         Relative path to the directory.
     * @param  {Boolean} failIfExists True if it should fail if the directory exists, false otherwise.
     * @return {Promise}              Promise to be resolved when the directory is created.
     */
    self.createDir = function(path, failIfExists) {
        failIfExists = failIfExists || false; // Default value false.
        return create(true, path, failIfExists);
    };

    /**
     * Create a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#createFile
     * @param  {String}  path         Relative path to the file.
     * @param  {Boolean} failIfExists True if it should fail if the file exists, false otherwise..
     * @return {Promise}              Promise to be resolved when the file is created.
     */
    self.createFile = function(path, failIfExists) {
        failIfExists = failIfExists || false; // Default value false.
        return create(false, path, failIfExists);
    };

    /**
     * Removes a directory and all its contents.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeDir
     * @param  {String}  path    Relative path to the directory.
     * @return {Promise}         Promise to be resolved when the directory is deleted.
     */
    self.removeDir = function(path) {
        return self.init().then(function() {
            $log.debug('Remove directory: ' + path);
            return $cordovaFile.removeRecursively(basePath, path);
        });
    };

    /**
     * Removes a file and all its contents.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeFile
     * @param  {String}  path    Relative path to the file.
     * @return {Promise}         Promise to be resolved when the file is deleted.
     */
    self.removeFile = function(path) {
        return self.init().then(function() {
            $log.debug('Remove file: ' + path);
            return $cordovaFile.removeFile(basePath, path);
        });
    };

    /**
     * Retrieve the contents of a directory (not subdirectories).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getDirectoryContents
     * @param  {String} path Relative path to the directory.
     * @return {Promise}     Promise to be resolved when the contents are retrieved.
     */
    self.getDirectoryContents = function(path) {
        $log.debug('Get contents of dir: ' + path);
        return self.getDir(path).then(function(dirEntry) {

            var deferred = $q.defer();

            var directoryReader = dirEntry.createReader();
            directoryReader.readEntries(deferred.resolve, deferred.reject);

            return deferred.promise;
        });
    };

    /**
     * Calculate the size of a directory or a file.
     *
     * @param  {String} path Relative path to the directory or file.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    function getSize(entry) {

        var deferred = $q.defer();

        if (entry.isDirectory) {

            var directoryReader = entry.createReader();
            directoryReader.readEntries(function(entries) {

                var promises = [];
                for (var i = 0; i < entries.length; i++) {
                    promises.push(getSize(entries[i]));
                }

                $q.all(promises).then(function(sizes) {

                    var directorySize = 0;
                    for (var i = 0; i < sizes.length; i++) {
                        var fileSize = parseInt(sizes[i]);
                        if (isNaN(fileSize)) {
                            deferred.reject();
                            return;
                        }
                        directorySize += fileSize;
                    }
                    deferred.resolve(directorySize);

                }, deferred.reject);

            }, deferred.reject);

        } else if (entry.isFile) {
            entry.file(function(file) {
                deferred.resolve(file.size);
            }, deferred.reject);
        }

        return deferred.promise;
    }

    /**
     * Calculate the size of a directory.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getDirectorySize
     * @param  {String} path Relative path to the directory.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    self.getDirectorySize = function(path) {
        $log.debug('Get size of dir: ' + path);
        return self.getDir(path).then(function(dirEntry) {
           return getSize(dirEntry);
        });
    };

    /**
     * Calculate the size of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFileSize
     * @param  {String} path Relative path to the file.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    self.getFileSize = function(path) {
        $log.debug('Get size of file: ' + path);
        return self.getFile(path).then(function(fileEntry) {
           return getSize(fileEntry);
        });
    };

    /**
     * Get file object from a FileEntry.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFileSizeFromFileEntry
     * @param  {String} path Relative path to the file.
     * @return {Promise}     Promise to be resolved when the size is calculated.
     */
    self.getFileObjectFromFileEntry = function(entry) {
        $log.debug('Get file object of: ' + entry.fullPath);
        var deferred = $q.defer();
        entry.file(function(file) {
            deferred.resolve(file);
        }, deferred.reject);
        return deferred.promise;
    };

    /**
     * Calculate the free space in the disk.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#calculateFreeSpace
     * @return {Promise} Promise resolved with the estimated free space in bytes.
     */
    self.calculateFreeSpace = function() {
        if (ionic.Platform.isIOS() || isHTMLAPI) {
            // getFreeDiskSpace doesn't work on iOS. See https://tracker.moodle.org/browse/MOBILE-956.
            // Ugly fix: request a file system instance with a minimum size until we get an error.

            if (window.requestFileSystem) {

                var iterations = 0,
                    maxIterations = 50,
                    deferred = $q.defer();

                function calculateByRequest(size, ratio) {
                    var deferred = $q.defer();

                    window.requestFileSystem(LocalFileSystem.PERSISTENT, size, function() {
                        iterations++;
                        if (iterations > maxIterations) {
                            deferred.resolve(size);
                            return;
                        }
                        calculateByRequest(size * ratio, ratio).then(deferred.resolve);
                    }, function() {
                        deferred.resolve(size / ratio);
                    });

                    return deferred.promise;
                };

                // General calculation, base 1MB and increasing factor 1.3.
                calculateByRequest(1048576, 1.3).then(function(size) {
                    iterations = 0;
                    maxIterations = 10;
                    // More accurate. Factor is 1.1.
                    calculateByRequest(size, 1.1).then(deferred.resolve);
                });

                return deferred.promise;
            } else {
                return $q.reject();
            }

        } else {
            return $cordovaFile.getFreeDiskSpace().then(function(size) {
                return size * 1024; // GetFreeDiskSpace returns KB.
            });
        }
    };

    /**
     * Normalize a filename that usually comes URL encoded.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#normalizeFileName
     * @param  {String} filename The file name.
     * @return {String}          The file name normalized.
     */
    self.normalizeFileName = function(filename) {
        filename = decodeURIComponent(filename);
        return filename;
    };

    /**
     * Read a file from local file system.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#readFile
     * @param  {String}  path   Relative path to the file.
     * @param  {Number}  format Format to read the file. By default, FORMATTEXT. Must be one of:
     *                                  $mmFS.FORMATTEXT
     *                                  $mmFS.FORMATDATAURL
     *                                  $mmFS.FORMATBINARYSTRING
     *                                  $mmFS.FORMATARRAYBUFFER
     * @return {Promise}        Promise to be resolved when the file is read.
     */
    self.readFile = function(path, format) {
        format = format || self.FORMATTEXT;
        $log.debug('Read file ' + path + ' with format '+format);
        switch (format) {
            case self.FORMATDATAURL:
                return $cordovaFile.readAsDataURL(basePath, path);
            case self.FORMATBINARYSTRING:
                return $cordovaFile.readAsBinaryString(basePath, path);
            case self.FORMATARRAYBUFFER:
                return $cordovaFile.readAsArrayBuffer(basePath, path);
            default:
                return $cordovaFile.readAsText(basePath, path);
        }
    };

    /**
     * Read file contents from a file data object.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#readFileData
     * @param  {Object}  fileData File's data.
     * @param  {Number}  format   Format to read the file. By default, FORMATTEXT. Must be one of:
     *                                  $mmFS.FORMATTEXT
     *                                  $mmFS.FORMATDATAURL
     *                                  $mmFS.FORMATBINARYSTRING
     *                                  $mmFS.FORMATARRAYBUFFER
     * @return {Promise}          Promise to be resolved when the file is read.
     */
    self.readFileData = function(fileData, format) {
        format = format || self.FORMATTEXT;
        $log.debug('Read file from file data with format '+format);

        var deferred = $q.defer();

        var reader = new FileReader();
        reader.onloadend = function(evt) {
            if (evt.target.result !== undefined || evt.target.result !== null) {
                deferred.resolve(evt.target.result);
            } else if (evt.target.error !== undefined || evt.target.error !== null) {
                deferred.reject(evt.target.error);
            } else {
                deferred.reject({code: null, message: 'READER_ONLOADEND_ERR'});
            }
        };

        switch (format) {
            case self.FORMATDATAURL:
                reader.readAsDataURL(fileData);
                break;
            case self.FORMATBINARYSTRING:
                reader.readAsBinaryString(fileData);
                break;
            case self.FORMATARRAYBUFFER:
                reader.readAsArrayBuffer(fileData);
                break;
            default:
                reader.readAsText(fileData);
        }

        return deferred.promise;
    };

    /**
     * Writes some data in a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#writeFile
     * @param  {String}  path Relative path to the file.
     * @param  {String}  data Data to write.
     * @return {Promise}      Promise to be resolved when the file is written.
     */
    self.writeFile = function(path, data) {
        $log.debug('Write file: ' + path);
        return self.init().then(function() {
            // Create file (and parent folders) to prevent errors.
            return self.createFile(path).then(function(fileEntry) {
                if (isHTMLAPI && typeof data == 'string') {
                    // We need to write Blobs.
                    var type = self.getMimeType(self.getFileExtension(path));
                    data = new Blob([data], {type: type || 'text/plain'});
                }
                return $cordovaFile.writeFile(basePath, path, data, true).then(function() {
                    return fileEntry;
                });
            });
        });
    };

    /**
     * Gets a file that might be outside the app's folder.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getExternalFile
     * @param  {String}  fullPath Absolute path to the file.
     * @return {Promise}          Promise to be resolved when the file is retrieved.
     */
    self.getExternalFile = function(fullPath) {
        return $cordovaFile.checkFile(fullPath, '');
    };

    /**
     * Removes a file that might be outside the app's folder.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeExternalFile
     * @param  {String}  fullPath Absolute path to the file.
     * @return {Promise}          Promise to be resolved when the file is removed.
     */
    self.removeExternalFile = function(fullPath) {
        // removeFile(fullPath, '') does not work, we need to pass two valid parameters.
        var directory = fullPath.substring(0, fullPath.lastIndexOf('/') );
        var filename = fullPath.substr(fullPath.lastIndexOf('/') + 1);
        return $cordovaFile.removeFile(directory, filename);
    };

    /**
     * Get the base path where the application files are stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getBasePath
     * @return {Promise} Promise to be resolved when the base path is retrieved.
     */
    self.getBasePath = function() {
        return self.init().then(function() {
            if (basePath.slice(-1) == '/') {
                return basePath;
            } else {
                return basePath + '/';
            }
        });
    };

    /**
     * Get the base path where the application files are stored in the format to be used for downloads.
     * iOS: Internal URL (cdvfile://).
     * Others: basePath (file://)
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getBasePathToDownload
     * @return {Promise} Promise to be resolved when the base path is retrieved.
     */
    self.getBasePathToDownload = function() {
        return self.init().then(function() {
            if (ionic.Platform.isIOS()) {
                // In iOS we want the internal URL (cdvfile://localhost/persistent/...).
                return $cordovaFile.checkDir(basePath, '').then(function(dirEntry) {
                    return dirEntry.toInternalURL();
                });
            } else {
                // In the other platforms we use the basePath as it is (file://...).
                return basePath;
            }
        });
    };

    /**
     * Get temporary directory path.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getTmpFolder
     * @return {String} Tmp directory path.
     */
    self.getTmpFolder = function() {
        return mmFsTmpFolder;
    };

    /**
     * Move a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#moveEntry
     * @param {String} originalPath Path to the file to move.
     * @param {String} newPath      New path of the file.
     * @return {Promise}            Promise resolved when the entry is moved.
     */
    self.moveFile = function(originalPath, newPath) {
        return self.init().then(function() {
            if (isHTMLAPI) {
                // In Cordova API we need to calculate the longest matching path to make it work.
                // $cordovaFile.moveFile('a/', 'b/c.ext', 'a/', 'b/d.ext') doesn't work.
                // cordovaFile.moveFile('a/b/', 'c.ext', 'a/b/', 'd.ext') works.
                var commonPath = basePath,
                    dirsA = originalPath.split('/'),
                    dirsB = newPath.split('/');

                for (var i = 0; i < dirsA.length; i++) {
                    var dir = dirsA[i];
                    if (dirsB[i] === dir) {
                        // Found a common folder, add it to common path and remove it from each specific path.
                        dir = dir + '/';
                        commonPath = self.concatenatePaths(commonPath, dir);
                        originalPath = originalPath.replace(dir, '');
                        newPath = newPath.replace(dir, '');
                    } else {
                        // Folder doesn't match, stop searching.
                        break;
                    }
                }

                return $cordovaFile.moveFile(commonPath, originalPath, commonPath, newPath);
            } else {
                return $cordovaFile.moveFile(basePath, originalPath, basePath, newPath);
            }
        });
    };

    /**
     * Copy a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#copyFile
     * @param {String} from   Path to the file to move.
     * @param {String} to     New path of the file.
     * @return {Promise}      Promise resolved when the entry is copied.
     */
    self.copyFile = function(from, to) {
        return self.init().then(function() {
            // Check if to contains a directory.
            var toFile = self.getFileAndDirectoryFromPath(to);
            if (toFile.directory == '') {
                return $cordovaFile.copyFile(basePath, from, basePath, to);
            } else {
                // Ensure directory is created.
                return self.createDir(toFile.directory).then(function() {
                    return $cordovaFile.copyFile(basePath, from, basePath, to);
                });
            }
        });
    };

    /**
     * Extract the file name and directory from a given path.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getFileAndDirectoryFromPath
     * @param {String} path   Path to be extracted.
     * @return {Object}       Plain object containing the file name and directory.
     * @description
     * file.pdf         -> directory: '', name: 'file.pdf'
     * /file.pdf        -> directory: '', name: 'file.pdf'
     * path/file.pdf    -> directory: 'path', name: 'file.pdf'
     * path/            -> directory: 'path', name: ''
     * path             -> directory: '', name: 'path'
     */
    self.getFileAndDirectoryFromPath = function(path) {
        var file = {
            directory: '',
            name: ''
        };

        file.directory = path.substring(0, path.lastIndexOf('/') );
        file.name = path.substr(path.lastIndexOf('/') + 1);

        return file;
    };

    /**
     * Concatenate two paths, adding a slash between them if needed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#concatenatePaths
     * @param {String} leftPath  Left path.
     * @param {String} rightPath Right path.
     * @return {String}          Concatenated path.
     */
    self.concatenatePaths = function(leftPath, rightPath) {
        var lastCharLeft = leftPath.slice(-1),
            firstCharRight = rightPath.charAt(0);

        if (lastCharLeft === '/' && firstCharRight === '/') {
            return leftPath + rightPath.substr(1);
        } else if(lastCharLeft !== '/' && firstCharRight !== '/') {
            return leftPath + '/' + rightPath;
        } else {
            return leftPath + rightPath;
        }
    };

    /**
     * Get the internal URL of a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#getInternalURL
     * @param  {Object} fileEntry File Entry.
     * @return {String}           Internal URL.
     */
    self.getInternalURL = function(fileEntry) {
        if (isHTMLAPI) {
            // HTML API doesn't implement toInternalURL.
            return fileEntry.toURL();
        }
        return fileEntry.toInternalURL();
    };

    /**
     * Get a file icon URL based on its file name.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#getFileIcon
     * @param  {String} The name of the file.
     * @return {String} The path to a file icon.
     */
    self.getFileIcon = function(filename) {
        var ext = self.getFileExtension(filename),
            icon;

        if (ext && mimeTypes[ext] && mimeTypes[ext].icon) {
            icon = mimeTypes[ext].icon + '-64.png';
        } else {
            icon = 'unknown-64.png';
        }

        return 'img/files/' + icon;
    };

    /**
     * Get the folder icon URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#getFolderIcon
     * @return {String} The path to a folder icon.
     */
    self.getFolderIcon = function() {
        return 'img/files/folder-64.png';
    };

    /**
     * Returns the file extension of a file.
     *
     * When the file does not have an extension, it returns undefined.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#getFileExtension
     * @param  {string} filename The file name.
     * @return {string}          The lowercased extension, or undefined.
     */
    self.getFileExtension = function(filename) {
        var dot = filename.lastIndexOf("."),
            ext;

        if (dot > -1) {
            ext = filename.substr(dot + 1).toLowerCase();
        }

        return ext;
    };

    /**
     * Get the mimetype of an extension. Returns undefined if not found.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtil#allPromises
     * @param  {String} extension Extension.
     * @return {String}           Mimetype.
     */
    self.getMimeType = function(extension) {
        if (mimeTypes[extension] && mimeTypes[extension].type) {
            return mimeTypes[extension].type;
        }
    };

    /**
     * Remove the extension from a path (if any).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#removeExtension
     * @param  {String} path Path.
     * @return {String}      Path without extension.
     */
    self.removeExtension = function(path) {
        var index = path.lastIndexOf('.');
        if (index > -1) {
            return path.substr(0, index); // Remove extension.
        }
        return path;
    };

    /**
     * Adds the basePath to a path if it doesn't have it already.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#addBasePathIfNeeded
     * @param {String} path Path to treat.
     * @return {String}     Path with basePath added.
     */
    self.addBasePathIfNeeded = function(path) {
        if (path.indexOf(basePath) > -1) {
            return path;
        } else {
            return self.concatenatePaths(basePath, path);
        }
    };

    /**
     * Unzips a file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmFS#unzipFile
     * @param  {String} path         Path to the ZIP file.
     * @param  {String} [destFolder] Path to the destination folder. If not defined, a new folder will be created with the
     *                               same location and name as the ZIP file (without extension).
     * @return {Promise}             Promise resolved when the file is unzipped.
     */
    self.unzipFile = function(path, destFolder) {
        // We need to use ansolute paths (including basePath).
        path = self.addBasePathIfNeeded(path);
         // If destFolder is not set, use same location as ZIP file.
        destFolder = self.addBasePathIfNeeded(destFolder || self.removeExtension(path));
        return $cordovaZip.unzip(path, destFolder);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Service to handle groups.
 *
 * @module mm.core.groups
 * @ngdoc service
 * @name $mmGroups
 */
.factory('$mmGroups', ["$log", "$q", "$mmSite", "$mmSitesManager", function($log, $q, $mmSite, $mmSitesManager) {

    $log = $log.getInstance('$mmGroups');

    // Group mode constants.
    self.NOGROUPS       = 0;
    self.SEPARATEGROUPS = 1;
    self.VISIBLEGROUPS  = 2;

    /**
     * Get the groups allowed in an activity.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getActivityAllowedGroups
     * @param {Number} cmid     Course module ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise}        Promise resolved when the groups are retrieved.
     */
    self.getActivityAllowedGroups = function(cmid, userid) {
        userid = userid || $mmSite.getUserId();

        var params = {
                cmid: cmid,
                userid: userid
            },
            preSets = {
                cacheKey: getActivityAllowedGroupsCacheKey(cmid, userid)
            };

        return $mmSite.read('core_group_get_activity_allowed_groups', params, preSets).then(function(response) {
            if (!response || !response.groups) {
                return $q.reject();
            }
            return response.groups;
        });
    };

    /**
     * Get cache key for group mode WS calls.
     *
     * @param {Number} cmid Course module ID.
     * @return {String}     Cache key.
     */
    function getActivityAllowedGroupsCacheKey(cmid, userid) {
        return 'mmGroups:allowedgroups:' + cmid + ':' + userid;
    }

    /**
     * Get the group mode of an activity.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getActivityGroupMode
     * @param {Number} cmid Course module ID.
     * @return {Promise}    Promise resolved when the group mode is retrieved.
     */
    self.getActivityGroupMode = function(cmid) {
        var params = {
                cmid: cmid
            },
            preSets = {
                cacheKey: getActivityGroupModeCacheKey(cmid)
            };

        return $mmSite.read('core_group_get_activity_groupmode', params, preSets).then(function(response) {
            if (!response || typeof response.groupmode == 'undefined') {
                return $q.reject();
            }
            return response.groupmode;
        });
    };

    /**
     * Get cache key for group mode WS calls.
     *
     * @param {Number} cmid Course module ID.
     * @return {String}     Cache key.
     */
    function getActivityGroupModeCacheKey(cmid) {
        return 'mmGroups:groupmode:' + cmid;
    }

    /**
     * Get user groups in courses.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getUserGroups
     * @param {Object[]|Number[]} courses List of courses or course ids to get the groups from.
     * @param {Boolean} [refresh]         True when we should not get the value from the cache.
     * @param {String} [siteid]           Site to get the groups from. If not defined, use current site.
     * @param {Number} [userid]           ID of the user. If not defined, use the userid related to siteid.
     * @return {Promise}                  Promise to be resolved when the groups are retrieved.
     */
    self.getUserGroups = function(courses, refresh, siteid, userid) {
        var promises = [],
            groups = [],
            deferred = $q.defer();

        angular.forEach(courses, function(course) {
            var courseid;
            if (typeof course == 'object') { // Param is array of courses.
                courseid = course.id;
            } else { // Param is array of courseids.
                courseid = course;
            }
            var promise = self.getUserGroupsInCourse(courseid, refresh, siteid, userid).then(function(coursegroups) {
                groups = groups.concat(coursegroups);
            });
            promises.push(promise);
        });

        $q.all(promises).finally(function() {
            // Use finally because we don't want to block the load of events if a request fails.
            deferred.resolve(groups);
        });

        return deferred.promise;
    };

    /**
     * Get user groups in a course.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#getUserGroupsInCourse
     * @param {Number} courseid   ID of the course.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @param {String} [siteid]   Site to get the groups from. If not defined, use current site.
     * @param {Number} [userid]   ID of the user. If not defined, use ID related to siteid.
     * @return {Promise}        Promise to be resolved when the groups are retrieved.
     */
    self.getUserGroupsInCourse = function(courseid, refresh, siteid, userid) {
        siteid = siteid || $mmSite.getId();

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var presets = {},
                data = {
                    userid: userid || site.getUserId(),
                    courseid: courseid
                };
            if (refresh) {
                presets.getFromCache = false;
            }
            return site.read('core_group_get_course_user_groups', data, presets).then(function(response) {
                if (response && response.groups) {
                    return response.groups;
                } else {
                    return $q.reject();
                }
            });
        });
    };

    /**
     * Invalidates activity allowed groups.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#invalidateActivityAllowedGroups
     * @param {Number} cmid     Course module ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateActivityAllowedGroups = function(cmid, userid) {
        userid = userid || $mmSite.getUserId();
        return $mmSite.invalidateWsCacheForKey(getActivityAllowedGroupsCacheKey(cmid, userid));
    };

    /**
     * Invalidates activity group mode.
     *
     * @module mm.core.groups
     * @ngdoc method
     * @name $mmGroups#invalidateActivityGroupMode
     * @param {Number} cmid Course module ID.
     * @return {Promise}    Promise resolved when the data is invalidated.
     */
    self.invalidateActivityGroupMode = function(cmid) {
        return $mmSite.invalidateWsCacheForKey(getActivityGroupModeCacheKey(cmid));
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * The default priority for init processes.
 * @module mm.core
 * @ngdoc constant
 * @name mmInitDelegateDefaultPriority
 */
.constant('mmInitDelegateDefaultPriority', 100)

/**
 * The maximum priority that an addon can use for init process, anything over that is reserved for core use.
 * @module mm.core
 * @ngdoc constant
 * @name mmInitDelegateMaxAddonPriority
 */
.constant('mmInitDelegateMaxAddonPriority', 599)

/**
 * Provider for initialisation mechanisms.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmInitDelegate
 */
.provider('$mmInitDelegate', ["mmInitDelegateDefaultPriority", function(mmInitDelegateDefaultPriority) {
    var initProcesses = {},
        self = {};

    /**
     * Registers an initialisation process.
     *
     * @description
     * Init processes can be used to add initialisation logic to the app. Anything that should
     * block the user interface while some processes are done should be an init process. When defining
     * an init process make sure you do not set a priority higher than mmInitDelegateMaxAddonPriority
     * in your addons. This is to make sure that your process does not happen before some essential
     * other core processes such as the upgrade, and restoring the user session.
     *
     * An init process should never change state or prompt user interaction.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmInitDelegateProvider#registerProcess
     * @param {String} name The name of the process.
     * @param {String|Function} callable The callable of the process. See {@link $mmUtil.resolveObject}.
     *                                   The resolved function will get $injector as first argument.
     * @param {Number} [priority=100] The priority of the process, the highest priority is executed first.
     * @param {Boolean} [blocking=false] Set this to true when this process should be resolved before any following one.
     * @return {Void}
     */
    self.registerProcess = function(name, callable, priority, blocking) {
        priority = typeof priority === 'undefined' ? mmInitDelegateDefaultPriority : priority;

        if (typeof initProcesses[name] !== 'undefined') {
            console.log('$mmInitDelegateProvider: Process \'' + name + '\' already defined.');
            return;
        }

        console.log('$mmInitDelegateProvider: Registered process \'' + name + '\'.');
        initProcesses[name] = {
            blocking: blocking,
            callable: callable,
            name: name,
            priority: priority
        };
    };

    self.$get = ["$q", "$log", "$injector", "$mmUtil", function($q, $log, $injector, $mmUtil) {

        $log = $log.getInstance('$mmInitDelegate');

        var self = {},
            readiness;

        /**
         * Convenience function to return a function that executes the process.
         *
         * @param  {Object} data The data of the process.
         * @return {Function}
         */
        function prepareProcess(data) {
            return function() {
                var promise,
                    fn;

                $log.debug('Executing init process \'' + data.name + '\'');

                try {
                    fn = $mmUtil.resolveObject(data.callable);
                } catch (e) {
                    $log.error('Could not resolve object of init process \'' + data.name + '\'. ' + e);
                    return;
                }

                try {
                    promise = fn($injector);
                } catch (e) {
                    $log.error('Error while calling the init process \'' + data.name + '\'. ' + e);
                    return;
                }

                return promise;
            };
        }

        /**
         * Executes the registered init processes.
         *
         * Reserved for core use, do not call directly.
         *
         * @module mm.core
         * @ngdoc service
         * @name $mmInitDelegate#executeInitProcesses
         * @protected
         * @return {Void}
         */
        self.executeInitProcesses = function() {
            var ordered = [],
                promises = [],
                dependency = $q.when();

            if (typeof readiness === 'undefined') {
                readiness = $q.defer();
            }

            // Re-ordering by priority.
            angular.forEach(initProcesses, function(data) {
                ordered.push(data);
            });
            ordered.sort(function(a, b) {
                return b.priority - a.priority;
            });

            // Execute all the processes.
            angular.forEach(ordered, function(data) {
                var promise;

                // Add the process to the dependency stack.
                promise = dependency.finally(prepareProcess(data));
                promises.push(promise);

                // If the new process is blocking, we set it as the dependency.
                if (data.blocking) {
                    dependency = promise;
                }
            });

            $q.all(promises).finally(readiness.resolve);
        };

        /**
         * Notifies when the app is ready.
         *
         * This returns a promise that is resolved when the app is initialised.
         *
         * Reserved for core use, do not call directly, use {@link $mmApp.ready} instead.
         *
         * @module mm.core
         * @ngdoc service
         * @name $mmInitDelegate#ready
         * @protected
         * @return {Promise} Resolved when the app is initialised. Never rejected.
         */
        self.ready = function() {
            if (typeof readiness === 'undefined') {
                // Prevent race conditions if this is called before executeInitProcesses.
                readiness = $q.defer();
            }

            return readiness.promise;
        };

        return self;
    }];

    return self;
}]);

/**
 * ionRadioFix - fixes a bug in iOS 9 UIWebView that breaks the tilde selector in CSS. To
 * use this fix, include it after your Ionic bundle JS.
 *
 * Note: due to Angular directive override limitations, you'll need to change any reference
 * to <ion-radio> to <ion-radio-fix> to apply this patched radio button.
 *
 * Also, make sure to add the new CSS from the second part of this gist.
 */
angular.module('ionic').directive('ionRadioFix', function() {
  return {
    restrict: 'E',
    replace: true,
    require: '?ngModel',
    transclude: true,
    template:
      '<label class="item item-radio">' +
        '<input type="radio" name="radio-group">' +
        '<div class="radio-content">' +
          '<div class="item-content disable-pointer-events" ng-transclude></div>' +
          '<i class="radio-icon disable-pointer-events icon ion-checkmark"></i>' +
        '</div>' +
      '</label>',

    compile: function(element, attr) {
      if (attr.icon) {
        var iconElm = element.find('i');
        iconElm.removeClass('ion-checkmark').addClass(attr.icon);
      }

      var input = element.find('input');
      angular.forEach({
          'name': attr.name,
          'value': attr.value,
          'disabled': attr.disabled,
          'ng-value': attr.ngValue,
          'ng-model': attr.ngModel,
          'ng-disabled': attr.ngDisabled,
          'ng-change': attr.ngChange,
          'ng-required': attr.ngRequired,
          'required': attr.required
      }, function(value, name) {
        if (angular.isDefined(value)) {
            input.attr(name, value);
          }
      });

      return function(scope, element, attr) {
        scope.getValue = function() {
          return scope.ngValue || attr.value;
        };
      };
    }
  };
});
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmLang
 * @module mm.core
 * @description
 * This service allows to add new languages strings.
 */
.factory('$mmLang', ["$translate", "$translatePartialLoader", "$mmConfig", "$cordovaGlobalization", "$q", "mmCoreConfigConstants", function($translate, $translatePartialLoader, $mmConfig, $cordovaGlobalization, $q, mmCoreConfigConstants) {

    var self = {},
        currentLanguage; // Save current language in a variable to speed up the get function.

    /**
     * Register a folder to search language files into it.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#registerLanguageFolder
     * @param  {String} path Path of the folder to use.
     * @return {Promise}     Promise resolved when file is loaded.
     */
    self.registerLanguageFolder = function(path) {
        $translatePartialLoader.addPart(path);
        return $translate.refresh();
    };

    /**
     * Get current language.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#getCurrentLanguage
     * @return {[type]} [description]
     */
    self.getCurrentLanguage = function() {

        if (typeof currentLanguage != 'undefined') {
            return $q.when(currentLanguage);
        }

        // Get current language from config (user might have changed it).
        return $mmConfig.get('current_language').then(function(language) {
            return language;
        }, function() {
            try {
                // User hasn't defined a language. Get it from cordova globalization.
                return $cordovaGlobalization.getPreferredLanguage().then(function(result) {
                    var language = result.value.toLowerCase();
                    if (language.indexOf('-') > -1) {
                        // Language code defined by locale has a dash, like en-US or es-ES. Check if it's supported.
                        if (mmCoreConfigConstants.languages && typeof mmCoreConfigConstants.languages[language] == 'undefined') {
                            // Code is NOT supported. Fallback to language without dash. E.g. 'en-US' would fallback to 'en'.
                            language = language.substr(0, language.indexOf('-'));

                        }
                    }
                    return language;
                }, function() {
                    // Error getting locale. Use default language.
                    return mmCoreConfigConstants.default_lang || 'en';
                });
            } catch(err) {
                // Error getting locale. Use default language.
                return mmCoreConfigConstants.default_lang || 'en';
            }
        }).then(function(language) {
            currentLanguage = language; // Save it for later.
            return language;
        });
    };

    /**
     * Change current language.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#changeCurrentLanguage
     * @param {String} language New language to use.
     * @return {Promise}        Promise resolved when the change is finished.
     */
    self.changeCurrentLanguage = function(language) {
        var p1 = $translate.use(language),
            p2 = $mmConfig.set('current_language', language);
        moment.locale(language);
        currentLanguage = language;
        return $q.all([p1, p2]);
    };

    /**
     * Translates an error message and returns a rejected promise with the translated message.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#translateAndReject
     * @param  {String} errorkey Key of the message to show.
     * @return {Promise}         Rejected promise.
     */
    self.translateAndReject = function(errorkey) {
        return $translate(errorkey).then(function(errorMessage) {
            return $q.reject(errorMessage);
        }, function() {
            return $q.reject(errorkey);
        });
    };

    /**
     * Translates an error message and rejects a deferred with the translated message.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLang#translateAndRejectDeferred
     * @param  {Object} deferred Deferred object to reject.
     * @param  {String} errorkey Key of the message to show.
     */
    self.translateAndRejectDeferred = function(deferred, errorkey) {
        $translate(errorkey).then(function(errorMessage) {
            deferred.reject(errorMessage);
        }, function() {
            deferred.reject(errorkey);
        });
    };

    return self;
}])

.config(["$translateProvider", "$translatePartialLoaderProvider", function($translateProvider, $translatePartialLoaderProvider) {

    $translateProvider.useLoader('$translatePartialLoader', {
        urlTemplate: '{part}/{lang}.json'
    });

    // Load the built language files from build/lang.
    $translatePartialLoaderProvider.addPart('build/lang');

    // Set fallback language.
    $translateProvider.fallbackLanguage('en');
    $translateProvider.preferredLanguage('en'); // Set English until we know which language to use.
}])

.run(["$ionicPlatform", "$translate", "$mmLang", function($ionicPlatform, $translate, $mmLang) {
    $ionicPlatform.ready(function() {
        $mmLang.getCurrentLanguage().then(function(language) {
            $translate.use(language);
            moment.locale(language);
        });
    });
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

// Stores used to create unique IDs for notifications.
.constant('mmCoreNotificationsSitesStore', 'notification_sites')
.constant('mmCoreNotificationsComponentsStore', 'notification_components')
.constant('mmCoreNotificationsTriggeredStore', 'notifications_triggered')

.config(["$mmAppProvider", "mmCoreNotificationsSitesStore", "mmCoreNotificationsComponentsStore", "mmCoreNotificationsTriggeredStore", function($mmAppProvider, mmCoreNotificationsSitesStore, mmCoreNotificationsComponentsStore,
        mmCoreNotificationsTriggeredStore) {
    var stores = [
        {
            name: mmCoreNotificationsSitesStore, // Store to asigne unique codes to each site.
            keyPath: 'id',
            indexes: [
                {
                    name: 'code',
                }
            ]
        },
        {
            name: mmCoreNotificationsComponentsStore, // Store to asigne unique codes to each component.
            keyPath: 'id',
            indexes: [
                {
                    name: 'code',
                }
            ]
        },
        {
            name: mmCoreNotificationsTriggeredStore, // Store to prevent re-triggering notifications.
            keyPath: 'id',
            indexes: []
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

/**
 * Factory to handle local notifications.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmLocalNotifications
 * @description
 * Provides methods to trigger notifications, listen clicks on them, etc.
 */
.factory('$mmLocalNotifications', ["$log", "$cordovaLocalNotification", "$mmApp", "$q", "mmCoreNotificationsSitesStore", "mmCoreNotificationsComponentsStore", "mmCoreNotificationsTriggeredStore", function($log, $cordovaLocalNotification, $mmApp, $q,
        mmCoreNotificationsSitesStore, mmCoreNotificationsComponentsStore, mmCoreNotificationsTriggeredStore) {

    $log = $log.getInstance('$mmLocalNotifications');

    var self = {},
        observers = {},
        codes = {}; // Store codes in memory to make getCode function faster.

    // We need a queue to request unique codes, to handle simultaneous requests.
    var codeRequestsQueue = {};

    /**
     * Get a code to create unique notifications. If there's no code assigned, create a new one.
     *
     * @param  {String} store Store to search in local DB.
     * @param  {String} id    ID of the element to get its code.
     * @return {Promise}      Promise resolved when the code is retrieved.
     */
    function getCode(store, id) {
        var db = $mmApp.getDB(),
            key = store + '#' + id;

        if (typeof codes[key] != 'undefined') {
            return $q.when(codes[key]);
        }

        return db.get(store, id).then(function(entry) {
            var code = parseInt(entry.code);
            codes[key] = code;
            return code;
        }, function() {
            // Site is not in the DB. Create a new ID for it.
            return db.query(store, undefined, 'code', true).then(function(entries) {
                var newCode = 0;
                if (entries.length > 0) {
                    newCode = parseInt(entries[0].code) + 1;
                }
                return db.insert(store, {id: id, code: newCode}).then(function() {
                    codes[key] = newCode;
                    return newCode;
                });
            });
        });
    }

    /**
     * Get a site code to be used.
     * If it's the first time this site is used to send notifications, create a new code for it.
     *
     * @param  {String} siteid   Site ID.
     * @return {Promise}         Promise resolved when the site code is retrieved.
     */
    function getSiteCode(siteid) {
        return requestCode(mmCoreNotificationsSitesStore, siteid);
    }

    /**
     * Get a notification component code to be used.
     * If it's the first time this component is used to send notifications, create a new code for it.
     *
     * @param {String} component Component name.
     * @return {Promise}         Promise resolved when the component code is retrieved.
     */
    function getComponentCode(component) {
        return requestCode(mmCoreNotificationsComponentsStore, component);
    }

    /**
     * Create a unique notification ID, trying to prevent collisions. Generated ID must be a Number (Android).
     * The generated ID shouldn't be higher than 2147483647 or it's going to cause problems in Android.
     * This function will prevent collisions and keep the number under Android limit if:
     *     -User has used less than 21 sites.
     *     -There are less than 11 components.
     *     -The notificationid passed as parameter is lower than 10000000.
     *
     * @param  {Number} notificationid Notification ID.
     * @param {String} component       Component triggering the notification.
     * @param  {String} siteid         Site ID.
     * @return {Promise}               Promise resolved when the notification ID is generated.
     */
    function getUniqueNotificationId(notificationid, component, siteid) {
        if (!siteid || !component) {
            return $q.reject();
        }

        return getSiteCode(siteid).then(function(sitecode) {
            return getComponentCode(component).then(function(componentcode) {
                // We use the % operation to keep the number under Android's limit.
                return (sitecode * 100000000 + componentcode * 10000000 + parseInt(notificationid)) % 2147483647;
            });
        });
    }

    /**
     * Process the next request in queue.
     */
    function processNextRequest() {
        var nextKey = Object.keys(codeRequestsQueue)[0],
            request,
            promise;

        if (typeof nextKey == 'undefined') {
            // No more requests in queue, stop.
            return;
        }

        request = codeRequestsQueue[nextKey];
        // Check if request is valid.
        if (angular.isObject(request) && typeof request.store != 'undefined' && typeof request.id != 'undefined') {
            // Get the code and resolve/reject all the promises of this request.
            promise = getCode(request.store, request.id).then(function(code) {
                angular.forEach(request.promises, function(p) {
                    p.resolve(code);
                });
            }, function(error) {
                angular.forEach(request.promises, function(p) {
                    p.reject(error);
                });
            });
        } else {
            promise = $q.when();
        }

        // Once this item is treated, remove it and process next.
        promise.finally(function() {
            delete codeRequestsQueue[nextKey];
            processNextRequest();
        });
    }

    /**
     * Request a unique code. The request will be added to the queue and the queue is going to be started if it's paused.
     *
     * @param  {String} store Store to search in local DB.
     * @param  {String} id    ID of the element to get its code.
     * @return {Promise}      Promise resolved when the code is retrieved.
     */
    function requestCode(store, id) {
        var deferred = $q.defer(),
            key = store+'#'+id,
            isQueueEmpty = Object.keys(codeRequestsQueue).length == 0;

        if (typeof codeRequestsQueue[key] != 'undefined') {
            // There's already a pending request for this store and ID, add the promise to it.
            codeRequestsQueue[key].promises.push(deferred);
        } else {
            // Add a pending request to the queue.
            codeRequestsQueue[key] = {
                store: store,
                id: id,
                promises: [deferred]
            };
        }

        if (isQueueEmpty) {
            processNextRequest();
        }

        return deferred.promise;
    }

    /**
     * Cancel a local notification.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#cancel
     * @param {Number} id        Notification id.
     * @param {String} component Component of the notification.
     * @param {String} siteid    Site ID.
     * @return {Promise}         Promise resolved when the notification is cancelled.
     */
    self.cancel = function(id, component, siteid) {
        return getUniqueNotificationId(id, component, siteid).then(function(uniqueId) {
            return $cordovaLocalNotification.cancel(uniqueId);
        });
    };

    /**
     * Cancel all the scheduled notifications belonging to a certain site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#cancelSiteNotifications
     * @param {String} siteid Site ID.
     * @return {Promise} Promise resolved when the notifications are cancelled.
     */
    self.cancelSiteNotifications = function(siteid) {

        if (!self.isAvailable()) {
            return $q.when();
        } else if (!siteid) {
            return $q.reject();
        }

        return $cordovaLocalNotification.getAllScheduled().then(function(scheduled) {
            var ids = [];

            angular.forEach(scheduled, function(notif) {
                if (typeof notif.data == 'string') {
                    notif.data = JSON.parse(notif.data);
                }

                if (typeof notif.data == 'object' && notif.data.siteid === siteid) {
                    ids.push(notif.id);
                }
            });

            return $cordovaLocalNotification.cancel(ids);
        });
    };

    /**
     * Returns whether local notifications plugin is installed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#isAvailable
     * @return {Boolean} True when local notifications plugin is installed.
     */
    self.isAvailable = function() {
        return window.plugin && window.plugin.notification && window.plugin.notification.local ? true: false;
    };

    /**
     * Check if a notification has been triggered with the same trigger time.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#isTriggered
     * @param  {Object}  notification Notification to check. Needs to have 'id' and 'at' properties.
     * @return {Promise}              Promise resolved with a boolean indicating if promise is triggered (true) or not.
     */
    self.isTriggered = function(notification) {
        return $mmApp.getDB().get(mmCoreNotificationsTriggeredStore, notification.id).then(function(stored) {
            var notifTime = notification.at.getTime() / 1000;
            return stored.at === notifTime;
        }, function() {
            return false;
        });
    };

    /**
     * Notify notification click to observer. Only the observer with the same component as the notification will be notified.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#notifyClick
     * @param {Object} data Data received by the notification.
     */
    self.notifyClick = function(data) {
        var component = data.component;
        if (component) {
            var callback = observers[component];
            if (typeof callback == 'function') {
                callback(data);
            }
        }
    };

    /**
     * Register an observer to be notified when a notification belonging to a certain component is clicked.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#registerClick
     * @param {String} component  Component to listen notifications for.
     * @param {Function} callback Function to call with the data received by the notification.
     */
    self.registerClick = function(component, callback) {
        $log.debug("Register observer '"+component+"' for notification click.");
        observers[component] = callback;
    };

    /**
     * Remove a notification from triggered store.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#removeTriggered
     * @param {String} id Notification ID.
     * @return {Promise}  Promise resolved when it is removed.
     */
    self.removeTriggered = function(id) {
        return $mmApp.getDB().remove(mmCoreNotificationsTriggeredStore, id);
    };

    /**
     * Schedule a local notification.
     * @see https://github.com/katzer/cordova-plugin-local-notifications/wiki/04.-Scheduling
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#schedule
     * @param {Object} notification Notification to schedule. Its ID should be lower than 10000000 and it should be unique inside
     *                              its component and site. If the ID is higher than that number there might be collisions.
     * @param {String} component    Component triggering the notification. It is used to generate unique IDs.
     * @param {String} siteid       Site ID.
     * @return {Promise}            Promise resolved when the notification is scheduled.
     */
    self.schedule = function(notification, component, siteid) {
        return getUniqueNotificationId(notification.id, component, siteid).then(function(uniqueId) {
            notification.id = uniqueId;
            notification.data = notification.data || {};
            notification.data.component = component;
            notification.data.siteid = siteid;

            return self.isTriggered(notification).then(function(triggered) {
                if (!triggered) {
                    // Remove from triggered, since the notification could be in there with a different time.
                    self.removeTriggered(notification.id);
                    return $cordovaLocalNotification.schedule(notification);
                }
            });
        });
    };

    /**
     * Function to call when a notification is triggered. Stores the notification so it's not scheduled again unless the
     * time is changed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmLocalNotifications#trigger
     * @param {Object} notification Triggered notification.
     * @return {Promise}            Promise resolved when stored, rejected otherwise.
     */
    self.trigger = function(notification) {
        var id = parseInt(notification.id);
        if (!isNaN(id)) {
            return $mmApp.getDB().insert(mmCoreNotificationsTriggeredStore, {
                id: id,
                at: parseInt(notification.at)
            });
        } else {
            return $q.reject();
        }
    };

    return self;
}])

.run(["$rootScope", "$log", "$mmLocalNotifications", "$mmEvents", "mmCoreEventSiteDeleted", function($rootScope, $log, $mmLocalNotifications, $mmEvents, mmCoreEventSiteDeleted) {
    $log = $log.getInstance('$mmLocalNotifications');

    $rootScope.$on('$cordovaLocalNotification:trigger', function(e, notification, state) {
        $mmLocalNotifications.trigger(notification);
    });

    $rootScope.$on('$cordovaLocalNotification:click', function(e, notification, state) {
        if (notification && notification.data) {
            $log.debug('Notification clicked: '+notification.data);
            var data = JSON.parse(notification.data);
            $mmLocalNotifications.notifyClick(data);
        }
    });

    $mmEvents.on(mmCoreEventSiteDeleted, function(site) {
        if (site) {
            $mmLocalNotifications.cancelSiteNotifications(site.id);
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreLogEnabledDefault', true) // Default value for logEnabled.
.constant('mmCoreLogEnabledConfigName', 'debug_enabled')

/**
 * Provider to decorate angular's $log service.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmLog
 * @description
 * $mmLogProvider.logDecorator function is designed to decorate '$log'. It should be used like this:
 *     $provide.decorator('$log', ['$delegate', $mmLogProvider.logDecorator]);
 *
 * Decorated $log usage:
 *     $log = $log.getInstance('MyFactory')
 *     $log.debug('My message') -> "dd/mm/aaaa hh:mm:ss MyFactory: My message"
 *
 * To permanently enable/disable logging messages, use:
 *     $mmLog.enabled(true/false)
 */
.provider('$mmLog', ["mmCoreLogEnabledDefault", function(mmCoreLogEnabledDefault) {

    var isEnabled = mmCoreLogEnabledDefault,
        self = this;

    // Function to pre-capture a logger function.
    function prepareLogFn(logFn, className) {
        className = className || '';
        // Invoke the specified 'logFn' with our new code.
        var enhancedLogFn = function() {
            if (isEnabled) {
                var args = Array.prototype.slice.call(arguments),
                    now  = moment().format('l LTS');

                args[0] = now + ' ' + className + ': ' + args[0]; // Prepend timestamp and className to the original message.
                logFn.apply(null, args);
            }
        };

        // Special, only needed to support angular-mocks expectations.
        enhancedLogFn.logs = [];

        return enhancedLogFn;
    }

    /**
     * Enhances $log service, adding date and component to the logged message, and allowing disable log.
     *
     * @param  {Service} $log Angular's $log service to decorate.
     * @return {Service}      Decorated $log.
     */
    self.logDecorator = function($log) {
        // Copy the original methods.
        var _$log = (function($log) {
            return {
                log   : $log.log,
                info  : $log.info,
                warn  : $log.warn,
                debug : $log.debug,
                error : $log.error
            };
        })($log);

        // Create the getInstance method so services/controllers can configure the className to be shown.
        var getInstance = function(className) {
            return {
                log   : prepareLogFn(_$log.log, className),
                info  : prepareLogFn(_$log.info, className),
                warn  : prepareLogFn(_$log.warn, className),
                debug : prepareLogFn(_$log.debug, className),
                error : prepareLogFn(_$log.error, className)
            };
        };

        // Decorate original $log functions too. This way if a service/controller uses $log without $log.getInstance,
        // it's going to prepend the date and 'Core'.
        $log.log   = prepareLogFn($log.log);
        $log.info  = prepareLogFn($log.info);
        $log.warn  = prepareLogFn($log.warn);
        $log.debug = prepareLogFn($log.debug);
        $log.error = prepareLogFn($log.error);
        $log.getInstance = getInstance;

        return $log;
    };

    this.$get = ["$mmConfig", "mmCoreLogEnabledDefault", "mmCoreLogEnabledConfigName", function($mmConfig, mmCoreLogEnabledDefault, mmCoreLogEnabledConfigName) {
        var self = {};

        /**
         * Initialize logging, enabling/disabling it based on settings and mmCoreLogEnabledDefault.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmLog#init
         */
        self.init = function() {
            $mmConfig.get(mmCoreLogEnabledConfigName).then(function(enabled) {
                isEnabled = enabled;
            }, function() {
                // Not set, use default value.
                isEnabled = mmCoreLogEnabledDefault;
            });
        }

        /**
         * Enable/disable logging in the app.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmLog#enabled
         * @param {Boolean} flag True if log should be enabled, false otherwise.
         */
        self.enabled = function(flag) {
            $mmConfig.set(mmCoreLogEnabledConfigName, flag);
            isEnabled = flag;
        };

        /**
         * Check if app logging is enabled.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmLog#isEnabled
         * @return {Boolean} True if log is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return isEnabled;
        };

        return self;
    }];
}])

.run(["$mmLog", function($mmLog) {
    $mmLog.init();
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Service to provide functionalities related to current site.
 *
 * @module mm.core
 * @ngdoc factory
 * @name $mmSite
 * @description
 * This services provides a set of functionalities related to current site. The current site instance is stored in $mmSitesManager.
 * This service can be seen as an instance of Site defined in $mmSitesFactory, with one method added: $mmSite.isLoggedIn.
 */
.factory('$mmSite', ["$mmSitesManager", "$mmSitesFactory", function($mmSitesManager, $mmSitesFactory) {

    var self = {},
        siteMethods = $mmSitesFactory.getSiteMethods();

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getId
     * @return {String} Current site ID.
     * @description
     *
     * Get current site ID.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getURL
     * @return {String} Current site URL.
     * @description
     *
     * Get current site URL.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getToken
     * @return {String} Current site token.
     * @description
     *
     * Get current site token.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getInfo
     * @return {Object} Current site info.
     * @description
     *
     * Get current site info.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getDb
     * @return {Object} Current site DB.
     * @description
     *
     * Get current site DB.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getUserId
     * @return {Object} User's ID.
     * @description
     *
     * Get current site user's ID.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#setId
     * @param {String} New ID.
     * @description
     *
     * Set current site ID.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#setToken
     * @param {String} New token.
     * @description
     *
     * Set current site token.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canAccessMyFiles
     * @return {Boolean} False when they cannot.
     * #description
     *
     * Check if user can access private files in current site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canDownloadFiles
     * @return {Boolean} False when they cannot.
     * #description
     *
     * Check if user can download files in current site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canUseAdvancedFeature
     * @param {String} feature The name of the feature.
     * @param {Boolean} [whenUndefined=true] The value to return when the parameter is undefined
     * @return {Boolean} False when they cannot.
     * @description
     *
     * Can the user use an advanced feature?
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#canUploadFiles
     * @return {Boolean} False when they cannot.
     * #description
     *
     * Check if user can upload files in current site.
     */

    /**
     * Fetch site info from the Moodle site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#fetchSiteInfo
     * @return {Promise} A promise to be resolved when the site info is retrieved.
     * #description
     *
     * Fetch site info from the current Moodle site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#read
     * @param  {String} read  WS method to use.
     * @param  {Object} data    Data to send to the WS.
     * @param  {Object} preSets Options. @see $mmSite#request.
     * @return {Promise}        Promise to be resolved when the request is finished.
     * #description
     *
     * Read some data from the current Moodle site using WS. Requests are cached by default.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#write
     * @param  {String} method  WS method to use.
     * @param  {Object} data    Data to send to the WS.
     * @param  {Object} preSets Options. @see $mmSite#request.
     * @return {Promise}        Promise to be resolved when the request is finished.
     * #description
     *
     * Sends some data to the current Moodle site using WS. Requests are NOT cached by default.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#request
     * @param {string} method The WebService method to be called.
     * @param {Object} data Arguments to pass to the method.
     * @param {Object} preSets Extra settings.
     *                    - getFromCache boolean (false) Use the cache when possible.
     *                    - saveToCache boolean (false) Save the call results to the cache.
     *                    - omitExpires boolean (false) Ignore cache expiry.
     *                    - sync boolean (false) Add call to queue if device is not connected.
     *                    - cacheKey (string) Extra key to add to the cache when storing this call. This key is to
     *                                        flag the cache entry, it doesn't affect the data retrieved in this call.
     *                    - getCacheUsingCacheKey (boolean) True if it should retrieve cached data by cacheKey,
     *                                        false if it should get the data based on the params passed (usual behavior).
     * @return {Promise}
     * @description
     *
     * Sends a webservice request to the site. This method will automatically add the
     * required parameters and pass it on to the low level API in $mmWS.call().
     *
     * Caching is also implemented, when enabled this method will returned a cached
     * version of itself rather than contacting the server.
     *
     * This method is smart which means that it will try to map the method to a
     * compatibility one if need be, usually that means that it will fallback on
     * the 'local_mobile_' prefixed function if it is available and the non-prefixed is not.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#wsAvailable
     * @param  {String}       method      WS name.
     * @param  {Boolean=true} checkPrefix When true also checks with the compatibility prefix.
     * @return {Boolean}                  True if the WS is available, false otherwise.
     * @description
     * Check if a WS is available in the current site.
     *
     * This method checks if a web service function is available. By default it will
     * also check if there is a compatibility function for it, e.g. a prefixed one.
     */

    /*
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#uploadFile
     * @param {Object} uri File URI.
     * @param {Object} options File settings: fileKey, fileName and mimeType.
     * @return {Promise}
     * @description
     *
     * Uploads a file to the current site using Cordova File API.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#invalidateWsCacheForKey
     * @param  {String} key Key to search.
     * @return {Promise}    Promise resolved when the cache entries are invalidated.
     * @description
     *
     * Invalidates all the cache entries with a certain key.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#invalidateWsCacheForKeyStartingWith
     * @param  {String} key Key to search.
     * @return {Promise}    Promise resolved when the cache entries are invalidated.
     * @description
     *
     * Invalidates all the cache entries whose key starts with a certain value.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#fixPluginfileURL
     * @param {String} url   The url to be fixed.
     * @return {String}      Fixed URL.
     * @description
     *
     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
     * Uses $mmUtil.fixPluginfileURL, passing current site's token.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#deleteDB
     * @return {Promise} Promise to be resolved when the DB is deleted.
     * @description
     *
     * Deletes current site's DB.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#deleteFolder
     * @return {Promise} Promise to be resolved when the folder is deleted.
     * @description
     *
     * Deletes current site's folder.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getSpaceUsage
     * @return {Promise} Promise resolved with the site space usage (size).
     * @description
     *
     * Get space usage of the site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getDocsUrl
     * @param {String} [page]    Docs page to go to.
     * @return {Promise}         Promise resolved with the Moodle docs URL.
     * @description
     *
     * Returns the URL to the documentation of the app, based on Moodle version and current language.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#checkLocalMobilePlugin
     * @return {Promise} Promise resolved when the check is done. Resolve params:
     *                           - {Number} code Code to identify the authentication method to use.
     *                           - {String} [service] If defined, name of the service to use.
     *                           - {String} [warning] If defined, code of the warning message.
     * @description
     *
     * Check if the local_mobile plugin is installed in the Moodle site.
     * This plugin provide extended services.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#checkLocalMobilePlugin
     * @return {Promise} Promise resolved it local_mobile was added, rejected otherwise.
     * @description
     *
     * Check if local_mobile has been installed in Moodle but the app is not using it.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#containsUrl
     * @param  {String}  url URL to check.
     * @return {Boolean}     True if URL belongs to this site, false otherwise.
     * @description
     *
     * Check if a URL belongs to this site.
     */

    /**
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#getCompatibleFunction
     * @param  {String} method WS function to check.
     * @return {String}        Method to use based in the available functions.
     * @description
     *
     * Return the function to be used, based on the available functions in the site. It'll try to use non-deprecated
     * functions first, and fallback to deprecated ones if needed.
     */

    // Replicate all Site methods refined in $mmSitesFactory to be used with current site.
    angular.forEach(siteMethods, function(method) {
        self[method] = function() {
            var currentSite = $mmSitesManager.getCurrentSite();
            if (typeof currentSite == 'undefined') {
                return undefined;
            } else {
                return currentSite[method].apply(currentSite, arguments);
            }
        };
    });

    /**
     * Check if the user is logged in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSite#isLoggedIn
     * @return {Boolean} True if the user is logged in a site, false otherwise.
     */
    self.isLoggedIn = function() {
        var currentSite = $mmSitesManager.getCurrentSite();
        return typeof currentSite != 'undefined' && typeof currentSite.token != 'undefined' && currentSite.token != '';
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.value('mmCoreWSPrefix', 'local_mobile_')

.constant('mmCoreWSCacheStore', 'wscache')

.config(["$mmSitesFactoryProvider", "mmCoreWSCacheStore", function($mmSitesFactoryProvider, mmCoreWSCacheStore) {
    var stores = [
        {
            name: mmCoreWSCacheStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'key'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Provider to create sites instances.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmSitesFactory
 * @description
 * This provider is the interface with the DB database. The modules that need to store
 * information here need to register their stores.
 *
 * Example:
 *
 * .config(function($mmSitesFactoryProvider) {
 *      $mmSitesFactoryProvider.registerStore({
 *          name: 'courses',
 *          keyPath: 'id'
 *      });
 *  })
 *
 * The service $mmSitesFactory is used to create site instances. It's not intended to be used directly, its usage is
 * restricted to core. Developers should only use $mmSitesFactoryProvider, $mmSitesManager and $mmSite.
 */
.provider('$mmSitesFactory', function() {

    /** Define the site storage schema. */
    var siteSchema = {
            stores: []
        },
        dboptions = {
            autoSchema: true
        };

    /**
     * Register a store schema.
     * IMPORTANT: Modifying the schema of an already existing store deletes all its data in WebSQL Storage.
     * If a store schema needs to be modified, the data should be manually migrated to the new store.
     *
     * @param  {Object} store The store object definition.
     * @return {Void}
     */
    this.registerStore = function(store) {
        if (typeof(store.name) === 'undefined') {
            console.log('$mmSite: Error: store name is undefined.');
            return;
        } else if (storeExists(store.name)) {
            console.log('$mmSite: Error: store ' + store.name + ' is already defined.');
            return;
        }
        siteSchema.stores.push(store);
    };

    /**
     * Register multiple stores at once.
     * IMPORTANT: Modifying the schema of an already existing store deletes all its data in WebSQL Storage.
     * If a store schema needs to be modified, the data should be manually migrated to the new store.
     *
     * @param  {Array} stores Array of store objects.
     * @return {Void}
     */
    this.registerStores = function(stores) {
        var self = this;
        angular.forEach(stores, function(store) {
            self.registerStore(store);
        });
    };

    /**
     * Check if a store is already defined.
     *
     * @param  {String} name The name of the store.
     * @return {Boolean} True when the store was already defined.
     */
    function storeExists(name) {
        var exists = false;
        angular.forEach(siteSchema.stores, function(store) {
            if (store.name === name) {
                exists = true;
            }
        });
        return exists;
    }

    this.$get = ["$http", "$q", "$mmWS", "$mmDB", "$log", "md5", "$mmApp", "$mmLang", "$mmUtil", "$mmFS", "mmCoreWSCacheStore", "mmCoreWSPrefix", "mmCoreSessionExpired", "$mmEvents", "mmCoreEventSessionExpired", "mmCoreUserDeleted", "mmCoreEventUserDeleted", "$mmText", "mmCoreConfigConstants", function($http, $q, $mmWS, $mmDB, $log, md5, $mmApp, $mmLang, $mmUtil, $mmFS, mmCoreWSCacheStore,
            mmCoreWSPrefix, mmCoreSessionExpired, $mmEvents, mmCoreEventSessionExpired, mmCoreUserDeleted, mmCoreEventUserDeleted,
            $mmText, mmCoreConfigConstants) {

        $log = $log.getInstance('$mmSite');

        /**
         * List of deprecated WS functions with their corresponding NOT deprecated name.
         *
         * When the function does not have an equivalent set its value to true.
         *
         * @type {Object}
         */
        var deprecatedFunctions = {
            "core_grade_get_definitions": "core_grading_get_definitions",
            "moodle_course_create_courses": "core_course_create_courses",
            "moodle_course_get_courses": "core_course_get_courses",
            "moodle_enrol_get_users_courses": "core_enrol_get_users_courses",
            "moodle_file_get_files": "core_files_get_files",
            "moodle_file_upload": "core_files_upload",
            "moodle_group_add_groupmembers": "core_group_add_group_members",
            "moodle_group_create_groups": "core_group_create_groups",
            "moodle_group_delete_groupmembers": "core_group_delete_group_members",
            "moodle_group_delete_groups": "core_group_delete_groups",
            "moodle_group_get_course_groups": "core_group_get_course_groups",
            "moodle_group_get_groupmembers": "core_group_get_group_members",
            "moodle_group_get_groups": "core_group_get_groups",
            "moodle_message_send_instantmessages": "core_message_send_instant_messages",
            "moodle_notes_create_notes": "core_notes_create_notes",
            "moodle_role_assign": "core_role_assign_role",
            "moodle_role_unassign": "core_role_unassign_role",
            "moodle_user_create_users": "core_user_create_users",
            "moodle_user_delete_users": "core_user_delete_users",
            "moodle_user_get_course_participants_by_id": "core_user_get_course_user_profiles",
            "moodle_user_get_users_by_courseid": "core_enrol_get_enrolled_users",
            // Both *_user_get_users_by_id are deprecated, but there is no equivalent available in the Mobile service.
            "moodle_user_get_users_by_id": "core_user_get_users_by_id",
            "moodle_user_update_users": "core_user_update_users",
            "moodle_webservice_get_siteinfo": "core_webservice_get_site_info",
        };

        var self = {};

        /**
         * Site object to store site data.
         *
         * @param {String} id      Site ID.
         * @param {String} siteurl Site URL.
         * @param {String} token   User's token in the site.
         * @param {Object} infos   Site's info.
         */
        function Site(id, siteurl, token, infos) {
            this.id = id;
            this.siteurl = siteurl;
            this.token = token;
            this.infos = infos;

            if (this.id) {
                this.db = $mmDB.getDB('Site-' + this.id, siteSchema, dboptions);
            }
        }

        /**
         * Get site ID.
         *
         * @return {String} Current site ID.
         */
        Site.prototype.getId = function() {
            return this.id;
        };

        /**
         * Get site URL.
         *
         * @return {String} Current site URL.
         */
        Site.prototype.getURL = function() {
            return this.siteurl;
        };

        /**
         * Get site token.
         *
         * @return {String} Current site token.
         */
        Site.prototype.getToken = function() {
            return this.token;
        };

        /**
         * Get site info.
         *
         * @return {Object} Current site info.
         */
        Site.prototype.getInfo = function() {
            return this.infos;
        };

        /**
         * Get site DB.
         *
         * @return {Object} Current site DB.
         */
        Site.prototype.getDb = function() {
            return this.db;
        };

        /**
         * Get site user's ID.
         *
         * @return {Object} User's ID.
         */
        Site.prototype.getUserId = function() {
            if (typeof this.infos != 'undefined' && typeof this.infos.userid != 'undefined') {
                return this.infos.userid;
            } else {
                return undefined;
            }
        };

        /**
         * Set site ID.
         *
         * @param {String} New ID.
         */
        Site.prototype.setId = function(id) {
            this.id = id;
            this.db = $mmDB.getDB('Site-' + this.id, siteSchema, dboptions);
        };

        /**
         * Set site token.
         *
         * @param {String} New token.
         */
        Site.prototype.setToken = function(token) {
            this.token = token;
        };

        /**
         * Set site info.
         *
         * @param {Object} New info.
         */
        Site.prototype.setInfo = function(infos) {
            this.infos = infos;
        };

        /**
         * Can the user access their private files?
         *
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canAccessMyFiles = function() {
            var infos = this.getInfo();
            return infos && (typeof infos.usercanmanageownfiles === 'undefined' || infos.usercanmanageownfiles);
        };

        /**
         * Can the user download files?
         *
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canDownloadFiles = function() {
            var infos = this.getInfo();
            return infos && infos.downloadfiles;
        };

        /**
         * Can the user use an advanced feature?
         *
         * @param {String} feature The name of the feature.
         * @param {Boolean} [whenUndefined=true] The value to return when the parameter is undefined
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canUseAdvancedFeature = function(feature, whenUndefined) {
            var infos = this.getInfo(),
                canUse = true;

            whenUndefined = (typeof whenUndefined === 'undefined') ? true : whenUndefined;

            if (typeof infos.advancedfeatures === 'undefined') {
                canUse = whenUndefined;
            } else {

                angular.forEach(infos.advancedfeatures, function(item) {
                    if (item.name === feature && parseInt(item.value, 10) === 0) {
                        canUse = false;
                    }
                });

            }

            return canUse;
        };

        /**
         * Can the user upload files?
         *
         * @return {Boolean} False when they cannot.
         */
        Site.prototype.canUploadFiles = function() {
            var infos = this.getInfo();
            return infos && infos.uploadfiles;
        };

        /**
         * Fetch site info from the Moodle site.
         *
         * @return {Promise} A promise to be resolved when the site info is retrieved.
         */
        Site.prototype.fetchSiteInfo = function() {
            var deferred = $q.defer(),
                site = this;

            // get_site_info won't be cached.
            var preSets = {
                getFromCache: 0,
                saveToCache: 0
            };

            site.read('core_webservice_get_site_info', {}, preSets).then(deferred.resolve, function(error) {
                site.read('moodle_webservice_get_siteinfo', {}, preSets).then(deferred.resolve, function(error) {
                    deferred.reject(error);
                });
            });

            return deferred.promise;
        };

        /**
         * Read some data from the Moodle site using WS. Requests are cached by default.
         *
         * @param  {String} read  WS method to use.
         * @param  {Object} data    Data to send to the WS.
         * @param  {Object} preSets Options: @see Site#request.
         * @return {Promise}        Promise to be resolved when the request is finished.
         */
        Site.prototype.read = function(method, data, preSets) {
            preSets = preSets || {};
            if (typeof(preSets.getFromCache) === 'undefined') {
                preSets.getFromCache = 1;
            }
            if (typeof(preSets.saveToCache) === 'undefined') {
                preSets.saveToCache = 1;
            }
            if (typeof(preSets.sync) === 'undefined') {
                preSets.sync = 0;
            }
            return this.request(method, data, preSets);
        };

        /**
         * Sends some data to the Moodle site using WS. Requests are NOT cached by default.
         *
         * @param  {String} method  WS method to use.
         * @param  {Object} data    Data to send to the WS.
         * @param  {Object} preSets Options: @see Site#request.
         * @return {Promise}        Promise to be resolved when the request is finished.
         */
        Site.prototype.write = function(method, data, preSets) {
            preSets = preSets || {};
            if (typeof(preSets.getFromCache) === 'undefined') {
                preSets.getFromCache = 0;
            }
            if (typeof(preSets.saveToCache) === 'undefined') {
                preSets.saveToCache = 0;
            }
            if (typeof(preSets.sync) === 'undefined') {
                preSets.sync = 0;
            }
            return this.request(method, data, preSets);
        };

        /**
         * WS request to the site.
         *
         * @param {string} method The WebService method to be called.
         * @param {Object} data Arguments to pass to the method.
         * @param {Object} preSets Extra settings.
         *                    - getFromCache boolean (false) Use the cache when possible.
         *                    - saveToCache boolean (false) Save the call results to the cache.
         *                    - omitExpires boolean (false) Ignore cache expiry.
         *                    - emergencyCache boolean (true) If possible, use the cache when the request fails.
         *                    - sync boolean (false) Add call to queue if device is not connected.
         *                    - cacheKey (string) Extra key to add to the cache when storing this call. This key is to
         *                                        flag the cache entry, it doesn't affect the data retrieved in this call.
         *                    - getCacheUsingCacheKey (boolean) True if it should retrieve cached data by cacheKey,
         *                                        false if it should get the data based on the params passed (usual behavior).
         * @return {Promise}
         * @description
         *
         * Sends a webservice request to the site. This method will automatically add the
         * required parameters and pass it on to the low level API in $mmWS.call().
         *
         * Caching is also implemented, when enabled this method will returned a cached
         * version of itself rather than contacting the server.
         *
         * This method is smart which means that it will try to map the method to a
         * compatibility one if need be, usually that means that it will fallback on
         * the 'local_mobile_' prefixed function if it is available and the non-prefixed is not.
         */
        Site.prototype.request = function(method, data, preSets) {
            var deferred = $q.defer(),
                site = this;
            data = data || {};

            // Get the method to use based on the available ones.
            method = site.getCompatibleFunction(method);

            // Check if the method is available, use a prefixed version if possible.
            // We ignore this check when we do not have the site info, as the list of functions is not loaded yet.
            if (site.getInfo() && !site.wsAvailable(method, false)) {
                if (site.wsAvailable(mmCoreWSPrefix + method, false)) {
                    $log.info("Using compatibility WS method '" + mmCoreWSPrefix + method + "'");
                    method = mmCoreWSPrefix + method;
                } else {
                    $log.error("WS function '" + method + "' is not available, even in compatibility mode.");
                    $mmLang.translateAndRejectDeferred(deferred, 'mm.core.wsfunctionnotavailable');
                    return deferred.promise;
                }
            }

            preSets = angular.copy(preSets) || {};
            preSets.wstoken = site.token;
            preSets.siteurl = site.siteurl;

            // Enable text filtering.
            data.moodlewssettingfilter = true;

            getFromCache(site, method, data, preSets).then(function(data) {
                deferred.resolve(data);
            }, function() {
                // Do not pass those options to the core WS factory.
                var wsPreSets = angular.copy(preSets);
                delete wsPreSets.getFromCache;
                delete wsPreSets.saveToCache;
                delete wsPreSets.omitExpires;
                delete wsPreSets.cacheKey;
                delete wsPreSets.emergencyCache;
                delete wsPreSets.getCacheUsingCacheKey;

                // TODO: Sync

                $mmWS.call(method, data, wsPreSets).then(function(response) {

                    if (preSets.saveToCache) {
                        saveToCache(site, method, data, response, preSets.cacheKey);
                    }

                    // We pass back a clone of the original object, this may
                    // prevent errors if in the callback the object is modified.
                    deferred.resolve(angular.copy(response));
                }, function(error) {
                    if (error === mmCoreSessionExpired) {
                        // Session expired, trigger event.
                        $mmLang.translateAndRejectDeferred(deferred, 'mm.core.lostconnection');
                        $mmEvents.trigger(mmCoreEventSessionExpired, site.id);
                    } else if (error === mmCoreUserDeleted) {
                        // User deleted, trigger event.
                        $mmLang.translateAndRejectDeferred(deferred, 'mm.core.userdeleted');
                        $mmEvents.trigger(mmCoreEventUserDeleted, {siteid: site.id, params: data});
                    } else if (typeof preSets.emergencyCache !== 'undefined' && !preSets.emergencyCache) {
                        $log.debug('WS call ' + method + ' failed. Emergency cache is forbidden, rejecting.');
                        deferred.reject(error);
                    } else {
                        $log.debug('WS call ' + method + ' failed. Trying to use the emergency cache.');
                        preSets.omitExpires = true;
                        preSets.getFromCache = true;
                        getFromCache(site, method, data, preSets).then(function(data) {
                            deferred.resolve(data);
                        }, function() {
                            deferred.reject(error);
                        });
                    }
                });
            });

            return deferred.promise;
        };

        /**
         * Check if a WS is available in this site.
         *
         * @param  {String} method WS name.
         * @param  {Boolean=true} checkPrefix When true also checks with the compatibility prefix.
         * @return {Boolean}       True if the WS is available, false otherwise.
         * @description
         *
         * This method checks if a web service function is available. By default it will
         * also check if there is a compatibility function for it, e.g. a prefixed one.
         */
        Site.prototype.wsAvailable = function(method, checkPrefix) {
            checkPrefix = (typeof checkPrefix === 'undefined') ? true : checkPrefix;

            if (typeof this.infos == 'undefined') {
                return false;
            }

            for (var i = 0; i < this.infos.functions.length; i++) {
                var f = this.infos.functions[i];
                if (f.name == method) {
                    return true;
                }
            }

            // Let's try again with the compatibility prefix.
            if (checkPrefix) {
                return this.wsAvailable(mmCoreWSPrefix + method, false);
            }

            return false;
        };

        /*
         * Uploads a file using Cordova File API.
         *
         * @param {Object} uri File URI.
         * @param {Object} options File settings: fileKey, fileName and mimeType.
         * @return {Promise}
         */
        Site.prototype.uploadFile = function(uri, options) {
            return $mmWS.uploadFile(uri, options, {
                siteurl: this.siteurl,
                token: this.token
            });
        };

        /**
         * Invalidates all the cache entries.
         *
         * @return {Promise} Promise resolved when the cache entries are invalidated.
         */
        Site.prototype.invalidateWsCache = function() {
            var db = this.db;
            if (!db) {
                return $q.reject();
            }

            $log.debug('Invalidate all the cache for site: '+ this.id);
            return db.getAll(mmCoreWSCacheStore).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };

        /**
         * Invalidates all the cache entries with a certain key.
         *
         * @param  {String} key Key to search.
         * @return {Promise}    Promise resolved when the cache entries are invalidated.
         */
        Site.prototype.invalidateWsCacheForKey = function(key) {
            var db = this.db;
            if (!db || !key) {
                return $q.reject();
            }

            $log.debug('Invalidate cache for key: '+key);
            return db.whereEqual(mmCoreWSCacheStore, 'key', key).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };

        /**
         * Invalidates all the cache entries whose key starts with a certain value.
         *
         * @param  {String} key Key to search.
         * @return {Promise}    Promise resolved when the cache entries are invalidated.
         */
        Site.prototype.invalidateWsCacheForKeyStartingWith = function(key) {
            var db = this.db;
            if (!db || !key) {
                return $q.reject();
            }

            $log.debug('Invalidate cache for key starting with: '+key);
            return db.where(mmCoreWSCacheStore, 'key', '^', key).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };

        /**
         * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
         * Uses $mmUtil.fixPluginfileURL, passing site's token.
         *
         * @param {String} url   The url to be fixed.
         * @return {String}      Fixed URL.
         */
        Site.prototype.fixPluginfileURL = function(url) {
            return $mmUtil.fixPluginfileURL(url, this.token);

        };

        /**
         * Deletes site's DB.
         *
         * @return {Promise} Promise to be resolved when the DB is deleted.
         */
        Site.prototype.deleteDB = function() {
            return $mmDB.deleteDB('Site-' + this.id);
        };

        /**
         * Deletes site's folder.
         *
         * @return {Promise} Promise to be resolved when the DB is deleted.
         */
        Site.prototype.deleteFolder = function() {
            if ($mmFS.isAvailable()) {
                var siteFolder = $mmFS.getSiteFolder(this.id);
                return $mmFS.removeDir(siteFolder).catch(function() {
                    // Ignore any errors, $mmFS.removeDir fails if folder doesn't exists.
                });
            } else {
                return $q.when();
            }
        };

        /**
         * Get space usage of the site.
         *
         * @return {Promise} Promise resolved with the site space usage (size).
         */
        Site.prototype.getSpaceUsage = function() {
            if ($mmFS.isAvailable()) {
                var siteFolderPath = $mmFS.getSiteFolder(this.id);
                return $mmFS.getDirectorySize(siteFolderPath).catch(function() {
                    return 0;
                });
            } else {
                return $q.when(0);
            }
        };

        /**
         * Returns the URL to the documentation of the app, based on Moodle version and current language.
         *
         * @param {String} [page]    Docs page to go to.
         * @return {Promise}         Promise resolved with the Moodle docs URL.
         */
        Site.prototype.getDocsUrl = function(page) {
            var release = this.infos.release ? this.infos.release : undefined;
            return $mmUtil.getDocsUrl(release, page);
        };

        /**
         * Check if the local_mobile plugin is installed in the Moodle site.
         * This plugin provide extended services.
         *
         * @param {Boolean} retrying True if we're retrying the check.
         * @return {Promise}         Promise resolved when the check is done. Resolve params:
         *                                   - {Number} code Code to identify the authentication method to use.
         *                                   - {String} [service] If defined, name of the service to use.
         *                                   - {String} [warning] If defined, code of the warning message.
         */
        Site.prototype.checkLocalMobilePlugin = function(retrying) {
            var siteurl = this.siteurl,
                self = this,
                service = mmCoreConfigConstants.wsextservice;

            if (!service) {
                // External service not defined.
                return $q.when({code: 0});
            }

            return $http.post(siteurl + '/local/mobile/check.php', {service: service}).then(function(response) {
                var data = response.data;

                if (typeof data != 'undefined' && data.errorcode === 'requirecorrectaccess') {
                    if (!retrying) {
                        self.siteurl = $mmText.addOrRemoveWWW(siteurl);
                        return self.checkLocalMobilePlugin(true);
                    } else {
                        return $q.reject(data.error);
                    }
                } else if (typeof data == 'undefined' || typeof data.code == 'undefined') {
                    // local_mobile returned something we didn't expect. Let's assume it's not installed.
                    return {code: 0, warning: 'mm.login.localmobileunexpectedresponse'};
                }

                var code = parseInt(data.code, 10);
                if (data.error) {
                    switch (code) {
                        case 1:
                            // Site in maintenance mode.
                            return $mmLang.translateAndReject('mm.login.siteinmaintenance');
                        case 2:
                            // Web services not enabled.
                            return $mmLang.translateAndReject('mm.login.webservicesnotenabled');
                        case 3:
                            // Extended service not enabled, but the official is enabled.
                            return {code: 0};
                        case 4:
                            // Neither extended or official services enabled.
                            return $mmLang.translateAndReject('mm.login.mobileservicesnotenabled');
                        default:
                            return $mmLang.translateAndReject('mm.core.unexpectederror');
                    }
                } else {
                    return {code: code, service: service};
                }
            }, function() {
                return {code: 0};
            });
        };

        /**
         * Check if local_mobile has been installed in Moodle but the app is not using it.
         *
         * @return {Promise} Promise resolved it local_mobile was added, rejected otherwise.
         */
        Site.prototype.checkIfLocalMobileInstalledAndNotUsed = function() {
            var appUsesLocalMobile = false;
            angular.forEach(this.infos.functions, function(func) {
                if (func.name.indexOf(mmCoreWSPrefix) != -1) {
                    appUsesLocalMobile = true;
                }
            });

            if (appUsesLocalMobile) {
                // App already uses local_mobile, it wasn't added.
                return $q.reject();
            }

            return this.checkLocalMobilePlugin().then(function(data) {
                if (typeof data.service == 'undefined') {
                    // local_mobile NOT installed. Reject.
                    return $q.reject();
                }
                return data;
            });
        };

        /**
         * Check if a URL belongs to this site.
         *
         * @param  {String}  url URL to check.
         * @return {Boolean}     True if URL belongs to this site, false otherwise.
         */
        Site.prototype.containsUrl = function(url) {
            if (!url) {
                return false;
            }
            var siteurl = $mmText.removeProtocolAndWWW(this.siteurl);
            url = $mmText.removeProtocolAndWWW(url);
            return url.indexOf(siteurl) == 0;
        };

        /**
         * Invalidate entries from the cache.
         *
         * @param  {Object} db      DB the entries belong to.
         * @param  {Array}  entries Entries to invalidate.
         * @return {Promise}        Promise resolved when the cache entries are invalidated.
         */
        function invalidateWsCacheEntries(db, entries) {
            var promises = [];
            angular.forEach(entries, function(entry) {
                entry.expirationtime = 0;
                var promise = db.insert(mmCoreWSCacheStore, entry);
                promises.push(promise);
            });
            return $q.all(promises);
        }

        /**
         * Return the function to be used, based on the available functions in the site. It'll try to use non-deprecated
         * functions first, and fallback to deprecated ones if needed.
         *
         * @param  {String} method WS function to check.
         * @return {String}        Method to use based in the available functions.
         */
        Site.prototype.getCompatibleFunction = function(method) {
            if (typeof deprecatedFunctions[method] !== "undefined") {
                // Deprecated function is being used. Warn the developer.
                if (this.wsAvailable(deprecatedFunctions[method])) {
                    $log.warn("You are using deprecated Web Services: " + method +
                        " you must replace it with the newer function: " + deprecatedFunctions[method]);
                    return deprecatedFunctions[method];
                } else {
                    $log.warn("You are using deprecated Web Services. " +
                        "Your remote site seems to be outdated, consider upgrade it to the latest Moodle version.");
                }
            } else if (!this.wsAvailable(method)) {
                // Method not available. Check if there is a deprecated method to use.
                for (var oldFunc in deprecatedFunctions) {
                    if (deprecatedFunctions[oldFunc] === method && this.wsAvailable(oldFunc)) {
                        $log.warn("Your remote site doesn't support the function " + method +
                            ", it seems to be outdated, consider upgrade it to the latest Moodle version.");
                        return oldFunc; // Use deprecated function.
                    }
                }
            }
            return method;
        };

        /**
         * Get a WS response from cache.
         *
         * @param {Object} site    Site.
         * @param {String} method  The WebService method.
         * @param {Object} data    Arguments to pass to the method.
         * @param {Object} preSets Extra settings.
         * @return {Promise}       Promise to be resolved with the WS response.
         */
        function getFromCache(site, method, data, preSets) {
            var result,
                db = site.db,
                deferred = $q.defer(),
                id,
                promise;

            if (!db) {
                deferred.reject();
                return deferred.promise;
            } else if (!preSets.getFromCache) {
                deferred.reject();
                return deferred.promise;
            }

            id = md5.createHash(method + ':' + JSON.stringify(data));

            if (preSets.getCacheUsingCacheKey) {
                promise = db.whereEqual(mmCoreWSCacheStore, 'key', preSets.cacheKey).then(function(entries) {
                    if (entries.length == 0) {
                        // Cache key not found, get by params sent.
                        return db.get(mmCoreWSCacheStore, id);
                    }
                    return entries[0];
                });
            } else {
                promise = db.get(mmCoreWSCacheStore, id);
            }

            promise.then(function(entry) {
                var now = new Date().getTime();

                preSets.omitExpires = preSets.omitExpires || !$mmApp.isOnline();

                if (!preSets.omitExpires) {
                    if (now > entry.expirationtime) {
                        $log.debug('Cached element found, but it is expired');
                        deferred.reject();
                        return;
                    }
                }

                if (typeof entry != 'undefined' && typeof entry.data != 'undefined') {
                    var expires = (entry.expirationtime - now) / 1000;
                    $log.info('Cached element found, id: ' + id + ' expires in ' + expires + ' seconds');
                    deferred.resolve(entry.data);
                    return;
                }

                deferred.reject();
            }, function() {
                deferred.reject();
            });

            return deferred.promise;
        }

        /**
         * Save a WS response to cache.
         *
         * @param {Object} site    Site.
         * @param {String} method   The WebService method.
         * @param {Object} data     Arguments to pass to the method.
         * @param {Object} preSets  Extra settings.
         * @param {String} cacheKey (Optional) Extra key to add to the cache object to identify similar calls.
         * @return {Promise}        Promise to be resolved when the response is saved.
         */
        function saveToCache(site, method, data, response, cacheKey) {
            var db = site.db,
                id = md5.createHash(method + ':' + JSON.stringify(data)),
                cacheExpirationTime = mmCoreConfigConstants.cache_expiration_time,
                entry = {
                        id: id,
                        data: response
                    };

            if (!db) {
                return $q.reject();
            } else {
                cacheExpirationTime = isNaN(cacheExpirationTime) ? 300000 : cacheExpirationTime;
                entry.expirationtime = new Date().getTime() + cacheExpirationTime;
                if (cacheKey) {
                    entry.key = cacheKey;
                }
                return db.insert(mmCoreWSCacheStore, entry);
            }
        }

        /**
         * Make a site object.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmSitesFactory#makeSite
         * @param {String} id      Site ID.
         * @param {String} siteurl Site URL.
         * @param {String} token   User's token in the site.
         * @param {Object} infos   Site's info.
         * @return {Object} The current site object.
         * @description
         * This returns a site object.
         */
        self.makeSite = function(id, siteurl, token, infos) {
            return new Site(id, siteurl, token, infos);
        };

        /**
         * Gets the list of Site methods.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmSitesFactory#getSiteMethods
         * @return {Array} List of methods.
         */
        self.getSiteMethods = function() {
            var methods = [];
            for (var name in Site.prototype) {
                methods.push(name);
            }
            return methods;
        };

        return self;
    }];
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreSitesStore', 'sites')
.constant('mmCoreCurrentSiteStore', 'current_site')

.config(["$mmAppProvider", "mmCoreSitesStore", "mmCoreCurrentSiteStore", function($mmAppProvider, mmCoreSitesStore, mmCoreCurrentSiteStore) {
    var stores = [
        {
            name: mmCoreSitesStore,
            keyPath: 'id'
        },
        {
            name: mmCoreCurrentSiteStore,
            keyPath: 'id'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

/**
 * Sites manager service.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmSitesManager
 */
.factory('$mmSitesManager', ["$http", "$q", "$mmSitesFactory", "md5", "$mmLang", "$mmApp", "$mmUtil", "$mmEvents", "$state", "$translate", "mmCoreSitesStore", "mmCoreCurrentSiteStore", "mmCoreEventLogin", "mmCoreEventLogout", "$log", "mmCoreWSPrefix", "mmCoreEventSiteUpdated", "mmCoreEventSiteAdded", "mmCoreEventSessionExpired", "mmCoreEventSiteDeleted", "$mmText", "mmCoreConfigConstants", function($http, $q, $mmSitesFactory, md5, $mmLang, $mmApp, $mmUtil, $mmEvents, $state,
            $translate, mmCoreSitesStore, mmCoreCurrentSiteStore, mmCoreEventLogin, mmCoreEventLogout, $log, mmCoreWSPrefix,
            mmCoreEventSiteUpdated, mmCoreEventSiteAdded, mmCoreEventSessionExpired, mmCoreEventSiteDeleted, $mmText,
            mmCoreConfigConstants) {

    $log = $log.getInstance('$mmSitesManager');

    var self = {},
        services = {},
        sessionRestored = false,
        currentSite,
        sites = {};

    /**
     * Get the demo data of the siteurl if it is a demo site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getDemoSiteData
     * @param  {String} siteurl URL of the site to check.
     * @return {Object}         Site data if it's a demo site, undefined otherwise.
     */
    self.getDemoSiteData = function(siteurl) {
        var demoSites = mmCoreConfigConstants.demo_sites;
        if (typeof demoSites != 'undefined' && typeof demoSites[siteurl] != 'undefined') {
            return demoSites[siteurl];
        }
    };

    /**
     * Check if a site is valid and if it has specifics settings for authentication
     * (like force to log in using the browser).
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#checkSite
     * @param {String} siteurl  URL of the site to check.
     * @param {String} protocol Protocol to use. If not defined, use https.
     * @return {Promise}        A promise to be resolved when the site is checked. Resolve params:
     *                            {Number} code      Code to identify the authentication method to use.
     *                            {String} siteurl   Site url to use (might have changed during the process).
     *                            {String} [warning] Code of the warning message to show to the user.
     */
    self.checkSite = function(siteurl, protocol) {

        // formatURL adds the protocol if is missing.
        siteurl = $mmUtil.formatURL(siteurl);

        if (siteurl.indexOf('://localhost') == -1 && !$mmUtil.isValidURL(siteurl)) {
            return $mmLang.translateAndReject('mm.login.invalidsite');
        } else if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        } else {

            protocol = protocol || "https://";

            // Now, replace the siteurl with the protocol.
            siteurl = siteurl.replace(/^http(s)?\:\/\//i, protocol);

            return self.siteExists(siteurl).then(function() {
                // Create a temporary site to check if local_mobile is installed.
                var temporarySite = $mmSitesFactory.makeSite(undefined, siteurl);
                return temporarySite.checkLocalMobilePlugin().then(function(data) {
                    siteurl = temporarySite.getURL();
                    services[siteurl] = data.service; // No need to store it in DB.
                    return {siteurl: siteurl, code: data.code, warning: data.warning};
                });
            }, function() {
                // Site doesn't exist.

                if (siteurl.indexOf("https://") === 0) {
                    // Retry without HTTPS.
                    return self.checkSite(siteurl, "http://");
                } else{
                    return $mmLang.translateAndReject('mm.core.cannotconnect');
                }
            });
        }
    };

    /**
     * Check if a site exists.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#siteExists
     * @param  {String} siteurl URL of the site to check.
     * @return {Promise}        A promise to be resolved if the site exists.
     */
    self.siteExists = function(siteurl) {
        var url = siteurl + '/login/token.php';
        if (!ionic.Platform.isWebView()) {
            // We pass fake parameters to make CORS work (without params, the script stops before allowing CORS).
            url = url + '?username=a&password=b&service=c';
        }
        return $http.get(url, {timeout: 30000});
    };

    /**
     * Gets a user token from the server.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getUserToken
     * @param {String} siteurl   The site url.
     * @param {String} username  User name.
     * @param {String} password  Password.
     * @param {String} [service] Service to use. If not defined, it will be searched in memory.
     * @param {Boolean} retry    We are retrying with a prefixed URL.
     * @return {Promise}         A promise to be resolved when the token is retrieved. If success, returns an object
     *                           with the token and the siteurl to use.
     */
    self.getUserToken = function(siteurl, username, password, service, retry) {
        retry = retry || false;

        if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        }

        if (!service) {
            service = determineService(siteurl);
        }

        var loginurl = siteurl + '/login/token.php';
        var data = {
            username: username,
            password: password,
            service: service
        };

        return $http.post(loginurl, data).then(function(response) {
            var data = response.data;

            if (typeof data == 'undefined') {
                return $mmLang.translateAndReject('mm.core.cannotconnect');
            } else {
                if (typeof data.token != 'undefined') {
                    return {token: data.token, siteurl: siteurl};
                } else {
                    if (typeof data.error != 'undefined') {
                        // We only allow one retry (to avoid loops).
                        if (!retry && data.errorcode == "requirecorrectaccess") {
                            siteurl = $mmText.addOrRemoveWWW(siteurl);
                            return self.getUserToken(siteurl, username, password, service, true);
                        } else {
                            return $q.reject(data.error);
                        }
                    } else {
                        return $mmLang.translateAndReject('mm.login.invalidaccount');
                    }
                }
            }
        }, function() {
            return $mmLang.translateAndReject('mm.core.cannotconnect');
        });
    };

    /**
     * Add a new site to the site list and authenticate the user in this site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#newSite
     * @param {String} siteurl  The site url.
     * @param {String} token    User's token.
     * @return {Promise}        A promise to be resolved when the site is added and the user is authenticated.
     */
    self.newSite = function(siteurl, token) {

        var candidateSite = $mmSitesFactory.makeSite(undefined, siteurl, token);

        return candidateSite.fetchSiteInfo().then(function(infos) {
            if (isValidMoodleVersion(infos)) {
                var validation = validateSiteInfo(infos);
                if (validation === true) {
                    var siteid = self.createSiteID(infos.siteurl, infos.username);
                    // Add site to sites list.
                    self.addSite(siteid, siteurl, token, infos);
                    // Turn candidate site into current site.
                    candidateSite.setId(siteid);
                    candidateSite.setInfo(infos);
                    currentSite = candidateSite;
                    // Store session.
                    self.login(siteid);
                    $mmEvents.trigger(mmCoreEventSiteAdded);
                } else {
                    return $translate(validation.error, validation.params).then(function(error) {
                        return $q.reject(error);
                    });
                }
            } else {
                return $mmLang.translateAndReject('mm.login.invalidmoodleversion');
            }
        });
    };

    /**
     * Create a site ID based on site URL and username.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#createSiteID
     * @param {String} siteurl  The site url.
     * @param {String} username Username.
     * @return {String}         Site ID.
     */
    self.createSiteID = function(siteurl, username) {
        return md5.createHash(siteurl + username);
    };

    /**
     * Function for determine which service we should use (default or extended plugin).
     *
     * @param  {String} siteurl The site URL.
     * @return {String}         The service shortname.
     */
    function determineService(siteurl) {
        // We need to try siteurl in both https or http (due to loginhttps setting).

        // First http://
        siteurl = siteurl.replace("https://", "http://");
        if (services[siteurl]) {
            return services[siteurl];
        }

        // Now https://
        siteurl = siteurl.replace("http://", "https://");
        if (services[siteurl]) {
            return services[siteurl];
        }

        // Return default service.
        return mmCoreConfigConstants.wsservice;
    }

    /**
     * Check for the minimum required version (Moodle 2.4).
     *
     * @param {Array} sitefunctions List of functions of the Moodle site.
     * @return {Boolean}            True if the moodle version is valid, false otherwise.
     */
    function isValidMoodleVersion(infos) {
        if (!infos) {
            return false;
        }

        var minVersion = 2012120300, // Moodle 2.4 version.
            minRelease = "2.4";

        // Try to validate by version.
        if (infos.version) {
            var version = parseInt(infos.version);
            if (!isNaN(version)) {
                return version >= minVersion;
            }
        }

        // We couldn't validate by version number. Let's try to validate by release number.
        if (infos.release) {
            var matches = infos.release.match(/^([\d|\.]*)/);
            if (matches && matches.length > 1) {
                return matches[1] >= minRelease;
            }
        }

        // Couldn't validate by release either. Check if it uses local_mobile plugin.
        var appUsesLocalMobile = false;
        angular.forEach(infos.functions, function(func) {
            if (func.name.indexOf(mmCoreWSPrefix) != -1) {
                appUsesLocalMobile = true;
            }
        });

        return appUsesLocalMobile;
    }

    /**
     * Check if site info is valid. If it's not, return error message.
     *
     * @param {Object} infos    Site info.
     * @return {Object|Boolean} Object with error message to show and its params if info is not valid, true if info is valid.
     */
    function validateSiteInfo(infos) {
        if (!infos.firstname || !infos.lastname) {
            var moodleLink = '<a mm-browser href="' + infos.siteurl + '">' + infos.siteurl + '</a>';
            return {error: 'mm.core.requireduserdatamissing', params: {'$a': moodleLink}};
        }
        return true;
    }

    /**
     * Saves a site in local DB.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#addSite
     * @param {String} id      Site ID.
     * @param {String} siteurl Site URL.
     * @param {String} token   User's token in the site.
     * @param {Object} infos   Site's info.
     */
    self.addSite = function(id, siteurl, token, infos) {
        return $mmApp.getDB().insert(mmCoreSitesStore, {
            id: id,
            siteurl: siteurl,
            token: token,
            infos: infos
        });
    };

    /**
     * Login a user to a site from the list of sites.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#loadSite
     * @param {String} siteid ID of the site to load.
     * @return {Promise}      Promise to be resolved when the site is loaded.
     */
    self.loadSite = function(siteid) {
        $log.debug('Load site '+siteid);

        return self.getSite(siteid).then(function(site) {
            currentSite = site;
            self.login(siteid);

            // Check if local_mobile was installed to Moodle.
            return site.checkIfLocalMobileInstalledAndNotUsed().then(function() {
                // Local mobile was added. Throw invalid session to force reconnect and create a new token.
                $mmEvents.trigger(mmCoreEventSessionExpired, siteid);
            }, function() {
                // Update site info. We don't block the UI.
                self.updateSiteInfo(siteid).finally(function() {
                    var infos = site.getInfo(),
                        validation = validateSiteInfo(infos);
                    if (validation !== true) {
                        // Site info is not valid. Logout the user and show an error message.
                        self.logout();
                        $state.go('mm_login.sites');
                        $translate(validation.error, validation.params).then(function(error) {
                            $mmUtil.showErrorModal(error);
                        });
                    }
                });
            });
        });
    };

    /**
     * Get current site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getCurrentSite
     * @return {Object} Current site.
     */
    self.getCurrentSite = function() {
        return currentSite;
    };

    /**
     * Delete a site from the sites list.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#deleteSite
     * @param {String} siteid ID of the site to delete.
     * @return {Promise}      Promise to be resolved when the site is deleted.
     */
    self.deleteSite = function(siteid) {
        $log.debug('Delete site '+siteid);

        if (typeof currentSite != 'undefined' && currentSite.id == siteid) {
            self.logout();
        }

        return self.getSite(siteid).then(function(site) {
            return site.deleteDB().then(function() {
                delete sites[siteid];
                return $mmApp.getDB().remove(mmCoreSitesStore, siteid).then(function() {
                    return site.deleteFolder();
                }, function() {
                    // DB remove shouldn't fail, but we'll go ahead even if it does.
                    return site.deleteFolder();
                }).then(function() {
                    $mmEvents.trigger(mmCoreEventSiteDeleted, site);
                });
            });
        });
    };

    /**
     * Check if there are no sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#hasNoSites
     * @return {Promise} Promise to be resolved if there are no sites, and rejected if there is at least one.
     */
    self.hasNoSites = function() {
        return $mmApp.getDB().count(mmCoreSitesStore).then(function(count) {
            if (count > 0) {
                return $q.reject();
            }
        });
    };

    /**
     * Check if there are sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#hasSites
     * @return {Promise} Promise to be resolved if there is at least one site, and rejected if there aren't.
     */
    self.hasSites = function() {
        return $mmApp.getDB().count(mmCoreSitesStore).then(function(count) {
            if (count == 0) {
                return $q.reject();
            }
        });
    };

    /**
     * Returns a site object.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSite
     * @param  {Number} siteId The site ID.
     * @return {Promise}
     */
    self.getSite = function(siteId) {
        if (!siteId) {
            // Site ID not valid, reject.
            return $q.reject();
        } else if (currentSite && currentSite.getId() === siteId) {
            return $q.when(currentSite);
        } else if (typeof sites[siteId] != 'undefined') {
            return $q.when(sites[siteId]);
        } else {
            return $mmApp.getDB().get(mmCoreSitesStore, siteId).then(function(data) {
                var site = $mmSitesFactory.makeSite(siteId, data.siteurl, data.token, data.infos);
                sites[siteId] = site;
                return site;
            });
        }
    };

    /**
     * Returns the database object of a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSiteDb
     * @param  {Number} siteId The site ID.
     * @return {Promise}
     */
    self.getSiteDb = function(siteId) {
        return self.getSite(siteId).then(function(site) {
            return site.getDb();
        });
    };

    /**
     * Get the list of sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSites
     * @param {String[]} [ids] IDs of the sites to get. If not defined, return all sites.
     * @return {Promise}       Promise to be resolved when the sites are retrieved.
     */
    self.getSites = function(ids) {
        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var formattedSites = [];
            angular.forEach(sites, function(site) {
                if (!ids || ids.indexOf(site.id) > -1) {
                    formattedSites.push({
                        id: site.id,
                        siteurl: site.siteurl,
                        fullname: site.infos.fullname,
                        sitename: site.infos.sitename,
                        avatar: site.infos.userpictureurl
                    });
                }
            });
            return formattedSites;
        });
    };

    /**
     * Get the list of IDs of sites stored.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSitesIds
     * @return {Promise} Promise to be resolved when the sites IDs are retrieved.
     */
    self.getSitesIds = function() {
        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var ids = [];
            angular.forEach(sites, function(site) {
                ids.push(site.id);
            });
            return ids;
        });
    };

    /**
     * Login the user in a site.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#login
     * @param  {String} siteid ID of the site the user is accessing.
     * @return {Promise}       Promise resolved when current site is stored.
     */
    self.login = function(siteid) {
        return $mmApp.getDB().insert(mmCoreCurrentSiteStore, {
            id: 1,
            siteid: siteid
        }).then(function() {
            $mmEvents.trigger(mmCoreEventLogin);
        });
    };

    /**
     * Logout the user.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#logout
     * @return {Promise} Promise to be resolved when the user is logged out.
     */
    self.logout = function() {
        currentSite = undefined;
        $mmEvents.trigger(mmCoreEventLogout);
        return $mmApp.getDB().remove(mmCoreCurrentSiteStore, 1);
    }

    /**
     * Restores the session to the previous one so the user doesn't has to login everytime the app is started.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#restoreSession
     * @return {Promise} Promise to be resolved if a session is restored.
     */
    self.restoreSession = function() {
        if (sessionRestored) {
            return $q.reject();
        }
        sessionRestored = true;

        return $mmApp.getDB().get(mmCoreCurrentSiteStore, 1).then(function(current_site) {
            var siteid = current_site.siteid;
            $log.debug('Restore session in site '+siteid);
            return self.loadSite(siteid);
        }, function() {
            return $q.reject(); // Reject without params.
        });
    };

    /**
     * Updates a site's token.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#updateSiteToken
     * @param {String} siteurl  Site's URL.
     * @param {String} username Username.
     * @param {String} token    User's new token.
     * @return {Promise}        A promise to be resolved when the site is updated.
     */
    self.updateSiteToken = function(siteurl, username, token) {
        var siteid = self.createSiteID(siteurl, username);
        return self.getSite(siteid).then(function(site) {
            site.token = token;

            return $mmApp.getDB().insert(mmCoreSitesStore, {
                id: siteid,
                siteurl: site.getURL(),
                token: token,
                infos: site.getInfo()
            });
        });
    };

    /**
     * Updates a site's info.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#updateSiteInfo
     * @param {String} siteid Site's ID.
     * @return {Promise}      A promise to be resolved when the site is updated.
     */
    self.updateSiteInfo = function(siteid) {
        return self.getSite(siteid).then(function(site) {
            return site.fetchSiteInfo().then(function(infos) {
                site.setInfo(infos);
                return $mmApp.getDB().insert(mmCoreSitesStore, {
                    id: siteid,
                    siteurl: site.getURL(),
                    token: site.getToken(),
                    infos: infos
                }).finally(function() {
                    $mmEvents.trigger(mmCoreEventSiteUpdated, siteid);
                });
            });
        });
    };

    /**
     * Updates a site's info.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#updateSiteInfoByUrl
     * @param {String} siteurl  Site's URL.
     * @param {String} username Username.
     * @return {Promise}        A promise to be resolved when the site is updated.
     */
    self.updateSiteInfoByUrl = function(siteurl, username) {
        var siteid = self.createSiteID(siteurl, username);
        return self.updateSiteInfo(siteid);
    };

    /**
     * Get the site IDs a URL belongs to.
     * Someone can have more than one account in the same site, that's why this function returns an array of IDs.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmSitesManager#getSitesUrls
     * @param {String} url         URL to check.
     * @param {Boolean} prioritize True if it should prioritize current site. If the URL belongs to current site then it won't
     *                             check any other site, it will only return current site.
     * @return {Promise}           Promise resolved with the site IDs (array).
     */
    self.getSiteIdsFromUrl = function(url, prioritize) {
        // Check current site first, it has priority over the rest of sites.
        if (prioritize && currentSite && currentSite.containsUrl(url)) {
            return $q.when([currentSite.getId()]);
        }

        // Check if URL has http(s) protocol.
        if (!url.match(/^https?:\/\//i)) {
            // URL doesn't have http(s) protocol. Check if it has any protocol.
            if (url.match(/^[^:]{2,10}:\/\//i)) {
                // It has some protocol. Return empty array.
                return $q.when([]);
            } else {
                // No protocol, probably a relative URL. Return current site.
                if (currentSite) {
                    return $q.when([currentSite.getId()]);
                } else {
                    return $q.when([]);
                }
            }
        }

        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var ids = [];
            angular.forEach(sites, function(site) {
                if (!sites[site.id]) {
                    sites[site.id] = $mmSitesFactory.makeSite(site.id, site.siteurl, site.token, site.infos);
                }
                if (sites[site.id].containsUrl(url)) {
                    ids.push(site.id);
                }
            });
            return ids;
        }).catch(function() {
            // Shouldn't happen.
            return [];
        });
    };

    return self;

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * @ngdoc service
 * @name $mmText
 * @module mm.core
 * @description
 * This service provides functions related to text, like formatting texts from Moodle.
 */
.factory('$mmText', ["$q", "$mmLang", "$translate", function($q, $mmLang, $translate) {

    var self = {};

    /**
     * Convert size in bytes into human readable format
     * http://codeaid.net/javascript/convert-size-in-bytes-to-human-readable-format-(javascript)
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#bytesToSize
     * @param {Number} bytes         Number of bytes to convert.
     * @param {Number} [precision=2] Number of digits after the decimal separator.
     * @return {String}              Size in human readable format.
     */
    self.bytesToSize = function(bytes, precision) {

        if (typeof bytes == 'undefined' || bytes < 0) {
            return $translate.instant('mm.core.notapplicable');
        }

        if (typeof precision == 'undefined' || precision < 0) {
            precision = 2;
        }

        var keys = ['mm.core.sizeb', 'mm.core.sizekb', 'mm.core.sizemb', 'mm.core.sizegb', 'mm.core.sizetb'];
        var units = $translate.instant(keys);
        var posttxt = 0;
        if (bytes >= 1024) {
            while (bytes >= 1024) {
                posttxt++;
                bytes = bytes / 1024;
            }
            bytes = Number(Math.round(bytes+'e+'+precision) + 'e-'+precision); // Round to "precision" decimals if needed.
        }
        return $translate.instant('mm.core.humanreadablesize', {size: Number(bytes), unit: units[keys[posttxt]]});
    };

    /**
     * Function to clean HTML tags.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#cleanTags
     * @param  {String}  text         The text to be cleaned.
     * @param  {Boolean} [singleLine] True if new lines should be removed (all the text in a single line).
     * @return {String}               Text cleaned.
     */
    self.cleanTags = function(text, singleLine) {
        // First, we use a regexpr.
        text = text.replace(/(<([^>]+)>)/ig,"");
        // Then, we rely on the browser. We need to wrap the text to be sure is HTML.
        text = angular.element('<p>').html(text).text(); // Get directive's content.
        // Recover or remove new lines.
        text = self.replaceNewLines(text, singleLine ? ' ' : '<br />');
        return text;
    };

    /**
     * Replace all the new lines on a certain text.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#replaceNewLines
     * @param  {String}  text     The text to be treated.
     * @param  {Boolean} newValue Text to place on each new line.
     * @return {String}           Treated text.
     */
    self.replaceNewLines = function(text, newValue) {
        return text.replace(/(?:\r\n|\r|\n)/g, newValue);
    };

    /**
     * Formats a text, treating multilang tags and cleaning HTML if needed.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#formatText
     * @param  {String} text             Text to format.
     * @param  {Boolean} clean           True if HTML tags should be removed, false otherwise.
     * @param  {Boolean} [singleLine]    True if new lines should be removed. Only valid if clean is true.
     * @param  {Number}  [shortenLength] Number of characters to shorten the text.
     * @return {Promise}                 Promise resolved with the formatted text.
     */
    self.formatText = function(text, clean, singleLine, shortenLength) {
        return self.treatMultilangTags(text).then(function(formatted) {
            if (clean) {
                formatted = self.cleanTags(formatted, singleLine);
            }
            if (shortenLength && parseInt(shortenLength) > 0) {
                formatted = self.shortenText(formatted, parseInt(shortenLength));
            }
            return formatted;
        });
    };

    /**
     * Shortens a text to length and adds an ellipsis.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#shortenText
     * @param  {String} text The text to be shortened.
     * @param  {Number} length The desired length.
     * @return {String} Shortened text.
     */
    self.shortenText = function(text, length) {
        if (text.length > length) {
            text = text.substr(0, length);

            // Now, truncate at the last word boundary (if exists).
            var lastWordPos = text.lastIndexOf(' ');
            if (lastWordPos > 0) {
                text = text.substr(0, lastWordPos);
            }
            text += '&hellip;';
        }
        return text;
    };

    /**
     * Treat the multilang tags from a HTML code, leaving only the current language.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#treatMultilangTags
     * @param {String} text   The text to be formatted.
     * @param {String} siteId ID of the site to use. If not set, use current site.
     * @return {Promise}      Promise resolved with the formatted text.
     */
    self.treatMultilangTags = function(text) {
        if (!text) {
            return $q.when('');
        }

        return $mmLang.getCurrentLanguage().then(function(language) {
            // Match the current language
            var currentLangRe = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g'),
                anyLangRE = /<(?:lang|span)[^>]+lang="[a-zA-Z0-9_-]+"[^>]*>(.*?)<\/(?:lang|span)>/g;

            if (!text.match(currentLangRe)) {
                // Current lang not found. Try to find the first language.
                var matches = text.match(anyLangRE);
                if (matches && matches[0]) {
                    language = matches[0].match(/lang="([a-zA-Z0-9_-]+)"/)[1];
                    currentLangRe = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g');
                } else {
                    // No multi-lang tag found, stop.
                    return text;
                }
            }
            // Extract contents of current language.
            text = text.replace(currentLangRe, '$1');
            // Delete the rest of languages
            text = text.replace(anyLangRE, '');
            return text;
        });
    };

    /**
     * Escape an HTML text. This implementation is based on PHP's htmlspecialchars.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#escapeHTML
     * @param  {String} text Text to escape.
     * @return {String}      Escaped text.
     */
    self.escapeHTML = function(text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        } else if (typeof text != 'string') {
            return '' + text;
        }

        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    };

    /**
     * Add or remove 'www' from a URL. The url needs to have http or https protocol.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#addOrRemoveWWW
     * @param {String} url URL to modify.
     * @return             Modified URL.
     */
    self.addOrRemoveWWW = function(url) {
        if (typeof url == 'string') {
            if (url.match(/http(s)?:\/\/www\./)) {
                // Already has www. Remove it.
                url = url.replace('www.', '');
            } else {
                url = url.replace('https://', 'https://www.');
                url = url.replace('http://', 'http://www.');
            }
        }
        return url;
    };

    /**
     * Remove protocol and www from a URL.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmText#removeProtocolAndWWW
     * @param  {String} url URL to treat.
     * @return {String}     Treated URL.
     */
    self.removeProtocolAndWWW = function(url) {
        // Remove protocol.
        url = url.replace(/.*?:\/\//g, '');
        // Remove www.
        url = url.replace(/^www./, '');
        return url;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreVersionApplied', 'version_applied')

/**
 * Factory to handle app updates. This factory shouldn't be used outside of core.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmUpdateManager
 * @description
 * This service handles processes that need to be run when updating the app, like migrate MM1 sites to MM2.
 */
.factory('$mmUpdateManager', ["$log", "$q", "$mmConfig", "$mmSitesManager", "$mmFS", "$cordovaLocalNotification", "$mmLocalNotifications", "$mmApp", "$mmEvents", "mmCoreSitesStore", "mmCoreVersionApplied", "mmCoreEventSiteAdded", "mmCoreEventSiteUpdated", "mmCoreEventSiteDeleted", "$injector", "$mmFilepool", "mmCoreCourseModulesStore", "mmFilepoolLinksStore", "mmFilepoolPackagesStore", "mmCoreConfigConstants", function($log, $q, $mmConfig, $mmSitesManager, $mmFS, $cordovaLocalNotification, $mmLocalNotifications,
            $mmApp, $mmEvents, mmCoreSitesStore, mmCoreVersionApplied, mmCoreEventSiteAdded, mmCoreEventSiteUpdated,
            mmCoreEventSiteDeleted, $injector, $mmFilepool, mmCoreCourseModulesStore, mmFilepoolLinksStore,
            mmFilepoolPackagesStore, mmCoreConfigConstants) {

    $log = $log.getInstance('$mmUpdateManager');

    var self = {},
        sitesFilePath = 'migration/sites.json';

    /**
     * Check if the app has been updated and performs the needed processes.
     * This function shouldn't be used outside of core.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUpdateManager#check
     * @return {Promise} Promise resolved when the update process finishes.
     */
    self.check = function() {
        var promises = [],
            versionCode = mmCoreConfigConstants.versioncode;

        return $mmConfig.get(mmCoreVersionApplied, 0).then(function(versionApplied) {

            if (versionCode >= 391 && versionApplied < 391) {
                // Migrating from MM1 to MM2.
                promises.push(migrateMM1Sites());
                // Ignore errors in clearAppFolder. We don't want to clear the folder
                // everytime the app is opened if something goes wrong.
                promises.push(clearAppFolder().catch(function() {}));
            }

            if (versionCode >= 2003 && versionApplied < 2003) {
                promises.push(cancelAndroidNotifications());
            }

            if (versionCode >= 2003) {
                setStoreSitesInFile();
            }

            if (versionCode >= 2007 && versionApplied < 2007) {
                promises.push(migrateModulesStatus());
            }

            return $q.all(promises).then(function() {
                return $mmConfig.set(mmCoreVersionApplied, versionCode);
            }).catch(function() {
                $log.error('Error applying update from ' + versionApplied + ' to ' + versionCode);
            });
        });
    };

    /**
     * Clear the app folder.
     *
     * @return {Promise} Promise resolved when the folder is cleared.
     */
    function clearAppFolder() {
        if ($mmFS.isAvailable()) {
            return $mmFS.getDirectoryContents('').then(function(entries) {
                var promises = [];
                angular.forEach(entries, function(entry) {
                    // In Android, don't delete 'cache' and 'files' folders, created by the OS.
                    var canDeleteAndroid = ionic.Platform.isAndroid() && entry.name !== 'cache' && entry.name !== 'files';
                    var canDeleteIOS = ionic.Platform.isIOS() && entry.name !== 'NoCloud';
                    if (canDeleteIOS || canDeleteAndroid) {
                        promises.push($mmFS.removeDir(entry.name));
                    }
                });
                return $q.all(promises);
            });
        } else {
            return $q.when();
        }
    }

    /**
     * Migrate MoodleMobile 1 sites to MoodleMobile 2.
     *
     * @return {Promise} Promise resolved when the sites are migrated.
     */
    function migrateMM1Sites() {
        var sites = localStorage.getItem('sites'),
            promises = [];

        if (sites) {
            sites = sites.split(',');

            angular.forEach(sites, function(siteid) {
                if (!siteid) {
                    return;
                }

                $log.debug('Migrating site from MoodleMobile 1: ' + siteid);
                var site = localStorage.getItem('sites-'+siteid),
                    infos;

                if (site) {
                    try {
                        site = JSON.parse(site);
                    } catch(ex) {
                        // Invalid site. Shouldn't happen.
                        $log.warn('Site ' + siteid + ' data is invalid. Ignoring.');
                        return;
                    }

                    // In MM1 site info is mixed with site basic data (id, token, siteurl).
                    infos = angular.copy(site);
                    delete infos.id;
                    delete infos.token;
                    promises.push($mmSitesManager.addSite(site.id, site.siteurl, site.token, infos));
                } else {
                    $log.warn('Site ' + siteid + ' not found in local storage. Ignoring.');
                }
            });
        }

        return $q.all(promises).then(function() {
            if (sites) {
                localStorage.clear();
            }
        });
    }

    /**
     * Cancel all Android notifications. MM 2.0 was released with a bug in notifications ID (Android). These IDs were stored in
     * SharedPreferences, cancel them all will clear the stored values. @see MOBILE-1148.
     *
     * @return {Promise} Promise resolved when the notifications are cancelled.
     */
    function cancelAndroidNotifications() {
        if ($mmLocalNotifications.isAvailable() && ionic.Platform.isAndroid()) {
            return $cordovaLocalNotification.cancelAll().catch(function() {
                $log.error('Error cancelling Android notifications.');
            });
        }
        return $q.when();
    }

    /**
     * Sets the events to store the sites in a file.
     */
    function setStoreSitesInFile() {
        $mmEvents.on(mmCoreEventSiteAdded, storeSitesInFile);
        $mmEvents.on(mmCoreEventSiteUpdated, storeSitesInFile);
        $mmEvents.on(mmCoreEventSiteDeleted, storeSitesInFile);
        storeSitesInFile();
    }

    /**
     * Get sites stored in a file. It'll be used to migrate to Crosswalk if users skipped SQLite migration version.
     *
     * @return {Promise} Promise resolved with sites are retrieved. Resolve param is the sites list.
     */
    function getSitesStoredInFile() {
        if ($mmFS.isAvailable()) {
            return $mmFS.readFile(sitesFilePath).then(function(sites) {
                try {
                    sites = JSON.parse(sites);
                } catch (ex) {
                    sites = [];
                }
                return sites;
            }).catch(function() {
                // Error reading, probably file doesn't exist. Return empty list.
                return [];
            });
        } else {
            return $q.when([]);
        }
    }

    /**
     * Store sites in a file. It'll be used to migrate to Crosswalk if users skipped SQLite migration version.
     *
     * @return {Promise} Promise resolved when file is written.
     */
    function storeSitesInFile() {
        if ($mmFS.isAvailable()) {
            return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
                angular.forEach(sites, function(site) {
                    site.token = 'private'; // Remove the token, we don't want it written in a file.
                });
                return $mmFS.writeFile(sitesFilePath, JSON.stringify(sites));
            });
        } else {
            return $q.when();
        }
    }

    /**
     * Delete file with sites stored.
     *
     * @return {Promise} Promise resolved when file is deleted.
     */
    function deleteSitesFile() {
        if ($mmFS.isAvailable()) {
            return $mmFS.removeFile(sitesFilePath);
        } else {
            return $q.when();
        }
    }

    /**
     * Migrate mmCoreCourseModulesStore to mmFilepoolPackagesStore.
     *
     * @return {Promise} Promise resolved when the migration is finished.
     */
    function migrateModulesStatus() {
        var components = [];
        components.push($injector.get('mmaModBookComponent'));
        components.push($injector.get('mmaModImscpComponent'));
        components.push($injector.get('mmaModPageComponent'));
        components.push($injector.get('mmaModResourceComponent'));

        return $mmSitesManager.getSitesIds().then(function(sites) {
            var promises = [];
            angular.forEach(sites, function(siteId) {
                promises.push(migrateSiteModulesStatus(siteId, components));
            });
            return $q.all(promises);
        });
    }

    /**
     * Migrates the modules status from a certain site.
     *
     * @param {String} siteId       Site ID.
     * @param {String[]} components Components to check.
     * @return {Promise}            Promise resolved when the site migration is finished.
     */
    function migrateSiteModulesStatus(siteId, components) {
        $log.debug('Migrate site modules status from site ' + siteId);

        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            return db.getAll(mmCoreCourseModulesStore).then(function(entries) {
                var promises = [];

                angular.forEach(entries, function(entry) {
                    if (!parseInt(entry.id)) {
                        return; // The id is not a number, ignore it.
                    }

                    promises.push(determineComponent(db, entry.id, components).then(function(component) {
                        if (component) {
                            // Add a new entry in filepool store.
                            // We don't use $mmFilepool#storePackageStatus because we want to keep previousStatus.
                            entry.component = component;
                            entry.componentId = entry.id;
                            entry.id = $mmFilepool.getPackageId(component, entry.id);
                            promises.push(db.insert(mmFilepoolPackagesStore, entry));
                        }
                    }));
                });

                return $q.all(promises).then(function() {
                    // Success creating all the new entries. Let's remove the old ones.
                    return db.removeAll(mmCoreCourseModulesStore).catch(function() {
                        // Ignore errors.
                    });
                });
            });
        });
    }

    /**
     * Determines the component of a module status entry.
     *
     * @param  {Object} db           Site database.
     * @param  {Number} componentId  Component ID.
     * @param  {String[]} components List of components to check.
     * @return {Promise}             Promise resolved with the component or undefined if no component found.
     */
    function determineComponent(db, componentId, components) {
        var promises = [],
            component;

        angular.forEach(components, function(c) {
            if (c) {
                promises.push(db.query(mmFilepoolLinksStore, ['componentAndId', '=', [c, componentId]]).then(function(items) {
                    if (items.length) {
                        component = c;
                    }
                }).catch(function() {
                    // Never reject.
                }));
            }
        });

        return $q.all(promises).then(function() {
            return component;
        });
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Service to handle custom URLs schemes. Notifies all the observers when the app is invoked with a custom URL.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmURLDelegate
 */
.factory('$mmURLDelegate', ["$log", function($log) {

    $log = $log.getInstance('$mmURLDelegate');

    var observers = {},
        self = {};

    /**
     * Register an observer to be notified when the app is launched via custom URL scheme.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmURLDelegate#register
     * @param {String} name       Observer's name. Must be unique.
     * @param {Function} callback Function to call with the URLs received by the app. This function should check if the URL
     *                            is the one expected by the observer and return true if it is, return false otherwise.
     */
    self.register = function(name, callback) {
        $log.debug("Register observer '"+name+"' for custom URL.");
        observers[name] = callback;
    };

    /**
     * Notify all observers.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmURLDelegate#notify
     * @param {String} url URL to notify to the observers.
     */
    self.notify = function(url) {
        var treated = false; // Once an observer accepts a URL (return true) we stop notifying.
        angular.forEach(observers, function(callback, name) {
            if (!treated && typeof(callback) === 'function') {
                treated = callback(url);
            }
        });
    };

    return self;
}])

.run(["$mmURLDelegate", "$log", function($mmURLDelegate, $log) {
    window.handleOpenURL = function(url) {
        $log.debug('App launched by URL.');
        $mmURLDelegate.notify(url);
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Provider with some 'util' functionalities.
 *
 * @module mm.core
 * @ngdoc provider
 * @name $mmUtil
 */
.provider('$mmUtil', ["mmCoreSecondsYear", "mmCoreSecondsDay", "mmCoreSecondsHour", "mmCoreSecondsMinute", function(mmCoreSecondsYear, mmCoreSecondsDay, mmCoreSecondsHour, mmCoreSecondsMinute) {

    var self = this, // Use 'self' to be coherent with the rest of services.
        provider = this; // To access provider methods from the service.

    /**
     * Serialize an object to be used in a request.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmUtilProvider#param
     * @param  {Object} obj Object to serialize.
     * @return {String}     Serialization of the object.
     */
    self.param = function(obj) {
        var query = '', name, value, fullSubName, subName, subValue, innerObj, i;

        for (name in obj) {
            value = obj[name];

            if (value instanceof Array) {
                for (i = 0; i < value.length; ++i) {
                    subValue = value[i];
                    fullSubName = name + '[' + i + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += self.param(innerObj) + '&';
                }
            }
            else if (value instanceof Object) {
                for (subName in value) {
                    subValue = value[subName];
                    fullSubName = name + '[' + subName + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += self.param(innerObj) + '&';
                }
            }
            else if (value !== undefined && value !== null) query += encodeURIComponent(name) + '=' + encodeURIComponent(value) + '&';
        }

        return query.length ? query.substr(0, query.length - 1) : query;
    };

    this.$get = ["$ionicLoading", "$ionicPopup", "$injector", "$translate", "$http", "$log", "$q", "$mmLang", "$mmFS", "$timeout", "$mmApp", "$mmText", "mmCoreWifiDownloadThreshold", "mmCoreDownloadThreshold", function($ionicLoading, $ionicPopup, $injector, $translate, $http, $log, $q, $mmLang, $mmFS, $timeout, $mmApp,
                $mmText, mmCoreWifiDownloadThreshold, mmCoreDownloadThreshold) {

        $log = $log.getInstance('$mmUtil');

        var self = {}; // Use 'self' to be coherent with the rest of services.

        /**
         * Formats a URL, trim, lowercase, etc...
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#formatURL
         * @param  {String} url The url to be formatted.
         * @return {String}     Fromatted url.
         */
        self.formatURL = function(url) {

            url = url.trim();

            // Check if the URL starts by http or https.
            if (! /^http(s)?\:\/\/.*/i.test(url)) {
                // Test first allways https.
                url = "https://" + url;
            }

            // http allways in lowercase.
            url = url.replace(/^http/i, 'http');
            url = url.replace(/^https/i, 'https');

            // Replace last slash.
            url = url.replace(/\/$/, "");

            return url;
        };

        /**
         * Resolves an object.
         *
         * @description
         * This is used to resolve what a callback should be when attached to a delegate.
         * For instance, if the object attached is a function, it is returned as is, but
         * we also support complex definition of objects. If we receive a string we will parse
         * it and to inject its service using $injector from Angular.
         *
         * Examples:
         * - (Function): returns the same function.
         * - (Object): returns the same object.
         * - '$mmSomething': Injects and returns $mmSomething.
         * - '$mmSomething.method': Injectes and returns a reference to the function 'method'.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#resolveObject
         * @param  {Mixed} object String, object or function.
         * @param  {Boolean} [instantiate=false] When true, if the object resolved is a function, instantiates it.
         * @return {Object} The reference to the object resolved.
         */
        self.resolveObject = function(object, instantiate) {
            var toInject,
                resolved;

            instantiate = angular.isUndefined(instantiate) ? false : instantiate;

            if (angular.isFunction(object) || angular.isObject(object)) {
                resolved = object;

            } else if (angular.isString(object)) {
                toInject = object.split('.');
                resolved = $injector.get(toInject[0]);

                if (toInject.length > 1) {
                    resolved = resolved[toInject[1]];
                }
            }

            if (angular.isFunction(resolved) && instantiate) {
                resolved = resolved();
            }

            if (typeof resolved === 'undefined') {
                throw new Error('Unexpected argument passed passed');
            }
            return resolved;
        };

        /**
         * Returns if a URL is downloadable: plugin file OR theme/image.php OR gravatar.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isDownloadableUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is downloadable.
         */
        self.isDownloadableUrl = function(url) {
            return self.isPluginFileUrl(url) || self.isThemeImageUrl(url) || self.isGravatarUrl(url);
        };

        /**
         * Returns if a URL is a gravatar URL.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isGravatarUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is a gravatar URL.
         */
        self.isGravatarUrl = function(url) {
            return url && url.indexOf('gravatar.com/avatar') !== -1;
        };

        /**
         * Returns if a URL is a pluginfile URL.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isPluginFileUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is a pluginfile URL.
         */
        self.isPluginFileUrl = function(url) {
            return url && url.indexOf('/pluginfile.php') !== -1;
        };

        /**
         * Returns if a URL is a theme image URL.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isThemeImageUrl
         * @param  {String}  url The URL to test.
         * @return {Boolean}     True when the URL is a theme image URL.
         */
        self.isThemeImageUrl = function(url) {
            return url && url.indexOf('/theme/image.php') !== -1;
        };

        /**
         * Validates a URL for a specific pattern.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isValidURL
         * @param {String} url The url to test against the pattern
         * @return {Boolean}   TRUE if the url matches the expected pattern.
         *                     FALSE otherwise.
         */
        self.isValidURL = function(url) {
            return /^http(s)?\:\/\/([\da-zA-Z\.-]+)\.([\da-zA-Z\.]{2,6})([\/\w \.-]*)*\/?/i.test(url);
        };

        /**
         * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
         * For download remote files from Moodle we need to use the special /webservice/pluginfile passing
         * the ws token as a get parameter.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#fixPluginfileURL
         * @param {String} url   The url to be fixed.
         * @param {String} token Token to use.
         * @return {String}      Fixed URL.
         */
        self.fixPluginfileURL = function(url, token) {

            // This function is used in regexp callbacks, better not to risk!!
            if (!url) {
                return '';
            }

            // First check if we need to fix this url or is already fixed.
            if (url.indexOf('token=') != -1) {
                return url;
            }

            // Check if is a valid URL (contains the pluginfile endpoint).
            if (url.indexOf('pluginfile') == -1) {
                return url;
            }

            if (!token) {
                return '';
            }

            // In which way the server is serving the files? Are we using slash parameters?
            if (url.indexOf('?file=') != -1 || url.indexOf('?forcedownload=') != -1 || url.indexOf('?rev=') != -1) {
                url += '&';
            } else {
                url += '?';
            }
            url += 'token=' + token;

            // Some webservices returns directly the correct download url, others not.
            if (url.indexOf('/webservice/pluginfile') == -1) {
                url = url.replace('/pluginfile', '/webservice/pluginfile');
            }
            return url;
        };

        /**
         * Open a file using platform specific method.
         *
         * node-webkit: Using the default application configured.
         * Android: Using the WebIntent plugin.
         * iOs: Using the window.open method.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#openFile
         * @param  {String} path The local path of the file to be open.
         * @return {Void}
         */
        self.openFile = function(path) {
            var deferred = $q.defer();

            if (false) {
                // TODO Restore node-webkit support.

                // Link is the file path in the file system.
                // We use the node-webkit shell for open the file (pdf, doc) using the default application configured in the os.
                // var gui = require('nw.gui');
                // gui.Shell.openItem(path);
                deferred.resolve();

            } else if (window.plugins) {
                var extension = $mmFS.getFileExtension(path),
                    mimetype = $mmFS.getMimeType(extension);

                if (ionic.Platform.isAndroid() && window.plugins.webintent) {
                    var iParams = {
                        action: "android.intent.action.VIEW",
                        url: path,
                        type: mimetype
                    };

                    window.plugins.webintent.startActivity(
                        iParams,
                        function() {
                            $log.debug('Intent launched');
                            deferred.resolve();
                        },
                        function() {
                            $log.debug('Intent launching failed.');
                            $log.debug('action: ' + iParams.action);
                            $log.debug('url: ' + iParams.url);
                            $log.debug('type: ' + iParams.type);

                            if (!extension || extension.indexOf('/') > -1 || extension.indexOf('\\') > -1) {
                                // Extension not found.
                                $mmLang.translateAndRejectDeferred(deferred, 'mm.core.erroropenfilenoextension');
                            } else {
                                $mmLang.translateAndRejectDeferred(deferred, 'mm.core.erroropenfilenoapp');
                            }
                        }
                    );

                } else if (ionic.Platform.isIOS() && typeof handleDocumentWithURL == 'function') {

                    $mmFS.getBasePath().then(function(fsRoot) {
                        // Encode/decode the specific file path, note that a path may contain directories
                        // with white spaces, special characters...
                        if (path.indexOf(fsRoot > -1)) {
                            path = path.replace(fsRoot, "");
                            path = encodeURIComponent(decodeURIComponent(path));
                            path = fsRoot + path;
                        }

                        handleDocumentWithURL(
                            function() {
                                $log.debug('File opened with handleDocumentWithURL' + path);
                                deferred.resolve();
                            },
                            function(error) {
                                $log.debug('Error opening with handleDocumentWithURL' + path);
                                if(error == 53) {
                                    $log.error('No app that handles this file type.');
                                }
                                self.openInBrowser(path);
                                deferred.resolve();
                            },
                            path
                        );
                    }, deferred.reject);
                } else {
                    // Last try, launch the file with the browser.
                    self.openInBrowser(path);
                    deferred.resolve();
                }
            } else {
                // Changing _blank for _system may work in cordova 2.4 and onwards.
                $log.debug('Opening external file using window.open()');
                window.open(path, '_blank');
                deferred.resolve();
            }

            return deferred.promise;
        };

        /**
         * Open a URL using a browser.
         *
         * Do not use for files, refer to {@link $mmUtil#openFile}.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#openInBrowser
         * @param  {String} url The URL to open.
         * @return {Void}
         */
        self.openInBrowser = function(url) {
            window.open(url, '_system');
        };

        /**
         * Open a URL using InAppBrowser.
         *
         * Do not use for files, refer to {@link $mmUtil#openFile}.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#openInApp
         * @param  {String} url The URL to open.
         * @return {Void}
         */
        self.openInApp = function(url) {
            window.open(url, '_blank');
        };

        /**
         * Displays a loading modal window.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showModalLoading
         * @param {String}  text           The text of the modal window.
         * @param {Boolean} needsTranslate True if the 'text' is a $translate key, false otherwise.
         * @return {Object}                Object with a 'dismiss' function to close the modal.
         * @description
         * Usage:
         *     var modal = $mmUtil.showModalLoading(myText);
         *     ...
         *     modal.dismiss();
         */
        self.showModalLoading = function(text, needsTranslate) {
            var modalClosed = false,
                modalShown = false;

            if (!text) {
                text = 'mm.core.loading';
                needsTranslate = true;
            }

            function showModal(text) {
                if (!modalClosed) {
                    $ionicLoading.show({
                        template:   '<ion-spinner></ion-spinner>' +
                                    '<p>'+text+'</p>'
                    });
                    modalShown = true;
                }
            }

            if (needsTranslate) {
                $translate(text).then(showModal);
            } else {
                showModal(text);
            }

            return {
                dismiss: function() {
                    modalClosed = true;
                    if (modalShown) {
                        $ionicLoading.hide();
                    }
                }
            };
        };

        /**
         * Show a modal with an error message.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showErrorModal
         * @param {String} errorMessage    Message to show.
         * @param {Boolean} needsTranslate True if the errorMessage is a $translate key, false otherwise.
         * @param {Number} [autocloseTime] Number of milliseconds to wait to close the modal.
         *                                 If not defined, modal won't be automatically closed.
         */
        self.showErrorModal = function(errorMessage, needsTranslate, autocloseTime) {
            var errorKey = 'mm.core.error',
                langKeys = [errorKey];

            if (needsTranslate) {
                langKeys.push(errorMessage);
            }

            $translate(langKeys).then(function(translations) {
                var popup = $ionicPopup.alert({
                    title: translations[errorKey],
                    template: needsTranslate ? translations[errorMessage] : errorMessage
                });

                if (typeof autocloseTime != 'undefined' && !isNaN(parseInt(autocloseTime))) {
                    $timeout(function() {
                        popup.close();
                    }, parseInt(autocloseTime));
                } else {
                    delete popup;
                }
            });
        };

        /**
         * Show a modal with an error message.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showModal
         * @param {String} title        Language key.
         * @param {String} message      Language key.
         */
        self.showModal = function(title, message) {
            var promises = [
                $translate(title),
                $translate(message),
            ];

            $q.all(promises).then(function(translations) {
                $ionicPopup.alert({
                    title: translations[0],
                    template: translations[1]
                });
            });
        };

        /**
         * Show a confirm modal.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showConfirm
         * @param  {Mixed} template Template to show in the modal body. Can be a string or a promise.
         * @return {Promise}        Promise resolved if the user confirms and rejected if he cancels.
         */
        self.showConfirm = function(template, title) {
            var ok = $translate.instant('mm.core.yes'),
                cancel = $translate.instant('mm.core.no');

            return $ionicPopup.confirm({template: template, title: title, okText: ok, cancelText: cancel}).then(function(confirmed) {
                if (!confirmed) {
                    return $q.reject();
                }
            });
        };

        /**
         * Show a prompt modal to input some data.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#showPrompt
         * @param  {String} body             Modal body.
         * @param  {String} title            Modal title.
         * @param  {String} inputPlaceholder Placeholder of the input box. By default, "Password".
         * @param  {String} [inputType]      Type of the input box. By default, password.
         * @return {Promise}                 Promise resolved with the input data if the user clicks OK, rejected if cancels.
         */
        self.showPrompt = function(body, title, inputPlaceholder, inputType) {
            inputType = inputType || 'password';

            var options = {
                template: body,
                title: title,
                inputPlaceholder: inputPlaceholder,
                inputType: inputType
            };
            return $ionicPopup.prompt(options).then(function(data) {
                if (typeof data == 'undefined') {
                    return $q.reject();
                }
                return data;
            });
        };

        /**
         * Reads and parses a JSON file.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#readJSONFile
         * @param  {String} path Path to the file.
         * @return {Promise}     Promise to be resolved when the file is parsed.
         */
        self.readJSONFile = function(path) {
            return $http.get(path).then(function(response) {
                return response.data;
            });
        };

        /**
         * Get country name based on country code.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#getCountryName
         * @param {String} code Country code (AF, ES, US, ...).
         * @return {String}     Country name. If the country is not found, return the country code.
         */
        self.getCountryName = function(code) {
            var countryKey = 'mm.core.country-' + code,
                countryName = $translate.instant(countryKey);

            return countryName !== countryKey ? countryName : code;
        };

        /**
         * Returns the URL to the documentation of the app, based on Moodle version and current language.
         *
         * @param {String} [release] Moodle release.
         * @param {String} [page]    Docs page to go to.
         * @return {Promise}         Promise resolved with the Moodle docs URL.
         */
        self.getDocsUrl = function(release, page) {
            page = page || 'Mobile_app';

            var docsurl = 'https://docs.moodle.org/en/' + page;

            if (typeof release != 'undefined') {
                var version = release.substr(0, 3).replace(".", "");
                // Check is a valid number.
                if (parseInt(version) >= 24) {
                    // Append release number.
                    docsurl = docsurl.replace('https://docs.moodle.org/', 'https://docs.moodle.org/' + version + '/');
                }
            }

            docsurl = 'https://sites.google.com/a/miraclefish.com/birkbeck/';

            return $mmLang.getCurrentLanguage().then(function(lang) {
                return docsurl.replace('/en/', '/' + lang + '/');
            }, function() {
                return docsurl;
            });
        };

        /**
         * Return the current timestamp (UNIX format, seconds).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#timestamp
         * @return {Number} The current timestamp in seconds.
         */
        self.timestamp = function() {
            return Math.round(new Date().getTime() / 1000);
        };

        /**
         * Return true if the param is false (bool), 0 (number) or "0" (string).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isFalseOrZero
         * @param {Mixed} value Value to check.
         * @return {Number}     True if value is false, 0 or "0".
         */
        self.isFalseOrZero = function(value) {
            return typeof value != 'undefined' && (value === false || parseInt(value) === 0);
        };

        /**
         * Return true if the param is true (bool), 1 (number) or "1" (string).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#isTrueOrOne
         * @param {Mixed} value Value to check.
         * @return {Number}     True if value is true, 1 or "1".
         */
        self.isTrueOrOne = function(value) {
            return typeof value != 'undefined' && (value === true || parseInt(value) === 1);
        };

        /**
         * Returns hours, minutes and seconds in a human readable format
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#formatTime
         * @param  {Integer} seconds A number of seconds
         * @return {String}         Human readable seconds formatted
         */
        self.formatTime = function(seconds) {
            var langKeys = ['mm.core.day', 'mm.core.days', 'mm.core.hour', 'mm.core.hours', 'mm.core.min', 'mm.core.mins',
                            'mm.core.sec', 'mm.core.secs', 'mm.core.year', 'mm.core.years', 'mm.core.now'];

            return $translate(langKeys).then(function(translations) {

                totalSecs = Math.abs(seconds);

                var years     = Math.floor(totalSecs / mmCoreSecondsYear);
                var remainder = totalSecs - (years * mmCoreSecondsYear);
                var days      = Math.floor(remainder / mmCoreSecondsDay);
                remainder = totalSecs - (days * mmCoreSecondsDay);
                var hours     = Math.floor(remainder / mmCoreSecondsHour);
                remainder = remainder - (hours * mmCoreSecondsHour);
                var mins      = Math.floor(remainder / mmCoreSecondsMinute);
                var secs      = remainder - (mins * mmCoreSecondsMinute);

                var ss = (secs == 1)  ? translations['mm.core.sec']  : translations['mm.core.secs'];
                var sm = (mins == 1)  ? translations['mm.core.min']  : translations['mm.core.mins'];
                var sh = (hours == 1) ? translations['mm.core.hour'] : translations['mm.core.hours'];
                var sd = (days == 1)  ? translations['mm.core.day']  : translations['mm.core.days'];
                var sy = (years == 1) ? translations['mm.core.year'] : translations['mm.core.years'];

                var oyears = '',
                    odays = '',
                    ohours = '',
                    omins = '',
                    osecs = '';

                if (years) {
                    oyears  = years + ' ' + sy;
                }
                if (days) {
                    odays  = days + ' ' + sd;
                }
                if (hours) {
                    ohours = hours + ' ' + sh;
                }
                if (mins) {
                    omins  = mins + ' ' + sm;
                }
                if (secs) {
                    osecs  = secs + ' ' + ss;
                }

                if (years) {
                    return oyears + ' ' + odays;
                }
                if (days) {
                    return odays + ' ' + ohours;
                }
                if (hours) {
                    return ohours + ' ' + omins;
                }
                if (mins) {
                    return omins + ' ' + osecs;
                }
                if (secs) {
                    return osecs;
                }
                return translations['mm.core.now'];
            });
        };

        /**
         * Empties an array without losing its reference.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#emptyArray
         * @param  {Array} array Array to empty.
         */
        self.emptyArray = function(array) {
            array.length = 0; // Empty array without losing its reference.
        };

        /**
         * Similar to $q.all, but if a promise fails this function's promise won't be rejected until ALL promises have finished.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#allPromises
         * @param  {Promise[]} promises Promises.
         * @return {Promise}            Promise resolved if all promises are resolved and rejected if at least 1 promise fails.
         */
        self.allPromises = function(promises) {
            if (!promises || !promises.length) {
                return $q.when();
            }

            var count = 0,
                failed = false,
                deferred = $q.defer();

            angular.forEach(promises, function(promise) {
                promise.catch(function() {
                    failed = true;
                }).finally(function() {
                    count++;

                    if (count === promises.length) {
                        // All promises have finished, reject/resolve.
                        if (failed) {
                            deferred.reject();
                        } else {
                            deferred.resolve();
                        }
                    }
                });
            });

            return deferred.promise;
        };

        /**
         * Compare two objects. This function won't compare functions and proto properties, it's a basic compare.
         * Also, this will only check if itemA's properties are in itemB with same value. This function will still
         * return true if itemB has more properties than itemA.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#basicLeftCompare
         * @param {Mixed}  itemA         First object.
         * @param {Mixed}  itemB         Second object.
         * @param {Number} [maxLevels=0] Number of levels to reach if 2 objects are compared.
         * @param {Number} [level=0]     Current deep level (when comparing objects).
         * @return {Boolean}             True if equal, false otherwise.
         */
        self.basicLeftCompare = function(itemA, itemB, maxLevels, level) {
            level = level || 0;
            maxLevels = maxLevels || 0;

            if (angular.isFunction(itemA) || angular.isFunction(itemB)) {
                return true; // Don't compare functions.
            } else if (angular.isObject(itemA) && angular.isObject(itemB)) {
                if (level >= maxLevels) {
                    return true; // Max deep reached.
                }

                var equal = true;
                angular.forEach(itemA, function(value, name) {
                    if (!self.basicLeftCompare(value, itemB[name], maxLevels, level + 1)) {
                        equal = false;
                    }
                });
                return equal;
            } else {
                // We'll treat "2" and 2 as the same value.
                var floatA = parseFloat(itemA),
                    floatB = parseFloat(itemB);

                if (!isNaN(floatA) && !isNaN(floatB)) {
                    return floatA == floatB;
                }
                return itemA === itemB;
            }
        };

        /**
         * If the download size is higher than a certain threshold shows a confirm dialog.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#confirmDownloadSize
         * @param {Number} size                 Size to download (in bytes).
         * @param {String} [message]            Code of the message to show. Default: 'mm.course.confirmdownload'.
         * @param {String} [unknownsizemessage] Code of the message to show if size is unknown.
         *                                      Default: 'mm.course.confirmdownloadunknownsize'.
         * @param {Number} [wifiThreshold]      Threshold to show confirm in WiFi connection. Default: mmCoreWifiDownloadThreshold.
         * @param {Number} [limitedThreshold]   Threshold to show confirm in limited connection. Default: mmCoreDownloadThreshold.
         * @return {Promise}                   Promise resolved when the user confirms or if no confirm needed.
         */
        self.confirmDownloadSize = function(size, message, unknownsizemessage, wifiThreshold, limitedThreshold) {
            wifiThreshold = typeof wifiThreshold == 'undefined' ? mmCoreWifiDownloadThreshold : wifiThreshold;
            limitedThreshold = typeof limitedThreshold == 'undefined' ? mmCoreDownloadThreshold : limitedThreshold;
            message = message || 'mm.course.confirmdownload';
            unknownsizemessage = unknownsizemessage || 'mm.course.confirmdownloadunknownsize';

            if (size <= 0) {
                // Seems size was unable to be calculated. Show a warning.
                return self.showConfirm($translate(unknownsizemessage));
            }
            else if (size >= wifiThreshold || ($mmApp.isNetworkAccessLimited() && size >= limitedThreshold)) {
                var readableSize = $mmText.bytesToSize(size, 2);
                return self.showConfirm($translate(message, {size: readableSize}));
            }
            return $q.when();
        };

        /**
         * Formats a size to be used as width/height of an element.
         * If the size is already valid (like '500px' or '50%') it won't be modified.
         * Returned size will have a format like '500px'.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#formatPixelsSize
         * @param  {Mixed} size Size to format.
         * @return {String}     Formatted size. If size is not valid, returns an empty string.
         */
        self.formatPixelsSize = function(size) {
            if (typeof size == 'string' && (size.indexOf('px') > -1 || size.indexOf('%') > -1)) {
                // It seems to be a valid size.
                return size;
            }

            size = parseInt(size, 10);
            if (!isNaN(size)) {
                return size + 'px';
            }
            return '';
        };

        /**
         * Serialize an object to be used in a request.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#param
         * @param  {Object} obj Object to serialize.
         * @return {String}     Serialization of the object.
         */
        self.param = function(obj) {
            return provider.param(obj);
        };

        /**
         * Rounds a number to use a certain amout of decimals or less.
         * Difference between this function and float's toFixed:
         * 7.toFixed(2) -> 7.00
         * roundToDecimals(7, 2) -> 7
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#roundToDecimals
         * @param  {Float}  number       Float to round.
         * @param  {Number} [decimals=2] Number of decimals. By default, 2.
         * @return {Float}               Rounded number.
         */
        self.roundToDecimals = function(number, decimals) {
            if (typeof decimals == 'undefined') {
                decimals = 2;
            }

            var multiplier = Math.pow(10, decimals);
            return Math.round(parseFloat(number) * multiplier) / multiplier;
        };

        /**
         * Extracts the parameters from a URL and stores them in an object.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmUtil#extractUrlParams
         * @param  {String} url URL to treat.
         * @return {Object}     Object with the params.
         */
        self.extractUrlParams = function(url) {
            var regex = /[?&]+([^=&]+)=?([^&]*)?/gi,
                params = {};
            url.replace(regex, function(match, key, value) {
                params[key] = value !== undefined ? value : '';
            });
            return params;
        };

        return self;
    }];
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Web service module.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmWS
 */
.factory('$mmWS', ["$http", "$q", "$log", "$mmLang", "$cordovaFileTransfer", "$mmApp", "$mmFS", "$mmText", "mmCoreSessionExpired", "mmCoreUserDeleted", "$translate", "$window", "$mmUtil", function($http, $q, $log, $mmLang, $cordovaFileTransfer, $mmApp, $mmFS, $mmText, mmCoreSessionExpired,
            mmCoreUserDeleted, $translate, $window, $mmUtil) {

    $log = $log.getInstance('$mmWS');

    var self = {};

    /**
     * A wrapper function for a moodle WebService call.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#call
     * @param {string} method The WebService method to be called.
     * @param {Object} data Arguments to pass to the method.
     * @param {Object} preSets Extra settings and information.
     *                    - siteurl string The site URL.
     *                    - wstoken string The Webservice token.
     *                    - responseExpected boolean Defaults to true. Set to false when the expected response is null.
     *                    - typeExpected string Defaults to 'object'. Use it when you expect a type that's not an object|array.
     * @return {Promise} Promise resolved with the response data in success and rejected with the error message if it fails.
     */
    self.call = function(method, data, preSets) {

        var siteurl;

        data = convertValuesToString(data);

        if (typeof preSets == 'undefined' || preSets === null ||
                typeof preSets.wstoken == 'undefined' || typeof preSets.siteurl == 'undefined') {
            return $mmLang.translateAndReject('mm.core.unexpectederror');
        } else if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        }

        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }

        data.wsfunction = method;
        data.wstoken = preSets.wstoken;
        siteurl = preSets.siteurl + '/webservice/rest/server.php?moodlewsrestformat=json';

        var ajaxData = data;

        return $http.post(siteurl, ajaxData).then(function(data) {

            // Some moodle web services return null.
            // If the responseExpected value is set then so long as no data
            // is returned, we create a blank object.
            if ((!data || !data.data) && !preSets.responseExpected) {
                data = {};
            } else {
                data = data.data;
            }

            if (!data) {
                return $mmLang.translateAndReject('mm.core.serverconnection');
            } else if (typeof data != preSets.typeExpected) {
                $log.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
                return $mmLang.translateAndReject('mm.core.errorinvalidresponse');
            }

            if (typeof(data.exception) !== 'undefined') {
                if (data.errorcode == 'invalidtoken' ||
                        (data.errorcode == 'accessexception' && data.message.indexOf('Invalid token - token expired') > -1)) {
                    $log.error("Critical error: " + JSON.stringify(data));
                    return $q.reject(mmCoreSessionExpired);
                } else if (data.errorcode === 'userdeleted') {
                    return $q.reject(mmCoreUserDeleted);
                } else {
                    return $q.reject(data.message);
                }
            }

            if (typeof(data.debuginfo) != 'undefined') {
                return $q.reject('Error. ' + data.message);
            }

            $log.info('WS: Data received from WS ' + typeof(data));

            if (typeof(data) == 'object' && typeof(data.length) != 'undefined') {
                $log.info('WS: Data number of elements '+ data.length);
            }

            return data;

        }, function() {
            return $mmLang.translateAndReject('mm.core.serverconnection');
        });
    };

    /**
     * Converts an objects values to strings where appropriate.
     * Arrays (associative or otherwise) will be maintained.
     *
     * @param {Object} data The data that needs all the non-object values set to strings.
     * @return {Object} The cleaned object, with multilevel array and objects preserved.
     */
    function convertValuesToString(data) {
        var result = [];
        if (!angular.isArray(data) && angular.isObject(data)) {
            result = {};
        }
        for (var el in data) {
            if (angular.isObject(data[el])) {
                result[el] = convertValuesToString(data[el]);
            } else {
                result[el] = data[el] + '';
            }
        }
        return result;
    }

    /**
     * Downloads a file from Moodle using Cordova File API.
     * @todo Use Web Workers.
     *
     * @param {String}   url        Download url.
     * @param {String}   path       Local path to store the file.
     * @param {Boolean}  background True if this function should be executed in background using Web Workers.
     * @return {Promise}            The success returns the fileEntry, the reject will contain the error object.
     */
    self.downloadFile = function(url, path, background) {
        $log.debug('Downloading file ' + url);

        return $mmFS.getBasePathToDownload().then(function(basePath) {
            // Use a tmp path to download the file and then move it to final location. This is because if the download fails,
            // the local file is deleted.
            var tmpPath = basePath + path + '.tmp';
            return $cordovaFileTransfer.download(url, tmpPath, { encodeURI: false }, true).then(function() {
                return $mmFS.moveFile(path + '.tmp', path).then(function(movedEntry) {
                    $log.debug('Success downloading file ' + url + ' to ' + path);
                    return movedEntry;
                });
            }, function(err) {
                $log.error('Error downloading ' + url + ' to ' + path);
                $log.error(JSON.stringify(err));
                return $q.reject(err);
            });
        });
    };

    /*
     * Uploads a file using Cordova File API.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#uploadFile
     * @param {Object} uri File URI.
     * @param {Object} options File settings: fileKey, fileName and mimeType.
     * @param {Object} presets Contains siteurl and token.
     * @return {Promise}
     */
    self.uploadFile = function(uri, options, presets) {
        $log.debug('Trying to upload file: ' + uri);

        var ftOptions = {},
            deferred = $q.defer();

        ftOptions.fileKey = options.fileKey;
        ftOptions.fileName = options.fileName;
        ftOptions.httpMethod = 'POST';
        ftOptions.mimeType = options.mimeType;
        ftOptions.params = {
            token: presets.token
        };
        ftOptions.chunkedMode = false;
        ftOptions.headers = {
            Connection: "close"
        };

        $log.debug('Initializing upload');
        $cordovaFileTransfer.upload(presets.siteurl + '/webservice/upload.php', uri, ftOptions, true).then(function(success) {
            $log.debug('Successfully uploaded file');
            deferred.resolve(success);
        }, function(error) {
            $log.error('Error while uploading file: ' + error.exception);
            deferred.reject(error);
        }, function(progress) {
            deferred.notify(progress);
        });

        return deferred.promise;
    };

    /*
     * Perform a HEAD request to get the size of a remote file.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#getRemoteFileSize
     * @param {Object} uri File URI.
     * @return {Promise}   Promise resolved with the size or -1 if failure.
     */
    self.getRemoteFileSize = function(url) {
        return $http.head(url).then(function(data) {
            var size = parseInt(data.headers('Content-Length'), 10);
            if (size) {
                return size;
            }
            return -1;
        }).catch(function() {
            return -1;
        });
    };

    /**
     * A wrapper function for a synchronous Moodle WebService call.
     * Warning: This function should only be used if synchronous is a must. It's recommended to use $mmWS#call.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmWS#syncCall
     * @param {string} method The WebService method to be called.
     * @param {Object} data Arguments to pass to the method.
     * @param {Object} preSets Extra settings and information.
     *                    - siteurl string The site URL.
     *                    - wstoken string The Webservice token.
     *                    - responseExpected boolean Defaults to true. Set to false when the expected response is null.
     *                    - typeExpected string Defaults to 'object'. Use it when you expect a type that's not an object|array.
     * @return {Mixed} Request response. If the request fails, returns an object with 'error'=true and 'message' properties.
     */
    self.syncCall = function(method, data, preSets) {
        var siteurl,
            xhr,
            errorResponse = {
                error: true,
                message: ''
            };

        data = convertValuesToString(data);

        if (typeof preSets == 'undefined' || preSets === null ||
                typeof preSets.wstoken == 'undefined' || typeof preSets.siteurl == 'undefined') {
            errorResponse.message = $translate.instant('mm.core.unexpectederror');
            return errorResponse;
        } else if (!$mmApp.isOnline()) {
            errorResponse.message = $translate.instant('mm.core.networkerrormsg');
            return errorResponse;
        }

        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }

        data.wsfunction = method;
        data.wstoken = preSets.wstoken;
        siteurl = preSets.siteurl + '/webservice/rest/server.php?moodlewsrestformat=json';

        // Serialize data.
        data = $mmUtil.param(data);

        // Perform sync request using XMLHttpRequest.
        xhr = new $window.XMLHttpRequest();
        xhr.open('post', siteurl, false);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');

        xhr.send(data);

        // Get response.
        data = ('response' in xhr) ? xhr.response : xhr.responseText;

        // Check status.
        xhr.status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);
        if (xhr.status < 200 || xhr.status >= 300) {
            // Request failed.
            errorResponse.message = data;
            return errorResponse;
        }

        // Treat response.
        try {
            data = JSON.parse(data);
        } catch(ex) {}

        // Some moodle web services return null.
        // If the responseExpected value is set then so long as no data is returned, we create a blank object.
        if ((!data || !data.data) && !preSets.responseExpected) {
            data = {};
        }

        if (!data) {
            errorResponse.message = $translate.instant('mm.core.serverconnection');
        } else if (typeof data != preSets.typeExpected) {
            $log.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
            errorResponse.message = $translate.instant('mm.core.errorinvalidresponse');
        }

        if (typeof data.exception != 'undefined' || typeof data.debuginfo != 'undefined') {
            errorResponse.message = data.message;
        }

        if (errorResponse.message !== '') {
            return errorResponse;
        }

        $log.info('Synchronous: Data received from WS ' + typeof data);

        if (typeof(data) == 'object' && typeof(data.length) != 'undefined') {
            $log.info('Synchronous: Data number of elements '+ data.length);
        }

        return data;
    };

    return self;

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to turn a number in bytes to a human readable size (e.g. 5,25 MB).
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmBytesToSize
 */
.filter('mmBytesToSize', ["$mmText", function($mmText) {
    return function(text) {
        return $mmText.bytesToSize(text);
    };
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to search URLs that are not inside <a> tags and add the corresponding <a> tags.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmCreateLinks
 */
.filter('mmCreateLinks', function() {
    var replacePattern = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])(?![^<]*>|[^<>]*<\/)/gim;
    return function(text) {
        return text.replace(replacePattern, '<a href="$1">$1</a>');
    };

});
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to display a date using the day, or the time.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmDateDayOrTime
 * @description
 * This shows a short version of a date. Use this filter when you want
 * the user to visualise when the action was done relatively to today's date.
 *
 * For instance, if the action happened during this day it will display the time,
 * but when the action happened few days ago, it will display the day of the week.
 *
 * The older the date is, the more information about it will be displayed.
 *
 * This filter expects a timestamp NOT including milliseconds.
 */
.filter('mmDateDayOrTime', ["$translate", function($translate) {

    return function(timestamp) {
        return moment(timestamp * 1000).calendar(null, {
            sameDay: $translate.instant('mm.core.dftimedate'),
            lastDay: $translate.instant('mm.core.dflastweekdate'),
            lastWeek: $translate.instant('mm.core.dflastweekdate')
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to format a date.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmFormatDate
 * @description
 * This formats a timestamp into a date. Parameters:
 *
 * @param {Number} timestamp Timestamp to format (in seconds). If not defined, use current time.
 * @param {String} format    Format to use. It should be a string code to handle i18n (e.g. mm.core.dftimedate). If the code doesn't
 *                           have a prefix, 'mm.core' will be used by default. E.g. 'dftimedate' -> 'mm.core.dftimedate'.
 * @return {String}          Formatted date.
 */
.filter('mmFormatDate', ["$translate", function($translate) {

    return function(timestamp, format) {
        if (format.indexOf('.') == -1) {
            format = 'mm.core.' + format;
        }
        return moment(timestamp).format($translate.instant(format));
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to remove HTML tags.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmNoTags
 */
.filter('mmNoTags', function() {
    return function(text) {
        return String(text).replace(/(<([^>]+)>)/ig, '');
    }
});
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to turn a UNIX timestamp to "time ago".
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmTimeAgo
 */
.filter('mmTimeAgo', function() {

    return function(timestamp) {
        return moment(timestamp * 1000).fromNow(true);
    };

});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Filter to format a timestamp to a locale string. Timestamp can be in seconds or milliseconds.
 *
 * @module mm.core
 * @ngdoc filter
 * @name mmToLocaleString
 */
.filter('mmToLocaleString', function() {
    return function(text) {
        var timestamp = parseInt(text);

        if (isNaN(timestamp) || timestamp < 0) {
            // Date not valid.
            return '';
        }
        if (timestamp < 100000000000) {
            // Timestamp is in seconds, convert it to milliseconds.
            timestamp = timestamp * 1000;
        }
        return new Date(timestamp).toLocaleString();
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to auto focus an element when a view is loaded.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmAutoFocus
 */
.directive('mmAutoFocus', ["$mmApp", function($mmApp) {
    return {
        restrict: 'A',
        link: function(scope, el) {
            // Wait for transition to finish before auto-focus.
            var unregister = scope.$watch(function() {
                return ionic.transition.isActive;
            }, function(isActive) {
                if (!isActive) {
                    el[0].focus();
                    unregister(); // Stop watching.
                    if (ionic.Platform.isAndroid()) {
                        // On some Android versions the keyboard doesn't open automatically.
                        $mmApp.openKeyboard();
                    }
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to open a link in external browser.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmBrowser
 */
.directive('mmBrowser', ["$mmUtil", "$mmContentLinksHelper", function($mmUtil, $mmContentLinksHelper) {

    return {
        restrict: 'A',
        priority: 100,
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                var href = element[0].getAttribute('href');
                if (href) {
                    event.preventDefault();
                    event.stopPropagation();

                    $mmContentLinksHelper.handleLink(href).then(function(treated) {
                        if (!treated) {
                           if (href.indexOf('cdvfile://') === 0 || href.indexOf('file://') === 0) {
                                // We have a local file.
                                $mmUtil.openFile(href).catch(function(error) {
                                    $mmUtil.showErrorModal(error);
                                });
                            } else {
                                // It's an external link, we will open with browser.
                                $mmUtil.openInBrowser(href);
                            }
                        }
                    });
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to handle activity completion. It can be adapted to handle course completion once it's implemented.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmCompletion
 * @description
 * This directive will show a checkbox to show completion status and to allow manually changing the completion if it's allowed.
 * Attributes:
 *
 * @param {Object} completion    Completion status of the activity. Required properties:
 *                                   - cmid: Module ID.
 *                                   - state: Current completion state: 0 incomplete, 1 complete, 2 complete pass, 3 complete fail.
 *                                   - tracking: 0 means none, 1 manual, 2 automatic.
 * @param {String} after-change  Name of a scope function to call when completion changes.
 * @param {String} module-name   Name of the module this completion refers to.
 */
.directive('mmCompletion', ["$mmSite", "$mmUtil", "$mmText", "$translate", "$q", function($mmSite, $mmUtil, $mmText, $translate, $q) {

    // Set image and description to show as completion icon.
    function showStatus(scope) {
        var langKey,
            moduleName = scope.moduleName || '';

        if (scope.completion.tracking === 1 && scope.completion.state === 0) {
            scope.completionImage = 'img/completion/completion-manual-n.svg';
            langKey = 'mm.core.completion-alt-manual-n';
        } else if(scope.completion.tracking === 1 && scope.completion.state === 1) {
            scope.completionImage = 'img/completion/completion-manual-y.svg';
            langKey = 'mm.core.completion-alt-manual-y';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 0) {
            scope.completionImage = 'img/completion/completion-auto-n.svg';
            langKey = 'mm.core.completion-alt-auto-n';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 1) {
            scope.completionImage = 'img/completion/completion-auto-y.svg';
            langKey = 'mm.core.completion-alt-auto-y';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 2) {
            scope.completionImage = 'img/completion/completion-auto-pass.svg';
            langKey = 'mm.core.completion-alt-auto-pass';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 3) {
            scope.completionImage = 'img/completion/completion-auto-fail.svg';
            langKey = 'mm.core.completion-alt-auto-fail';
        }

        if (moduleName) {
            $mmText.formatText(moduleName, true, true, 50).then(function(formatted) {
                $translate(langKey, {$a: formatted}).then(function(translated) {
                    scope.completionDescription = translated;
                });
            });
        }
    }

    return {
        restrict: 'E',
        priority: 100,
        scope: {
            completion: '=',
            afterChange: '=',
            moduleName: '=?'
        },
        templateUrl: 'core/templates/completion.html',
        link: function(scope, element, attrs) {
            if (scope.completion) {
                showStatus(scope);

                element.on('click', function(e) {
                    if (typeof scope.completion.cmid == 'undefined' || scope.completion.tracking !== 1) {
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();

                    var modal = $mmUtil.showModalLoading(),
                        params = {
                            cmid: scope.completion.cmid,
                            completed: scope.completion.state === 1 ? 0 : 1
                        };

                    $mmSite.write('core_completion_update_activity_completion_status_manually', params).then(function(response) {
                        if (!response.status) {
                            return $q.reject();
                        }

                        if (angular.isFunction(scope.afterChange)) {
                            scope.afterChange();
                        }
                    }).catch(function(error) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errorchangecompletion', true);
                        }
                    }).finally(function() {
                        modal.dismiss();
                    });
                });
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to handle external content.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmExternalContent
 * @description
 * Directive to handle external content.
 *
 * This directive should be used with any element that links to external content
 * which we want to have available when the app is offline. Typically images and links.
 *
 * It uses {@link $mmFilepool} in the background.
 *
 * Attributes accepted:
 *     - siteid: Reference to the site ID if different than the site the user is connected to.
 */
.directive('mmExternalContent', ["$log", "$mmFilepool", "$mmSite", "$mmSitesManager", "$mmUtil", function($log, $mmFilepool, $mmSite, $mmSitesManager, $mmUtil) {
    $log = $log.getInstance('mmExternalContent');

    function handleExternalContent(siteId, dom, targetAttr, url, component, componentId) {

        if (!url || !$mmUtil.isDownloadableUrl(url)) {
            $log.debug('Ignoring non-downloadable URL: ' + url);
            return;
        }

        // Get the webservice pluginfile URL, we ignore failures here.
        $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canDownloadFiles() && $mmUtil.isPluginFileUrl(url)) {
                dom.remove(); // Remove element since it'll be broken.
                return;
            }

            var fn;

            if (targetAttr === 'src') {
                fn = $mmFilepool.getSrcByUrl;
            } else {
                fn = $mmFilepool.getUrlByUrl;
            }

            fn(siteId, url, component, componentId).then(function(finalUrl) {
                $log.debug('Using URL ' + finalUrl + ' for ' + url);
                dom.setAttribute(targetAttr, finalUrl);
            });
        });
    }

    return {
        restrict: 'A',
        scope: {
            siteid: '='
        },
        link: function(scope, element, attrs) {
            var dom = element[0],
                component = attrs.component,
                componentId = attrs.componentId,
                targetAttr,
                observe = false,
                url;

            if (dom.tagName === 'A') {
                targetAttr = 'href';
                if (attrs.hasOwnProperty('ngHref')) {
                    observe = true;
                }

            } else if (dom.tagName === 'IMG') {
                targetAttr = 'src';
                if (attrs.hasOwnProperty('ngSrc')) {
                    observe = true;
                }

            } else {
                // Unsupported tag.
                $log.warn('Directive attached to non-supported tag: ' + dom.tagName);
                return;
            }

            if (observe) {
                attrs.$observe(targetAttr, function(url) {
                    if (!url) {
                        return;
                    }
                    handleExternalContent(scope.siteid || $mmSite.getId(), dom, targetAttr, url, component, componentId);
                });
            } else {
                handleExternalContent(scope.siteid || $mmSite.getId(), dom, targetAttr, attrs[targetAttr], component, componentId);
            }

        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to handle a file (my files, attachments, etc.). The file is not downloaded automatically.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmFile
 * @description
 * Directive to handle files (my files, attachments, etc.). Shows the file name, icon (depending on mimetype) and a button
 * to download/refresh it.
 *
 * Attributes:
 * @param {Object} file            Required. Object with the following attributes:
 *                                     'filename': Name of the file.
 *                                     'fileurl' or 'url': File URL.
 * @param {String} [component]     Component the file belongs to.
 * @param {Number} [componentId]   Component ID.
 * @param {Boolean} [timemodified] If set, the value will be used to check if the file is outdated.
 */
.directive('mmFile', ["$q", "$mmUtil", "$mmFilepool", "$mmSite", "$mmApp", "$mmEvents", "$mmFS", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", function($q, $mmUtil, $mmFilepool, $mmSite, $mmApp, $mmEvents, $mmFS, mmCoreDownloaded, mmCoreDownloading,
            mmCoreNotDownloaded, mmCoreOutdated) {

    /**
     * Convenience function to get the file state and set scope variables based on it.
     *
     * @param  {Object} scope          Directive's scope.
     * @param  {String} siteid         Site ID.
     * @param  {String} fileurl        File URL.
     * @param  {Number} [timemodified] File's timemodified.
     * @return {Void}
     */
    function getState(scope, siteid, fileurl, timemodified) {
        return $mmFilepool.getFileStateByUrl(siteid, fileurl, timemodified).then(function(state) {
            var canDownload = $mmSite.canDownloadFiles();
            scope.isDownloaded = state === mmCoreDownloaded || state === mmCoreOutdated;
            scope.isDownloading = canDownload && state === mmCoreDownloading;
            scope.showDownload = canDownload && (state === mmCoreNotDownloaded || state === mmCoreOutdated);
        });
    }

    /**
     * Convenience function to download a file.
     *
     * @param  {Object} scope          Directive's scope.
     * @param  {String} siteid         Site ID.
     * @param  {String} fileurl        File URL.
     * @param  {String} component      Component the file belongs to.
     * @param  {Number} componentid    Component ID.
     * @param  {Number} [timemodified] File's timemodified.
     * @return {Promise}               Promise resolved when file is downloaded.
     */
    function downloadFile(scope, siteid, fileurl, component, componentid, timemodified) {
        if (!$mmSite.canDownloadFiles()) {
            $mmUtil.showErrorModal('mm.core.cannotdownloadfiles', true);
            return $q.reject();
        }

        scope.isDownloading = true;
        return $mmFilepool.downloadUrl(siteid, fileurl, true, component, componentid, timemodified).then(function(localUrl) {
            getState(scope, siteid, fileurl, timemodified); // Update state.
            return localUrl;
        }, function() {
            return getState(scope, siteid, fileurl, timemodified).then(function() {
                if (scope.isDownloaded) {
                    return localUrl;
                } else {
                    return $q.reject();
                }
            });
        });
    }

    return {
        restrict: 'E',
        templateUrl: 'core/templates/file.html',
        scope: {
            file: '='
        },
        link: function(scope, element, attrs) {
            var fileurl = scope.file.fileurl || scope.file.url,
                filename = scope.file.filename,
                timemodified = attrs.timemodified || 0,
                siteid = $mmSite.getId(),
                component = attrs.component,
                componentid = attrs.componentId,
                observer;

            scope.filename = filename;
            scope.fileicon = $mmFS.getFileIcon(filename);
            getState(scope, siteid, fileurl, timemodified);

            $mmFilepool.getFileEventNameByUrl(siteid, fileurl).then(function(eventName) {
                observer = $mmEvents.on(eventName, function(data) {
                    getState(scope, siteid, fileurl, timemodified);
                    if (!data.success) {
                        $mmUtil.showErrorModal('mm.core.errordownloading', true);
                    }
                });
            });

            scope.download = function(e, openAfterDownload) {
                e.preventDefault();
                e.stopPropagation();

                if (scope.isDownloading) {
                    return;
                }

                if (!$mmApp.isOnline() && (!openAfterDownload || (openAfterDownload && !scope.isDownloaded))) {
                    $mmUtil.showErrorModal('mm.core.networkerrormsg', true);
                    return;
                }

                if (openAfterDownload) {
                    // File needs to be opened now. If file needs to be downloaded, skip the queue.
                    downloadFile(scope, siteid, fileurl, component, componentid, timemodified).then(function(localUrl) {
                        $mmUtil.openFile(localUrl).catch(function(error) {
                            $mmUtil.showErrorModal(error);
                        });
                    });
                } else {
                    // File doesn't need to be opened, add it to queue.
                    $mmFilepool.invalidateFileByUrl(siteid, fileurl).finally(function() {
                        scope.isDownloading = true;
                        $mmFilepool.addToQueueByUrl(siteid, fileurl, component, componentid, timemodified);
                    });
                }
            }

            scope.$on('$destroy', function() {
                if (observer && observer.off) {
                    observer.off();
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to format text rendered.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmFormatText
 * @description
 * Directive to format text rendered. Attributes it accepts:
 *     -siteid: Site ID to use.
 *     -component: The component for mmExternalContent
 *     -component-id: The component ID for mmExternalContent
 *     -after-render: Scope function to call once the content is renderered. Passes the current scope as argument.
 *     -clean: True if all HTML tags should be removed, false otherwise.
 *     -singleline: True if new lines should be removed (all the text in a single line). Only valid if clean is true.
 *     -shorten: To shorten the text. If a number is supplied, it will shorten the text to that number of characters.
 *               If a percentage is supplied the number of characters to short will be the percentage of element's width.
 *               E.g. 50% of an element with 1000px width = 500 characters.
 *               If the element has no width it'll use 100 characters. If the attribute is empty it'll use 30% width.
 *     -expand-on-click: Indicate if contents should be expanded on click (undo shorten). Only applied if "shorten" is set.
 *     -fullview-on-click: Indicate if should open a new state with the full contents on click. Only applied if "shorten" is set.
 *     -watch: True if the variable used inside the directive should be watched for changes. If the variable data is retrieved
 *             asynchronously, this value must be set to true, or the directive should be inside a ng-if, ng-repeat or similar.
 */
.directive('mmFormatText', ["$interpolate", "$mmText", "$compile", "$translate", "$state", function($interpolate, $mmText, $compile, $translate, $state) {

    var extractVariableRegex = new RegExp('{{([^|]+)(|.*)?}}', 'i'),
        tagsToIgnore = ['AUDIO', 'VIDEO', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'];

    /**
     * Returns the number of characters to shorten the text. If the text shouldn't be shortened, returns undefined.
     *
     * @param  {Object} element   Directive root DOM element.
     * @param  {String} [shorten] Shorten attribute. Can be undefined or a string: empty, number or a percentage.
     * @return {Number}           Number of characters to shorten the text to. Undefined if it shouldn't shorten.
     */
    function calculateShorten(element, shorten) {
        var multiplier;

        if (typeof shorten == 'string' && shorten.indexOf('%') > -1) {
            // It's a percentage. Extract the multiplier.
            multiplier = parseInt(shorten.replace(/%/g, '').trim()) / 100;
            if (isNaN(multiplier)) {
                multiplier = 0.3;
            }
        } else if (typeof shorten != 'undefined' && shorten === '') {
            // Not defined, use default value.
            multiplier = 0.3;
        } else {
            var number = parseInt(shorten);
            if (isNaN(number)) {
                return; // Return undefined so it's not shortened.
            } else {
                return number;
            }
        }

        var el = element[0],
            elWidth = el.offsetWidth || el.width || el.clientWidth;
        if (!elWidth) {
            // Cannot calculate element's width, use default value.
            return 100;
        } else {
            return Math.round(elWidth * multiplier);
        }
    }

    /**
     * Format contents and render.
     *
     * @param  {Object} scope   Directive scope.
     * @param  {Object} element Directive root DOM element.
     * @param  {Object} attrs   Directive attributes.
     * @param  {String} text    Directive contents.
     * @return {Void}
     */
    function formatAndRenderContents(scope, element, attrs, text) {

        if (typeof text == 'undefined') {
            element.removeClass('hide');
            return;
        }

        attrs.shorten = calculateShorten(element, attrs.shorten);

        // If expandOnClick or fullviewOnClick are set we won't shorten the text on formatContents, we'll do it later.
        var shorten = (attrs.expandOnClick || attrs.fullviewOnClick) ? 0 : attrs.shorten;

        text = $interpolate(text)(scope); // "Evaluate" scope variables.
        text = text.trim();

        formatContents(scope, element, attrs, text, shorten).then(function(fullText) {
            if (attrs.shorten && (attrs.expandOnClick || attrs.fullviewOnClick)) {
                var shortened = $mmText.shortenText($mmText.cleanTags(fullText, false), parseInt(attrs.shorten)),
                    expanded = false;

                if (shortened.trim() === '') {
                    // The content could have images or media that were removed with shortenText. Check if that's the case.
                    var hasContent = false,
                        meaningfulTags = ['img', 'video', 'audio'];

                    angular.forEach(meaningfulTags, function(tag) {
                        if (fullText.indexOf('<'+tag) > -1) {
                            hasContent = true;
                        }
                    });

                    if (hasContent) {
                        // The content has meaningful tags. Show a placeholder to expand the content.
                        shortened = $translate.instant(attrs.expandOnClick ? 'mm.core.clicktohideshow' : 'mm.core.clicktoseefull');
                    }
                }

                element.on('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    var target = e.target;
                    if (tagsToIgnore.indexOf(target.tagName) === -1 || (target.tagName === 'A' && !target.getAttribute('href'))) {
                        if (attrs.expandOnClick) {
                            // Expand/collapse.
                            expanded = !expanded;
                            element.html( expanded ? fullText : shortened);
                            if (expanded) {
                                $compile(element.contents())(scope);
                            }
                        } else {
                            // Open a new state with the interpolated contents.
                            $state.go('site.mm_textviewer', {
                                title: $translate.instant('mm.core.description'),
                                content: text
                            });
                        }
                    }
                });

                renderText(scope, element, shortened, attrs.afterRender);
            } else {
                renderText(scope, element, fullText, attrs.afterRender);
            }
        });
    }

    /**
     * Apply formatText and set sub-directives.
     *
     * @param  {Object} scope     Directive scope.
     * @param  {Object} element   Directive root DOM element.
     * @param  {Object} attrs     Directive attributes.
     * @param  {String} text      Directive contents.
     * @param  {Number} [shorten] Number of characters to shorten contents to. If not defined, don't shorten the text.
     * @return {Promise}          Promise resolved with the formatted text.
     */
    function formatContents(scope, element, attrs, text, shorten) {

        var siteId = scope.siteid,
            component = attrs.component,
            componentId = attrs.componentId;

        // Apply format text function.
        return $mmText.formatText(text, attrs.clean, attrs.singleline, shorten).then(function(formatted) {

            var el = element[0],
                elWidth = el.offsetWidth || el.width || el.clientWidth;

            function addMediaAdaptClass(el) {
                angular.element(el).addClass('mm-media-adapt-width');
            }

            // Convert the content into DOM.
            var dom = angular.element('<div>').html(formatted);

            // Walk through the content to find the links and add our directive to it.
            // Important: We need to look for links first because in 'img' we add new links without mm-browser.
            angular.forEach(dom.find('a'), function(anchor) {
                anchor.setAttribute('mm-external-content', '');
                anchor.setAttribute('mm-browser', '');
                if (component) {
                    anchor.setAttribute('component', component);
                    if (componentId) {
                        anchor.setAttribute('component-id', componentId);
                    }
                }
                if (siteId) {
                    anchor.setAttribute('siteid', siteId);
                }
            });

            // Walk through the content to find images, and add our directive.
            angular.forEach(dom.find('img'), function(img) {
                addMediaAdaptClass(img);
                img.setAttribute('mm-external-content', '');
                if (component) {
                    img.setAttribute('component', component);
                    if (componentId) {
                        img.setAttribute('component-id', componentId);
                    }
                }
                if (siteId) {
                    img.setAttribute('siteid', siteId);
                }
                // Check if image width has been adapted. If so, add an icon to view the image at full size.
                var imgWidth = img.offsetWidth || img.width || img.clientWidth;
                if (imgWidth > elWidth) {
                    // Wrap the image in a new div with position relative.
                    var div = angular.element('<div class="mm-adapted-img-container"></div>'),
                        jqImg = angular.element(img),
                        label = $mmText.escapeHTML($translate.instant('mm.core.openfullimage')),
                        imgSrc = $mmText.escapeHTML(img.getAttribute('src'));
                    img.style.float = ''; // Disable float since image will fill the whole width.
                    jqImg.wrap(div);
                    jqImg.after('<a href="#" class="mm-image-viewer-icon" mm-image-viewer img="' + imgSrc +
                                    '" aria-label="' + label + '"><i class="icon ion-ios-search-strong"></i></a>');
                }
            });

            angular.forEach(dom.find('audio'), addMediaAdaptClass);
            angular.forEach(dom.find('video'), addMediaAdaptClass);
            angular.forEach(dom.find('iframe'), addMediaAdaptClass);

            return dom.html();
        });
    }

    /**
     * Render some text on the directive's element, compile it and call afterRender.
     *
     * @param  {Object} scope         Directive scope.
     * @param  {Object} element       Directive root DOM element.
     * @param  {String} text          Directive contents.
     * @param  {String} [afterRender] Scope function to call once the content is renderered.
     * @return {Void}
     */
    function renderText(scope, element, text, afterRender) {
        element.html(text);
        element.removeClass('hide');
        $compile(element.contents())(scope);
        // Call the after render function.
        if (afterRender && scope[afterRender]) {
            scope[afterRender](scope);
        }
    }

    return {
        restrict: 'E',
        scope: true,
        link: function(scope, element, attrs) {
            element.addClass('hide'); // Hide contents until they're treated.
            var content = element.html(); // Get directive's content.

            if (attrs.watch) {
                // Watch the variable inside the directive.
                var matches = content.match(extractVariableRegex);
                if (matches && typeof matches[1] == 'string') {
                    var variable = matches[1].trim();
                    scope.$watch(variable, function() {
                        formatAndRenderContents(scope, element, attrs, content);
                    });
                }
            } else {
                formatAndRenderContents(scope, element, attrs, content);
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to display content in an iframe.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmIframe
 * @description
 * Accepts the following attributes:
 *
 * @param {String} src          The source of the iframe.
 * @param {Mixed} [width=100%]  Width of the iframe. If not defined, use 100%.
 * @param {Mixed} [height=100%] Height of the iframe. If not defined, use 100%.
 */
.directive('mmIframe', ["$mmUtil", function($mmUtil) {

    var errorShownTime = 0,
        tags = ['iframe', 'frame', 'object', 'embed'];

    /**
     * Intercept window.open in a frame and its subframes, shows an error modal instead.
     *
     * @param  {DOMElement} element Element to treat.
     * @return {Void}
     */
    function interceptPopups(element) {
        if (element) {
            // Redefine window.open in this element and sub frames, it might have been loaded already.
            redefineWindowOpen(element);

            element.on('load', function() {
                // Element loaded, redefine window.open again.
                redefineWindowOpen(element);
            });
        }
    }

    /**
     * Redefine the open method in the contentWindow of an element and the sub frames.
     *
     * @param  {DOMElement} element Element to treat.
     * @return {Void}
     */
    function redefineWindowOpen(element) {
        var el = element[0],
            contentWindow = element.contentWindow || el.contentWindow,
            contents = element.contents();

        if (!contentWindow && el && el.contentDocument) {
            // It's probably an <object>. Try to get the window.
            contentWindow = el.contentDocument.defaultView;
        }

        if (!contentWindow && el && el.getSVGDocument) {
            // It's probably an <embed>. Try to get the window.
            var svgDoc = el.getSVGDocument;
            if (svgDoc && svgDoc.defaultView) {
                contents = angular.element(svgdoc);
                contentWindow = svgdoc.defaultView;
            } else if (el.window) {
                contentWindow = el.window;
            } else if (el.getWindow) {
                contentWindow = el.getWindow();
            }
        }

        if (contentWindow) {
            // Intercept window.open.
            contentWindow.open = function () {
                // Prevent showing more than one consecutive error. This shouldn't happen often because it means that the
                // element is using more than one window.open, but it's better to handle it just in case.
                var currentTime = new Date().getTime();
                if (currentTime - errorShownTime > 500) {
                    errorShownTime = currentTime;
                    $mmUtil.showErrorModal('mm.core.erroropenpopup', true);
                }
                return {}; // Return empty "window" object.
            };
        }

        // Search sub frames.
        angular.forEach(tags, function(tag) {
            angular.forEach(contents.find(tag), function(subelement) {
                interceptPopups(angular.element(subelement));
            });
        });
    }

    return {
        restrict: 'E',
        template: '<div class="iframe-wrapper"><iframe class="mm-iframe" ng-style="{\'width\': width, \'height\': height}" ng-src="{{src}}"></iframe></div>',
        scope: {
            src: '='
        },
        link: function(scope, element, attrs) {
            scope.width = $mmUtil.formatPixelsSize(attrs.iframeWidth) || '100%';
            scope.height = $mmUtil.formatPixelsSize(attrs.iframeHeight) || '100%';

            var iframe = angular.element(element.find('iframe')[0]);
            interceptPopups(iframe);
            iframe.on('load', function() {
                angular.forEach(iframe.contents().find('a'), function(el) {
                    var href = el.getAttribute('href');
                    if (href && href.indexOf('http') === 0) { // Check that href is not null.
                        angular.element(el).on('click', function(e) {
                            $mmUtil.openInBrowser(href);
                            e.preventDefault();
                        });
                    }
                });
            });

        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to prevent input validation on input fields.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmNoInputValidation
 * @description
 * Sometimes we might want to disable automatic validation on some input fields (like URLs).
 * This directive allows us to do so.
 */
.directive('mmImageViewer', ["$ionicModal", function($ionicModal) {
    return {
        restrict: 'A',
        priority: 500,
        scope: true,
        link: function(scope, element, attrs) {
            if (attrs.img) {
                scope.img = attrs.img;

                scope.closeModal = function(){
                    scope.modal.hide();
                };

                element.on('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    if (!scope.modal) {
                        $ionicModal.fromTemplateUrl('core/templates/imageviewer.html', {
                            scope: scope,
                            animation: 'slide-in-up'
                        }).then(function(m) {
                            scope.modal = m;
                            scope.modal.show();
                        });
                    } else {
                        scope.modal.show();
                    }
                });

                scope.$on('$destroy', function() {
                    if (scope.modal) {
                        scope.modal.remove();
                    }
                });
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to show a loading spinner and message while data is being loaded.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmLoading
 * @description
 * Usage:
 * <mm-loading message="{{loadingMessage}}" hide-until="dataLoaded" loading-padding-top="paddingTop">
 *     <!-- CONTENT TO HIDE UNTIL LOADED -->
 * </mm-loading>
 * This directive will show a ion-spinner with a message and hide all the content until 'dataLoaded' variable is set to true.
 * If 'message' attribute is not set, default message "Loading" is shown.
 * 'message' attribute accepts hardcoded strings, variables, filters, etc. E.g. message="{{ 'mm.core.loading' | translate}}".
 *
 * @param {String} [message]           Message to show while loading. If not set, default "Loading" message is shown.
 * @param {String} hideUntil           Scope variable to determine when should the contents be shown. When the variable is set
 *                                     to true, the loading is hidden and the contents are shown.
 * @param {String} [loadingPaddingTop] Padding top to set to loading view. If not set, no padding top is set. This attribute is
 *                                     meant to be used with dynamic paddings (e.g. to move the loading spinner to the user
 *                                     scrollTop). Static padding-top should be set using CSS.
 */
.directive('mmLoading', ["$translate", function($translate) {

    return {
        restrict: 'E',
        templateUrl: 'core/templates/loading.html',
        transclude: true,
        scope: {
            hideUntil: '=?',
            message: '@?',
            loadingPaddingTop: '=?'
        },
        link: function(scope, element, attrs) {
            var el = element[0],
                loading = angular.element(el.querySelector('.mm-loading-container'));

            if (!attrs.message) {
                // Default loading message.
                $translate('mm.core.loading').then(function(loadingString) {
                    scope.message = loadingString;
                });
            }

            if (attrs.loadingPaddingTop) {
                scope.$watch('loadingPaddingTop', function(newValue) {
                    // parseInt of an invalid string is NaN, but parseInt('a') == NaN is FALSE and typeof NaN = 'number'.
                    // That's why we use num >= 0 or num < 0 to check if it's a valid number.
                    var num = parseInt(newValue);
                    if (num >= 0 || num < 0) {
                        loading.css('padding-top', newValue + 'px');
                    } else if(typeof newValue == 'string') {
                        // Maybe they set a value like '200px'.
                        loading.css('padding-top', newValue);
                    }
                });
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * This directive adds a "bar" with arrows to navigate forward/backward and a "info" icon to display more data.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmNavigationBar
 * @description
 * This directive will show two arrows at the left and right of the screen to navigate to previous/next item when clicked.
 * If no previous/next item is defined, that arrow won't be shown. It will also show a button to show more info.
 *
 * @param {Mixed}    [previous] Previous item. If not defined, the previous arrow won't be shown.
 * @param {Mixed}    [next]     Next item. If not defined, the next arrow won't be shown.
 * @param {Function} [action]   Function to call when an arrow is clicked. Will receive as a param the item to load.
 * @param {String}   [info]     Info to show when clicking the info button. If not defined, the info button won't be shown.
 * @param {String}   [title]    Title to show when seeing the info (new state).
 */
.directive('mmNavigationBar', ["$state", "$translate", function($state, $translate) {
    return {
        restrict: 'E',
        scope: {
            previous: '=?',
            next: '=?',
            action: '=?',
            info: '=?'
        },
        templateUrl: 'core/templates/navigationbar.html',
        link: function(scope, element, attrs) {
            scope.title = attrs.title || $translate.instant('mm.core.info');
            scope.showInfo = function() {
                $state.go('site.mm_textviewer', {
                    title: scope.title,
                    content: scope.info
                });
            };
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to prevent input validation on input fields.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmNoInputValidation
 * @description
 * Sometimes we might want to disable automatic validation on some input fields (like URLs).
 * This directive allows us to do so.
 */
.directive('mmNoInputValidation', function() {
    return {
        restrict: 'A',
        priority: 500,
        compile: function(el, attrs) {
            attrs.$set('type',
                null,                //to delete type from attributes object
                false                //to preserve type attribute in DOM
            );
        }
    }
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

.constant('mmCoreSplitViewLoad', 'mmSplitView:load')

/**
 * Directive to create a split view layout. This directive should be used along with mm-split-view-link.
 *
 * IMPORTANT: Due to a limitation in Angular ui-router, the left pane state and the right pane state should NOT have
 * parameters with the same name but different value. It can cause unexpected behaviors.
 * Example: if the left pane loads a state with param 'courseid', then all the states that can be loaded in the right pane
 * should avoid having a parameter named 'courseid'. The right pane state can have a 'courseid' param only if it will always
 * have the same value than in left pane state.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmSplitView
 * @description
 * Usage:
 * <mm-split-view component="mmaCalendarEventsList">
 *     <!-- CONTENT TO SHOW ON THE LEFT PANEL (MENU) -->
 * </mm-split-view>
 *
 * To change the right pane contents (content pane), mmSplitViewLink directive is needed.
 * mmSplitView will automatically try to load a mmSplitViewLink when the view is loaded. This can be configured using
 * the attributes "load" and "loadWhen".
 *
 * If you don't have access to the directive's scope but you still want to configure when should the data be loaded and which
 * element should it load you can use the mmCoreSplitViewLoad event. When the directive receives this event it will try to
 * immediately load the link set (if no link is set it will load the first link found). Example:
 * $rootScope.$broadcast(mmCoreSplitViewLoad, {load: 2});
 *
 * IMPORTANT: Due to a limitation in Angular ui-router, the left pane state and the right pane state should NOT have
 * parameters with the same name but different value. It can cause unexpected behaviors.
 * Example: if the left pane loads a state with param 'courseid', then all the states that can be loaded in the right pane
 * should avoid having a parameter named 'courseid'. The right pane state can have a 'courseid' param only if it will always
 * have the same value than in left pane state.
 *
 * Accepts the following params:
 *
 * @param {String} [menuWidth] Width of the left menu. Can be specified in pixels ('200px') or in percentage ('30%').
 *
 * @param {String} [loadWhen]  Name of a scope variable. When that variable is set to true, a mm-split-view-link will be loaded in
 *                             in the contents pane. If not set, try to load it right at the start. See "load" param.
 *
 * @param {String} component   Component. In tablet, the new view will be named after the component.
 *
 * @param {Number} [load] Link to load. If not set then the first link will be loaded by default. If it's set then it will
 *                        try to load the nth link. E.g. load=2 will load the second link in the page.
 */
.directive('mmSplitView', ["$log", "$state", "$ionicPlatform", "$timeout", "$mmUtil", "$interpolate", "mmCoreSplitViewLoad", function($log, $state, $ionicPlatform, $timeout, $mmUtil, $interpolate, mmCoreSplitViewLoad) {

    $log = $log.getInstance('mmSplitView');

    /**
     * Trigger click on a DOM element.
     *
     * @param  {Object} link DOM element to trigger click.
     * @return {Boolean}     True if success, false otherwise.
     */
    function triggerClick(link) {
        if (link && link.length && link.triggerHandler) {
            link.triggerHandler('click');
            return true;
        }
        return false;
    }

    // Directive controller.
    function controller() {
        var self = this,
            element,
            menuState,
            linkToLoad,
            component;

        /**
         * Clears links marked as selected.
         */
        this.clearMarkedLinks = function() {
            angular.element(element.querySelectorAll('[mm-split-view-link]')).removeClass('mm-split-item-selected');
        };

        /**
         * Get component.
         *
         * @return {String} Component.
         */
        this.getComponent = function() {
            return component;
        };

        /**
         * Get split view menu's state name (left pane).
         *
         * @return {String} Menu state name.
         */
        this.getMenuState = function() {
            return menuState || $state.current.name;
        };

        /**
         * Load a mm-split-view-link.
         *
         * @param {Object} [scope]           Directive's scope.
         * @param {String|Number} [loadAttr] Number of link to load.
         * @param {Boolean} retrying         True if we're retrying because the function failed (link wasn't ready).
         */
        this.loadLink = function(scope, loadAttr, retrying) {
            if ($ionicPlatform.isTablet()) {
                if (!linkToLoad) {
                    // No link set. Let's determine if loadAttr is set and its real value.
                    if (typeof loadAttr != 'undefined') {
                        var position = parseInt(loadAttr);
                        if (!position) {
                            // Seems it's not a number. Try to interpolate it.
                            position = parseInt($interpolate(loadAttr)(scope), 10); // "Evaluate" scope variables.
                        }
                        if (position) {
                            var links = element.querySelectorAll('[mm-split-view-link]');
                            position = position > links.length ? 0 : position - 1;
                            linkToLoad = angular.element(links[position]);
                        } else {
                            // Load first link
                            linkToLoad = angular.element(element.querySelector('[mm-split-view-link]'));
                        }
                    } else {
                        // Load first link
                        linkToLoad = angular.element(element.querySelector('[mm-split-view-link]'));
                    }
                }

                if (!triggerClick(linkToLoad)) {
                    // Link not found. Let's retry once in the next digest.
                    if (!retrying) {
                        linkToLoad = undefined;
                        $timeout(function() {
                            self.loadLink(scope, loadAttr, true);
                        });
                    }
                }
            }
        };

        /**
         * Set component.
         *
         * @param {String} cmp Component.
         */
        this.setComponent = function(cmp) {
            component = cmp;
        };

        /**
         * Set directive's DOM element.
         *
         * @param {Object} el Directive's DOM element.
         */
        this.setElement = function(el) {
            element = el;
        };

        /**
         * Set mm-split-view-link to load. Used to re-load last state if needed.
         *
         * @param {Object} link Link to set (DOM element).
         */
        this.setLink = function(link) {
            linkToLoad = link;
        };

        /**
         * Set split view menu's state name (left pane).
         *
         * @param {String} state State name to set.
         */
        this.setMenuState = function(state) {
            menuState = state;
        };
    }

    return {
        restrict: 'E',
        templateUrl: 'core/templates/splitview.html',
        transclude: true,
        controller: controller,
        link: function(scope, element, attrs, controller) {
            var el = element[0],
                menu = angular.element(el.querySelector('.mm-split-pane-menu')),
                menuState = $state.$current.name,
                menuParams = $state.params,
                menuWidth = attrs.menuWidth,
                component = attrs.component || 'tablet';

            scope.component = component;

            controller.setComponent(component);
            controller.setElement(el);
            controller.setMenuState(menuState);

            if (menuWidth && $ionicPlatform.isTablet()) {
                menu.css('width', menuWidth);
                menu.css('-webkit-flex-basis', menuWidth);
                menu.css('-moz-flex-basis', menuWidth);
                menu.css('-ms-flex-basis', menuWidth);
                menu.css('flex-basis', menuWidth);
            }

            // We'll set all the listeners even if it's not a tablet, to support change between tablet-smartphone mode.

            if (attrs.loadWhen) {
                // Load link when variable is set to true.
                scope.$watch(attrs.loadWhen, function(newValue) {
                    if (newValue) {
                        controller.loadLink(scope, attrs.load);
                    }
                });
            } else {
                controller.loadLink(scope, attrs.load);
            }

            // Load last opened link when we re-enter the same state. We use $stateChangeSuccess instead of $ionicView.enter
            // because $ionicView.enter is not triggered when going to the same state.
            scope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
                // Compare that name and params are similar. We'll only compare 1st level of params, it's not a deep compare.
                if (toState.name === menuState && $mmUtil.basicLeftCompare(toParams, menuParams, 1)) {
                    controller.loadLink(); // No need to pass scope and load, link should be set.
                }
            });

            // Listen for event to load link.
            scope.$on(mmCoreSplitViewLoad, function(e, data) {
                if (data && data.load) {
                    controller.loadLink(scope, data.load);
                } else {
                    controller.loadLink(scope, attrs.load);
                }
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to load a state in a split-view-content pane in tablet or in a new page in phone.
 * Requires being a child of mmSplitView.
 *
 * IMPORTANT: Due to a limitation in Angular ui-router, the left pane state and the right pane state should NOT have
 * parameters with the same name but different value. It can cause unexpected behaviors.
 * Example: if the left pane loads a state with param 'courseid', then all the states that can be loaded in the right pane
 * should avoid having a parameter named 'courseid'. The right pane state can have a 'courseid' param only if it will always
 * have the same value than in left pane state.
 *
 * @module mm.core
 * @ngdoc directive
 * @name mmSplitViewLink
 * @description
 * Usage:
 * <... mm-split-view-link="site.mm_user-profile({courseid: courseid, userid: participant.id})" >
 *
 * This directive accepts a sref string that indicates the state to go to and the params. Scope variable need to be
 * inside curly brackets: {{variable_name}}.
 * In tablet, the new state contents will be loaded in split-pane contents pane.
 * In phone, the new state contents will be loaded in a new page.
 */
.directive('mmSplitViewLink', ["$log", "$ionicPlatform", "$state", "$mmApp", function($log, $ionicPlatform, $state, $mmApp) {
    $log = $log.getInstance('mmSplitViewLink');

    var srefRegex = new RegExp(/([^\(]*)(\((.*)\))?$/);

    /**
     * Create a new state for tablet view (split-view). The state created will be exactly the same as the target state
     * (stateName), but changing the name and the view name.
     *
     * @param  {String} stateName       Name of the state to copy.
     * @param  {String} tabletStateName Name of the new state.
     * @param  {String} newViewName     Name of the new view.
     * @return {Boolean}                True if success, false otherwise.
     */
    function createTabletState(stateName, tabletStateName, newViewName) {
        var targetState = $state.get(stateName),
            newConfig,
            viewName;

        if (targetState) {
            newConfig = angular.copy(targetState);

            // Change first view name to 'tablet' so it's loaded in the split-view content pane.
            viewName = Object.keys(newConfig.views)[0];
            newConfig.views[newViewName] = newConfig.views[viewName];
            delete newConfig.views[viewName];
            delete newConfig['name'];

            $mmApp.createState(tabletStateName, newConfig);
            return true;
        } else {
            $log.error('State doesn\'t exist: '+stateName);
            return false;
        }
    }

    /**
     * Evaluate a string using scope.
     *
     * @param  {Object} scope Scope.
     * @param  {String} value String to eval.
     * @return {Mixed}        Evaluated value or undefined if not valid.
     */
    function scopeEval(scope, value) {
        if (typeof value == 'string') {
            try {
                return scope.$eval(value);
            } catch(ex) {
                $log.error('Error evaluating string: ' + param);
            }
        }
    }

    return {
        restrict: 'A',
        require: '^mmSplitView',
        link: function(scope, element, attrs, splitViewController) {
            var sref = attrs.mmSplitViewLink,
                menuState = splitViewController.getMenuState(),
                matches,
                stateName,
                stateParams,
                stateParamsString,
                tabletStateName;

            if (sref) {
                matches = sref.match(srefRegex);
                if (matches && matches.length) {
                    stateName = matches[1]; // E.g. site.mm_user-profile
                    tabletStateName = menuState + '.' + stateName.substr(stateName.lastIndexOf('.') + 1);

                    stateParamsString = matches[3]; // E.g. {courseid: courseid, userid: userid}
                    stateParams = scopeEval(scope, stateParamsString);

                    // Watch for changes on stateParams.
                    scope.$watch(stateParamsString, function(newVal) {
                        stateParams = newVal;
                    });

                    element.on('click', function(event) {
                        event.stopPropagation();
                        event.preventDefault();

                        if ($ionicPlatform.isTablet()) {
                            if (!$state.get(tabletStateName)) {
                                // State doesn't exists. Let's create it.
                                if (!createTabletState(stateName, tabletStateName, splitViewController.getComponent())) {
                                    return;
                                }
                            }
                            splitViewController.setLink(element); // Set last link loaded.
                            splitViewController.clearMarkedLinks();
                            element.addClass('mm-split-item-selected');
                            $state.go(tabletStateName, stateParams, {location:'replace'});
                        } else {
                            $state.go(stateName, stateParams);
                        }
                    });
                } else {
                    $log.error('Invalid sref.');
                }
            } else {
                $log.error('Invalid sref.');
            }
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('mm_contentlinks', {
        url: '/mm_contentlinks',
        abstract: true,
        templateUrl: 'core/components/contentlinks/templates/base.html',
        cache: false,   // Disable caching to force controller reload.
    })

    .state('mm_contentlinks.choosesite', {
        url: '/choosesite',
        templateUrl: 'core/components/contentlinks/templates/choosesite.html',
        controller: 'mmContentLinksChooseSiteCtrl',
        params: {
            url: null
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course', ['mm.core.courses'])

.constant('mmCoreCoursePriority', 800)
.constant('mmCoreCourseAllSectionsId', -1)

.config(["$stateProvider", "$mmCoursesDelegateProvider", "mmCoreCoursePriority", function($stateProvider, $mmCoursesDelegateProvider, mmCoreCoursePriority) {

    $stateProvider

    .state('site.mm_course', {
        url: '/mm_course',
        params: {
            courseid: null,
            sid: null, // Section to load. Not naming it sectionid because it collides with 'mm_course-section' param in split-view.
            moduleid: null // Module to load.
        },
        views: {
            'site': {
                templateUrl: 'core/components/course/templates/sections.html',
                controller: 'mmCourseSectionsCtrl'
            }
        }
    })

    .state('site.mm_course-section', {
        url: '/mm_course-section',
        params: {
            sectionid: null,
            cid: null, // Not naming it courseid because it collides with 'site.mm_course' param in split-view.
            mid: null // Not naming it moduleid because it collides with 'site.mm_course' param in split-view.
        },
        views: {
            'site': {
                templateUrl: 'core/components/course/templates/section.html',
                controller: 'mmCourseSectionCtrl'
            }
        }
    })

    .state('site.mm_course-modcontent', {
        url: '/mm_course-modcontent',
        params: {
            module: null
        },
        views: {
            site: {
                templateUrl: 'core/components/course/templates/modcontent.html',
                controller: 'mmCourseModContentCtrl'
            }
        }
    });

    $mmCoursesDelegateProvider.registerNavHandler('mmCourse', '$mmCourseCoursesNavHandler', mmCoreCoursePriority);
}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmCourseDelegate", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmCourseDelegate) {
    $mmEvents.on(mmCoreEventLogin, $mmCourseDelegate.updateContentHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCourseDelegate.updateContentHandlers);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses', [])

.constant('mmCoursesSearchComponent', 'mmCoursesSearch')
.constant('mmCoursesSearchPerPage', 20) // Max of courses per page when searching courses.
.constant('mmCoursesEnrolInvalidKey', 'mmCoursesEnrolInvalidKey')
.constant('mmCoursesEventMyCoursesUpdated', 'my_courses_updated')
.constant('mmCoursesAccessMethods', {
     guest: 'guest',
     default: 'default'
})

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mm_courses', {
        url: '/mm_courses',
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/list.html',
                controller: 'mmCoursesListCtrl'
            }
        }
    })

    .state('site.mm_searchcourses', {
        url: '/mm_searchcourses',
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/search.html',
                controller: 'mmCoursesSearchCtrl'
            }
        }
    })

    .state('site.mm_viewresult', {
        url: '/mm_viewresult',
        params: {
            course: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/viewresult.html',
                controller: 'mmCoursesViewResultCtrl'
            }
        }
    });

}])

.config(["$mmContentLinksDelegateProvider", function($mmContentLinksDelegateProvider) {
    $mmContentLinksDelegateProvider.registerLinkHandler('mmCourses', '$mmCoursesHandlers.linksHandler');
}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmCoursesDelegate", "$mmCourses", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmCoursesDelegate, $mmCourses) {
    $mmEvents.on(mmCoreEventLogin, $mmCoursesDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCoursesDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventLogout, function() {
        $mmCoursesDelegate.clearCoursesHandlers();
        $mmCourses.clearCurrentCourses();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login', [])

.config(["$stateProvider", "$urlRouterProvider", "$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($stateProvider, $urlRouterProvider, $mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {

    $stateProvider

    .state('mm_login', {
        url: '/mm_login',
        abstract: true,
        templateUrl: 'core/components/login/templates/base.html',
        cache: false,   // Disable caching to force controller reload.
        onEnter: ["$ionicHistory", function($ionicHistory) {
            // Ensure that there is no history stack when getting here.
            $ionicHistory.clearHistory();
        }]
    })

    .state('mm_login.init', {
        url: '/init',
        templateUrl: 'core/components/login/templates/init.html',
        controller: 'mmLoginInitCtrl',
        cache: false // Disable caching to force controller reload.
    })

    .state('mm_login.sites', {
        url: '/sites',
        templateUrl: 'core/components/login/templates/sites.html',
        controller: 'mmLoginSitesCtrl',
        onEnter: ["$mmLoginHelper", "$mmSitesManager", function($mmLoginHelper, $mmSitesManager) {
            // Skip this page if there are no sites yet.
            $mmSitesManager.hasNoSites().then(function() {
                $mmLoginHelper.goToAddSite();
            });
        }]
    })

    .state('mm_login.site', {
        url: '/site',
        templateUrl: 'core/components/login/templates/site.html',
        controller: 'mmLoginSiteCtrl'
    })

    .state('mm_login.credentials', {
        url: '/cred',
        templateUrl: 'core/components/login/templates/credentials.html',
        controller: 'mmLoginCredentialsCtrl',
        params: {
            siteurl: ''
        },
        onEnter: ["$state", "$stateParams", function($state, $stateParams) {
            // Do not allow access to this page when the URL was not passed.
            if (!$stateParams.siteurl) {
              $state.go('mm_login.init');
            }
        }]
    })

    .state('mm_login.reconnect', {
        url: '/reconnect',
        templateUrl: 'core/components/login/templates/reconnect.html',
        controller: 'mmLoginReconnectCtrl',
        cache: false,
        params: {
            siteurl: '',
            username: '',
            infositeurl: ''
        }
    });

    // Default redirect to the login page.
    $urlRouterProvider.otherwise(function($injector) {
        var $state = $injector.get('$state');
        return $state.href('mm_login.init').replace('#', '');
    });

    // Restore the session.
    $mmInitDelegateProvider.registerProcess('mmLogin', '$mmSitesManager.restoreSession', mmInitDelegateMaxAddonPriority + 200);
}])

.run(["$log", "$state", "$mmUtil", "$translate", "$mmSitesManager", "$rootScope", "$mmSite", "$mmURLDelegate", "$ionicHistory", "$mmEvents", "$mmLoginHelper", "mmCoreEventSessionExpired", "$mmApp", function($log, $state, $mmUtil, $translate, $mmSitesManager, $rootScope, $mmSite, $mmURLDelegate, $ionicHistory,
                $mmEvents, $mmLoginHelper, mmCoreEventSessionExpired, $mmApp) {

    $log = $log.getInstance('mmLogin');

    // Listen for sessionExpired event to reconnect the user.
    $mmEvents.on(mmCoreEventSessionExpired, sessionExpired);

    // Register observer to check if the app was launched via URL scheme.
    $mmURLDelegate.register('mmLoginSSO', appLaunchedByURL);

    // Redirect depending on user session.
    $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {

        // Prevent state changes while the app is not ready.
        if (!$mmApp.isReady() && toState.name !== 'mm_login.init') {
            event.preventDefault();
            $state.transitionTo('mm_login.init');
            $log.warn('Forbidding state change to \'' + toState.name + '\'. App is not ready yet.');
            return;
        }

        if (toState.name.substr(0, 8) === 'redirect' || toState.name.substr(0, 15) === 'mm_contentlinks') {
            return;
        } else if ((toState.name.substr(0, 8) !== 'mm_login' || toState.name === 'mm_login.reconnect') && !$mmSite.isLoggedIn()) {
            // We are not logged in.
            event.preventDefault();
            $log.debug('Redirect to login page, request was: ' + toState.name);
            // Disable animation and back button for the next transition.
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.transitionTo('mm_login.init');
        } else if (toState.name.substr(0, 8) === 'mm_login' && toState.name !== 'mm_login.reconnect' && $mmSite.isLoggedIn()) {
            // We are logged in and requested the login page.
            event.preventDefault();
            $log.debug('Redirect to course page, request was: ' + toState.name);
            // Disable animation and back button for the next transition.
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.transitionTo('site.mm_courses');
        }

    });

    // Function to handle session expired events.
    function sessionExpired(siteid) {

        var siteurl = $mmSite.getURL();

        if (typeof(siteurl) !== 'undefined') {

            if (siteid && siteid !== $mmSite.getId()) {
                return; // Site that triggered the event is not current site.
            }

            // Check authentication method.
            $mmSitesManager.checkSite(siteurl).then(function(result) {

                if (result.warning) {
                    $mmUtil.showErrorModal(result.warning, true, 4000);
                }

                if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                    // SSO. User needs to authenticate in a browser.
                    $mmUtil.showConfirm($translate('mm.login.reconnectssodescription')).then(function() {
                        $mmLoginHelper.openBrowserForSSOLogin(result.siteurl);
                    });
                } else {
                    var info = $mmSite.getInfo();
                    if (typeof(info) !== 'undefined' && typeof(info.username) !== 'undefined') {
                        $ionicHistory.nextViewOptions({disableBack: true});
                        $state.go('mm_login.reconnect',
                                        {siteurl: result.siteurl, username: info.username, infositeurl: info.siteurl});
                    }
                }
            });
        }
    }

    // Function to handle URL received by Custom URL Scheme. If it's a SSO login, perform authentication.
    function appLaunchedByURL(url) {
        var ssoScheme = 'moodlemobile://token=';
        if (url.indexOf(ssoScheme) == -1) {
            return false;
        }

        // App opened using custom URL scheme. Probably an SSO authentication.
        $log.debug('App launched by URL');

        var modal = $mmUtil.showModalLoading('mm.login.authenticating', true);

        // Delete the sso scheme from the URL.
        url = url.replace(ssoScheme, '');
        // Decode from base64.
        try {
            url = atob(url);
        } catch(err) {
            // Error decoding the parameter.
            $log.error('Error decoding parameter received for login SSO');
            return false;
        }

        $mmLoginHelper.validateBrowserSSOLogin(url).then(function(sitedata) {

            $mmLoginHelper.handleSSOLoginAuthentication(sitedata.siteurl, sitedata.token).then(function() {
                $state.go('site.mm_courses');
            }, function(error) {
                $mmUtil.showErrorModal(error);
            }).finally(function() {
                modal.dismiss();
            });

        }, function(errorMessage) {
            modal.dismiss();
            if (typeof(errorMessage) === 'string' && errorMessage != '') {
                $mmUtil.showErrorModal(errorMessage);
            }
        });

        return true;
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings', [])

.constant('mmCoreSettingsDownloadSection', 'mmCoreSettingsDownloadSection')
.constant('mmCoreSettingsReportInBackground', 'mmCoreReportInBackground')
.constant('mmCoreSettingsSyncOnlyOnWifi', 'mmCoreSyncOnlyOnWifi')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mm_settings', {
        url: '/mm_settings',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/list.html'
            }
        }
    })

    .state('site.mm_settings-about', {
        url: '/mm_settings-about',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/about.html',
                controller: 'mmSettingsAboutCtrl'
            }
        }
    })

    .state('site.mm_settings-general', {
        url: '/mm_settings-general',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/general.html',
                controller: 'mmSettingsGeneralCtrl'
            }
        }
    })

    .state('site.mm_settings-spaceusage', {
        url: '/mm_settings-spaceusage',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/space-usage.html',
                controller: 'mmSettingsSpaceUsageCtrl'
            }
        }
    })

    .state('site.mm_settings-synchronization', {
        url: '/mm_settings-synchronization',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/synchronization.html',
                controller: 'mmSettingsSynchronizationCtrl'
            }
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.sidemenu', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site', {
        url: '/site',
        templateUrl: 'core/components/sidemenu/templates/menu.html',
        controller: 'mmSideMenuCtrl',
        abstract: true,
        cache: false,
        onEnter: ["$ionicHistory", "$state", "$mmSite", "$timeout", function($ionicHistory, $state, $mmSite, $timeout) {
            // Remove the login page from the history stack.
            $ionicHistory.clearHistory();

            // Go to login if user is not logged in.
            if (!$mmSite.isLoggedIn()) {
                $state.go('mm_login.init');
            }
        }]
    });

}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmSideMenuDelegate", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmSideMenuDelegate) {
    $mmEvents.on(mmCoreEventLogin, $mmSideMenuDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmSideMenuDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventLogout, $mmSideMenuDelegate.clearSiteHandlers);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.textviewer', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mm_textviewer', {
        url: '/mm_textviewer',
        params: {
            title: null,
            content: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/textviewer/templates/textviewer.html',
                controller: 'mmTextViewerIndexCtrl'
            }
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user', [])

.value('mmUserProfileState', 'site.mm_user-profile')

.config(["$stateProvider", "$mmContentLinksDelegateProvider", function($stateProvider, $mmContentLinksDelegateProvider) {

    $stateProvider

        .state('site.mm_user-profile', {
            url: '/mm_user-profile',
            views: {
                'site': {
                    controller: 'mmUserProfileCtrl',
                    templateUrl: 'core/components/user/templates/profile.html'
                }
            },
            params: {
                courseid: 0,
                userid: 0
            }
        });

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmUser', '$mmUserHandlers.linksHandler');

}])

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmUserDelegate", "$mmSite", "mmCoreEventUserDeleted", "$mmUser", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmUserDelegate, $mmSite, mmCoreEventUserDeleted, $mmUser) {
    $mmEvents.on(mmCoreEventLogin, $mmUserDelegate.updateProfileHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmUserDelegate.updateProfileHandlers);

    $mmEvents.on(mmCoreEventUserDeleted, function(data) {
        if (data.siteid && data.siteid === $mmSite.getId() && data.params) {
            // Search for userid in params.
            var params = data.params,
                userid = 0;
            if (params.userid) {
                userid = params.userid;
            } else if (params.userids) {
                userid = params.userids[0];
            } else if (params.field === 'id' && params.values && params.values.length) {
                userid = params.values[0];
            } else if (params.userlist && params.userlist.length) {
                userid = params.userlist[0].userid;
            }

            userid = parseInt(userid);
            if (userid > 0) {
                $mmUser.deleteStoredUser(userid);
            }
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks')

/**
 * Controller to choose an account to handle content links.
 *
 * @module mm.core.contentlinks
 * @ngdoc controller
 * @name mmContentLinksChooseSiteCtrl
 */
.controller('mmContentLinksChooseSiteCtrl', ["$scope", "$stateParams", "$mmSitesManager", "$mmUtil", "$ionicHistory", "$state", "$q", "$mmContentLinksDelegate", "$mmContentLinksHelper", function($scope, $stateParams, $mmSitesManager, $mmUtil, $ionicHistory, $state, $q,
            $mmContentLinksDelegate, $mmContentLinksHelper) {

    $scope.url = $stateParams.url || '';

    var action;

    function leaveView() {
        $mmSitesManager.logout().finally(function() {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.go('mm_login.sites');
        });
    }

    if (!$scope.url) {
        leaveView();
        return;
    }

    $mmContentLinksDelegate.getActionsFor($scope.url).then(function(actions) {
        action = $mmContentLinksHelper.getFirstValidAction(actions);
        if (!action) {
            return $q.reject();
        }

        $mmSitesManager.getSites(action.sites).then(function(sites) {
            $scope.sites = sites;
        });
    }).catch(function() {
        $mmUtil.showErrorModal('mm.contentlinks.errornosites', true);
        leaveView();
    });

    $scope.siteClicked = function(siteId) {
        action.action(siteId);
    };

    $scope.cancel = function() {
        leaveView();
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks')

/**
 * Service to handle links found in contents. Allows to capture links in content and redirect to certain parts
 * of the app instead of opening them in browser.
 *
 * @module mm.core.contentlinks
 * @ngdoc provider
 * @name $mmContentLinksDelegate
 */
.provider('$mmContentLinksDelegate', function() {
    var linkHandlers = {},
        self = {};

    /**
     * Register a link handler.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksDelegateProvider#registerLinkHandler
     * @param {String} name                    Handler's name.
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                         returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - getActions(siteIds, url, courseId) (Promise) Returns list of actions. Each action must have:
     *                                                           - message: Message related to the action to do. E.g. 'View'.
     *                                                           - icon: Icon related to the action to do.
     *                                                           - sites: Sites IDs that support the action. Subset of 'siteIds'.
     *                                                           - action(siteId): A function to be called when the link is clicked.
     * @param {Number} [priority]              Handler's priority.
     */
    self.registerLinkHandler = function(name, handler, priority) {
        if (typeof linkHandlers[name] !== 'undefined') {
            console.log("$mmContentLinksDelegateProvider: Addon '" + linkHandlers[name].name +
                        "' already registered as link handler");
            return false;
        }
        console.log("$mmContentLinksDelegateProvider: Registered handler '" + name + "' as link handler.");
        linkHandlers[name] = {
            name: name,
            handler: handler,
            instance: undefined,
            priority: typeof priority === 'undefined' ? 100 : priority
        };
        return true;
    };

    self.$get = ["$mmUtil", "$log", "$q", "$mmSitesManager", function($mmUtil, $log, $q, $mmSitesManager) {
        var self = {};

        $log = $log.getInstance('$mmContentLinksDelegate');

        /**
         * Get the list of possible actions to do for a URL.
         *
         * @module mm.core.contentlinks
         * @ngdoc method
         * @name $mmContentLinksDelegate#getLinkHandlersFor
         * @param {String} url        URL to handle.
         * @param {Number} [courseId] Course ID related to the URL. Optional but recommended since some handlers might require
         *                            to know the courseid if Moodle version is previous to 3.0.
         * @return {Promise}          Promise resolved with the actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActionsFor = function(url, courseId) {
            if (!url) {
                return $q.when([]);
            }

            // Get the list of sites the URL belongs to.
            return $mmSitesManager.getSiteIdsFromUrl(url, true).then(function(siteIds) {
                var linkActions = [],
                    promises = [];

                angular.forEach(linkHandlers, function(handler) {
                    if (typeof handler.instance === 'undefined') {
                        handler.instance = $mmUtil.resolveObject(handler.handler, true);
                    }

                    if (handler.instance) {
                        promises.push($q.when(handler.instance.getActions(siteIds, url, courseId)).then(function(actions) {
                            if (actions && actions.length) {
                                linkActions.push({
                                    priority: handler.priority,
                                    actions: actions
                                });
                            }
                        }));
                    }
                });

                return $mmUtil.allPromises(promises).catch(function() {}).then(function() {
                    // Sort link actions by priority.
                    return sortActionsByPriority(linkActions);
                });
            });
        };

        /**
         * Sort actions by priority. Each object in the actions param must have a priority and a list of actions.
         * The returned array only contains the actions ordered by priority.
         *
         * @param  {Object[]} actions Actions to sort.
         * @return {Object[]}         Sorted actions.
         */
        function sortActionsByPriority(actions) {
            var sorted = [];

            // Sort by priority.
            actions = actions.sort(function(a, b) {
                return a.priority > b.priority;
            });

            // Fill result array.
            actions.forEach(function(entry) {
                sorted = sorted.concat(entry.actions);
            });
            return sorted;
        }

        return self;
    }];

    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.contentlinks')

/**
 * Service to provide some helper functionalities for the contentlinks component.
 *
 * @module mm.core.contentlinks
 * @ngdoc service
 * @name $mmContentLinksHelper
 */
.factory('$mmContentLinksHelper', ["$log", "$ionicHistory", "$state", "$mmSite", "$mmContentLinksDelegate", "$mmUtil", "$translate", "$mmCourseHelper", function($log, $ionicHistory, $state, $mmSite, $mmContentLinksDelegate, $mmUtil, $translate,
            $mmCourseHelper) {

    $log = $log.getInstance('$mmContentLinksHelper');

    var self = {};

    /**
     * Filter the list of supported sites based on a isEnabled function.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#filterSupportedSites
     * @param  {String[]} siteIds     Site IDs to filter.
     * @param  {Function} isEnabledFn Function to call for each site. Must return a promise resolved with true if enabled. It
     *                                receives a siteId param and all the params sent to this function after 'checkAll'.
     * @param  {Boolean} checkAll     True if it should check all the sites, false if it should check only 1 and treat them all
     *                                depending on this result.
     * @param  {Mixed}                All the params sent after checkAll will be passed to isEnabledFn.
     * @return {Promise}              Promise resolved with the list of supported sites.
     */
    self.filterSupportedSites = function(siteIds, isEnabledFn, checkAll) {
        var promises = [],
            supported = [],
            extraParams = Array.prototype.slice.call(arguments, 3); // Params received after 'checkAll'.

        angular.forEach(siteIds, function(siteId) {
            if (checkAll || !promises.length) {
                promises.push(isEnabledFn.apply(isEnabledFn, [siteId].concat(extraParams)).then(function(enabled) {
                    if (enabled) {
                        supported.push(siteId);
                    }
                }));
            }
        });

        return $mmUtil.allPromises(promises).catch(function() {}).then(function() {
            if (!checkAll) {
                if (supported.length) {
                    return siteIds; // Checking 1 was enough and it succeeded, all sites supported.
                } else {
                    return []; // Checking 1 was enough and it failed, no sites supported.
                }
            } else {
                return supported;
            }
        });
    };

    /**
     * Get the first valid action in a list of actions.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#getFirstValidAction
     * @param  {Object[]} actions List of actions.
     * @return {Object}           First valid action. Returns undefined if no valid action found.
     */
    self.getFirstValidAction = function(actions) {
        if (actions) {
            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];
                if (action && action.sites && action.sites.length && angular.isFunction(action.action)) {
                    return action;
                }
            }
        }
    };

    /**
     * Goes to a certain state in a certain site. If the site is current site it will perform a regular navigation,
     * otherwise it uses the 'redirect' state to change the site.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#goInSite
     * @param  {String} stateName   Name of the state to go.
     * @param  {Object} stateParams Params to send to the state.
     * @param  {String} [siteId]    Site ID. If not defined, current site.
     * @return {Promise}            Promise resolved when the state is changed.
     */
    self.goInSite = function(stateName, stateParams, siteId) {
        siteId = siteId || $mmSite.getId();
        if (siteId == $mmSite.getId()) {
            return $state.go(stateName, stateParams);
        } else {
            return $state.go('redirect', {
                siteid: siteId,
                state: stateName,
                params: stateParams
            });
        }
    };

    /**
     * Go to the view to choose a site.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#goToChooseSite
     * @param {String} url URL to treat.
     * @return {Promise}   Promise resolved when the state changes.
     */
    self.goToChooseSite = function(url) {
        $ionicHistory.nextViewOptions({
            disableBack: true
        });
        return $state.go('mm_contentlinks.choosesite', {url: url});
    };

    /**
     * Handle a link.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#handleLink
     * @param  {String} url URL to handle.
     * @return {Promise}    Promise resolved with a boolean: true if URL was treated, false otherwise.
     */
    self.handleLink = function(url) {
        // Check if the link should be treated by some component/addon.
        return $mmContentLinksDelegate.getActionsFor(url).then(function(actions) {
            var action = self.getFirstValidAction(actions);
            if (action) {
                if (action.sites.length == 1 && action.sites[0] == $mmSite.getId()) {
                    // Current site.
                    action.action(action.sites[0]);
                } else {
                    // Not current site or more than one site. Ask for confirmation.
                    $mmUtil.showConfirm($translate('mm.contentlinks.confirmurlothersite')).then(function() {
                        if (action.sites.length == 1) {
                            action.action(action.sites[0]);
                        } else {
                            self.goToChooseSite(url);
                        }
                    });
                }
                return true;
            }
        }).catch(function() {
            return false;
        });
    };

    /**
     * Treats a URL that belongs to a module's index page.
     *
     * @module mm.core.contentlinks
     * @ngdoc method
     * @name $mmContentLinksHelper#treatModuleIndexUrl
     * @param {String[]} siteIds   Site IDs the URL belongs to.
     * @param {String} url         URL to treat.
     * @param {Function} isEnabled Function to check if the module is enabled. @see $mmContentLinksHelper#filterSupportedSites .
     * @param {Number} [courseId]  Course ID related to the URL.
     * @return {Promise}           Promise resolved with the list of actions.
     */
    self.treatModuleIndexUrl = function(siteIds, url, isEnabled, courseId) {
        var params = $mmUtil.extractUrlParams(url);
        if (typeof params.id != 'undefined') {
            // Pass false because all sites should have the same siteurl.
            return self.filterSupportedSites(siteIds, isEnabled, false, courseId).then(function(ids) {
                if (!ids.length) {
                    return [];
                } else {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: ids,
                        action: function(siteId) {
                            $mmCourseHelper.navigateToModule(parseInt(params.id, 10), siteId, courseId);
                        }
                    }];
                }
            });
        }
        return $q.when([]);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Mod content controller.
 *
 * @todo MDL-50114 The description might be missing because this data is based on the course
 *       contents which does not always include it.
 * @module mm.core.course
 * @ngdoc controller
 * @name mmCourseModContentCtrl
 */
.controller('mmCourseModContentCtrl', ["$log", "$stateParams", "$scope", function($log, $stateParams, $scope) {
    $log = $log.getInstance('mmCourseModContentCtrl');
    var module = $stateParams.module || {};
    $scope.description = module.description;
    $scope.title = module.name;
    $scope.url = module.url;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Section view controller.
 *
 * @module mm.core.course
 * @ngdoc controller
 * @name mmCourseSectionCtrl
 */
.controller('mmCourseSectionCtrl', ["$mmCourseDelegate", "$mmCourse", "$mmUtil", "$scope", "$stateParams", "$translate", "$mmSite", "$mmEvents", "$ionicScrollDelegate", "$mmCourses", "$q", "mmCoreEventCompletionModuleViewed", "$controller", function($mmCourseDelegate, $mmCourse, $mmUtil, $scope, $stateParams, $translate, $mmSite,
            $mmEvents, $ionicScrollDelegate, $mmCourses, $q, mmCoreEventCompletionModuleViewed, $controller) {

    // Default values are course 1 (front page) and all sections.
    var courseId = $stateParams.cid || 1,
        sectionId = $stateParams.sectionid || -1,
        moduleId = $stateParams.mid;

    $scope.sitehome = (courseId === 1); // Are we visiting the site home?
    $scope.sections = []; // Reset scope.sections, otherwise an error is shown in console with tablet view.

    if (sectionId < 0) {
        // Special scenario, we want all sections.
        if ($scope.sitehome) {
            $scope.title = $translate.instant('mma.frontpage.sitehome');
        } else {
            $scope.title = $translate.instant('mm.course.allsections');
        }
        $scope.summary = null;
    }

    // Convenience function to fetch section(s).
    function loadContent(sectionId) {
        return $mmCourses.getUserCourse(courseId, true).catch(function() {
            // User not enrolled in the course or an error occurred, ignore the error.
        }).then(function(course) {
            var promise;
            if (course && course.enablecompletion === false) {
                promise = $q.when([]); // Completion not enabled, return empty array.
            } else {
                promise = $mmCourse.getActivitiesCompletionStatus(courseId).catch(function() {
                    return []; // If fail, return empty array (as if there was no completion).
                });
            }

            return promise.then(function(statuses) {
                var promise,
                    sectionnumber;

                if (sectionId < 0) {
                    sectionnumber = 0;
                    promise = $mmCourse.getSections(courseId);
                } else {
                    sectionnumber = sectionId;
                    promise = $mmCourse.getSection(courseId, sectionId).then(function(section) {
                        $scope.title = section.name;
                        $scope.summary = section.summary;
                        return [section];
                    });
                }

                return promise.then(function(sections) {
                    // For the site home, we need to reverse the order to display first the site home section topic.
                    if ($scope.sitehome) {
                        sections.reverse();
                    }

                    var hasContent = false;

                    angular.forEach(sections, function(section) {
                        if (section.summary != '' || section.modules.length) {
                            hasContent = true;
                        }

                        angular.forEach(section.modules, function(module) {
                            module._controller =
                                    $mmCourseDelegate.getContentHandlerControllerFor(module.modname, module, courseId, section.id);
                            // Check if activity has completions and if it's marked.
                            var status = statuses[module.id];
                            if (typeof status != 'undefined') {
                                module.completionstatus = status;
                            }

                            if (module.id == moduleId) {
                                // This is the module we're looking for. Open it.
                                var scope = $scope.$new();
                                $controller(module._controller, {$scope: scope});
                                if (scope.action) {
                                    scope.action();
                                }
                            }
                        });
                    });

                    $scope.sections = sections;
                    $scope.hasContent = hasContent;

                    // Add log in Moodle.
                    $mmSite.write('core_course_view_course', {
                        courseid: courseId,
                        sectionnumber: sectionnumber
                    });
                }, function(error) {
                    if (error) {
                        $mmUtil.showErrorModal(error);
                    } else {
                        $mmUtil.showErrorModal('mm.course.couldnotloadsectioncontent', true);
                    }
                });
            });
        });
    }

    loadContent(sectionId).finally(function() {
        $scope.sectionLoaded = true;
    });

    $scope.doRefresh = function() {
        $mmCourse.invalidateSections(courseId).finally(function() {
            loadContent(sectionId).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    // Refresh list after a completion change since there could be new activities or so.
    function refreshAfterCompletionChange() {
        var scrollView = $ionicScrollDelegate.$getByHandle('mmSectionScroll');
        if (scrollView && scrollView.getScrollPosition()) {
            $scope.loadingPaddingTop = scrollView.getScrollPosition().top;
        }
        $scope.sectionLoaded = false;
        $scope.sections = [];
        loadContent(sectionId).finally(function() {
            $scope.sectionLoaded = true;
            $scope.loadingPaddingTop = 0;
        });
    }

    // Completion changed for at least one module. Invalidate data and re-load it.
    $scope.completionChanged = function() {
        $mmCourse.invalidateSections(courseId).finally(function() {
            refreshAfterCompletionChange();
        });
    };

    // Listen for viewed modules. If an automatic completion module is viewed, refresh the whole list.
    var observer = $mmEvents.on(mmCoreEventCompletionModuleViewed, function(cid) {
        if (cid === courseId) {
            refreshAfterCompletionChange();
        }
    });
    $scope.$on('$destroy', function() {
        if (observer && observer.off) {
            observer.off();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Sections view controller.
 *
 * @module mm.core.course
 * @ngdoc controller
 * @name mmCourseSectionsCtrl
 */
.controller('mmCourseSectionsCtrl', ["$mmCourse", "$mmUtil", "$scope", "$stateParams", "$translate", "$mmCourseHelper", "$mmEvents", "$mmSite", "$mmCoursePrefetchDelegate", "$mmCourses", "$q", "$ionicHistory", "$ionicPlatform", "mmCoreCourseAllSectionsId", "mmCoreEventSectionStatusChanged", "$mmConfig", "mmCoreSettingsDownloadSection", "$state", "$timeout", function($mmCourse, $mmUtil, $scope, $stateParams, $translate, $mmCourseHelper, $mmEvents,
            $mmSite, $mmCoursePrefetchDelegate, $mmCourses, $q, $ionicHistory, $ionicPlatform, mmCoreCourseAllSectionsId,
            mmCoreEventSectionStatusChanged, $mmConfig, mmCoreSettingsDownloadSection, $state, $timeout) {
    var courseId = $stateParams.courseid,
        sectionId = $stateParams.sid,
        moduleId = $stateParams.moduleid,
        downloadSectionsEnabled;

    $scope.courseId = courseId;
    $scope.sectionToLoad = 2; // Load "General" section by default.

    function checkDownloadSectionsEnabled() {
        return $mmConfig.get(mmCoreSettingsDownloadSection, true).then(function(enabled) {
            downloadSectionsEnabled = enabled;
        }).catch(function() {
            // Shouldn't happen.
            downloadSectionsEnabled = false;
        });
    }

    function loadSections(refresh) {
        // Get full course data. If not refreshing we'll try to get it from cache to speed up the response.
        return $mmCourses.getUserCourse(courseId).then(function(course) {
            $scope.fullname = course.fullname;
            // Get the sections.
            return $mmCourse.getSections(courseId).then(function(sections) {
                // Add a fake first section (all sections).
                return $translate('mm.course.allsections').then(function(str) {
                    // Adding fake first section.
                    var result = [{
                        name: str,
                        id: mmCoreCourseAllSectionsId
                    }].concat(sections);

                    $scope.sections = result;

                    if (downloadSectionsEnabled) {
                        // Calculate status of the sections.
                        return $mmCourseHelper.calculateSectionsStatus(result, courseId, true, refresh).catch(function() {
                            // Ignore errors (shouldn't happen).
                        }).then(function(downloadpromises) {
                            // If we restored any download we'll recalculate the status once all of them have finished.
                            if (downloadpromises && downloadpromises.length) {
                                $mmUtil.allPromises(downloadpromises).catch(function() {
                                    if (!$scope.$$destroyed) {
                                        $mmUtil.showErrorModal('mm.course.errordownloadingsection', true);
                                    }
                                }).finally(function() {
                                    if (!$scope.$$destroyed) {
                                        // Recalculate the status.
                                        $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false);
                                    }
                                });
                            }
                        });
                    }
                });
            });
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.couldnotloadsections', true);
            }
        });
    }

    // Prefetch a section. The second parameter indicates if the prefetch was started manually (true)
    // or it was automatically started because all modules are being downloaded (false).
    function prefetch(section, manual) {
        $mmCourseHelper.prefetch(section, courseId, $scope.sections).catch(function() {
            // Don't show error message if scope is destroyed or it's an automatic download but we aren't in this state.
            if ($scope.$$destroyed) {
                return;
            }

            var current = $ionicHistory.currentStateName(),
                isCurrent = ($ionicPlatform.isTablet() && current == 'site.mm_course.mm_course-section') ||
                            (!$ionicPlatform.isTablet() && current == 'site.mm_course');
            if (!manual && !isCurrent) {
                return;
            }

            $mmUtil.showErrorModal('mm.course.errordownloadingsection', true);
        }).finally(function() {
            if (!$scope.$$destroyed) {
                // Recalculate the status.
                $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false);
            }
        });
    }

    // Convenience function to autoload a section if sectionId param is set.
    function autoloadSection() {
        if (sectionId) {
            if ($ionicPlatform.isTablet()) {
                // Search the position of the section to load.
                angular.forEach($scope.sections, function(section, index) {
                    if (section.id == sectionId) {
                        $scope.sectionToLoad = index + 1;
                    }
                });
                // Set moduleId to pass it to the new state when the section is autoloaded. We unset it after this
                // to prevent autoloading the module when the user manually loads a section.
                $scope.moduleId = moduleId;
                $timeout(function() {
                    $scope.moduleId = null; // Unset moduleId when
                }, 500);
            } else {
                $state.go('site.mm_course-section', {
                    sectionid: sectionId,
                    cid: courseId,
                    mid: moduleId
                });
            }
        }
    }

    $scope.doRefresh = function() {
        var promises = [];
        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourse.invalidateSections(courseId));

        $q.all(promises).finally(function() {
            loadSections(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    $scope.prefetch = function(e, section) {
        e.preventDefault();
        e.stopPropagation();

        $mmCourseHelper.confirmDownloadSize(courseId, section, $scope.sections).then(function() {
            prefetch(section, true);
        });
    };

    checkDownloadSectionsEnabled().then(function() {
        loadSections().finally(function() {
            autoloadSection();
            $scope.sectionsLoaded = true;
        });
    });

    // Listen for section status changes.
    var statusObserver = $mmEvents.on(mmCoreEventSectionStatusChanged, function(data) {
        if (downloadSectionsEnabled && $scope.sections && $scope.sections.length && data.siteid === $mmSite.getId() &&
                    !$scope.$$destroyed&& data.sectionid) {
            // Check if the affected section is being downloaded. If so, we don't update section status
            // because it'll already be updated when the download finishes.
            if ($mmCoursePrefetchDelegate.isBeingDownloaded($mmCourseHelper.getSectionDownloadId({id: data.sectionid}))) {
                return;
            }

            // Recalculate the status.
            $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false).then(function() {
                var section;
                angular.forEach($scope.sections, function(s) {
                    if (s.id === data.sectionid) {
                        section = s;
                    }
                });
                if (section) {
                    var downloadid = $mmCourseHelper.getSectionDownloadId(section);
                    if (section.isDownloading && !$mmCoursePrefetchDelegate.isBeingDownloaded(downloadid)) {
                        // All the modules are now downloading, set a download all promise.
                        prefetch(section, false);
                    }
                }
            });
        }
    });

    $scope.$on('$destroy', function() {
        statusObserver && statusObserver.off && statusObserver.off();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Course Mod Description directive.
 *
 * To use to display the description of a module.
 *
 * @module mm.core.course
 * @ngdoc directive
 * @name mmCourseModDescription
 * @description
 *
 * This directive is meant to display a module description in a similar way throughout
 * all the modules. It has its own scope and so will use the attribute 'description' to
 * know what scope variable to look for in the parent scope.
 *
 * If the description is asynchronous you should set the attribute 'watch' to true.
 * This attribute is directly shared with mmFormatText which needs it.
 *
 * You can add a note at the right side of the description by using the 'note' attribute.
 *
 * Module descriptions are shortened by default, allowing the user to see the full description by clicking in it.
 * If you want the whole description to be shown you can use the 'showfull' attribute.
 *
 * @example
 *
 * <mm-course-mod-description description="myDescription"></mm-course-mod-description>
 *
 * <mm-course-mod-description description="myAsyncDesc" watch="true"></mm-course-mod-description>
 */
.directive('mmCourseModDescription', function() {
    return {
        compile: function(element, attrs) {
            if (attrs.watch) {
                element.find('mm-format-text').attr('watch', attrs.watch);
            }

            return function(scope) { // Link function.
                scope.showfull = !!attrs.showfull;
            };
        },
        restrict: 'E',
        scope: {
            description: '=',
            note: '='
        },
        templateUrl: 'core/components/course/templates/mod_description.html'
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Default course content handler.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseContentHandler
 */
.factory('$mmCourseContentHandler', ["$mmCourse", "$mmUtil", function($mmCourse, $mmUtil) {
    return {
        getController: function(module) {
            return function($scope, $state) {
                $scope.icon = $mmCourse.getModuleIconSrc(module.modname);
                $scope.title = module.name;

                $scope.action = function(e) {
                    $state.go('site.mm_course-modcontent', {module: module});
                    e.preventDefault();
                    e.stopPropagation();
                };

                if (module.url) {
                    $scope.buttons = [{
                        icon: 'ion-ios-browsers-outline',
                        label: 'mm.core.openinbrowser',
                        action: function(e) {
                            $mmUtil.openInBrowser(module.url);
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }];
                }
            };
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

.constant('mmCoreCourseModulesStore', 'course_modules') // @deprecated since version 2.6. Please do not use.

.config(["$mmSitesFactoryProvider", "mmCoreCourseModulesStore", function($mmSitesFactoryProvider, mmCoreCourseModulesStore) {
    var stores = [
        {
            name: mmCoreCourseModulesStore,
            keyPath: 'id'
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Factory containing course related methods.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourse
 */
.factory('$mmCourse', ["$mmSite", "$translate", "$q", "$log", "$mmEvents", "$mmSitesManager", "mmCoreEventCompletionModuleViewed", function($mmSite, $translate, $q, $log, $mmEvents, $mmSitesManager, mmCoreEventCompletionModuleViewed) {

    $log = $log.getInstance('$mmCourse');

    var self = {},
        mods = ["assign", "assignment", "book", "chat", "choice", "data", "database", "date", "external-tool",
            "feedback", "file", "folder", "forum", "glossary", "ims", "imscp", "label", "lesson", "lti", "page", "quiz",
            "resource", "scorm", "survey", "url", "wiki", "workshop"
        ],
        modsWithContent = ['book', 'folder', 'imscp', 'page', 'resource', 'url'];

    /**
     * Add a 'contents' property if the module needs it and it doesn't have it already. In some weird cases the site
     * doesn't return this property and it's needed. See MOBILE-1381.
     *
     * @param {Object} module Module to check.
     * @return {Object}       Module with contents.
     */
    function addContentsIfNeeded(module) {
        if (modsWithContent.indexOf(module.modname) > -1) {
            module.contents = module.contents || [];
        }
        return module;
    }

    /**
     * Check if the site is prepared to return a module without having its course ID.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#canGetModuleWithoutCourseId
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if can return it, rejected or resolved with false otherwise.
     */
    self.canGetModuleWithoutCourseId = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('core_course_get_course_module');
        });
    };

    /**
     * Check if the site is prepared to return a module by instance ID.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#canGetModuleByInstance
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if can return it, rejected or resolved with false otherwise.
     */
    self.canGetModuleByInstance = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('core_course_get_course_module_by_instance');
        });
    };

    /**
     * Check if module completion could have changed. If it could have, trigger event. This function must be used,
     * for example, after calling a "module_view" WS since it can change the module completion.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#checkModuleCompletion
     * @param {Number} courseId   Course ID.
     * @param {Object} completion Completion status of the module.
     */
    self.checkModuleCompletion = function(courseId, completion) {
        if (completion && completion.tracking === 2 && completion.state === 0) {
            self.invalidateSections(courseId).finally(function() {
                $mmEvents.trigger(mmCoreEventCompletionModuleViewed, courseId);
            });
        }
    };

    /**
     * Get completion status of all the activities in a course for a certain user.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getActivitiesCompletionStatus
     * @param  {Number} courseid Course ID.
     * @param  {Number} [userid] User ID. If not defined, current user.
     * @return {Promise}         Promise resolved with the completion statuses: object where the key is module ID.
     */
    self.getActivitiesCompletionStatus = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();

        $log.debug('Getting completion status for user ' + userid + ' in course ' + courseid);

        var params = {
                courseid: courseid,
                userid: userid
            },
            preSets = {
                cacheKey: getActivitiesCompletionCacheKey(courseid, userid)
            };

        return $mmSite.read('core_completion_get_activities_completion_status', params, preSets).then(function(data) {
            if (data && data.statuses) {
                var formattedStatuses = {};
                angular.forEach(data.statuses, function(status) {
                    formattedStatuses[status.cmid] = status;
                });
                return formattedStatuses;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for activities completion WS calls.
     *
     * @param  {Number} courseid Course ID.
     * @param  {Number} userid   User ID.
     * @return {String}          Cache key.
     */
    function getActivitiesCompletionCacheKey(courseid, userid) {
        return 'mmCourse:activitiescompletion:' + courseid + ':' + userid;
    }

    /**
     * Gets a module basic info by module ID.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleBasicInfo
     * @param  {Number} moduleId Module ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the module's info.
     */
    self.getModuleBasicInfo = function(moduleId, siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    cmid: moduleId
                },
                preSets = {
                    cacheKey: getModuleCacheKey(moduleId)
                };

            return site.read('core_course_get_course_module', params, preSets).then(function(response) {
                if (response.cm && (!response.warnings || !response.warnings.length)) {
                    return response.cm;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Gets a module basic info by instance.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleBasicInfoByInstance
     * @param {Number} id        Instance ID.
     * @param {String} module    Name of the module. E.g. 'glossary'.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the module's info.
     */
    self.getModuleBasicInfoByInstance = function(id, module, siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    instance: id,
                    module: module
                },
                preSets = {
                    cacheKey: getModuleByInstanceCacheKey(id, module)
                };

            return site.read('core_course_get_course_module_by_instance', params, preSets).then(function(response) {
                if (response.cm && (!response.warnings || !response.warnings.length)) {
                    return response.cm;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Get a module from Moodle.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModule
     * @param {Number} moduleId    The module ID.
     * @param {Number} [courseId]  The course ID. Recommended to speed up the process and minimize data usage.
     * @param {Number} [sectionId] The section ID.
     * @return {Promise}
     */
    self.getModule = function(moduleId, courseId, sectionId) {

        if (!moduleId) {
            return $q.reject();
        }

        var promise;

        if (!courseId) {
            // No courseId passed, try to retrieve it.
            promise = self.getModuleBasicInfo(moduleId).then(function(module) {
                return module.course;
            });
        } else {
            promise = $q.when(courseId);
        }

        return promise.then(function(courseId) {
            // We have courseId, we can use core_course_get_contents for compatibility.
            $log.debug('Getting module ' + moduleId + ' in course ' + courseId);

            params = {
                courseid: courseId,
                options: [
                    {
                        name: 'cmid',
                        value: moduleId
                    }
                ]
            };
            preSets = {
                cacheKey: getModuleCacheKey(moduleId)
            };

            if (sectionId) {
                params.options.push({
                    name: 'sectionid',
                    value: sectionId
                });
            }

            return $mmSite.read('core_course_get_contents', params, preSets).catch(function() {
                // Error getting the module. Try to get all contents (without filtering).
                params.options = [];
                preSets.cacheKey = getSectionsCacheKey(courseId);
                return $mmSite.read('core_course_get_contents', params, preSets);
            }).then(function(sections) {
                var section,
                    module;

                for (var i = 0; i < sections.length; i++) {
                    section = sections[i];
                    for (var j = 0; j < section.modules.length; j++) {
                        module = section.modules[j];
                        if (module.id == moduleId) {
                            module.course = courseId;
                            return addContentsIfNeeded(module);
                        }
                    }
                }
                return $q.reject();
            });
        });
    };

    /**
     * Get cache key for module WS calls.
     *
     * @param {Number} id     Instance ID.
     * @param {String} module Name of the module. E.g. 'glossary'.
     * @return {String}       Cache key.
     */
    function getModuleByInstanceCacheKey(id, module) {
        return 'mmCourse:moduleByInstance:' + module + ':' + id;
    }

    /**
     * Get cache key for module WS calls.
     *
     * @param {Number} moduleid Module ID.
     * @return {String}         Cache key.
     */
    function getModuleCacheKey(moduleid) {
        return 'mmCourse:module:' + moduleid;
    }

    /**
     * Returns the source to a module icon.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleIconSrc
     * @param {String} moduleName The module name.
     * @return {String} The IMG src.
     */
    self.getModuleIconSrc = function(moduleName) {
        if (mods.indexOf(moduleName) < 0) {
            moduleName = "external-tool";
        }

        return "img/mod/" + moduleName + ".svg";
    };

    /**
     * Get the section ID a module belongs to.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getModuleSectionId
     * @param {Number} moduleId   The module ID.
     * @param {Number} [courseId] The course ID. Required if Moodle site is prior to 3.0.
     * @param {String} [siteId]   Site ID. If not defined, current site.
     * @return {Promise}
     */
    self.getModuleSectionId = function(moduleId, courseId, siteId) {

        if (!moduleId) {
            return $q.reject();
        }

        // Try to get the section using getModuleBasicInfo.
        return self.getModuleBasicInfo(moduleId, siteId).then(function(module) {
            return module.section;
        }).catch(function() {
            if (!courseId) {
                // It failed and we don't have courseId, reject.
                return $q.reject();
            }

            // Get all the sections in the course and iterate over them to find it.
            return self.getSections(courseId, {}, siteId).then(function(sections) {
                sections.forEach(function(section) {
                    section.modules.forEach(function(module) {
                        if (module.id == moduleId) {
                            return section.id;
                        }
                    });
                });
                // Not found.
                return $q.reject();
            });
        });
    };

    /**
     * Return a specific section.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getSection
     * @param {Number} courseid The course ID.
     * @param {Number} sectionid The section ID.
     * @return {Promise} The reject contains the error message, else contains the section.
     */
    self.getSection = function(courseid, sectionid) {
        var deferred = $q.defer();

        if (sectionid < 0) {
            deferred.reject('Invalid section ID');
            return deferred.promise;
        }

        self.getSections(courseid).then(function(sections) {
            for (var i = 0; i < sections.length; i++) {
                if (sections[i].id == sectionid) {
                    deferred.resolve(sections[i]);
                    return;
                }
            }
            deferred.reject('Unkown section');
        }, function(error) {
            deferred.reject(error);
        });

        return deferred.promise;
    };

    /**
     * Get the course sections.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#getSections
     * @param {Number} courseid  The course ID.
     * @param {Object} [preSets] Optional. Presets to use.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise} The reject contains the error message, else contains the sections.
     */
    self.getSections = function(courseid, preSets, siteId) {
        preSets = preSets || {};
        siteId = siteId || $mmSite.getId();
        preSets.cacheKey = getSectionsCacheKey(courseid);

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.read('core_course_get_contents', {
                courseid: courseid,
                options: []
            }, preSets).then(function(sections) {
                angular.forEach(sections, function(section) {
                    angular.forEach(section.modules, function(module) {
                        addContentsIfNeeded(module);
                    });
                });
                return sections;
            });
        });
    };

    /**
     * Get cache key for section WS call.
     *
     * @param  {Number} courseid Course ID.
     * @return {String}          Cache key.
     */
    function getSectionsCacheKey(courseid) {
        return 'mmCourse:sections:' + courseid;
    }

    /**
     * Invalidates module WS call.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#invalidateModule
     * @param {Number} moduleid Module ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateModule = function(moduleid) {
        return $mmSite.invalidateWsCacheForKey(getModuleCacheKey(moduleid));
    };

    /**
     * Invalidates module WS call.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#invalidateModuleByInstance
     * @param {Number} id     Instance ID.
     * @param {String} module Name of the module. E.g. 'glossary'.
     * @return {Promise}      Promise resolved when the data is invalidated.
     */
    self.invalidateModuleByInstance = function(id, module) {
        return $mmSite.invalidateWsCacheForKey(getModuleByInstanceCacheKey(id, module));
    };

    /**
     * Invalidates sections WS call.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#invalidateSections
     * @param {Number} courseid  Course ID.
     * @param  {Number} [userid] User ID. If not defined, current user.
     * @return {Promise}         Promise resolved when the data is invalidated.
     */
    self.invalidateSections = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();

        var p1 = $mmSite.invalidateWsCacheForKey(getSectionsCacheKey(courseid)),
            p2 = $mmSite.invalidateWsCacheForKey(getActivitiesCompletionCacheKey(courseid, userid));
        return $q.all([p1, p2]);
    };

    /**
     * Translate a module name to current language.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourse#translateModuleName
     * @param {String} moduleName The module name.
     * @return {Promise}          Promise resolved with the translated name.
     */
    self.translateModuleName = function(moduleName) {
        if (mods.indexOf(moduleName) < 0) {
            moduleName = "external-tool";
        }

        var langkey = 'mm.core.mod_'+moduleName;
        return $translate(langkey).then(function(translated) {
            return translated !== langkey ? translated : moduleName;
        });
    };


    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Courses nav handler.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseCoursesNavHandler
 */
.factory('$mmCourseCoursesNavHandler', function() {
    return {

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        isEnabled: function() {
            return true;
        },

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean}          True if handler is enabled, false otherwise.
         */
        isEnabledForCourse: function() {
            return true;
        },

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        getController: function(courseId) {
            return function($scope, $state) {
                $scope.icon = 'ion-briefcase';
                $scope.title = 'mm.course.contents';

                $scope.action = function(e, course) {
                    $state.go('site.mm_course', {courseid: course.id});
                    e.preventDefault();
                    e.stopPropagation();
                };
            };
        }
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Delegate to register content handlers.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseDelegate
 * @description
 *
 * To register a content handler:
 *
 * .config($mmCourseDelegate, function() {
 *     $mmCourseDelegate.registerContentHandler('mmaYourAddon', 'moduleName', 'handlerName');
 *     $mmCourseDelegate.registerContentHandler('mmaModPage', 'page', '$mmaModPageCourseContentHandler');
 * })
 *
 * The content handler must provide two methods.
 *
 * 1/ isEnabled() which will be called once in a while to check if the plugin works on the current site.
 * 2/ getController(module, courseid) which should return a controller object
 *
 * The controller has its own scope inheriting the parent one. Though you should not use the
 * parent scope. To find out more what scope variables are expected look at the template
 * core/components/course/templates/section.html and at existing content handlers.
 */
.provider('$mmCourseDelegate', function() {
    var contentHandlers = {},
        self = {};

    /**
     * Register a content handler. If module is not supported in current site, handler should return undefined.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseDelegate#registerContentHandler
     * @param {String} addon The addon's name (mmaLabel, mmaForum, ...)
     * @param {String} handles The module this handler handles, e.g. forum, label. This value will be compared with
     *                         the value contained in module.modname from the Webservice core_course_get_contents.
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean) Whether or not the handler is enabled on a site level.
     *                             - getController(module, courseid) (Function) Returns the function that will act as controller.
     *                                                                See core/components/course/templates/section.html
     *                                                                for the list of scope variables expected.
     */
    self.registerContentHandler = function(addon, handles, handler) {
        if (typeof contentHandlers[handles] !== 'undefined') {
            console.log("$mmCourseDelegateProvider: Addon '" + contentHandlers[handles].addon + "' already registered as handler for '" + handles + "'");
            return false;
        }
        console.log("$mmCourseDelegateProvider: Registered addon '" + addon + "' as course content handler.");
        contentHandlers[handles] = {
            addon: addon,
            handler: handler,
            instance: undefined
        };
        return true;
    };

    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", "$mmCourseContentHandler", function($q, $log, $mmSite, $mmUtil, $mmCourseContentHandler) {
        var enabledHandlers = {},
            self = {};

        $log = $log.getInstance('$mmCourseDelegate');

        /**
         * Get the controller a content handler provides.
         *
         * This will first get the default data, then call the handler if any and override
         * the default data with the new data from the handler. That means that a handler
         * should always override any existing attribute if they want to change the defaults.
         *
         * @module mm.core.course
         * @ngdoc method
         * @name $mmCourseDelegate#getContentHandlerControllerFor
         * @param {String} handles   The module to work on
         * @param {Object} module    The module data
         * @param {Number} courseid  The course ID.
         * @param {Number} sectionid The section ID.
         * @return {Object}
         */
        self.getContentHandlerControllerFor = function(handles, module, courseid, sectionid) {
            if (typeof enabledHandlers[handles] !== 'undefined') {
                return enabledHandlers[handles].getController(module, courseid, sectionid);
            }
            return $mmCourseContentHandler.getController(module, courseid, sectionid);
        };

        /**
         * Update the enabled handlers for the current site.
         *
         * @module mm.core.course
         * @ngdoc method
         * @name $mmCourseDelegate#updateContentHandler
         * @param {String} handles The module this handler handles, e.g. forum, label. This value will be compared with
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateContentHandler = function(handles, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledHandlers[handles] = handlerInfo.instance;
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledHandlers[handles];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core.course
         * @ngdoc method
         * @name $mmCourseDelegate#updateContentHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateContentHandlers = function() {
            var promises = [],
                enabledHandlers = {};

            $log.debug('Updating content handlers for current site.');

            // Loop over all the content handlers.
            angular.forEach(contentHandlers, function(handlerInfo, handles) {
                promises.push(self.updateContentHandler(handles, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            });
        };

        return self;
    }];


    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Helper to gather some common course functions.
 *
 * @module mm.core.course
 * @ngdoc service
 * @name $mmCourseHelper
 */
.factory('$mmCourseHelper', ["$q", "$mmCoursePrefetchDelegate", "$mmFilepool", "$mmUtil", "$mmCourse", "$mmSite", "$state", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreDownloading", "mmCoreCourseAllSectionsId", function($q, $mmCoursePrefetchDelegate, $mmFilepool, $mmUtil, $mmCourse, $mmSite, $state,
            mmCoreNotDownloaded, mmCoreOutdated, mmCoreDownloading, mmCoreCourseAllSectionsId) {

    var self = {};

    /**
     * Calculate the status of a section.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#calculateSectionStatus
     * @param {Object[]} section          Section to calculate its status. Can't be "All sections".
     * @param  {Number} courseid          Course ID the section belongs to.
     * @param {Boolean} restoreDownloads  True if it should restore downloads. It will try to restore this section downloads.
     * @param {Boolean} refresh           True if it shouldn't use module status cache (slower).
     * @param {Promise[]} [dwnpromises]   If section download is restored, a promise will be added to this array. Required
     *                                    if restoreDownloads=true.
     * @return {Promise}         Promise resolved when the state is calculated.
     */
    self.calculateSectionStatus = function(section, courseid, restoreDownloads, refresh, dwnpromises) {

        if (section.id !== mmCoreCourseAllSectionsId) {
            // Get the status of this section.
            return $mmCoursePrefetchDelegate.getModulesStatus(section.id, section.modules, courseid, refresh, restoreDownloads)
                    .then(function(result) {

                // Check if it's being downloaded. We can't trust status 100% because downloaded books are always outdated.
                var downloadid = self.getSectionDownloadId(section);
                if ($mmCoursePrefetchDelegate.isBeingDownloaded(downloadid)) {
                    result.status = mmCoreDownloading;
                }

                // Set this section data.
                section.showDownload = result.status === mmCoreNotDownloaded;
                section.showRefresh = result.status === mmCoreOutdated;

                if (result.status !== mmCoreDownloading) {
                    section.isDownloading = false;
                    section.total = 0;
                } else if (!restoreDownloads) {
                    // Set download data.
                    section.count = 0;
                    section.total = result[mmCoreOutdated].length + result[mmCoreNotDownloaded].length +
                                    result[mmCoreDownloading].length;
                    section.isDownloading = true;
                } else {
                    // Restore or re-start the prefetch.
                    var promise = self.startOrRestorePrefetch(section, result, courseid).then(function() {
                        // Re-calculate the status of this section once finished.
                        return self.calculateSectionStatus(section, courseid);
                    });
                    if (dwnpromises) {
                        dwnpromises.push(promise);
                    }
                }

                return result;
            });
        }
        return $q.reject();
    };

    /**
     * Calculate the status of a list of sections, setting attributes to determine the icons/data to be shown.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#calculateSectionsStatus
     * @param {Object[]} sections         Sections to calculate their status.
     * @param  {Number} courseid          Course ID the sections belong to.
     * @param {Boolean} restoreDownloads  True if it should restore downloads. It will try to restore section downloads
     * @param {Boolean} refresh           True if it shouldn't use module status cache (slower).
     * @return {Promise}                  Promise resolved when the states are calculated. Returns an array of download promises
     *                                    with the restored downloads (only if restoreDownloads=true).
     */
    self.calculateSectionsStatus = function(sections, courseid, restoreDownloads, refresh) {

        var allsectionssection,
            allsectionsstatus,
            downloadpromises = [],
            statuspromises = [];

        angular.forEach(sections, function(section) {
            if (section.id === mmCoreCourseAllSectionsId) {
                // "All sections" section status is calculated using the status of the rest of sections.
                allsectionssection = section;
            } else {
                statuspromises.push(self.calculateSectionStatus(section, courseid, restoreDownloads, refresh, downloadpromises)
                        .then(function(result) {

                    // Calculate "All sections" status.
                    allsectionsstatus = $mmFilepool.determinePackagesStatus(allsectionsstatus, result.status);
                }));
            }
        });

        return $q.all(statuspromises).then(function() {
            if (allsectionssection) {
                // Set "All sections" data.
                allsectionssection.showDownload = allsectionsstatus === mmCoreNotDownloaded;
                allsectionssection.showRefresh = allsectionsstatus === mmCoreOutdated;
                allsectionssection.isDownloading = allsectionsstatus === mmCoreDownloading;
            }
            return downloadpromises;
        });
    };

    /**
     * Calculate the size of the download and show a confirm modal if needed.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#confirmDownloadSize
     * @param {Number} courseid   Course ID the section belongs to.
     * @param {Object} section    Section.
     * @param {Object[]} sections List of sections. Used when downloading all the sections.
     * @return {Promise}          Promise resolved if the user confirms or there's no need to confirm.
     */
    self.confirmDownloadSize = function(courseid, section, sections) {
        var sizePromise;

        // Calculate the size of the download.
        if (section.id != mmCoreCourseAllSectionsId) {
            sizePromise = $mmCoursePrefetchDelegate.getDownloadSize(section.modules, courseid);
        } else {
            var promises = [],
                size = 0;
            angular.forEach(sections, function(s) {
                if (s.id != mmCoreCourseAllSectionsId) {
                    promises.push($mmCoursePrefetchDelegate.getDownloadSize(s.modules, courseid).then(function(sectionsize) {
                        size = size + sectionsize;
                    }));
                }
            });
            sizePromise = $q.all(promises).then(function() {
                return size;
            });
        }

        return sizePromise.then(function(size) {
            // Show confirm modal if needed.
            return $mmUtil.confirmDownloadSize(size);
        });
    };

    /**
     * Get the course ID from a module, showing an error message if it can't be retrieved.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#getModuleCourseId
     * @param {Number} id        Instance ID.
     * @param {String} module    Name of the module. E.g. 'glossary'.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the module's course ID.
     */
    self.getModuleCourseIdByInstance = function(id, module, siteId) {
        return $mmCourse.getModuleBasicInfoByInstance(id, module, siteId).then(function(cm) {
            return cm.course;
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.errorgetmodule', true);
            }
            return $q.reject();
        });
    };

    /**
     * Get the download ID of a section. It's used to interact with $mmCoursePrefetchDelegate.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#getSectionDownloadId
     * @param {Object} section Section.
     * @return {String}        Section download ID.
     */
    self.getSectionDownloadId = function(section) {
        return 'Section-'+section.id;
    };

    /**
     * Retrieves the courseId of the module and navigates to it.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#navigateToModule
     * @param  {Number} moduleId    Module's ID.
     * @param  {String} [siteId]    Site ID. If not defined, current site.
     * @param  {Number} [courseId]  Course ID. If not defined we'll try to retrieve it from the site.
     * @param  {Number} [sectionId] Section the module belongs to. If not defined we'll try to retrieve it from the site.
     * @return {Promise}            Promise resolved when the state changes.
     */
    self.navigateToModule = function(moduleId, siteId, courseId, sectionId) {
        siteId = siteId || $mmSite.getId();
        var modal = $mmUtil.showModalLoading(),
            promise;

        return $mmCourse.canGetModuleWithoutCourseId(siteId).then(function(enabled) {
            if (courseId && sectionId) {
                // No need to retrieve more data.
                promise = $q.when();
            } else if (!courseId && !enabled) {
                // We don't have enough data and we can't retrieve it.
                promise = $q.reject();
            } else if (!courseId) {
                // We don't have courseId but WS is enabled.
                promise = $mmCourse.getModuleBasicInfo(moduleId, siteId).then(function(module) {
                    courseId = module.course;
                    sectionId = module.section;
                });
            } else {
                // We don't have sectionId but we have courseId.
                promise = $mmCourse.getModuleSectionId(moduleId, courseId, siteId).then(function(id) {
                    sectionId = id;
                });
            }

            return promise.then(function() {
                return $state.go('redirect', {
                    siteid: siteId,
                    state: 'site.mm_course',
                    params: {
                        courseid: courseId,
                        moduleid: moduleId,
                        sid: sectionId
                    }
                });
            });
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.errorgetmodule', true);
            }
            return $q.reject();
        }).finally(function() {
            modal.dismiss();
        });
    };

    /**
     * Prefetch or restore the prefetch of one section or all the sections.
     * If the section is "All sections" it will prefetch all the sections.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#prefetch
     * @param  {Object} section    Section.
     * @param  {Number} courseid   Course ID the section belongs to.
     * @param  {Object[]} sections List of sections. Used when downloading all the sections.
     * @return {promise}           Promise resolved when the prefetch is finished.
     */
    self.prefetch = function(section, courseid, sections) {

        if (section.id != mmCoreCourseAllSectionsId) {
            // Download only this section.
            return self.prefetchSection(section, courseid, true, sections);
        } else {
            // Download all the sections except "All sections".
            // In case of a failure, we want that ALL promises have finished before rejecting the promise.
            var promises = [];

            section.isDownloading = true;
            angular.forEach(sections, function(s) {
                if (s.id != mmCoreCourseAllSectionsId) {
                    promises.push(self.prefetchSection(s, courseid, false, sections).then(function() {
                        // Calculate only the section that finished.
                        return self.calculateSectionStatus(s, courseid);
                    }));
                }
            });

            return $mmUtil.allPromises(promises);
        }
    };

    /**
     * Prefetch or restore the prefetch of a certain section if it needs to be prefetched.
     * If the section is "All sections" it will be ignored.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#prefetchSection
     * @param  {Object} section         Section to prefetch.
     * @param  {Number} courseid        Course ID the section belongs to.
     * @param  {Boolean} singleDownload True if user is only downloading this section, false if user is downloading all sections.
     * @param {Object[]} [sections]     List of sections. Used only if singleDownload is true.
     * @return {Promise}                Promise resolved when the section is prefetched.
     */
    self.prefetchSection = function(section, courseid, singleDownload, sections) {

        if (section.id == mmCoreCourseAllSectionsId) {
            return $q.when();
        }

        section.isDownloading = true;

        // Validate the section needs to be downloaded and calculate amount of modules that need to be downloaded.
        return $mmCoursePrefetchDelegate.getModulesStatus(section.id, section.modules, courseid).then(function(result) {
            if (result.status === mmCoreNotDownloaded || result.status === mmCoreOutdated || result.status === mmCoreDownloading) {
                var promise = self.startOrRestorePrefetch(section, result, courseid);
                if (singleDownload) {
                    // Re-calculate status to determine the right status for the "All sections" section.
                    self.calculateSectionsStatus(sections, courseid, false);
                }
                return promise;
            }
        }, function() {
            // This shouldn't happen.
            section.isDownloading = false;
            return $q.reject();
        });
    };

    /**
     * Start or restore the prefetch of a section.
     * If the section is "All sections" it will be ignored.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#startOrRestorePrefetch
     * @param {Object} section Section to download.
     * @param {Object} status  Result of $mmCoursePrefetchDelegate#getModulesStatus for this section.
     * @return {Promise}       Promise resolved when the section has been prefetched.
     */
    self.startOrRestorePrefetch = function(section, status, courseid) {

        if (section.id == mmCoreCourseAllSectionsId) {
            return $q.when();
        }

        // We only download modules with status notdownloaded, downloading or outdated.
        var modules = status[mmCoreOutdated].concat(status[mmCoreNotDownloaded]).concat(status[mmCoreDownloading]),
            downloadid = self.getSectionDownloadId(section),
            moduleids;

        moduleids = modules.map(function(m) {
            return m.id;
        });

        // Set download data.
        section.count = 0;
        section.total = modules.length;
        section.isDownloading = true;

        // We prefetch all the modules to prevent incoeherences in the download count
        // and also to download stale data that might not be marked as outdated.
        return $mmCoursePrefetchDelegate.prefetchAll(downloadid, modules, courseid).then(function() {}, function() {
            // Return a rejected promise so errors are handled outside of this function.
            return $q.reject();
        }, function(id) {
            // Progress. Check that the module downloaded is one of the expected ones.
            var index = moduleids.indexOf(id);
            if (index > -1) {
                // It's one of the modules we were expecting to download.
                moduleids.splice(index, 1);
                section.count++;
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Delegate to register prefetch handlers.
 *
 * @module mm.core
 * @ngdoc service
 * @name $mmCoursePrefetchDelegate
 * @description
 *
 * To register a prefetch handler:
 *
 * .config(function($mmCoursePrefetchDelegateProvider) {
 *     $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaYourAddon', 'moduleName', 'handlerName');
 * })
 *
 * To see the methods that must provide the prefetch handler see {@link $mmCoursePrefetchDelegateProvider#registerPrefetchHandler}.
 */
.provider('$mmCoursePrefetchDelegate', function() {
    var prefetchHandlers = {},
        self = {};

    /**
     * Register a prefetch handler.
     *
     * @module mm.core
     * @ngdoc method
     * @name $mmCoursePrefetchDelegateProvider#registerPrefetchHandler
     * @param {String} addon The addon's name (mmaLabel, mmaForum, ...)
     * @param {String} handles The module this handler handles, e.g. forum, label.
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these properties. See {@link $mmUtil#resolveObject}.
     *                             - component (String) Handler's component.
     *                             - getDownloadSize(module, courseid) (Number|Promise) Get the download size of a module.
     *                             - isEnabled() (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                             - prefetch(module, courseid) (Promise) Prefetches a module.
     *                             - (Optional) getFiles(module, courseid) (Object[]|Promise) Get list of files. If not defined,
     *                                                                      we'll assume they're in module.contents.
     *                             - (Optional) determineStatus(status) (String) Returns status to show based on current. E.g. for
     *                                                                 books we'll show "outdated" even if state is "downloaded".
     *                             - (Optional) getRevision(module, courseid) (String|Number|Promise) Returns the module revision.
     *                                                                 If not defined we'll calculate it using module files.
     *                             - (Optional) getTimemodified(module, courseid) (Number|Promise) Returns the module timemodified.
     *                                                                 If not defined we'll calculate it using module files.
     */
    self.registerPrefetchHandler = function(addon, handles, handler) {
        if (typeof prefetchHandlers[handles] !== 'undefined') {
            console.log("$mmCoursePrefetchDelegateProvider: Addon '" + prefetchHandlers[handles].addon +
                            "' already registered as handler for '" + handles + "'");
            return false;
        }
        console.log("$mmCoursePrefetchDelegateProvider: Registered addon '" + addon + "' as prefetch handler.");
        prefetchHandlers[handles] = {
            addon: addon,
            handler: handler,
            instance: undefined
        };
        return true;
    };

    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", "$mmFilepool", "$mmEvents", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreNotDownloadable", "mmCoreEventSectionStatusChanged", function($q, $log, $mmSite, $mmUtil, $mmFilepool, $mmEvents, mmCoreDownloaded, mmCoreDownloading,
                mmCoreNotDownloaded, mmCoreOutdated, mmCoreNotDownloadable, mmCoreEventSectionStatusChanged) {
        var enabledHandlers = {},
            self = {},
            deferreds = {},
            statusCache = {}; // To speed up the getModulesStatus function.

        $log = $log.getInstance('$mmCoursePrefetchDelegate');

        /**
         * Clear the status cache (memory object).
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#clearStatusCache
         * @return {Void}
         */
        self.clearStatusCache = function() {
            statusCache = {};
        };

        /**
         * Determines a module status based on current status, restoring downloads if needed.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#determineModuleStatus
         * @param  {Object} module           Module.
         * @param  {String} status           Current status.
         * @param {Boolean} restoreDownloads True if it should restore downloads if needed.
         * @return {String}                  Module status.
         */
        self.determineModuleStatus = function(module, status, restoreDownloads) {
            var handler = enabledHandlers[module.modname];

            if (handler) {
                if (status == mmCoreDownloading && restoreDownloads) {
                    // Check if the download is being handled.
                    if (!$mmFilepool.getPackageDownloadPromise($mmSite.getId(), handler.component, module.id)) {
                        // Not handled, the app was probably restarted or something weird happened.
                        // Re-start download (files already on queue or already downloaded will be skipped).
                        handler.prefetch(module);
                    }
                } else if (handler.determineStatus) {
                    // The handler implements a determineStatus function. Apply it.
                    return handler.determineStatus(status);
                }
            }
            return status;
        };

        /**
         * Get modules download size. Only treat the modules with status not downloaded or outdated.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getDownloadSize
         * @param  {Object[]} modules List of modules.
         * @param  {Number} courseid  Course ID the modules belong to.
         * @return {Promise}          Promise resolved with the download size.
         */
        self.getDownloadSize = function(modules, courseid) {
            var size = 0,
                promises = [];

            angular.forEach(modules, function(module) {
                // Prevent null contents.
                module.contents = module.contents || [];

                // Check if the module has a prefetch handler.
                var handler = enabledHandlers[module.modname];
                if (handler) {
                    // Check if the file will be downloaded.
                    promises.push(self.getModuleStatus(module, courseid).then(function(modstatus) {
                        if (modstatus === mmCoreNotDownloaded || modstatus === mmCoreOutdated) {
                            return $q.when(handler.getDownloadSize(module, courseid)).then(function(modulesize) {
                                // Add the size of the downloadable files.
                                size = size + modulesize;
                            }).catch(function() {
                                // Ignore errors.
                            });
                        }
                    }));
                }
            });

            return $q.all(promises).then(function() {
                return size;
            });
        };

        /**
         * Get the module status.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getModuleStatus
         * @param {Object} module         Module.
         * @param {Number} courseid       Course ID the module belongs to.
         * @param {Number} [revision]     Module's revision. If not defined, it will be calculated using module data.
         * @param {Number} [timemodified] Module's timemodified. If not defined, it will be calculated using module data.
         * @return {Promise}              Promise resolved with the status.
         */
        self.getModuleStatus = function(module, courseid, revision, timemodified) {
            var handler = enabledHandlers[module.modname],
                siteid = $mmSite.getId();
            module.contents = module.contents || [];

            if (handler) {
                // If the handler doesn't define a function to get the files, use module.contents.
                var promise = handler.getFiles ? $q.when(handler.getFiles(module, courseid)) : $q.when(module.contents);

                return promise.then(function(files) {

                    if (files.length === 0) { // No files, treat is as downloaded.
                        return $q.when(mmCoreDownloaded);
                    }

                    // Get revision and timemodified if they aren't defined.
                    // If handler doesn't define a function to get them, get them from file list.
                    var promises = [];

                    if (typeof revision == 'undefined') {
                        if (handler.getRevision) {
                            promises.push($q.when(handler.getRevision(module, courseid)).then(function(rev) {
                                revision = rev;
                            }));
                        } else {
                            revision = $mmFilepool.getRevisionFromFileList(files);
                        }
                    }

                    if (typeof timemodified == 'undefined') {
                        if (handler.getTimemodified) {
                            promises.push($q.when(handler.getTimemodified(module, courseid)).then(function(timemod) {
                                timemodified = timemod;
                            }));
                        } else {
                            timemodified = $mmFilepool.getTimemodifiedFromFileList(files);
                        }
                    }

                    return $q.all(promises).then(function() {
                        // Now get the status.
                        return $mmFilepool.getPackageStatus(siteid, handler.component, module.id, revision, timemodified)
                                .then(function(status) {
                            return self.determineModuleStatus(module, status, true);
                        });
                    });
                });
            }

            return $q.reject();
        };

        /**
         * Get the status of a list of modules, along with the lists of modules for each status.
         * @see {@link $mmFilepool#determinePackagesStatus}
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getModulesStatus
         * @param  {String} sectionid         ID of the section the modules belong to.
         * @param  {Object[]} modules         List of modules to prefetch.
         * @param  {Number} courseid          Course ID the modules belong to.
         * @param  {Boolean} refresh          True if it should always check the DB (slower).
         * @param {Boolean} restoreDownloads  True if it should restore downloads. It's only used if refresh=false,
         *                                    if refresh=true then it always tries to restore downloads.
         * @return {Promise}                  Promise resolved with an object with the following properties:
         *                                            - status (String) Status of the module.
         *                                            - total (Number) Number of modules.
         *                                            - mmCoreNotDownloaded (Object[]) Modules with state mmCoreNotDownloaded.
         *                                            - mmCoreDownloaded (Object[]) Modules with state mmCoreDownloaded.
         *                                            - mmCoreDownloading (Object[]) Modules with state mmCoreDownloading.
         *                                            - mmCoreOutdated (Object[]) Modules with state mmCoreOutdated.
         */
        self.getModulesStatus = function(sectionid, modules, courseid, refresh, restoreDownloads) {

            var promises = [],
                status = mmCoreNotDownloadable,
                result = {};

            // Init result.
            result[mmCoreNotDownloaded] = [];
            result[mmCoreDownloaded] = [];
            result[mmCoreDownloading] = [];
            result[mmCoreOutdated] = [];
            result.total = 0;

            angular.forEach(modules, function(module) {
                // Check if the module has a prefetch handler.
                var handler = enabledHandlers[module.modname],
                    promise;
                // Prevent null contents.
                module.contents = module.contents || [];

                if (handler) {
                    var packageId = $mmFilepool.getPackageId(handler.component, module.id);
                    if (!refresh && statusCache[packageId] && statusCache[packageId].status) {
                        promise = $q.when(self.determineModuleStatus(module, statusCache[packageId].status, restoreDownloads));
                    } else {
                        promise = self.getModuleStatus(module, courseid);
                    }

                    promises.push(promise.then(function(modstatus) {
                        // Update status cache.
                        statusCache[packageId] = {
                            status: modstatus,
                            sectionid: sectionid
                        };
                        status = $mmFilepool.determinePackagesStatus(status, modstatus);
                        result[modstatus].push(module);
                        result.total++;
                    }));
                }
            });

            return $q.all(promises).then(function() {
                result.status = status;
                return result;
            });
        };

        /**
         * Get a prefetch handler.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getPrefetchHandlerFor
         * @param {String} handles The module to work on.
         * @return {Object}        Prefetch handler.
         */
        self.getPrefetchHandlerFor = function(handles) {
            return enabledHandlers[handles];
        };

        /**
         * Check if a list of modules is being downloaded.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#isBeingDownloaded
         * @param  {String} id An ID to identify the download.
         * @return {Boolean}   True if it's being downloaded, false otherwise.
         */
        self.isBeingDownloaded = function(id) {
            return deferreds[$mmSite.getId()] && deferreds[$mmSite.getId()][id];
        };

        /**
         * Prefetches a list of modules using their prefetch handlers.
         * If a prefetch already exists for this site and id, returns the current promise.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#getPrefetchHandlerFor
         * @param  {String} siteid    Site ID.
         * @param  {String} id        An ID to identify the download. It can be used to retrieve the download promise.
         * @param  {Object[]} modules List of modules to prefetch.
         * @param  {Number} courseid  Course ID the modules belong to.
         * @return {Promise}          Promise resolved when all modules have been prefetched. Notify is called everytime
         *                            a module is prefetched, passing the module id as param.
         */
        self.prefetchAll = function(id, modules, courseid) {

            var siteid = $mmSite.getId();

            if (deferreds[siteid] && deferreds[siteid][id]) {
                // There's a prefetch ongoing, return the current promise.
                return deferreds[siteid][id].promise;
            }

            var deferred = $q.defer(),
                promises = [];

            // Store the deferred.
            if (!deferreds[siteid]) {
                deferreds[siteid] = {};
            }
            deferreds[siteid][id] = deferred;

            angular.forEach(modules, function(module) {
                // Prevent null contents.
                module.contents = module.contents || [];

                // Check if the module has a prefetch handler.
                var handler = enabledHandlers[module.modname];
                if (handler) {
                    promises.push(handler.prefetch(module, courseid).then(function() {
                        deferred.notify(module.id);
                    }));
                }
            });

            $q.all(promises).then(function() {
                delete deferreds[siteid][id]; // Remove from array before resolving.
                deferred.resolve();
            }, function() {
                delete deferreds[siteid][id]; // Remove from array before rejecting.
                deferred.reject();
            });

            return deferred.promise;
        };

        /**
         * Update the enabled handlers for the current site.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#updatePrefetchHandler
         * @param {String} handles The module this handler handles, e.g. forum, label.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updatePrefetchHandler = function(handles, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the prefetch is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledHandlers[handles] = handlerInfo.instance;
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledHandlers[handles];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#updatePrefetchHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updatePrefetchHandlers = function() {
            var promises = [];

            $log.debug('Updating prefetch handlers for current site.');

            // Loop over all the prefetch handlers.
            angular.forEach(prefetchHandlers, function(handlerInfo, handles) {
                promises.push(self.updatePrefetchHandler(handles, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            });
        };

        /**
         * Update the status of a module in the "cache".
         *
         * @module mm.core
         * @ngdoc method
         * @name $mmCoursePrefetchDelegate#updateStatusCache
         * @return {Void}
         */
        self.updateStatusCache = function(component, componentId, status) {
            var notify = false,
                packageid = $mmFilepool.getPackageId(component, componentId);

            if (statusCache[packageid]) {
                // If the status has changed, notify that the section has changed.
                notify = statusCache[packageid].status !== status;
            } else {
                statusCache[packageid] = {};
            }
            statusCache[packageid].status = status;

            if (notify) {
                $mmEvents.trigger(mmCoreEventSectionStatusChanged, {
                    sectionid: statusCache[packageid].sectionid,
                    siteid: $mmSite.getId()
                });
            }
        };

        return self;
    }];


    return self;
})

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmCoursePrefetchDelegate", "$mmSite", "mmCoreEventPackageStatusChanged", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmCoursePrefetchDelegate, $mmSite,
            mmCoreEventPackageStatusChanged) {
    $mmEvents.on(mmCoreEventLogin, $mmCoursePrefetchDelegate.updatePrefetchHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCoursePrefetchDelegate.updatePrefetchHandlers);
    $mmEvents.on(mmCoreEventLogout, $mmCoursePrefetchDelegate.clearStatusCache);
    $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
        if (data.siteid === $mmSite.getId()) {
            $mmCoursePrefetchDelegate.updateStatusCache(data.component, data.componentId, data.status);
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Controller to handle the courses list.
 *
 * @module mm.core.courses
 * @ngdoc controller
 * @name mmCoursesListCtrl
 */
.controller('mmCoursesListCtrl', ["$scope", "$mmCourses", "$mmCoursesDelegate", "$mmUtil", "$mmEvents", "$mmSite", "mmCoursesEventMyCoursesUpdated", function($scope, $mmCourses, $mmCoursesDelegate, $mmUtil, $mmEvents, $mmSite,
            mmCoursesEventMyCoursesUpdated) {

    $scope.searchEnabled = $mmCourses.isSearchCoursesAvailable();
    $scope.areNavHandlersLoadedFor = $mmCoursesDelegate.areNavHandlersLoadedFor;

    // Convenience function to fetch courses.
    function fetchCourses(refresh) {
        return $mmCourses.getUserCourses().then(function(courses) {
            $scope.courses = courses;
            angular.forEach(courses, function(course) {
                course._handlers = $mmCoursesDelegate.getNavHandlersFor(course.id, refresh);
            });
            $scope.filterText = ''; // Filter value MUST be set after courses are shown.
        }, function(error) {
            if (typeof error != 'undefined' && error !== '') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.courses.errorloadcourses', true);
            }
        });
    }
    fetchCourses().finally(function() {
        $scope.coursesLoaded = true;
    });

    $scope.refreshCourses = function() {
        $mmCourses.invalidateUserCourses().finally(function() {
            fetchCourses(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    $mmEvents.on(mmCoursesEventMyCoursesUpdated, function(siteid) {
        if (siteid == $mmSite.getId()) {
            fetchCourses();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Controller to handle search courses.
 *
 * @module mm.core.courses
 * @ngdoc controller
 * @name mmCoursesSearchCtrl
 */
.controller('mmCoursesSearchCtrl', ["$scope", "$mmCourses", "$q", "$mmUtil", function($scope, $mmCourses, $q, $mmUtil) {

    var page = 0,
    	currentSearch = '';

    $scope.searchText = '';

    // Convenience function to search courses.
    function searchCourses(refresh) {
        if (refresh) {
            page = 0;
        }

        return $mmCourses.search(currentSearch, page).then(function(response) {
            if (page === 0) {
                $scope.courses = response.courses;
            } else {
                $scope.courses = $scope.courses.concat(response.courses);
            }
            $scope.total = response.total;

            page++;
            $scope.canLoadMore = $scope.courses.length < $scope.total;

        }).catch(function(message) {
            $scope.canLoadMore = false;
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.searchcourses.errorsearching', true);
            }
            return $q.reject();
        });
    }

    $scope.search = function(text) {
        currentSearch = text;
        $scope.courses = undefined;

    	var modal = $mmUtil.showModalLoading('mm.core.searching', true);
    	searchCourses(true).finally(function() {
            modal.dismiss();
    	});
    };

    $scope.loadMoreResults = function() {
    	searchCourses();
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Controller to handle view a course that was searched.
 *
 * @module mm.core.courses
 * @ngdoc controller
 * @name mmCoursesViewResultCtrl
 */
.controller('mmCoursesViewResultCtrl', ["$scope", "$stateParams", "$mmCourses", "$mmCoursesDelegate", "$mmUtil", "$translate", "$q", "$ionicModal", "$mmEvents", "$mmSite", "mmCoursesSearchComponent", "mmCoursesEnrolInvalidKey", "mmCoursesEventMyCoursesUpdated", function($scope, $stateParams, $mmCourses, $mmCoursesDelegate, $mmUtil, $translate, $q,
            $ionicModal, $mmEvents, $mmSite, mmCoursesSearchComponent, mmCoursesEnrolInvalidKey, mmCoursesEventMyCoursesUpdated) {

    var course = $stateParams.course || {},
        selfEnrolWSAvailable = $mmCourses.isSelfEnrolmentEnabled(),
        guestWSAvailable = $mmCourses.isGuestWSAvailable(),
        isGuestEnabled = false,
        guestInstanceId,
        handlersShouldBeShown = true,
        enrollmentMethods;

    $scope.course = course;
    $scope.title = course.fullname;
    $scope.component = mmCoursesSearchComponent;
    $scope.selfEnrolInstances = [];
    $scope.enroldata = {
        password: ''
    };

    // Function to determine if handlers are being loaded.
    $scope.loadingHandlers = function() {
        return handlersShouldBeShown && !$mmCoursesDelegate.areNavHandlersLoadedFor(course.id);
    };

    // Convenience function to get course. We use this to determine if a user can see the course or not.
    function getCourse(refresh) {
        var promise;
        if (selfEnrolWSAvailable || guestWSAvailable) {
            // Get course enrolment methods.
            $scope.selfEnrolInstances = [];
            promise = $mmCourses.getCourseEnrolmentMethods(course.id).then(function(methods) {
                enrollmentMethods = methods;

                angular.forEach(enrollmentMethods, function(method) {
                    if (selfEnrolWSAvailable && method.type === 'self') {
                        $scope.selfEnrolInstances.push(method);
                    } else if (guestWSAvailable && method.type === 'guest') {
                        isGuestEnabled = true;
                    }
                });
            }).catch(function(error) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                }
            });
        } else {
            promise = $q.when(); // No need to get enrolment methods.
        }

        return promise.then(function() {
            // Check if user is enrolled in the course.
            return $mmCourses.getUserCourse(course.id).then(function(c) {
                $scope.isEnrolled = true;
                return c;
            }).catch(function() {
                // The user is not enrolled in the course. Use getCourses to see if it's an admin/manager and can see the course.
                $scope.isEnrolled = false;
                return $mmCourses.getCourse(course.id);
            }).then(function(c) {
                // Success retrieving the course, we can assume the user has permissions to view it.
                course.fullname = c.fullname || course.fullname;
                course.summary = c.summary || course.summary;
                course._handlers = $mmCoursesDelegate.getNavHandlersFor(course.id, refresh);
            }).catch(function() {
                // The user is not an admin/manager. Check if we can provide guest access to the course.
                return canAccessAsGuest().then(function(passwordRequired) {
                    if (!passwordRequired) {
                        course._handlers = $mmCoursesDelegate.getNavHandlersForGuest(course.id, refresh);
                    } else {
                        course._handlers = [];
                        handlersShouldBeShown = false;
                    }
                }).catch(function() {
                    course._handlers = [];
                    handlersShouldBeShown = false;
                });
            });
        });
    }

    // Convenience function to check if the user can access as guest.
    function canAccessAsGuest() {
        if (!isGuestEnabled) {
            return $q.reject();
        }

            // Search instance ID of guest enrolment method.
        angular.forEach(enrollmentMethods, function(method) {
            if (method.type == 'guest') {
                guestInstanceId = method.id;
            }
        });

        if (guestInstanceId) {
            return $mmCourses.getCourseGuestEnrolmentInfo(guestInstanceId).then(function(info) {
                if (!info.status) {
                    // Not active, reject.
                    return $q.reject();
                }
                return info.passwordrequired;
            });
        }
        return $q.reject();
    }

    function refreshData() {
        var promises = [];

        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourses.invalidateCourse(course.id));
        promises.push($mmCourses.invalidateCourseEnrolmentMethods(course.id));
        if (guestInstanceId) {
            promises.push($mmCourses.invalidateCourseGuestEnrolmentInfo(guestInstanceId));
        }

        return $q.all(promises).finally(function() {
            return getCourse(true);
        });
    }

    getCourse().finally(function() {
        $scope.courseLoaded = true;
    });

    $scope.doRefresh = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    if (selfEnrolWSAvailable && course.enrollmentmethods.indexOf('self') > -1) {
        // Setup password modal for self-enrolment.
        $ionicModal.fromTemplateUrl('core/components/courses/templates/password-modal.html', {
            scope: $scope,
            animation: 'slide-in-up'
        }).then(function(modal) {
            $scope.modal = modal;

            $scope.closeModal = function() {
                $scope.enroldata.password = '';
                delete $scope.currentEnrolInstance;
                modal.hide();
            };
            $scope.$on('$destroy', function() {
                modal.remove();
            });
        });

        // Convenience function to self-enrol a user in a course.
        $scope.enrol = function(instanceId, password) {
            var promise;

            if ($scope.modal.isShown()) {
                // Don't show confirm if password is shown, we already showed it before.
                promise = $q.when();
            } else {
                promise = $mmUtil.showConfirm($translate('mm.courses.confirmselfenrol'));
            }

            promise.then(function() {
                var modal = $mmUtil.showModalLoading('mm.core.loading', true);

                $mmCourses.selfEnrol(course.id, password, instanceId).then(function() {
                    // Close modal and refresh data.
                    $scope.closeModal();
                    $scope.isEnrolled = true;
                    refreshData().finally(function() {
                        // My courses have been updated, trigger event.
                        $mmEvents.trigger(mmCoursesEventMyCoursesUpdated, $mmSite.getId());
                    });
                }).catch(function(error) {
                    if (error) {
                        if (error.code === mmCoursesEnrolInvalidKey) {
                            // Invalid password. If password was already shown, show error message.
                            if ($scope.modal.isShown()) {
                                $mmUtil.showErrorModal(error.message);
                            } else {
                                $scope.currentEnrolInstance = instanceId;
                                $scope.modal.show();
                            }
                        } else if (typeof error == 'string') {
                            $mmUtil.showErrorModal(error);
                        }
                    } else {
                        $mmUtil.showErrorModal('mm.courses.errorselfenrol', true);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            });
        };
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Service to handle site courses.
 *
 * @module mm.core.courses
 * @ngdoc service
 * @name $mmCourses
 */
.factory('$mmCourses', ["$q", "$mmSite", "$log", "$mmSitesManager", "mmCoursesSearchPerPage", "mmCoursesEnrolInvalidKey", function($q, $mmSite, $log, $mmSitesManager, mmCoursesSearchPerPage, mmCoursesEnrolInvalidKey) {

    $log = $log.getInstance('$mmCourses');

    var self = {},
        currentCourses = {};

    /**
     * DEPRECATED: this function will be removed in a future version.
     * Clear current courses array. Reserved for core use.
     *
     * @deprecated since version 2.5
     * @protected
     */
    self.clearCurrentCourses = function() {
        currentCourses = {};
    };

    /**
     * Get course.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourse
     * @param {Number} id       ID of the course to get.
     * @param {String} [siteid] Site to get the courses from. If not defined, use current site.
     * @return {Promise}        Promise to be resolved when the courses are retrieved.
     */
    self.getCourse = function(id, siteid) {
        return self.getCourses([id], siteid).then(function(courses) {
            if (courses && courses.length > 0) {
                return courses[0];
            }
            return $q.reject();
        });
    };

    /**
     * Get the enrolment methods from a course.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourseEnrolmentMethods
     * @param {Number} id ID of the course.
     * @return {Promise}  Promise to be resolved when the methods are retrieved.
     */
    self.getCourseEnrolmentMethods = function(id) {
        var params = {
                courseid: id
            },
            preSets = {
                cacheKey: getCourseEnrolmentMethodsCacheKey(id)
            };

        return $mmSite.read('core_enrol_get_course_enrolment_methods', params, preSets);
    };

    /**
     * Get cache key for get course enrolment methods WS call.
     *
     * @param  {Number} id Course ID.
     * @return {String}    Cache key.
     */
    function getCourseEnrolmentMethodsCacheKey(id) {
        return 'mmCourses:enrolmentmethods:' + id;
    }

    /**
     * Get info from a course guest enrolment method.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourseGuestEnrolmentInfo
     * @param {Number} instanceId Guest instance ID.
     * @return {Promise}          Promise to be resolved when the info is retrieved.
     */
    self.getCourseGuestEnrolmentInfo = function(instanceId) {
        var params = {
                instanceid: instanceId
            },
            preSets = {
                cacheKey: getCourseGuestEnrolmentInfoCacheKey(instanceId)
            };

        return $mmSite.read('enrol_guest_get_instance_info', params, preSets).then(function(response) {
            return response.instanceinfo;
        });
    };

    /**
     * Get cache key for get course enrolment methods WS call.
     *
     * @param {Number} instanceId Guest instance ID.
     * @return {String}           Cache key.
     */
    function getCourseGuestEnrolmentInfoCacheKey(instanceId) {
        return 'mmCourses:guestinfo:' + instanceId;
    }

    /**
     * Get courses.
     * Warning: if the user doesn't have permissions to view some of the courses passed the WS call will fail.
     * The user must be able to view ALL the courses passed.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getCourses
     * @param {Number[]} ids    List of IDs of the courses to get.
     * @param {String} [siteid] Site to get the courses from. If not defined, use current site.
     * @return {Promise}        Promise to be resolved when the courses are retrieved.
     */
    self.getCourses = function(ids, siteid) {
        siteid = siteid || $mmSite.getId();

        if (!angular.isArray(ids)) {
            return $q.reject();
        } else if (ids.length === 0) {
            return $q.when([]);
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {

            var data = {
                    options: {
                        ids: ids
                    }
                },
                preSets = {
                    cacheKey: getCoursesCacheKey(ids)
                };

            return site.read('core_course_get_courses', data, preSets).then(function(courses) {
                if (typeof courses != 'object' && !angular.isArray(courses)) {
                    return $q.reject();
                }
                return courses;
            });
        });
    };

    /**
     * Get cache key for get courses WS call.
     *
     * @param  {Number[]} ids Courses IDs.
     * @return {String}       Cache key.
     */
    function getCoursesCacheKey(ids) {
        return 'mmCourses:course:' + JSON.stringify(ids);
    }

    /**
     * DEPRECATED: this function will be removed in a future version. Please use $mmCourses#getUserCourse.
     * Get a course stored in memory.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getStoredCourse
     * @param  {Number} id ID of the course to get.
     * @return {Object}    Course.
     * @deprecated since version 2.5
     */
    self.getStoredCourse = function(id) {
        $log.warn('The function \'getStoredCourse\' is deprecated. Please use \'getUserCourse\' instead');
        return currentCourses[id];
    };

    /**
     * Get a course the user is enrolled in. This function relies on $mmCourses#getUserCourses.
     * preferCache=true will try to speed up the response, but the data returned might not be updated.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getUserCourse
     * @param {Number} id                   ID of the course to get.
     * @param {Boolean} [preferCache=false] True if shouldn't call WS if data is cached, false otherwise.
     * @param {String} [siteid]             Site to get the courses from. If not defined, use current site.
     * @return {Promise}                    Promise resolved with the course.
     * @since 2.5
     */
    self.getUserCourse = function(id, preferCache, siteid) {
        siteid = siteid || $mmSite.getId();

        if (!id) {
            return $q.reject();
        }

        if (typeof preferCache == 'undefined') {
            preferCache = false;
        }

        return self.getUserCourses(preferCache, siteid).then(function(courses) {
            var course;
            angular.forEach(courses, function(c) {
                if (c.id == id) {
                    course = c;
                }
            });
            return course ? course : $q.reject();
        });
    };

    /**
     * Get user courses.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#getUserCourses
     * @param {Boolean} [preferCache=false] True if shouldn't call WS if data is cached, false otherwise.
     * @param {String} [siteid]            Site to get the courses from. If not defined, use current site.
     * @return {Promise}                   Promise to be resolved when the courses are retrieved.
     */
    self.getUserCourses = function(preferCache, siteid) {
        siteid = siteid || $mmSite.getId();
        if (typeof preferCache == 'undefined') {
            preferCache = false;
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {

            var userid = site.getUserId(),
                presets = {
                    cacheKey: getUserCoursesCacheKey(),
                    omitExpires: preferCache
                },
                data = {userid: userid};

            if (typeof userid === 'undefined') {
                return $q.reject();
            }

            return site.read('core_enrol_get_users_courses', data, presets).then(function(courses) {
                if (siteid === $mmSite.getId()) {
                    // Only store courses if we're getting current site courses. This function is deprecated and will be removed.
                    storeCoursesInMemory(courses);
                }
                return courses;
            });
        });
    };

    /**
     * Get cache key for get user courses WS call.
     *
     * @return {String}       Cache key.
     */
    function getUserCoursesCacheKey() {
        return 'mmCourses:usercourses';
    }

    /**
     * Invalidates get course WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateCourse
     * @param  {Number} id Course ID.
     * @return {Promise}   Promise resolved when the data is invalidated.
     */
    self.invalidateCourse = function(id, siteid) {
        return self.invalidateCourses([id], siteid);
    };

    /**
     * Invalidates get course enrolment methods WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateUserCourses
     * @param {Number} id Course ID.
     * @return {Promise}  Promise resolved when the data is invalidated.
     */
    self.invalidateCourseEnrolmentMethods = function(id) {
        return $mmSite.invalidateWsCacheForKey(getCourseEnrolmentMethodsCacheKey(id));
    };

    /**
     * Invalidates get course guest enrolment info WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateUserCourses
     * @param {Number} instanceId Guest instance ID.
     * @return {Promise}          Promise resolved when the data is invalidated.
     */
    self.invalidateCourseGuestEnrolmentInfo = function(instanceId) {
        return $mmSite.invalidateWsCacheForKey(getCourseGuestEnrolmentInfoCacheKey(instanceId));
    };

    /**
     * Invalidates get courses WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateCourses
     * @param  {Number[]} ids   Courses IDs.
     * @param {String} [siteid] Site ID to invalidate. If not defined, use current site.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateCourses = function(ids, siteid) {
        siteid = siteid || $mmSite.getId();
        return $mmSitesManager.getSite(siteid).then(function(site) {
            return site.invalidateWsCacheForKey(getCoursesCacheKey(ids));
        });
    };

    /**
     * Invalidates get user courses WS call.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#invalidateUserCourses
     * @param {String} [siteid] Site ID to invalidate. If not defined, use current site.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateUserCourses = function(siteid) {
        siteid = siteid || $mmSite.getId();
        return $mmSitesManager.getSite(siteid).then(function(site) {
            return site.invalidateWsCacheForKey(getUserCoursesCacheKey());
        });
    };

    /**
     * Check if WS to retrieve guest enrolment data is available.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#isGuestWSAvailable
     * @return {Boolean} True if guest WS is available, false otherwise.
     */
    self.isGuestWSAvailable = function() {
        return $mmSite.wsAvailable('enrol_guest_get_instance_info');
    };

    /**
     * Check if search courses feature is available in the current site.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#isSearchCoursesAvailable
     * @return {Boolean} True if is available, false otherwise.
     */
    self.isSearchCoursesAvailable = function() {
        return $mmSite.wsAvailable('core_course_search_courses');
    };

    /**
     * Check if self enrolment is available.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#isSelfEnrolmentEnabled
     * @return {Boolean} True if self enrolment is available, false otherwise.
     */
    self.isSelfEnrolmentEnabled = function() {
        return $mmSite.wsAvailable('enrol_self_enrol_user');
    };

    /**
     * Search courses.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#search
     * @param {String} text      Text to search.
     * @param {Number} [page]    Page to get. Defaults to 0.
     * @param {Number} [perpage] Number of courses per page. Defaults to mmCoursesSearchPerPage.
     * @return {Promise}         Promise resolved with the courses and the total of matches.
     */
    self.search = function(text, page, perpage) {
        page = page || 0;
        perpage = perpage || mmCoursesSearchPerPage;

        var params = {
                criterianame: 'search',
                criteriavalue: text,
                page: page,
                perpage: perpage
            }, preSets = {
                getFromCache: false
            };

        return $mmSite.read('core_course_search_courses', params, preSets).then(function(response) {
            if (typeof response == 'object') {
                return {total: response.total, courses: response.courses};
            }
            return $q.reject();
        });
    };

    /**
     * Self enrol current user in a certain course.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCourses#selfEnrol
     * @param {String} courseid     Course ID.
     * @param {String} [password]   Password to use.
     * @param {Number} [instanceId] Enrol instance ID.
     * @return {Promise}            Promise resolved if the user is enrolled. If the password is invalid,
     *                              the promise is rejected with an object with code = mmCoursesEnrolInvalidKey.
     */
    self.selfEnrol = function(courseid, password, instanceId) {
        if (typeof password == 'undefined') {
            password = '';
        }

        var params = {
            courseid: courseid,
            password: password
        };
        if (instanceId) {
            params.instanceid = instanceId;
        }

        return $mmSite.write('enrol_self_enrol_user', params).then(function(response) {
            if (response) {
                if (response.status) {
                    return true;
                } else if (response.warnings && response.warnings.length) {
                    var message;
                    angular.forEach(response.warnings, function(warning) {
                        if (warning.warningcode == '2' || warning.warningcode == '4') { // Invalid password warnings.
                            message = warning.message;
                        }
                    });

                    if (message) {
                        return $q.reject({code: mmCoursesEnrolInvalidKey, message: message});
                    }
                }
            }
            return $q.reject();
        });
    };

    /**
     * DEPRECATED: this function will be removed in a future version.
     * Stores a list of courses in memory so they can be retrieved later.
     *
     * @param  {Object[]} courses Courses to store
     * @return {Void}
     * @deprecated since version 2.5
     */
    function storeCoursesInMemory(courses) {
        angular.forEach(courses, function(course) {
            currentCourses[course.id] = angular.copy(course); // Store a copy to prevent unwanted modifications.
        });
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Service to interact with courses.
 *
 * @module mm.core.courses
 * @ngdoc service
 * @name $mmCoursesDelegate
 */
.provider('$mmCoursesDelegate', function() {
    var navHandlers = {},
        self = {};

    /**
     * Register a navigation handler.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCoursesDelegate#registerNavHandler
     * @param {String} addon The addon's name (mmaLabel, mmaForum, ...)
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                                                           When using a promise, it should return a boolean.
     *                             - isEnabledForCourse(courseid, accessData) (Boolean|Promise) Whether or not the handler is
     *                                               enabled on a course level. When using a promise, it should return a boolean.
     *                             - getController(courseid) (Object) Returns the object that will act as controller.
     *                                                                See core/components/courses/templates/list.html
     *                                                                for the list of scope variables expected.
     */
    self.registerNavHandler = function(addon, handler, priority) {
        if (typeof navHandlers[addon] !== 'undefined') {
            console.log("$mmCoursesDelegateProvider: Addon '" + navHandlers[addon].addon + "' already registered as navigation handler");
            return false;
        }
        console.log("$mmCoursesDelegateProvider: Registered addon '" + addon + "' as navigation handler.");
        navHandlers[addon] = {
            addon: addon,
            handler: handler,
            instance: undefined,
            priority: priority
        };
        return true;
    };

    self.$get = ["$mmUtil", "$q", "$log", "$mmSite", "mmCoursesAccessMethods", function($mmUtil, $q, $log, $mmSite, mmCoursesAccessMethods) {
        var enabledNavHandlers = {},
            coursesHandlers = {},
            self = {},
            loaded = {};

        $log = $log.getInstance('$mmCoursesDelegate');

        /**
         * Check if addons are loaded for a certain course.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#areNavHandlersLoadedFor
         * @param {Number} courseId The course ID.
         * @return {Boolean} True if addons are loaded, false otherwise.
         */
        self.areNavHandlersLoadedFor = function(courseId) {
            return loaded[courseId];
        };

        /**
         * Clear all courses handlers.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#clearCoursesHandlers
         * @protected
         */
        self.clearCoursesHandlers = function() {
            coursesHandlers = {};
            loaded = {};
        };

        /**
         * Get the handler for a course using a certain access type.
         *
         * @param {Number} courseId    The course ID.
         * @param {Boolean} refresh    True if it should refresh the list.
         * @param  {Object} accessData Access type and data. Default, guest, ...
         * @return {Array}             Array of objects containing 'priority' and 'controller'.
         */
        function getNavHandlersForAccess(courseId, refresh, accessData) {
            if (refresh || !coursesHandlers[courseId] || coursesHandlers[courseId].access.type != accessData.type) {
                coursesHandlers[courseId] = {
                    access: accessData,
                    handlers: []
                };
                self.updateNavHandlersForCourse(courseId, accessData);
            }
            return coursesHandlers[courseId].handlers;
        }

        /**
         * Get the handlers for a course where the user is enrolled in.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#getNavHandlersFor
         * @param {Number} courseId The course ID.
         * @param {Boolean} refresh True if it should refresh the list.
         * @return {Array}          Array of objects containing 'priority' and 'controller'.
         */
        self.getNavHandlersFor = function(courseId, refresh) {
            // Default access.
            var accessData = {
                type: mmCoursesAccessMethods.default
            };
            return getNavHandlersForAccess(courseId, refresh, accessData);
        };

        /**
         * Get the handlers for a course as guest.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#getNavHandlersForGuest
         * @param {Number} courseId The course ID.
         * @param {Boolean} refresh True if it should refresh the list.
         * @return {Array}          Array of objects containing 'priority' and 'controller'.
         */
        self.getNavHandlersForGuest = function(courseId, refresh) {
            // Guest access.
            var accessData = {
                type: mmCoursesAccessMethods.guest
            };
            return getNavHandlersForAccess(courseId, refresh, accessData);
        };

        /**
         * Update the handler for the current site.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#updateNavHandler
         * @param {String} addon The addon.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateNavHandler = function(addon, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledNavHandlers[addon] = {
                        instance: handlerInfo.instance,
                        priority: handlerInfo.priority
                    };
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledNavHandlers[addon];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#updateNavHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateNavHandlers = function() {
            var promises = [];

            $log.debug('Updating navigation handlers for current site.');

            // Loop over all the content handlers.
            angular.forEach(navHandlers, function(handlerInfo, addon) {
                promises.push(self.updateNavHandler(addon, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            }).finally(function() {
                // Update handlers for all courses.
                angular.forEach(coursesHandlers, function(handler, courseId) {
                    self.updateNavHandlersForCourse(parseInt(courseId), handler.access);
                });
            });
        };

        /**
         * Update the handlers for a certain course.
         *
         * @module mm.core.courses
         * @ngdoc method
         * @name $mmCoursesDelegate#updateNavHandlersForCourse
         * @param {Number} courseId    The course ID.
         * @param  {Object} accessData Access type and data. Default, guest, ...
         * @return {Promise}           Resolved when updated.
         * @protected
         */
        self.updateNavHandlersForCourse = function(courseId, accessData) {
            var promises = [],
                enabledForCourse = [];

            angular.forEach(enabledNavHandlers, function(handler) {
                // Checks if the handler is enabled for the user.
                var promise = $q.when(handler.instance.isEnabledForCourse(courseId, accessData)).then(function(enabled) {
                    if (enabled) {
                        enabledForCourse.push(handler);
                    } else {
                        return $q.reject();
                    }
                }).catch(function() {
                    // Nothing to do here, it is not enabled for this user.
                });
                promises.push(promise);
            });

            return $q.all(promises).then(function() {
                return true;
            }).catch(function() {
                // Never fails.
                return true;
            }).finally(function() {
                // Update the coursesHandlers array with the new enabled addons.
                $mmUtil.emptyArray(coursesHandlers[courseId].handlers);
                angular.forEach(enabledForCourse, function(handler) {
                    coursesHandlers[courseId].handlers.push({
                        controller: handler.instance.getController(courseId),
                        priority: handler.priority
                    });
                });
                loaded[courseId] = true;
            });
        };

        return self;
    }];


    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.courses')

/**
 * Courses handlers factory.
 *
 * @module mm.core.courses
 * @ngdoc service
 * @name $mmCoursesHandlers
 */
.factory('$mmCoursesHandlers', ["$mmSite", "$state", "$mmCourses", "$q", "$mmUtil", "$translate", "$timeout", "$mmContentLinksHelper", "mmCoursesEnrolInvalidKey", function($mmSite, $state, $mmCourses, $q, $mmUtil, $translate, $timeout, $mmContentLinksHelper,
            mmCoursesEnrolInvalidKey) {

    var self = {};

    /**
     * Content links handler.
     *
     * @module mm.core.courses
     * @ngdoc method
     * @name $mmCoursesHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Action to perform when an enrol link is clicked.
         *
         * @param  {Number} courseId Course ID.
         * @param  {String} url      Treated URL.
         * @return {Void}
         */
        function actionEnrol(courseId, url) {
            var modal = $mmUtil.showModalLoading();

            // Check if user is enrolled in the course.
            $mmCourses.getUserCourse(courseId).catch(function() {
                // User is not enrolled in the course. Check if can self enrol.
                return canSelfEnrol(courseId).then(function() {
                    modal.dismiss();
                    return selfEnrol(courseId).catch(function() {
                        if (typeof error == 'string') {
                            $mmUtil.showErrorModal(error);
                        }
                        return $q.reject();
                    });
                }, function(error) {
                    // Error. Show error message and allow the user to open the link in browser.
                    modal.dismiss();
                    if (typeof error != 'string') {
                        error = $translate.instant('mm.courses.notenroled');
                    }

                    var body = $translate('mm.core.twoparagraphs',
                                    {p1: error, p2: $translate.instant('mm.core.confirmopeninbrowser')});
                    $mmUtil.showConfirm(body).then(function() {
                        $mmUtil.openInBrowser(url);
                    });
                    return $q.reject();
                });
            }).then(function() {
                modal.dismiss();
                $state.go('site.mm_course', {courseid: parseInt(courseId)});
            });
        }

        /**
         * Check if a user can be "automatically" self enrolled in a course.
         *
         * @param  {Number} courseId Course ID.
         * @return {Promise}         Promise resolved if user is can be enrolled in a course, rejected otherwise.
         */
        function canSelfEnrol(courseId) {
            // Check if self enrolment is enabled.
            if (!$mmCourses.isSelfEnrolmentEnabled()) {
                return $q.reject();
            }

            // Check that the course has self enrolment enabled.
            return $mmCourses.getCourseEnrolmentMethods(courseId).then(function(methods) {
                var isSelfEnrolEnabled = false,
                    instances = 0;
                angular.forEach(methods, function(method) {
                    if (method.type == 'self' && method.status) {
                        isSelfEnrolEnabled = true;
                        instances++;
                    }
                });

                if (!isSelfEnrolEnabled || instances != 1) {
                    // Self enrol not enabled or more than one instance.
                    return $q.reject();
                }
            });
        }

        /**
         * Try to self enrol a user in a course.
         *
         * @param  {Number} courseId Course ID.
         * @param  {String} password Password.
         * @return {Promise}         Promiser esolved when the user is enrolled, rejected otherwise.
         */
        function selfEnrol(courseId, password) {
            var modal = $mmUtil.showModalLoading();
            return $mmCourses.selfEnrol(courseId, password).then(function() {
                // Success self enrolling the user, invalidate the courses list.
                return $mmCourses.invalidateUserCourses().catch(function() {
                    // Ignore errors.
                }).then(function() {
                    // For some reason, if we get the course list right after self enrolling
                    // we won't retrieve the new course. Let's delay it a bit.
                    return $timeout(function() {}, 4000).finally(function() {
                        modal.dismiss();
                    });
                });

            }).catch(function(error) {
                modal.dismiss();
                if (error && error.code === mmCoursesEnrolInvalidKey) {
                    // Invalid password. Allow the user to input password.
                    var title = $translate.instant('mm.courses.selfenrolment'),
                        body = ' ', // Empty message.
                        placeholder = $translate.instant('mm.courses.password');

                    if (typeof password != 'undefined') {
                        // The user attempted a password. Show an error message.
                        $mmUtil.showErrorModal(error.message);
                    }

                    return $mmUtil.showPrompt(body, title, placeholder).then(function(password) {
                        return selfEnrol(courseId, password);
                    });
                } else {
                    return $q.reject(error);
                }
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        List of actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check if it's a course URL.
            if (url.indexOf('enrol/index.php') > -1 || url.indexOf('course/enrol.php') > -1 ||
                        url.indexOf('course/view.php') > -1) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: siteIds,
                        action: function(siteId) {
                            siteId = siteId || $mmSite.getId();
                            if (siteId == $mmSite.getId()) {
                                actionEnrol(parseInt(params.id, 10), url);
                            } else {
                                $mmContentLinksHelper.goInSite('site.mm_course', {courseid: parseInt(params.id, 10)}, siteId);
                            }
                        }
                    }];
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle input of user credentials.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginCredentialsCtrl
 */
.controller('mmLoginCredentialsCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmUtil", "$ionicHistory", "$mmApp", "$q", "$mmLoginHelper", "$translate", function($scope, $state, $stateParams, $mmSitesManager, $mmUtil, $ionicHistory, $mmApp,
            $q, $mmLoginHelper, $translate) {

    $scope.siteurl = $stateParams.siteurl;
    $scope.credentials = {};

    var siteChecked = false;

    // Function to check if a site uses local_mobile, requires SSO login, etc.
    // This should be used only if a fixed URL is set, otherwise this check is already performed in mmLoginSiteCtrl.
    function checkSite(siteurl) {
        var checkmodal = $mmUtil.showModalLoading();
        return $mmSitesManager.checkSite(siteurl).then(function(result) {

            siteChecked = true;
            $scope.siteurl = result.siteurl;

            if (result && result.warning) {
                $mmUtil.showErrorModal(result.warning, true, 4000);
            }

            if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                // SSO. User needs to authenticate in a browser.
                $scope.isBrowserSSO = true;
                $mmUtil.showConfirm($translate('mm.login.logininsiterequired')).then(function() {
                    $mmLoginHelper.openBrowserForSSOLogin(result.siteurl);
                });
            } else {
                $scope.isBrowserSSO = false;
            }

        }).catch(function(error) {
            $mmUtil.showErrorModal(error);
            return $q.reject();
        }).finally(function() {
            checkmodal.dismiss();
        });
    }

    if ($mmLoginHelper.isFixedUrlSet()) {
        // Fixed URL, we need to check if it uses browser SSO login.
        checkSite($scope.siteurl);
    } else {
        siteChecked = true;
    }

    $scope.login = function() {

        $mmApp.closeKeyboard();

        // Get input data.
        var siteurl = $scope.siteurl,
            username = $scope.credentials.username,
            password = $scope.credentials.password;

        if (!siteChecked) {
            // Site wasn't checked (it failed), let's check again.
            return checkSite(siteurl).then(function() {
                if (!$scope.isBrowserSSO) {
                    // Site doesn't use browser SSO, throw app's login again.
                    return $scope.login();
                }
            });
        } else if ($scope.isBrowserSSO) {
            // A previous check determined that browser SSO is needed. Let's check again, maybe site was updated.
            return checkSite(siteurl);
        }

        if (!username) {
            $mmUtil.showErrorModal('mm.login.usernamerequired', true);
            return;
        }
        if (!password) {
            $mmUtil.showErrorModal('mm.login.passwordrequired', true);
            return;
        }

        var modal = $mmUtil.showModalLoading();

        // Start the authentication process.
        return $mmSitesManager.getUserToken(siteurl, username, password).then(function(data) {
            return $mmSitesManager.newSite(data.siteurl, data.token).then(function() {
                delete $scope.credentials; // Delete username and password from the scope.
                $ionicHistory.nextViewOptions({disableBack: true});
                $state.go('site.mm_courses');
            });
        }).catch(function(error) {
            $mmUtil.showErrorModal(error);
        }).finally(function() {
            modal.dismiss();
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle splash screen and initialize the app (restore session, determine first state, etc.).
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginInitCtrl
 */
.controller('mmLoginInitCtrl', ["$log", "$ionicHistory", "$state", "$mmSitesManager", "$mmSite", "$mmApp", "$mmLoginHelper", function($log, $ionicHistory, $state, $mmSitesManager, $mmSite, $mmApp, $mmLoginHelper) {

    $log = $log.getInstance('mmLoginInitCtrl');

    $mmApp.ready().then(function() {

        // Disable animation and back button for the next transition.
        $ionicHistory.nextViewOptions({
            disableAnimate: true,
            disableBack: true
        });

        if ($mmSite.isLoggedIn()) {
            $state.go('site.mm_courses');
        } else {
            $mmSitesManager.hasSites().then(function() {
                return $state.go('mm_login.sites');
            }, function() {
                return $mmLoginHelper.goToAddSite();
            });
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle input of user credentials.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginReconnectCtrl
 */
.controller('mmLoginReconnectCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmApp", "$mmUtil", "$ionicHistory", function($scope, $state, $stateParams, $mmSitesManager, $mmApp, $mmUtil, $ionicHistory) {

    var infositeurl = $stateParams.infositeurl; // Siteurl in site info. It might be different than siteurl (http/https).
    $scope.siteurl = $stateParams.siteurl;
    $scope.credentials = {
        username: $stateParams.username,
        password: ''
    };

    $scope.cancel = function() {
        $mmSitesManager.logout().finally(function() {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.go('mm_login.sites');
        });
    };

    $scope.login = function() {

        $mmApp.closeKeyboard();

        // Get input data.
        var siteurl = $scope.siteurl,
            username = $scope.credentials.username,
            password = $scope.credentials.password;

        if (!password) {
            $mmUtil.showErrorModal('mm.login.passwordrequired', true);
            return;
        }

        var modal = $mmUtil.showModalLoading();

        // Start the authentication process.
        $mmSitesManager.getUserToken(siteurl, username, password).then(function(data) {
            $mmSitesManager.updateSiteToken(infositeurl, username, data.token).then(function() {
                // Update site info too because functions might have changed (e.g. unisntall local_mobile).
                $mmSitesManager.updateSiteInfoByUrl(infositeurl, username).finally(function() {
                    delete $scope.credentials; // Delete password from the scope.
                    $ionicHistory.nextViewOptions({disableBack: true});
                    $state.go('site.mm_courses');
                });
            }, function(error) {
                // Site deleted? Go back to login page.
                $mmUtil.showErrorModal('mm.login.errorupdatesite', true);
                $scope.cancel();
            }).finally(function() {
                modal.dismiss();
            });
        }, function(error) {
            modal.dismiss();
            $mmUtil.showErrorModal(error);
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle the input of a site URL and its validation.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginSiteCtrl
 */
.controller('mmLoginSiteCtrl', ["$scope", "$state", "$mmSitesManager", "$mmUtil", "$translate", "$ionicHistory", "$mmApp", "$ionicModal", "$mmLoginHelper", function($scope, $state, $mmSitesManager, $mmUtil, $translate, $ionicHistory, $mmApp,
        $ionicModal, $mmLoginHelper) {

    $scope.siteurl = '';
    $scope.isInvalidUrl = true;

    $scope.validate = function(url) {
        if (!url) {
            $scope.isInvalidUrl = true;
            return;
        }

        if ($mmSitesManager.getDemoSiteData(url)) {
            // Is demo site.
            $scope.isInvalidUrl = false;
        } else {
            // formatURL adds the protocol if is missing.
            var formattedurl = $mmUtil.formatURL(url);
            $scope.isInvalidUrl = formattedurl.indexOf('://localhost') == -1 && !$mmUtil.isValidURL(formattedurl);
        }
    };

    $scope.connect = function(url) {

        $mmApp.closeKeyboard();

        if (!url) {
            $mmUtil.showErrorModal('mm.login.siteurlrequired', true);
            return;
        }

        var modal = $mmUtil.showModalLoading(),
            sitedata = $mmSitesManager.getDemoSiteData(url);

        if (sitedata) {
            // It's a demo site.
            $mmSitesManager.getUserToken(sitedata.url, sitedata.username, sitedata.password).then(function(data) {
                $mmSitesManager.newSite(data.siteurl, data.token).then(function() {
                    $ionicHistory.nextViewOptions({disableBack: true});
                    $state.go('site.mm_courses');
                }, function(error) {
                    $mmUtil.showErrorModal(error);
                }).finally(function() {
                    modal.dismiss();
                });
            }, function(error) {
                modal.dismiss();
                $mmUtil.showErrorModal(error);
            });

        } else {
            // Not a demo site.
            $mmSitesManager.checkSite(url).then(function(result) {

                if (result.warning) {
                    $mmUtil.showErrorModal(result.warning, true, 4000);
                }

                if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                    // SSO. User needs to authenticate in a browser.
                    $mmUtil.showConfirm($translate('mm.login.logininsiterequired')).then(function() {
                        $mmLoginHelper.openBrowserForSSOLogin(result.siteurl);
                    });
                } else {
                    $state.go('mm_login.credentials', {siteurl: result.siteurl});
                }

            }, function(error) {
                $mmUtil.showErrorModal(error);
            }).finally(function() {
                modal.dismiss();
            });
        }
    };

    // Get docs URL for help modal.
    $mmUtil.getDocsUrl().then(function(docsurl) {
        $scope.docsurl = docsurl;
    });

    // Setup help modal.
    $ionicModal.fromTemplateUrl('core/components/login/templates/help-modal.html', {
        scope: $scope,
        animation: 'slide-in-up'
    }).then(function(helpModal) {
        $scope.showHelp = function() {
            helpModal.show();
        };
        $scope.closeHelp = function() {
            helpModal.hide();
        };
        $scope.$on('$destroy', function() {
            helpModal.remove();
        });
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

/**
 * Controller to handle the list of sites.
 *
 * @module mm.core.login
 * @ngdoc controller
 * @name mmLoginSitesCtrl
 */
.controller('mmLoginSitesCtrl', ["$scope", "$state", "$mmSitesManager", "$log", "$translate", "$mmUtil", "$ionicHistory", "$mmText", "$mmLoginHelper", function($scope, $state, $mmSitesManager, $log, $translate, $mmUtil, $ionicHistory, $mmText,
            $mmLoginHelper) {

    $log = $log.getInstance('mmLoginSitesCtrl');

    $mmSitesManager.getSites().then(function(sites) {
        $scope.sites = sites;
        $scope.data = {
            hasSites: sites.length > 0,
            showDelete: false
        };
    });

    $scope.toggleDelete = function() {
        $scope.data.showDelete = !$scope.data.showDelete;
    };

    $scope.onItemDelete = function(e, index) {
        // Prevent login() from being triggered. No idea why I cannot replicate this
        // problem on http://codepen.io/ionic/pen/JsHjf.
        e.stopPropagation();

        var site = $scope.sites[index],
            sitename = site.sitename;

        $mmText.formatText(sitename).then(function(sitename) {
            $mmUtil.showConfirm($translate('mm.login.confirmdeletesite', {sitename: sitename})).then(function() {
                $mmSitesManager.deleteSite(site.id).then(function() {
                    $scope.sites.splice(index, 1);
                    $mmSitesManager.hasNoSites().then(function() {
                        // No sites left, go to add a new site state.
                        $ionicHistory.nextViewOptions({disableBack: true});
                        $mmLoginHelper.goToAddSite();
                    });
                }, function() {
                    $log.error('Delete site failed');
                    $mmUtil.showErrorModal('mm.login.errordeletesite', true);
                });
            });
        });
    };

    $scope.login = function(siteid) {
        var modal = $mmUtil.showModalLoading();

        $mmSitesManager.loadSite(siteid).then(function() {
            $ionicHistory.nextViewOptions({disableBack: true});
            $state.go('site.mm_courses');
        }, function(error) {
            $log.error('Error loading site '+siteid);
            error = error || 'Error loading site.';
            $mmUtil.showErrorModal(error);
        }).finally(function() {
            modal.dismiss();
        });
    };

    $scope.add = function() {
        $mmLoginHelper.goToAddSite();
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.login')

.constant('mmLoginSSOCode', 2) // This code is returned by local_mobile Moodle plugin if SSO in browser is required.
.constant('mmLoginLaunchSiteURL', 'mmLoginLaunchSiteURL')
.constant('mmLoginLaunchPassport', 'mmLoginLaunchPassport')

/**
 * Service to provide some helper functionalities for the login component.
 *
 * @module mm.core.login
 * @ngdoc service
 * @name $mmLoginHelper
 */
.factory('$mmLoginHelper', ["$q", "$log", "$mmConfig", "mmLoginSSOCode", "mmLoginLaunchSiteURL", "mmLoginLaunchPassport", "md5", "$mmSite", "$mmSitesManager", "$mmLang", "$mmUtil", "$state", "mmCoreConfigConstants", function($q, $log, $mmConfig, mmLoginSSOCode, mmLoginLaunchSiteURL, mmLoginLaunchPassport,
            md5, $mmSite, $mmSitesManager, $mmLang, $mmUtil, $state, mmCoreConfigConstants) {

    $log = $log.getInstance('$mmLoginHelper');

    var self = {};

    /**
     * Go to the view to add a new site.
     * If a fixed URL is configured, go to credentials instead.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#goToAddSite
     * @return {Promise} Promise resolved when the state changes.
     */
    self.goToAddSite = function() {
        if (mmCoreConfigConstants.siteurl) {
            // Fixed URL is set, go to credentials page.
            return $state.go('mm_login.credentials', {siteurl: mmCoreConfigConstants.siteurl});
        } else {
            return $state.go('mm_login.site');
        }
    };

    /**
     * Check if the app is configured to use a fixed URL.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#isFixedUrlSet
     * @return {Boolean} True if set, false otherwise.
     */
    self.isFixedUrlSet = function() {
        return typeof mmCoreConfigConstants.siteurl != 'undefined';
    };

    /**
     * Check if SSO login is needed based on code returned by the WS.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#isSSOLoginNeeded
     * @param  {Number}  code Code to check.
     * @return {Boolean}      True if SSO login is needed, false othwerise.
     */
    self.isSSOLoginNeeded = function(code) {
        return code == mmLoginSSOCode;
    };

    /**
     * Open a browser to perform SSO login.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#openBrowserForSSOLogin
     * @param {String} siteurl URL of the site where the SSO login will be performed.
     */
    self.openBrowserForSSOLogin = function(siteurl) {
        var passport = Math.random() * 1000;
        var loginurl = siteurl + "/local/mobile/launch.php?service=" + mmCoreConfigConstants.wsextservice;
        loginurl += "&passport=" + passport;

        // Store the siteurl and passport in $mmConfig for persistence. We are "configuring"
        // the app to wait for an SSO. $mmConfig shouldn't be used as a temporary storage.
        $mmConfig.set(mmLoginLaunchSiteURL, siteurl);
        $mmConfig.set(mmLoginLaunchPassport, passport);

        $mmUtil.openInBrowser(loginurl);
        if (navigator.app) {
            navigator.app.exitApp();
        }
    };

    /**
     * Convenient helper to validate a browser SSO login.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#validateBrowserSSOLogin
     * @param {String} url URL received, to be validated.
     * @return {Promise}   The success contains the signature and token. The reject contains the error message.
     */
    self.validateBrowserSSOLogin = function(url) {
        // Split signature:::token
        var params = url.split(":::");

        return $mmConfig.get(mmLoginLaunchSiteURL).then(function(launchSiteURL) {
            return $mmConfig.get(mmLoginLaunchPassport).then(function(passport) {

                // Reset temporary values.
                $mmConfig.delete(mmLoginLaunchSiteURL);
                $mmConfig.delete(mmLoginLaunchPassport);

                // Validate the signature.
                // We need to check both http and https.
                var signature = md5.createHash(launchSiteURL + passport);
                if (signature != params[0]) {
                    if (launchSiteURL.indexOf("https://") != -1) {
                        launchSiteURL = launchSiteURL.replace("https://", "http://");
                    } else {
                        launchSiteURL = launchSiteURL.replace("http://", "https://");
                    }
                    signature = md5.createHash(launchSiteURL + passport);
                }

                if (signature == params[0]) {
                    $log.debug('Signature validated');
                    return { siteurl: launchSiteURL, token: params[1] };
                } else {
                    $log.debug('Inalid signature in the URL request yours: ' + params[0] + ' mine: '
                                    + signature + ' for passport ' + passport);
                    return $mmLang.translateAndReject('mm.core.unexpectederror');
                }

            });
        });
    };

    /**
     * Convenient helper to handle authentication in the app using a token received by SSO login. If it's a new account,
     * the site is stored and the user is authenticated. If the account already exists, update its token.
     *
     * @module mm.core.login
     * @ngdoc method
     * @name $mmLoginHelper#handleSSOLoginAuthentication
     * @param {String} siteurl Site's URL.
     * @param {String} token   User's token.
     * @return {Promise}       Promise resolved when the user is authenticated with the token. Reject returns an error message.
     */
    self.handleSSOLoginAuthentication = function(siteurl, token) {
        if ($mmSite.isLoggedIn()) {
            // User logged in, he is reconnecting.
            var deferred = $q.defer();

            // Retrieve username.
            var info = $mmSite.getInfo();
            if (typeof(info) !== 'undefined' && typeof(info.username) !== 'undefined') {
                $mmSitesManager.updateSiteToken(info.siteurl, info.username, token).then(function() {
                    $mmSitesManager.updateSiteInfoByUrl(info.siteurl, info.username).finally(deferred.resolve);
                }, function() {
                    // Error updating token, return proper error message.
                    $mmLang.translateAndRejectDeferred(deferred, 'mm.login.errorupdatesite');
                });
            } else {
                $mmLang.translateAndRejectDeferred(deferred, 'mm.login.errorupdatesite');
            }
            return deferred.promise;
        } else {
            return $mmSitesManager.newSite(siteurl, token);
        }
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'About' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsAboutCtrl
 */
.controller('mmSettingsAboutCtrl', ["$scope", "$translate", "$window", "$mmApp", "$ionicPlatform", "$mmLang", "$mmFS", "$mmLocalNotifications", "mmCoreConfigConstants", function($scope, $translate, $window, $mmApp, $ionicPlatform, $mmLang, $mmFS,
            $mmLocalNotifications, mmCoreConfigConstants) {

    $scope.versionname = mmCoreConfigConstants.versionname;
    $translate('mm.settings.appname', {version: $scope.versionname}).then(function(appName) {
        $scope.appname = appName;
    });

    $scope.versioncode = mmCoreConfigConstants.versioncode;

    $scope.navigator = $window.navigator;
    if ($window.location && $window.location.href) {
        var url = $window.location.href;
        $scope.locationhref = url.substr(0, url.indexOf('#/site/'));
    }

    $scope.appready = $mmApp.isReady() ? 'mm.core.yes' : 'mm.core.no';
    $scope.devicetype = $ionicPlatform.isTablet() ? 'mm.core.tablet' : 'mm.core.phone';

    if (ionic.Platform.isAndroid()) {
        $scope.deviceos = 'mm.core.android';
    } else if (ionic.Platform.isIOS()) {
        $scope.deviceos = 'mm.core.ios';
    } else if (ionic.Platform.isWindowsPhone()) {
        $scope.deviceos = 'mm.core.windowsphone';
    } else {
        var matches = navigator.userAgent.match(/\(([^\)]*)\)/);
        if (matches && matches.length > 1) {
            $scope.deviceos = matches[1];
        } else {
            $scope.deviceos = 'mm.core.unknown';
        }
    }

    $mmLang.getCurrentLanguage().then(function(lang) {
        $scope.currentlanguage = lang;
    });

    $scope.networkstatus = $mmApp.isOnline() ? 'mm.core.online' : 'mm.core.offline';
    $scope.wificonnection = $mmApp.isNetworkAccessLimited() ? 'mm.core.no' : 'mm.core.yes';
    $scope.devicewebworkers = !!window.Worker && !!window.URL ? 'mm.core.yes' : 'mm.core.no';
    $scope.device = ionic.Platform.device();

    if ($mmFS.isAvailable()) {
        $mmFS.getBasePath().then(function(basepath) {
            $scope.filesystemroot = basepath;
            $scope.fsclickable = $mmFS.usesHTMLAPI();
        });
    }

    $scope.storagetype = $mmApp.getDB().getType();
    $scope.localnotifavailable = $mmLocalNotifications.isAvailable() ? 'mm.core.yes' : 'mm.core.no';
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'General' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsGeneralCtrl
 */
.controller('mmSettingsGeneralCtrl', ["$scope", "$mmLang", "$ionicHistory", "$mmEvents", "$mmConfig", "mmCoreEventLanguageChanged", "mmCoreSettingsReportInBackground", "mmCoreConfigConstants", "mmCoreSettingsDownloadSection", function($scope, $mmLang, $ionicHistory, $mmEvents, $mmConfig, mmCoreEventLanguageChanged,
            mmCoreSettingsReportInBackground, mmCoreConfigConstants, mmCoreSettingsDownloadSection) {

    $scope.langs = mmCoreConfigConstants.languages;

    $mmLang.getCurrentLanguage().then(function(currentLanguage) {
        $scope.selectedLanguage = currentLanguage;
    });

    $scope.languageChanged = function(newLang) {
        $mmLang.changeCurrentLanguage(newLang).finally(function() {
            // Clear cached views.
            $ionicHistory.clearCache();
            $mmEvents.trigger(mmCoreEventLanguageChanged);
        });
    };

    $mmConfig.get(mmCoreSettingsDownloadSection, true).then(function(downloadSectionEnabled) {
        $scope.downloadSection = downloadSectionEnabled;
    });

    $scope.downloadSectionChanged = function(downloadSection) {
        $mmConfig.set(mmCoreSettingsDownloadSection, downloadSection);
    };

    if (localStorage && localStorage.getItem && localStorage.setItem) {
        $scope.showReport = true;
        $scope.reportInBackground = parseInt(localStorage.getItem(mmCoreSettingsReportInBackground), 10) === 1;

        $scope.reportChanged = function(inBackground) {
            localStorage.setItem(mmCoreSettingsReportInBackground, inBackground ? '1' : '0');
        };
    } else {
        $scope.showReport = false;
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'Space Usage' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsSpaceUsageCtrl
 * @todo When "mock site" is implemented we should have functions to calculate the site usage and delete its files.
 */
.controller('mmSettingsSpaceUsageCtrl', ["$log", "$scope", "$mmSitesManager", "$mmFS", "$q", "$mmUtil", "$translate", "$mmText", "$mmFilepool", function($log, $scope, $mmSitesManager, $mmFS, $q, $mmUtil, $translate,
            $mmText, $mmFilepool) {
    $log = $log.getInstance('mmSettingsSpaceUsageCtrl');

    // Convenience function to calculate each site's usage, and the total usage.
    function calculateSizeUsage() {
        return $mmSitesManager.getSites().then(function(sites) {
            var promises = [];
            $scope.sites = sites;

            angular.forEach(sites, function(siteEntry) {
                var promise = $mmSitesManager.getSite(siteEntry.id).then(function(site) {
                    return site.getSpaceUsage().then(function(size) {
                        siteEntry.spaceusage = size;
                    });
                });
                promises.push(promise);
            });

            return $q.all(promises);
        });
    }

    // Convenience function to calculate total usage.
    function calculateTotalUsage() {
        var total = 0;
        angular.forEach($scope.sites, function(site) {
            if (site.spaceusage) {
                total += parseInt(site.spaceusage, 10);
            }
        });
        $scope.totalusage = total;
    }

    // Convenience function to calculate free space in the device.
    function calculateFreeSpace() {
        if ($mmFS.isAvailable()) {
            return $mmFS.calculateFreeSpace().then(function(freespace) {
                $scope.freespace = freespace;
            }, function() {
                $scope.freespace = 0;
            });
        } else {
            $scope.freespace = 0;
        }
    }

    function fetchData() {
        var promises = [];
        promises.push(calculateSizeUsage().then(calculateTotalUsage));
        promises.push($q.when(calculateFreeSpace()));
        return $q.all(promises);
    }
    fetchData().finally(function() {
        $scope.sizeLoaded = true;
    });

    // Pull to refresh.
    $scope.refresh = function() {
        fetchData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Convenience function to update site size, along with total usage and free space.
    function updateSiteUsage(site, newUsage) {
        var oldUsage = site.spaceusage;
        site.spaceusage = newUsage;
        $scope.totalusage -= oldUsage - newUsage;
        $scope.freespace += oldUsage - newUsage;
    }

    $scope.deleteSiteFiles = function(siteData) {
        if (siteData) {
            var siteid = siteData.id,
                sitename = siteData.sitename;

            $mmText.formatText(sitename).then(function(sitename) {
                $translate('mm.settings.deletesitefilestitle').then(function(title) {
                    return $mmUtil.showConfirm($translate('mm.settings.deletesitefiles', {sitename: sitename}), title);
                }).then(function() {
                    return $mmSitesManager.getSite(siteid);
                }).then(function(site) {
                    return site.deleteFolder().then(function() {
                        $mmFilepool.clearAllPackagesStatus(siteid);
                        $mmFilepool.clearFilepool(siteid);
                        updateSiteUsage(siteData, 0);
                    }).catch(function(error) {
                        if (error && error.code === FileError.NOT_FOUND_ERR) {
                            // Not found, set size 0.
                            $mmFilepool.clearAllPackagesStatus(siteid);
                            updateSiteUsage(siteData, 0);
                        } else {
                            // Error, recalculate the site usage.
                            $mmUtil.showErrorModal('mm.settings.errordeletesitefiles', true);
                            site.getSpaceUsage().then(function(size) {
                                updateSiteUsage(siteData, size);
                            });
                        }
                    });
                });
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.settings')

/**
 * Controller to handle the app 'Synchronization' section in settings.
 *
 * @module mm.core.settings
 * @ngdoc controller
 * @name mmSettingsSynchronizationCtrl
 */
.controller('mmSettingsSynchronizationCtrl', ["$log", "$scope", "$mmSitesManager", "$mmUtil", "$mmFilepool", "$mmEvents", "$mmLang", "$mmConfig", "mmCoreEventSessionExpired", "mmCoreSettingsSyncOnlyOnWifi", function($log, $scope, $mmSitesManager, $mmUtil, $mmFilepool, $mmEvents,
            $mmLang, $mmConfig, mmCoreEventSessionExpired, mmCoreSettingsSyncOnlyOnWifi) {
    $log = $log.getInstance('mmSettingsSynchronizationCtrl');

    $mmSitesManager.getSites().then(function(sites) {
        $scope.sites = sites;
    });

    $mmConfig.get(mmCoreSettingsSyncOnlyOnWifi, true).then(function(syncOnlyOnWifi) {
        $scope.syncOnlyOnWifi = syncOnlyOnWifi;
    });

    $scope.syncWifiChanged = function(syncOnlyOnWifi) {
        $mmConfig.set(mmCoreSettingsSyncOnlyOnWifi, syncOnlyOnWifi);
    };

    $scope.synchronize = function(siteData) {
        if (siteData) {
            var siteid = siteData.id,
                modal = $mmUtil.showModalLoading('mm.settings.synchronizing', true);
            $mmFilepool.invalidateAllFiles(siteid).finally(function() {
                $mmSitesManager.getSite(siteid).then(function(site) {
                    return site.invalidateWsCache().then(function() {
                        // Check if local_mobile was installed to Moodle.
                        return site.checkIfLocalMobileInstalledAndNotUsed().then(function() {
                            // Local mobile was added. Throw invalid session to force reconnect and create a new token.
                            $mmEvents.trigger(mmCoreEventSessionExpired, siteid);
                            return $mmLang.translateAndReject('mm.core.lostconnection');
                        }, function() {
                            // Update site info.
                            return $mmSitesManager.updateSiteInfo(siteid);
                        });
                    }).then(function() {
                        siteData.fullname = site.getInfo().fullname;
                        siteData.sitename = site.getInfo().sitename;
                        $mmUtil.showModal('mm.core.success', 'mm.settings.syncsitesuccess');
                    });
                }).catch(function(error) {
                    if (error) {
                        $mmUtil.showErrorModal(error);
                    } else {
                        $mmUtil.showErrorModal('mm.settings.errorsyncsite', true);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.sidemenu')

/**
 * Controller to handle the side menu.
 *
 * @module mm.core.sidemenu
 * @ngdoc controller
 * @name mmSideMenuCtrl
 */
.controller('mmSideMenuCtrl', ["$scope", "$state", "$mmSideMenuDelegate", "$mmSitesManager", "$mmSite", "$mmEvents", "$timeout", "mmCoreEventLanguageChanged", "mmCoreEventSiteUpdated", function($scope, $state, $mmSideMenuDelegate, $mmSitesManager, $mmSite, $mmEvents,
            $timeout, mmCoreEventLanguageChanged, mmCoreEventSiteUpdated) {

    $scope.handlers = $mmSideMenuDelegate.getNavHandlers();
    $scope.areNavHandlersLoaded = $mmSideMenuDelegate.areNavHandlersLoaded;
    $scope.siteinfo = $mmSite.getInfo();

    $scope.logout = function() {
        $mmSitesManager.logout().finally(function() {
            $state.go('mm_login.sites');
        });
    };

    $mmSite.getDocsUrl().then(function(docsurl) {
        $scope.docsurl = docsurl;
    });

    function updateSiteInfo() {
        // We need to use $timeout to force a $digest and make $watch notice the variable change.
        $scope.siteinfo = undefined;
        $timeout(function() {
            $scope.siteinfo = $mmSite.getInfo();

            // Update docs URL, maybe the Moodle release has changed.
            $mmSite.getDocsUrl().then(function(docsurl) {
                $scope.docsurl = docsurl;
            });
        });
    }

    var langObserver = $mmEvents.on(mmCoreEventLanguageChanged, updateSiteInfo);
    var updateSiteObserver = $mmEvents.on(mmCoreEventSiteUpdated, function(siteid) {
        if ($mmSite.getId() === siteid) {
            updateSiteInfo();
        }
    });

    $scope.$on('$destroy', function() {
        if (langObserver && langObserver.off) {
            langObserver.off();
        }
        if (updateSiteObserver && updateSiteObserver.off) {
            updateSiteObserver.off();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.sidemenu')

/**
 * Service to interact with plugins to be shown in the side menu. Provides functions to register a plugin
 * and notify an update in the data.
 *
 * @module mm.core.sidemenu
 * @ngdoc provider
 * @name $mmSideMenuDelegate
 */
.provider('$mmSideMenuDelegate', function() {
    var navHandlers = {},
        self = {};

    /**
     * Register a navigation handler.
     *
     * @module mm.core.sidemenu
     * @ngdoc method
     * @name $mmSideMenuDelegateProvider#registerNavHandler
     * @param {String} addon The addon's name (mmaFiles, mmaMessages, ...)
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                           returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                                                           When using a promise, it should return a boolean.
     *                             - getController (Object) Returns the object that will act as controller.
     *                                                                See core/components/sidemenu/templates/menu.html
     *                                                                for the list of scope variables expected.
     */
    self.registerNavHandler = function(addon, handler, priority) {
        if (typeof navHandlers[addon] !== 'undefined') {
            console.log("$mmSideMenuDelegateProvider: Addon '" + navHandlers[addon].addon + "' already registered as navigation handler");
            return false;
        }
        console.log("$mmSideMenuDelegateProvider: Registered addon '" + addon + "' as navigation handler.");
        navHandlers[addon] = {
            addon: addon,
            handler: handler,
            instance: undefined,
            priority: priority
        };
        return true;
    };

    self.$get = ["$mmUtil", "$q", "$log", "$mmSite", function($mmUtil, $q, $log, $mmSite) {
        var enabledNavHandlers = {},
            currentSiteHandlers = [], // Handlers to return.
            self = {},
            loaded = false; // If site handlers have been loaded.

        $log = $log.getInstance('$mmSideMenuDelegate');

        /**
         * Check if addons are loaded.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#areNavHandlersLoaded
         * @return {Boolean} True if addons are loaded, false otherwise.
         */
        self.areNavHandlersLoaded = function() {
            return loaded;
        };

        /**
         * Clear current site nav handlers. Reserved for core use.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#clearSiteHandlers
         * @return {Void}
         */
        self.clearSiteHandlers = function() {
            loaded = false;
            $mmUtil.emptyArray(currentSiteHandlers);
        };

        /**
         * Get the handlers for the current site.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#getNavHandlers
         * @return {Promise} Resolved with an array of objects containing 'priority' and 'controller'.
         */
        self.getNavHandlers = function() {
            return currentSiteHandlers;
        };

        /**
         * Update the handler for the current site.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#updateNavHandler
         * @param {String} addon The addon.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateNavHandler = function(addon, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledNavHandlers[addon] = {
                        instance: handlerInfo.instance,
                        priority: handlerInfo.priority
                    };
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledNavHandlers[addon];
            });
        };

        /**
         * Update the handlers for the current site.
         *
         * @module mm.core.sidemenu
         * @ngdoc method
         * @name $mmSideMenuDelegate#updateNavHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateNavHandlers = function() {
            var promises = [];

            $log.debug('Updating navigation handlers for current site.');

            // Loop over all the content handlers.
            angular.forEach(navHandlers, function(handlerInfo, addon) {
                promises.push(self.updateNavHandler(addon, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            }).finally(function() {

                $mmUtil.emptyArray(currentSiteHandlers);

                angular.forEach(enabledNavHandlers, function(handler) {
                    currentSiteHandlers.push({
                        controller: handler.instance.getController(),
                        priority: handler.priority
                    });
                });

                loaded = true;
            });
        };

        return self;
    }];

    return self;

});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.textviewer')

/**
 * Text viewer  controller.
 *
 * @module mm.core.textviewer
 * @ngdoc controller
 * @name mmTextViewerIndexCtrl
 */
.controller('mmTextViewerIndexCtrl', ["$stateParams", "$scope", function($stateParams, $scope) {
    $scope.title = $stateParams.title;
    $scope.content = $stateParams.content;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

/**
 * Controller to handle a user profile page.
 *
 * @module mm.core.user
 * @ngdoc controller
 * @name mmaParticipantsProfileCtrl
 */
.controller('mmUserProfileCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmUser", "$mmUserDelegate", "$mmSite", "$q", "$translate", function($scope, $stateParams, $mmUtil, $mmUser, $mmUserDelegate, $mmSite, $q, $translate) {

    var courseid = $stateParams.courseid,
        userid   = $stateParams.userid;

    $scope.isAndroid = ionic.Platform.isAndroid();
    $scope.plugins = [];

    function fetchUserData() {
        return $mmUser.getProfile(userid, courseid).then(function(user) {

            user.address = $mmUser.formatAddress(user.address, user.city, user.country);
            if (user.address) {
                user.encodedAddress = encodeURIComponent(user.address);
            }

            $mmUser.formatRoleList(user.roles).then(function(roles) {
                user.roles = roles;
            });

            $scope.user = user;
            $scope.title = user.fullname;
            $scope.hasContact = user.email || user.phone1 || user.phone2 || user.city || user.country || user.address;
            $scope.hasDetails = user.url || user.roles || user.interests;

            $scope.isLoadingHandlers = true;
            $mmUserDelegate.getProfileHandlersFor(user, courseid).then(function(handlers) {
                $scope.profileHandlers = handlers;
            }).finally(function() {
                $scope.isLoadingHandlers = false;
            });
        }, function(message) {
            $scope.user = false;
            if (message) {
                $mmUtil.showErrorMessage(message);
            }
            return $q.reject();
        });
    }

    fetchUserData().then(function() {
        // Add log in Moodle.
        return $mmSite.write('core_user_view_user_profile', {
            userid: userid,
            courseid: courseid
        }).catch(function(error) {
            $scope.isDeleted = error === $translate.instant('mm.core.userdeleted');
        });
    }).finally(function() {
        $scope.userLoaded = true;
    });

    $scope.refreshUser = function() {
        $mmUser.invalidateUserCache(userid).finally(function() {
            fetchUserData().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core')

/**
 * Directive to go to user profile on click.
 *
 * @module mm.core
 * @ngdoc provider
 * @name mmUserLink
 */
.directive('mmUserLink', ["$state", "mmUserProfileState", function($state, mmUserProfileState) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                $state.go(mmUserProfileState, {courseid: attrs.courseid, userid: attrs.userid});
            });
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

/**
 * Service to interact with plugins to be shown in user profile. Provides functions to register a plugin
 * and notify an update in the data.
 *
 * @module mm.core.user
 * @ngdoc provider
 * @name $mmUserDelegate
 */
.provider('$mmUserDelegate', function() {
    var profileHandlers = {},
        self = {};

    /**
     * Register a profile handler.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUserDelegateProvider#registerProfileHandler
     * @param {String} component The addon's name, or addon and sub context (mmaMessages, mmaMessage:blockContact, ...)
     * @param {String|Object|Function} handler Must be resolved to an object defining the following functions. Or to a function
     *                          returning an object defining these functions. See {@link $mmUtil#resolveObject}.
     *                             - isEnabled (Boolean|Promise) Whether or not the handler is enabled on a site level.
     *                                                           When using a promise, it should return a boolean.
     *                             - isEnabledForUser (Boolean|Promise) Whether or not the handler is enabled for a user.
     *                                                                  When using a promise, it should return a boolean.
     *                             - getController(userid) (Function) Returns the function that will act as controller.
     *                                                                See core/components/user/templates/profile.html
     *                                                                for the list of scope variables expected.
     *                           The string can either be 'factoryName' or 'factoryName.functionToCall'.
     * @param {Number} [priority=100] Plugin priority.
     */
    self.registerProfileHandler = function(component, handler, priority) {
        if (typeof profileHandlers[component] !== 'undefined') {
            console.log("$mmUserDelegateProvider: Handler '" + profileHandlers[component].component + "' already registered as profile handler");
            return false;
        }
        console.log("$mmUserDelegateProvider: Registered component '" + component + "' as profile handler.");
        profileHandlers[component] = {
            component: component,
            handler: handler,
            instance: undefined,
            priority: typeof priority === 'undefined' ? 100 : priority
        };
        return true;
    };

    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", function($q, $log, $mmSite, $mmUtil) {
        var enabledProfileHandlers = {},
            self = {};

        $log = $log.getInstance('$mmUserDelegate');

        /**
         * Get the profile handlers for a user.
         *
         * @module mm.core.user
         * @ngdoc method
         * @name $mmUserDelegate#getProfileHandlersFor
         * @param {Object} user The user object.
         * @param {Number} courseId The course ID.
         * @return {Promise} Resolved with an array of objects containing 'priority' and 'controller'.
         */
        self.getProfileHandlersFor = function(user, courseId) {
            var handlers = [],
                promises = [];

            angular.forEach(enabledProfileHandlers, function(handler) {
                // Checks if the handler is enabled for the user.
                var promise = $q.when(handler.instance.isEnabledForUser(user, courseId)).then(function(enabled) {
                    if (enabled) {
                        handlers.push({
                            controller: handler.instance.getController(user, courseId),
                            priority: handler.priority
                        });
                    } else {
                        return $q.reject();
                    }
                }).catch(function() {
                    // Nothing to do here, it is not enabled for this user.
                });
                promises.push(promise);
            });

            return $q.all(promises).then(function() {
                return handlers;
            }).catch(function() {
                // Never fails.
                return handlers;
            });
        };

        /**
         * Update the enabled profile handlers for the current site.
         *
         * @module mm.core.user
         * @ngdoc method
         * @name $mmUserDelegate#updateProfileHandler
         * @param {String} component The component name.
         * @param {Object} handlerInfo The handler details.
         * @return {Promise} Resolved when enabled, rejected when not.
         * @protected
         */
        self.updateProfileHandler = function(component, handlerInfo) {
            var promise;

            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }

            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }

            // Checks if the content is enabled.
            return promise.then(function(enabled) {
                if (enabled) {
                    enabledProfileHandlers[component] = {
                        instance: handlerInfo.instance,
                        priority: handlerInfo.priority
                    };
                } else {
                    return $q.reject();
                }
            }).catch(function() {
                delete enabledProfileHandlers[component];
            });
        };

        /**
         * Update the profile handlers for the current site.
         *
         * @module mm.core.user
         * @ngdoc method
         * @name $mmUserDelegate#updateProfileHandlers
         * @return {Promise} Resolved when done.
         * @protected
         */
        self.updateProfileHandlers = function() {
            var promises = [];

            $log.debug('Updating profile handlers for current site.');

            // Loop over all the profile handlers.
            angular.forEach(profileHandlers, function(handlerInfo, component) {
                promises.push(self.updateProfileHandler(component, handlerInfo));
            });

            return $q.all(promises).then(function() {
                return true;
            }, function() {
                // Never reject.
                return true;
            });
        };

        return self;

    }];

    return self;
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

/**
 * User handlers factory.
 *
 * @module mm.core.user
 * @ngdoc service
 * @name $mmUserHandlers
 */
.factory('$mmUserHandlers', ["$mmUtil", "$mmContentLinksHelper", function($mmUtil, $mmContentLinksHelper) {

    var self = {};

    /**
     * Content links handler.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUserHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        List of actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a user URL.
            if (url.indexOf('grade/report/user') == -1 &&
                    (url.indexOf('/user/view.php') > -1 || url.indexOf('/user/profile.php') > -1)) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: siteIds,
                        action: function(siteId) {
                            var stateParams = {
                                courseid: params.course,
                                userid: parseInt(params.id, 10)
                            };
                            $mmContentLinksHelper.goInSite('site.mm_user-profile', stateParams, siteId);
                        }
                    }];
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.user')

.constant('mmCoreUsersStore', 'users')

.config(["$mmSitesFactoryProvider", "mmCoreUsersStore", function($mmSitesFactoryProvider, mmCoreUsersStore) {
    var stores = [
        {
            name: mmCoreUsersStore,
            keyPath: 'id'
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Service to provide user functionalities.
 *
 * @module mm.core.user
 * @ngdoc service
 * @name $mmUser
 */
.factory('$mmUser', ["$log", "$q", "$mmSite", "$mmUtil", "$translate", "mmCoreUsersStore", function($log, $q, $mmSite, $mmUtil, $translate, mmCoreUsersStore) {

    $log = $log.getInstance('$mmUser');

    var self = {};

    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @param  {Number} id User ID.
     * @return {Promise}   Promise resolve when the user is deleted.
     */
    self.deleteStoredUser = function(id) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }

        self.invalidateUserCache(id); // Invalidate WS calls.
        return $mmSite.getDb().remove(mmCoreUsersStore, parseInt(id));
    };

    /**
     * Formats a user address, concatenating address, city and country.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#formatAddress
     * @param  {String} address Address.
     * @param  {String} city    City..
     * @param  {String} country Country.
     * @return {String}         Formatted address.
     */
    self.formatAddress = function(address, city, country) {
        if (address) {
            address += city ? ', ' + city : '';
            address += country ? ', ' + country : '';
        }
        return address;
    };

    /**
     * Formats a user role list, translating and concatenating them.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#formatRoleList
     * @param  {Array} roles List of user roles.
     * @return {Promise}     Promise resolved with the formatted roles (string).
     */
    self.formatRoleList = function(roles) {
        var deferred = $q.defer();

        if (roles && roles.length > 0) {
            $translate('mm.core.elementseparator').then(function(separator) {
                var rolekeys = roles.map(function(el) {
                    return 'mm.user.'+el.shortname; // Set the string key to be translated.
                });

                $translate(rolekeys).then(function(roleNames) {
                    var roles = '';
                    for (var roleKey in roleNames) {
                        var roleName = roleNames[roleKey];
                        if (roleName.indexOf('mm.user.') > -1) {
                            // Role name couldn't be translated, leave it like it was.
                            roleName = roleName.replace('mm.user.', '');
                        }
                        roles += (roles != '' ? separator: '') + roleName;
                    }
                    deferred.resolve(roles);
                });
            });
        } else {
            deferred.resolve('');
        }
        return deferred.promise;
    };

    /**
     * Get user profile. The type of profile retrieved depends on the params.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#getProfile
     * @param  {Number} userid      User's ID.
     * @param  {Number} [courseid]  Course ID to get course profile, undefined or 0 to get site profile.
     * @param  {Boolean} forceLocal True to retrieve the user data from local DB, false to retrieve it from WS.
     * @return {Promise}            Promise resolved with the user data.
     */
    self.getProfile = function(userid, courseid, forceLocal) {

        var deferred = $q.defer();

        if (forceLocal) {
            self.getUserFromLocal(userid).then(deferred.resolve, function() {
                self.getUserFromWS(userid, courseid).then(deferred.resolve, deferred.reject);
            });
        } else {
            self.getUserFromWS(userid, courseid).then(deferred.resolve, function() {
                self.getUserFromLocal(userid).then(deferred.resolve, deferred.reject);
            });
        }

        return deferred.promise;
    };

    /**
     * Invalidates user WS calls.
     *
     * @param  {Number} userid User ID.
     * @return {String}        Cache key.
     */
    function getUserCacheKey(userid) {
        return 'mmUser:data:'+userid;
    }

    /**
     * Get user basic information from local DB.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#getUserFromLocal
     * @param  {Number} id User ID.
     * @return {Promise}   Promise resolve when the user is retrieved.
     */
    self.getUserFromLocal = function(id) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }
        return $mmSite.getDb().get(mmCoreUsersStore, parseInt(id));
    };

    /**
     * Get user profile from WS.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#getUserFromWS
     * @param  {Number} id         User ID.
     * @param  {Number} [courseid] Course ID to get course profile, undefined or 0 to get site profile.
     * @return {Promise}           Promise resolve when the user is retrieved.
     */
    self.getUserFromWS = function(userid, courseid) {
        var wsName,
            data,
            preSets ={
                cacheKey: getUserCacheKey(userid)
            };

        // Determine WS and data to use.
        if (courseid > 1) {
            $log.debug('Get participant with ID ' + userid + ' in course '+courseid);
            wsName = 'core_user_get_course_user_profiles';
            data = {
                "userlist[0][userid]": userid,
                "userlist[0][courseid]": courseid
            };
        } else {
            $log.debug('Get user with ID ' + userid);
            if ($mmSite.wsAvailable('core_user_get_users_by_field')) {
                wsName = 'core_user_get_users_by_field';
                data = {
                    'field': 'id',
                    'values[0]': userid
                };
            } else {
                wsName = 'core_user_get_users_by_id';
                data = {
                    'userids[0]': userid
                };
            }
        }

        return $mmSite.read(wsName, data, preSets).then(function(users) {
            if (users.length == 0) {
                return $q.reject();
            }

            var user = users.shift();
            if (user.country) {
                user.country = $mmUtil.getCountryName(user.country);
            }
            self.storeUser(user.id, user.fullname, user.profileimageurl);
            return user;
        });
    };

    /**
     * Invalidates user WS calls.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#invalidateUserCache
     * @param  {Number} userid User ID.
     * @return {Promise}       Promise resolved when the data is invalidated.
     */
    self.invalidateUserCache = function(userid) {
        return $mmSite.invalidateWsCacheForKey(getUserCacheKey(userid));
    };

    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @module mm.core.user
     * @ngdoc method
     * @name $mmUser#storeUser
     * @param  {Number} id       User ID.
     * @param  {String} fullname User full name.
     * @param  {String} avatar   User avatar URL.
     * @return {Promise}         Promise resolve when the user is stored.
     */
    self.storeUser = function(id, fullname, avatar) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }

        return $mmSite.getDb().insert(mmCoreUsersStore, {
            id: parseInt(id),
            fullname: fullname,
            profileimageurl: avatar
        });
    };

    /**
     * Store users basic information in local DB.
     *
     * @param  {Object[]} users Users to store. Fields stored: id, fullname, profileimageurl.
     * @return {Promise}        Promise resolve when the user is stored.
     */
    self.storeUsers = function(users) {
        var promises = [];

        angular.forEach(users, function(user) {
            var userid = user.id || user.userid,
                img = user.profileimageurl || user.profileimgurl;
            if (typeof userid != 'undefined') {
                promises.push(self.storeUser(userid, user.fullname, img));
            }
        });

        return $q.all(promises);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar', [])

.constant('mmaCalendarDaysInterval', 30)
.constant('mmaCalendarDefaultNotifTime', 60)
.constant('mmaCalendarComponent', 'mmaCalendarEvents')
.constant('mmaCalendarPriority', 400)

.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaCalendarPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaCalendarPriority) {

    $stateProvider
        .state('site.calendar', {
            url: '/calendar',
            views: {
                'site': {
                    controller: 'mmaCalendarListCtrl',
                    templateUrl: 'addons/calendar/templates/list.html'
                }
            },
            params: {
                eventid: null,
                clear: false
            }
        })

        .state('site.calendar-event', {
            url: '/calendar-event/:id', // We need to add ID to the URL to make ng-href work.
            views: {
                'site': {
                    controller: 'mmaCalendarEventCtrl',
                    templateUrl: 'addons/calendar/templates/event.html'
                }
            }
        });

    // Register side menu addon.
    // FYI: Comment this out to disable from side menu
    $mmSideMenuDelegateProvider.registerNavHandler('mmaCalendar', '$mmaCalendarHandlers.sideMenuNav', mmaCalendarPriority);

}])

.run(["$mmaCalendar", "$mmLocalNotifications", "$state", "$ionicPlatform", "$mmApp", "mmaCalendarComponent", function($mmaCalendar, $mmLocalNotifications, $state, $ionicPlatform, $mmApp, mmaCalendarComponent) {

    // Listen for notification clicks.
    $mmLocalNotifications.registerClick(mmaCalendarComponent, function(data) {
        if (data.eventid) {
            $mmApp.ready().then(function() {
                $state.go('redirect', {siteid: data.siteid, state: 'site.calendar', params: {eventid: data.eventid}});
            });
        }
    });

    $ionicPlatform.ready(function() {
        $mmaCalendar.scheduleAllSitesEventsNotifications();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion', [])

.constant('mmaCourseCompletionPriority', 200)
.constant('mmaCourseCompletionViewCompletionPriority', 200)

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "mmaCourseCompletionPriority", "mmaCourseCompletionViewCompletionPriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, mmaCourseCompletionPriority,
            mmaCourseCompletionViewCompletionPriority) {

    $stateProvider

    .state('site.course-completion', {
        url: '/course-completion',
        views: {
            'site': {
                templateUrl: 'addons/coursecompletion/templates/report.html',
                controller: 'mmaCourseCompletionReportCtrl'
            }
        },
        params: {
            course: null,
            userid: null
        }
    });

    // Register plugin on user profile.
    $mmUserDelegateProvider.registerProfileHandler('mmaCourseCompletion:viewCompletion',
            '$mmaCourseCompletionHandlers.viewCompletion', mmaCourseCompletionViewCompletionPriority);

    // Register courses handler.
    $mmCoursesDelegateProvider.registerNavHandler('mmaCourseCompletion',
            '$mmaCourseCompletionHandlers.coursesNav', mmaCourseCompletionPriority);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files', ['mm.core'])

.constant('mmaFilesUploadStateName', 'site.files-upload')
.constant('mmaFilesSharedFilesStore', 'shared_files')
.constant('mmaFilesMyComponent', 'mmaFilesMy')
.constant('mmaFilesSiteComponent', 'mmaFilesSite')
.constant('mmaFilesPriority', 200)

.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaFilesUploadStateName", "mmaFilesPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaFilesUploadStateName, mmaFilesPriority) {

    $stateProvider
        .state('site.files', {
            url: '/files',
            views: {
                'site': {
                    controller: 'mmaFilesIndexController',
                    templateUrl: 'addons/files/templates/index.html'
                }
            }
        })

        .state('site.files-list', {
            url: '/list',
            params: {
                path: false,
                root: false,
                title: false
            },
            views: {
                'site': {
                    controller: 'mmaFilesListController',
                    templateUrl: 'addons/files/templates/list.html'
                }
            }
        })

        .state(mmaFilesUploadStateName, {
            url: '/upload',
            params: {
                path: false,
                root: false
            },
            views: {
                'site': {
                    controller: 'mmaFilesUploadCtrl',
                    templateUrl: 'addons/files/templates/upload.html'
                }
            }
        })

        .state('site.files-choose-site', {
            url: '/choose-site',
            params: {
                file: null
            },
            views: {
                'site': {
                    controller: 'mmaFilesChooseSiteCtrl',
                    templateUrl: 'addons/files/templates/choosesite.html'
                }
            }
        });

    // Register side menu addon.
    $mmSideMenuDelegateProvider.registerNavHandler('mmaFiles', '$mmaFilesHandlers.sideMenuNav', mmaFilesPriority);

}])

.run(["$mmaFiles", "$state", "$mmSitesManager", "$mmUtil", "$mmaFilesHelper", "$ionicPlatform", "$mmApp", function($mmaFiles, $state, $mmSitesManager, $mmUtil, $mmaFilesHelper, $ionicPlatform, $mmApp) {

    // Search for new files shared with the upload (to upload).
    if (ionic.Platform.isIOS()) {
        // In iOS we need to manually check if there are new files in the app Inbox folder.
        function searchToUpload() {
            $mmApp.ready().then(function() {
                $mmaFiles.checkIOSNewFiles().then(function(fileEntry) {
                    $mmSitesManager.getSites().then(function(sites) {
                        if (sites.length == 0) {
                            $mmUtil.showErrorModal('mma.files.errorreceivefilenosites', true);
                        } else if (sites.length == 1) {
                            $mmaFilesHelper.showConfirmAndUploadInSite(fileEntry, sites[0].id);
                        } else {
                            $state.go('site.files-choose-site', {file: fileEntry});
                        }
                    });
                });
            });
        }
        // We want to check it at app start and when the app is resumed.
        $ionicPlatform.on('resume', searchToUpload);
        searchToUpload();
    }

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.frontpage', [])

.constant('mmaFrontpagePriority', 1000)

.config(["$mmSideMenuDelegateProvider", "mmaFrontpagePriority", function($mmSideMenuDelegateProvider, mmaFrontpagePriority) {
    // Register side menu addon.
    //$mmSideMenuDelegateProvider.registerNavHandler('mmaFrontpage', '$mmaFrontPageHandlers.sideMenuNav', mmaFrontpagePriority);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades', [])

.constant('mmaGradesPriority', 400)
.constant('mmaGradesViewGradesPriority', 400)

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "$mmContentLinksDelegateProvider", "mmaGradesPriority", "mmaGradesViewGradesPriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, $mmContentLinksDelegateProvider,
            mmaGradesPriority, mmaGradesViewGradesPriority) {

    $stateProvider

    .state('site.grades', {
        url: '/grades',
        views: {
            'site': {
                templateUrl: 'addons/grades/templates/table.html',
                controller: 'mmaGradesTableCtrl'
            }
        },
        params: {
            course: null,
            userid: null
        }
    });


    // Register plugin on user profile.
    $mmUserDelegateProvider.registerProfileHandler('mmaGrades:viewGrades', '$mmaGradesHandlers.viewGrades', mmaGradesViewGradesPriority);

    // Register courses content plugin.
    $mmCoursesDelegateProvider.registerNavHandler('mmaGrades', '$mmaGradesHandlers.coursesNav', mmaGradesPriority);

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaGrades', '$mmaGradesHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages', ['mm.core'])

.constant('mmaMessagesDiscussionLoadedEvent', 'mma_messages_discussion_loaded')
.constant('mmaMessagesDiscussionLeftEvent', 'mma_messages_discussion_left')
.constant('mmaMessagesPollInterval', 5000)
.constant('mmaMessagesPriority', 600)
.constant('mmaMessagesSendMessagePriority', 1000)
.constant('mmaMessagesAddContactPriority', 800)
.constant('mmaMessagesBlockContactPriority', 600)
.constant('mmaMessagesNewMessageEvent', 'mma-messages_new_message')

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmSideMenuDelegateProvider", "mmaMessagesSendMessagePriority", "mmaMessagesAddContactPriority", "mmaMessagesBlockContactPriority", "mmaMessagesPriority", "$mmContentLinksDelegateProvider", function($stateProvider, $mmUserDelegateProvider, $mmSideMenuDelegateProvider, mmaMessagesSendMessagePriority,
            mmaMessagesAddContactPriority, mmaMessagesBlockContactPriority, mmaMessagesPriority, $mmContentLinksDelegateProvider) {

    $stateProvider

    .state('site.messages', {
        url: '/messages',
        views: {
            'site': {
                templateUrl: 'addons/messages/templates/index.html',
                controller: 'mmaMessagesIndexCtrl'
            }
        }
    })

    .state('site.messages-discussion', {
        url: '/messages-discussion',
        params: {
            userId: null,
            userFullname: null
        },
        views: {
            'site': {
                templateUrl: 'addons/messages/templates/discussion.html',
                controller: 'mmaMessagesDiscussionCtrl'
            }
        }
    });

    // Register side menu addon.
    $mmSideMenuDelegateProvider.registerNavHandler('mmaMessages', '$mmaMessagesHandlers.sideMenuNav', mmaMessagesPriority);

    // Register user profile addons.
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:sendMessage', '$mmaMessagesHandlers.sendMessage', mmaMessagesSendMessagePriority);
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:addContact', '$mmaMessagesHandlers.addContact', mmaMessagesAddContactPriority);
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:blockContact', '$mmaMessagesHandlers.blockContact', mmaMessagesBlockContactPriority);

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaMessages', '$mmaMessagesHandlers.linksHandler');
}])

.run(["$mmaMessages", "$mmEvents", "$state", "$mmAddonManager", "$mmUtil", "mmCoreEventLogin", function($mmaMessages, $mmEvents, $state, $mmAddonManager, $mmUtil, mmCoreEventLogin) {

    // Invalidate messaging enabled WS calls.
    $mmEvents.on(mmCoreEventLogin, function() {
        $mmaMessages.invalidateEnabledCache();
    });

    // Register push notification clicks.
    var $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate');
    if ($mmPushNotificationsDelegate) {
        $mmPushNotificationsDelegate.registerHandler('mmaMessages', function(notification) {
            if ($mmUtil.isFalseOrZero(notification.notif)) {
                $mmaMessages.isMessagingEnabledForSite(notification.site).then(function() {
                    $mmaMessages.invalidateDiscussionsCache().finally(function() {
                        $state.go('redirect', {siteid: notification.site, state: 'site.messages'});
                    });
                });
                return true;
            }
        });
    }

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign', ['mm.core'])

.constant('mmaModAssignComponent', 'mmaModAssign')
.constant('mmaModAssignSubmissionComponent', 'mmaModAssignSubmission')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_assign', {
        url: '/mod_assign',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignIndexCtrl',
                templateUrl: 'addons/mod_assign/templates/index.html'
            }
        }
    })

    .state('site.mod_assign-submission', {
        url: '/mod_assign-submission',
        params: {
            submission: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignSubmissionCtrl',
                templateUrl: 'addons/mod_assign/templates/submission.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModAssign', 'assign', '$mmaModAssignHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModAssign', '$mmaModAssignHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book', ['mm.core'])

.constant('mmaModBookComponent', 'mmaModBook')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_book', {
      url: '/mod_book',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModBookIndexCtrl',
          templateUrl: 'addons/mod_book/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModBook', 'book', '$mmaModBookHandlers.courseContentHandler');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModBook', 'book', '$mmaModBookPrefetchHandler');

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModBook', '$mmaModBookHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat', [])

.constant('mmaChatPollInterval', 4000)

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_chat', {
        url: '/mod_chat',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModChatIndexCtrl',
                templateUrl: 'addons/mod_chat/templates/index.html'
            }
        }
    })

    .state('site.mod_chat-chat', {
        url: '/mod_chat-chat',
        params: {
            chatid: null,
            courseid: null,
            title: null
        },
        views: {
            'site': {
                controller: 'mmaModChatChatCtrl',
                templateUrl: 'addons/mod_chat/templates/chat.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModChat', 'chat', '$mmaModChatHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModChat', '$mmaModChatHandlers.linksHandler');
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice', [])

.constant('mmaModChoiceResultsNot', 0)
.constant('mmaModChoiceResultsAfterAnswer', 1)
.constant('mmaModChoiceResultsAfterClose', 2)
.constant('mmaModChoiceResultsAlways', 3)

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_choice', {
        url: '/mod_choice',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModChoiceIndexCtrl',
                templateUrl: 'addons/mod_choice/templates/index.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModChoice', 'choice', '$mmaModChoiceHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModChoice', '$mmaModChoiceHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder', ['mm.core'])

.constant('mmaModFolderComponent', 'mmaModFolder')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_folder', {
      url: '/mod_folder',
      params: {
        module: null,
        courseid: null,
        sectionid: null,
        path: null // For subfolders. Use the path instead of a boolean so Angular detects them as different states.
      },
      views: {
        'site': {
          controller: 'mmaModFolderIndexCtrl',
          templateUrl: 'addons/mod_folder/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModFolder', 'folder', '$mmaModFolderHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModFolder', 'folder', '$mmaModFolderPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModFolder', '$mmaModFolderHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum', [])

.constant('mmaModForumDiscPerPage', 10) // Max of discussions per page.
.constant('mmaModForumComponent', 'mmaModForum')
.constant('mmaModForumNewDiscussionEvent', 'mma-mod_forum_new_discussion')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_forum', {
        url: '/mod_forum',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModForumDiscussionsCtrl',
                templateUrl: 'addons/mod_forum/templates/discussions.html'
            }
        }
    })

    .state('site.mod_forum-discussion', {
        url: '/mod_forum-discussion',
        params: {
            discussionid: null,
            cid: null // Not naming it courseid because it collides with 'site.mod_forum' param in split-view.
        },
        views: {
            'site': {
                controller: 'mmaModForumDiscussionCtrl',
                templateUrl: 'addons/mod_forum/templates/discussion.html'
            }
        }
    })

    .state('site.mod_forum-newdiscussion', {
        url: '/mod_forum-newdiscussion',
        params: {
            cid: null, // Not naming it courseid because it collides with 'site.mod_forum' param in split-view.
            forumid: null,
            cmid: null
        },
        views: {
            'site': {
                controller: 'mmaModForumNewDiscussionCtrl',
                templateUrl: 'addons/mod_forum/templates/newdiscussion.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModForum', 'forum', '$mmaModForumHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModForum', '$mmaModForumHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary', ['mm.core'])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_glossary', {
      url: '/mod_glossary',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModGlossaryIndexCtrl',
          templateUrl: 'addons/mod_glossary/templates/index.html'
        }
      }
    })

    .state('site.mod_glossary-entry', {
      url: '/mod_glossary-entry',
      params: {
        cid: null, // Not naming it courseid because it collides with 'site.mod_glossary' param in split-view.
        entry: null
      },
      views: {
        'site': {
          controller: 'mmaModGlossaryEntryCtrl',
          templateUrl: 'addons/mod_glossary/templates/entry.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModGlossary', 'glossary', '$mmaModGlossaryHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModGlossary', '$mmaModGlossaryHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp', ['mm.core'])

.constant('mmaModImscpComponent', 'mmaModImscp')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_imscp', {
      url: '/mod_imscp',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModImscpIndexCtrl',
          templateUrl: 'addons/mod_imscp/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModImscp', 'imscp', '$mmaModImscpHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModImscp', 'imscp', '$mmaModImscpPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModImscp', '$mmaModImscpHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_label', ['mm.core'])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider
    .state('site.mod_label', {
        url: '/mod_label',
        params: {
            description: null
        },
        views: {
            'site': {
                templateUrl: 'addons/mod_label/templates/index.html',
                controller: 'mmaModLabelIndexCtrl'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModLabel', 'label', '$mmaModLabelHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModLabel', '$mmaModLabelHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti', [])

.constant('mmaModLtiComponent', 'mmaModLti')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_lti', {
        url: '/mod_lti',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModLtiIndexCtrl',
                templateUrl: 'addons/mod_lti/templates/index.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModLti', 'lti', '$mmaModLtiHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModLti', '$mmaModLtiHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page', ['mm.core'])

.constant('mmaModPageComponent', 'mmaModPage')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_page', {
      url: '/mod_page',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModPageIndexCtrl',
          templateUrl: 'addons/mod_page/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModPage', 'page', '$mmaModPageHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModPage', 'page', '$mmaModPagePrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModPage', '$mmaModPageHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource', ['mm.core'])

.constant('mmaModResourceComponent', 'mmaModResource')

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_resource', {
      url: '/mod_resource',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModResourceIndexCtrl',
          templateUrl: 'addons/mod_resource/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModResource', 'resource', '$mmaModResourceHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModResource', 'resource', '$mmaModResourcePrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModResource', '$mmaModResourceHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm', ['mm.core'])

.constant('mmaModScormComponent', 'mmaModScorm')
.constant('mmaModScormEventLaunchNextSco', 'mma_mod_scorm_launch_next_sco')
.constant('mmaModScormEventLaunchPrevSco', 'mma_mod_scorm_launch_prev_sco')
.constant('mmaModScormEventUpdateToc', 'mma_mod_scorm_update_toc')
.constant('mmaModScormEventGoOffline', 'mma_mod_scorm_go_offline')
.constant('mmaModScormEventAutomSynced', 'mma_mod_scorm_autom_synced')
.constant('mmaModScormSyncTime', 200000) // In milliseconds.

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_scorm', {
      url: '/mod_scorm',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModScormIndexCtrl',
          templateUrl: 'addons/mod_scorm/templates/index.html'
        }
      }
    })

    .state('site.mod_scorm-player', {
      url: '/mod_scorm-player',
      params: {
        scorm: null,
        mode: null,
        newAttempt: false,
        organizationId: null,
        scoId: null
      },
      views: {
        'site': {
          controller: 'mmaModScormPlayerCtrl',
          templateUrl: 'addons/mod_scorm/templates/player.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModScorm', 'scorm', '$mmaModScormHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModScorm', 'scorm', '$mmaModScormPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModScorm', '$mmaModScormHandlers.linksHandler');
}])

.run(["$timeout", "$mmaModScormSync", "$mmApp", "$mmEvents", "$mmSite", "mmCoreEventLogin", function($timeout, $mmaModScormSync, $mmApp, $mmEvents, $mmSite, mmCoreEventLogin) {
    var lastExecution = 0,
        executing = false,
        allSitesCalled = false;

    function syncScorms(allSites) {
        var now = new Date().getTime();

        if (!allSites && !$mmSite.isLoggedIn()) {
            return;
        }

        // Prevent consecutive and simultaneous executions. A sync process shouldn't take more than a few minutes,
        // so if it's been more than 5 minutes since the last execution we'll ignore the executing value.
        if (now - 5000 > lastExecution && (!executing || now - 300000 > lastExecution)) {
            lastExecution = new Date().getTime();
            executing = true;

            $timeout(function() { // Minor delay just to make sure network is fully established.
                $mmaModScormSync.syncAllScorms(allSites ? undefined : $mmSite.getId()).finally(function() {
                    executing = false;
                });
            }, 1000);
        }
    }

    $mmApp.ready().then(function() {
        document.addEventListener('online', function() {
            syncScorms(false);
        }, false); // Cordova event.
        window.addEventListener('online', function() {
            syncScorms(false);
        }, false); // HTML5 event.

        if (!$mmSite.isLoggedIn()) {
            // App was started without any site logged in. Try to sync all sites.
            allSitesCalled = true;
            if ($mmApp.isOnline()) {
                syncScorms(true);
            }
        }
    });

    $mmEvents.on(mmCoreEventLogin, function() {
        var allSites = false;
        if (!allSitesCalled) {
            // App started with a site logged in. Try to sync all sites.
            allSitesCalled = true;
            allSites = true;
        }

        if ($mmApp.isOnline()) {
            syncScorms(allSites);
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey', [])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_survey', {
        url: '/mod_survey',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModSurveyIndexCtrl',
                templateUrl: 'addons/mod_survey/templates/index.html'
            }
        }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModSurvey', 'survey', '$mmaModSurveyHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModSurvey', '$mmaModSurveyHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url', ['mm.core'])

.config(["$stateProvider", function($stateProvider) {

    $stateProvider

    .state('site.mod_url', {
      url: '/mod_url',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModUrlIndexCtrl',
          templateUrl: 'addons/mod_url/templates/index.html'
        }
      }
    });

}])

.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModUrl', 'url', '$mmaModUrlHandlers.courseContentHandler');

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModUrl', '$mmaModUrlHandlers.linksHandler');
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes', [])

.constant('mmaNotesPriority', 200)
.constant('mmaNotesAddNotePriority', 200)

.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "mmaNotesPriority", "mmaNotesAddNotePriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, mmaNotesPriority, mmaNotesAddNotePriority) {

    $stateProvider

    .state('site.notes-types', {
        url: '/notes-types',
        views: {
            'site': {
                templateUrl: 'addons/notes/templates/types.html',
                controller: 'mmaNotesTypesCtrl'
            }
        },
        params: {
            course: null
        }
    })

    .state('site.notes-list', {
        url: '/notes-list',
        views: {
            'site': {
                templateUrl: 'addons/notes/templates/list.html',
                controller: 'mmaNotesListCtrl'
            }
        },
        params: {
            courseid: null,
            type: null
        }
    });

    // Register plugin on user profile.
    $mmUserDelegateProvider.registerProfileHandler('mmaNotes:addNote', '$mmaNotesHandlers.addNote', mmaNotesAddNotePriority);

    // Register courses handler.
    $mmCoursesDelegateProvider.registerNavHandler('mmaNotes', '$mmaNotesHandlers.coursesNav', mmaNotesPriority);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications', [])

.constant('mmaNotificationsListLimit', 20) // Max of notifications to retrieve in each WS call.
.constant('mmaNotificationsPriority', 800)

.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaNotificationsPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaNotificationsPriority) {

    $stateProvider

    .state('site.notifications', {
        url: '/notifications',
        views: {
            'site': {
                templateUrl: 'addons/notifications/templates/list.html',
                controller: 'mmaNotificationsListCtrl'
            }
        }
    });

    // Register side menu addon.
    $mmSideMenuDelegateProvider.registerNavHandler('mmaNotifications', '$mmaNotificationsHandlers.sideMenuNav', mmaNotificationsPriority);
}])

.run(["$log", "$mmaNotifications", "$mmUtil", "$state", "$mmAddonManager", function($log, $mmaNotifications, $mmUtil, $state, $mmAddonManager) {
    $log = $log.getInstance('mmaNotifications');

    // Register push notification clicks.
    var $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate');
    if ($mmPushNotificationsDelegate) {
        $mmPushNotificationsDelegate.registerHandler('mmaNotifications', function(notification) {
            if ($mmUtil.isTrueOrOne(notification.notif)) {
                $mmaNotifications.isPluginEnabledForSite(notification.site).then(function() {
                    $mmaNotifications.invalidateNotificationsList().finally(function() {
                        $state.go('redirect', {siteid: notification.site, state: 'site.notifications'});
                    });
                });
                return true;
            }
        });
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants', [])

.constant('mmaParticipantsListLimit', 50) // Max of participants to retrieve in each WS call.
.constant('mmaParticipantsPriority', 600)

.config(["$stateProvider", "$mmCoursesDelegateProvider", "$mmContentLinksDelegateProvider", "mmaParticipantsPriority", function($stateProvider, $mmCoursesDelegateProvider, $mmContentLinksDelegateProvider, mmaParticipantsPriority) {

    $stateProvider
        .state('site.participants', {
            url: '/participants',
            views: {
                'site': {
                    controller: 'mmaParticipantsListCtrl',
                    templateUrl: 'addons/participants/templates/list.html'
                }
            },
            params: {
                course: null
            }
        });

    $mmCoursesDelegateProvider.registerNavHandler('mmaParticipants', '$mmaParticipantsHandlers.coursesNavHandler',
                mmaParticipantsPriority);

    // Register content links handler.
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaParticipants', '$mmaParticipantsHandlers.linksHandler');

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.pushnotifications', [])

.constant('mmaPushNotificationsComponent', 'mmaPushNotifications')

.run(["$mmaPushNotifications", "$ionicPlatform", "$rootScope", "$mmEvents", "$mmLocalNotifications", "mmCoreEventLogin", "mmaPushNotificationsComponent", "mmCoreEventSiteDeleted", function($mmaPushNotifications, $ionicPlatform, $rootScope, $mmEvents, $mmLocalNotifications, mmCoreEventLogin,
            mmaPushNotificationsComponent, mmCoreEventSiteDeleted) {

    // Register device on GCM or APNS server.
    $ionicPlatform.ready(function() {
        $mmaPushNotifications.registerDevice();
    });

    // Notification received.
    $rootScope.$on('$cordovaPush:notificationReceived', function(e, notification) {
        if (ionic.Platform.isAndroid()) {
            $mmaPushNotifications.onGCMReceived(notification);
        } else if (ionic.Platform.isIOS()) {
            $mmaPushNotifications.onMessageReceived(notification);
        }
    });

    // Register device on Moodle site when login.
    $mmEvents.on(mmCoreEventLogin, function() {
        $mmaPushNotifications.registerDeviceOnMoodle();
    });

    $mmEvents.on(mmCoreEventSiteDeleted, function(site) {
        $mmaPushNotifications.unregisterDeviceOnMoodle(site);
    });

    // Listen for local notification clicks (generated by the app).
    $mmLocalNotifications.registerClick(mmaPushNotificationsComponent, $mmaPushNotifications.notificationClicked);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.remotestyles', [])

.constant('mmaRemoteStylesComponent', 'mmaRemoteStyles')

.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventLogout", "mmCoreEventSiteAdded", "mmCoreEventSiteUpdated", "$mmaRemoteStyles", "$mmSite", function($mmEvents, mmCoreEventLogin, mmCoreEventLogout, mmCoreEventSiteAdded, mmCoreEventSiteUpdated, $mmaRemoteStyles,
            $mmSite) {

    $mmEvents.on(mmCoreEventSiteAdded, $mmaRemoteStyles.load);
    $mmEvents.on(mmCoreEventSiteUpdated, function(siteid) {
        // Load only if current site was updated.
        if (siteid === $mmSite.getId()) {
            $mmaRemoteStyles.load();
        }
    });
    $mmEvents.on(mmCoreEventLogin, $mmaRemoteStyles.load);

    // Remove added styles on logout.
    $mmEvents.on(mmCoreEventLogout, $mmaRemoteStyles.clear);
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

/**
 * Controller to handle an event.
 *
 * @module mm.addons.calendar
 * @ngdoc controller
 * @name mmaCalendarEventCtrl
 */
.controller('mmaCalendarEventCtrl', ["$scope", "$log", "$stateParams", "$mmaCalendar", "$mmUtil", "$mmCourse", "$mmCourses", "$mmLocalNotifications", function($scope, $log, $stateParams, $mmaCalendar, $mmUtil, $mmCourse, $mmCourses,
        $mmLocalNotifications) {

    $log = $log.getInstance('mmaCalendarEventCtrl');

    var eventid = parseInt($stateParams.id);

    // Convenience function that fetches the event and updates the scope.
    function fetchEvent(refresh) {
        return $mmaCalendar.getEvent(eventid, refresh).then(function(e) {
            $mmaCalendar.formatEventData(e);
            $scope.event = e;
            $scope.title = e.name;

            if (e.moduleicon) {
                // It's a module event, translate the module name to the current language.
                $mmCourse.translateModuleName(e.modulename).then(function(name) {
                    if (name.indexOf('mm.core.mod') === -1) {
                        e.modulename = name;
                    }
                });
            }

            if (e.courseid > 1) {
                // It's a course event, retrieve the course name.
                $mmCourses.getUserCourse(e.courseid, true).then(function(course) {
                    $scope.coursename = course.fullname;
                });
            }

        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.calendar.errorloadevent', true);
            }
        });
    }

    // Get event.
    fetchEvent().finally(function() {
        $scope.eventLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshEvent = function() {
        fetchEvent(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.notificationsEnabled = $mmLocalNotifications.isAvailable();
    if ($scope.notificationsEnabled) {

        $mmaCalendar.getEventNotificationTime(eventid).then(function(notificationtime) {
            $scope.notification = { // Use an object, otherwise changes are not reflected.
                time: String(notificationtime)
            };
        });

        $scope.updateNotificationTime = function() {
            var time = parseInt($scope.notification.time);
            if (!isNaN(time) && $scope.event && $scope.event.id) {
                $mmaCalendar.updateNotificationTime($scope.event, time);
            }
        };
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

/**
 * Controller to handle calendar events.
 *
 * @module mm.addons.calendar
 * @ngdoc controller
 * @name mmaCalendarListCtrl
 */
.controller('mmaCalendarListCtrl', ["$scope", "$stateParams", "$log", "$state", "$mmaCalendar", "$mmUtil", "$ionicHistory", "mmaCalendarDaysInterval", function($scope, $stateParams, $log, $state, $mmaCalendar, $mmUtil, $ionicHistory,
        mmaCalendarDaysInterval) {

    $log = $log.getInstance('mmaCalendarListCtrl');

    var daysLoaded,
        emptyEventsTimes; // Variable to identify consecutive calls returning 0 events.

    if ($stateParams.eventid) {
        // We arrived here via notification click, let's clear history and redirect to event details.
        $ionicHistory.clearHistory();
        $state.go('site.calendar-event', {id: $stateParams.eventid});
    }

    // Convenience function to initialize variables.
    function initVars() {
        daysLoaded = 0;
        emptyEventsTimes = 0;
        $scope.events = [];
    }

    // Convenience function that fetches the events and updates the scope.
    function fetchEvents(refresh) {
        if (refresh) {
            initVars();
        }
        $scope.canLoadMore = false; // Set it to false to prevent consecutive calls.

        return $mmaCalendar.getEvents(daysLoaded, mmaCalendarDaysInterval, refresh).then(function(events) {
            daysLoaded += mmaCalendarDaysInterval;

            if (events.length === 0) {
                emptyEventsTimes++;
                if (emptyEventsTimes > 5) { // Stop execution if we retrieve empty list 6 consecutive times.
                    $scope.canLoadMore = false;
                    $scope.eventsLoaded = true;
                } else {
                    // No events returned, load next events.
                    return fetchEvents();
                }
            } else {
                angular.forEach(events, $mmaCalendar.formatEventData);
                if (refresh) {
                    $scope.events = events;
                } else {
                    $scope.events = $scope.events.concat(events);
                }
                $scope.count = $scope.events.length;
                $scope.eventsLoaded = true;
                $scope.canLoadMore = true;

                // Schedule notifications for the events retrieved (might have new events).
                $mmaCalendar.scheduleEventsNotifications(events);
            }
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.calendar.errorloadevents', true);
            }
            $scope.eventsLoaded = true;
        });
    }

    initVars();
    $scope.count = 0;

    // Get first events.
    fetchEvents();

    // Load more events.
    $scope.loadMoreEvents = function() {
        fetchEvents().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };

    // Pull to refresh.
    $scope.refreshEvents = function() {
        $mmaCalendar.invalidateEventsList().finally(function() {
            fetchEvents(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

.constant('mmaCalendarEventsStore', 'calendar_events')

.config(["$mmSitesFactoryProvider", "mmaCalendarEventsStore", function($mmSitesFactoryProvider, mmaCalendarEventsStore) {
    var stores = [
        {
            name: mmaCalendarEventsStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'notificationtime'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Service to handle calendar events.
 *
 * @module mm.addons.calendar
 * @ngdoc service
 * @name $mmaCalendar
 */
.factory('$mmaCalendar', ["$log", "$q", "$mmSite", "$mmUtil", "$mmCourses", "$mmGroups", "$mmCourse", "$mmLocalNotifications", "$mmSitesManager", "mmCoreSecondsDay", "mmaCalendarDaysInterval", "mmaCalendarEventsStore", "mmaCalendarDefaultNotifTime", "mmaCalendarComponent", function($log, $q, $mmSite, $mmUtil, $mmCourses, $mmGroups, $mmCourse, $mmLocalNotifications,
        $mmSitesManager, mmCoreSecondsDay, mmaCalendarDaysInterval, mmaCalendarEventsStore, mmaCalendarDefaultNotifTime,
        mmaCalendarComponent) {

    $log = $log.getInstance('$mmaCalendar');

    var self = {},
        calendarImgPath = 'addons/calendar/img/',
        eventicons = {
            'course': calendarImgPath + 'courseevent.svg',
            'group': calendarImgPath + 'groupevent.svg',
            'site': calendarImgPath + 'siteevent.svg',
            'user': calendarImgPath + 'userevent.svg'
        };

    /**
     * Get cache key for events list WS calls.
     *
     * @param {Number} daysToStart  Number of days from now to start getting events.
     * @param {Number} daysInterval Number of days between timestart and timeend.
     * @return {String} Cache key.
     */
    function getEventsListCacheKey(daysToStart, daysInterval) {
        return 'mmaCalendar:events:' + daysToStart + ':' + daysInterval;
    }

    /**
     * Get cache key for a single event WS call.
     *
     * @param {Number} id Event ID.
     * @return {String} Cache key.
     */
    function getEventCacheKey(id) {
        return 'mmaCalendar:events:' + id;
    }

    /**
     * Get the common part of the cache keys for events WS calls. Invalidate the whole list also invalidates all the
     * single events.
     *
     * @return {String} Cache key.
     */
    function getEventsCommonCacheKey() {
        return 'mmaCalendar:events:';
    }

    /**
     * Store events in local DB.
     *
     * @param {Object[]} events  Events to store.
     * @param  {String} [siteid] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise}         Promise resolved when the events are stored.
     */
    function storeEventsInLocalDB(events, siteid) {
        siteid = siteid || $mmSite.getId();

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var promises = [],
                db = site.getDb();

            angular.forEach(events, function(event) {
                // Get the event notification time to prevent overriding it in DB.
                var promise = self.getEventNotificationTime(event.id, siteid).then(function(time) {
                    event.notificationtime = time;
                    return db.insert(mmaCalendarEventsStore, event);
                });
                promises.push(promise);
            });

            return $q.all(promises);
        });
    }

    /**
     * Convenience function to format some event data to be rendered. Adds properties 'start', 'end', 'icon'
     * and (if it's a module event) 'moduleicon'.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#formatEventData
     * @param {Object} e Event to format.
     */
    self.formatEventData = function(e) {
        var icon = self.getEventIcon(e.eventtype);
        if (icon === '') {
            // It's a module event.
            icon = $mmCourse.getModuleIconSrc(e.modulename);
            e.moduleicon = icon;
        }
        e.icon = icon;
    };

    /**
     * Get a calendar event from server or cache. If the server request fails and data is not cached,
     * try to get it from local DB.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEvent
     * @param {Number}  id        Event ID.
     * @param {Boolean} [refresh] True when we should update the event data.
     * @return {Promise}          Promise resolved when the event data is retrieved.
     */
    self.getEvent = function(id, refresh) {
        var presets = {},
            data = {
                "options[userevents]": 0,
                "options[siteevents]": 0,
                "events[eventids][0]": id
            };

        presets.cacheKey = getEventCacheKey(id);
        if (refresh) {
            presets.getFromCache = false;
        }
        return $mmSite.read('core_calendar_get_calendar_events', data, presets).then(function(response) {
            var e = response.events[0];
            if (e) {
                return e;
            } else {
                return self.getEventFromLocalDb(id);
            }
        }, function() {
            return self.getEventFromLocalDb(id);
        });
    };

    /**
     * Get a calendar event from local Db.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEventFromLocalDb
     * @param {Number}  id Event ID.
     * @return {Promise}   Promise resolved when the event data is retrieved.
     */
    self.getEventFromLocalDb = function(id) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }
        return $mmSite.getDb().get(mmaCalendarEventsStore, id);
    };

    /**
     * Get event icon name based on event type.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEventIcon
     * @param  {String} type Event type.
     * @return {String}      Event icon name. If type not valid, return empty string.
     */
    self.getEventIcon = function(type) {
        return eventicons[type] || '';
    };

    /**
     * Get event notification time.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEventNotificationTime
     * @param  {Number} id       Event ID.
     * @param  {String} [siteid] ID of the site the event belongs to. If not defined, use current site.
     * @return {String}          Event icon name. If type not valid, return empty string.
     */
    self.getEventNotificationTime = function(id, siteid) {
        siteid = siteid || $mmSite.getId();

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var db = site.getDb();

            return db.get(mmaCalendarEventsStore, id).then(function(e) {
                if (typeof e.notificationtime != 'undefined') {
                    return e.notificationtime;
                }
                return mmaCalendarDefaultNotifTime;
            }, function(err) {
                return mmaCalendarDefaultNotifTime;
            });
        });
    };

    /**
     * Get calendar events in a certain period.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#getEvents
     * @param {Number} [daysToStart=0]   Number of days from now to start getting events.
     * @param {Number} [daysInterval=30] Number of days between timestart and timeend.
     * @param {Boolean} [refresh]        True when we should not get the value from the cache.
     * @param {String} [siteid]          Site to get the events from. If not defined, use current site.
     * @return {Promise}                 Promise to be resolved when the participants are retrieved.
     * @description
     * Get the events in a certain period. The period is calculated like this:
     *     start time: now + daysToStart
     *     end time: start time + daysInterval
     * E.g. using $mmaCalendar.getEvents(30, 30) is going to get the events starting after 30 days from now
     * and ending before 60 days from now.
     */
    self.getEvents = function(daysToStart, daysInterval, refresh, siteid) {
        daysToStart = daysToStart || 0;
        daysInterval = daysInterval || mmaCalendarDaysInterval;
        siteid = siteid || $mmSite.getId();

         var now = $mmUtil.timestamp(),
            start = now + (mmCoreSecondsDay * daysToStart),
            end = start + (mmCoreSecondsDay * daysInterval);

        // The core_calendar_get_calendar_events needs all the current user courses and groups.
        var data = {
            "options[userevents]": 1,
            "options[siteevents]": 1,
            "options[timestart]": start,
            "options[timeend]": end
        };

        return $mmCourses.getUserCourses(false, siteid).then(function(courses) {
            courses.push({id: 1}); // Add front page.
            angular.forEach(courses, function(course, index) {
                data["events[courseids][" + index + "]"] = course.id;
            });

            return $mmGroups.getUserGroups(courses, refresh, siteid).then(function(groups) {
                angular.forEach(groups, function(group, index) {
                    data["events[groupids][" + index + "]"] = group.id;
                });

                return $mmSitesManager.getSite(siteid).then(function(site) {

                    // We need to retrieve cached data using cache key because we have timestamp in the params.
                    var preSets = {
                        cacheKey: getEventsListCacheKey(daysToStart, daysInterval),
                        getCacheUsingCacheKey: true
                    };
                    return site.read('core_calendar_get_calendar_events', data, preSets).then(function(response) {
                        storeEventsInLocalDB(response.events, siteid);
                        return response.events;
                    });
                });
            });

        });
    };

    /**
     * Invalidates events list and all the single events.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#invalidateEventsList
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateEventsList = function() {
        var p1 = $mmCourses.invalidateUserCourses(),
            p2 = $mmSite.invalidateWsCacheForKeyStartingWith(getEventsCommonCacheKey());
        return $q.all([p1, p2]);
    };

    /**
     * Check if calendar events WS is available.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#isAvailable
     * @return {Boolean} True if calendar events WS is available, false otherwise.
     */
    self.isAvailable = function() {
        return $mmSite.wsAvailable('core_calendar_get_calendar_events');
    };

    /**
     * Get the next events for all the sites and schedules their notifications.
     * If an event notification time is 0, cancel its scheduled notification (if any).
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#scheduleAllSitesEventsNotifications
     * @param  {Object[]} events Events to schedule.
     * @return {Promise}         Promise resolved when all the notifications have been scheduled.
     */
    self.scheduleAllSitesEventsNotifications = function() {

        if ($mmLocalNotifications.isAvailable()) {
            return $mmSitesManager.getSitesIds().then(function(siteids) {

                var promises = [];
                angular.forEach(siteids, function(siteid) {
                    // Get first events.
                    var promise = self.getEvents(undefined, undefined, false, siteid).then(function(events) {
                        return self.scheduleEventsNotifications(events, siteid);
                    });
                    promises.push(promise);
                });

                return $q.all(promises);
            });
        } else {
            var deferred = $q.defer();
            deferred.resolve();
            return deferred.promise;
        }
    };

    /**
     * Schedules an event notification. If time is 0, cancel scheduled notification if any.
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#scheduleEventNotification
     * @param  {Object} event    Event to schedule.
     * @param  {Number} time     Notification setting time (in minutes). E.g. 10 means "notificate 10 minutes before start".
     * @param  {String} [siteid] Site ID the event belongs to. If not defined, use current site.
     * @return {Promise}       Promise resolved when the notification is scheduled.
     */
    self.scheduleEventNotification = function(event, time, siteid) {
        siteid = siteid || $mmSite.getId();

        if ($mmLocalNotifications.isAvailable()) {
            if (time === 0) {
                return $mmLocalNotifications.cancel(event.id, mmaCalendarComponent, siteid); // Cancel if it was scheduled.
            } else {
                var timeend = (event.timestart + event.timeduration) * 1000;
                if (timeend <= new Date().getTime()) {
                    // The event has finished already, don't schedule it.
                    return $q.when();
                }

                var dateTriggered = new Date((event.timestart - (time * 60)) * 1000),
                    startDate = new Date(event.timestart * 1000),
                    notification = {
                        id: event.id,
                        title: event.name,
                        message: startDate.toLocaleString(),
                        at: dateTriggered,
                        smallIcon: 'res://icon',
                        data: {
                            eventid: event.id,
                            siteid: siteid
                        }
                    };

                return $mmLocalNotifications.schedule(notification, mmaCalendarComponent, siteid);
            }
        } else {
            return $q.when();
        }
    };

    /**
     * Schedules the notifications for a list of events.
     * If an event notification time is 0, cancel its scheduled notification (if any).
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#scheduleEventsNotifications
     * @param  {Object[]} events Events to schedule.
     * @param  {String} [siteid] ID of the site the events belong to. If not defined, use current site.
     * @return {Promise}         Promise resolved when all the notifications have been scheduled.
     */
    self.scheduleEventsNotifications = function(events, siteid) {
        siteid = siteid || $mmSite.getId();
        var promises = [];

        if ($mmLocalNotifications.isAvailable()) {
            angular.forEach(events, function(e) {
                var promise = self.getEventNotificationTime(e.id, siteid).then(function(time) {
                    return self.scheduleEventNotification(e, time, siteid);
                });
                promises.push(promise);
            });
        }

        return $q.all(promises);
    };

    /**
     * Updates an event notification time and schedule a new notification.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendar#updateNotificationTime
     * @param  {Object} event Event to update its notification time.
     * @param  {Number} time  New notification setting time (in minutes). E.g. 10 means "notificate 10 minutes before start".
     * @return {Promise}      Promise resolved when the notification is updated.
     */
    self.updateNotificationTime = function(event, time) {
        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return $q.reject();
        }

        var db = $mmSite.getDb();

        event.notificationtime = time;

        return db.insert(mmaCalendarEventsStore, event).then(function() {
            return self.scheduleEventNotification(event, time);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.calendar')

/**
 * Calendar handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.calendar
 * @ngdoc service
 * @name $mmaCalendarHandlers
 */
.factory('$mmaCalendarHandlers', ["$log", "$mmaCalendar", function($log, $mmaCalendar) {
    $log = $log.getInstance('$mmaCalendarHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.calendar
     * @ngdoc method
     * @name $mmaCalendarHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaCalendar.isAvailable();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.calendar
             * @ngdoc controller
             * @name $mmaCalendarHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-calendar';
                $scope.title = 'mma.calendar.calendarevents';
                $scope.state = 'site.calendar';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion')

/**
 * Controller to handle course completion report.
 *
 * @module mm.addons.coursecompletion
 * @ngdoc controller
 * @name mmaCourseCompletionReportCtrl
 */
.controller('mmaCourseCompletionReportCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaCourseCompletion", "$mmSite", "$ionicPlatform", function($scope, $stateParams, $mmUtil, $mmaCourseCompletion, $mmSite,
            $ionicPlatform) {

    var course = $stateParams.course,
        userid = $stateParams.userid || $mmSite.getUserId();

    $scope.isTablet = $ionicPlatform.isTablet();

    function fetchCompletion() {
        return $mmaCourseCompletion.getCompletion(course.id, userid).then(function(completion) {

            completion.statusText = $mmaCourseCompletion.getCompletedStatusText(completion);

            $scope.completion = completion;
            $scope.showSelfComplete = $mmaCourseCompletion.isSelfCompletionAvailable() &&
                                        $mmaCourseCompletion.canMarkSelfCompleted(userid, completion);
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.coursecompletion.couldnotloadreport', true);
            }
        });
    }

    fetchCompletion().finally(function() {
        $scope.completionLoaded = true;
    });

    // Convenienve function to refresh completion data.
    function refreshCompletion() {
        return $mmaCourseCompletion.invalidateCourseCompletion(course.id, userid).finally(function() {
            return fetchCompletion();
        });
    }

    $scope.refreshCompletion = function() {
        refreshCompletion().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.completeCourse = function() {
        var modal = $mmUtil.showModalLoading('mm.core.sending', true);
        $mmaCourseCompletion.markCourseAsSelfCompleted(course.id).then(function() {
            return refreshCompletion();
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
        }).finally(function() {
            modal.dismiss();
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion')

/**
 * Course completion factory.
 *
 * @module mm.addons.coursecompletion
 * @ngdoc service
 * @name $mmaCourseCompletion
 */
.factory('$mmaCourseCompletion', ["$mmSite", "$log", "$q", "$mmCourses", function($mmSite, $log, $q, $mmCourses) {
    $log = $log.getInstance('$mmaCourseCompletion');

    var self = {};

    /**
     * Returns whether or not the user can mark a course as self completed.
     * It can if it's configured in the course and it hasn't been completed yet.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#canMarkSelfCompleted
     * @param {Number} userid     User ID.
     * @param {Object} completion Course completion.
     * @return {Boolean}          True if user can mark course as self completed, false otherwise.
     */
    self.canMarkSelfCompleted = function(userid, completion) {
        var selfCompletionActive = false,
            alreadyMarked = false;

        if ($mmSite.getUserId() != userid) {
            return false;
        }

        angular.forEach(completion.completions, function(criteria) {
            if (criteria.type === 1) {
                // Self completion criteria found.
                selfCompletionActive = true;
                alreadyMarked = criteria.complete;
            }
        });

        return selfCompletionActive && !alreadyMarked;
    };

    /**
     * Get completed status text. The language code returned is meant to be translated.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#getCompletedStatusText
     * @param {Object} completion Course completion.
     * @return {Promise}          Language code of the text to show.
     */
    self.getCompletedStatusText = function(completion) {
        if (completion.completed) {
            return 'mma.coursecompletion.completed';
        } else {
            // Let's calculate status.
            var hasStarted = false;
            angular.forEach(completion.completions, function(criteria) {
                if (criteria.timecompleted || criteria.complete) {
                    hasStarted = true;
                }
            });
            if (hasStarted) {
                return 'mma.coursecompletion.inprogress';
            } else {
                return 'mma.coursecompletion.notyetstarted';
            }
        }
    };

    /**
     * Get course completion status for a certain course and user.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#getCompletion
     * @param {Number} courseid Course ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise}        Promise to be resolved when the completion is retrieved.
     */
    self.getCompletion = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();

        $log.debug('Get completion for course ' + courseid + ' and user ' + userid);

        var data = {
                courseid : courseid,
                userid: userid
            },
            preSets = {
                cacheKey: getCompletionCacheKey(courseid, userid)
            };

        return $mmSite.read('core_completion_get_course_completion_status', data, preSets).then(function(data) {
            if (data.completionstatus) {
                return data.completionstatus;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for get completion WS calls.
     *
     * @param {Number} courseid Course ID.
     * @param {Number} userid   User ID.
     * @return {String}         Cache key.
     */
    function getCompletionCacheKey(courseid, userid) {
        return 'mmaCourseCompletion:view:' + courseid + ':' + userid;
    }

    /**
     * Invalidates view course completion WS call.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#invalidateCourseCompletion
     * @param {Number} courseid Course ID.
     * @param {Number} [userid] User ID. If not defined, use current user.
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateCourseCompletion = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();
        return $mmSite.invalidateWsCacheForKey(getCompletionCacheKey(courseid, userid));
    };

    /**
     * Returns whether or not the view course completion plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#isPluginViewEnabled
     * @return {Boolean} True if plugin enabled, false otherwise.
     */
    self.isPluginViewEnabled = function() {
        if (!$mmSite.isLoggedIn()) {
            return false;
        } else if (!$mmSite.wsAvailable('core_completion_get_course_completion_status')) {
            return false;
        }

        return true;
    };

    /**
     * Returns whether or not the view course completion plugin is enabled for a certain course.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#isPluginViewEnabledForCourse
     * @param {Number} courseId Course ID.
     * @return {Promise}        Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginViewEnabledForCourse = function(courseId) {
        if (!courseId) {
            return $q.reject();
        }

        return $mmCourses.getUserCourse(courseId, true).then(function(course) {
            if (course && typeof course.enablecompletion != 'undefined' && !course.enablecompletion) {
                return false;
            }
            return true;
        });
    };

    /**
     * Returns whether or not the self completion is available in current site.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#isSelfCompletionAvailable
     * @return {Boolean} True if self completion is available, false otherwise.
     */
    self.isSelfCompletionAvailable = function() {
        return $mmSite.wsAvailable('core_completion_mark_course_self_completed');
    };

    /**
     * Mark a course as self completed.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletion#markCourseAsSelfCompleted
     * @param {Number} courseid Course ID.
     * @return {Promise}        Resolved on success.
     */
    self.markCourseAsSelfCompleted = function(courseid) {
        var params = {
            courseid: courseid
        };

        return $mmSite.write('core_completion_mark_course_self_completed', params).then(function(response) {
            if (!response.status) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.coursecompletion')

/**
 * Course completion handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.coursecompletion
 * @ngdoc service
 * @name $mmaCourseCompletionHandlers
 */
.factory('$mmaCourseCompletionHandlers', ["$mmaCourseCompletion", "$state", "mmCoursesAccessMethods", function($mmaCourseCompletion, $state, mmCoursesAccessMethods) {

    var self = {};

    /**
     * View user completion handler.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletionHandlers#viewCompletion
     */
    self.viewCompletion = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaCourseCompletion.isPluginViewEnabled();
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User to check.
         * @param {Number} courseId Course ID.
         * @return {Boolean}        True if handler is enabled, false otherwise.
         */
        self.isEnabledForUser = function(user, courseId) {
            return $mmaCourseCompletion.isPluginViewEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Object} user     Course ID.
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(user, courseId) {

            /**
             * View course completion handler controller.
             *
             * @module mm.addons.coursecompletion
             * @ngdoc controller
             * @name $mmaCourseCompletionHandlers#viewCompletion:controller
             */
            return function($scope) {

                // Button title.
                $scope.title = 'mma.coursecompletion.viewcoursereport';

                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.course-completion', {
                        userid: user.id,
                        course: {id: courseId}
                    });

                };
            };

        };

        return self;
    };

    /**
     * Course nav handler.
     *
     * @module mm.addons.coursecompletion
     * @ngdoc method
     * @name $mmaCourseCompletionHandlers#coursesNav
     */
    self.coursesNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaCourseCompletion.isPluginViewEnabled();
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean}          True if handler is enabled, false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return $mmaCourseCompletion.isPluginViewEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(courseId) {

            /**
             * Courses nav handler controller.
             *
             * @module mm.addons.coursecompletion
             * @ngdoc controller
             * @name $mmaCourseCompletionHandlers#coursesNav:controller
             */
            return function($scope, $state) {
                $scope.icon = 'ion-android-checkbox-outline';
                $scope.title = 'mma.coursecompletion.coursecompletion';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.course-completion', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Controller to upload any kind of file on iOS. Lets the user choose the site he wants to upload the file to.
 *
 * @module mm.addons.files
 * @ngdoc controller
 * @name mmaFilesChooseSiteCtrl
 */
.controller('mmaFilesChooseSiteCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmaFilesHelper", "$ionicHistory", function($scope, $state, $stateParams, $mmSitesManager, $mmaFilesHelper, $ionicHistory) {

    var fileEntry = $stateParams.file || {};
    $scope.filename = fileEntry.name;

    $mmSitesManager.getSites().then(function(sites) {
        $scope.sites = sites;
    });

    $scope.uploadInSite = function(siteid) {
        $mmaFilesHelper.showConfirmAndUploadInSite(fileEntry, siteid).then(function() {
            $ionicHistory.nextViewOptions({
                disableBack: true
            });
            $state.go('site.mm_courses');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.controller('mmaFilesIndexController', ["$scope", "$mmaFiles", "$mmSite", "$mmUtil", "$mmApp", "$state", function($scope, $mmaFiles, $mmSite, $mmUtil, $mmApp, $state) {

    $scope.canAccessFiles = $mmaFiles.canAccessFiles;
    $scope.showPrivateFiles = function() {
        return $mmaFiles.canAccessFiles() && $mmSite.canAccessMyFiles();
    };
    $scope.showUpload = function() {
        // Show upload in this page if user can upload but he can't see the My Files option.
        return !$mmaFiles.canAccessFiles() && $mmSite.canAccessMyFiles() && $mmSite.canUploadFiles();
    };
    $scope.canDownload = $mmSite.canDownloadFiles;

    $scope.add = function() {
        if (!$mmApp.isOnline()) {
            $mmUtil.showErrorModal('mma.files.errormustbeonlinetoupload', true);
        } else {
            $state.go('site.files-upload');
        }
    };

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.controller('mmaFilesListController', ["$q", "$scope", "$stateParams", "$mmaFiles", "$mmSite", "$translate", "$mmUtil", "$ionicHistory", "mmaFilesUploadStateName", "$state", "$mmApp", "mmaFilesMyComponent", "mmaFilesSiteComponent", function($q, $scope, $stateParams, $mmaFiles, $mmSite, $translate, $mmUtil,
        $ionicHistory, mmaFilesUploadStateName, $state, $mmApp, mmaFilesMyComponent, mmaFilesSiteComponent) {

    var path = $stateParams.path,
        root = $stateParams.root,
        title,
        promise;

    // We're loading the files.
    $scope.count = -1;
    $scope.component = root === 'my' ? mmaFilesMyComponent : mmaFilesSiteComponent;

    // Convenience function that fetches the files and updates the scope.
    function fetchFiles(root, path) {
        if (!path) {
            // The path is unknown, the user must be requesting a root.
            if (root === 'site') {
                promise = $mmaFiles.getSiteFiles();
                title = $translate('mma.files.sitefiles');
            } else if (root === 'my') {
                promise = $mmaFiles.getMyFiles();
                title = $translate('mma.files.myprivatefiles');
            } else {
                // Upon error we create a fake promise that is rejected.
                promise = $q.reject();
                title = (function() {
                    var q = $q.defer();
                    q.resolve('');
                    return q.promise;
                })();
            }
        } else {
            // Serve the files the user requested.
            pathdata = JSON.parse(path);
            promise = $mmaFiles.getFiles(pathdata);

            // Put the title in a promise to act like translate does.
            title = (function() {
                var q = $q.defer();
                q.resolve($stateParams.title);
                return q.promise;
            })();
        }

        return $q.all([promise, title]).then(function(data) {
            var files = data[0],
                title = data[1];

            $scope.files = files.entries;
            $scope.count = files.count;
            $scope.title = title;
        }, function() {
            $mmUtil.showErrorModal('mma.files.couldnotloadfiles', true);
        });
    }

    fetchFiles(root, path).finally(function() {
        $scope.filesLoaded = true;
    });

    $scope.refreshFiles = function() {
        $mmaFiles.invalidateDirectory(root, path).finally(function() {
            fetchFiles(root, path).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    // Update list if we come from upload page (we don't know if user upoaded a file or not).
    // List is invalidated in upload state after uploading a file.
    $scope.$on('$ionicView.enter', function(e) {
        var forwardView = $ionicHistory.forwardView();
        if (forwardView && forwardView.stateName === mmaFilesUploadStateName) {
            $scope.filesLoaded = false;
            fetchFiles(root, path).finally(function() {
                $scope.filesLoaded = true;
            });
        }
    });

    $scope.showUpload = function() {
        return (root === 'my' && !path && $mmSite.canUploadFiles());
    };

    // When we are in the root of the private files we can add more files.
    $scope.add = function() {
        if (!$mmApp.isOnline()) {
            $mmUtil.showErrorModal('mma.files.errormustbeonlinetoupload', true);
        } else {
            $state.go('site.files-upload', {root: root, path: path});
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Controller to upload any kind of file.
 *
 * @module mm.addons.files
 * @ngdoc controller
 * @name mmaFilesUploadCtrl
 */
.controller('mmaFilesUploadCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaFilesHelper", "$ionicHistory", "$mmaFiles", "$mmApp", function($scope, $stateParams, $mmUtil, $mmaFilesHelper, $ionicHistory, $mmaFiles, $mmApp) {

    var uploadMethods = {
            album: $mmaFilesHelper.uploadImageFromAlbum,
            camera: $mmaFilesHelper.uploadImageFromCamera,
            audio: $mmaFilesHelper.uploadAudio,
            video: $mmaFilesHelper.uploadVideo
        },
        path = $stateParams.path,
        root = $stateParams.root;

    $scope.isAndroid = ionic.Platform.isAndroid();

    // Function called when a file is uploaded.
    function successUploading() {
        $mmaFiles.invalidateDirectory(root, path).finally(function() {
            $mmUtil.showModal('mm.core.success', 'mma.files.fileuploaded');
            $ionicHistory.goBack();
        });
    }

    // Function called when a file upload fails.
    function errorUploading(err) {
        if (err) {
            $mmUtil.showErrorModal(err);
        }
    }

    $scope.upload = function(type) {
        if (!$mmApp.isOnline()) {
            $mmUtil.showErrorModal('mma.files.errormustbeonlinetoupload', true);
        } else {
            if (typeof(uploadMethods[type]) !== 'undefined') {
                uploadMethods[type]().then(successUploading, errorUploading);
            }
        }
    };

    $scope.uploadFile = function(evt) {
        var input = evt.srcElement;
        var file = input.files[0];
        input.value = ''; // Unset input.
        if (file) {
            $mmaFilesHelper.confirmUploadFile(file.size).then(function() {
                // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
                $mmaFilesHelper.copyAndUploadFile(file).then(successUploading, errorUploading);
            }, errorUploading);
        }
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Directive to detect chanegs on file inputs (ng-Change doesn't work in that type of input).
 *
 * @module mm.addons.files
 * @ngdoc directive
 * @name mmaFilesOnChange
 */
.directive('mmaFilesOnChange', function() {
  return {
    restrict: 'A',
    link: function (scope, element, attrs) {
      var onChangeHandler = scope.$eval(attrs.mmaFilesOnChange);
      element.bind('change', onChangeHandler);
    }
  };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.config(["$mmAppProvider", "mmaFilesSharedFilesStore", function($mmAppProvider, mmaFilesSharedFilesStore) {
    var stores = [
        {
            name: mmaFilesSharedFilesStore,
            keyPath: 'id'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])

.factory('$mmaFiles', ["$mmSite", "$mmFS", "$q", "$timeout", "$log", "$mmSitesManager", "$mmApp", "md5", "mmaFilesSharedFilesStore", function($mmSite, $mmFS, $q, $timeout, $log, $mmSitesManager, $mmApp, md5,
            mmaFilesSharedFilesStore) {

    $log = $log.getInstance('$mmaFiles');

    var self = {},
        defaultParams = {
            "contextid": 0,
            "component": "",
            "filearea": "",
            "itemid": 0,
            "filepath": "",
            "filename": ""
        };

    /**
     * Check if core_files_get_files WS call is available.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#canAccessFiles
     * @return {Boolean} True if WS is available, false otherwise.
     */
    self.canAccessFiles = function() {
        return $mmSite.wsAvailable('core_files_get_files');
    };

    /**
     * Checks if there is a new file received in iOS. If more than one file is found, treat only the first one.
     * The file returned is marked as "treated" and will be deleted in the next execution.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#checkIOSNewFiles
     * @return {Promise} Promise resolved with a new file to be treated. If no new files found, promise is rejected.
     */
    self.checkIOSNewFiles = function() {

        var deferred = $q.defer();

        $log.debug('Search for new files on iOS');
        $mmFS.getDirectoryContents('Inbox').then(function(entries) {

            if (entries.length > 0) {

                var promises = [];
                angular.forEach(entries, function(entry) {

                    var fileDeferred = $q.defer(),
                        fileId = md5.createHash(entry.name);

                    // Check if file was already treated.
                    $mmApp.getDB().get(mmaFilesSharedFilesStore, fileId).then(function() {
                        // File already treated. Delete it.
                        $log.debug('Delete already treated file: ' + entry.name);
                        fileDeferred.resolve();

                        entry.remove(function() {
                            $log.debug('File deleted: ' + entry.name);
                            $mmApp.getDB().remove(mmaFilesSharedFilesStore, fileId).then(function() {
                                $log.debug('"Treated" mark removed from file: ' + entry.name);
                            }, function() {
                                $log.debug('Error deleting "treated" mark from file: ' + entry.name);
                            });
                        }, function() {
                            $log.debug('Error deleting file in Inbox: ' + entry.name);
                        });

                    }, function() {
                        // File not treated before, send it to resolve so it's a candidate to be notified.
                        $log.debug('Found new file ' + entry.name + ' shared with the app.');
                        fileDeferred.resolve(entry);
                    });

                    promises.push(fileDeferred.promise);
                });

                $q.all(promises).then(function(responses) {
                    var fileToReturn,
                        fileId;
                    for (var i = 0; i < responses.length; i++) {
                        if (typeof(responses[i]) !== 'undefined') {
                            // Found new entry to treat.
                            fileToReturn = responses[i];
                            break;
                        }
                    }
                    if (fileToReturn) {
                        fileId = md5.createHash(fileToReturn.name);
                        // Mark it as "treated".
                        $mmApp.getDB().insert(mmaFilesSharedFilesStore, {id: fileId}).then(function() {
                            $log.debug('File marked as "treated": ' + fileToReturn.name);
                            deferred.resolve(fileToReturn);
                        }, function() {
                            $log.debug('Error marking file as "treated": ' + fileToReturn.name);
                            deferred.reject();
                        });
                    } else {
                        deferred.reject();
                    }
                }, deferred.reject);
            } else {
                deferred.reject();
            }
        });

        return deferred.promise;
    };

    /**
     * Get the list of files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#getFiles
     * @param  {Object} params A list of parameters accepted by the Web service.
     * @return {Object}        An object containing the files in the key 'entries', and 'count'.
     *                         Additional properties is added to the entries, such as:
     *                          - imgpath: The path to the icon.
     *                          - link: The JSON string of params to get to the file.
     *                          - linkId: A hash of the file parameters.
     */
    self.getFiles = function(params) {
        var deferred = $q.defer(),
            options = {};

        options.cacheKey = getFilesListCacheKey(params);

        $mmSite.read('core_files_get_files', params, options).then(function(result) {
            var data = {
                entries: [],
                count: 0
            };

            if (typeof result.files == 'undefined') {
                deferred.reject();
                return;
            }

            angular.forEach(result.files, function(entry) {
                entry.link = {};
                entry.link.contextid = (entry.contextid) ? entry.contextid : "";
                entry.link.component = (entry.component) ? entry.component : "";
                entry.link.filearea = (entry.filearea) ? entry.filearea : "";
                entry.link.itemid = (entry.itemid) ? entry.itemid : 0;
                entry.link.filepath = (entry.filepath) ? entry.filepath : "";
                entry.link.filename = (entry.filename) ? entry.filename : "";

                if (entry.component && entry.isdir) {
                    // Delete unused elements that may break the request.
                    entry.link.filename = "";
                }

                if (entry.isdir) {
                    entry.imgpath = $mmFS.getFolderIcon();
                } else {
                    entry.imgpath = $mmFS.getFileIcon(entry.filename);
                }

                entry.link = JSON.stringify(entry.link);
                entry.linkId = md5.createHash(entry.link);
                // entry.localpath = "";

                // if (!entry.isdir && entry.url) {
                //     // TODO Check $mmSite.
                //     var uniqueId = $mmSite.id + "-" + md5.createHash(entry.url);
                //     var path = MM.db.get("files", uniqueId);
                //     if (path) {
                //         entry.localpath = path.get("localpath");
                //     }
                // }

                data.count += 1;
                data.entries.push(entry);
            });

            deferred.resolve(data);
        }, function() {
            deferred.reject();
        });

        return deferred.promise;
    };

    /**
     * Get cache key for file list WS calls.
     *
     * @param  {Object} params Params of the directory to get.
     * @return {String}        Cache key.
     */
    function getFilesListCacheKey(params) {
        var root = params.component === '' ? 'site' : 'my';
        return 'mmaFiles:list:' + root + ':' + params.contextid + ':' + params.filepath;
    }

    /**
     * Get the private files of the current user.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#getMyFiles
     * @return {Object} See $mmaFiles#getFiles
     */
    self.getMyFiles = function() {
        var params = getMyFilesRootParams();
        return self.getFiles(params);
    };

    /**
     * Get the common part of the cache keys for private files WS calls.
     *
     * @return {String} Cache key.
     */
    function getMyFilesListCommonCacheKey() {
        return 'mmaFiles:list:my';
    }

    /**
     * Get params to get root private files directory.
     *
     * @return {Object} Params.
     */
    function getMyFilesRootParams() {
        var params = angular.copy(defaultParams, {});
        params.component = "user";
        params.filearea = "private";
        params.contextid = -1;
        params.contextlevel = "user";
        params.instanceid = $mmSite.getUserId();
        return params;
    }

    /**
     * Get the site files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#getSiteFiles
     * @return {Object} See $mmaFiles#getFiles
     */
    self.getSiteFiles = function() {
        var params = angular.copy(defaultParams, {});
        return self.getFiles(params);
    };

    /**
     * Get the common part of the cache keys for site files WS calls.
     *
     * @return {String} Cache key.
     */
    function getSiteFilesListCommonCacheKey() {
        return 'mmaFiles:list:site';
    }

    /**
     * Invalidates list of files in a certain directory.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#invalidateDirectory
     * @param  {String} root     Root of the directory ('my' for private files, 'site' for site files).
     * @param  {String} path     Path to the directory.
     * @param  {String} [siteid] Id of the site to invalidate. If not defined, use current site.
     * @return {Promise}         Promise resolved when the list is invalidated.
     */
    self.invalidateDirectory = function(root, path, siteid) {
        siteid = siteid || $mmSite.getId();

        var params = {};
        if (!path) {
            if (root === 'site') {
                params = angular.copy(defaultParams, {});
            } else if (root === 'my') {
                params = getMyFilesRootParams();
            }
        } else {
            params = JSON.parse(path);
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {
            site.invalidateWsCacheForKey(getFilesListCacheKey(params));
        });
    };

    /**
     * Invalidates list of private files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#invalidateMyFiles
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateMyFiles = function() {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getMyFilesListCommonCacheKey());
    };

    /**
     * Invalidates list of site files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#invalidateSiteFiles
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateSiteFiles = function() {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getSiteFilesListCommonCacheKey());
    };

    /**
     * Return whether or not the plugin is enabled. Plugin is enabled if:
     *     - Site supports core_files_get_files
     *     or
     *     - User has capability moodle/user:manageownfiles and WS allows uploading files.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#isPluginEnabled
     * @return {Boolean}
     */
    self.isPluginEnabled = function() {
        var canAccessFiles = self.canAccessFiles(),
            canAccessMyFiles = $mmSite.canAccessMyFiles(),
            canUploadFiles = $mmSite.canUploadFiles();

        return canAccessFiles || (canUploadFiles && canAccessMyFiles);
    };

    /**
     * Upload a file.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadFile
     * @param  {Object} uri      File URI.
     * @param  {Object} options  Options for the upload.
     *                           - {Boolean} deleteAfterUpload Whether or not to delete the original after upload.
     *                           - {String} fileKey
     *                           - {String} fileName
     *                           - {String} mimeType
     * @param  {String} [siteid] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}
     */
    self.uploadFile = function(uri, options, siteid) {
        options = options || {};
        siteid = siteid || $mmSite.getId();

        var deleteAfterUpload = options.deleteAfterUpload,
            deferred = $q.defer(),
            ftOptions = {
                fileKey: options.fileKey,
                fileName: options.fileName,
                mimeType: options.mimeType
            };

        function deleteFile() {
            $timeout(function() {
                // Use set timeout, otherwise in Node-Webkit the upload threw an error sometimes.
                $mmFS.removeExternalFile(uri);
            }, 500);
        }

        $mmSitesManager.getSite(siteid).then(function(site) {
            site.uploadFile(uri, ftOptions).then(deferred.resolve, deferred.reject, deferred.notify).finally(function() {
                if (deleteAfterUpload) {
                    deleteFile();
                }
            });
        }, function() {
            if (deleteAfterUpload) {
                deleteFile();
            }
            deferred.reject(error);
        });

        return deferred.promise;
    };

    /**
     * Upload image.
     * @todo Handle Node Webkit.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadImage
     * @param  {String}  uri         File URI.
     * @param  {Boolean} isFromAlbum True if the image was taken from album, false if it's a new image taken with camera.
     * @return {Promise}
     */
    self.uploadImage = function(uri, isFromAlbum) {
        $log.debug('Uploading an image');
        var d = new Date(),
            options = {};

        if (typeof(uri) === 'undefined' || uri === ''){
            // In Node-Webkit, if you successfully upload a picture and then you open the file picker again
            // and cancel, this function is called with an empty uri. Let's filter it.
            $log.debug('Received invalid URI in $mmaFiles.uploadImage()');
            return $q.reject();
        }

        options.deleteAfterUpload = !isFromAlbum;
        options.fileKey = "file";
        options.fileName = "image_" + d.getTime() + ".jpg";
        options.mimeType = "image/jpeg";

        return self.uploadFile(uri, options);
    };

    /**
     * Upload media.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadMedia
     * @param  {Array} mediaFiles Array of file objects.
     * @return {Array} Array of promises.
     */
    self.uploadMedia = function(mediaFiles) {
        $log.debug('Uploading media');
        var promises = [];
        angular.forEach(mediaFiles, function(mediaFile, index) {
            var options = {};
            options.fileKey = null;
            options.fileName = mediaFile.name;
            options.mimeType = null;
            options.deleteAfterUpload = true;
            promises.push(self.uploadFile(mediaFile.fullPath, options));
        });
        return promises;
    };

    /**
     * Upload a file of any type.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFiles#uploadGenericFile
     * @param  {String} uri      File URI.
     * @param  {String} name     File name.
     * @param  {String} type     File type.
     * @param  {String} [siteid] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}     Promise resolved when the file is uploaded.
     */
    self.uploadGenericFile = function(uri, name, type, siteid) {
        var options = {};
        options.fileKey = null;
        options.fileName = name;
        options.mimeType = type;
        // Don't delete the file on iOS, it's going to be deleted on $mmaFiles#checkIOSNewFiles.
        options.deleteAfterUpload = !ionic.Platform.isIOS();

        return self.uploadFile(uri, options, siteid);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

/**
 * Files handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.files
 * @ngdoc service
 * @name $mmaFilesHandlers
 */
.factory('$mmaFilesHandlers', ["$log", "$mmaFiles", function($log, $mmaFiles) {
    $log = $log.getInstance('$mmaFilesHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaFiles.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.files
             * @ngdoc controller
             * @name $mmaFilesHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-folder';
                $scope.title = 'mma.files.myfiles';
                $scope.state = 'site.files';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.files')

.constant('mmaFilesFileSizeWarning', 5242880)

.factory('$mmaFilesHelper', ["$q", "$mmUtil", "$mmApp", "$log", "$translate", "$window", "$mmaFiles", "$cordovaCamera", "$cordovaCapture", "$mmLang", "$mmFS", "$mmText", "mmaFilesFileSizeWarning", function($q, $mmUtil, $mmApp, $log, $translate, $window,
        $mmaFiles, $cordovaCamera, $cordovaCapture, $mmLang, $mmFS, $mmText, mmaFilesFileSizeWarning) {

    $log = $log.getInstance('$mmaFilesHelper');

    var self = {};

    /**
     * Convenient helper for the user to upload an image from an album.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadImageFromAlbum
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadImageFromAlbum = function() {
        $log.debug('Trying to get a image from albums');
        var deferred = $q.defer();

        var width  =  $window.innerWidth  - 200;
        var height =  $window.innerHeight - 200;

        // iPad popOver, see https://tracker.moodle.org/browse/MOBILE-208
        var popover = new CameraPopoverOptions(10, 10, width, height, Camera.PopoverArrowDirection.ARROW_ANY);
        $cordovaCamera.getPicture({
            quality: 50,
            destinationType: navigator.camera.DestinationType.FILE_URI,
            sourceType: navigator.camera.PictureSourceType.PHOTOLIBRARY,
            popoverOptions : popover
        }).then(function(img) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $mmaFiles.uploadImage(img, true).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatImageError(error, deferred, 'mma.files.errorgettingimagealbum');
        });

        return deferred.promise;
    };

    /**
     * Convenient helper for the user to take an image with the camera and upload it.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadImageFromCamera
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadImageFromCamera = function() {
        $log.debug('Trying to capture an image with camera');
        var deferred = $q.defer();

        $cordovaCamera.getPicture({
            quality: 50,
            destinationType: navigator.camera.DestinationType.FILE_URI
        }).then(function(img) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $mmaFiles.uploadImage(img, false).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatImageError(error, deferred, 'mma.files.errorcapturingimage');
        });

        return deferred.promise;
    };

    /**
     * Convenient helper for the user to record and upload an audio.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadAudio
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadAudio = function() {
        $log.debug('Trying to record an audio file');
        var deferred = $q.defer();

        $cordovaCapture.captureAudio({limit: 1}).then(function(medias) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $q.all($mmaFiles.uploadMedia(medias)).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatCaptureError(error, deferred, 'mma.files.errorcapturingaudio');
        });

        return deferred.promise;
    };

    /**
     * Convenient helper for the user to record and upload a video.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadVideo
     * @return {Promise} The reject contains the error message, if there is no error message
     *                   then we can consider that this is a silent fail.
     */
    self.uploadVideo = function() {
        $log.debug('Trying to record a video file');
        var deferred = $q.defer();

        $cordovaCapture.captureVideo({limit: 1}).then(function(medias) {
            var modal = $mmUtil.showModalLoading('mma.files.uploading', true);
            $q.all($mmaFiles.uploadMedia(medias)).then(function() {
                // Success.
                deferred.resolve();
            }, function() {
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
            }).finally(function() {
                modal.dismiss();
            });

        }, function(error) {
            treatCaptureError(error, deferred, 'mma.files.errorcapturingvideo');
        });

        return deferred.promise;
    };

    /**
     * Show a confirmation modal to the user if he is using a limited connection or the file size is higher than 5MB.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#confirmUploadFile
     * @param  {Number} size File's size.
     * @return {Promise}     Promise resolved when the user confirms or if there's no need to show a modal.
     */
    self.confirmUploadFile = function(size) {
        if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mma.files.errormustbeonlinetoupload');
        }

        if ($mmApp.isNetworkAccessLimited() || size >= mmaFilesFileSizeWarning) {
             var size = $mmText.bytesToSize(size, 2);
            return $mmUtil.showConfirm($translate('mma.files.confirmuploadfile', {size: size}));
        } else {
            var deferred = $q.defer();
            deferred.resolve();
            return deferred.promise;
        }
    };

    /**
     * Create a temporary copy of a file and upload it.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#copyAndUploadFile
     * @param {Object} file File to copy and upload.
     * @return {Promise}    Promise resolved when the file is uploaded.
     */
    self.copyAndUploadFile = function(file) {
        var deferred = $q.defer();

        var modal = $mmUtil.showModalLoading('mma.files.readingfile', true);

        // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
        $mmFS.readFileData(file, $mmFS.FORMATARRAYBUFFER).then(function(data) {

            var filepath = $mmFS.getTmpFolder() + '/' + file.name;

            $mmFS.writeFile(filepath, data).then(function(fileEntry) {
                modal.dismiss();
                self.uploadGenericFile(fileEntry.toURL(), file.name, file.type).then(deferred.resolve, deferred.reject);
            }, function(error) {
                $log.error('Error writing file to upload: '+JSON.stringify(error));
                $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorreadingfile');
                modal.dismiss();
            });

        }, function(error) {
            $log.error('Error reading file to upload: '+JSON.stringify(error));
            $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorreadingfile');
            modal.dismiss();
        });

        return deferred.promise;
    };

    /**
     * Uploads a file of any type.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#uploadGenericFile
     * @param  {String} uri      File URI.
     * @param  {String} name     File name.
     * @param  {String} type     File type.
     * @param  {String} [siteid] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}         Promise resolved when the file is uploaded.
     */
    self.uploadGenericFile = function(uri, name, type, siteid) {
        var deferred = $q.defer();

        if (!$mmApp.isOnline()) {
            $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errormustbeonlinetoupload');
            return deferred.promise;
        }

        var modal = $mmUtil.showModalLoading('mma.files.uploading', true);

        $mmaFiles.uploadGenericFile(uri, name, type, siteid).then(deferred.resolve, function(error) {
            $log.error('Error uploading file: '+JSON.stringify(error));
            $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errorwhileuploading');
        }).finally(function() {
            modal.dismiss();
        });

        return deferred.promise;
    };

    /**
     * Convenience function to upload a file on a certain site, showing a confirm if needed.
     *
     * @module mm.addons.files
     * @ngdoc method
     * @name $mmaFilesHelper#showConfirmAndUploadInSite
     * @param  {String} fileEntry FileEntry of the file to upload.
     * @param  {String} [siteid]  Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise}          Promise resolved when the file is uploaded.
     */
    self.showConfirmAndUploadInSite = function(fileEntry, siteid) {
        return $mmFS.getFileObjectFromFileEntry(fileEntry).then(function(file) {
            return self.confirmUploadFile(file.size).then(function() {
                return self.uploadGenericFile(fileEntry.toURL(), file.name, file.type, siteid).then(function() {
                    // Invalidate my files root dir so the list is refreshed when the user goes in.
                    return $mmaFiles.invalidateDirectory('my', undefined, siteid).finally(function() {
                        $mmUtil.showModal('mm.core.success', 'mma.files.fileuploaded');
                    });
                }, function(err) {
                    if (err) {
                        $mmUtil.showErrorModal(err);
                    }
                    return $q.reject();
                });
            }, function(err) {
                if (err) {
                    $mmUtil.showErrorModal(err);
                }
                return $q.reject();
            });
        }, function() {
            $mmUtil.showErrorModal('mma.files.errorreadingfile', true);
            return $q.reject();
        });
    }

    /**
     * Treat a capture image or browse album error.
     *
     * @param  {String} error          Error returned by the Cordova plugin.
     * @param  {Promise} deferred      Promise to reject.
     * @param  {String} defaultMessage Key of the default message to show.
     */
    function treatImageError(error, deferred, defaultMessage) {
        // Cancelled, or error. If cancelled, error is a string with "Selection cancelled." or "Camera cancelled.".
        if (error) {
            if (typeof(error) === 'string') {
                if (error.toLowerCase().indexOf("error") > -1 || error.toLowerCase().indexOf("unable") > -1) {
                    $log.error('Error getting image: ' + error);
                    deferred.reject(error);
                } else {
                    $log.debug('Cancelled');
                    deferred.reject();
                }
            } else {
                $mmLang.translateAndRejectDeferred(deferred, defaultMessage);
            }
        } else {
            deferred.reject();
        }
    }

    /**
     * Treat a capture audio/video error.
     *
     * @param  {Mixed} error           Error returned by the Cordova plugin. Can be a string or an object.
     * @param  {Promise} deferred      Promise to reject.
     * @param  {String} defaultMessage Key of the default message to show.
     */
    function treatCaptureError(error, deferred, defaultMessage) {
        // Cancelled, or error. If cancelled, error is an object with code = 3.
        if (error) {
            if (typeof(error) === 'string') {
                $log.error('Error while recording audio/video: ' + error);
                if (error.indexOf('No Activity found') > -1) {
                    // User doesn't have an app to do this.
                    $mmLang.translateAndRejectDeferred(deferred, 'mma.files.errornoapp');
                } else {
                    $mmLang.translateAndRejectDeferred(deferred, defaultMessage);
                }
            } else {
                if (error.code != 3) {
                    // Error, not cancelled.
                    $log.error('Error while recording audio/video: ' + JSON.stringify(error));
                    $mmLang.translateAndRejectDeferred(deferred, defaultMessage);
                } else {
                    $log.debug('Cancelled');
                    deferred.reject();
                }
            }
        } else {
            deferred.reject();
        }
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.frontpage')

/**
 * Frontpage factory.
 *
 * @module mm.addons.frontpage
 * @ngdoc service
 * @name $mmaFrontpage
 */
.factory('$mmaFrontpage', ["$mmSite", "$log", "$q", "$mmCourse", function($mmSite, $log, $q, $mmCourse) {
    $log = $log.getInstance('$mmaFrontpage');

    var self = {};

    /**
     * Returns whether or not the plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.frontpage
     * @ngdoc method
     * @name $mmaFrontpage#isPluginEnabled
     * @return {Boolean}
     */
    self.isPluginEnabled = function() {

        if (!$mmSite.isLoggedIn()) {
            return false;
        }

        return true;
    };

    /**
     * Returns whether or not the frontpage is available for the current site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @module mm.addons.frontpage
     * @ngdoc method
     * @name $mmaFrontpage#isFrontpageAvailable
     * @return {Promise} Resolved when enabled, otherwise rejected.
     */
    self.isFrontpageAvailable = function() {

        // On older version we cannot check other than calling a WS. If the request
        // fails there is a very high chance that frontpage is not available.
        $log.debug('Using WS call to check if frontpage is available.');
        return $mmCourse.getSections(1, {emergencyCache: false}).then(function(data) {
            if (!angular.isArray(data) || data.length == 0) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.frontpage')

/**
 * Front page handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.frontpage
 * @ngdoc service
 * @name $mmaFrontPageHandlers
 */
.factory('$mmaFrontPageHandlers', ["$log", "$mmaFrontpage", function($log, $mmaFrontpage) {
    $log = $log.getInstance('$mmaFrontPageHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.frontpage
     * @ngdoc method
     * @name $mmaFrontPageHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Promise|Boolean} If handler is enabled returns a resolved promise. If it's not it can return a
         *                           rejected promise or false.
         */
        self.isEnabled = function() {
            if ($mmaFrontpage.isPluginEnabled()) {
                return $mmaFrontpage.isFrontpageAvailable().then(function() {
                    return true;
                });
            }
            return false;
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.frontpage
             * @ngdoc controller
             * @name $mmaFrontPageHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-home';
                $scope.title = 'mma.frontpage.sitehome';
                $scope.state = 'site.mm_course-section';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades')

/**
 * Controller to handle course grades.
 *
 * @module mm.addons.grades
 * @ngdoc controller
 * @name mmaGradesTableCtrl
 */
.controller('mmaGradesTableCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaGrades", "$mmSite", function($scope, $stateParams, $mmUtil, $mmaGrades, $mmSite) {

    var course = $stateParams.course || {},
        courseid = course.id,
        userid = $stateParams.userid || $mmSite.getUserId();

    function fetchGrades(refresh) {
        return $mmaGrades.getGradesTable(courseid, userid, refresh).then(function(table) {
            $scope.gradesTable = table;
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.errormessage = message;
        });
    }
    fetchGrades().then(function() {
        // Add log in Moodle.
        $mmSite.write('gradereport_user_view_grade_report', {
            courseid: courseid,
            userid: userid
        });
    })
    .finally(function() {
        $scope.gradesLoaded = true;
    });

    $scope.refreshGrades = function() {
        fetchGrades(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades')

/**
 * Service to handle grades.
 *
 * @module mm.addons.grades
 * @ngdoc service
 * @name $mmaGrades
 */
.factory('$mmaGrades', ["$q", "$log", "$mmSite", "$mmText", "$ionicPlatform", "$translate", "$mmCourse", "$mmCourses", "$mmSitesManager", function($q, $log, $mmSite, $mmText, $ionicPlatform, $translate, $mmCourse, $mmCourses, $mmSitesManager) {

    $log = $log.getInstance('$mmaGrades');

    var self = {};

    /**
     * Formats the response of gradereport_user_get_grades_table to be rendered.
     *
     * @param  {Object}  table      JSON object representing a table with data.
     * @param  {Boolean} showSimple True if simple table should be shown, false for full table.
     * @return {Object}             Formatted HTML table.
     */
    function formatGradesTable(table, showSimple) {
        var formatted = {
            columns: [],
            rows: []
        };

        if (!table || !table.tables) {
            return formatted;
        }

        // Columns, by order.
        var columns = [ "itemname", "weight", "grade", "range", "percentage", "lettergrade", "rank",
                        "average", "feedback", "contributiontocoursetotal"];
        var returnedColumns = [];

        var tabledata = [];
        var maxDepth = 0;
        // Check columns returned (maybe some of the above).
        if (table.tables && table.tables[0] && table.tables[0]['tabledata']) {
            tabledata = table.tables[0]['tabledata'];
            maxDepth = table.tables[0]['maxdepth'];
            for (var el in tabledata) {
                // This is a typical row.
                if (!angular.isArray(tabledata[el]) && typeof(tabledata[el]["leader"]) === "undefined") {
                    for (var col in tabledata[el]) {
                        returnedColumns.push(col);
                    }
                    break;
                }
            }
        }

        if (returnedColumns.length > 0) {

            // Reduce the returned columns for phone version.
            if (showSimple) {
                returnedColumns = ["itemname", "grade"];
            }

            for (var el in columns) {
                var colName = columns[el];
                if (returnedColumns.indexOf(colName) > -1) {
                    var width = colName == "itemname" ? maxDepth : 1;
                    var column = {
                        id: colName,
                        name: colName,
                        width: width
                    };
                    formatted.columns.push(column);
                }
            }

            var name, rowspan, tclass, colspan, content, celltype, id, headers,j, img, colspanVal;

            var len = tabledata.length;
            for (var i = 0; i < len; i++) {
                var row = '';
                if (typeof(tabledata[i]['leader']) != "undefined") {
                    rowspan = tabledata[i]['leader']['rowspan'];
                    tclass = tabledata[i]['leader']['class'];
                    row += '<td class="' + tclass + '" rowspan="' + rowspan + '"></td>';
                }
                for (el in returnedColumns) {
                    name = returnedColumns[el];

                    if (typeof(tabledata[i][name]) != "undefined") {
                        tclass = (typeof(tabledata[i][name]['class']) != "undefined")? tabledata[i][name]['class'] : '';
                        colspan = (typeof(tabledata[i][name]['colspan']) != "undefined")? "colspan='"+tabledata[i][name]['colspan']+"'" : '';
                        content = (typeof(tabledata[i][name]['content']) != "undefined")? tabledata[i][name]['content'] : null;
                        celltype = (typeof(tabledata[i][name]['celltype']) != "undefined")? tabledata[i][name]['celltype'] : 'td';
                        id = (typeof(tabledata[i][name]['id']) != "undefined")? "id='" + tabledata[i][name]['id'] +"'" : '';
                        headers = (typeof(tabledata[i][name]['headers']) != "undefined")? "headers='" + tabledata[i][name]['headers'] + "'" : '';

                        if (typeof(content) != "undefined") {
                            img = getImgHTML(content);
                            content = content.replace(/<\/span>/gi, "\n");
                            content = $mmText.cleanTags(content);
                            content = content.replace("\n", "<br />");
                            content = img + " " + content;

                            row += "<" + celltype + " " + id + " " + headers + " " + "class='"+ tclass +"' " + colspan +">";
                            row += content;
                            row += "</" + celltype + ">";
                        }
                    }
                }
                formatted.rows.push(row);
            }
        }

        return formatted;
    }

    /**
     * Gets the HTML code to render the contents img.
     *
     * @param  {String} text HTML where the image will be rendered.
     * @return {String}      HTML code to render the image.
     */
    function getImgHTML(text) {
        var img = '';

        if (text.indexOf("/agg_mean") > -1) {
            img = '<img src="addons/grades/img/agg_mean.png" width="16">';
        } else if (text.indexOf("/agg_sum") > -1) {
            img = '<img src="addons/grades/img/agg_sum.png" width="16">';
        } else if (text.indexOf("/outcomes") > -1) {
            img = '<img src="addons/grades/img/outcomes.png" width="16">';
        } else if (text.indexOf("i/folder") > -1) {
            img = '<img src="addons/grades/img/folder.png" width="16">';
        } else if (text.indexOf("/manual_item") > -1) {
            img = '<img src="addons/grades/img/manual_item.png" width="16">';
        } else if (text.indexOf("/mod/") > -1) {
            var module = text.match(/mod\/([^\/]*)\//);
            if (typeof module[1] != "undefined") {
                var moduleSrc = $mmCourse.getModuleIconSrc(module[1]);
                img = '<img src="' + moduleSrc + '" width="16">';
            }
        }
        if (img) {
            img = '<span class="app-ico">' + img + '</span>';
        }
        return img;
    }

    /**
     * Translates the names of the grades table columns.
     *
     * @param  {Object} table Grades table.
     * @return {Promise}      Promise to be resolved with the translated table.
     */
    function translateGradesTable(table) {
        var columns = angular.copy(table.columns),
            promises = [];

        columns.forEach(function(column) {
            var promise = $translate('mma.grades.'+column.name).then(function(translated) {
                column.name = translated;
            });
            promises.push(promise);
        });

        return $q.all(promises).then(function() {
            return {
                columns: columns,
                rows: table.rows
            };
        });
    };

    /**
     * Returns whether or not the plugin is enabled for a certain site.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGrades#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Boolean}         True if plugin is enabled, false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('gradereport_user_get_grades_table');
        });
    };

    /**
     * Returns whether or not the grade addon is enabled for a certain course.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGrades#isPluginEnabledForCourse
     * @param {Number} courseId  Course ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabledForCourse = function(courseId, siteId) {
        if (!courseId) {
            return $q.reject();
        }

        return $mmCourses.getUserCourse(courseId, true, siteId).then(function(course) {
            if (course && typeof course.showgrades != 'undefined' && !course.showgrades) {
                return false;
            }
            return true;
        });
    };

    /**
     * Get the grades for a certain course.
     * For now we only support gradereport_user_get_grades_table. It returns the complete grades table.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGrades#getGradesTable
     * @param {Number} courseid ID of the course to get the grades from.
     * @param {Number} userid   ID of the user to get the grades from.
     * @param {Boolean} refresh True when we should not get the value from the cache.
     * @return {Promise}        Promise to be resolved when the grades table is retrieved.
     */
    self.getGradesTable = function(courseid, userid, refresh) {

        $log.debug('Get grades for course ' + courseid + ' and user ' + userid);

        var data = {
                courseid : courseid,
                userid   : userid
            },
            presets = {};
        if (refresh) {
            presets.getFromCache = false;
        }

        return $mmSite.read('gradereport_user_get_grades_table', data, presets).then(function(table) {
            table = formatGradesTable(table, !$ionicPlatform.isTablet());
            return translateGradesTable(table);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.grades')

/**
 * Grades handlers factory.
 *
 * @module mm.addons.grades
 * @ngdoc service
 * @name $mmaGradesHandlers
 */
.factory('$mmaGradesHandlers', ["$mmaGrades", "$state", "$mmUtil", "$mmContentLinksHelper", "mmCoursesAccessMethods", function($mmaGrades, $state, $mmUtil, $mmContentLinksHelper, mmCoursesAccessMethods) {

    var self = {};

    /**
     * Course nav handler.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGradesHandlers#coursesNav
     */
    self.coursesNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Promise} Promise resolved with true if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaGrades.isPluginEnabled();
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Promise}          Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return $mmaGrades.isPluginEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function() {

            /**
             * Courses nav handler controller.
             *
             * @module mm.addons.grades
             * @ngdoc controller
             * @name $mmaGradesHandlers#coursesNav:controller
             */
            return function($scope, $state) {
                $scope.icon = 'ion-stats-bars';
                $scope.title = 'mma.grades.grades';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.grades', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    /**
     * View grades handler.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGradesHandlers#viewGrades
     */
    self.viewGrades = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Promise} Promise resolved with true if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaGrades.isPluginEnabled();
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User to check.
         * @param {Number} courseId Course ID.
         * @return {Promise}        Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
         */
        self.isEnabledForUser = function(user, courseId) {
            return $mmaGrades.isPluginEnabledForCourse(courseId);
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User.
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(user, courseId) {

            /**
             * View grades handler controller.
             *
             * @module mm.addons.grades
             * @ngdoc controller
             * @name $mmaGradesHandlers#viewGrades:controller
             */
            return function($scope) {
                $scope.title = 'mma.grades.viewgrades';

                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.grades', {
                        userid: user.id,
                        course: {id: courseId}
                    });
                };
            };

        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.grades
     * @ngdoc method
     * @name $mmaGradesHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site and course.
         *
         * @param  {String} siteId   Site ID.
         * @param  {Number} courseId Course ID.
         * @return {Promise}         Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaGrades.isPluginEnabled(siteId).then(function(enabled) {
                if (enabled) {
                    return $mmaGrades.isPluginEnabledForCourse(courseId, siteId);
                }
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        Promise resolved with the list of actions.
         *                           See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a grade URL.
            if (url.indexOf('/grade/report/user/index.php') > -1) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    var courseId = parseInt(params.id, 10);
                    // Pass false because all sites should have the same siteurl.
                    return $mmContentLinksHelper.filterSupportedSites(siteIds, isEnabled, false, courseId).then(function(ids) {
                        if (!ids.length) {
                            return [];
                        } else {
                            // Return actions.
                            return [{
                                message: 'mm.core.view',
                                icon: 'ion-eye',
                                sites: ids,
                                action: function(siteId) {
                                    var stateParams = {
                                        course: {id: courseId},
                                        userid: parseInt(params.userid, 10)
                                    };
                                    $mmContentLinksHelper.goInSite('site.grades', stateParams, siteId);
                                }
                            }];
                        }
                    });
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Contacts controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesContactsCtrl
 */
.controller('mmaMessagesContactsCtrl', ["$scope", "$mmaMessages", "$mmSite", "$mmUtil", "$mmApp", "mmUserProfileState", function($scope, $mmaMessages, $mmSite, $mmUtil, $mmApp, mmUserProfileState) {

    var currentUserId = $mmSite.getUserId();

    $scope.loaded = false;
    $scope.contactTypes = ['online', 'offline', 'blocked', 'strangers', 'search'];
    $scope.searchType = 'search';
    $scope.hasContacts = false;
    $scope.canSearch = $mmaMessages.isSearchEnabled;
    $scope.formData = {
        searchString: ''
    };
    $scope.userStateName = mmUserProfileState;

    $scope.refresh = function() {
        $mmaMessages.invalidateAllContactsCache(currentUserId).then(function() {
            return fetchContacts(true).then(function() {
                $scope.formData.searchString = '';
            });
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.search = function(query) {
        if (query.length < 3) {
            // The view should handle this case, but adding this check here to document that
            // we do not want users to query on less than 3 characters as they could retrieve
            // too many users!
            return;
        }

        $mmApp.closeKeyboard();

        $scope.loaded = false;
        return $mmaMessages.searchContacts(query).then(function(result) {
            $scope.hasContacts = result.length > 0;
            $scope.contacts = {
                search: result
            };
        }).catch(function(error) {
            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.errorwhileretrievingcontacts', true);
            }
        }).finally(function() {
            $scope.loaded = true;
        });
    };

    $scope.clearSearch = function() {
        $scope.loaded = false;
        fetchContacts().finally(function() {
            $scope.loaded = true;
        });
    };

    function fetchContacts() {
        return $mmaMessages.getAllContacts().then(function(contacts) {
            $scope.contacts = contacts;

            angular.forEach(contacts, function(contact) {
                if (contact.length > 0) {
                    $scope.hasContacts = true;
                }
            });
        }, function(error) {
            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.errorwhileretrievingcontacts', true);
            }
        });
    }
    fetchContacts().finally(function() {
        $scope.loaded = true;
    });
}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Discussion controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesDiscussionCtrl
 */
.controller('mmaMessagesDiscussionCtrl', ["$scope", "$stateParams", "$mmApp", "$mmaMessages", "$mmSite", "$timeout", "$mmEvents", "$window", "$ionicScrollDelegate", "mmUserProfileState", "$mmUtil", "mmaMessagesPollInterval", "$interval", "$log", "$ionicHistory", "$ionicPlatform", "mmCoreEventKeyboardShow", "mmCoreEventKeyboardHide", "mmaMessagesDiscussionLoadedEvent", "mmaMessagesDiscussionLeftEvent", "$mmUser", function($scope, $stateParams, $mmApp, $mmaMessages, $mmSite, $timeout, $mmEvents, $window,
        $ionicScrollDelegate, mmUserProfileState, $mmUtil, mmaMessagesPollInterval, $interval, $log, $ionicHistory, $ionicPlatform,
        mmCoreEventKeyboardShow, mmCoreEventKeyboardHide, mmaMessagesDiscussionLoadedEvent, mmaMessagesDiscussionLeftEvent,
        $mmUser) {

    $log = $log.getInstance('mmaMessagesDiscussionCtrl');

    var userId = $stateParams.userId,
        userFullname = $stateParams.userFullname,
        messagesBeingSent = 0,
        polling,
        backView = $ionicHistory.backView(),
        lastMessage,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaMessagesScroll');

    $scope.loaded = false;
    $scope.messages = [];
    $scope.userId = userId;
    $scope.currentUserId = $mmSite.getUserId();
    $scope.profileLink = true;

    if (userFullname) {
        $scope.title = userFullname;
    } else if (userId) {
        // We don't have the fullname, try to get it.
        $mmUser.getProfile(userId).then(function(user) {
            if (!$scope.title) {
                $scope.title = user.fullname;
            }
        });
    }

    // Disable the profile button if we're coming from a profile. It is safer to prevent forbid the access
    // to the full profile (we do not know the course ID they came from) as some users cannot view the full
    // profile of other users.
    if (backView && backView.stateName === mmUserProfileState) {
        $scope.profileLink = false;
    }

    $scope.isAppOffline = function() {
        return !$mmApp.isOnline();
    };

    $scope.showDate = function(message, prevMessage) {
        if (!prevMessage) {
            return true;
        }

        // Check if day has changed.
        return !moment(message.timecreated * 1000).isSame(prevMessage.timecreated * 1000, 'day');
    };

    $scope.sendMessage = function(text) {
        var message;
        if (!$mmApp.isOnline()) {
            // Silent error, the view should prevent this.
            return;
        } else if (!text.trim()) {
            // Silent error.
            return;
        }

        text = text.replace(/(?:\r\n|\r|\n)/g, '<br />');
        message = {
            sending: true,
            useridfrom: $scope.currentUserId,
            smallmessage: text,
            timecreated: ((new Date()).getTime() / 1000)
        };
        $scope.messages.push(message);

        messagesBeingSent++;
        $mmaMessages.sendMessage(userId, text).then(function() {
            message.sending = false;
            notifyNewMessage();
        }, function(error) {

            // Only close the keyboard if an error happens, we want the user to be able to send multiple
            // messages withoutthe keyboard being closed.
            $mmApp.closeKeyboard();

            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.messagenotsent', true);
            }
            $scope.messages.splice($scope.messages.indexOf(message), 1);
        }).finally(function() {
            messagesBeingSent--;
        });
    };

    // Fetch the messages for the first time.
    $mmaMessages.getDiscussion(userId).then(function(messages) {
        $scope.messages = $mmaMessages.sortMessages(messages);
        if (!userFullname && messages && messages.length > 0) {
            // When we did not receive the fullname via argument. Also it is possible that
            // we cannot resolve the name when no messages were yet exchanged.
            if (messages[0].useridto != $scope.currentUserId) {
                $scope.title = messages[0].usertofullname || '';
            } else {
                $scope.title = messages[0].userfromfullname || '';
            }
        }
        notifyNewMessage();
    }, function(error) {
        if (typeof error === 'string') {
            $mmUtil.showErrorModal(error);
        } else {
            $mmUtil.showErrorModal('mma.messages.errorwhileretrievingmessages', true);
        }
    }).finally(function() {
        $scope.loaded = true;
    });

    $scope.scrollAfterRender = function(scope) {
        if (scope.$last === true) {
            // Need a timeout to leave time to the view to be rendered.
            $timeout(function() {
                scrollView.scrollBottom();
                setScrollWithKeyboard();
            });
        }
    };

    // Set a polling to get new messages every certain time.
    function setPolling() {
        if (polling) {
            // We already have the polling in place.
            return;
        }

        // Start polling.
        polling = $interval(function() {
            $log.debug('Polling new messages for discussion with user ' + userId);
            if (messagesBeingSent > 0) {
                // We do not poll while a message is being sent or we could confuse the user
                // as his message would disappear from the list, and he'd have to wait for the
                // interval to check for new messages.
                return;
            } else if (!$mmApp.isOnline()) {
                // Obviously we cannot check for new messages when the app is offline.
                return;
            }

            // Invalidate the cache before fetching.
            $mmaMessages.invalidateDiscussionCache(userId);
            $mmaMessages.getDiscussion(userId).then(function(messages) {
                if (messagesBeingSent > 0) {
                    // Ignore polling if due to a race condition.
                    return;
                }
                $scope.messages = $mmaMessages.sortMessages(messages);
                notifyNewMessage();
            });
        }, mmaMessagesPollInterval);
    }

    // Unset polling.
    function unsetPolling() {
        if (polling) {
            $log.debug('Cancelling polling for conversation with user ' + userId);
            $interval.cancel(polling);
            polling = undefined;
        }
    }

    if ($ionicPlatform.isTablet()) {
        // Listen for events to set/unset the polling in tablet. We use angular events because we cannot use ionic events
        // (we use ui-view). The behavior is the same, since scope is destroyed on tablet view when navigating to subviews.
        $scope.$on('$viewContentLoaded', function(){
            setPolling();
        });
        $scope.$on('$destroy', function(){
            unsetPolling();
        });
    } else {
        // Listen for events to set/unset the polling in phones. We can use ionic events.
        $scope.$on('$ionicView.enter', function() {
            setPolling();
        });
        $scope.$on('$ionicView.leave', function(e) {
            unsetPolling();
        });

    }

    // Notify the last message found so discussions list controller can tell if last message should be updated.
    function notifyNewMessage() {
        var last = $scope.messages[$scope.messages.length - 1];
        if (last && last.smallmessage !== lastMessage) {
            lastMessage = last.smallmessage;
            $mmEvents.trigger($mmaMessages.getDiscussionEventName(userId), {
                message: lastMessage,
                timecreated: last.timecreated
            });
        }
    }

    // Scroll when keyboard is hide/shown to keep the user scroll. This is only needed for Android.
    function setScrollWithKeyboard() {
        if (ionic.Platform.isAndroid()) {
            $timeout(function() { // Use a $timeout to wait for scroll to correctly measure height.
                var obsShow,
                    obsHide,
                    keyboardHeight,
                    maxInitialScroll = scrollView.getScrollView().__contentHeight - scrollView.getScrollView().__clientHeight,
                    initialHeight = $window.innerHeight;

                obsShow = $mmEvents.on(mmCoreEventKeyboardShow, function(e) {
                    $timeout(function() {
                        // Try to calculate keyboard height ourselves since e.keyboardHeight is not reliable.
                        var heightDifference = initialHeight - $window.innerHeight,
                            newKeyboardHeight = heightDifference > 50 ? heightDifference : e.keyboardHeight;
                        if (newKeyboardHeight) {
                            keyboardHeight = newKeyboardHeight;
                            scrollView.scrollBy(0, newKeyboardHeight);
                        }
                    });
                });

                obsHide = $mmEvents.on(mmCoreEventKeyboardHide, function(e) {
                    if (!scrollView || !scrollView.getScrollPosition()) {
                        return; // Can't get scroll position, stop.
                    }

                    if (scrollView.getScrollPosition().top >= maxInitialScroll) {
                        // scrollBy(0,0) would automatically reset at maxInitialScroll. We need to apply the difference
                        // from there to scroll to the right point.
                        scrollView.scrollBy(0, scrollView.getScrollPosition().top - keyboardHeight - maxInitialScroll);
                    } else {
                        scrollView.scrollBy(0, - keyboardHeight);
                    }
                });

                $scope.$on('$destroy', function() {
                    obsShow && obsShow.off && obsShow.off();
                    obsHide && obsHide.off && obsHide.off();
                });
            });
        }
    }

    if ($ionicPlatform.isTablet()) {
        $mmEvents.trigger(mmaMessagesDiscussionLoadedEvent, userId);
    }
    $scope.$on('$destroy', function() {
        if ($ionicPlatform.isTablet()) {
            $mmEvents.trigger(mmaMessagesDiscussionLeftEvent);
        }
    });

}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Discussions controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesDiscussionsCtrl
 */
.controller('mmaMessagesDiscussionsCtrl', ["$q", "$state", "$scope", "$mmUtil", "$mmaMessages", "$rootScope", "$mmEvents", "mmCoreSplitViewLoad", function($q, $state, $scope, $mmUtil, $mmaMessages, $rootScope, $mmEvents,
            mmCoreSplitViewLoad) {
    var observers = [];

    $scope.loaded = false;

    // Set observers to watch for new messages on discussions. If a user sees a new message in a discussion, we'll update
    // the discussion's last message in discussions list.
    function setObservers(discussions) {
        clearObservers();

        angular.forEach(discussions, function(discussion) {
            observers.push($mmEvents.on($mmaMessages.getDiscussionEventName(discussion.message.user), function(data) {
                if (data && data.timecreated > discussion.message.timecreated) {
                    discussion.message.message = data.message;
                    discussion.message.timecreated = data.timecreated;
                }
            }));
        });
    }

    // Clear observers.
    function clearObservers() {
        angular.forEach(observers, function(observer) {
            if (observer && observer.off) {
                observer.off();
            }
        });
    }

    function fetchDiscussions() {
        return $mmaMessages.getDiscussions().then(function(discussions) {
            // Convert to an array for sorting.
            var array = [];
            angular.forEach(discussions, function(v) {
                array.push(v);
            });
            $scope.discussions = array;
            setObservers(array);
        }, function(error) {
            if (typeof error === 'string') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.messages.errorwhileretrievingdiscussions', true);
            }
        });
    }

    $scope.refresh = function() {
        $mmaMessages.invalidateDiscussionsCache().then(function() {
            return fetchDiscussions();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    fetchDiscussions().finally(function() {
        $scope.loaded = true;
        // Tell mm-split-view that it can load the first link now in tablets. We need to do it
        // like this because the directive doesn't have access to $scope.loaded variable (because of tabs).
        $rootScope.$broadcast(mmCoreSplitViewLoad);
    });

    $scope.$on('$destroy', function() {
        clearObservers();
    });
}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Messages index controller.
 *
 * @module mm.addons.messages
 * @ngdoc controller
 * @name mmaMessagesIndexCtrl
 */
.controller('mmaMessagesIndexCtrl', ["$scope", "$mmEvents", "$ionicPlatform", "$ionicTabsDelegate", "mmaMessagesDiscussionLoadedEvent", "mmaMessagesDiscussionLeftEvent", function($scope, $mmEvents, $ionicPlatform, $ionicTabsDelegate,
            mmaMessagesDiscussionLoadedEvent, mmaMessagesDiscussionLeftEvent) {
    // Listen for discussion loaded event to show user profile link in tablet view.
    var obsLoaded = $mmEvents.on(mmaMessagesDiscussionLoadedEvent, function(userId) {
        $scope.profileLink = $ionicPlatform.isTablet() && $ionicTabsDelegate.selectedIndex() == 0;
        $scope.userId = userId;
    });

    // Listen for discussion loaded event to show user profile link in tablet view.
    var obsLeft = $mmEvents.on(mmaMessagesDiscussionLeftEvent, function() {
        $scope.profileLink = false;
    });

    $scope.$on('$destroy', function() {
        if (obsLoaded && obsLoaded.off) {
            obsLoaded.off();
        }
        if (obsLeft && obsLeft.off) {
            obsLeft.off();
        }
    });
}]);


// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Filter to format a message.
 *
 * @module mma.messages
 * @ngdoc filter
 * @name mmaMessagesFormat
 */
.filter('mmaMessagesFormat', ["$mmText", function($mmText) {
  return function(text) {
    text = text.replace(/-{4,}/ig, '');
    text = text.replace(/<br \/><br \/>/ig, "<br />");
    text = $mmText.replaceNewLines(text, '<br />');
    return text;
  };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Messages handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.messages
 * @ngdoc service
 * @name $mmaMessagesHandlers
 */
.factory('$mmaMessagesHandlers', ["$log", "$mmaMessages", "$mmSite", "$state", "$mmUtil", "$mmContentLinksHelper", function($log, $mmaMessages, $mmSite, $state, $mmUtil, $mmContentLinksHelper) {
    $log = $log.getInstance('$mmaMessagesHandlers');

    var self = {};

    /**
     * Add contact handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#addContact
     */
    self.addContact = function() {

        var self = {};

        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        self.isEnabledForUser = function(user, courseId) {
            return user.id != $mmSite.getUserId();
        };

        /**
         * Add contact handler controller.
         *
         * @module mm.addons.messages
         * @ngdoc controller
         * @name $mmaMessagesHandlers#blockContact:controller
         */
        self.getController = function(user, courseid) {

            return function($scope, $rootScope) {
                var disabled = false;

                function updateTitle() {
                    return $mmaMessages.isContact(user.id).then(function(isContact) {
                        if (isContact) {
                            $scope.title = 'mma.messages.removecontact';
                        } else {
                            $scope.title = 'mma.messages.addcontact';
                        }
                    }).catch(function() {
                        // This fails for some reason, let's just hide the button.
                        $scope.hidden = true;
                    });
                }

                $scope.title = '';
                $scope.spinner = false;
                $scope.action = function($event) {
                    if (disabled) {
                        return;
                    }
                    disabled = true;
                    $scope.spinner = true;
                    $mmaMessages.isContact(user.id).then(function(isContact) {
                        if (isContact) {
                            return $mmaMessages.removeContact(user.id);
                        } else {
                            return $mmaMessages.addContact(user.id);
                        }
                    }).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    }).finally(function() {
                        $rootScope.$broadcast('mmaMessagesHandlers:addUpdated');
                        updateTitle().finally(function() {
                            disabled = false;
                            $scope.spinner = false;
                        });
                    });
                };

                $scope.$on('mmaMessagesHandlers:blockUpdated', function() {
                    updateTitle();
                });

                updateTitle();

            };

        };

        return self;
    };

    /**
     * Block contact handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#blockContact
     */
    self.blockContact = function() {

        var self = {};

        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        self.isEnabledForUser = function(user, courseId) {
            return user.id != $mmSite.getUserId();
        };

        self.getController = function(user, courseid) {

            /**
             * Block contact handler controller.
             *
             * @module mm.addons.messages
             * @ngdoc controller
             * @name $mmaMessagesHandlers#blockContact:controller
             */
            return function($scope, $rootScope) {
                var disabled = false;

                function updateTitle() {
                    return $mmaMessages.isBlocked(user.id).then(function(isBlocked) {
                        if (isBlocked) {
                            $scope.title = 'mma.messages.unblockcontact';
                        } else {
                            $scope.title = 'mma.messages.blockcontact';
                        }
                    }).catch(function() {
                        // This fails for some reason, let's just hide the button.
                        $scope.hidden = true;
                    });
                }

                $scope.title = '';
                $scope.spinner = false;
                $scope.action = function($event) {
                    if (disabled) {
                        return;
                    }
                    disabled = true;
                    $scope.spinner = true;
                    $mmaMessages.isBlocked(user.id).then(function(isBlocked) {
                        if (isBlocked) {
                            return $mmaMessages.unblockContact(user.id);
                        } else {
                            return $mmaMessages.blockContact(user.id);
                        }
                    }).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    }).finally(function() {
                        $rootScope.$broadcast('mmaMessagesHandlers:blockUpdated');
                        updateTitle().finally(function() {
                            disabled = false;
                            $scope.spinner = false;
                        });
                    });
                };

                $scope.$on('mmaMessagesHandlers:addUpdated', function() {
                    updateTitle();
                });

                updateTitle();

            };

        };

        return self;
    };

    /**
     * Send message handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#blockContact
     */
    self.sendMessage = function() {

        var self = {};

        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        self.isEnabledForUser = function(user, courseId) {
            return user.id != $mmSite.getUserId();
        };

        self.getController = function(user, courseid) {

            /**
             * Send message handler controller.
             *
             * @module mm.addons.messages
             * @ngdoc controller
             * @name $mmaMessagesHandlers#sendMessage:controller
             */
            return function($scope) {
                $scope.title = 'mma.messages.sendmessage';
                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.messages-discussion', {
                        userId: user.id,
                        userFullname: user.fullname
                    });
                };
            };

        };

        return self;
    };

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.messages
             * @ngdoc controller
             * @name $mmaMessagesHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-chatbox';
                $scope.title = 'mma.messages.messages';
                $scope.state = 'site.messages';
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessagesHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId Site ID.
         * @return {Promise}       Promise resolved with true if enabled.
         */
        function isEnabledForSite(siteId) {
            return $mmaMessages.isPluginEnabled(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        Promise resolved with the list of actions.
         *                           See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a messages URL.
            if (url.indexOf('/message/index.php') > -1) {
                // Pass false because all sites should have the same siteurl.
                return $mmContentLinksHelper.filterSupportedSites(siteIds, isEnabledForSite, false).then(function(ids) {
                    if (!ids.length) {
                        return [];
                    } else {
                        // Return actions.
                        var params = $mmUtil.extractUrlParams(url);
                        return [{
                            message: 'mm.core.view',
                            icon: 'ion-eye',
                            sites: ids,
                            action: function(siteId) {
                                var stateName,
                                    stateParams;

                                if (typeof params.user1 != 'undefined' && typeof params.user2 != 'undefined') {
                                    // Check if the current user is in the conversation.
                                    if ($mmSite.getUserId() == params.user1) {
                                        stateName = 'site.messages-discussion';
                                        stateParams = {userId: parseInt(params.user2, 10)};
                                    } else if ($mmSite.getUserId() == params.user2) {
                                        stateName = 'site.messages-discussion';
                                        stateParams = {userId: parseInt(params.user1, 10)};
                                    } else {
                                        // He isn't, open in browser.
                                        $mmUtil.openInBrowser(url);
                                        return;
                                    }
                                } else if (typeof params.id != 'undefined') {
                                    stateName = 'site.messages-discussion';
                                    stateParams = {userId: parseInt(params.id, 10)};
                                }

                                if (!stateName) {
                                    // Go to messaging index page. We use redirect state to view the side menu.
                                    $state.go('redirect', {
                                        siteid: siteId,
                                        state: 'site.messages',
                                        params: {}
                                    });
                                } else {
                                    $mmContentLinksHelper.goInSite(stateName, stateParams, siteId);
                                }
                            }
                        }];
                    }
                });
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.messages')

/**
 * Messages factory.
 *
 * @module mm.addons.messages
 * @ngdoc service
 * @name $mmaMessages
 */
.factory('$mmaMessages', ["$mmSite", "$mmSitesManager", "$log", "$q", "$mmUser", "mmaMessagesNewMessageEvent", function($mmSite, $mmSitesManager, $log, $q, $mmUser, mmaMessagesNewMessageEvent) {
    $log = $log.getInstance('$mmaMessages');

    var self = {};

    /**
     * Add a contact.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#addContact
     * @param {Number} to User ID of the person to add.
     * @return {Promise}
     */
    self.addContact = function(userId) {
        return $mmSite.write('core_message_create_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };

    /**
     * Block a contact.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#blockContact
     * @param {Number} to User ID of the person to block.
     * @return {Promise}
     */
    self.blockContact = function(userId) {
        return $mmSite.write('core_message_block_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };

    /**
     * Get all the contacts of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getAllContacts
     * @return {Promise} Resolved with the WS data.
     */
    self.getAllContacts = function() {
        return self.getContacts().then(function(contacts) {
            return self.getBlockedContacts().then(function(blocked) {
                contacts.blocked = blocked.users;
                storeUsersFromAllContacts(contacts);
                return contacts;
            }, function() {
                // The WS for blocked contacts might not be available yet, but we still want the contacts.
                contacts.blocked = [];
                storeUsersFromAllContacts(contacts);
                return contacts;
            });
        });
    };

    /**
     * Get all the blocked contacts of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getBlockedContacts
     * @return {Promise} Resolved with the WS data.
     */
    self.getBlockedContacts = function() {
        var params = {
                userid: $mmSite.getUserId()
            },
            presets = {
                cacheKey: self._getCacheKeyForBlockedContacts($mmSite.getUserId())
            },
            deferred;

        if (!$mmSite.wsAvailable('core_message_get_blocked_users')) {
            // If the WS is not available, we mock an empty response.
            deferred = $q.defer();
            deferred.resolve({users: [], warnings: []});
            return deferred.promise;
        }

        return $mmSite.read('core_message_get_blocked_users', params, presets);
    };

    /**
     * Get the cache key for contacts.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForContacts
     * @return {String}
     * @protected
     */
    self._getCacheKeyForContacts = function() {
        // Note: the contacts WS does not take arguments, so we do not need any here.
        return 'mmaMessages:contacts';
    };

    /**
     * Get the cache key for blocked contacts.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForBlockedContacts
     * @param {Number} userId The user who's contacts we're looking for.
     * @return {String}
     * @protected
     */
    self._getCacheKeyForBlockedContacts = function(userId) {
        return 'mmaMessages:blockedContacts:' + userId;
    };

    /**
     * Get the cache key for a discussion.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForDiscussion
     * @param {Number} userId The other person with whom the current user is having the discussion.
     * @return {String}
     * @protected
     */
    self._getCacheKeyForDiscussion = function(userId) {
        return 'mmaMessages:discussion:' + userId;
    };

    /**
     * Get the cache key for the list of discussions.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForDiscussions
     * @return {String}
     * @protected
     */
    self._getCacheKeyForDiscussions = function() {
        return 'mmaMessages:discussions';
    };

    /**
     * Get the cache key for the messaging enabled call.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getCacheKeyForEnabled
     * @return {String}
     * @protected
     */
    self._getCacheKeyForEnabled = function() {
        return 'mmaMessages:enabled';
    };

    /**
     * Get the contacts of the current user.
     *
     * This excludes the blocked users.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getContacts
     * @return {Promise} Resolved with the WS data.
     */
    self.getContacts = function() {
        var presets = {
                cacheKey: self._getCacheKeyForContacts()
            };
        return $mmSite.read('core_message_get_contacts', undefined, presets);
    };

    /**
     * Get the name of the events of a discussion.
     *
     * @param  {Number} userid User ID of the discussion.
     * @return {String}        Name of the event.
     */
    self.getDiscussionEventName = function(userid) {
        return mmaMessagesNewMessageEvent + '_' + $mmSite.getUserId() + '_' + userid;
    }

    /**
     * Return the current user's discussion with another user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getDiscussion
     * @param {Number} userId The ID of the other user.
     * @return {Promise}
     */
    self.getDiscussion = function(userId) {
        var messages,
            presets = {
                cacheKey: self._getCacheKeyForDiscussion(userId)
            },
            params = {
                useridto: $mmSite.getUserId(),
                useridfrom: userId,
                limitfrom: 0,
                limitnum: 50
            };

        return self._getRecentMessages(params, presets).then(function(response) {
            messages = response;
            params.useridto = userId;
            params.useridfrom = $mmSite.getUserId();

            return self._getRecentMessages(params, presets).then(function(response) {
                return messages.concat(response);
            });
        });
    };

    /**
     * Get the discussions of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getDiscussions
     * @return {Promise} Resolved with an object where the keys are the user ID of the other user.
     */
    self.getDiscussions = function() {
        var discussions = {},
            presets = {
                cacheKey: self._getCacheKeyForDiscussions()
            },
            promise;

        return self._getRecentMessages({
            useridto: $mmSite.getUserId(),
            useridfrom: 0,
            limitfrom: 0,
            limitnum: 50
        }, presets).then(function(messages) {

            // Extract the discussions by filtering same senders.
            angular.forEach(messages, function(message) {
                if (typeof discussions[message.useridfrom] === 'undefined') {
                    discussions[message.useridfrom] = {
                        fullname: message.userfromfullname,
                        profileimageurl: ""
                    };

                    if (!message.timeread) {
                        discussions[message.useridfrom].unread = true;
                    }
                }

                // Extract the most recent message.
                if (typeof discussions[message.useridfrom].message === 'undefined' ||
                        discussions[message.useridfrom].message.timecreated < message.timecreated) {

                    discussions[message.useridfrom].message = {
                        user: message.useridfrom,
                        message: message.smallmessage,
                        timecreated: message.timecreated
                    };
                }
            });

            // Now get the last messages sent from which we might not have received a reply yet.
            return self._getRecentMessages({
                useridfrom: $mmSite.getUserId(),
                useridto: 0,
                limitfrom: 0,
                limitnum: 50
            }, presets).then(function(messages) {

                // Extract the discussions by filtering same senders.
                angular.forEach(messages, function(message) {
                    if (typeof discussions[message.useridto] === 'undefined') {
                        discussions[message.useridto] = {
                            fullname: message.usertofullname,
                            profileimageurl: ""
                        };

                        if (!message.timeread) {
                            discussions[message.useridto].unread = true;
                        }
                    }

                    // Extract the most recent message.
                    if (typeof discussions[message.useridto].message === 'undefined' ||
                            discussions[message.useridto].message.timecreated < message.timecreated) {

                        discussions[message.useridto].message = {
                            user: message.useridto,
                            message: message.smallmessage,
                            timecreated: message.timecreated
                        };
                    }
                });

                // Now get the contacts
                return self.getContacts().then(function(contacts) {
                    var types = ['online', 'offline', 'strangers'];

                    angular.forEach(types, function(type) {
                        if (contacts[type] && contacts[type].length > 0) {
                            angular.forEach(contacts[type], function(contact) {

                                if (typeof discussions[contact.id] === 'undefined' && contact.unread) {
                                    // It's a contact with unread messages. Contacts without unread messages are not used.
                                    discussions[contact.id] = {
                                        fullname: contact.fullname,
                                        profileimageurl: "",
                                        message: {
                                            user: contact.id,
                                            message: "...",
                                            timecreated: 0,
                                        }
                                    };
                                }

                                if (typeof discussions[contact.id] !== 'undefined') {
                                    // The contact is used in a discussion.
                                    if (contact.profileimageurl) {
                                        discussions[contact.id].profileimageurl = contact.profileimageurl;
                                    }
                                    if (typeof contact.unread !== 'undefined') {
                                        discussions[contact.id].unread = contact.unread;
                                    }
                                }
                            });
                        }
                    });

                    return self.getDiscussionsUserImg(discussions).then(function(discussions) {
                        storeUsersFromDiscussions(discussions);
                        return discussions;
                    });
                });
            });
        });
    };

    /**
     * Get user images for all the discussions that don't have one already.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#getDiscussionsUserImg
     * @param {Object[]} discussions List of discussions.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted discussions.
     */
    self.getDiscussionsUserImg = function(discussions) {
        var promises = [];

        angular.forEach(discussions, function(discussion) {
            if (!discussion.profileimageurl) {
                // We don't have the user image. Try to retrieve it.
                var promise = $mmUser.getProfile(discussion.message.user, 1, true).then(function(user) {
                    discussion.profileimageurl = user.profileimageurl;
                }, function() {
                    // Error getting profile, resolve promise without adding any extra data.
                });
                promises.push(promise);
            }
        });
        return $q.all(promises).then(function() {
            return discussions;
        });
    };

    /**
     * Get messages according to the params.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getMessages
     * @param {Object} params Parameters to pass to the WS.
     * @param {Object} presets Set of presets for the WS.
     * @return {Promise}
     * @protected
     */
    self._getMessages = function(params, presets) {
        params = angular.extend(params, {
            type: 'conversations',
            newestfirst: 1,
        });

        return $mmSite.read('core_message_get_messages', params, presets);
    };

    /**
     * Get the most recent messages.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_getRecentMessages
     * @param {Object} params Parameters to pass to the WS.
     * @param {Object} presets Set of presets for the WS.
     * @return {Promise}
     * @protected
     */
    self._getRecentMessages = function(params, presets) {
        params = angular.extend(params, {
            read: 0
        });

        return self._getMessages(params, presets).then(function(response) {
            var messages = response.messages;
            if (messages) {
                if (messages.length >= params.limitnum) {
                    return messages;
                }

                // We need to fetch more messages.
                params.limitnum = params.limitnum - messages.length;
                params.read = 1;

                return self._getMessages(params, presets).then(function(response) {
                    if (response.messages) {
                        messages = messages.concat(response.messages);
                    }
                    return messages;
                }, function() {
                    return messages;
                });

            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Invalidate all contacts cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateAllContactsCache
     * @param {Number} userId The user ID.
     * @return {Promise}
     */
    self.invalidateAllContactsCache = function(userId) {
        return self.invalidateContactsCache().then(function() {
            return self.invalidateBlockedContactsCache(userId);
        });
    };

    /**
     * Invalidate blocked contacts cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateBlockedContactsCache
     * @param {Number} userId The user ID.
     * @return {Promise}
     */
    self.invalidateBlockedContactsCache = function(userId) {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForBlockedContacts(userId));
    };


    /**
     * Invalidate contacts cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateContactsCache
     * @return {Promise}
     */
    self.invalidateContactsCache = function() {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForContacts());
    };

    /**
     * Invalidate discussion cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateDiscussionCache
     * @param {Number} userId The user ID with whom the current user is having the discussion.
     * @return {Promise}
     */
    self.invalidateDiscussionCache = function(userId) {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForDiscussion(userId));
    };

    /**
     * Invalidate discussions cache.
     *
     * Note that {@link $mmaMessages#getDiscussions} uses the contacts, so we need to invalidate contacts too.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateDiscussionsCache
     * @return {Promise}
     */
    self.invalidateDiscussionsCache = function(userId) {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForDiscussions()).then(function(){
            return self.invalidateContactsCache();
        });
    };

    /**
     * Invalidate messaging enabled cache.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#invalidateEnabledCache
     * @return {Promise}
     */
    self.invalidateEnabledCache = function() {
        return $mmSite.invalidateWsCacheForKey(self._getCacheKeyForEnabled());
    };

    /**
     * Checks if the a user is blocked by the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isBlocked
     * @param {Number} userId The user ID to check against.
     * @return {Promise} Resolved with boolean, rejected when we do not know.
     */
    self.isBlocked = function(userId) {
        return self.getBlockedContacts().then(function(blockedContacts) {
            var blocked = false;
            if (!blockedContacts.users || blockedContacts.users.length < 1) {
                return blocked;
            }
            angular.forEach(blockedContacts.users, function(user) {
                if (userId == user.id) {
                    blocked = true;
                }
            });
            return blocked;
        });
    };

    /**
     * Checks if the a user is a contact of the current user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isContact
     * @param {Number} userId The user ID to check against.
     * @return {Promise} Resolved with boolean, rejected when we do not know.
     */
    self.isContact = function(userId) {
        return self.getContacts().then(function(contacts) {
            var isContact = false,
                types = ['online', 'offline'];

            angular.forEach(types, function(type) {
                if (contacts[type] && contacts[type].length > 0) {
                    angular.forEach(contacts[type], function(user) {
                        if (userId == user.id) {
                            isContact = true;
                        }
                    });
                }
            });

            return isContact;
        });
    };

    /**
     * Returns whether or not messaging is enabled for the current site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#_isMessagingEnabled
     * @return {Promise} Resolved when enabled, otherwise rejected.
     * @protected
     */
    self._isMessagingEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var enabled = site.canUseAdvancedFeature('messaging', 'unknown');

            if (enabled === 'unknown') {
                // On older version we cannot check other than calling a WS. If the request
                // fails there is a very high chance that messaging is disabled.
                $log.debug('Using WS call to check if messaging is enabled.');
                return site.read('core_message_search_contacts', {
                    searchtext: 'CheckingIfMessagingIsEnabled',
                    onlymycourses: 0
                }, {
                    emergencyCache: false,
                    cacheKey: self._getCacheKeyForEnabled()
                });
            }

            if (enabled) {
                return true;
            }
            return $q.reject();
        });
    };

   /**
     * Returns whether or not messaging is enabled for a certain site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isMessagingEnabledForSite
     * @param {String} siteid Site ID.
     * @return {Promise}      Resolved when enabled, otherwise rejected.
     */
    self.isMessagingEnabledForSite = function(siteid) {
        return $mmSitesManager.getSite(siteid).then(function(site) {
            if (!site.canUseAdvancedFeature('messaging') || !site.wsAvailable('core_message_get_messages')) {
                return $q.reject();
            }

            // On older version we cannot check other than calling a WS. If the request
            // fails there is a very high chance that messaging is disabled.
            $log.debug('Using WS call to check if messaging is enabled.');
            return site.read('core_message_search_contacts', {
                searchtext: 'CheckingIfMessagingIsEnabled',
                onlymycourses: 0
            }, {
                emergencyCache: false,
                cacheKey: self._getCacheKeyForEnabled()
            });
        });
    };

    /**
     * Returns whether or not the plugin is enabled in a certain site.
     *
     * Do not abuse this method.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canUseAdvancedFeature('messaging')) {
                return false;
            } else if (!site.wsAvailable('core_message_get_messages')) {
                return false;
            } else {
                return self._isMessagingEnabled(siteId).then(function() {
                    return true;
                });
            }
        });
    };

    /**
     * Returns whether or not we can search contacts.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#isSearchEnabled
     * @return {Boolean}
     */
    self.isSearchEnabled = function() {
        return $mmSite.wsAvailable('core_message_search_contacts');
    };

    /**
     * Remove a contact.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#removeContact
     * @param {Number} to User ID of the person to remove.
     * @return {Promise}
     */
    self.removeContact = function(userId) {
        return $mmSite.write('core_message_delete_contacts', {
            userids: [ userId ]
        }, {
            responseExpected: false
        }).then(function() {
            return self.invalidateContactsCache();
        });
    };

    /**
     * Search for contacts.
     *
     * By default this only returns the first 100 contacts, but note that the WS can return thousands
     * of results which would take a while to process. The limit here is just a convenience to
     * prevent viewed to crash because too many DOM elements are created.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#searchContacts
     * @param {String} query The query string.
     * @param {Number} [limit=100] The number of results to return, 0 for none.
     * @return {Promise}
     */
    self.searchContacts = function(query, limit) {
        var data = {
                searchtext: query,
                onlymycourses: 0
            };
        limit = typeof limit === 'undefined' ? 100 : limit;
        return $mmSite.read('core_message_search_contacts', data).then(function(contacts) {
            if (limit && contacts.length > limit) {
                contacts = contacts.splice(0, limit);
            }
            $mmUser.storeUsers(contacts);
            return contacts;
        });
    };

    /**
     * Send a message to someone.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#sendMessage
     * @param {Number} to User ID to send the message to.
     * @param {String} message The message to send
     * @return {Promise}
     */
    self.sendMessage = function(to, message) {
        return $mmSite.write('core_message_send_instant_messages', {
            messages: [
                {
                    touserid: to,
                    text: message,
                    textformat: 1
                }
            ]
        }).then(function(response) {
            if (response && response[0] && response[0].msgid === -1) {
                // There was an error, and it should be translated already.
                return $q.reject(response[0].errormessage);
            }
            return self.invalidateDiscussionCache(to);
        });
    };

    /**
     * Helper method to sort messages by time.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#sortMessages
     * @param {Object[]} messages Array of messages containing the key 'timecreated'.
     * @return {Object[]} Messages sorted with most recent last.
     */
    self.sortMessages = function(messages) {
        return messages.sort(function (a, b) {
            a = parseInt(a.timecreated, 10);
            b = parseInt(b.timecreated, 10);
            return a >= b ? 1 : -1;
        });
    };

    /**
     * Store user data from contacts in local DB.
     *
     * @param {Object[]} contactTypes List of contacts grouped in types.
     */
    function storeUsersFromAllContacts(contactTypes) {
        angular.forEach(contactTypes, function(contacts) {
            $mmUser.storeUsers(contacts);
        });
    }

    /**
     * Store user data from discussions in local DB.
     *
     * @param {Object[]} discussions List of discussions.
     */
    function storeUsersFromDiscussions(discussions) {
        angular.forEach(discussions, function(discussion, userid) {
            if (typeof userid != 'undefined' && !isNaN(parseInt(userid))) {
                $mmUser.storeUser(userid, discussion.fullname, discussion.profileimageurl);
            }
        });
    }

    /**
     * Unblock a user.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaMessages#unblockContact
     * @param {Number} to User ID of the person to unblock.
     * @return {Promise}
     */
    self.unblockContact = function(userId) {
        return $mmSite.write('core_message_unblock_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Assign index controller.
 *
 * @module mm.addons.mod_assign
 * @ngdoc controller
 * @name mmaModAssignIndexCtrl
 */
.controller('mmaModAssignIndexCtrl', ["$scope", "$stateParams", "$mmaModAssign", "$mmUtil", "$translate", "mmaModAssignComponent", "mmaModAssignSubmissionComponent", function($scope, $stateParams, $mmaModAssign, $mmUtil, $translate,
        mmaModAssignComponent, mmaModAssignSubmissionComponent) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.assigncomponent = mmaModAssignComponent;
    $scope.submissioncomponent = mmaModAssignSubmissionComponent;
    $scope.assignurl = module.url;
    $scope.courseid = courseid;

    function fetchAssignment(refresh) {
        // Get assignment data.
        return $mmaModAssign.getAssignment(courseid, module.id, refresh).then(function(assign) {
            $scope.title = assign.name || $scope.title;
            $scope.description = assign.intro || $scope.description;
            $scope.assign = assign;

            // Get assignment submissions.
            return $mmaModAssign.getSubmissions(assign.id, refresh).then(function(data) {
                $scope.canviewsubmissions = data.canviewsubmissions;

                if (data.canviewsubmissions) {
                    // We want to show the user data on each submission.
                    return $mmaModAssign.getSubmissionsUserData(data.submissions, courseid).then(function(submissions) {
                        angular.forEach(submissions, function(submission) {
                            submission.text = $mmaModAssign.getSubmissionText(submission);
                            submission.attachments = $mmaModAssign.getSubmissionAttachments(submission);
                        });
                        $scope.submissions = submissions;
                    });
                }
            }, function() {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $translate('mm.core.error').then(function(error) {
                        $mmUtil.showErrorModal(error + ': get_assignment_submissions');
                    });
                }
            });
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $translate('mm.core.error').then(function(error) {
                    $mmUtil.showErrorModal(error + ': get_assignment');
                });
            }
        });
    }

    fetchAssignment().finally(function() {
        $scope.assignmentLoaded = true;
    });

    $scope.refreshAssignment = function() {
        fetchAssignment(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Assign submission controller.
 *
 * @module mm.addons.mod_assign
 * @ngdoc controller
 * @name mmaModAssignSubmissionCtrl
 */
.controller('mmaModAssignSubmissionCtrl', ["$scope", "$stateParams", "mmaModAssignSubmissionComponent", function($scope, $stateParams, mmaModAssignSubmissionComponent) {
    var submission = $stateParams.submission || {};

    $scope.title = submission.userfullname;
    $scope.submission = submission;
    $scope.component = mmaModAssignSubmissionComponent;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Assignments service.
 *
 * @module mm.addons.mod_assign
 * @ngdoc controller
 * @name $mmaModAssign
 */
.factory('$mmaModAssign', ["$mmSite", "$q", "$mmUser", "$mmSitesManager", function($mmSite, $q, $mmUser, $mmSitesManager) {
    var self = {};

    /**
     * Get an assignment.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getAssignment
     * @param {Number} courseid   Course ID the assignment belongs to.
     * @param {Number} cmid       Assignment module ID.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @return {Promise}          Promise resolved with the assignment.
     */
    self.getAssignment = function(courseid, cmid, refresh) {
        var params = {
                "courseids": [courseid]
            },
            preSets = {};

        if (refresh) {
            preSets.getFromCache = false;
        }

        return $mmSite.read('mod_assign_get_assignments', params, preSets).then(function(response) {
            if (response.courses && response.courses.length) {
                var assignments = response.courses[0].assignments;
                for (var i = 0; i < assignments.length; i++) {
                    if (assignments[i].cmid == cmid) {
                        return assignments[i];
                    }
                }
                return $q.reject();
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Get attachments of a submission.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissionAttachments
     * @param {Object} submission Submission.
     * @return {Object[]}         Submission attachments.
     */
    self.getSubmissionAttachments = function(submission) {
        var files = [];
        if (submission.plugins) {
            submission.plugins.forEach(function(plugin) {
                if (plugin.type === 'file' && plugin.fileareas && plugin.fileareas[0] && plugin.fileareas[0].files) {
                    files = plugin.fileareas[0].files;
                    angular.forEach(files, function(file) {
                        file.filename = file.filepath;
                    });
                }
            });
        }
        return files;
    };

    /**
     * Get text of a submission.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissionText
     * @param {Object} submission Submission.
     * @return {String}           Submission text.
     */
    self.getSubmissionText = function(submission) {
        var text = '';
        if (submission.plugins) {
            angular.forEach(submission.plugins, function(plugin) {
                if (plugin.type === 'onlinetext' && plugin.editorfields) {
                    text = plugin.editorfields[0].text;

                    // Online text contains '@@PLUGINFILE@@' for each embedded file. Replace those with the right URL.
                    if (plugin.fileareas && plugin.fileareas[0] && plugin.fileareas[0].files && plugin.fileareas[0].files[0]) {
                        var fileURL =  plugin.fileareas[0].files[0].fileurl;
                        fileURL = fileURL.substr(0, fileURL.lastIndexOf('/')).replace('pluginfile.php/', 'pluginfile.php?file=/');
                        text = text.replace(/@@PLUGINFILE@@/g, fileURL);
                    }
                }
            });
        }
        return text;
    };

    /**
     * Get an assignment submissions.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissions
     * @param {Number}  id        Assignment id.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @return {Promise}          Promise resolved with:
     *                                    - canviewsubmissions: True if user can view submissions, false otherwise.
     *                                    - submissions: Array of submissions.
     */
    self.getSubmissions = function(id, refresh) {
        var params = {
                "assignmentids": [id]
            },
            preSets = {};

        if (refresh) {
            preSets.getFromCache = false;
        }

        return $mmSite.read('mod_assign_get_submissions', params, preSets).then(function(response) {
            // Check if we can view submissions, with enough permissions.
            if (response.warnings.length > 0 && response.warnings[0].warningcode == 1) {
                return {canviewsubmissions: false};
            } else {
                if (response.assignments && response.assignments.length) {
                    return {
                        canviewsubmissions: true,
                        submissions: response.assignments[0].submissions
                    };
                } else {
                    return $q.reject();
                }
            }
        });
    };

    /**
     * Get user data for submissions since they only have userid.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#getSubmissionsUserData
     * @param {Object[]} submissions Submissions to get the data for.
     * @param {Number}   courseid    ID of the course the submissions belong to.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted submissions.
     */
    self.getSubmissionsUserData = function(submissions, courseid) {
        var promises = [];

        angular.forEach(submissions, function(submission) {
            var promise = $mmUser.getProfile(submission.userid, courseid, true).then(function(user) {
                submission.userfullname = user.fullname;
                submission.userprofileimageurl = user.profileimageurl;
            }, function() {
                // Error getting profile, resolve promise without adding any extra data.
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return submissions;
        });
    };

    /**
     * Check if assignments plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssign#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('mod_assign_get_assignments') && site.wsAvailable('mod_assign_get_submissions');
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_assign')

/**
 * Mod assign handlers.
 *
 * @module mm.addons.mod_assign
 * @ngdoc service
 * @name $mmaModAssignHandlers
 */
.factory('$mmaModAssignHandlers', ["$mmCourse", "$mmaModAssign", "$state", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModAssign, $state, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssignHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for the site.
         *
         * @return {Promise}
         */
        self.isEnabled = function() {
            return $mmaModAssign.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('assign');
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_assign', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_assign
     * @ngdoc method
     * @name $mmaModAssignHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModAssign.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's an assign URL.
            if (url.indexOf('/mod/assign/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Book index controller.
 *
 * @module mm.addons.mod_book
 * @ngdoc controller
 * @name mmaModBookIndexCtrl
 */
.controller('mmaModBookIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModBook", "$log", "mmaModBookComponent", "$ionicPopover", "$mmApp", "$q", "$mmCourse", "$ionicScrollDelegate", function($scope, $stateParams, $mmUtil, $mmaModBook, $log, mmaModBookComponent,
            $ionicPopover, $mmApp, $q, $mmCourse, $ionicScrollDelegate) {
    $log = $log.getInstance('mmaModBookIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        currentChapter;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModBookComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;

    var chapters = $mmaModBook.getTocList(module.contents);
    currentChapter = $mmaModBook.getFirstChapter(chapters);

    // Convenience function to load a book chapter.
    function loadChapter(chapterId) {
        currentChapter = chapterId;
        $ionicScrollDelegate.scrollTop();
        return $mmaModBook.getChapterContent(module.contents, chapterId, module.id).then(function(content) {
            $scope.content = content;
            $scope.previousChapter = $mmaModBook.getPreviousChapter(chapters, chapterId);
            $scope.nextChapter = $mmaModBook.getNextChapter(chapters, chapterId);
        }).catch(function() {
            $mmUtil.showErrorModal('mma.mod_book.errorchapter', true);
            return $q.reject();
        }).finally(function() {
            $scope.loaded = true;
            $ionicScrollDelegate.resize(); // Call resize to recalculate scroll area.
        });
    }

    // Convenience function to download book contents and load the current chapter.
    function fetchContent(chapterId) {
        var downloadFailed = false;
        return $mmaModBook.downloadAllContent(module).catch(function() {
            // Mark download as failed but go on since the main files could have been downloaded.
            downloadFailed = true;
        }).finally(function() {
            // Show chapter.
            return loadChapter(chapterId).then(function() {
                if (downloadFailed && $mmApp.isOnline()) {
                    // We could load the main file but the download failed. Show error message.
                    $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                }
            });
        });
    }

    $scope.doRefresh = function() {
        $mmaModBook.invalidateContent(module.id).then(function() {
            return fetchContent(currentChapter);
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Function to load a chapter.
    $scope.loadChapter = function(chapterId) {
        $scope.popover.hide();
        $scope.loaded = false;
        loadChapter(chapterId);
    };

    // Menu popover.
    $scope.toc = chapters;
    $ionicPopover.fromTemplateUrl('addons/mod_book/templates/toc.html', {
        scope: $scope,
    }).then(function(popover) {
        $scope.popover = popover;
    });


    fetchContent(currentChapter).then(function() {
        $mmaModBook.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Directive to navigate to previous/next chapter in a book.
 *
 * @module mm.addons.mod_book
 * @ngdoc directive
 * @name mmaModBookArrows
 * @description
 * This directive will show two arrows at the left and right of the screen to navigate to previous/next book chapter when
 * clicked. If no previous/next chapter is defined, that arrow won't be shown.
 *
 * @param {Number}   previous ID of the previous chapter.
 * @param {Number}   next     ID of the next chapter.
 * @param {Function} action   Function to call when an arrow is clicked. Will receive as a param the chapterId to load.
 */
.directive('mmaModBookArrows', function() {
    return {
        restrict: 'E',
        scope: {
            previous: '=?',
            next: '=?',
            action: '=?'
        },
        templateUrl: 'addons/mod_book/templates/arrows.html'
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Book factory.
 *
 * @module mm.addons.mod_book
 * @ngdoc service
 * @name $mmaModBook
 */
.factory('$mmaModBook', ["$mmFilepool", "$mmSite", "$mmFS", "$http", "$log", "$q", "$mmSitesManager", "mmaModBookComponent", function($mmFilepool, $mmSite, $mmFS, $http, $log, $q, $mmSitesManager, mmaModBookComponent) {
    $log = $log.getInstance('$mmaModBook');

    var self = {};

    /**
     * Download all the content.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModBookComponent, module.id, revision, timemod);
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get the book toc as an array.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getToc
     * @param  {array} contents The module contents.
     * @return {Array}          The toc.
     * @protected
     */
    self.getToc = function(contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return JSON.parse(contents[0].content);
    };

    /**
     * Get the book toc as an array of chapters (no nested).
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getTocList
     * @param  {array} contents The module contents.
     * @return {Array}          The toc as a list.
     * @protected
     */
    self.getTocList = function(contents) {
        var chapters = [];
        var toc = self.getToc(contents);
        angular.forEach(toc, function(el) {
            var chapterId = el.href.replace('/index.html', '');
            chapters.push({id: chapterId, title: el.title, level: el.level});
            angular.forEach(el.subitems, function(sel) {
                chapterId = sel.href.replace('/index.html', '');
                chapters.push({id: chapterId, title: sel.title, level: sel.level});
            });
        });
        return chapters;
    };

    /**
     * Get the first chapter of a book.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getFirstChapter
     * @param  {array} chapters  The chapters list.
     * @return {String}          The chapter id.
     * @protected
     */
    self.getFirstChapter = function(chapters) {
        if (!chapters || !chapters.length) {
            return;
        }
        return chapters[0].id;
    };

    /**
     * Get the previous chapter to the given one.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getPreviousChapter
     * @param  {array} chapters     The chapters list.
     * @param  {String} chapterId   The current chapter.
     * @return {String}             The previous chapter id.
     * @protected
     */
    self.getPreviousChapter = function(chapters, chapterId) {
        var previous = 0;

        for (var i = 0, len = chapters.length; i < len; i++) {
            if (chapters[i].id == chapterId) {
                break;
            }
            previous = chapters[i].id;
        }

        return previous;
    };

    /**
     * Get the next chapter to the given one.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getNextChapter
     * @param  {array} chapters     The chapters list.
     * @param  {String} chapterId   The current chapter.
     * @return {String}             The next chapter id.
     * @protected
     */
    self.getNextChapter = function(chapters, chapterId) {
        var next = 0;

        for (var i = 0, len = chapters.length; i < len; i++) {
            if (chapters[i].id == chapterId) {
                if (typeof chapters[i + 1] != 'undefined') {
                    next = chapters[i + 1].id;
                    break;
                }
            }
        }
        return next;
    };

    /**
     * Gets a chapter contents from the book.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#getChapterContent
     * @param {Object} contents     The module contents.
     * @param {String} chapterId    Chapter to retrieve.
     * @param {Integer} moduleId    The module ID.
     * @return {Promise}
     */
    self.getChapterContent = function(contents, chapterId, moduleId) {
        var indexUrl,
            paths = {},
            promise;

        // Extract the information about paths from the module contents.
        angular.forEach(contents, function(content) {
            if (self.isFileDownloadable(content)) {
                var key,
                    url = content.fileurl;

                if (!indexUrl && content.filename == 'index.html') {
                    // First chapter, we don't have a chapter id.
                    if (content.filepath == "/" + chapterId + "/") {
                        indexUrl = url;
                    }
                } else {
                    key = content.filename;
                    paths[key] = url;
                }
            }
        });

        // Promise handling when we are in a browser.
        promise = (function() {
            var deferred;
            if (!indexUrl) {
                // If ever that happens.
                $log.debug('Could not locate the index chapter');
                return $q.reject();
            } else if ($mmFS.isAvailable()) {
                // The file system is available.
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModBookComponent, moduleId);
            } else {
                // We return the live URL.
                deferred = $q.defer();
                deferred.resolve($mmSite.fixPluginfileURL(indexUrl));
                return deferred.promise;
            }
        })();

        return promise.then(function(url) {
            // Fetch the URL content.
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    // Now that we have the content, we update the SRC to point back to
                    // the external resource. That will be caught by mm-format-text.
                    var html = angular.element('<div>');
                    html.html(response.data);
                    angular.forEach(html.find('img'), function(img) {
                        var src = paths[decodeURIComponent(img.getAttribute('src'))];
                        if (typeof src !== 'undefined') {
                            img.setAttribute('src', src);
                        }
                    });
                    // We do the same for links.
                    angular.forEach(html.find('a'), function(anchor) {
                        var href = paths[decodeURIComponent(anchor.getAttribute('href'))];
                        if (typeof href !== 'undefined') {
                            anchor.setAttribute('href', href);
                        }
                    });
                    return html.html();
                }
            });
        });
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#invalidateContent
     * @param {Object} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModBookComponent, moduleId);
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Return whether or not the plugin is enabled.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var version = site.getInfo().version;
            // Require Moodle 2.9.
            return version && (parseInt(version) >= 2015051100) && site.canDownloadFiles();
        });
    };

    /**
     * Report a book as being viewed.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                bookid: id
            };
            return $mmSite.write('mod_book_view_book', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBook#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModBookComponent, module.id, revision, timemod);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Mod book handlers.
 *
 * @module mm.addons.mod_book
 * @ngdoc service
 * @name $mmaModBookHandlers
 */
.factory('$mmaModBookHandlers', ["$mmCourse", "$mmaModBook", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreDownloaded", "mmCoreEventPackageStatusChanged", "mmaModBookComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModBook, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreDownloaded,
            mmCoreEventPackageStatusChanged, mmaModBookComponent, $mmContentLinksHelper, $q) {

    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookHandlers#courseContentHandler
     */
    self.courseContentHandler = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModBook.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModBook.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();

                        $mmaModBook.invalidateContent(module.id).finally(function() {
                            $mmaModBook.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('book');
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_book', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        // Always show refresh button if a book is downloaded because revision and timemodified aren't reliable.
                        refreshBtn.hidden = status !== mmCoreOutdated && status !== mmCoreDownloaded;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModBookComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModBook.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a book URL.
            if (url.indexOf('/mod/book/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_book')

/**
 * Mod book prefetch handler.
 *
 * @module mm.addons.mod_book
 * @ngdoc service
 * @name $mmaModBookPrefetchHandler
 */
.factory('$mmaModBookPrefetchHandler', ["$mmaModBook", "mmCoreDownloaded", "mmCoreOutdated", "mmaModBookComponent", function($mmaModBook, mmCoreDownloaded, mmCoreOutdated, mmaModBookComponent) {

    var self = {};

    self.component = mmaModBookComponent;

    /**
     * Determine the status of a module based on the current status detected.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#determineStatus
     * @param {String} status Current status.
     * @return {String}       Status to show.
     */
    self.determineStatus = function(status) {
        if (status === mmCoreDownloaded) {
            // Books are always treated as outdated since revision and timemodified aren't reliable.
            return mmCoreOutdated;
        } else {
            return status;
        }
    };

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModBook.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmaModBook.isPluginEnabled();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_book
     * @ngdoc method
     * @name $mmaModBookPrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModBook.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Chat controller.
 *
 * @module mm.addons.mod_chat
 * @ngdoc controller
 * @name mmaModChatChatCtrl
 */
.controller('mmaModChatChatCtrl', ["$scope", "$stateParams", "$mmApp", "$mmaModChat", "$log", "$ionicModal", "$mmUtil", "$ionicHistory", "$ionicScrollDelegate", "$timeout", "$mmSite", "$interval", "mmaChatPollInterval", function($scope, $stateParams, $mmApp, $mmaModChat, $log, $ionicModal, $mmUtil, $ionicHistory,
            $ionicScrollDelegate, $timeout, $mmSite, $interval, mmaChatPollInterval) {

    $log = $log.getInstance('mmaModChatChatCtrl');

    var chatId = $stateParams.chatid,
        courseId = $stateParams.courseid,
        title = $stateParams.title,
        polling;

    $scope.loaded = false;
    $scope.title = title;
    $scope.currentUserId = $mmSite.getUserId();
    $scope.currentUserBeep = 'beep ' + $scope.currentUserId;
    $scope.messages = [];
    $scope.chatUsers = [];

    // We use an object because it works better with forms.
    $scope.newMessage = {
        text: ''
    };
    chatLastTime = 0;

    // Chat users modal.
    $ionicModal.fromTemplateUrl('addons/mod_chat/templates/users.html', {
        scope: $scope,
        animation: 'slide-in-up'
    }).then(function(m) {
        $scope.modal = m;
    });

    // Close the chat users modal.
    $scope.closeModal = function(){
        $scope.modal.hide();
    };

    // Display the chat users modal.
    $scope.showChatUsers = function() {
        $scope.usersLoaded = false;
        $scope.modal.show();
        $mmaModChat.getChatUsers($scope.chatsid).then(function(data) {
            $scope.chatUsers = data.users;
        }).catch(function(error) {
            showError(error, 'mma.mod_chat.errorwhilegettingchatusers');
        }).finally(function() {
            $scope.usersLoaded = true;
        });
    };

    // Add To "user":
    $scope.talkTo = function(user) {
        $scope.newMessage.text = "To " + user + ": ";
        $scope.modal.hide();
    };

    // Beep a user.
    $scope.beepTo = function(userId) {
        $scope.sendMessage('', userId);
        $scope.modal.hide();
    };

    // Check is the app is offline.
    $scope.isAppOffline = function() {
        return !$mmApp.isOnline();
    };

    // Show error modal.
    function showError(error, defaultMessage) {
        if (typeof error === 'string') {
            $mmUtil.showErrorModal(error);
        } else {
            $mmUtil.showErrorModal(defaultMessage, true);
        }
    }

    // Check if the date should be displayed between messages (when the day changes at midnight for example).
    $scope.showDate = function(message, prevMessage) {
        if (!prevMessage) {
            return true;
        }

        // Check if day has changed.
        return !moment(message.timestamp * 1000).isSame(prevMessage.timestamp * 1000, 'day');
    };

    // Send a message to the chat.
    $scope.sendMessage = function(text, beep) {
        beep = beep || '';

        if (!$mmApp.isOnline()) {
            // Silent error, the view should prevent this.
            return;
        } else if (beep === '' && !text.trim()) {
            // Silent error.
            return;
        }
        text = text.replace(/(?:\r\n|\r|\n)/g, '<br />');

        $mmaModChat.sendMessage($scope.chatsid, text, beep).then(function() {
            if (beep === '') {
                $scope.newMessage.text = '';
            }
        }, function(error) {
            // Only close the keyboard if an error happens, we want the user to be able to send multiple
            // messages withoutthe keyboard being closed.
            $mmApp.closeKeyboard();

            showError(error, 'mma.mod_chat.errorwhilesendingmessage');
        });
    };

    // Login the user.
    $mmaModChat.loginUser(chatId).then(function(chatsid) {
        return $mmaModChat.getLatestMessages(chatsid, 0).then(function(messagesInfo) {
            $scope.chatsid = chatsid;
            chatLastTime = messagesInfo.chatnewlasttime;
            return $mmaModChat.getMessagesUserData(messagesInfo.messages, courseId).then(function(messages) {
                $scope.messages = $scope.messages.concat(messages);
            });
        }).catch(function(message) {
            showError(message, 'mma.mod_chat.errorwhileretrievingmessages');
        });
    }, function(error) {
        showError(error, 'mma.mod_chat.errorwhileconnecting');
        $ionicHistory.goBack();
    }).finally(function() {
        $scope.loaded = true;
    });

    // Scroll to the bottom.
    $scope.scrollAfterRender = function(scope) {
        if (scope.$last === true) {
            // Need a timeout to leave time to the view to be rendered.
            $timeout(function() {
                var scrollView = $ionicScrollDelegate.$getByHandle('mmaChatScroll');
                scrollView.scrollBottom();
            });
        }
    };

    // Set up the polling on a view enter, this allows for the user to go back and resume the polling.
    $scope.$on('$ionicView.enter', function() {
        // Strange case, we already have the polling in place.
        if (polling) {
            return;
        }

        // Start polling.
        polling = $interval(function() {
            $log.debug('Polling for messages');
            if (!$mmApp.isOnline()) {
                // Obviously we cannot check for new messages when the app is offline.
                return;
            }

            $mmaModChat.getLatestMessages($scope.chatsid, chatLastTime).then(function(data) {
                chatLastTime = data.chatnewlasttime;
                $mmaModChat.getMessagesUserData(data.messages, courseId).then(function(messages) {
                    $scope.messages = $scope.messages.concat(messages);
                });
            }, function(error) {
                $interval.cancel(polling);
                showError(error, 'mma.mod_chat.errorwhileretrievingmessages');
            });

        }, mmaChatPollInterval);
    });

    // Removing the polling as we leave the page.
    $scope.$on('$ionicView.leave', function(e) {
        if (polling) {
            $log.debug('Cancelling polling for conversation');
            $interval.cancel(polling);
        }
    });

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Chat index controller.
 *
 * @module mm.addons.mod_chat
 * @ngdoc controller
 * @name mmaModChatIndexCtrl
 */
.controller('mmaModChatIndexCtrl', ["$scope", "$stateParams", "$mmaModChat", "$mmUtil", "$q", "$mmCourse", function($scope, $stateParams, $mmaModChat, $mmUtil, $q, $mmCourse) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        chat;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;

    // Convenience function to get chat data.
    function fetchChatData(refresh) {
        return $mmaModChat.getChat(courseid, module.id, refresh).then(function(chatdata) {
            chat = chatdata;
            $scope.title = chat.name || $scope.title;
            $scope.description = chat.intro || $scope.description;
            $scope.chatId = chat.id;
            $scope.chatScheduled = '';

            var now = $mmUtil.timestamp();
            var span = chat.chattime - now;

            if (chat.chattime && chat.schedule > 0 && span > 0) {
                $mmUtil.formatTime(span).then(function(time) {
                    $scope.chatScheduled = time;
                });
            }

        }, function(error) {
            if (!refresh) {
                // Get chat failed, retry without using cache since it might be a new activity.
                return fetchChatData(true);
            }

            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.mod_chat.errorwhilegettingchatdata', true);
            }
            return $q.reject();
        });
    }

    fetchChatData().then(function() {
        $mmaModChat.logView(chat.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.chatLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshChat = function() {
        fetchChatData(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Chat service.
 *
 * @module mm.addons.mod_chat
 * @ngdoc service
 * @name $mmaModChat
 */
.factory('$mmaModChat', ["$q", "$mmSite", "$mmUser", "$mmSitesManager", function($q, $mmSite, $mmUser, $mmSitesManager) {
    var self = {};


    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the chat WS are available.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_chat_get_chats_by_courses') &&
                    site.wsAvailable('mod_chat_login_user') &&
                    site.wsAvailable('mod_chat_get_chat_users') &&
                    site.wsAvailable('mod_chat_send_chat_message') &&
                    site.wsAvailable('mod_chat_get_chat_latest_messages');
        });
    };

    /**
     * Get a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#getChat
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @param {Boolean} [refresh] True when we should not get the value from the cache.
     * @return {Promise}        Promise resolved when the chat is retrieved.
     */
    self.getChat = function(courseid, cmid, refresh) {
        var params = {
            courseids: [courseid]
            },
            preSets = {};

        if (refresh) {
            preSets.getFromCache = false;
        }

        return $mmSite.read('mod_chat_get_chats_by_courses', params, preSets).then(function(response) {
            if (response.chats) {
                var currentChat;
                angular.forEach(response.chats, function(chat) {
                    if (chat.coursemodule == cmid) {
                        currentChat = chat;
                    }
                });
                if (currentChat) {
                    return currentChat;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#loginUser
     * @param {Number} chatId   Chat instance ID.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.loginUser = function(chatId) {
        var params = {
            chatid: chatId
        };

        return $mmSite.write('mod_chat_login_user', params).then(function(response) {
            if (response.chatsid) {
                return response.chatsid;
            }
            return $q.reject();
        });
    };

    /**
     * Report a chat as being viewed.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                chatid: id
            };
            return $mmSite.write('mod_chat_view_chat', params);
        }
        return $q.reject();
    };

    /**
     * Send a message to a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#sendMessage
     * @param {Number} chatsid  Chat sessiond ID.
     * @param {String} message  Message text.
     * @param {Number} beep     Beep user ID.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.sendMessage = function(chatsid, message, beep) {
        var params = {
            chatsid: chatsid,
            messagetext: message,
            beepid: beep
        };

        return $mmSite.write('mod_chat_send_chat_message', params).then(function(response) {
            if (response.messageid) {
                return response.messageid;
            }
            return $q.reject();
        });
    };

    /**
     * Get the latest messages from a chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#getLatestMessages
     * @param {Number} chatsid  Chat sessiond ID.
     * @param {Number} lasttime Last time when messages were retrieved.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.getLatestMessages = function(chatsid, lasttime) {
        var params = {
            chatsid: chatsid,
            chatlasttime: lasttime
        };
        var preSets = {
            getFromCache: false
        };

        return $mmSite.read('mod_chat_get_chat_latest_messages', params, preSets);
    };

    /**
     * Get user data for messages since they only have userid.
     *
     * @module mm.addons.messages
     * @ngdoc method
     * @name $mmaModChat#getMessagesUserData
     * @param {Object[]} messages    Messages to get the data for.
     * @param {Number}   courseid    ID of the course the messages belong to.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted messages.
     */
    self.getMessagesUserData = function(messages, courseid) {
        var promises = [];

        angular.forEach(messages, function(message) {
            var promise = $mmUser.getProfile(message.userid, courseid, true).then(function(user) {
                message.userfullname = user.fullname;
                message.userprofileimageurl = user.profileimageurl;
            }, function() {
                // Error getting profile. Set default data.
                message.userfullname = message.userid;
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return messages;
        });
    };

    /**
     * Get the actives users of a current chat.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChat#getChatUsers
     * @param {Number} chatsid  Chat sessiond ID.
     * @return {Promise}        Promise resolved when the WS is executed.
     */
    self.getChatUsers = function(chatsid) {
        var params = {
            chatsid: chatsid
        };
        var preSets = {
            getFromCache: false
        };

        return $mmSite.read('mod_chat_get_chat_users', params, preSets);
    };

    return self;
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_chat')

/**
 * Mod chat handlers.
 *
 * @module mm.addons.mod_chat
 * @ngdoc service
 * @name $mmaModChatHandlers
 */
.factory('$mmaModChatHandlers', ["$mmCourse", "$mmaModChat", "$state", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModChat, $state, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChatHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModChat.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('chat');
                $scope.action = function(e) {
                    $state.go('site.mod_chat', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_chat
     * @ngdoc method
     * @name $mmaModChatHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModChat.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a chat URL.
            if (url.indexOf('/mod/chat/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice')

/**
 * Choice index controller.
 *
 * @module mm.addons.mod_choice
 * @ngdoc controller
 * @name mmaModChoiceIndexCtrl
 * @todo Delete answer if user can update the answer, show selected if choice is closed (WS returns empty options).
 */
.controller('mmaModChoiceIndexCtrl', ["$scope", "$timeout", "$stateParams", "$mmaModChoice", "$mmUtil", "$q", "$mmCourse", "$translate", function($scope, $timeout, $stateParams, $mmaModChoice, $mmUtil, $q, $mmCourse, $translate) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        choice,
        hasAnswered = false;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;

    $scope.d3_options = {
        chart: {
            type: 'discreteBarChart',
            x: function(d){ return d.label; },
            y: function(d){ return d.value; },
            showValues: true,
            valueFormat: function(d){
                return d3.format('')(d);
            },
            transitionDuration: 500,
            xAxis: {},
            yAxis: {
                tickFormat: function(d){ return d3.format(',f')(d) }
            },
            // https://nvd3-community.github.io/nvd3/examples/documentation.html#tooltip
            tooltip: {
                contentGenerator: function(obj) {
                    // console.log(obj);
                    return d3.format('.1%')(obj.data.percent);
                }
            },
            // https://github.com/krispo/angular-nvd3/issues/36
            discretebar: {
                dispatch: {
                    renderEnd: function(e){
                        d3.selectAll(".tick text").call(wrap,_chart.xAxis.rangeBand());
                    },
                }
            },
            callback: function(chart){
                _chart = chart; //global var
            }
        }
    };

    // re-wrap x-axis labels after (swipe down) refresh
    $scope.d3_events = {
        'scroll.refreshComplete': function(e, scope) {
            // The mirky depths of Angular require wrapping this event handler in $timeout()
            // for the text wrapping to persist in the DOM.
            // example: https://github.com/krispo/angular-nvd3/issues/36
            // background: https://docs.angularjs.org/error/$rootScope/inprog
            $timeout(function() {d3.selectAll(".tick text").call(wrap,_chart.xAxis.rangeBand());}, 0);
        }
    };

    // http://bl.ocks.org/mbostock/7555321
    function wrap(text, width) {
      text.each(function() {
        var text = d3.select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            y = text.attr("y"),
            dy = parseFloat(text.attr("dy")),
            tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
          }
        }
      });
    }

    // Convenience function to get choice data.
    function fetchChoiceData(refresh) {
        $scope.now = new Date().getTime();
        return $mmaModChoice.getChoice(courseid, module.id).then(function(choicedata) {
            choice = choicedata;
            choice.timeopen = parseInt(choice.timeopen) * 1000;
            choice.openTimeReadable = moment(choice.timeopen).format('LLL');
            choice.timeclose = parseInt(choice.timeclose) * 1000;
            choice.closeTimeReadable = moment(choice.timeclose).format('LLL');

            $scope.title = choice.name || $scope.title;
            $scope.description = choice.intro || $scope.description;
            $scope.choice = choice;

            // We need fetchOptions to finish before calling fetchResults because it needs hasAnswered variable.
            return fetchOptions().then(function() {
                return fetchResults();
            });
        }).catch(function(message) {
            if (!refresh) {
                // Some call failed, retry without using cache since it might be a new activity.
                return refreshAllData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_choice.errorgetchoice', true);
            }
            return $q.reject();
        });
    }

    // Convenience function to get choice options.
    function fetchOptions() {
        return $mmaModChoice.getOptions(choice.id).then(function(options) {
            var isOpen = isChoiceOpen();
            hasAnswered = false;
            $scope.selectedOption = {id: -1}; // Single choice model.
            angular.forEach(options, function(option) {
                if (option.checked) {
                    hasAnswered = true;
                    if (!choice.allowmultiple) {
                        $scope.selectedOption.id = option.id;
                    }
                }
            });
            $scope.canEdit = isOpen && (choice.allowupdate || !hasAnswered);
            $scope.canDelete = $mmaModChoice.isDeleteResponsesEnabled() && isOpen && choice.allowupdate && hasAnswered;
            $scope.options = options;
        });
    }

    // Convenience function to get choice results.
    function fetchResults() {
        return $mmaModChoice.getResults(choice.id).then(function(results) {
            var hasVotes = false;
            var data     = [];
            angular.forEach(results, function(result) {
                if (result.numberofuser > 0) {
                    hasVotes = true;
                }
                result.percentageamount = parseFloat(result.percentageamount).toFixed(1);
                data.push({
                    'label': result.text,
                    'value': result.numberofuser,
                    'percent': result.percentageamount / 100 });
            });
            $scope.canSeeResults = hasVotes || $mmaModChoice.canStudentSeeResults(choice, hasAnswered);
            $scope.results = results;
            $scope.data = [{
                //key: "Some key to the data?",
                values: data
            }];
        });
    }

    /**
     * Check if a choice is open.
     *
     * @return {Boolean} True if choice is open, false otherwise.
     */
    function isChoiceOpen() {
        return (choice.timeopen === 0 || choice.timeopen <= $scope.now) &&
                (choice.timeclose === 0 || choice.timeclose > $scope.now);
    }

    // Convenience function to refresh all the data.
    function refreshAllData() {
        var p1 = $mmaModChoice.invalidateChoiceData(courseid),
            p2 = choice ? $mmaModChoice.invalidateOptions(choice.id) : $q.when(),
            p3 = choice ? $mmaModChoice.invalidateResults(choice.id) : $q.when();

        return $q.all([p1, p2, p3]).finally(function() {
            return fetchChoiceData(true);
        });
    }

    fetchChoiceData().then(function() {
        $mmaModChoice.logView(choice.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.choiceLoaded = true;
    });

    // Save options selected.
    $scope.save = function() {
        // Only show confirm if choice doesn't allow update.
        var promise = choice.allowupdate ? $q.when() : $mmUtil.showConfirm($translate('mm.core.areyousure'));
        promise.then(function() {
            var responses = [];
            if (choice.allowmultiple) {
                angular.forEach($scope.options, function(option) {
                    if (option.checked) {
                        responses.push(option.id);
                    }
                });
            } else {
                responses.push($scope.selectedOption.id);
            }

            var modal = $mmUtil.showModalLoading('mm.core.sending', true);
            $mmaModChoice.submitResponse(choice.id, responses).then(function() {
                // Success! Let's refresh the data.
                return refreshAllData();
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_choice.cannotsubmit', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };

    // Delete options selected.
    $scope.delete = function() {
        $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
            var modal = $mmUtil.showModalLoading('mm.core.sending', true);
            $mmaModChoice.deleteResponses(choice.id).then(function() {
                // Success! Let's refresh the data.
                return refreshAllData();
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_choice.cannotsubmit', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };

    // Pull to refresh.
    $scope.refreshChoice = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice')

/**
 * Choice service.
 *
 * @module mm.addons.mod_choice
 * @ngdoc service
 * @name $mmaModChoice
 */
.factory('$mmaModChoice', ["$q", "$mmSite", "$mmSitesManager", "mmaModChoiceResultsAfterAnswer", "mmaModChoiceResultsAfterClose", "mmaModChoiceResultsAlways", function($q, $mmSite, $mmSitesManager, mmaModChoiceResultsAfterAnswer, mmaModChoiceResultsAfterClose,
            mmaModChoiceResultsAlways) {
    var self = {};

    /**
     * Check if results can be seen by a student. The student can see the results if:
     *     - they're always published, OR
     *     - they're published after the choice is closed and it's closed, OR
     *     - they're published after answering and the user has answered.
     *
     * @param {Object}  choice      Choice to check.
     * @param {Boolean} hasAnswered True if user has answered the choice, false otherwise.
     * @return {Boolean} [description]
     */
    self.canStudentSeeResults = function(choice, hasAnswered) {
        var now = new Date().getTime();
        return  choice.showresults === mmaModChoiceResultsAlways ||
                choice.showresults === mmaModChoiceResultsAfterClose && choice.timeclose !== 0 && choice.timeclose <= now ||
                choice.showresults === mmaModChoiceResultsAfterAnswer && hasAnswered;
    };

    /**
     * Delete responses from a choice.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#deleteResponses
     * @param {Number} choiceid      Choice ID.
     * @param {Number[]} [responses] IDs of the answers. If not defined, delete all the answers of the current user.
     * @return {Promise}             Promise resolved when the options are deleted.
     */
    self.deleteResponses = function(choiceid, responses) {
        responses = responses || [];
        var params = {
            choiceid: choiceid,
            responses: responses
        };
        return $mmSite.write('mod_choice_delete_choice_responses', params).then(function(response) {
            if (!response || response.status === false) {
                return $q.reject();
            }
        });
    };

    /**
     * Get cache key for choice data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getChoiceDataCacheKey(courseid) {
        return 'mmaModChoice:choice:' + courseid;
    }

    /**
     * Get cache key for choice options WS calls.
     *
     * @param {Number} choiceid Choice ID.
     * @return {String}     Cache key.
     */
    function getChoiceOptionsCacheKey(choiceid) {
        return 'mmaModChoice:options:' + choiceid;
    }

    /**
     * Get cache key for choice results WS calls.
     *
     * @param {Number} choiceid Choice ID.
     * @return {String}     Cache key.
     */
    function getChoiceResultsCacheKey(choiceid) {
        return 'mmaModChoice:results:' + choiceid;
    }

    /**
     * Returns if current site supports deleting choice responses.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#isDeleteResponsesEnabled
     * @return {Boolean} True if supported, false otherwise.
     */
    self.isDeleteResponsesEnabled = function() {
        return $mmSite.wsAvailable('mod_choice_delete_choice_responses');
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the choice WS are available.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_choice_get_choice_options') &&
                    site.wsAvailable('mod_choice_get_choice_results') &&
                    site.wsAvailable('mod_choice_get_choices_by_courses') &&
                    site.wsAvailable('mod_choice_submit_choice_response');
        });
    };

    /**
     * Get a choice.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#getChoice
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the choice is retrieved.
     */
    self.getChoice = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getChoiceDataCacheKey(courseid)
            };

        return $mmSite.read('mod_choice_get_choices_by_courses', params, preSets).then(function(response) {
            if (response.choices) {
                var currentChoice;
                angular.forEach(response.choices, function(choice) {
                    if (choice.coursemodule == cmid) {
                        currentChoice = choice;
                    }
                });
                if (currentChoice) {
                    return currentChoice;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get a choice options.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#getOptions
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved with choice options.
     */
    self.getOptions = function(choiceid) {
        var params = {
                choiceid: choiceid
            },
            preSets = {
                cacheKey: getChoiceOptionsCacheKey(choiceid)
            };

        return $mmSite.read('mod_choice_get_choice_options', params, preSets).then(function(response) {
            if (response.options) {
                return response.options;
            }
            return $q.reject();
        });
    };

    /**
     * Get a choice results.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#getResults
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved with choice results.
     */
    self.getResults = function(choiceid) {
        var params = {
                choiceid: choiceid
            },
            preSets = {
                cacheKey: getChoiceResultsCacheKey(choiceid)
            };

        return $mmSite.read('mod_choice_get_choice_results', params, preSets).then(function(response) {
            if (response.options) {
                return response.options;
            }
            return $q.reject();
        });
    };

    /**
     * Invalidates choice data.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#invalidateChoiceData
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateChoiceData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getChoiceDataCacheKey(courseid));
    };

    /**
     * Invalidates options.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#invalidateOptions
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateOptions = function(choiceid) {
        return $mmSite.invalidateWsCacheForKey(getChoiceOptionsCacheKey(choiceid));
    };

    /**
     * Invalidates results.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#invalidateResults
     * @param {Number} choiceid Choice ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateResults = function(choiceid) {
        return $mmSite.invalidateWsCacheForKey(getChoiceResultsCacheKey(choiceid));
    };

    /**
     * Report the choice as being viewed.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#logView
     * @param {String} id Choice ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                choiceid: id
            };
            return $mmSite.write('mod_choice_view_choice', params);
        }
        return $q.reject();
    };

    /**
     * Send a response to a choice to Moodle.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoice#submitResponse
     * @param {Number} choiceid    Choice ID.
     * @param {Number[]} responses IDs of selected options.
     * @return {Promise}           Promise resolved when results are successfully submitted.
     */
    self.submitResponse = function(choiceid, responses) {
        var params = {
            choiceid: choiceid,
            responses: responses
        };
        return $mmSite.write('mod_choice_submit_choice_response', params);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_choice')

/**
 * Mod choice handlers.
 *
 * @module mm.addons.mod_choice
 * @ngdoc service
 * @name $mmaModChoiceHandlers
 */
.factory('$mmaModChoiceHandlers', ["$mmCourse", "$mmaModChoice", "$state", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModChoice, $state, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoiceHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModChoice.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('choice');
                $scope.action = function(e) {
                    $state.go('site.mod_choice', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_choice
     * @ngdoc method
     * @name $mmaModChoiceHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModChoice.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a choice URL.
            if (url.indexOf('/mod/choice/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Folder index controller.
 *
 * @module mm.addons.mod_folder
 * @ngdoc controller
 * @name mmaModFolderIndexCtrl
 */
.controller('mmaModFolderIndexCtrl', ["$scope", "$stateParams", "$mmaModFolder", "$mmCourse", "$mmUtil", "$q", function($scope, $stateParams, $mmaModFolder, $mmCourse, $mmUtil, $q) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        sectionid = $stateParams.sectionid,
        path = $stateParams.path;

    // Convenience function to set scope data using module.
    function showModuleData(module) {
        $scope.title = module.name;
        $scope.description = module.description;
        if (path) {
            // Subfolder.
            $scope.contents = module.contents;
        } else {
            $scope.contents = $mmaModFolder.formatContents(module.contents);
            $scope.moduleurl = module.url;
        }
    }

    // Convenience function to fetch folder data from Moodle.
    function fetchFolder() {
        return $mmCourse.getModule(module.id, courseid, sectionid).then(function(module) {
            showModuleData(module);
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.mod_folder.errorwhilegettingfolder', true);
            }

            if (!$scope.title) {
                // Error getting data from server. Use module param.
                showModuleData(module);
            }
            return $q.reject();
        });
    }

    if (path) {
        // Subfolder. Use module param.
        showModuleData(module);
        $scope.folderLoaded = true;
        $scope.canReload = false;
    } else {
        fetchFolder().then(function() {
            $mmaModFolder.logView(module.instance).then(function() {
                $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
            });
        }).finally(function() {
            $scope.folderLoaded = true;
            $scope.canReload = true;
        });
    }

    $scope.refreshFolder = function() {
        $mmCourse.invalidateModule(module.id).finally(function() {
            fetchFolder().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Folder service.
 *
 * @module mm.addons.mod_folder
 * @ngdoc service
 * @name $mmaModFolder
 * @todo Adding a new file in a folder updates the revision of all the files, so they're all shown as outdated.
 *       To ignore revision in folders we'll have to modify $mmCoursePrefetchDelegate, mm-file and $mmFilepool.
 */
.factory('$mmaModFolder', ["$mmSite", "$mmCourse", "$q", "$mmFilepool", "mmaModFolderComponent", function($mmSite, $mmCourse, $q, $mmFilepool, mmaModFolderComponent) {
    var self = {};

    /**
     * Download all the content.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModFolderComponent, module.id, revision, timemod);
    };

    /**
     * Format folder contents, creating directory structure.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#formatContents
     * @param {Object[]} contents Folder contents.
     * @return {Object[]}         Formatted contents.
     * @description
     * Format folder contents, creating directory structure.
     * Folders found in filepaths are added to the array. Each folder has the properties: name, fileicon,
     * type (folder), filepath and contents (array with files and subfolders).
     */
    self.formatContents = function(contents) {
        var files = [],
            folders = [],
            foldericon = $mmCourse.getModuleIconSrc('folder');

        angular.forEach(contents, function(entry) {
            if (entry.filepath !== '/') {
                // It's a file in a subfolder. Lets treat the path to add the subfolders to the array.
                var directories,
                    currentList = folders, // Start at root level.
                    path = entry.filepath,
                    subpath = '';

                // Remove first and last slash if needed.
                if (path.substr(0, 1) === '/') {
                    path = path.substr(1);
                }
                if (path.substr(path.length - 1) === '/') {
                    path = path.slice(0, -1);
                }

                directories = path.split('/');

                angular.forEach(directories, function(directory) {
                    subpath = subpath + '/' + directory;
                    // Search if the directory is already stored in folders array.
                    var found = false;
                    for (var i = 0; i < currentList.length; i++) {
                        if (currentList[i].name === directory) {
                            currentList = currentList[i].contents;
                            found = true;
                            break;
                        }
                    }
                    // Directory not found. Add it to the array.
                    if (!found) {
                        var newFolder = {
                            name: directory,
                            fileicon: foldericon,
                            contents: [],
                            filepath: subpath,
                            type: 'folder'
                        };
                        currentList.push(newFolder);
                        currentList = newFolder.contents;
                    }
                });

                currentList.push(entry);
            } else {
                files.push(entry);
            }
        });

        return folders.concat(files);
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Report a folder as being viewed.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                folderid: id
            };
            return $mmSite.write('mod_folder_view_folder', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolder#prefetchContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModFolderComponent, module.id, revision, timemod);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Mod Folder handlers.
 *
 * @module mm.addons.mod_folder
 * @ngdoc service
 * @name $mmaModFolderHandlers
 */
.factory('$mmaModFolderHandlers', ["$mmCourse", "$mmaModFolder", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModFolderComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModFolder, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModFolderComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @module mm.addons.mod_folder
         * @ngdoc method
         * @name $mmaModFolderCourseContentHandler#isEnabled
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Get the controller.
         *
         * @module mm.addons.mod_folder
         * @ngdoc method
         * @name $mmaModFolderCourseContentHandler#getController
         * @param {Object} module    The module info.
         * @param {Number} courseid  Course ID.
         * @param {Number} sectionid Section ID.
         * @return {Function}
         */
        self.getController = function(module, courseid, sectionid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                // Prefetch folder contents.
                function prefetchFolder(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    $mmaModFolder.prefetchContent(module).catch(function() {
                        if (!$scope.$$destroyed) {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: prefetchFolder
                };

                refreshBtn = {
                    hidden: true,
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    action: prefetchFolder
                };

                $scope.icon = $mmCourse.getModuleIconSrc('folder');
                $scope.title = module.name;
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_folder', {module: module, courseid: courseid, sectionid: sectionid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModFolderComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            if (courseId) {
                return $q.when(true);
            }
            return $mmCourse.canGetModuleWithoutCourseId(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a folder URL.
            if (url.indexOf('/mod/folder/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_folder')

/**
 * Mod folder prefetch handler.
 *
 * @module mm.addons.mod_folder
 * @ngdoc service
 * @name $mmaModFolderPrefetchHandler
 */
.factory('$mmaModFolderPrefetchHandler', ["$mmaModFolder", "$mmSite", "mmaModFolderComponent", function($mmaModFolder, $mmSite, mmaModFolderComponent) {

    var self = {};

    self.component = mmaModFolderComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderPrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModFolder.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return true;
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_folder
     * @ngdoc method
     * @name $mmaModFolderPrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModFolder.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Forum discussion controller.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name mmaModForumDiscussionCtrl
 */
.controller('mmaModForumDiscussionCtrl', ["$q", "$scope", "$stateParams", "$mmaModForum", "$mmSite", "$mmUtil", "$translate", "$ionicScrollDelegate", "mmaModForumComponent", function($q, $scope, $stateParams, $mmaModForum, $mmSite, $mmUtil, $translate,
            $ionicScrollDelegate, mmaModForumComponent) {

    var discussionid = $stateParams.discussionid,
        courseid = $stateParams.cid,
        scrollView;

    $scope.component = mmaModForumComponent;
    $scope.courseid = courseid;
    $scope.newpost = {
        replyingto: undefined,
        subject: '',
        message: ''
    };

    // Convenience function to get forum discussions.
    function fetchPosts() {
        return $mmaModForum.getDiscussionPosts(discussionid).then(function(posts) {
            $scope.discussion = $mmaModForum.extractStartingPost(posts);
            $scope.posts = posts;

            // Set default reply subject.
            return $translate('mma.mod_forum.re').then(function(strReplyPrefix) {
                $scope.defaultSubject = strReplyPrefix + ' ' + $scope.discussion.subject;
                $scope.newpost.subject = $scope.defaultSubject;
            });
        }, function(message) {
            $mmUtil.showErrorModal(message);
            return $q.reject();
        });
    }

    // Refresh posts.
    function refreshPosts() {
        return $mmaModForum.invalidateDiscussionPosts(discussionid).finally(function() {
            return fetchPosts();
        });
    }

    fetchPosts().then(function() {
        // Add log in Moodle.
        $mmSite.write('mod_forum_view_forum_discussion', {
            discussionid: discussionid
        });
    }).finally(function() {
        $scope.discussionLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshPosts = function() {
        refreshPosts().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // New post added.
    $scope.newPostAdded = function() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmaModForumPostsScroll');
        }
        scrollView && scrollView.scrollTop && scrollView.scrollTop();

        $scope.newpost.replyingto = undefined;
        $scope.newpost.subject = $scope.defaultSubject;
        $scope.newpost.message = '';

        $scope.discussionLoaded = false;
        refreshPosts().finally(function() {
            $scope.discussionLoaded = true;
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Forum discussion list controller.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name mmaModForumDiscussionsCtrl
 */
.controller('mmaModForumDiscussionsCtrl', ["$q", "$scope", "$stateParams", "$mmaModForum", "$mmCourse", "$mmUtil", "$mmGroups", "$mmEvents", "$ionicScrollDelegate", "$ionicPlatform", "mmUserProfileState", "mmaModForumNewDiscussionEvent", function($q, $scope, $stateParams, $mmaModForum, $mmCourse, $mmUtil, $mmGroups,
            $mmEvents, $ionicScrollDelegate, $ionicPlatform, mmUserProfileState, mmaModForumNewDiscussionEvent) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        forum,
        page = 0,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaModForumDiscussionsScroll'),
        shouldScrollTop = false,
        usesGroups = false;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;
    $scope.userStateName = mmUserProfileState;
    $scope.isCreateEnabled = $mmaModForum.isCreateDiscussionEnabled();

    // Convenience function to get forum data and discussions.
    function fetchForumDataAndDiscussions(refresh) {
        return $mmaModForum.getForum(courseid, module.id).then(function(forumdata) {
            forum = forumdata;

            $scope.title = forum.name || $scope.title;
            $scope.description = forum.intro || $scope.description;
            $scope.forum = forum;

            return $mmGroups.getActivityGroupMode(forum.cmid).then(function(mode) {
                usesGroups = mode === $mmGroups.SEPARATEGROUPS || mode === $mmGroups.VISIBLEGROUPS;
            }).finally(function() {
                return fetchDiscussions(refresh);
            });
        }, function(message) {
            if (!refresh) {
                // Get forum failed, retry without using cache since it might be a new activity.
                return refreshData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_forum.errorgetforum', true);
            }
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
            return $q.reject();
        });
    }

    // Convenience function to get forum discussions.
    function fetchDiscussions(refresh) {
        if (refresh) {
            page = 0;
        }

        return $mmaModForum.getDiscussions(forum.id, page).then(function(response) {
            var promise = usesGroups ?
                    $mmaModForum.formatDiscussionsGroups(forum.cmid, response.discussions) : $q.when(response.discussions);
            return promise.then(function(discussions) {
                if (page == 0) {
                    $scope.discussions = discussions;
                } else {
                    $scope.discussions = $scope.discussions.concat(discussions);
                }

                $scope.count = $scope.discussions.length;
                $scope.canLoadMore = response.canLoadMore;
                page++;

                preFetchDiscussionsPosts(discussions);
            });
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
            return $q.reject();
        });
    }

    // Convenience function to prefetch the posts of each discussion, so they're available in offline mode.
    function preFetchDiscussionsPosts(discussions) {
        angular.forEach(discussions, function(discussion) {
            var discussionid = discussion.discussion;
            $mmaModForum.getDiscussionPosts(discussionid);
        });
    }

    // Refresh forum data and discussions list.
    function refreshData() {
        var promises = [];
        promises.push($mmaModForum.invalidateForumData(courseid));
        if (forum) {
            promises.push($mmaModForum.invalidateDiscussionsList(forum.id));
            promises.push($mmGroups.invalidateActivityGroupMode(forum.cmid));
        }
        return $q.all(promises).finally(function() {
            return fetchForumDataAndDiscussions(true);
        });
    }

    fetchForumDataAndDiscussions().then(function() {
        $mmaModForum.logView(forum.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.discussionsLoaded = true;
    });

    // Load more discussions.
    $scope.loadMoreDiscussions = function() {
        fetchDiscussions().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };

    // Pull to refresh.
    $scope.refreshDiscussions = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Listen for discussions added. When a discussion is added, we reload the data.
    var obsNewDisc = $mmEvents.on(mmaModForumNewDiscussionEvent, function(data) {
        if ((forum && forum.id === data.forumid) || data.cmid === module.id) {
            if ($ionicPlatform.isTablet()) {
                scrollView.scrollTop();
            } else {
                // We can't scroll top inmediately because the scroll is not seen.
                shouldScrollTop = true;
            }
            $scope.discussionsLoaded = false;
            refreshData().finally(function() {
                $scope.discussionsLoaded = true;
            });
        }
    });

    // Scroll top if needed.
    $scope.$on('$ionicView.enter', function() {
        if (shouldScrollTop) {
            shouldScrollTop = false;
            scrollView.scrollTop();
        }
    });

    $scope.$on('$destroy', function(){
        if (obsNewDisc && obsNewDisc.off) {
            obsNewDisc.off();
        }
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Add new discussion controller.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name mmaModForumNewDiscussionCtrl
 */
.controller('mmaModForumNewDiscussionCtrl', ["$scope", "$stateParams", "$mmGroups", "$q", "$mmaModForum", "$mmEvents", "$ionicPlatform", "$mmUtil", "$ionicHistory", "$translate", "mmaModForumNewDiscussionEvent", function($scope, $stateParams, $mmGroups, $q, $mmaModForum, $mmEvents, $ionicPlatform,
            $mmUtil, $ionicHistory, $translate, mmaModForumNewDiscussionEvent) {

    var courseid = $stateParams.cid,
        forumid = $stateParams.forumid,
        cmid = $stateParams.cmid;

    $scope.newdiscussion = {
        subject: '',
        message: '',
        subscribe: true
    };

    // Fetch if forum uses groups and the groups it uses.
    function fetchGroups(refresh) {
        return $mmGroups.getActivityGroupMode(cmid).then(function(mode) {
            if (mode === $mmGroups.SEPARATEGROUPS || mode === $mmGroups.VISIBLEGROUPS) {
                return $mmGroups.getActivityAllowedGroups(cmid).then(function(forumgroups) {
                    var promise;
                    if (mode === $mmGroups.VISIBLEGROUPS) {
                        // We need to check which of the returned groups the user can post to.
                        promise = validateVisibleGroups(forumgroups, refresh);
                    } else {
                        // WS already filters groups, no need to do it ourselves.
                        promise = $q.when(forumgroups);
                    }

                    return promise.then(function(forumgroups) {
                        if (forumgroups.length > 0) {
                            $scope.groups = forumgroups;
                            $scope.newdiscussion.groupid = forumgroups[0].id;
                            $scope.showGroups = true;
                            $scope.showForm = true;
                        } else {
                            var message = mode === $mmGroups.SEPARATEGROUPS ?
                                                'mma.mod_forum.cannotadddiscussionall' : 'mma.mod_forum.cannotadddiscussion';
                            return $q.reject($translate.instant(message));
                        }
                    });
                });
            } else {
                $scope.showGroups = false;
                $scope.showForm = true;
            }
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_forum.errorgetgroups', true);
            }
            $scope.showForm = false;
            return $q.reject();
        });
    }

    // Validate which of the groups returned by getActivityAllowedGroups in visible groups should be shown to post to.
    function validateVisibleGroups(forumgroups, refresh) {
        if ($mmaModForum.isCanAddDiscussionAvailable()) {
            // Use the canAddDiscussion function to filter the groups.
            // We first check if the user can post to all the groups.
            return $mmaModForum.canAddDiscussionToAll(forumid).catch(function() {
                // The call failed, let's assume he can't.
                return false;
            }).then(function(canAdd) {
                if (canAdd) {
                    // The user can post to all groups, return them all.
                    return forumgroups;
                } else {
                    // The user can't post to all groups, let's check which groups he can post to.
                    var promises = [],
                        filtered = [];

                    angular.forEach(forumgroups, function(group) {
                        promises.push($mmaModForum.canAddDiscussion(forumid, group.id).catch(function() {
                            // The call failed, let's return true so the group is shown. If the user can't post to
                            // it an error will be shown when he tries to add the discussion.
                            return true;
                        }).then(function(canAdd) {
                            if (canAdd) {
                                filtered.push(group);
                            }
                        }));
                    });

                    return $q.all(promises).then(function() {
                        return filtered;
                    });
                }
            });
        } else {
            // We can't check it using WS. We'll get the groups the user belongs to and use them to
            // filter the groups to post.
            return $mmGroups.getUserGroupsInCourse(courseid, refresh).then(function(usergroups) {
                if (usergroups.length === 0) {
                    // User doesn't belong to any group, probably a teacher. Let's return all groups,
                    // if the user can't post to some of them it will be filtered by add discussion WS.
                    return forumgroups;
                }
                return filterGroups(forumgroups, usergroups);
            });
        }
    }

    // Filter forumgroups, returning only those that are inside usergroups.
    function filterGroups(forumgroups, usergroups) {
        var filtered = [],
            usergroupsids = usergroups.map(function(g) {
                return g.id;
            });

        angular.forEach(forumgroups, function(fg) {
            if (usergroupsids.indexOf(fg.id) > -1) {
                filtered.push(fg);
            }
        });

        return filtered;
    }

    fetchGroups().finally(function() {
        $scope.groupsLoaded = true;
    });

    // Pull to refresh.
    $scope.refreshGroups = function() {
        var p1 = $mmGroups.invalidateActivityGroupMode(cmid),
            p2 = $mmGroups.invalidateActivityAllowedGroups(cmid),
            p3 = $mmaModForum.invalidateCanAddDiscussion(forumid);

        $q.all([p1, p2]).finally(function() {
            fetchGroups(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    // Add a new discussion.
    $scope.add = function() {
        var subject = $scope.newdiscussion.subject,
            message = $scope.newdiscussion.message,
            subscribe = $scope.newdiscussion.subscribe,
            groupid = $scope.newdiscussion.groupid;

        if (!subject) {
            $mmUtil.showErrorModal('mma.mod_forum.erroremptysubject', true);
            return;
        }
        if (!message) {
            $mmUtil.showErrorModal('mma.mod_forum.erroremptymessage', true);
            return;
        }
        message = '<p>' + message + '<p>';

        $mmaModForum.addNewDiscussion(forumid, subject, message, subscribe, groupid).then(function(discussionid) {
            var data = {
                forumid: forumid,
                discussionid: discussionid,
                cmid: cmid
            };
            $mmEvents.trigger(mmaModForumNewDiscussionEvent, data);

            if ($ionicPlatform.isTablet()) {
                // Empty form.
                $scope.newdiscussion.subject = '';
                $scope.newdiscussion.message = '';
            } else {
                // Go back to discussions list.
                $ionicHistory.goBack();
            }
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_forum.cannotcreatediscussion', true);
            }
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Directive to show a discussion post, its attachments and the action buttons allowed (reply, etc.).
 *
 * @module mm.addons.mod_forum
 * @ngdoc directive
 * @name mmaForumDiscussionPost
 * @description
 * This directive will show a forum post if the right data is supplied. Attributes:
 *
 * @param {Object} post             Post.
 * @param {Number} courseid         Post's course ID.
 * @param {String} title            Post's title.
 * @param {String} subject          Post's subject.
 * @param {String} component        Component this post belong to.
 * @param {Object} newpost          Object with the new post data. Usually shared between posts.
 * @param {Boolean} showdivider     True if it should have a list divider before the post.
 * @param {Boolean} titleimportant  True if title should be "important" (bold).
 * @oaram {Function} [postadded]    Function to call when a new post is added.
 * @param {String} [defaultsubject] Default subject to set to new posts.
 */
.directive('mmaModForumDiscussionPost', ["$mmaModForum", "$mmUtil", "$translate", "$q", function($mmaModForum, $mmUtil, $translate, $q) {
    return {
        restrict: 'E',
        scope: {
            post: '=',
            courseid: '=',
            title: '=',
            subject: '=',
            component: '=',
            newpost: '=',
            showdivider: '=?',
            titleimportant: '=?',
            postadded: '&?',
            defaultsubject: '=?'
        },
        templateUrl: 'addons/mod_forum/templates/discussionpost.html',
        transclude: true,
        link: function(scope) {
            scope.isReplyEnabled = $mmaModForum.isReplyPostEnabled();

            // Set this post as being replied to.
            scope.showReply = function() {
                scope.newpost.replyingto = scope.post.id;
            };

            // Reply to this post.
            scope.reply = function() {
                if (!scope.newpost.subject) {
                    $mmUtil.showErrorModal('mma.mod_forum.erroremptysubject', true);
                    return;
                }
                if (!scope.newpost.message) {
                    $mmUtil.showErrorModal('mma.mod_forum.erroremptymessage', true);
                    return;
                }

                var message = '<p>' + scope.newpost.message.replace(/\n/g, '<br>') + '</p>',
                    modal = $mmUtil.showModalLoading('mm.core.sending', true);

                $mmaModForum.replyPost(scope.newpost.replyingto, scope.newpost.subject, message).then(function() {
                    if (scope.postadded) {
                        scope.postadded();
                    }
                }).catch(function(message) {
                    if (message) {
                        $mmUtil.showErrorModal(message);
                    } else {
                        $mmUtil.showErrorModal('mma.mod_forum.couldnotadd', true);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            };

            // Cancel reply.
            scope.cancel = function() {
                var promise;
                if (!scope.newpost.subject && !scope.newpost.message) {
                    promise = $q.when(); // Nothing written, cancel right away.
                } else {
                    promise = $mmUtil.showConfirm($translate('mm.core.areyousure'));
                }

                promise.then(function() {
                    scope.newpost.replyingto = undefined;
                    scope.newpost.subject = scope.defaultsubject || '';
                    scope.newpost.message = '';
                });
            };
        }
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Forum service.
 *
 * @module mm.addons.mod_forum
 * @ngdoc controller
 * @name $mmaModForum
 */
.factory('$mmaModForum', ["$q", "$mmSite", "$mmUser", "$mmGroups", "$translate", "$mmSitesManager", "mmaModForumDiscPerPage", function($q, $mmSite, $mmUser, $mmGroups, $translate, $mmSitesManager, mmaModForumDiscPerPage) {
    var self = {};

    /**
     * Get cache key for can add discussion WS calls.
     *
     * @param  {Number} forumid Forum ID.
     * @param  {Number} groupid Group ID.
     * @return {String}         Cache key.
     */
    function getCanAddDiscussionCacheKey(forumid, groupid) {
        return getCommonCanAddDiscussionCacheKey(forumid) + ':' + groupid;
    }

    /**
     * Get common part of cache key for can add discussion WS calls.
     *
     * @param  {Number} forumid Forum ID.
     * @return {String}         Cache key.
     */
    function getCommonCanAddDiscussionCacheKey(forumid) {
        return 'mmaModForum:canadddiscussion:' + forumid;
    }

    /**
     * Get cache key for forum data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getForumDataCacheKey(courseid) {
        return 'mmaModForum:forum:' + courseid;
    }

    /**
     * Get cache key for forum discussion posts WS calls.
     *
     * @param  {Number} discussionid Discussion ID.
     * @return {String}              Cache key.
     */
    function getDiscussionPostsCacheKey(discussionid) {
        return 'mmaModForum:discussion:' + discussionid;
    }

    /**
     * Get cache key for forum discussions list WS calls.
     *
     * @param  {Number} forumid Forum ID.
     * @return {String}         Cache key.
     */
    function getDiscussionsListCacheKey(forumid) {
        return 'mmaModForum:discussions:' + forumid;
    }

    /**
     * Add a new discussion.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#addNewDiscussion
     * @param {Number} forumid   Forum ID.
     * @param {String} subject   New discussion's subject.
     * @param {String} message   New discussion's message.
     * @param {String} subscribe True if should subscribe to the discussion, false otherwise.
     * @param {String} [groupid] Group this discussion belongs to.
     * @return {Promise}         Promise resolved when the discussion is created.
     */
    self.addNewDiscussion = function(forumid, subject, message, subscribe, groupid) {
        var params = {
            forumid: forumid,
            subject: subject,
            message: message,
            options: [
                {
                    name: 'discussionsubscribe',
                    value: !!subscribe
                }
            ]
        };
        if (groupid) {
            params.groupid = groupid;
        }

        return $mmSite.write('mod_forum_add_discussion', params).then(function(response) {
            if (!response || !response.discussionid) {
                return $q.reject();
            } else {
                return response.discussionid;
            }
        });
    };

    /**
     * Check if a user can post to a certain group.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#canAddDiscussion
     * @param  {Number} forumid Forum ID.
     * @param  {Number} groupid Group ID.
     * @return {Promise}        Promise resolved with a boolean: true if can add discussion, false otherwise.
     */
    self.canAddDiscussion = function(forumid, groupid) {
        var params = {
                forumid: forumid,
                groupid: groupid
            },
            preSets = {
                cacheKey: getCanAddDiscussionCacheKey(forumid, groupid)
            };

        return $mmSite.read('mod_forum_can_add_discussion', params, preSets).then(function(result) {
            if (result) {
                return !!result.status;
            }
            return $q.reject();
        });
    };

    /**
     * Check if a user can post to all groups.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#canAddDiscussionToAll
     * @param  {Number} forumid Forum ID.
     * @return {Promise}        Promise resolved with a boolean: true if can add discussion to all, false otherwise.
     */
    self.canAddDiscussionToAll = function(forumid) {
        return self.canAddDiscussion(forumid, -1);
    };

    /**
     * Extract the starting post of a discussion from a list of posts. The post is removed from the array passed as a parameter.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getStartingPost
     * @param  {Object[]} posts Posts to search.
     * @return {Object}         Starting post.
     */
    self.extractStartingPost = function(posts) {
        // Check the last post first, since they'll usually be ordered by create time.
        var lastPost = posts[posts.length - 1];
        if (lastPost.parent == 0) {
            posts.pop(); // Remove it from the array.
            return lastPost;
        }

        // Last post wasn't the starting one. Let's search all the posts until we find the first one.
        for (var i = 0; i < posts.length; i++) {
            if (posts[i].parent == 0) {
                array.splice(i, 1); // Remove it from the array.
                return posts[i];
            }
        }

        return undefined;
    };

    /**
     * Check if canAddDiscussion is available.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isCanAddDiscussionAvailable
     * @return {Boolean} True if available, false otherwise.
     */
    self.isCanAddDiscussionAvailable = function() {
        return $mmSite.wsAvailable('mod_forum_can_add_discussion');
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the forum WS are available.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_forum_get_forums_by_courses') &&
                    site.wsAvailable('mod_forum_get_forum_discussions_paginated') &&
                    site.wsAvailable('mod_forum_get_forum_discussion_posts');
        });
    };

    /**
     * Format discussions, setting groupname if the discussion group is valid.
     *
     * @param  {Number} cmid          Forum cmid.
     * @param  {Object[]} discussions List of discussions to format.
     * @return {Promise}              Promise resolved with the formatted discussions.
     */
    self.formatDiscussionsGroups = function(cmid, discussions) {
        discussions = angular.copy(discussions);
        return $translate('mm.core.allparticipants').then(function(strAllParts) {
            return $mmGroups.getActivityAllowedGroups(cmid).then(function(forumgroups) {
                // Turn groups into an object where each group is identified by id.
                var groups = {};
                angular.forEach(forumgroups, function(fg) {
                    groups[fg.id] = fg;
                });

                // Format discussions.
                angular.forEach(discussions, function(disc) {
                    if (disc.groupid === -1) {
                        disc.groupname = strAllParts;
                    } else {
                        var group = groups[disc.groupid];
                        if (group) {
                            disc.groupname = group.name;
                        }
                    }
                });
                return discussions;
            });
        }).catch(function() {
            return discussions;
        });
    };

    /**
     * Get a forum.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getForum
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the forum is retrieved.
     */
    self.getForum = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getForumDataCacheKey(courseid)
            };

        return $mmSite.read('mod_forum_get_forums_by_courses', params, preSets).then(function(forums) {
            var currentForum;
            angular.forEach(forums, function(forum) {
                if (forum.cmid == cmid) {
                    currentForum = forum;
                }
            });
            if (currentForum) {
                return currentForum;
            }
            return $q.reject();
        });
    };

    /**
     * Get forum discussion posts.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getDiscussionPosts
     * @param {Number} discussionid Discussion ID.
     * @return {Promise}            Promise resolved with forum discussions.
     */
    self.getDiscussionPosts = function(discussionid) {
        var params = {
                discussionid: discussionid
            },
            preSets = {
                cacheKey: getDiscussionPostsCacheKey(discussionid)
            };

        return $mmSite.read('mod_forum_get_forum_discussion_posts', params, preSets).then(function(response) {
            if (response) {
                storeUserData(response.posts);
                return response.posts;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Get forum discussions.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#getDiscussions
     * @param {Number} forumid Forum ID.
     * @param {Number} page    Page.
     * @return {Promise}       Promise resolved with forum discussions.
     */
    self.getDiscussions = function(forumid, page) {
        page = page || 0;

        var params = {
                forumid: forumid,
                sortby:  'timemodified',
                sortdirection:  'DESC',
                page: page,
                perpage: mmaModForumDiscPerPage
            },
            preSets = {
                cacheKey: getDiscussionsListCacheKey(forumid)
            };

        return $mmSite.read('mod_forum_get_forum_discussions_paginated', params, preSets).then(function(response) {
            if (response) {
                var canLoadMore = response.discussions.length >= mmaModForumDiscPerPage;
                storeUserData(response.discussions);
                return {discussions: response.discussions, canLoadMore: canLoadMore};
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Invalidates can add discussion WS calls.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateCanAddDiscussion
     * @param  {Number} forumid Forum ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateCanAddDiscussion = function(forumid) {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getCommonCanAddDiscussionCacheKey(forumid));
    };

    /**
     * Invalidates forum discussion posts.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateDiscussionPosts
     * @param {Number} discussionid Discussion ID.
     * @return {Promise}            Promise resolved when the data is invalidated.
     */
    self.invalidateDiscussionPosts = function(discussionid) {
        return $mmSite.invalidateWsCacheForKey(getDiscussionPostsCacheKey(discussionid));
    };

    /**
     * Invalidates discussion list.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateDiscussionsList
     * @param  {Number} forumid Forum ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateDiscussionsList = function(forumid) {
        return $mmSite.invalidateWsCacheForKey(getDiscussionsListCacheKey(forumid));
    };

    /**
     * Invalidates forum data.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#invalidateForumData
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateForumData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getForumDataCacheKey(courseid));
    };

    /**
     * Check if the current site allows creating new discussions.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isCreateDiscussionEnabled
     * @return {Boolean} True if enabled, false otherwise.
     */
    self.isCreateDiscussionEnabled = function() {
        return $mmSite.wsAvailable('core_group_get_activity_groupmode') &&
                $mmSite.wsAvailable('core_group_get_activity_allowed_groups') &&
                $mmSite.wsAvailable('mod_forum_add_discussion');
    };

    /**
     * Check if the current site allows replying to posts.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#isReplyPostEnabled
     * @return {Boolean} True if enabled, false otherwise.
     */
    self.isReplyPostEnabled = function() {
        return $mmSite.wsAvailable('mod_forum_add_discussion_post');
    };

    /**
     * Report a forum as being viewed.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                forumid: id
            };
            return $mmSite.write('mod_forum_view_forum', params);
        }
        return $q.reject();
    };

    /**
     * Reply to a certain post.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForum#replyPost
     * @param {Number} postid  ID of the post being replied.
     * @param {String} subject New post's subject.
     * @param {String} message New post's message.
     * @return {Promise}       Promise resolved when the post is created.
     */
    self.replyPost = function(postid, subject, message) {
        var params = {
            postid: postid,
            subject: subject,
            message: message
        };

        return $mmSite.write('mod_forum_add_discussion_post', params).then(function(response) {
            if (!response || !response.postid) {
                return $q.reject();
            } else {
                return response.postid;
            }
        });
    };

    /**
     * Store the users data from a discussions/posts list.
     *
     * @param {Object[]} list Array of posts or discussions.
     */
    function storeUserData(list) {
        var ids = [];
        angular.forEach(list, function(entry) {
            var id = parseInt(entry.userid);
            if (!isNaN(id) && ids.indexOf(id) === -1) {
                ids.push(id);
                $mmUser.storeUser(id, entry.userfullname, entry.userpictureurl);
            }
            if (typeof entry.usermodified != 'undefined') {
                id = parseInt(entry.usermodified);
                if(!isNaN(id) && ids.indexOf(id) === -1) {
                    ids.push(id);
                    $mmUser.storeUser(id, entry.usermodifiedfullname, entry.usermodifiedpictureurl);
                }
            }
        });
    }

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_forum')

/**
 * Mod forum handlers.
 *
 * @module mm.addons.mod_forum
 * @ngdoc service
 * @name $mmaModForumHandlers
 */
.factory('$mmaModForumHandlers', ["$mmCourse", "$mmaModForum", "$state", "$mmUtil", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModForum, $state, $mmUtil, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForumHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @module mm.addons.mod_forum
         * @ngdoc method
         * @name $mmaModForumCourseContentHandler#isEnabled
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModForum.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @module mm.addons.mod_forum
         * @ngdoc method
         * @name $mmaModForumCourseContentHandler#isEnabled
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('forum');
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_forum', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_forum
     * @ngdoc method
     * @name $mmaModForumHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isIndexEnabled(siteId, courseId) {
            return $mmaModForum.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId Site ID.
         * @return {Promise}       Promise resolved with true if enabled.
         */
        function isDiscEnabled(siteId) {
            // We don't check courseId because it's only needed for user profile links, we can afford not passing it.
            return $mmaModForum.isPluginEnabled(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a forum URL.
            if (url.indexOf('/mod/forum/view.php') > -1) {
                // Forum index.
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isIndexEnabled, courseId);
            } else if (url.indexOf('/mod/forum/discuss.php') > -1) {
                // Forum discussion.
                var params = $mmUtil.extractUrlParams(url);
                if (params.d != 'undefined') {
                    // Pass false because all sites should have the same siteurl.
                    return $mmContentLinksHelper.filterSupportedSites(siteIds, isDiscEnabled, false, courseId).then(function(ids) {
                        if (!ids.length) {
                            return [];
                        } else {
                            // Return actions.
                            return [{
                                message: 'mm.core.view',
                                icon: 'ion-eye',
                                sites: ids,
                                action: function(siteId) {
                                    var stateParams = {
                                        discussionid: parseInt(params.d, 10),
                                        cid: courseId
                                    };
                                    $mmContentLinksHelper.goInSite('site.mod_forum-discussion', stateParams, siteId);
                                }
                            }];
                        }
                    });
                }
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Glossary entry controller.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc controller
 * @name mmaModGlossaryEntryCtrl
 */
.controller('mmaModGlossaryEntryCtrl', ["$scope", "$stateParams", "$mmaModGlossary", "$translate", "mmUserProfileState", function($scope, $stateParams, $mmaModGlossary, $translate,
        mmUserProfileState) {
    var entry = $stateParams.entry || {},
        courseid = $stateParams.cid || 0,
        glossary;

    // This is a coding error, for now the course ID is required here as we need it for the author link.
    if (!courseid) {
        notifyErrorOccured();
        return;
    }

    $scope.refreshEntry = function() {
        refreshEntry().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Load the glossary first.
    $mmaModGlossary.getGlossaryById(courseid, entry.glossaryid).then(function(gloss) {
        glossary = gloss;
        var displayFormat = glossary.displayformat;

        $scope.title = entry.concept;
        $scope.entry = entry;
        $scope.courseid = courseid;
        $scope.userStateName = mmUserProfileState;

        if (displayFormat == 'fullwithauthor' || displayFormat == 'encyclopedia') {
            $scope.showAuthor = true;
            $scope.showDate = true;

        } else if (displayFormat == 'fullwithoutauthor') {
            $scope.showAuthor = false;
            $scope.showDate = true;

        // Default, and faq, simple, entrylist, continuous.
        } else {
            $scope.showAuthor = false;
            $scope.showDate = false;
        }

        $scope.loaded = true;

        // Log that the entry was viewed.
        $mmaModGlossary.logEntryView(entry.id);

    }).catch(function() {
        notifyErrorOccured();
    });

    function fetchEntry() {
        return $mmaModGlossary.getEntry(entry.id).then(function(result) {
            $scope.entry = result.entry;
            $scope.title = result.entry.concept;
        });
    }

    function refreshEntry() {
        return $mmaModGlossary.invalidateEntry(entry.id).then(function() {
            return fetchEntry();
        });
    }

    function notifyErrorOccured() {
        $scope.title = $translate.instant('mm.core.error');
        $scope.entry = false;
        $scope.loaded = true;
    }

}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Glossary index controller.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc controller
 * @name mmaModGlossaryIndexCtrl
 */
.controller('mmaModGlossaryIndexCtrl', ["$q", "$scope", "$stateParams", "$ionicPopover", "$mmUtil", "$mmaModGlossary", "$ionicScrollDelegate", function($q, $scope, $stateParams, $ionicPopover, $mmUtil, $mmaModGlossary,
        $ionicScrollDelegate) {

    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        glossary,
        noop = function(){},
        limitFrom = 0,
        limitNum = 25,
        popover,
        viewMode,   // The archetype of view (letter, date, author, cat).
        fetchMode = 'letter_all',       // Default.
        fetchFunction,
        fetchInvalidate,
        fetchArguments,
        popoverScope = $scope.$new(true),
        browseModes = [
            {
                key: 'letter_all',
                langkey: 'mma.mod_glossary.byalphabet'
            },
            {
                key: 'search',
                langkey: 'mma.mod_glossary.bysearch'
            }
        ];

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.externalUrl = module.url;
    $scope.courseid = courseId;
    $scope.loaded = false;
    $scope.entries = [];
    $scope.getDivider = noop;
    $scope.showDivider = noop;
    $scope.canLoadMore = false;
    $scope.searchData = {
        searchQuery: ''
    };

    $scope.loadMoreEntries = function() {
        loadMoreEntries().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
    $scope.refreshEntries = function() {
        refreshEntries().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.pickMode = function(e) {
        popoverScope.data.selectedMode = fetchMode;
        popover.show(e);
    };

    $scope.search = function(query) {
        fetchArguments = [glossary.id, query, 1, 'CONCEPT', 'ASC'];
        fetchEntries();
    };

    $scope.trackBy = function(entry) {
        return fetchMode + ':' + entry.id;
    };

    // Controller run.
    $mmaModGlossary.getGlossary(courseId, module.id).then(function(mod) {
        glossary = mod;

        // Preparing browse modes.
        if (glossary.browsemodes.indexOf('date') >= 0) {
            browseModes.push({key: 'newest_first', langkey: 'mma.mod_glossary.bynewestfirst'});
            browseModes.push({key: 'recently_updated', langkey: 'mma.mod_glossary.byrecentlyupdated'});
        }
        if (glossary.browsemodes.indexOf('author') >= 0) {
            browseModes.push({key: 'author_all', langkey: 'mma.mod_glossary.byauthor'});
        }

        // Preparing the popover.
        popoverScope.modes = browseModes;
        popoverScope.modePicked = function(mode) {
            $ionicScrollDelegate.$getByHandle('mmaModGlossaryIndex').scrollTop(false);
            if (switchMode(mode)) {
                $scope.loaded = false;
                fetchEntries().finally(function() {
                    $scope.loaded = true;
                });
            } else {
                // If it's not an instant search, then we reset the values.
                $scope.loaded = true;
                $scope.entries = [];
                $scope.canLoadMore = false;
                $scope.showNoEntries = false;
            }
            popover.hide();
        };
        popoverScope.data = { selectedMode: '' };
        $ionicPopover.fromTemplateUrl('addons/mod_glossary/templates/mode_picker.html', {
            scope: popoverScope
        }).then(function(po) {
            popover = po;
        });
        $scope.$on('$destroy', function() {
            popover.remove();
            popoverScope.$destroy();
        });

        // Preparing the initial mode.
        switchMode();

        // Do not return the promise here, the error modal is already handled.
        fetchEntries().then(function() {
            // After a successful fetch, the glossary can be considered as 'viewed'.
            $mmaModGlossary.logView(glossary.id, viewMode);
        }).finally(function() {
            $scope.loaded = true;
        });
    }).catch(function() {
        $mmUtil.showErrorModal('mma.mod_glossary.errorloadingglossary', true);
        $scope.loaded = true;
    });

    // Controller library.
    function fetchEntries(append) {
        if (!append) {
            limitFrom = 0;
        }
        var args = angular.extend([], fetchArguments);
        args.push(limitFrom);
        args.push(limitNum);

        return fetchFunction.apply(this, args).then(function(result) {
            if (append) {
                $scope.entries = $scope.entries.concat(result.entries);
            } else {
                $scope.entries = result.entries;
            }
            $scope.canLoadMore = (limitFrom + limitNum) < result.count;
            $scope.showNoEntries = result.count <= 0;
        }).catch(function() {
            $mmUtil.showErrorModal('mma.mod_glossary.errorloadingentries', true);
            return $q.reject();
        });
    }

    function refreshEntries() {
        if (fetchMode == 'search' && !$scope.searchQuery) {
            // Ignore search mode that is not set yet.
            return $q.when();
        }
        var args = angular.extend([], fetchArguments);
        return fetchInvalidate.apply(this, args).then(function() {
            limitFrom = 0;
            return fetchEntries();
        });
    }

    function loadMoreEntries() {
        limitFrom += limitNum;
        return fetchEntries(true);
    }

    function switchMode(mode) {
        if (mode == fetchMode) {
            return false;
        }

        var instantFetch = true;
        fetchMode = mode;
        $scope.isSearch = false;

        // Browse by author.
        if (mode == 'author_all') {
            viewMode = 'author';
            fetchFunction = $mmaModGlossary.getEntriesByAuthor;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByAuthor;
            fetchArguments = [glossary.id, 'ALL', 'LASTNAME', 'ASC'];
            $scope.getDivider = function(entry) {
                return entry.userfullname;
            };
            $scope.showDivider = function(entry, previous) {
                if (typeof previous === 'undefined') {
                    return true;
                }
                return entry.userid != previous.userid;
            };

        // Newest first.
        } else if (mode == 'newest_first') {
            viewMode = 'date';
            fetchFunction = $mmaModGlossary.getEntriesByDate;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByDate;
            fetchArguments = [glossary.id, 'CREATION', 'DESC'];
            $scope.getDivider = noop;
            $scope.showDivider = function() { return false; };

        // Recently updated.
        } else if (mode == 'recently_updated') {
            viewMode = 'date';
            fetchFunction = $mmaModGlossary.getEntriesByDate;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByDate;
            fetchArguments = [glossary.id, 'UPDATE', 'DESC'];
            $scope.getDivider = noop;
            $scope.showDivider = function() { return false; };

        // Search for entries.
        } else if (mode == 'search') {
            viewMode = 'search';
            fetchFunction = $mmaModGlossary.getEntriesBySearch;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesBySearch;
            fetchArguments = false; // Dynamically set later.
            $scope.isSearch = true;
            $scope.getDivider = noop;
            $scope.showDivider = function() { return false; };
            instantFetch = false;

        // Consider it is 'letter_all'.
        } else {
            viewMode = 'letter';
            fetchMode = 'letter_all';
            fetchFunction = $mmaModGlossary.getEntriesByLetter;
            fetchInvalidate = $mmaModGlossary.invalidateEntriesByLetter;
            fetchArguments = [glossary.id, 'ALL'];
            $scope.getDivider = function(entry) {
                return entry.concept.substr(0, 1).toUpperCase();
            };
            $scope.showDivider = function(entry, previous) {
                if (typeof previous === 'undefined') {
                    return true;
                }
                return $scope.getDivider(entry) != $scope.getDivider(previous);
            };
        }

        return instantFetch;
    }
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Glossary service.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc service
 * @name $mmaModGlossary
 */
.factory('$mmaModGlossary', ["$mmSite", "$q", "$mmSitesManager", function($mmSite, $q, $mmSitesManager) {
    var self = {};

    /**
     * Get the course glossary cache key.
     *
     * @param  {Number} courseId
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getCourseGlossariesCacheKey
     */
    self._getCourseGlossariesCacheKey = function(courseId) {
        return 'mmaModGlossary:courseGlossaries:' + courseId;
    };

    /**
     * Get all the glossaries in a course.
     *
     * @param  {Number} courseId
     * @return {Promise} resolved with the glossaries
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getCourseGlossaries
     */
    self.getCourseGlossaries = function(courseId) {
        var params = {
                courseids: [courseId]
            },
            preSets = {
                cacheKey: self._getCourseGlossariesCacheKey(courseId)
            };
        return $mmSite.read('mod_glossary_get_glossaries_by_courses', params, preSets).then(function(result) {
            return result.glossaries;
        });
    };

    /**
     * Get the course glossary cache key.
     *
     * @param  {Number} courseId
     * @return {Promise}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateCourseGlossaries
     */
    self.invalidateCourseGlossaries = function(courseId) {
        var key = self._getCourseGlossariesCacheKey(courseId);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by author cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @param  {String} sort
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesByAuthorCacheKey
     */
    self._getEntriesByAuthorCacheKey = function(glossaryId, letter, field, sort) {
        return 'mmaModGlossary:entriesByAuthor:' + glossaryId + ":" + letter + ":" + field + ":" + sort;
    };

    /**
     * Get entries by author.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @param  {String} sort
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesByAuthor
     */
    self.getEntriesByAuthor = function(glossaryId, letter, field, sort, from, limit) {
        var params = {
                id: glossaryId,
                letter: letter,
                field: field,
                sort: sort,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesByAuthorCacheKey(glossaryId, letter, field, sort)
            };

        return $mmSite.read('mod_glossary_get_entries_by_author', params, preSets);
    };

    /**
     * Invalidate cache of entries by author.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @param  {String} sort
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesByAuthor
     */
    self.invalidateEntriesByAuthor = function(glossaryId, letter, field, sort) {
        var key = self._getEntriesByAuthorCacheKey(glossaryId, letter, field, sort);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by date cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} order
     * @param  {String} sort
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesByDateCacheKey
     */
    self._getEntriesByDateCacheKey = function(glossaryId, order, sort) {
        return 'mmaModGlossary:entriesByDate:' + glossaryId + ":" + order + ":" + sort;
    };

    /**
     * Get entries by date.
     *
     * @param  {Number} glossaryId
     * @param  {String} order
     * @param  {String} sort
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesByDate
     */
    self.getEntriesByDate = function(glossaryId, order, sort, from, limit) {
        var params = {
                id: glossaryId,
                order: order,
                sort: sort,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesByDateCacheKey(glossaryId, order, sort)
            };

        return $mmSite.read('mod_glossary_get_entries_by_date', params, preSets);
    };

    /**
     * Invalidate cache of entries by date.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {String} field
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesByDate
     */
    self.invalidateEntriesByDate = function(glossaryId, order, sort) {
        var key = self._getEntriesByDateCacheKey(glossaryId, order, sort);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by letter cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesByLetterCacheKey
     */
    self._getEntriesByLetterCacheKey = function(glossaryId, letter) {
        return 'mmaModGlossary:entriesByLetter:' + glossaryId + ":" + letter;
    };

    /**
     * Get entries by letter.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesByLetter
     */
    self.getEntriesByLetter = function(glossaryId, letter, from, limit) {
        var params = {
                id: glossaryId,
                letter: letter,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesByLetterCacheKey(glossaryId, letter)
            };

        return $mmSite.read('mod_glossary_get_entries_by_letter', params, preSets);
    };

    /**
     * Invalidate cache of entries by letter.
     *
     * @param  {Number} glossaryId
     * @param  {String} letter
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesByLetter
     */
    self.invalidateEntriesByLetter = function(glossaryId, letter) {
        var key = self._getEntriesByLetterCacheKey(glossaryId, letter);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get the entries by search cache key.
     *
     * @param  {Number} glossaryId
     * @param  {String} query
     * @param  {Boolean} fullsearch
     * @param  {String} order
     * @param  {String} sort
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntriesBySearchCacheKey
     */
    self._getEntriesBySearchCacheKey = function(glossaryId, query, fullsearch, order, sort) {
        return 'mmaModGlossary:entriesBySearch:' + glossaryId + ":" + fullsearch + ":" + order + ":" + sort + ":" + query;
    };

    /**
     * Get entries by search.
     *
     * @param  {Number} glossaryId
     * @param  {String} query
     * @param  {Boolean} fullsearch
     * @param  {String} order
     * @param  {String} sort
     * @param  {Number} from
     * @param  {Number} limit
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntriesBySearch
     */
    self.getEntriesBySearch = function(glossaryId, query, fullsearch, order, sort, from, limit) {
        var params = {
                id: glossaryId,
                query: query,
                fullsearch: fullsearch,
                order: order,
                sort: sort,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: self._getEntriesBySearchCacheKey(glossaryId, query, fullsearch, order, sort)
            };

        return $mmSite.read('mod_glossary_get_entries_by_search', params, preSets);
    };

    /**
     * Invalidate cache of entries by search.
     *
     * @param  {Number} glossaryId
     * @param  {String} query
     * @param  {Boolean} fullsearch
     * @param  {String} order
     * @param  {String} sort
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntriesBySearch
     */
    self.invalidateEntriesBySearch = function(glossaryId, query, fullsearch, order, sort) {
        var key = self._getEntriesBySearchCacheKey(glossaryId, query, fullsearch, order, sort);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get an entry by ID cache key.
     *
     * @param  {Number} id
     * @return {String}
     * @protected
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#_getEntryCacheKey
     */
    self._getEntryCacheKey = function(id) {
        return 'mmaModGlossary:getEntry:' + id;
    };

    /**
     * Get one entry by ID.
     *
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getEntry
     * @param  {Number} id       Entry ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with the entry.
     */
    self.getEntry = function(id, siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    id: id
                },
                preSets = {
                    cacheKey: self._getEntryCacheKey(id)
                };

            return site.read('mod_glossary_get_entry_by_id', params, preSets);
        });
    };

    /**
     * Invalidate cache of entry by ID.
     *
     * @param  {Number} id
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#invalidateEntry
     */
    self.invalidateEntry = function(id) {
        var key = self._getEntryCacheKey(id);
        return $mmSite.invalidateWsCacheForKey(key);
    };

    /**
     * Get one glossary by cmID.
     *
     * @param  {Number} courseId
     * @param  {Number} cmid
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getGlossary
     */
    self.getGlossary = function(courseId, cmid) {
        return self.getCourseGlossaries(courseId).then(function(glossaries) {
            var result = $q.reject();
            angular.forEach(glossaries, function(glossary) {
                if (glossary.coursemodule == cmid) {
                    result = glossary;
                }
            });
            return result;
        });
    };

    /**
     * Get one glossary by glossary ID.
     *
     * @param  {Number} courseId
     * @param  {Number} id
     * @return {Promise}
     * @ngdoc  method
     * @module mm.addons.mod_glossary
     * @name   $mmaModGlossary#getGlossaryById
     */
    self.getGlossaryById = function(courseId, id) {
        return self.getCourseGlossaries(courseId).then(function(glossaries) {
            var result = $q.reject();
            angular.forEach(glossaries, function(glossary) {
                if (glossary.id == id) {
                    result = glossary;
                }
            });
            return result;
        });
    };

    /**
     * Check if glossary plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossary#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            // This function was introduced along with all the other required ones.
            return site.wsAvailable('mod_glossary_get_glossaries_by_courses');
        });
    };

    /**
     * Report a glossary as being viewed.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossary#logView
     * @param {Number} id Glossary ID.
     * @param {String} mode The mode in which the glossary was viewed.
     * @return {Promise} Promise resolved when the WS call is successful.
     */
    self.logView = function(id, mode) {
        var params = {
            id: id,
            mode: mode
        };
        return $mmSite.write('mod_glossary_view_glossary', params);
    };

    /**
     * Report a glossary entry as being viewed.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossary#logEntryView
     * @param {Number} id Entry ID.
     * @return {Promise} Promise resolved when the WS call is successful.
     */
    self.logEntryView = function(id) {
        var params = {
            id: id
        };
        return $mmSite.write('mod_glossary_view_entry', params);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_glossary')

/**
 * Mod glossary handlers.
 *
 * @module mm.addons.mod_glossary
 * @ngdoc service
 * @name $mmaModGlossaryHandlers
 */
.factory('$mmaModGlossaryHandlers', ["$mmCourse", "$mmaModGlossary", "$state", "$q", "$mmContentLinksHelper", "$mmUtil", "$mmCourseHelper", function($mmCourse, $mmaModGlossary, $state, $q, $mmContentLinksHelper, $mmUtil,
            $mmCourseHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossaryHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModGlossary.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.icon = $mmCourse.getModuleIconSrc('glossary');
                $scope.title = module.name;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_glossary', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_glossary
     * @ngdoc method
     * @name $mmaModGlossaryHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled to see glossary index for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isIndexEnabled(siteId, courseId) {
            return $mmaModGlossary.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Whether or not the handler is enabled to see glossary entry for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEntryEnabled(siteId, courseId) {
            return $mmaModGlossary.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleByInstance(siteId);
            });
        }

        function getEntry(entryId, siteId) {
            return $mmaModGlossary.getEntry(entryId, siteId).then(function(result) {
                return result.entry;
            }).catch(function(error) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $mmUtil.showErrorModal('mma.mod_glossary.errorloadingentry', true);
                }
                return $q.reject();
            });
        }

        /**
         * Treat a glossary entry link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         */
        function treatEntryLink(siteIds, url, courseId) {
            var params = $mmUtil.extractUrlParams(url);
            if (params.eid != 'undefined') {
                // Pass false because all sites should have the same siteurl.
                return $mmContentLinksHelper.filterSupportedSites(siteIds, isEntryEnabled, false, courseId).then(function(ids) {
                    if (!ids.length) {
                        return [];
                    }

                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: ids,
                        action: function(siteId) {
                            var modal = $mmUtil.showModalLoading();
                            return getEntry(parseInt(params.eid, 10), siteId).then(function(entry) {
                                var promise;
                                if (courseId) {
                                    promise = $q.when(courseId);
                                } else {
                                    promise = $mmCourseHelper.getModuleCourseIdByInstance(entry.glossaryid, 'glossary', siteId);
                                }
                                return promise.then(function(courseId) {
                                    var stateParams = {
                                        entry: entry,
                                        cid: courseId
                                    };
                                    $mmContentLinksHelper.goInSite('site.mod_glossary-entry', stateParams, siteId);
                                });
                            }).finally(function() {
                                modal.dismiss();
                            });
                        }
                    }];
                });
            }
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a glossary URL.
            if (url.indexOf('/mod/glossary/view.php') > -1) {
                // Glossary index.
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isIndexEnabled, courseId);
            } else if (url.indexOf('/mod/glossary/showentry.php') > -1) {
                // Glossary entry.
                return treatEntryLink(siteIds, url, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * IMSCP index controller.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc controller
 * @name mmaModImscpIndexCtrl
 */
.controller('mmaModImscpIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModImscp", "$log", "mmaModImscpComponent", "$ionicPopover", "$timeout", "$q", "$mmCourse", "$mmApp", function($scope, $stateParams, $mmUtil, $mmaModImscp, $log, mmaModImscpComponent,
            $ionicPopover, $timeout, $q, $mmCourse, $mmApp) {
    $log = $log.getInstance('mmaModImscpIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        currentItem;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModImscpComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;

    // Initialize empty previous/next to prevent showing arrows for an instant before they're hidden.
    $scope.previousItem = '';
    $scope.nextItem = '';

    $scope.items = $mmaModImscp.createItemList(module.contents);
    if ($scope.items.length) {
        currentItem = $scope.items[0].href;
    }

    function loadItem(itemId) {
        currentItem = itemId;
        $scope.previousItem = $mmaModImscp.getPreviousItem($scope.items, itemId);
        $scope.nextItem = $mmaModImscp.getNextItem($scope.items, itemId);
        var src = $mmaModImscp.getFileSrc(module, itemId);
        if ($scope.src && src.toString() == $scope.src.toString()) {
            // Re-loading same page. Set it to empty and then re-set the src in the next digest so it detects it has changed.
            $scope.src = '';
            $timeout(function() {
                $scope.src = src;
            });
        } else {
            $scope.src = src;
        }
    }

    function fetchContent() {
        if (module.contents && module.contents.length) {
            var downloadFailed = false;
            return $mmaModImscp.downloadAllContent(module).catch(function() {
                // Mark download as failed but go on since the main files could have been downloaded.
                downloadFailed = true;
            }).finally(function() {
                return $mmaModImscp.getIframeSrc(module).then(function() {
                    loadItem(currentItem);

                    if (downloadFailed && $mmApp.isOnline()) {
                        // We could load the main file but the download failed. Show error message.
                        $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                    }
                }).catch(function() {
                    $mmUtil.showErrorModal('mma.mod_imscp.deploymenterror', true);
                    return $q.reject();
                }).finally(function() {
                    $scope.loaded = true;
                });
            });
        } else {
            $mmUtil.showErrorModal('mma.mod_imscp.deploymenterror', true);
            return $q.reject();
        }
    }

    $scope.doRefresh = function() {
        $mmaModImscp.invalidateContent(module.id).then(function() {
            return fetchContent();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    $scope.loadItem = function(itemId) {
        $scope.popover.hide();
        loadItem(itemId);
    };

    $scope.getNumberForPadding = function(n) {
        return new Array(n);
    };

    $ionicPopover.fromTemplateUrl('addons/mod_imscp/templates/toc.html', {
        scope: $scope,
    }).then(function(popover) {
        $scope.popover = popover;
    });

    fetchContent().then(function() {
        $mmaModImscp.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * Mod IMSCP handlers.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc service
 * @name $mmaModImscpHandlers
 */
.factory('$mmaModImscpHandlers', ["$mmCourse", "$mmaModImscp", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModImscpComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModImscp, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModImscpComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @module mm.addons.mod_imscp
         * @ngdoc method
         * @name $mmaModImscpCourseContentHandler#isEnabled
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModImscp.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @module mm.addons.mod_imscp
         * @ngdoc method
         * @name $mmaModImscpCourseContentHandler#getController
         * @param {Object} module   The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModImscp.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModImscp.invalidateContent(module.id).then(function() {
                            $mmaModImscp.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('imscp');
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_imscp', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModImscpComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModImscp.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's an IMSCP URL.
            if (url.indexOf('/mod/imscp/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * IMSCP factory.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc service
 * @name $mmaModImscp
 */
.factory('$mmaModImscp', ["$mmFilepool", "$mmSite", "$mmFS", "$log", "$q", "$sce", "$mmApp", "$mmSitesManager", "mmaModImscpComponent", function($mmFilepool, $mmSite, $mmFS, $log, $q, $sce, $mmApp, $mmSitesManager, mmaModImscpComponent) {
    $log = $log.getInstance('$mmaModImscp');

    var self = {},
        currentDirPath; // Directory path of the current IMSCP.

    /**
     * Get the IMSCP toc as an array.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getToc
     * @param  {array} contents The module contents.
     * @return {Array}          The toc.
     * @protected
     */
    self.getToc = function(contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return JSON.parse(contents[0].content);
    };

    /**
     * Get the imscp toc as an array of items (no nested) to build the navigation tree.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#createItemList
     * @param  {array} contents The module contents.
     * @return {Array}          The toc as a list.
     * @protected
     */
    self.createItemList = function(contents) {
        var items = [];
        var toc = self.getToc(contents);
        angular.forEach(toc, function(el) {
            items.push({href: el.href, title: el.title, level: el.level});
            angular.forEach(el.subitems, function(sel) {
                items.push({href: sel.href, title: sel.title, level: sel.level});
            });
        });
        return items;
    };

    /**
     * Get the previous item to the given one.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getPreviousItem
     * @param  {array} items     The items list.
     * @param  {String} itemId   The current item.
     * @return {String}          The previous item id.
     * @protected
     */
    self.getPreviousItem = function(items, itemId) {
        var previous = '';

        for (var i = 0, len = items.length; i < len; i++) {
            if (items[i].href == itemId) {
                break;
            }
            previous = items[i].href;
        }

        return previous;
    };

    /**
     * Get the next item to the given one.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getNextItem
     * @param  {array} items     The items list.
     * @param  {String} itemId   The current item.
     * @return {String}           The next item id.
     * @protected
     */
    self.getNextItem = function(items, itemId) {
        var next = '';

        for (var i = 0, len = items.length; i < len; i++) {
            if (items[i].href == itemId) {
                if (typeof items[i + 1] != 'undefined') {
                    next = items[i + 1].href;
                    break;
                }
            }
        }
        return next;
    };


    /**
     * Check if we should ommit the file download.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#checkSpecialFiles
     * @param {String} fileName The file name
     * @return {Boolean}        True if we should ommit the file
     * @protected
     */
    self.checkSpecialFiles = function(fileName) {
        return fileName == 'imsmanifest.xml';
    };

    /**
     * Download all the content. All the files are downloaded inside a folder in filepool, keeping their folder structure.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        return $mmFilepool.getFilePathByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModImscpComponent, module.id, revision, timemod, dirPath);
        });
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }

            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Given a filepath, get a certain fileurl from module contents.
     *
     * @param {Object[]} contents     Module contents.
     * @param {String} targetFilepath Filepath of the searched file.
     * @return {String}               Fileurl.
     * @protected
     */
    self._getFileUrlFromContents = function(contents, targetFilepath) {
        var indexUrl;
        angular.forEach(contents, function(content) {
            if (content.type == 'file' && !indexUrl) {
                var filepath = $mmFS.concatenatePaths(content.filepath, content.filename),
                    filepathalt = filepath.charAt(0) === '/' ? filepath.substr(1) : '/' + filepath;
                // Check if it's main file.
                if (filepath === targetFilepath || filepathalt === targetFilepath) {
                    indexUrl = content.fileurl;
                }
            }
        });
        return indexUrl;
    };

    /**
     * Download all the files needed and returns the src of the iframe.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getIframeSrc
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved with the iframe src.
     */
    self.getIframeSrc = function(module) {
        var toc = self.getToc(module.contents),
            mainFilePath;
        if (!toc.length) {
            return $q.reject();
        }
        mainFilePath = toc[0].href;

        return $mmFilepool.getDirectoryUrlByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            currentDirPath = dirPath;
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, mainFilePath));
        }, function() {
            // Error getting directory, there was an error downloading or we're in browser. Return online URL if connected.
            if ($mmApp.isOnline()) {
                var indexUrl = self._getFileUrlFromContents(module.contents, mainFilePath);
                if (indexUrl) {
                    // This URL is going to be injected in an iframe, we need this to make it work.
                    return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(indexUrl));
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get src of a imscp item.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#getFileSrc
     * @param {Object} module    The module object.
     * @param {String} itemId    Item to get the src.
     * @return {String}          Item src.
     */
    self.getFileSrc = function(module, itemId) {
        if (currentDirPath) {
            // IMSCP successfully loaded.
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(currentDirPath, itemId));
        } else {
            // Error loading IMSCP. Let's get online URL.
            if ($mmApp.isOnline()) {
                var indexUrl = self._getFileUrlFromContents(module.contents, itemId);
                if (indexUrl) {
                    // This URL is going to be injected in an iframe, we need this to make it work.
                    return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(indexUrl));
                }
            }
        }
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#invalidateContent
     * @param {Number} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModImscpComponent, moduleId);
    };

    /**
     * Check if a file is downloadable. The file param must have 'type' and 'filename' attributes
     * like in core_course_get_contents response.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file' && !self.checkSpecialFiles(file.filename);
    };

    /**
     * Return whether or not the plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            var version = site.getInfo().version;
            // Require Moodle 2.9.
            return version && (parseInt(version) >= 2015051100) && site.canDownloadFiles();
        });
    };

    /**
     * Report a IMSCP as being viewed.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                imscpid: id
            };
            return $mmSite.write('mod_imscp_view_imscp', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content. All the files are downloaded inside a folder in filepool, keeping their folder structure.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscp#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        return $mmFilepool.getFilePathByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModImscpComponent, module.id, revision, timemod, dirPath);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_imscp')

/**
 * Mod imscp prefetch handler.
 *
 * @module mm.addons.mod_imscp
 * @ngdoc service
 * @name $mmaModImscpPrefetchHandler
 */
.factory('$mmaModImscpPrefetchHandler', ["$mmaModImscp", "mmaModImscpComponent", function($mmaModImscp, mmaModImscpComponent) {

    var self = {};

    self.component = mmaModImscpComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpPrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModImscp.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmaModImscp.isPluginEnabled();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_imscp
     * @ngdoc method
     * @name $mmaModImscpPrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModImscp.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.core.course')

/**
 * Label index controller.
 *
 * @module mm.addons.mod_label
 * @ngdoc controller
 * @name mmaModLabelIndexCtrl
 */
.controller('mmaModLabelIndexCtrl', ["$scope", "$stateParams", "$log", function($scope, $stateParams, $log) {
    $log = $log.getInstance('mmaModLabelIndexCtrl');
    $scope.description = $stateParams.description;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_label')

/**
 * Mod label handlers.
 *
 * @module mm.addons.mod_label
 * @ngdoc service
 * @name $mmaModLabelHandlers
 */
.factory('$mmaModLabelHandlers', ["$mmText", "$translate", "$state", "$mmContentLinksHelper", "$q", "$mmCourse", function($mmText, $translate, $state, $mmContentLinksHelper, $q, $mmCourse) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_label
     * @ngdoc method
     * @name $mmaModLabelHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @return {Function}
         */
        self.getController = function(module) {
            return function($scope) {
                var title = $mmText.shortenText($mmText.cleanTags(module.description).trim(), 128);
                if (title.length <= 0) {
                    $translate('mma.mod_label.taptoview').then(function(taptoview) {
                        $scope.title = '<span class="mma-mod_label-empty">' + taptoview + '</span>';
                    });
                } else {
                    $scope.title = title;
                }

                $scope.icon = false;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_label', {description: module.description});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_label
     * @ngdoc method
     * @name $mmaModLabelHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            if (courseId) {
                return $q.when(true);
            }
            return $mmCourse.canGetModuleWithoutCourseId(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a label URL.
            if (url.indexOf('/mod/label/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti')

/**
 * LTI index controller.
 *
 * @module mm.addons.mod_lti
 * @ngdoc controller
 * @name mmaModLtiIndexCtrl
 */
.controller('mmaModLtiIndexCtrl', ["$scope", "$stateParams", "$mmaModLti", "$mmUtil", "$q", "$mmCourse", function($scope, $stateParams, $mmaModLti, $mmUtil, $q, $mmCourse) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        lti;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.courseid = courseid;

    // Convenience function to get LTI data.
    function fetchLTI(refresh) {
        return $mmaModLti.getLti(courseid, module.id).then(function(ltidata) {
            lti = ltidata;

            return $mmaModLti.getLtiLaunchData(lti.id).then(function(launchdata) {
                lti.launchdata = launchdata;
                $scope.title = lti.name || $scope.title;
                $scope.description = lti.intro || $scope.description;
                $scope.isValidUrl = $mmUtil.isValidURL(launchdata.endpoint);
            });
        }).catch(function(message) {
            if (!refresh) {
                // Some call failed, retry without using cache since it might be a new activity.
                return refreshAllData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_lti.errorgetlti', true);
            }
            return $q.reject();
        });
    }

    // Convenience function to refresh all the data.
    function refreshAllData() {
        var p1 = $mmaModLti.invalidateLti(courseid),
            p2 = lti ? $mmaModLti.invalidateLtiLaunchData(lti.id) : $q.when();

        return $q.all([p1, p2]).finally(function() {
            return fetchLTI(true);
        });
    }

    fetchLTI().finally(function() {
        $scope.ltiLoaded = true;
    });

    // Pull to refresh.
    $scope.doRefresh = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Launch the LTI.
    $scope.launch = function() {
        // "View" LTI.
        $mmaModLti.logView(lti.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });

        // Launch LTI.
        $mmaModLti.launch(lti.launchdata.endpoint, lti.launchdata.parameters).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            }
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti')

/**
 * Mod LTI handler.
 *
 * @module mm.addons.mod_lti
 * @ngdoc service
 * @name $mmaModLtiHandlers
 */
.factory('$mmaModLtiHandlers', ["$mmCourse", "$mmaModLti", "$state", "$mmSite", "$mmFilepool", "$mmApp", "$mmUtil", "mmaModLtiComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModLti, $state, $mmSite, $mmFilepool, $mmApp, $mmUtil,
            mmaModLtiComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLtiHandlers#courseContent
     */
    self.courseContent = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModLti.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('lti'); // Get LTI default icon for now.
                $scope.action = function() {
                    $state.go('site.mod_lti', {module: module, courseid: courseid});
                };

                // Get LTI data.
                var promise = $mmaModLti.getLti(courseid, module.id);

                // Handle custom icons.
                promise.then(function(ltidata) {
                    var icon = ltidata.secureicon || ltidata.icon;
                    if (icon) {
                        $mmFilepool.downloadUrl($mmSite.getId(), icon, false, mmaModLtiComponent, module.id).then(function(url) {
                            $scope.icon = url;
                        }).catch(function() {
                            // Error downloading. If we're online we'll set the online url.
                            if ($mmApp.isOnline()) {
                                $scope.icon = icon;
                            }
                        });
                    }
                });

                // Button to launch the LTI.
                $scope.buttons = [{
                    icon: 'ion-link',
                    label: 'mma.mod_lti.launchactivity',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();

                        var modal = $mmUtil.showModalLoading('mm.core.loading', true);
                        // Get LTI and launch data.
                        promise.then(function(ltidata) {
                            return $mmaModLti.getLtiLaunchData(ltidata.id).then(function(launchdata) {
                                // "View" LTI.
                                $mmaModLti.logView(ltidata.id).then(function() {
                                    $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                                });

                                // Launch LTI.
                                return $mmaModLti.launch(launchdata.endpoint, launchdata.parameters);
                            });
                        }).catch(function(message) {
                            if (message) {
                                $mmUtil.showErrorModal(message);
                            } else {
                                $mmUtil.showErrorModal('mma.mod_lti.errorgetlti', true);
                            }
                        }).finally(function() {
                            modal.dismiss();
                        });
                    }
                }];
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLtiHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModLti.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a LTI URL.
            if (url.indexOf('/mod/lti/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_lti')

/**
 * LTI service.
 *
 * @module mm.addons.mod_lti
 * @ngdoc service
 * @name $mmaModLti
 */
.factory('$mmaModLti', ["$q", "$mmSite", "$mmFS", "$mmText", "$mmUtil", "$mmLang", "$mmSitesManager", function($q, $mmSite, $mmFS, $mmText, $mmUtil, $mmLang, $mmSitesManager) {
    var self = {},
        launcherFileName = 'lti_launcher.html';

    /**
     * Delete launcher.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#deleteLauncher
     * @return {Promise} Promise resolved when the launcher file is deleted.
     */
    self.deleteLauncher = function() {
        return $mmFS.removeFile(launcherFileName);
    };

    /**
     * Generates a launcher file.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#generateLauncher
     * @param {String} url      Launch URL.
     * @param {Object[]} params Launch params.
     * @return {Promise}        Promise resolved with the file URL.
     */
    self.generateLauncher = function(url, params) {

        if (!$mmFS.isAvailable()) {
            return $q.when(url);
        }

        // Generate a form with the params.
        var text = '<form action="' + url + '" name="ltiLaunchForm" ' +
                    'method="post" encType="application/x-www-form-urlencoded">\n';
        angular.forEach(params, function(p) {
            if (p.name == 'ext_submit') {
                text += '    <input type="submit"';
            } else {
                text += '    <input type="hidden" name="' + $mmText.escapeHTML(p.name) + '"';
            }
            text += ' value="' + $mmText.escapeHTML(p.value) + '"/>\n';
        });
        text += '</form>\n';

        // Add an in-line script to automatically submit the form.
        text += '<script type="text/javascript"> \n' +
            '    document.ltiLaunchForm.submit(); \n' +
            '</script> \n';

        return $mmFS.writeFile(launcherFileName, text).then(function(entry) {
            return entry.toURL();
        });
    };

    /**
     * Get a LTI.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#getLti
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the LTI is retrieved.
     */
    self.getLti = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getLtiCacheKey(courseid)
            };

        return $mmSite.read('mod_lti_get_ltis_by_courses', params, preSets).then(function(response) {
            if (response.ltis) {
                var currentLti;
                angular.forEach(response.ltis, function(lti) {
                    if (lti.coursemodule == cmid) {
                        currentLti = lti;
                    }
                });
                if (currentLti) {
                    return currentLti;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for LTI data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getLtiCacheKey(courseid) {
        return 'mmaModLti:lti:' + courseid;
    }

    /**
     * Get a LTI launch data.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#getLtiLaunchData
     * @param {Number} id LTI ID.
     * @return {Promise}  Promise resolved when the launch data is retrieved.
     */
    self.getLtiLaunchData = function(id) {
        var params = {
                toolid: id
            },
            preSets = {
                cacheKey: getLtiLaunchDataCacheKey(id)
            };

        return $mmSite.read('mod_lti_get_tool_launch_data', params, preSets).then(function(response) {
            if (response.endpoint) {
                return response;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for LTI launch data WS calls.
     *
     * @param {Number} id LTI ID.
     * @return {String}   Cache key.
     */
    function getLtiLaunchDataCacheKey(id) {
        return 'mmaModLti:launch:' + id;
    }

    /**
     * Invalidates LTI data.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#invalidateLti
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateLti = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getLtiCacheKey(courseid));
    };

    /**
     * Invalidates options.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#invalidateLtiLaunchData
     * @param {Number} id LTI ID.
     * @return {Promise}  Promise resolved when the data is invalidated.
     */
    self.invalidateLtiLaunchData = function(id) {
        return $mmSite.invalidateWsCacheForKey(getLtiLaunchDataCacheKey(id));
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the lti WS are available.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_lti_get_ltis_by_courses') &&
                    site.wsAvailable('mod_lti_get_tool_launch_data');
        });
    };

    /**
     * Launch LTI.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#launch
     * @param {String} url      Launch URL.
     * @param {Object[]} params Launch params.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.launch = function(url, params) {
        if (!$mmUtil.isValidURL(url)) {
            return $mmLang.translateAndReject('mma.mod_lti.errorinvalidlaunchurl');
        }

        // Generate launcher and open it.
        return self.generateLauncher(url, params).then(function(url) {
            $mmUtil.openInApp(url);
        });
    };

    /**
     * Report the LTI as being viewed.
     *
     * @module mm.addons.mod_lti
     * @ngdoc method
     * @name $mmaModLti#logView
     * @param {String} id LTI ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                ltiid: id
            };
            return $mmSite.write('mod_lti_view_lti', params);
        }
        return $q.reject();
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Page index controller.
 *
 * @module mm.addons.mod_page
 * @ngdoc controller
 * @name mmaModPageIndexCtrl
 */
.controller('mmaModPageIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModPage", "$mmCourse", "$q", "$log", "$mmApp", "mmaModPageComponent", function($scope, $stateParams, $mmUtil, $mmaModPage, $mmCourse, $q, $log, $mmApp,
            mmaModPageComponent) {
    $log = $log.getInstance('mmaModPageIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModPageComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;

    function fetchContent() {
        var downloadFailed = false;
        // Prefetch the content so ALL files are downloaded, not just the ones shown in the page.
        return $mmaModPage.downloadAllContent(module).catch(function(err) {
            // Mark download as failed but go on since the main files could have been downloaded.
            downloadFailed = true;
        }).then(function() {
            return $mmaModPage.getPageHtml(module.contents, module.id).then(function(content) {
                $scope.content = content;

                if (downloadFailed && $mmApp.isOnline()) {
                    // We could load the main file but the download failed. Show error message.
                    $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                }
            }).catch(function() {
                $mmUtil.showErrorModal('mma.mod_page.errorwhileloadingthepage', true);
                return $q.reject();
            }).finally(function() {
                $scope.loaded = true;
            });
        });
    }

    $scope.doRefresh = function() {
        $mmaModPage.invalidateContent(module.id).then(function() {
            return fetchContent();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    fetchContent().then(function() {
        $mmaModPage.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Mod page handlers.
 *
 * @module mm.addons.mod_page
 * @ngdoc service
 * @name $mmaModPageHandlers
 */
.factory('$mmaModPageHandlers', ["$mmCourse", "$mmaModPage", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmFilepool", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModPageComponent", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModPage, $mmEvents, $state, $mmSite, $mmUtil, $mmFilepool,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModPageComponent, $mmContentLinksHelper, $q) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPageHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModPage.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModPage.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModPage.invalidateContent(module.id).finally(function() {
                            $mmaModPage.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('page');
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_page', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModPageComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPageHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModPage.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a page URL.
            if (url.indexOf('/mod/page/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Page factory.
 *
 * @module mm.addons.mod_page
 * @ngdoc service
 * @name $mmaModPage
 */
.factory('$mmaModPage', ["$mmFilepool", "$mmSite", "$mmFS", "$http", "$log", "$q", "$mmSitesManager", "mmaModPageComponent", function($mmFilepool, $mmSite, $mmFS, $http, $log, $q, $mmSitesManager, mmaModPageComponent) {
    $log = $log.getInstance('$mmaModPage');

    var self = {};

    /**
     * Download all the content.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.downloadPackage($mmSite.getId(), files, mmaModPageComponent, module.id, revision, timemod);
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Gets the page HTML.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#getPageHtml
     * @param {Object} contents The module contents.
     * @param {Object} moduleId The module ID.
     * @return {Promise}
     */
    self.getPageHtml = function(contents, moduleId) {
        var indexUrl,
            paths = {},
            promise;

        // Extract the information about paths from the module contents.
        angular.forEach(contents, function(content) {
            var key,
                url = content.fileurl;

            if (self._isMainPage(content)) {
                // This seems to be the most reliable way to spot the index page.
                indexUrl = url;
            } else {
                key = content.filename;
                if (content.filepath !== '/') {
                    // Add the folders without the leading slash.
                    key = content.filepath.substr(1) + key;
                }
                paths[key] = url;
            }
        });

        // Promise handling when we are in a browser.
        promise = (function() {
            var deferred;
            if (!indexUrl) {
                // If ever that happens.
                $log.debug('Could not locate the index page');
                return $q.reject();
            } else if ($mmFS.isAvailable()) {
                // The file system is available.
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModPageComponent, moduleId);
            } else {
                // We return the live URL.
                deferred = $q.defer();
                deferred.resolve($mmSite.fixPluginfileURL(indexUrl));
                return deferred.promise;
            }
        })();

        return promise.then(function(url) {
            // Fetch the URL content.
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    // Now that we have the content, we update the SRC to point back to
                    // the external resource. That will be caught by mm-format-text.
                    var html = angular.element('<div>');
                    html.html(response.data);
                    angular.forEach(html.find('img'), function(img) {
                        var src = paths[decodeURIComponent(img.getAttribute('src'))];
                        if (typeof src !== 'undefined') {
                            img.setAttribute('src', src);
                        }
                    });
                    // We do the same for links.
                    angular.forEach(html.find('a'), function(anchor) {
                        var href = paths[decodeURIComponent(anchor.getAttribute('href'))];
                        if (typeof href !== 'undefined') {
                            anchor.setAttribute('href', href);
                        }
                    });
                    return html.html();
                }
            });
        });
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#invalidateContent
     * @param {Object} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModPageComponent, moduleId);
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Returns whether the file is the main page of the module.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#_isMainPage
     * @param {Object} file An object returned from WS containing file info.
     * @return {Boolean}
     * @protected
     */
    self._isMainPage = function(file) {
        var filename = file.filename || undefined,
            fileurl = file.fileurl || '',
            url = '/mod_page/content/index.html',
            encodedUrl = encodeURIComponent(url);

        return (filename === 'index.html' && (fileurl.indexOf(url) > 0 || fileurl.indexOf(encodedUrl) > 0 ));
    };

    /**
     * Check if page plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.canDownloadFiles();
        });
    };

    /**
     * Report a page as being viewed.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                pageid: id
            };
            return $mmSite.write('mod_page_view_page', params);
        }
        return $q.reject();
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPage#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);
        return $mmFilepool.prefetchPackage($mmSite.getId(), files, mmaModPageComponent, module.id, revision, timemod);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_page')

/**
 * Mod page prefetch handler.
 *
 * @module mm.addons.mod_page
 * @ngdoc service
 * @name $mmaModPagePrefetchHandler
 */
.factory('$mmaModPagePrefetchHandler', ["$mmaModPage", "$mmSite", "mmaModPageComponent", function($mmaModPage, $mmSite, mmaModPageComponent) {

    var self = {};

    self.component = mmaModPageComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPagePrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModPage.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPagePrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmSite.canDownloadFiles();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_page
     * @ngdoc method
     * @name $mmaModPagePrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModPage.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Resource index controller.
 *
 * @module mm.addons.mod_resource
 * @ngdoc controller
 * @name mmaModResourceIndexCtrl
 */
.controller('mmaModResourceIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModResource", "$log", "$mmApp", "$mmCourse", "$timeout", "mmaModResourceComponent", function($scope, $stateParams, $mmUtil, $mmaModResource, $log, $mmApp, $mmCourse, $timeout,
            mmaModResourceComponent) {
    $log = $log.getInstance('mmaModResourceIndexCtrl');

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModResourceComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.mode = false;
    $scope.loaded = false;

    function fetchContent() {
        if (module.contents && module.contents.length) {
            if ($mmaModResource.isDisplayedInIframe(module)) {
                $scope.mode = 'iframe';
                var downloadFailed = false;
                return $mmaModResource.downloadAllContent(module).catch(function(err) {
                    // Mark download as failed but go on since the main files could have been downloaded.
                    downloadFailed = true;
                }).finally(function() {
                    $mmaModResource.getIframeSrc(module).then(function(src) {
                        if ($scope.src && src.toString() == $scope.src.toString()) {
                            // Re-loading same page. Set it to empty and then re-set the src
                            // in the next digest so it detects it has changed.
                            $scope.src = '';
                            $timeout(function() {
                                $scope.src = src;
                            });
                        } else {
                            $scope.src = src;
                        }
                        $mmaModResource.logView(module.instance).then(function() {
                            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                        });
                        if (downloadFailed && $mmApp.isOnline()) {
                            // We could load the main file but the download failed. Show error message.
                            $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                        }
                    }).catch(function() {
                        $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
                    }).finally(function() {
                        $scope.loaded = true;
                    });
                });
            } else if ($mmaModResource.isDisplayedInline(module)) {
                var downloadFailed = false;
                $mmaModResource.downloadAllContent(module).catch(function(err) {
                    // Mark download as failed but go on since the main files could have been downloaded.
                    downloadFailed = true;
                }).finally(function() {
                    $mmaModResource.getResourceHtml(module.contents, module.id).then(function(content) {
                        $scope.mode = 'inline';
                        $scope.content = content;
                        $mmaModResource.logView(module.instance).then(function() {
                            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                        });

                        if (downloadFailed && $mmApp.isOnline()) {
                            // We could load the main file but the download failed. Show error message.
                            $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                        }
                    }).catch(function() {
                        $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
                    }).finally(function() {
                        $scope.loaded = true;
                    });
                });
            } else {
                $scope.loaded = true;
                $scope.mode = 'external';

                $scope.open = function() {
                    var modal = $mmUtil.showModalLoading('mm.core.downloading', true);

                    $mmaModResource.openFile(module.contents, module.id).then(function() {
                        $mmaModResource.logView(module.instance).then(function() {
                            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                        });
                    }).catch(function(error) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
                        }
                    }).finally(function() {
                        modal.dismiss();
                    });
                };
            }
        } else {
            $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
        }
    }

    // Event sent by the directive mmaModResourceHtmlLink when we click an HTML link.
    $scope.$on('mmaModResourceHtmlLinkClicked', function(e, target) {
        $scope.loaded = false;
        $mmaModResource.getResourceHtml(module.contents, module.id, target).then(function(content) {
            $scope.content = content;
        }).catch(function() {
            $mmUtil.showErrorModal('mma.mod_resource.errorwhileloadingthecontent', true);
        }).finally(function() {
            $scope.loaded = true;
        });
    });

    $scope.doRefresh = function() {
        $mmaModResource.invalidateContent(module.id).then(function() {
            return fetchContent();
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    fetchContent();
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Directive to open a link in external browser.
 *
 * @module mm.addons.mod_resource
 * @ngdoc directive
 * @name mmaModResourceHtmlLink
 */
.directive('mmaModResourceHtmlLink', function() {
    return {
        restrict: 'A',
        priority: 99,   // Must be lower than mm-browser, or anything listening for a click event.
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                var href = element[0].getAttribute('data-href');
                if (!href) {
                    return;
                }

                // Prevent any other directive from catching the event.
                event.stopImmediatePropagation();
                event.preventDefault();

                // Notify the scope which must handle this click, we do not support bubbling.
                scope.$emit('mmaModResourceHtmlLinkClicked', href);
            });
        }
    };
});

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Mod resource handlers.
 *
 * @module mm.addons.mod_resource
 * @ngdoc service
 * @name $mmaModResourceHandlers
 */
.factory('$mmaModResourceHandlers', ["$mmCourse", "$mmaModResource", "$mmEvents", "$state", "$mmSite", "$mmUtil", "$mmCoursePrefetchDelegate", "$mmFilepool", "$mmFS", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModResourceComponent", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModResource, $mmEvents, $state, $mmSite, $mmUtil,
            $mmCoursePrefetchDelegate, $mmFilepool, $mmFS, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated,
            mmCoreEventPackageStatusChanged, mmaModResourceComponent, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourceHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModResource.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module   The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    revision = $mmFilepool.getRevisionFromFileList(module.contents),
                    timemodified = $mmFilepool.getTimemodifiedFromFileList(module.contents);

                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModResource.prefetchContent(module).catch(function() {
                            if (!$scope.$$destroyed) {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            }
                        });
                    }
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModResource.invalidateContent(module.id).finally(function() {
                            $mmaModResource.prefetchContent(module).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        });
                    }
                };

                $scope.title = module.name;

                if (module.contents.length) {
                    var filename = module.contents[0].filename,
                        extension = $mmFS.getFileExtension(filename);
                    if (module.contents.length == 1 || (extension != "html" && extension != "htm")) {
                        $scope.icon = $mmFS.getFileIcon(filename);
                    } else {
                        $scope.icon = $mmCourse.getModuleIconSrc('resource');
                    }
                } else {
                    $scope.icon = $mmCourse.getModuleIconSrc('resource');
                }
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_resource', {module: module, courseid: courseid});
                };

                // Show buttons according to module status.
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }

                // Listen for changes on this module status.
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModResourceComponent) {
                        showStatus(data.status);
                    }
                });

                // Get current status to decide which icon should be shown.
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourceHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModResource.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a resource URL.
            if (url.indexOf('/mod/resource/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Mod resource prefetch handler.
 *
 * @module mm.addons.mod_resource
 * @ngdoc service
 * @name $mmaModResourcePrefetchHandler
 */
.factory('$mmaModResourcePrefetchHandler', ["$mmaModResource", "$mmSite", "mmaModResourceComponent", function($mmaModResource, $mmSite, mmaModResourceComponent) {

    var self = {};

    self.component = mmaModResourceComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourcePrefetchHandler#getDownloadSize
     * @param {Object} module Module to get the size.
     * @return {Number}       Size.
     */
    self.getDownloadSize = function(module) {
        var size = 0;
        angular.forEach(module.contents, function(content) {
            if ($mmaModResource.isFileDownloadable(content) && content.filesize) {
                size = size + content.filesize;
            }
        });
        return size;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourcePrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmSite.canDownloadFiles();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResourcePrefetchHandler#prefetch
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module) {
        return $mmaModResource.prefetchContent(module);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_resource')

/**
 * Resource factory.
 *
 * @module mm.addons.mod_resource
 * @ngdoc service
 * @name $mmaModResource
 */
.factory('$mmaModResource', ["$mmFilepool", "$mmSite", "$mmUtil", "$mmFS", "$http", "$log", "$q", "$sce", "$mmApp", "$mmSitesManager", "mmaModResourceComponent", function($mmFilepool, $mmSite, $mmUtil, $mmFS, $http, $log, $q, $sce, $mmApp, $mmSitesManager,
            mmaModResourceComponent) {
    $log = $log.getInstance('$mmaModResource');

    var self = {};

    /**
     * Download all the content. All the files are downloaded inside a folder in filepool, keeping their folder structure.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#downloadAllContent
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.downloadAllContent = function(module) {
        var files = self.getDownloadableFiles(module),
            siteid = $mmSite.getId(),
            promise,
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        if (self.isDisplayedInIframe(module)) {
            // Get path of the module folder in filepool.
            promise = $mmFilepool.getFilePathByUrl(siteid, module.url);
        } else {
            promise = $q.when();
        }

        return promise.then(function(dirPath) {
            return $mmFilepool.downloadPackage(siteid, files, mmaModResourceComponent, module.id, revision, timemod, dirPath);
        });
    };

    /**
     * Returns a list of files that can be downloaded.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModresource#getDownloadableFiles
     * @param {Object} module The module object returned by WS.
     * @return {Object[]}     List of files.
     */
    self.getDownloadableFiles = function(module) {
        var files = [];

        angular.forEach(module.contents, function(content) {
            if (self.isFileDownloadable(content)) {
                files.push(content);
            }
        });

        return files;
    };

    /**
     * Get event names of files being downloaded.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getDownloadingFilesEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Resolved with an array of event names.
     */
    self.getDownloadingFilesEventNames = function(module) {
        var promises = [],
            eventNames = [],
            siteid = $mmSite.getId();

        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.isFileDownloadingByUrl(siteid, url).then(function() {
                return $mmFilepool.getFileEventNameByUrl(siteid, url).then(function(eventName) {
                    eventNames.push(eventName);
                });
            }, function() {
                // Ignore fails.
            }));
        });

        return $q.all(promises).then(function() {
            return eventNames;
        });
    };

    /**
     * Returns a list of file event names.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getFileEventNames
     * @param {Object} module The module object returned by WS.
     * @return {Promise} Promise resolved with array of $mmEvent names.
     */
    self.getFileEventNames = function(module) {
        var promises = [];
        angular.forEach(module.contents, function(content) {
            var url = content.fileurl;
            if (!self.isFileDownloadable(content)) {
                return;
            }
            promises.push($mmFilepool.getFileEventNameByUrl($mmSite.getId(), url));
        });
        return $q.all(promises).then(function(eventNames) {
            return eventNames;
        });
    };

    /**
     * Download all the files needed and returns the src of the iframe.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getIframeSrc
     * @param {Object} module The module object.
     * @return {Promise}      Promise resolved with the iframe src.
     */
    self.getIframeSrc = function(module) {
        if (!module.contents.length) {
            return $q.reject();
        }

        var mainFile = module.contents[0],
            mainFilePath = mainFile.filename;

        if (mainFile.filepath !== '/') {
            mainFilePath = mainFile.filepath.substr(1) + mainFilePath;
        }

        return $mmFilepool.getDirectoryUrlByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, mainFilePath));
        }, function() {
            // Error getting directory, there was an error downloading or we're in browser. Return online URL.
            if ($mmApp.isOnline() && mainFile.fileurl) {
                // This URL is going to be injected in an iframe, we need this to make it work.
                return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(mainFile.fileurl));
            }
            return $q.reject();
        });
    };

    /**
     * Gets the resource HTML.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#getResourceHtml
     * @param {Object[]} contents Array of content objects.
     * @param {Number} moduleId The module ID.
     * @param {String} [target] The HTML file that the user wants to open, if not defined uses the main file.
     * @return {Promise}
     */
    self.getResourceHtml = function(contents, moduleId, target) {
        var indexUrl,
            paths = {},
            promise;

        // Extract the information about paths from the module contents.
        angular.forEach(contents, function(content, index) {
            var url = content.fileurl,
                fullpath = content.filename;

            if (content.filepath !== '/') {
                fullpath = content.filepath.substr(1) + fullpath;
            }

            if (typeof target !== 'undefined' && target == fullpath) {
                // We use another index.
                indexUrl = url;
            } else if (typeof target === 'undefined' && index === 0) {
                // We use the main page, it should always be the first one.
                indexUrl = url;
            } else {
                // Any other file in the resource.
                paths[fullpath] = url;
            }
        });

        // Promise handling when we are in a browser.
        promise = (function() {
            if (!indexUrl) {
                // If ever that happens.
                $log.debug('Could not locate the index page');
                return $q.reject();
            }
            if ($mmFS.isAvailable()) {
                // The file system is available.
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModResourceComponent, moduleId);
            } else {
                // We return the live URL.
                return $q.when($mmSite.fixPluginfileURL(indexUrl));
            }
        })();

        return promise.then(function(url) {
            // Fetch the URL content.
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    // Now that we have the content, we update the SRC to point back to
                    // the external resource. That will be caught by mm-format-text.
                    var html = angular.element('<div>');
                        html.append(response.data);

                    angular.forEach(html.find('img'), function(img) {
                        var src = paths[decodeURIComponent(img.getAttribute('src'))];
                        if (typeof src !== 'undefined') {
                            img.setAttribute('src', src);
                        }
                    });
                    // We do the same for links.
                    angular.forEach(html.find('a'), function(anchor) {
                        var href = decodeURIComponent(anchor.getAttribute('href')),
                            url = paths[href],
                            ext = $mmFS.getFileExtension(href);
                        if (typeof url !== 'undefined') {
                            anchor.setAttribute('href', url);
                            if (ext == 'html' || ext == 'html') {
                                anchor.setAttribute('mma-mod-resource-html-link', 1);
                                anchor.setAttribute('data-href', href);
                            }
                        }
                    });

                    return html.html();
                }
            });
        });
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#invalidateContent
     * @param {Number} moduleId The module ID.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModResourceComponent, moduleId);
    };

    /**
     * Whether the resource has to be displayed in an iframe.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isDisplayedInIframe
     * @param {Object} module The module object.
     * @return {Boolean}
     */
    self.isDisplayedInIframe = function(module) {
        var inline = self.isDisplayedInline(module);

        if (inline && $mmFS.isAvailable()) {
            for (var i = 0; i < module.contents.length; i++) {
                var ext = $mmFS.getFileExtension(module.contents[i].filename);
                if (ext == 'js' || ext == 'swf' || ext == 'css') {
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * Whether the resource is to be displayed inline (HTML).
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isDisplayedInline
     * @param {Object} module The module object.
     * @return {Boolean}
     */
    self.isDisplayedInline = function(module) {
        if (!module.contents.length) {
            return false;
        }
        var ext = $mmFS.getFileExtension(module.contents[0].filename);
        return ext === 'htm' || ext === 'html';
    };

    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isFileDownloadable
     * @param {Object} file File to check.
     * @return {Boolean}    True if downloadable, false otherwise.
     */
    self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };

    /**
     * Check if resource plugin is enabled in a certain site.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.canDownloadFiles();
        });
    };

    /**
     * Report the resource as being viewed.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                resourceid: id
            };
            return $mmSite.write('mod_resource_view_resource', params);
        }
        return $q.reject();
    };

    /**
     * Download and open the file from the resource.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#openFile
     * @param {Object[]} contents Array of content objects.
     * @param {Number} moduleId The module ID.
     * @return {Promise}
     */
    self.openFile = function(contents, moduleId) {
        if (!contents || !contents.length) {
            return $q.reject();
        }

        var url = contents[0].fileurl,
            promise;

        if ($mmFS.isAvailable()) {
            // The file system is available.
            promise = $mmFilepool.downloadUrl($mmSite.getId(), url, false, mmaModResourceComponent, moduleId);
        } else {
            // We use the live URL.
            promise = $q.when($mmSite.fixPluginfileURL(url));
        }

        return promise.then(function(localUrl) {
            return $mmUtil.openFile(localUrl);
        });
    };

    /**
     * Prefetch the content.
     *
     * @module mm.addons.mod_resource
     * @ngdoc method
     * @name $mmaModResource#prefetchContent
     * @param {Object} module The module object returned by WS.
     * @return {Promise}      Promise resolved when content is downloaded. Data returned is not reliable.
     */
    self.prefetchContent = function(module) {
        var files = self.getDownloadableFiles(module),
            siteid = $mmSite.getId(),
            promise,
            revision = $mmFilepool.getRevisionFromFileList(module.contents),
            timemod = $mmFilepool.getTimemodifiedFromFileList(module.contents);

        if (self.isDisplayedInIframe(module)) {
            // Get path of the module folder in filepool.
            promise = $mmFilepool.getFilePathByUrl(siteid, module.url);
        } else {
            promise = $q.when();
        }

        return promise.then(function(dirPath) {
            return $mmFilepool.prefetchPackage(siteid, files, mmaModResourceComponent, module.id, revision, timemod, dirPath);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM index controller.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc controller
 * @name mmaModScormIndexCtrl
 */
.controller('mmaModScormIndexCtrl', ["$scope", "$stateParams", "$mmaModScorm", "$mmUtil", "$q", "$mmCourse", "$ionicScrollDelegate", "$mmCoursePrefetchDelegate", "$mmaModScormHelper", "$mmEvents", "$mmSite", "$state", "mmCoreOutdated", "mmCoreNotDownloaded", "mmCoreDownloading", "mmaModScormComponent", "mmCoreEventPackageStatusChanged", "$ionicHistory", "mmaModScormEventAutomSynced", "$mmaModScormSync", "$timeout", function($scope, $stateParams, $mmaModScorm, $mmUtil, $q, $mmCourse, $ionicScrollDelegate,
            $mmCoursePrefetchDelegate, $mmaModScormHelper, $mmEvents, $mmSite, $state, mmCoreOutdated, mmCoreNotDownloaded,
            mmCoreDownloading, mmaModScormComponent, mmCoreEventPackageStatusChanged, $ionicHistory, mmaModScormEventAutomSynced,
            $mmaModScormSync, $timeout) {

    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        scorm,
        statusObserver,
        currentStatus,
        lastAttempt,
        lastOffline = false,
        attempts,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaModScormIndexScroll');

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.currentOrganization = {};
    $scope.scormOptions = {
        mode: $mmaModScorm.MODENORMAL
    };

    $scope.modenormal = $mmaModScorm.MODENORMAL;
    $scope.modebrowse = $mmaModScorm.MODEBROWSE;

    // Convenience function to get SCORM data.
    function fetchScormData(refresh) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scormData) {
            scorm = scormData;

            $scope.title = scorm.name || $scope.title;
            $scope.description = scorm.intro || $scope.description;
            $scope.scorm = scorm;

            var result = $mmaModScorm.isScormSupported(scorm);
            if (result === true) {
                $scope.errorMessage = '';
            } else {
                $scope.errorMessage = result;
            }

            if (scorm.warningmessage) {
                return; // SCORM is closed or not open yet, we can't get more data.
            }

            return syncScorm(!refresh, false).catch(function() {
                // Ignore errors, keep getting data even if sync fails.
            }).then(function() {

                // No need to return this promise, it should be faster than the rest.
                $mmaModScormHelper.getScormReadableSyncTime(scorm.id).then(function(syncTime) {
                    $scope.syncTime = syncTime;
                });

                // Get the number of attempts and check if SCORM is incomplete.
                return $mmaModScorm.getAttemptCount(scorm.id).then(function(attemptsData) {
                    attempts = attemptsData;
                    $scope.showSyncButton = attempts.offline.length; // Show sync button only if there are offline attempts.

                    // Determine the attempt that will be continued or reviewed.
                    return $mmaModScormHelper.determineAttemptToContinue(scorm, attempts).then(function(attempt) {
                        lastAttempt = attempt.number;
                        lastOffline = attempt.offline;
                        if (lastAttempt != attempts.lastAttempt.number) {
                            $scope.attemptToContinue = lastAttempt;
                        } else {
                            delete $scope.attemptToContinue;
                        }

                        return $mmaModScorm.isAttemptIncomplete(scorm.id, lastAttempt, lastOffline).then(function(incomplete) {
                            var promises = [];

                            scorm.incomplete = incomplete;
                            scorm.numAttempts = attempts.total;
                            scorm.grademethodReadable = $mmaModScorm.getScormGradeMethod(scorm);
                            scorm.attemptsLeft = $mmaModScorm.countAttemptsLeft(scorm, attempts.lastAttempt.number);
                            if (scorm.forceattempt && scorm.incomplete) {
                                $scope.scormOptions.newAttempt = true;
                            }

                            promises.push(getReportedGrades());

                            promises.push(fetchStructure());

                            if (!scorm.packagesize && $scope.errorMessage === '') {
                                // SCORM is supported but we don't have package size. Try to calculate it.
                                promises.push($mmaModScorm.calculateScormSize(scorm).then(function(size) {
                                    scorm.packagesize = size;
                                }));
                            }

                            // Handle status. We don't add getStatus to promises because it should be fast.
                            setStatusListener();
                            getStatus().then(showStatus);

                            return $q.all(promises);
                        });
                    });
                }).catch(function(message) {
                    return showError(message);
                });

            });

        }, function(message) {
            if (!refresh) {
                // Get scorm failed, retry without using cache since it might be a new activity.
                return refreshData();
            }
            return showError(message);
        });
    }

    // Show error message and return a rejected promise.
    function showError(message, defaultMessage) {
        defaultMessage = defaultMessage || 'mma.mod_scorm.errorgetscorm';
        if (message) {
            $mmUtil.showErrorModal(message);
        } else {
            $mmUtil.showErrorModal(defaultMessage, true);
        }
        return $q.reject();
    }

    // Get the grades of each attempt and the grade of the SCORM.
    function getReportedGrades() {
        var promises = [];
        scorm.onlineAttempts = {};
        scorm.offlineAttempts = {};
        // Calculate the grade for each attempt.
        attempts.online.forEach(function(attempt) {
            // Check that attempt isn't in offline to prevent showing the same attempt twice. Offline should be more recent.
            if (attempts.offline.indexOf(attempt) == -1) {
                promises.push(getAttemptGrade(scorm, attempt));
            }
        });
        attempts.offline.forEach(function(attempt) {
            promises.push(getAttemptGrade(scorm, attempt, true));
        });

        return $q.all(promises).then(function() {

            // Calculate the grade of the whole SCORM. We only use online attempts to calculate this data.
            scorm.grade = $mmaModScorm.calculateScormGrade(scorm, scorm.onlineAttempts);

            // Now format the grades.
            angular.forEach(scorm.onlineAttempts, function(attempt) {
                attempt.grade = $mmaModScorm.formatGrade(scorm, attempt.grade);
            });
            angular.forEach(scorm.offlineAttempts, function(attempt) {
                attempt.grade = $mmaModScorm.formatGrade(scorm, attempt.grade);
            });
            scorm.grade = $mmaModScorm.formatGrade(scorm, scorm.grade);
        });
    }

    // Convenience function to get the grade of an attempt and add it to the scorm attempts list.
    function getAttemptGrade(scorm, attempt, offline) {
        return $mmaModScorm.getAttemptGrade(scorm, attempt, offline).then(function(grade) {
            var entry = {
                number: attempt,
                grade: grade
            };
            if (offline) {
                scorm.offlineAttempts[attempt] = entry;
            } else {
                scorm.onlineAttempts[attempt] = entry;
            }
        });
    }

    // Fetch the structure of the SCORM (TOC).
    function fetchStructure() {
        return $mmaModScorm.getOrganizations(scorm.id).then(function(organizations) {
            $scope.organizations = organizations;

            if (!$scope.currentOrganization.identifier) {
                // Load first organization (if any).
                if (organizations.length) {
                    $scope.currentOrganization.identifier = organizations[0].identifier;
                } else {
                    $scope.currentOrganization.identifier = '';
                }
            }

            return loadOrganizationToc($scope.currentOrganization.identifier);
        });
    }

    // Load the TOC of a certain organization.
    function loadOrganizationToc(organizationId) {
        if (!scorm.displaycoursestructure) {
            // TOC is not displayed, no need to load it.
            return $q.when();
        }

        $scope.loadingToc = true;
        return $mmaModScorm.getOrganizationToc(scorm.id, organizationId, lastAttempt, lastOffline).then(function(toc) {
            $scope.toc = $mmaModScorm.formatTocToArray(toc);
            // Get images for each SCO.
            angular.forEach($scope.toc, function(sco) {
                sco.image = $mmaModScorm.getScoStatusIcon(sco, scorm.incomplete);
            });
            // Search organization title.
            angular.forEach($scope.organizations, function(org) {
                if (org.identifier == organizationId) {
                    $scope.currentOrganization.title = org.title;
                }
            });
            // Resize scroll to prevent empty spaces if new TOC is shorter than previous TOC.
            $ionicScrollDelegate.resize();
        }).finally(function() {
            $scope.loadingToc = false;
        });
    }

    // Get status of the SCORM.
    function getStatus() {
        return $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, scorm.sha1hash, 0);
    }

    // Set a listener to monitor changes on this SCORM status to show a message to the user.
    function setStatusListener() {
        if (typeof statusObserver !== 'undefined') {
            return; // Already set.
        }

        // Listen for changes on this module status to show a message to the user.
        statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
            if (data.siteid === $mmSite.getId() && data.componentId === scorm.coursemodule &&
                    data.component === mmaModScormComponent) {
                showStatus(data.status);
            }
        });
    }

    // Showing or hide a status message depending on the SCORM status.
    function showStatus(status) {
        currentStatus = status;

        if (status == mmCoreOutdated) {
            $scope.statusMessage = 'mma.mod_scorm.scormstatusoutdated';
        } else if (status == mmCoreNotDownloaded) {
            $scope.statusMessage = 'mma.mod_scorm.scormstatusnotdownloaded';
        } else if (status == mmCoreDownloading) {
            if (!$scope.downloading) {
                // It's being downloaded right now but the view isn't tracking it. "Restore" the download.
                downloadScormPackage(true);
            }
        } else {
            $scope.statusMessage = '';
        }
    }

    // Refreshes data.
    function refreshData(dontForceSync) {
        var promises = [];
        promises.push($mmaModScorm.invalidateScormData(courseid));
        if (scorm) {
            promises.push($mmaModScorm.invalidateAllScormData(scorm.id));
        }

        return $q.all(promises).finally(function() {
            return fetchScormData(!dontForceSync);
        });
    }

    // Download a SCORM package or restores an ongoing download.
    function downloadScormPackage() {
        $scope.downloading = true;
        return $mmaModScorm.download(scorm).then(undefined, undefined, function(progress) {

            if (!progress) {
                return;
            }

            if (progress.packageDownload) { // Downloading package.
                if (scorm.packagesize) {
                    $scope.percentage = (parseFloat(progress.loaded / scorm.packagesize) * 100).toFixed(1);
                }
            } else if (progress.message) { // Show a message.
                $scope.progressMessage = progress.message;
            } else if (progress.loaded && progress.total) { // Unzipping package.
                $scope.percentage = (parseFloat(progress.loaded / progress.total) * 100).toFixed(1);
            } else {
                $scope.percentage = undefined;
            }

        }).finally(function() {
            $scope.progressMessage = undefined;
            $scope.percentage = undefined;
            $scope.downloading = false;
        });
    }

    // Open a SCORM package.
    function openScorm(scoId) {
        $state.go('site.mod_scorm-player', {
            scorm: scorm,
            mode: $scope.scormOptions.mode,
            newAttempt: !!$scope.scormOptions.newAttempt,
            organizationId: $scope.currentOrganization.identifier,
            scoId: scoId
        });
    }

    // Tries to synchronize the current SCORM.
    function syncScorm(checkTime, showErrors) {
        var promise = checkTime ? $mmaModScormSync.syncScormIfNeeded(scorm) : $mmaModScormSync.syncScorm(scorm);
        return promise.then(function(warnings) {
            var message = $mmaModScormHelper.buildWarningsMessage(warnings);
            if (message) {
                $mmUtil.showErrorModal(message);
            }
        }).catch(function(err) {
            if (showErrors) {
                return showError(err, 'mma.mod_scorm.errorsyncscorm');
            }
            return $q.reject();
        });
    }

    // Fetch the SCORM data.
    fetchScormData().then(function() {
        $mmaModScorm.logView(scorm.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.scormLoaded = true;
    });

    // Load a organization's TOC.
    $scope.loadOrg = function() {
        loadOrganizationToc($scope.currentOrganization.identifier).catch(function(message) {
            return showError(message);
        });
    };

    $scope.refreshScorm = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };

    // Open a SCORM. It will download the SCORM package if it's not downloaded or it has changed.
    // The scoId param indicates the SCO that needs to be loaded when the SCORM is opened. If not defined, load first SCO.
    $scope.open = function(e, scoId) {
        e.preventDefault();
        e.stopPropagation();

        if ($scope.downloading) {
            // Scope is being downloaded, abort.
            return;
        }

        if (currentStatus == mmCoreOutdated || currentStatus == mmCoreNotDownloaded) {
            // SCORM needs to be downloaded.
            $mmaModScormHelper.confirmDownload(scorm).then(function() {
                // Invalidate file if SCORM is outdated.
                var promise = currentStatus == mmCoreOutdated ? $mmaModScorm.invalidateContent(scorm.coursemodule) : $q.when();
                promise.finally(function() {
                    downloadScormPackage().then(function() {
                        // Success downloading, open scorm if user hasn't left the view.
                        if (!$scope.$$destroyed) {
                            openScorm(scoId);
                        }
                    }).catch(function() {
                        if (!$scope.$$destroyed) {
                            $mmaModScormHelper.showDownloadError(scorm);
                        }
                    });
                });
            });
        } else {
            openScorm(scoId);
        }
    };

    // Synchronize the SCORM.
    $scope.sync = function() {
        var modal = $mmUtil.showModalLoading('mm.settings.synchronizing', true);
        syncScorm(false, true).then(function() {
            // Refresh the data.
            $scope.scormLoaded = false;
            scrollView.scrollTop();
            refreshData(true).finally(function() {
                $scope.scormLoaded = true;
            });
        }).finally(function() {
            modal.dismiss();
        });
    };

    // Update data when we come back from the player since it's probable that it has changed.
    // We want to skip the first $ionicView.enter event because it's when the view is created.
    var skip = true;
    $scope.$on('$ionicView.enter', function() {
        if (skip) {
            skip = false;
            return;
        }

        $scope.scormOptions.newAttempt = false; // Uncheck new attempt.

        var forwardView = $ionicHistory.forwardView();
        if (forwardView && forwardView.stateName === 'site.mod_scorm-player') {
            $scope.scormLoaded = false;
            scrollView.scrollTop();
            // Add a delay to make sure the player has started the last writing calls so we can detect conflicts.
            $timeout(function() {
                refreshData().finally(function() {
                    $scope.scormLoaded = true;
                });
            }, 500);
        }
    });

    // Refresh data if this SCORM is synchronized automatically.
    var syncObserver = $mmEvents.on(mmaModScormEventAutomSynced, function(data) {
        if (data && data.siteid == $mmSite.getId() && data.scormid == scorm.id) {
            $scope.scormLoaded = false;
            scrollView.scrollTop();
            fetchScormData().finally(function() {
                $scope.scormLoaded = true;
            });
        }
    });

    $scope.$on('$destroy', function() {
        statusObserver && statusObserver.off && statusObserver.off();
        syncObserver && syncObserver.off && syncObserver.off();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM player controller.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc controller
 * @name mmaModScormPlayerCtrl
 */
.controller('mmaModScormPlayerCtrl', ["$scope", "$stateParams", "$mmaModScorm", "$mmUtil", "$ionicPopover", "$mmaModScormHelper", "$mmEvents", "$timeout", "$q", "mmaModScormEventUpdateToc", "mmaModScormEventLaunchNextSco", "mmaModScormEventLaunchPrevSco", "$mmaModScormDataModel12", "mmaModScormEventGoOffline", "$mmaModScormSync", function($scope, $stateParams, $mmaModScorm, $mmUtil, $ionicPopover, $mmaModScormHelper,
            $mmEvents, $timeout, $q, mmaModScormEventUpdateToc, mmaModScormEventLaunchNextSco, mmaModScormEventLaunchPrevSco,
            $mmaModScormDataModel12, mmaModScormEventGoOffline, $mmaModScormSync) {

    var scorm = $stateParams.scorm || {},
        mode = $stateParams.mode || $mmaModScorm.MODENORMAL,
        newAttempt = $stateParams.newAttempt,
        organizationId = $stateParams.organizationId,
        currentSco,
        attempt,
        userData,
        apiInitialized = false,
        offline = false;

    $scope.title = scorm.name; // We use SCORM name at start, later we'll use the SCO title.
    $scope.scorm = scorm;
    $scope.loadingToc = true;

    if (scorm.popup) {
        // If we receive a value <= 100 we need to assume it's a percentage.
        if (scorm.width <= 100) {
            scorm.width = scorm.width + '%';
        }
        if (scorm.height <= 100) {
            scorm.height = scorm.height + '%';
        }
    }

    // Fetch data needed to play the SCORM.
    function fetchData() {
        // Wait for any ongoing sync to finish. We won't sync a SCORM while it's being played.
        return $mmaModScormSync.waitForSync(scorm.id).then(function() {
            // Get attempts data.
            return $mmaModScorm.getAttemptCount(scorm.id).then(function(attemptsData) {
                return determineAttemptAndMode(attemptsData).then(function() {
                    // Fetch TOC and get user data.
                    var promises = [];
                    promises.push(fetchToc());
                    promises.push($mmaModScorm.getScormUserData(scorm.id, attempt, offline).then(function(data) {
                        userData = data;
                    }));

                    return $q.all(promises);
                });
            }).catch(showError);
        });
    }

    // Determine the attempt to use, the mode (normal/preview) and if it's offline or online.
    function determineAttemptAndMode(attemptsData) {
        return $mmaModScormHelper.determineAttemptToContinue(scorm, attemptsData).then(function(data) {
            attempt = data.number;
            offline = data.offline;
            if (attempt != attemptsData.lastAttempt.number) {
                $scope.attemptToContinue = attempt;
            }

            // Check if current attempt is incomplete.
            var promise;
            if (attempt > 0) {
                promise = $mmaModScorm.isAttemptIncomplete(scorm.id, attempt, offline);
            } else {
                // User doesn't have attempts. Last attempt is not incomplete (since he doesn't have any).
                promise = $q.when(false);
            }

            return promise.then(function(incomplete) {
                // Determine mode and attempt to use.
                var result = $mmaModScorm.determineAttemptAndMode(scorm, mode, attempt, newAttempt, incomplete);

                if (result.attempt > attempt) {
                    // We're creating a new attempt.
                    if (offline) {
                        // Last attempt was offline, so we'll create a new offline attempt.
                        promise = $mmaModScormHelper.createOfflineAttempt(scorm, result.attempt, attemptsData.online.length);
                    } else {
                        // Last attempt was online, verify that we can create a new online attempt. We ignore cache.
                        promise = $mmaModScorm.getScormUserData(scorm.id, result.attempt, false, undefined, undefined, true)
                                    .catch(function() {
                            // Cannot communicate with the server, create an offline attempt.
                            offline = true;
                            return $mmaModScormHelper.createOfflineAttempt(scorm, result.attempt, attemptsData.online.length);
                        });
                    }
                } else {
                    promise = $q.when();
                }

                return promise.then(function() {
                    mode = result.mode;
                    newAttempt = result.newAttempt;
                    attempt = result.attempt;
                    $scope.isBrowse = mode === $mmaModScorm.MODEBROWSE;
                    $scope.isReview = mode === $mmaModScorm.MODEREVIEW;
                });
            });
        });
    }

    // Show error and reject.
    function showError(message) {
        if (message) {
            $mmUtil.showErrorModal(message);
        } else {
            $mmUtil.showErrorModal('mma.mod_scorm.errorgetscorm', true);
        }
        return $q.reject();
    }

    // Fetch TOC.
    function fetchToc() {
        $scope.loadingToc = true;
        // We need to check incomplete again: attempt number might have changed in determineAttemptAndMode,
        // or attempt status might have changed due to an action in the current SCO.
        return $mmaModScorm.isAttemptIncomplete(scorm.id, attempt, offline).then(function(incomplete) {
            scorm.incomplete = incomplete;

            // Get TOC.
            return $mmaModScorm.getOrganizationToc(scorm.id, organizationId, attempt, offline).then(function(toc) {
                $scope.toc = $mmaModScorm.formatTocToArray(toc);
                // Get images for each SCO.
                angular.forEach($scope.toc, function(sco) {
                    sco.image = $mmaModScorm.getScoStatusIcon(sco, scorm.incomplete);
                });
                // Determine current SCO if param is set.
                if ($stateParams.scoId > 0) {
                    // SCO set by parameter, get it from TOC.
                    currentSco = $mmaModScormHelper.getScoFromToc($scope.toc, $stateParams.scoId);
                }

                if (!currentSco) {
                    // No SCO defined. Get the first valid one.
                    return $mmaModScormHelper.getFirstSco(scorm.id, $scope.toc, organizationId, attempt, offline)
                            .then(function(sco) {
                        if (sco) {
                            currentSco = sco;
                        } else {
                            // We couldn't find a SCO to load: they're all inactive or without launch URL.
                            $scope.errorMessage = 'mma.mod_scorm.errornovalidsco';
                        }
                    });
                }
            });
        }).finally(function() {
            $scope.loadingToc = false;
        });
    }

    // Calculate the next and previous SCO.
    function calculateNextAndPreviousSco(scoId) {
        $scope.previousSco = $mmaModScormHelper.getPreviousScoFromToc($scope.toc, scoId);
        $scope.nextSco = $mmaModScormHelper.getNextScoFromToc($scope.toc, scoId);
    }

    // Load a SCO.
    function loadSco(sco) {
        // Setup API.
        if (!apiInitialized) {
            $mmaModScormDataModel12.initAPI(scorm, sco.id, attempt, userData, mode, offline);
            apiInitialized = true;
        } else {
            $mmaModScormDataModel12.loadSco(sco.id);
        }

        currentSco = sco;
        $scope.title = sco.title || scorm.name; // Try to use SCO title.
        calculateNextAndPreviousSco(sco.id);
        $mmaModScorm.getScoSrc(scorm, sco).then(function(src) {
            if ($scope.src && src.toString() == $scope.src.toString()) {
                // Re-loading same page. Set it to empty and then re-set the src in the next digest so it detects it has changed.
                $scope.src = '';
                $timeout(function() {
                    $scope.src = src;
                });
            } else {
                $scope.src = src;
            }
        });

        if (sco.scormtype == 'asset') {
            // Mark the asset as completed.
            var tracks = [{
                element: 'cmi.core.lesson_status',
                value: 'completed'
            }];
            $mmaModScorm.saveTracks(sco.id, attempt, tracks, offline, scorm).catch(function() {
                // Error saving data. We'll go offline if we're online and the asset is not marked as completed already.
                if (!offline) {
                    return $mmaModScorm.getScormUserData(scorm.id, attempt, offline).then(function(data) {
                        if (!data[sco.id] || data[sco.id].userdata['cmi.core.lesson_status'] != 'completed') {
                            // Go offline.
                            return $mmaModScormHelper.convertAttemptToOffline(scorm, attempt).then(function() {
                                offline = true;
                                $mmaModScormDataModel12.setOffline(true);
                                return $mmaModScorm.saveTracks(sco.id, attempt, tracks, offline, scorm);
                            }).catch(showError);
                        }
                    });
                }
            }).then(function() {
                // Refresh TOC, some prerequisites might have changed.
                refreshToc();
            });
        }

        // Trigger SCO launch event.
        $mmaModScorm.logLaunchSco(scorm.id, sco.id);
    }

    // Refresh the TOC.
    function refreshToc() {
        $mmaModScorm.invalidateAllScormData(scorm.id).finally(function() {
            fetchToc().catch(showError);
        });
    }

    // Set SCORM start time.
    function setStartTime(scoId) {
        var tracks = [{
            element: 'x.start.time',
            value: $mmUtil.timestamp()
        }];
        return $mmaModScorm.saveTracks(scoId, attempt, tracks, offline, scorm).then(function() {
            if (!offline) {
                // New online attempt created, update cached data about online attempts.
                $mmaModScorm.getAttemptCount(scorm.id, undefined, undefined, false, true);
            }
        });
    }

    $scope.showToc = $mmaModScorm.displayTocInPlayer(scorm);
    if ($scope.showToc) {
        // Setup TOC popover.
        $ionicPopover.fromTemplateUrl('addons/mod_scorm/templates/toc.html', {
            scope: $scope,
        }).then(function(popover) {
            $scope.popover = popover;
        });
    }

    // Fetch the SCORM data.
    fetchData().then(function() {
        if (currentSco) {
            // Set start time if it's a new attempt.
            var promise = newAttempt ? setStartTime(currentSco.id) : $q.when();
            return promise.catch(showError).finally(function() {
                // Load SCO.
                loadSco(currentSco);
            });
        }
    }).finally(function() {
        $scope.loaded = true;
    });

    $scope.loadSco = function(sco) {
        if (!sco.prereq || !sco.isvisible || !sco.launch) {
            return;
        }

        $scope.popover.hide();
        loadSco(sco);
    };

    // Listen for events to update the TOC and navigate through SCOs.
    var tocObserver = $mmEvents.on(mmaModScormEventUpdateToc, function(data) {
        if (data.scormid === scorm.id) {
            if (offline) {
                // Wait a bit to make sure data is stored.
                $timeout(refreshToc, 100);
            } else {
                refreshToc();
            }
        }
    });

    var launchNextObserver = $mmEvents.on(mmaModScormEventLaunchNextSco, function(data) {
        if (data.scormid === scorm.id && $scope.nextSco) {
            loadSco($scope.nextSco);
        }
    });

    var launchPrevObserver = $mmEvents.on(mmaModScormEventLaunchPrevSco, function(data) {
        if (data.scormid === scorm.id && $scope.previousSco) {
            loadSco($scope.previousSco);
        }
    });

    var goOfflineObserver = $mmEvents.on(mmaModScormEventGoOffline, function(data) {
        if (data.scormid === scorm.id && !offline) {
            offline = true;
            $timeout(function() {
                // Wait a bit to prevent collisions between this store and SCORM API's store.
                $mmaModScormHelper.convertAttemptToOffline(scorm, attempt).catch(showError).finally(function() {
                    refreshToc();
                });
            }, 200);
        }
    });

    // Empty src when leaving the state so unload event is triggered in the iframe.
    $scope.$on('$ionicView.beforeLeave', function() {
        $scope.src = '';
    });

    $scope.$on('$destroy', function() {
        tocObserver && tocObserver.off && tocObserver.off();
        launchNextObserver && launchNextObserver.off && launchNextObserver.off();
        launchPrevObserver && launchPrevObserver.off && launchPrevObserver.off();
        goOfflineObserver && goOfflineObserver.off && goOfflineObserver.off();
    });
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM data model implementation for version 1.2.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormDataModel12
 */
.factory('$mmaModScormDataModel12', ["$mmaModScorm", "$mmEvents", "$window", "mmaModScormEventLaunchNextSco", "mmaModScormEventLaunchPrevSco", "mmaModScormEventUpdateToc", "mmaModScormEventGoOffline", function($mmaModScorm, $mmEvents, $window, mmaModScormEventLaunchNextSco,
            mmaModScormEventLaunchPrevSco, mmaModScormEventUpdateToc, mmaModScormEventGoOffline) {
    var self = {};

    /**
     * Initialize the global SCORM API class.
     *
     * @param  {Object} scorm    The SCORM object.
     * @param  {Number} scoId    The SCO id.
     * @param  {Number} attempt  The attempt number.
     * @param  {Object} userData The user default data.
     * @param  {String} mode     Mode. One of $mmaModScorm#MODE constants.
     * @param  {Boolean} offline True if attempt is offline, false otherwise.
     */
    function SCORMAPI(scorm, scoId, attempt, userData, mode, offline) {

        // Contains all the current values for all the data model elements for each SCO.
        var currentUserData = {},
            self = this;

        // Current SCO Id.
        self.scoId = scoId;
        self.offline = offline;

        // Convenience function to trigger events.
        function triggerEvent(name) {
            $mmEvents.trigger(name, {
                scormid: scorm.id,
                scoid: self.scoId,
                attempt: attempt
            });
        }

        // Standard Data Type Definition.
        var CMIString256 = '^[\\u0000-\\uFFFF]{0,255}$';
        var CMIString4096 = '^[\\u0000-\\uFFFF]{0,4096}$';
        var CMITime = '^([0-2]{1}[0-9]{1}):([0-5]{1}[0-9]{1}):([0-5]{1}[0-9]{1})(\.[0-9]{1,2})?$';
        var CMITimespan = '^([0-9]{2,4}):([0-9]{2}):([0-9]{2})(\.[0-9]{1,2})?$';
        var CMIInteger = '^\\d+$';
        var CMISInteger = '^-?([0-9]+)$';
        var CMIDecimal = '^-?([0-9]{0,3})(\.[0-9]*)?$';
        var CMIIdentifier = '^[\\u0021-\\u007E]{0,255}$';
        var CMIFeedback = CMIString256; // This must be redefined.
        var CMIIndex = '[._](\\d+).';

        // Vocabulary Data Type Definition.
        var CMIStatus = '^passed$|^completed$|^failed$|^incomplete$|^browsed$';
        var CMIStatus2 = '^passed$|^completed$|^failed$|^incomplete$|^browsed$|^not attempted$';
        var CMIExit = '^time-out$|^suspend$|^logout$|^$';
        var CMIType = '^true-false$|^choice$|^fill-in$|^matching$|^performance$|^sequencing$|^likert$|^numeric$';
        var CMIResult = '^correct$|^wrong$|^unanticipated$|^neutral$|^([0-9]{0,3})?(\.[0-9]*)?$';
        var NAVEvent = '^previous$|^continue$';

        // Children lists.
        var cmi_children = 'core,suspend_data,launch_data,comments,objectives,student_data,student_preference,interactions';
        var core_children = 'student_id,student_name,lesson_location,credit,lesson_status,entry,score,total_time,lesson_mode,exit,session_time';
        var score_children = 'raw,min,max';
        var comments_children = 'content,location,time';
        var objectives_children = 'id,score,status';
        var correct_responses_children = 'pattern';
        var student_data_children = 'mastery_score,max_time_allowed,time_limit_action';
        var student_preference_children = 'audio,language,speed,text';
        var interactions_children = 'id,objectives,time,type,correct_responses,weighting,student_response,result,latency';

        // Data ranges.
        var score_range = '0#100';
        var audio_range = '-1#100';
        var speed_range = '-100#100';
        var weighting_range = '-100#100';
        var text_range = '-1#1';

        // Prepare the definition array containing the default values.
        var def = {};
        // We need an extra object that will contain the objectives and interactions data (all the .n. elements).
        var defExtra = {};

        angular.forEach(userData, function(sco) {
            def[sco.scoid] = sco.defaultdata;
            defExtra[sco.scoid] = sco.userdata;
        });

        // The SCORM 1.2 data model.
        // Set up data model for each sco.
        var datamodel = {};
        for (var scoid in def) {
            datamodel[scoid] = {
                'cmi._children':{'defaultvalue':cmi_children, 'mod':'r', 'writeerror':'402'},
                'cmi._version':{'defaultvalue':'3.4', 'mod':'r', 'writeerror':'402'},
                'cmi.core._children':{'defaultvalue':core_children, 'mod':'r', 'writeerror':'402'},
                'cmi.core.student_id':{'defaultvalue':def[scoid]['cmi.core.student_id'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.student_name':{'defaultvalue':def[scoid]['cmi.core.student_name'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_location':{'defaultvalue':def[scoid]['cmi.core.lesson_location'], 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.credit':{'defaultvalue':def[scoid]['cmi.core.credit'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_status':{'defaultvalue':def[scoid]['cmi.core.lesson_status'], 'format':CMIStatus, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.entry':{'defaultvalue':def[scoid]['cmi.core.entry'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.score._children':{'defaultvalue':score_children, 'mod':'r', 'writeerror':'402'},
                'cmi.core.score.raw':{'defaultvalue':def[scoid]['cmi.core.score.raw'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.score.max':{'defaultvalue':def[scoid]['cmi.core.score.max'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.score.min':{'defaultvalue':def[scoid]['cmi.core.score.min'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.total_time':{'defaultvalue':def[scoid]['cmi.core.total_time'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_mode':{'defaultvalue':def[scoid]['cmi.core.lesson_mode'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.exit':{'defaultvalue':def[scoid]['cmi.core.exit'], 'format':CMIExit, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.core.session_time':{'format':CMITimespan, 'mod':'w', 'defaultvalue':'00:00:00', 'readerror':'404', 'writeerror':'405'},
                'cmi.suspend_data':{'defaultvalue':def[scoid]['cmi.suspend_data'], 'format':CMIString4096, 'mod':'rw', 'writeerror':'405'},
                'cmi.launch_data':{'defaultvalue':def[scoid]['cmi.launch_data'], 'mod':'r', 'writeerror':'403'},
                'cmi.comments':{'defaultvalue':def[scoid]['cmi.comments'], 'format':CMIString4096, 'mod':'rw', 'writeerror':'405'},
                // Deprecated evaluation attributes.
                'cmi.evaluation.comments._count':{'defaultvalue':'0', 'mod':'r', 'writeerror':'402'},
                'cmi.evaluation.comments._children':{'defaultvalue':comments_children, 'mod':'r', 'writeerror':'402'},
                'cmi.evaluation.comments.n.content':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.evaluation.comments.n.location':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.evaluation.comments.n.time':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMITime, 'mod':'rw', 'writeerror':'405'},
                'cmi.comments_from_lms':{'mod':'r', 'writeerror':'403'},
                'cmi.objectives._children':{'defaultvalue':objectives_children, 'mod':'r', 'writeerror':'402'},
                'cmi.objectives._count':{'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.objectives.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score._children':{'pattern':CMIIndex, 'mod':'r', 'writeerror':'402'},
                'cmi.objectives.n.score.raw':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score.min':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score.max':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.status':{'pattern':CMIIndex, 'format':CMIStatus2, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_data._children':{'defaultvalue':student_data_children, 'mod':'r', 'writeerror':'402'},
                'cmi.student_data.mastery_score':{'defaultvalue':def[scoid]['cmi.student_data.mastery_score'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_data.max_time_allowed':{'defaultvalue':def[scoid]['cmi.student_data.max_time_allowed'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_data.time_limit_action':{'defaultvalue':def[scoid]['cmi.student_data.time_limit_action'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_preference._children':{'defaultvalue':student_preference_children, 'mod':'r', 'writeerror':'402'},
                'cmi.student_preference.audio':{'defaultvalue':def[scoid]['cmi.student_preference.audio'], 'format':CMISInteger, 'range':audio_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.language':{'defaultvalue':def[scoid]['cmi.student_preference.language'], 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.speed':{'defaultvalue':def[scoid]['cmi.student_preference.speed'], 'format':CMISInteger, 'range':speed_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.text':{'defaultvalue':def[scoid]['cmi.student_preference.text'], 'format':CMISInteger, 'range':text_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.interactions._children':{'defaultvalue':interactions_children, 'mod':'r', 'writeerror':'402'},
                'cmi.interactions._count':{'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.objectives._count':{'pattern':CMIIndex, 'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.objectives.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.time':{'pattern':CMIIndex, 'format':CMITime, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.type':{'pattern':CMIIndex, 'format':CMIType, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.correct_responses._count':{'pattern':CMIIndex, 'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.correct_responses.n.pattern':{'pattern':CMIIndex, 'format':CMIFeedback, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.weighting':{'pattern':CMIIndex, 'format':CMIDecimal, 'range':weighting_range, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.student_response':{'pattern':CMIIndex, 'format':CMIFeedback, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.result':{'pattern':CMIIndex, 'format':CMIResult, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.latency':{'pattern':CMIIndex, 'format':CMITimespan, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'nav.event':{'defaultvalue':'', 'format':NAVEvent, 'mod':'w', 'readerror':'404', 'writeerror':'405'}
            };

            currentUserData[scoid] = {};

            // Load default values.
            for (var element in datamodel[scoid]) {
                if (element.match(/\.n\./) === null) {
                    if (typeof datamodel[scoid][element].defaultvalue != 'undefined') {
                        currentUserData[scoid][element] = datamodel[scoid][element].defaultvalue;
                    }
                }
            }

            // Load initial user data for current SCO.
            for (element in def[scoid]) {
                if (element.match(/\.n\./) === null) {
                    if (typeof datamodel[scoid][element].defaultvalue != 'undefined') {
                        currentUserData[scoid][element] = datamodel[scoid][element].defaultvalue;
                    } else if (typeof defExtra[scoid][element] != 'undefined') {
                        // Check in user data values.
                        currentUserData[scoid][element] = defExtra[scoid][element];
                    } else {
                        currentUserData[scoid][element] = '';
                    }
                }
            }

            // Load interactions and objectives, and init the counters.
            var expression = new RegExp(CMIIndex,'g');
            var elementDotFormat, counterElement, currentCounterIndex, currentN;
            for (element in defExtra[scoid]) {
                counterElement = '';
                currentCounterIndex = 0;
                // This check for an indexed element. cmi.objectives.1.id or cmi.objectives_1.id.
                if (element.match(expression)) {
                    // Normalize to the expected value according the standard.
                    // Moodle stores this values using _n. instead .n.
                    elementDotFormat = element.replace(expression, ".$1.");
                    currentUserData[scoid][elementDotFormat] = defExtra[scoid][element];

                    // Get the correct counter and current index.
                    if (elementDotFormat.indexOf("cmi.evaluation.comments") === 0) {
                        counterElement = "cmi.evaluation.comments._count";
                        currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                    } else if (elementDotFormat.indexOf("cmi.objectives") === 0) {
                        counterElement = "cmi.objectives._count";
                        currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                    } else if (elementDotFormat.indexOf("cmi.interactions") === 0) {
                        if (elementDotFormat.indexOf(".objectives.") > 0) {
                            currentN = elementDotFormat.match(/cmi.interactions.(\d+)./)[1];
                            currentCounterIndex = elementDotFormat.match(/objectives.(\d+)./)[1];
                            counterElement = "cmi.interactions." + currentN + ".objectives._count";
                        } else if (elementDotFormat.indexOf(".correct_responses.") > 0) {
                            currentN = elementDotFormat.match(/cmi.interactions.(\d+)./)[1];
                            currentCounterIndex = elementDotFormat.match(/correct_responses.(\d+)./)[1];
                            counterElement = "cmi.interactions." + currentN + ".correct_responses._count";
                        } else {
                            counterElement = "cmi.interactions._count";
                            currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                        }
                    }

                    if (counterElement) {
                        if (typeof currentUserData[scoid][counterElement] == "undefined") {
                            currentUserData[scoid][counterElement] = 0;
                        }
                        // Check if we need to sum.
                        if (parseInt(currentCounterIndex) == parseInt(currentUserData[scoid][counterElement])) {
                            currentUserData[scoid][counterElement] = parseInt(currentUserData[scoid][counterElement]) + 1;
                        }
                        if (parseInt(currentCounterIndex) > parseInt(currentUserData[scoid][counterElement])) {
                            currentUserData[scoid][counterElement] = parseInt(currentCounterIndex) - 1;
                        }
                    }

                }
            }

            // Set default status.
            if (currentUserData[scoid]['cmi.core.lesson_status'] === '') {
                currentUserData[scoid]['cmi.core.lesson_status'] = 'not attempted';
            }

            // Define mode and credit.
            currentUserData[scoid]['cmi.core.credit'] = mode == $mmaModScorm.MODENORMAL ? 'credit' : 'no-credit';
            currentUserData[scoid]['cmi.core.lesson_mode'] = mode;
        }

        // API helper methods.

        /**
         * Get the value of the given element from the non-persistent (current) user data.
         *
         * @param  {String} el The element
         * @return {String}    The element value
         */
        function getEl(el) {
            if (typeof currentUserData[self.scoId] != 'undefined' && typeof currentUserData[self.scoId][el] != 'undefined') {
                return currentUserData[self.scoId][el];
            }
            return '';
        }

        /**
         * Set the value of the given element in the non-persistent (current) user data.
         *
         * @param  {String} el The element
         * @param  {String} value The value
         */
        function setEl(el, value) {
            if (typeof currentUserData[self.scoId] == 'undefined') {
                currentUserData[self.scoId] = {};
            }
            currentUserData[self.scoId][el] = value;
        }

        /**
         * Utility function for cloning an object
         *
         * @param {Object} obj The object to  be cloned
         * @return {Object} The object cloned
         */
        function CloneObj(obj){
            if(obj == null || typeof(obj) != 'object') {
                return obj;
            }

            var temp = new obj.constructor(); // Changed (twice).
            for(var key in obj) {
                temp[key] = CloneObj(obj[key]);
            }

            return temp;
        }

        /**
         * Utility function for adding two times in format hh:mm:ss.
         *
         * @param {String} first  First time.
         * @param {String} second Second time.
         * @return {String}       Total time.
         */
        function AddTime (first, second) {
            var sFirst = first.split(":");
            var sSecond = second.split(":");
            var cFirst = sFirst[2].split(".");
            var cSecond = sSecond[2].split(".");
            var change = 0;

            FirstCents = 0;  //Cents
            if (cFirst.length > 1) {
                FirstCents = parseInt(cFirst[1],10);
            }
            SecondCents = 0;
            if (cSecond.length > 1) {
                SecondCents = parseInt(cSecond[1],10);
            }
            var cents = FirstCents + SecondCents;
            change = Math.floor(cents / 100);
            cents = cents - (change * 100);
            if (Math.floor(cents) < 10) {
                cents = "0" + cents.toString();
            }

            var secs = parseInt(cFirst[0],10) + parseInt(cSecond[0],10) + change;  //Seconds
            change = Math.floor(secs / 60);
            secs = secs - (change * 60);
            if (Math.floor(secs) < 10) {
                secs = "0" + secs.toString();
            }

            mins = parseInt(sFirst[1],10) + parseInt(sSecond[1],10) + change;   //Minutes
            change = Math.floor(mins / 60);
            mins = mins - (change * 60);
            if (mins < 10) {
                mins = "0" + mins.toString();
            }

            hours = parseInt(sFirst[0],10) + parseInt(sSecond[0],10) + change;  //Hours
            if (hours < 10) {
                hours = "0" + hours.toString();
            }

            if (cents != '0') {
                return hours + ":" + mins + ":" + secs + '.' + cents;
            } else {
                return hours + ":" + mins + ":" + secs;
            }
        }

        /**
         * Utility function for calculating the total time spent in the SCO.
         */
        function TotalTime() {
            total_time = AddTime(getEl('cmi.core.total_time'), getEl('cmi.core.session_time'));
            return {'element': 'cmi.core.total_time', value: total_time};
        }

        /**
         * Persist the current user data (this is usually called by LMSCommit)
         *
         * @param {Bool} storetotaltime If true, we need to calculate the total time too
         * @return {Bool} [description]
         */
        function StoreData(storetotaltime) {
            if (storetotaltime) {
                if (getEl('cmi.core.lesson_status') == 'not attempted') {
                    setEl('cmi.core.lesson_status', 'completed');
                }
                if (getEl('cmi.core.lesson_mode') == $mmaModScorm.MODENORMAL) {
                    if (getEl('cmi.core.credit') == 'credit') {
                        if (getEl('cmi.student_data.mastery_score') !== '' && getEl('cmi.core.score.raw') !== '') {
                            if (parseFloat(getEl('cmi.core.score.raw')) >= parseFloat(getEl('cmi.student_data.mastery_score'))) {
                                setEl('cmi.core.lesson_status', 'passed');
                            } else {
                                setEl('cmi.core.lesson_status', 'failed');
                            }
                        }
                    }
                }
                if (getEl('cmi.core.lesson_mode') == $mmaModScorm.MODEBROWSE) {
                    if (datamodel[self.scoId]['cmi.core.lesson_status'].defaultvalue == '' && getEl('cmi.core.lesson_status') == 'not attempted') {
                        setEl('cmi.core.lesson_status', 'browsed');
                    }
                }
                tracks = CollectData();
                tracks.push(TotalTime());
            } else {
                tracks = CollectData();
            }
            var success = $mmaModScorm.saveTracksSync(self.scoId, attempt, tracks, self.offline, scorm, currentUserData);
            if (!self.offline && !success) {
                // Failure storing data in online. Go offline.
                self.offline = true;
                triggerEvent(mmaModScormEventGoOffline);
                return $mmaModScorm.saveTracksSync(self.scoId, attempt, tracks, self.offline, scorm, currentUserData);
            }
            return success;
        }

        /**
         * Collect all the user tracking data that must be persisted in the system, this is usually called by LMSCommit().
         *
         */
        function CollectData() {
            var data = [];
            for (var element in currentUserData[self.scoId]) {
                // Ommit for example the nav. elements.
                if (element.substr(0, 3) == 'cmi') {
                    expression = new RegExp(CMIIndex,'g');

                    // Get the generic name for this element (e.g. convert 'cmi.interactions.1.id' to 'cmi.interactions.n.id')
                    elementmodel = String(element).replace(expression,'.n.');

                    // Ignore the session time element.
                    if (element != "cmi.core.session_time") {

                        // Check if this specific element is not defined in the datamodel,
                        // but the generic element name is.
                        if (typeof datamodel[self.scoId][element] == "undefined" &&
                                typeof datamodel[self.scoId][elementmodel] != "undefined") {

                            // Add this specific element to the data model (by cloning
                            // the generic element) so we can track changes to it.
                            datamodel[self.scoId][element] = CloneObj(datamodel[self.scoId][elementmodel]);
                        }

                        // Check if the current element exists in the datamodel.
                        if (typeof datamodel[self.scoId][element] != "undefined") {

                            // Make sure this is not a read only element.
                            if (datamodel[self.scoId][element].mod != 'r') {

                                var el = {
                                    // Moodle stores the organizations and interactions using _n. instead .n.
                                    'element': element.replace(expression, "_$1."),
                                    'value': getEl(element)
                                };

                                // Check if the element has a default value.
                                if (typeof datamodel[self.scoId][element].defaultvalue != "undefined") {

                                    // Check if the default value is different from the current value.
                                    if (datamodel[self.scoId][element].defaultvalue != el['value'] ||
                                            typeof datamodel[self.scoId][element].defaultvalue != typeof(el['value'])) {

                                        data.push(el);

                                        // Update the element default to reflect the current committed value.
                                        datamodel[self.scoId][element].defaultvalue = el['value'];
                                    }
                                } else {
                                    data.push(el);
                                    // No default value for the element, so set it now.
                                    datamodel[self.scoId][element].defaultvalue = el['value'];
                                }
                            }
                        }
                    }
                }

            }
            return data;
        }

        // API methods now.
        var initialized = false;
        var errorCode;
        var timeout;

        self.LMSInitialize = function(param) {
            errorCode = "0";
            if (param == "") {
                if (!initialized) {
                    initialized = true;
                    errorCode = "0";
                    return "true";
                } else {
                    errorCode = "101";
                }
            } else {
                errorCode = "201";
            }

            return "false";
        };

        self.LMSFinish = function(param) {
            errorCode = "0";
            if (param == "") {
                if (initialized) {
                    initialized = false;
                    result = StoreData(true);
                    if (getEl('nav.event') != '') {
                        if (getEl('nav.event') == 'continue') {
                            triggerEvent(mmaModScormEventLaunchNextSco);
                        } else {
                            triggerEvent(mmaModScormEventLaunchPrevSco);
                        }
                    } else {
                        if (scorm.auto == '1') {
                            triggerEvent(mmaModScormEventLaunchNextSco);
                        }
                    }
                    errorCode = (result) ? '0' : '101';

                    // Trigger TOC update.
                    triggerEvent(mmaModScormEventUpdateToc);
                    return result;
                } else {
                    errorCode = "301";
                }
            } else {
                errorCode = "201";
            }
            return "false";
        };

        self.LMSGetValue = function(element) {
            errorCode = "0";
            if (initialized) {
                if (element != "") {
                    expression = new RegExp(CMIIndex,'g');
                    elementmodel = String(element).replace(expression,'.n.');
                    if (typeof datamodel[self.scoId][elementmodel] != "undefined") {
                        if (datamodel[self.scoId][elementmodel].mod != 'w') {
                            errorCode = "0";
                            return getEl(element);
                        } else {
                            errorCode = datamodel[self.scoId][elementmodel].readerror;
                        }
                    } else {
                        childrenstr = '._children';
                        countstr = '._count';
                        if (elementmodel.substr(elementmodel.length - childrenstr.length,elementmodel.length) == childrenstr) {
                            parentmodel = elementmodel.substr(0,elementmodel.length - childrenstr.length);
                            if (typeof datamodel[self.scoId][parentmodel] != "undefined") {
                                errorCode = "202";
                            } else {
                                errorCode = "201";
                            }
                        } else if (elementmodel.substr(elementmodel.length - countstr.length,elementmodel.length) == countstr) {
                            parentmodel = elementmodel.substr(0,elementmodel.length - countstr.length);
                            if (typeof datamodel[self.scoId][parentmodel] != "undefined") {
                                errorCode = "203";
                            } else {
                                errorCode = "201";
                            }
                        } else {
                            errorCode = "201";
                        }
                    }
                } else {
                    errorCode = "201";
                }
            } else {
                errorCode = "301";
            }
            return "";
        };

        self.LMSSetValue = function(element, value) {
            errorCode = "0";
            if (initialized) {
                if (element != "") {
                    expression = new RegExp(CMIIndex,'g');
                    elementmodel = String(element).replace(expression,'.n.');
                    if (typeof datamodel[self.scoId][elementmodel] != "undefined") {
                        if (datamodel[self.scoId][elementmodel].mod != 'r') {
                            expression = new RegExp(datamodel[self.scoId][elementmodel].format);
                            value = value + '';
                            matches = value.match(expression);
                            if (matches != null) {
                                // Create dynamic data model element.
                                if (element != elementmodel) {

                                    // Init default counters and values.
                                    if (element.indexOf("cmi.objectives") === 0) {
                                        currentN = element.match(/cmi.objectives.(\d+)./)[1];
                                        counterElement = "cmi.objectives." + currentN + ".score";
                                        if (typeof currentUserData[self.scoId][counterElement + '._children'] == "undefined") {
                                            setEl(currentUserData[self.scoId][counterElement + '._children'], score_children);
                                            setEl(currentUserData[self.scoId][counterElement + '.raw'], '');
                                            setEl(currentUserData[self.scoId][counterElement + '.min'], '');
                                            setEl(currentUserData[self.scoId][counterElement + '.max'], '');
                                        }

                                    } else if (element.indexOf("cmi.interactions") === 0) {
                                        currentN = element.match(/cmi.interactions.(\d+)./)[1];

                                        counterElement = "cmi.interactions." + currentN + ".objectives._count";
                                        if (typeof currentUserData[self.scoId][counterElement] == "undefined") {
                                            setEl(counterElement, 0);
                                        }
                                        counterElement = "cmi.interactions." + currentN + ".correct_responses._count";
                                        if (typeof currentUserData[self.scoId][counterElement] == "undefined") {
                                            setEl(counterElement, 0);
                                        }
                                    }

                                    elementIndexes = element.split('.');
                                    subelement = 'cmi';
                                    for (i = 1; i < elementIndexes.length - 1; i++) {
                                        elementIndex = elementIndexes[i];
                                        if (elementIndexes[i + 1].match(/^\d+$/)) {
                                            if (typeof currentUserData[self.scoId][subelement + '.' + elementIndex + '._count'] == "undefined") {
                                                setEl(subelement + '.' + elementIndex + '._count', 0);
                                            }
                                            if (elementIndexes[i + 1] == getEl(subelement + '.' + elementIndex + '._count')) {
                                                var count = getEl(subelement + '.' + elementIndex + '._count');
                                                setEl(subelement + '.' + elementIndex + '._count', parseInt(count) + 1);
                                            }
                                            if (elementIndexes[i + 1] > getEl(subelement + '.' + elementIndex + '._count')) {
                                                errorCode = "201";
                                            }
                                            subelement = subelement.concat('.' + elementIndex + '.' + elementIndexes[i + 1]);
                                            i++;
                                        } else {
                                            subelement = subelement.concat('.' + elementIndex);
                                        }
                                    }
                                    element = subelement.concat('.' + elementIndexes[elementIndexes.length - 1]);
                                }
                                //Store data
                                if (errorCode == "0") {
                                    if (scorm.autocommit && !(timeout)) {
                                        timeout = setTimeout(self.LMSCommit, 60000, [""]);
                                    }
                                    if (typeof datamodel[self.scoId][elementmodel].range != "undefined") {
                                        range = datamodel[self.scoId][elementmodel].range;
                                        ranges = range.split('#');
                                        value = value * 1.0;
                                        if ((value >= ranges[0]) && (value <= ranges[1])) {
                                            setEl(element, value);
                                            errorCode = "0";
                                            return "true";
                                        } else {
                                            errorCode = datamodel[self.scoId][elementmodel].writeerror;
                                        }
                                    } else {
                                        if (element == 'cmi.comments') {
                                            setEl('cmi.comments', getEl('cmi.comments') + value);
                                        } else {
                                            setEl(element, value);
                                        }
                                        errorCode = "0";
                                        return "true";
                                    }
                                }
                            } else {
                                errorCode = datamodel[self.scoId][elementmodel].writeerror;
                            }
                        } else {
                            errorCode = datamodel[self.scoId][elementmodel].writeerror;
                        }
                    } else {
                        errorCode = "201";
                    }
                } else {
                    errorCode = "201";
                }
            } else {
                errorCode = "301";
            }
            return "false";
        };

        self.LMSCommit = function(param) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            errorCode = "0";
            if (param == "") {
                if (initialized) {
                    result = StoreData(false);
                    // Trigger TOC update.
                    triggerEvent(mmaModScormEventUpdateToc);

                    errorCode = result ? '0' : '101';
                    return result;
                } else {
                    errorCode = "301";
                }
            } else {
                errorCode = "201";
            }
            return "false";
        };

        self.LMSGetLastError = function() {
            return errorCode;
        };

        var errorString = [];
        errorString["0"] = "No error";
        errorString["101"] = "General exception";
        errorString["201"] = "Invalid argument error";
        errorString["202"] = "Element cannot have children";
        errorString["203"] = "Element not an array - cannot have count";
        errorString["301"] = "Not initialized";
        errorString["401"] = "Not implemented error";
        errorString["402"] = "Invalid set value, element is a keyword";
        errorString["403"] = "Element is read only";
        errorString["404"] = "Element is write only";
        errorString["405"] = "Incorrect data type";

        self.LMSGetErrorString = function(param) {
            if (param != "") {
                return errorString[param];
            } else {
               return "";
            }
        };

        self.LMSGetDiagnostic = function(param) {
            if (param == "") {
                param = errorCode;
            }
            return param;
        };
    }


    /**
     * Prepare the datamodel for SCORM 1.2 populating all the required data.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormDataModel12#initAPI
     * @param  {Object} scorm    The SCORM object.
     * @param  {Number} scoId    The SCO id.
     * @param  {Number} attempt  The attempt number.
     * @param  {Object} userData The user default data.
     * @param  {String} [mode]   Mode. One of $mmaModScorm#MODE constants. By default, MODENORMAL.
     * @param  {Boolean} offline True if attempt is offline, false otherwise.
     */
    self.initAPI = function(scorm, scoId, attempt, userData, mode, offline) {
        mode = mode || $mmaModScorm.MODENORMAL;
        $window.API = new SCORMAPI(scorm, scoId, attempt, userData, mode, offline);
    };

    /**
     * Set a different SCO id for the current API object.
     * The scoId is like a pointer to be able to retrieve the SCO default values and set the new ones in the overall SCORM data structure
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormDataModel12#loadSco
     * @param  {Number} scoId The new SCO id.
     */
    self.loadSco = function(scoId) {
        $window.API.scoId = scoId;
    };

    /**
     * Set offline mode to true or false.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormDataModel12#setOffline
     * @param  {Boolean} offline True if offline, false otherwise.
     */
    self.setOffline = function(offline) {
        $window.API.offline = offline;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Mod scorm handlers.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormHandlers
 */
.factory('$mmaModScormHandlers', ["$mmCourse", "$mmaModScorm", "$mmEvents", "$state", "$mmSite", "$mmaModScormHelper", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModScormComponent", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModScorm, $mmEvents, $state, $mmSite, $mmaModScormHelper,
        $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
        mmaModScormComponent, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModScorm.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn;

                // Create the buttons without action yet. This is to prevent a glitch in the view.
                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download',
                    label: 'mm.core.download'
                };

                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true
                };

                $scope.icon = $mmCourse.getModuleIconSrc('scorm');
                $scope.title = module.name;
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = false;

                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_scorm', {module: module, courseid: courseid});
                };

                // Retrieve SCORM to calculate the rest of data.
                $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
                    var revision = scorm.sha1hash,
                        timemodified = 0;

                    function download() {
                        $mmaModScormHelper.confirmDownload(scorm).then(function() {
                            $mmaModScorm.prefetch(scorm).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmaModScormHelper.showDownloadError(scorm);
                                }
                            });
                        });
                    }

                    // Now add the action to the buttons.
                    downloadBtn.action = function(e) {
                        if (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        download();
                    };

                    refreshBtn.action = function(e) {
                        if (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        $mmaModScorm.invalidateContent(scorm.coursemodule).finally(function() {
                            download();
                        });
                    };

                    // Show buttons according to module status.
                    function showStatus(status) {
                        if (status) {
                            $scope.spinner = status === mmCoreDownloading;
                            downloadBtn.hidden = status !== mmCoreNotDownloaded;
                            refreshBtn.hidden = status !== mmCoreOutdated;
                        }
                    }

                    // Listen for changes on this module status.
                    var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                        if (data.siteid === $mmSite.getId() && data.componentId === scorm.coursemodule &&
                                data.component === mmaModScormComponent) {
                            showStatus(data.status);
                        }
                    });

                    // Get current status to decide which icon should be shown.
                    $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);

                    $scope.$on('$destroy', function() {
                        statusObserver && statusObserver.off && statusObserver.off();
                    });
                });
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModScorm.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a SCORM URL.
            if (url.indexOf('/mod/scorm/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Helper to gather some common SCORM functions.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmCourseHelper
 */
.factory('$mmaModScormHelper', ["$mmaModScorm", "$mmUtil", "$translate", "$q", "$mmaModScormOffline", "$mmaModScormSync", "$mmSite", function($mmaModScorm, $mmUtil, $translate, $q, $mmaModScormOffline, $mmaModScormSync, $mmSite) {

    var self = {},
        elementsToIgnore = ['status', 'score_raw', 'total_time', 'session_time', 'student_id', 'student_name', 'credit',
                            'mode', 'entry']; // List of elements we want to ignore when copying attempts (they're calculated).

    /**
     * Build message to show warnings.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#buildWarningsMessage
     * @param  {String[]} warnings Warnings to show.
     * @return {String}            Message with all the warnings.
     */
    self.buildWarningsMessage = function(warnings) {
        var message = '';
        angular.forEach(warnings, function(warning) {
            if (warning) {
                message = message + '<p>' + warning + '</p>';
            }
        });
        return message;
    };

    /**
     * Creates a new offline attempt based on an existing online attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#convertAttemptToOffline
     * @param  {Object} scorm   SCORM.
     * @param  {Number} attempt Number of the online attempt.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the attempt is created.
     */
    self.convertAttemptToOffline = function(scorm, attempt, siteId) {
        siteId = siteId || $mmSite.getId();

        // Get data from the online attempt.
        return $mmaModScorm.getScormUserData(scorm.id, attempt, false, siteId).then(function(onlineData) {
            // The SCORM API might have written some data to the offline attempt already.
            // We don't want to override it with cached online data.
            return $mmaModScormOffline.getScormUserData(siteId, scorm.id, attempt).catch(function() {
                // Ignore errors.
            }).then(function(offlineData) {
                var dataToStore = angular.copy(onlineData);
                // Filter the data to copy.
                angular.forEach(dataToStore, function(sco) {
                    // Delete calculated data.
                    elementsToIgnore.forEach(function(el) {
                        delete sco.userdata[el];
                    });

                    // Don't override offline data.
                    if (offlineData && offlineData[sco.scoid] && offlineData[sco.scoid].userdata) {
                        var scoUserData = {};
                        angular.forEach(sco.userdata, function(value, element) {
                            if (!offlineData[sco.scoid].userdata[element]) {
                                // This element is not stored in offline, we can save it.
                                scoUserData[element] = value;
                            }
                        });
                        sco.userdata = scoUserData;
                    }
                });

                return $mmaModScormOffline.createNewAttempt(siteId, scorm, undefined, attempt, dataToStore, onlineData);
            });
        }).catch(function() {
            // Shouldn't happen.
            return $q.reject($translate.instant('mma.mod_scorm.errorcreateofflineattempt'));
        });
    };

    /**
     * Creates a new offline attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#createOfflineAttempt
     * @param  {Object} scorm      SCORM.
     * @param  {Number} newAttempt Number of the new attempt.
     * @param  {Number} lastOnline Number of the last online attempt.
     * @param {String} [siteId]    Site ID. If not defined, current site.
     * @return {Promise}           Promise resolved when the attempt is created.
     */
    self.createOfflineAttempt = function(scorm, newAttempt, lastOnline, siteId) {
        siteId = siteId || $mmSite.getId();
        // Try to get data from online attempts.
        return self.searchOnlineAttemptUserData(scorm.id, lastOnline, siteId).then(function(userData) {
            // We're creating a new attempt, remove all the user data that is not needed for a new attempt.
            // We need to get the SCO data from here because WS get_scoes doesn't return sco_data in Moodle 3.0.
            angular.forEach(userData, function(sco) {
                var filtered = {};
                angular.forEach(sco.userdata, function(value, element) {
                    if (element.indexOf('.') == -1 && elementsToIgnore.indexOf(element) == -1) {
                        // The element doesn't use a dot notation, probably SCO data.
                        filtered[element] = value;
                    }
                });
                sco.userdata = filtered;
            });
            return $mmaModScormOffline.createNewAttempt(siteId, scorm, undefined, newAttempt, userData);
        }).catch(function() {
            return $q.reject($translate.instant('mma.mod_scorm.errorcreateofflineattempt'));
        });
    };

    /**
     * Show a confirm dialog if needed. If SCORM doesn't have size, try to calculate it.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#confirmDownload
     * @param {Object} scorm SCORM to download.
     * @return {Promise}     Promise resolved if the user confirms or no confirmation needed.
     */
    self.confirmDownload = function(scorm) {
        var promise;
        if (!scorm.packagesize) {
            // We don't have package size, try to calculate it.
            promise = $mmaModScorm.calculateScormSize(scorm).then(function(size) {
                // Store it so we don't have to calculate it again when using the same object.
                scorm.packagesize = size;
                return size;
            });
        } else {
            promise = $q.when(scorm.packagesize);
        }

        return promise.then(function(size) {
            return $mmUtil.confirmDownloadSize(size);
        });
    };

    /**
     * Determines the attempt to continue/review. It will be:
     * - The last incomplete online attempt if it hasn't been continued in offline and all offline attempts are complete.
     * - The attempt with highest number without surpassing max attempts otherwise.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#determineAttemptToContinue
     * @param  {Object} scorm    SCORM.
     * @param  {Object} attempts Result of $mmaModScorm#getAttemptCount.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with an object with 2 properties: 'number' and 'offline'.
     */
    self.determineAttemptToContinue = function(scorm, attempts, siteId) {
        siteId = siteId || $mmSite.getId();
        var lastOnline,
            result = {
                number: 0,
                offline: false
            };

        // Get the last attempt. It'll be the highest number as long as it doesn't surpass the max number of attempts.
        function getLastBeforeMax() {
            if (scorm.maxattempt != 0 && attempts.lastAttempt.number > scorm.maxattempt) {
                result.number = scorm.maxattempt;
                result.offline = attempts.offline.indexOf(scorm.maxattempt) > -1;
            } else {
                result.number = attempts.lastAttempt.number;
                result.offline = attempts.lastAttempt.offline;
            }
        }

        // Get last online attempt.
        if (attempts.online.length) {
            lastOnline = Math.max.apply(Math, attempts.online);
        }

        if (lastOnline) {
            // Check if last online incomplete.
            var hasOffline = attempts.offline.indexOf(lastOnline) > -1;
            return $mmaModScorm.isAttemptIncomplete(scorm.id, lastOnline, hasOffline, false, siteId).then(function(incomplete) {
                if (incomplete) {
                    result.number = lastOnline;
                    result.offline = hasOffline;
                } else {
                    getLastBeforeMax();
                }
                return result;
            });
        } else {
            getLastBeforeMax();
            return $q.when(result);
        }
    };

    /**
     * Get the first SCO to load in a SCORM. If a non-empty TOC is provided, it will be the first valid SCO in the TOC.
     * Otherwise, it will be the first valid SCO returned by $mmaModScorm#getScos.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getFirstSco
     * @param {String} scormId        Scorm ID.
     * @param {Object[]} [toc]        SCORM's TOC.
     * @param {String} [organization] Organization to use.
     * @param {Number} attempt        Attempt number.
     * @param {Boolean} offline       True if attempt is offline, false otherwise.
     * @param {String} [siteId]       Site ID. If not defined, current site.
     * @return {Promise}              Promise resolved with the first SCO.
     */
    self.getFirstSco = function(scormId, toc, organization, attempt, offline, siteId) {
        siteId = siteId || $mmSite.getId();
        var promise;
        if (toc && toc.length) {
            promise = $q.when(toc);
        } else {
            // SCORM doesn't have a TOC. Get all the scos.
            promise = $mmaModScorm.getScosWithData(scormId, organization, attempt, offline, false, siteId);
        }

        return promise.then(function(scos) {
            // Search the first valid SCO.
            for (var i = 0; i < scos.length; i++) {
                var sco = scos[i];
                if (sco.isvisible && sco.prereq && sco.launch) {
                    return sco;
                }
            }
        });
    };

    /**
     * Given a TOC in array format (@see $mmaModScorm#formatTocToArray) and a scoId, return the next available SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getNextScoFromToc
     * @param  {Object[]} toc SCORM's TOC.
     * @param  {Number} scoId SCO ID.
     * @return {Object}       Next SCO.
     */
    self.getNextScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                // We found the current SCO. Now let's search the next visible SCO with fulfilled prerequisites.
                for (var j = i + 1; j < len; j++) {
                    if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {
                        return toc[j];
                    }
                }
                break;
            }
        }
    };

    /**
     * Given a TOC in array format (@see $mmaModScorm#formatTocToArray) and a scoId, return the previous available SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getPreviousScoFromToc
     * @param  {Object[]} toc SCORM's TOC.
     * @param  {Number} scoId SCO ID.
     * @return {Object}       Previous SCO.
     */
    self.getPreviousScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                // We found the current SCO. Now let's search the previous visible SCO with fulfilled prerequisites.
                for (var j = i - 1; j >= 0; j--) {
                    if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {
                        return toc[j];
                    }
                }
                break;
            }
        }
    };

    /**
     * Given a TOC in array format (@see $mmaModScorm#formatTocToArray) and a scoId, return the SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getScoFromToc
     * @param  {Object[]} toc SCORM's TOC.
     * @param  {Number} scoId SCO ID.
     * @return {Object}       SCO.
     */
    self.getScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                return toc[i];
            }
        }
    };

    /**
     * Get SCORM sync time in a human readable format.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#getScormReadableSyncTime
     * @param  {Number} scormId SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the readable time.
     */
    self.getScormReadableSyncTime = function(scormId, siteId) {
        return $mmaModScormSync.getScormSyncTime(scormId, siteId).then(function(time) {
            if (time == 0) {
                return $translate('mm.core.none');
            } else {
                return moment(time).format('LLL');
            }
        });
    };

    /**
     * Searches user data for an online attempt. If the data can't be retrieved,
     * re-try with the previous online attempt (if exists).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#searchOnlineAttemptUserData
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Online attempt to get the data.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with user data.
     */
    self.searchOnlineAttemptUserData = function(scormId, attempt, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId).catch(function() {
            if (attempt > 0) {
                // We couldn't retrieve the data. Try again with the previous online attempt.
                return self.searchOnlineAttemptUserData(scormId, attempt - 1, siteId);
            } else {
                // No more attempts to try. Reject
                return $q.reject();
            }
        });
    };

    /**
     * Show error because a SCORM download failed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormHelper#showDownloadError
     * @param {Object} scorm SCORM downloaded.
     * @return {Void}
     */
    self.showDownloadError = function(scorm) {
        $translate('mma.mod_scorm.errordownloadscorm', {name: scorm.name}).then(function(message) {
            $mmUtil.showErrorModal(message);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Mod SCORM prefetch handler.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormPrefetchHandler
 */
.factory('$mmaModScormPrefetchHandler', ["$mmaModScorm", "mmaModScormComponent", function($mmaModScorm, mmaModScormComponent) {

    var self = {};

    self.component = mmaModScormComponent;

    /**
     * Get the download size of a module.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getDownloadSize
     * @param {Object} module   Module to get the size.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Promise}        Promise resolved with the size.
     */
    self.getDownloadSize = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            if ($mmaModScorm.isScormSupported(scorm) !== true) {
                return 0;
            } else if (!scorm.packagesize) {
                // We don't have package size, try to calculate it.
                return $mmaModScorm.calculateScormSize(scorm);
            } else {
                return scorm.packagesize;
            }
        });
    };

    /**
     * Get the list of downloadable files.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getFiles
     * @param {Object} module   Module to get the files.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Promise}         Size.
     */
    self.getFiles = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return $mmaModScorm.getScormFileList(scorm);
        }).catch(function() {
            // SCORM not found, return empty list.
            return [];
        });
    };

    /**
     * Get revision of a SCORM (sha1hash).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getRevision
     * @param {Object} module   Module to get the revision.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Number}         Timemodified.
     */
    self.getRevision = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return scorm.sha1hash;
        });
    };

    /**
     * Get timemodified of a SCORM. It always return 0, we don't use timemodified for SCORM packages.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#getTimemodified
     * @param {Object} module   Module to get the timemodified.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Number}         Timemodified.
     */
    self.getTimemodified = function(module, courseid) {
        return 0;
    };

    /**
     * Whether or not the module is enabled for the site.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#isEnabled
     * @return {Boolean}
     */
    self.isEnabled = function() {
        return $mmaModScorm.isPluginEnabled();
    };

    /**
     * Prefetch the module.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormPrefetchHandler#prefetch
     * @param {Object} module   The module object returned by WS.
     * @param {Number} courseid Course ID the module belongs to.
     * @return {Promise}        Promise resolved when all files have been downloaded. Data returned is not reliable.
     */
    self.prefetch = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return $mmaModScorm.prefetch(scorm);
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * SCORM service.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScorm
 */
.factory('$mmaModScorm', ["$mmSite", "$q", "$translate", "$mmLang", "$mmFilepool", "$mmFS", "$mmWS", "$sce", "$mmaModScormOnline", "$state", "$mmaModScormOffline", "$mmUtil", "$log", "$mmSitesManager", "mmaModScormComponent", "mmCoreNotDownloaded", function($mmSite, $q, $translate, $mmLang, $mmFilepool, $mmFS, $mmWS, $sce, $mmaModScormOnline, $state,
            $mmaModScormOffline, $mmUtil, $log, $mmSitesManager, mmaModScormComponent, mmCoreNotDownloaded) {
    $log = $log.getInstance('$mmaModScorm');

    var self = {},
        statuses = ['notattempted', 'passed', 'completed', 'failed', 'incomplete', 'browsed', 'suspend'],
        downloadPromises = {}; // Store download promises to be able to restore them.

    // Constants.
    self.GRADESCOES     = 0;
    self.GRADEHIGHEST   = 1;
    self.GRADEAVERAGE   = 2;
    self.GRADESUM       = 3;

    self.HIGHESTATTEMPT = 0;
    self.AVERAGEATTEMPT = 1;
    self.FIRSTATTEMPT   = 2;
    self.LASTATTEMPT    = 3;

    self.MODEBROWSE = 'browse';
    self.MODENORMAL = 'normal';
    self.MODEREVIEW = 'review';

    /**
     * Calculates the SCORM grade based on the grading method and the list of attempts scores.
     * We only treat online attempts to calculate a SCORM grade.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#calculateScormGrade
     * @param  {Object} scorm           SCORM.
     * @param  {Object} onlineAttempts  Online attempts. Each attempt must have a property called "grade".
     * @return {Number}                 Grade. -1 if no grade.
     */
    self.calculateScormGrade = function(scorm, onlineAttempts) {
        if (!onlineAttempts || !Object.keys(onlineAttempts).length) {
            return -1;
        }

        switch (scorm.whatgrade) {
            case self.FIRSTATTEMPT:
                return onlineAttempts[1] ? onlineAttempts[1].grade : -1;
            case self.LASTATTEMPT:
                var max = 0;
                angular.forEach(Object.keys(onlineAttempts), function(number) {
                    max = Math.max(number, max);
                });
                if (max > 0) {
                    return onlineAttempts[max].grade;
                }
                return -1;
            case self.HIGHESTATTEMPT:
                var grade = 0;
                angular.forEach(onlineAttempts, function(attempt) {
                    grade = Math.max(attempt.grade, grade);
                });
                return grade;
            case self.AVERAGEATTEMPT:
                var sumgrades = 0,
                    total = 0;
                angular.forEach(onlineAttempts, function(attempt) {
                    sumgrades += attempt.grade;
                    total++;
                });
                return Math.round(sumgrades / total);
        }

        return -1;
    };

    /**
     * Calculates the size of a SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#calculateScormSize
     * @param {Object} scorm SCORM.
     * @return {Promise}     Promise resolved with the SCORM size.
     */
    self.calculateScormSize = function(scorm) {
        if (scorm.packagesize) {
            return $q.when(scorm.packagesize);
        }

        return $mmWS.getRemoteFileSize(self.getPackageUrl(scorm));
    };

    /**
     * Count the attempts left for the given scorm.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#countAttemptsLeft
     * @param {Object} scorm         SCORM.
     * @param {Number} attemptsCount Number of attempts performed.
     * @return {Number}              Number of attempts left.
     */
    self.countAttemptsLeft = function(scorm, attemptsCount) {
        if (scorm.maxattempt == 0) {
            return Number.MAX_VALUE; // Unlimited attempts.
        }

        attemptsCount = parseInt(attemptsCount, 10);
        if (isNaN(attemptsCount)) {
            return -1;
        }
        return scorm.maxattempt - attemptsCount;
    };

    /**
     * Returns the mode and attempt number to use based on mode selected and SCORM data.
     * This function is based on Moodle's scorm_check_mode.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#determineAttemptAndMode
     * @param {Object} scorm       SCORM.
     * @param {String} mode        Selected mode.
     * @param {Number} attempt     Current attempt.
     * @param {Boolean} newAttempt True if should start a new attempt, false otherwise.
     * @param {Boolean} incomplete True if current attempt is incomplete, false otherwise.
     * @return {Object}            Object with properties: 'mode', 'attempt' and 'newAttempt'.
     */
    self.determineAttemptAndMode = function(scorm, mode, attempt, newAttempt, incomplete) {
        if (mode == self.MODEBROWSE) {
            if (scorm.hidebrowse) {
                // Prevent Browse mode if hidebrowse is set.
                mode = self.MODENORMAL;
            } else {
                // We don't need to check attempts as browse mode is set.
                if (attempt == 0) {
                    attempt = 1;
                    newAttempt = true;
                }

                return {
                    mode: mode,
                    attempt: attempt,
                    newAttempt: newAttempt
                };
            }
        }

        // Validate user request to start a new attempt.
        if (attempt == 0) {
            newAttempt = true;
        } else if (incomplete) {
            // The option to start a new attempt should never have been presented. Force false.
            newAttempt = false;
        } else if (scorm.forcenewattempt) {
            // A new attempt should be forced for already completed attempts.
            newAttempt = true;
        }

        if (newAttempt && (scorm.maxattempt == 0 || attempt < scorm.maxattempt)) {
            // Create a new attempt. Force mode normal.
            attempt++;
            mode = self.MODENORMAL;
        } else {
            if (incomplete) {
                // We can't review an incomplete attempt.
                mode = self.MODENORMAL;
            } else {
                // We aren't starting a new attempt and the current one is complete, force review mode.
                mode = self.MODEREVIEW;
            }
        }

        return {
            mode: mode,
            attempt: attempt,
            newAttempt: newAttempt
        };
    };

    /**
     * Check if TOC should be displayed in the player.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#displayTocInPlayer
     * @param {Object} scorm SCORM.
     * @return {Boolean}     True if should display TOC, false otherwise.
     */
    self.displayTocInPlayer = function(scorm) {
        return scorm.hidetoc !== 3;
    };

    /**
     * Download and unzips the SCORM package.
     * @see $mmaModScorm#_downloadOrPrefetch
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#download
     * @param {Object} scorm SCORM object returned by $mmaModScorm#getScorm.
     * @return {Promise}     Promise resolved when the package is downloaded and unzipped.
     */
    self.download = function(scorm) {
        return self._downloadOrPrefetch(scorm, false);
    };

    /**
     * Downloads/Prefetches and unzips the SCORM package.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#_downloadOrPrefetch
     * @param {Object} scorm     SCORM object returned by $mmaModScorm#getScorm.
     * @param {Boolean} prefetch True if prefetch, false otherwise.
     * @return {Promise}         Promise resolved when the package is downloaded and unzipped. It will call notify in these cases:
     *                                   -File download in progress. Notify object will have these properties:
     *                                       packageDownload {Boolean} Always true.
     *                                       loaded {Number} Number of bytes of the package loaded.
     *                                       fileProgress {Object} FileTransfer's notify param for the current file.
     *                                   -Download or unzip starting. Notify object will have these properties:
     *                                       message {String} Message code related to the starting operation.
     *                                   -File unzip in progress. Notify object will have these properties:
     *                                       loaded {Number} Number of bytes unzipped.
     *                                       total {Number} Total of bytes of the ZIP file.
     * @protected
     */
    self._downloadOrPrefetch = function(scorm, prefetch) {
        var result = self.isScormSupported(scorm),
            siteId = $mmSite.getId();
        if (result !== true) {
            return $mmLang.translateAndReject(result);
        }

        if (downloadPromises[siteId] && downloadPromises[siteId][scorm.id]) {
            // There's already a download ongoing for this package, return the promise.
            return downloadPromises[siteId][scorm.id];
        } else if (!downloadPromises[siteId]) {
            downloadPromises[siteId] = {};
        }

        var files = self.getScormFileList(scorm),
            revision = scorm.sha1hash, // We use sha1hash instead of revision number.
            dirPath,
            deferred = $q.defer(), // We use a deferred to be able to notify.
            fn = prefetch ? $mmFilepool.prefetchPackage : $mmFilepool.downloadPackage;

        downloadPromises[siteId][scorm.id] = deferred.promise; // Store promise to be able to restore it later.

        // Get the folder where the unzipped files will be.
        self.getScormFolder(scorm.moduleurl).then(function(path) {
            dirPath = path;
            // Download the ZIP file to the filepool.
            // Using undefined for success & fail will pass the success/failure to the parent promise.
            deferred.notify({message: 'mm.core.downloading'});
            return fn(siteId, files, mmaModScormComponent, scorm.coursemodule, revision, 0)
                                                        .then(undefined, undefined, deferred.notify);
        }).then(function() {
            // Remove the destination folder to prevent having old unused files.
            return $mmFS.removeDir(dirPath).catch(function() {
                // Ignore errors, it might have failed because the folder doesn't exist.
            });
        }).then(function() {
            // Get the ZIP file path.
            return $mmFilepool.getFilePathByUrl(siteId, self.getPackageUrl(scorm));
        }).then(function(zippath) {
            // Unzip and delete the zip when finished.
            deferred.notify({message: 'mm.core.unzipping'});
            return $mmFS.unzipFile(zippath, dirPath).then(function() {
                return $mmFilepool.removeFileByUrl(siteId, self.getPackageUrl(scorm)).catch(function() {
                    // Ignore errors.
                });
            }, function(error) {
                // Error unzipping. Set status as not downloaded and reject.
                return $mmFilepool.storePackageStatus(siteId, mmaModScormComponent, scorm.coursemodule,
                                            mmCoreNotDownloaded, revision, 0).then(function() {
                    return $q.reject(error);
                });
            }, deferred.notify);
        }).then(deferred.resolve, deferred.reject).finally(function() {
            delete downloadPromises[siteId][scorm.id]; // Delete stored promise.
        });

        return deferred.promise;
    };

    /**
     * This is a little language parser for AICC_SCRIPT.
     * Evaluates the expression and returns a boolean answer.
     * See 2.3.2.5.1. Sequencing/Navigation Today  - from the SCORM 1.2 spec (CAM).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#evalPrerequisites
     * @param  {String} prerequisites The AICC_SCRIPT prerequisites expression.
     * @param  {Object} trackData     The tracked user data of each SCO.
     * @return {Boolean}              True if prerequisites are fulfilled, false otherwise.
     */
    self.evalPrerequisites = function(prerequisites, trackData) {

        var stack = [],
            statuses = {
                'passed': 'passed',
                'completed': 'completed',
                'failed': 'failed',
                'incomplete': 'incomplete',
                'browsed': 'browsed',
                'not attempted': 'notattempted',
                'p': 'passed',
                'c': 'completed',
                'f': 'failed',
                'i': 'incomplete',
                'b': 'browsed',
                'n': 'notattempted'
            };

        // Expand the amp entities.
        prerequisites = prerequisites.replace(/&amp;/gi, '&');
        // Find all my parsable tokens.
        prerequisites = prerequisites.replace(/(&|\||\(|\)|\~)/gi, '\t$1\t');
        // Expand operators.
        prerequisites = prerequisites.replace(/&/gi, '&&');
        prerequisites = prerequisites.replace(/\|/gi, '||');
        // Now - grab all the tokens.
        var elements = prerequisites.trim().split('\t');

        // Process each token to build an expression to be evaluated.
        angular.forEach(elements, function(element) {
            element = element.trim();
            if (!element) {
                return;
            }
            if (!element.match(/^(&&|\|\||\(|\))$/gi)) {
                // Create each individual expression.
                // Search for ~ = <> X*{} .

                var re = /^(\d+)\*\{(.+)\}$/, // Sets like 3*{S34, S36, S37, S39}.
                    reOther = /^(.+)(\=|\<\>)(.+)$/, // Other symbols.
                    matches;

                if (re.test(element)) {
                    matches = element.match(re);

                    var repeat = matches[1],
                        set = matches[2].split(','),
                        count = 0;
                    angular.forEach(set, function(setelement) {
                        setelement = setelement.trim();
                        if (typeof trackData[setelement] != 'undefined' &&
                                (trackData[setelement].status == 'completed' || trackData[setelement].status == 'passed')) {
                            count++;
                        }
                    });
                    if (count >= repeat) {
                        element = 'true';
                    } else {
                        element = 'false';
                    }
                } else if (element == '~') {
                    // Not maps ~.
                    element = '!';
                } else if (reOther.test(element)) {
                    // Other symbols = | <> .
                    matches = element.match(reOther);
                    element = matches[1].trim();
                    if (typeof trackData[element] != 'undefined') {
                        value = matches[3].trim().replace(/(\'|\")/gi);
                        if (typeof statuses[value] != 'undefined') {
                            value = statuses[value];
                        }
                        if (matches[2] == '<>') {
                            oper = '!=';
                        } else {
                            oper = '==';
                        }
                        element = '(\'' + trackData[element].status + '\' ' + oper + ' \'' + value + '\')';
                    } else {
                        element = 'false';
                    }
                } else {
                    // Everything else must be an element defined like S45 ...
                    if (typeof trackData[element] != 'undefined' &&
                            (trackData[element].status == 'completed' || trackData[element].status == 'passed')) {
                        element = 'true';
                    } else {
                        element = 'false';
                    }
                }

            }
            stack.push(' ' + element + ' ');
        });

        return eval(stack.join('') + ';');
    };

    /**
     * Formats a grade to be displayed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#formatGrade
     * @param  {Object} scorm SCORM.
     * @param  {Number} grade Grade.
     * @return {String}       Grade to display.
     */
    self.formatGrade = function(scorm, grade) {
        if (typeof grade == 'undefined' || grade == -1) {
            return $translate.instant('mm.core.none');
        }
        if (scorm.grademethod !== self.GRADESCOES && scorm.maxgrade > 0) {
            grade = (grade / scorm.maxgrade) * 100;
            return $translate.instant('mm.core.percentagenumber', {$a: $mmUtil.roundToDecimals(grade, 2)});
        }
        return grade;
    };

    /**
     * Formats a tree-like TOC into an array.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#formatTocToArray
     * @param {Object[]} toc     SCORM's TOC (tree format).
     * @param {Number} [level=0] The level of the TOC we're right now. 0 by default.
     * @return {Object[]}        SCORM's TOC (array format).
     */
    self.formatTocToArray = function(toc, level) {
        if (!toc || !toc.length) {
            return [];
        }

        if (typeof level == 'undefined') {
            level = 0;
        }

        var formatted = [];
        angular.forEach(toc, function(node) {
            node.level = level;
            formatted.push(node);
            formatted = formatted.concat(self.formatTocToArray(node.children, level + 1));
        });

        return formatted;
    };

    /**
     * Get the number of attempts done by a user in the given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getAttemptCount
     * @param {Number} scormId        SCORM ID.
     * @param {String} [siteId]       Site ID. If not defined, current site.
     * @param {Number} [userId]       User ID. If not defined use site's current user.
     * @param {Boolean} ignoreMissing True if it should ignore attempts without grade/completion. Only for online attempts.
     * @param {Boolean} ignoreCache   True if it should ignore cached data for online attempts.
     * @return {Promise}              Promise resolved when the attempt count is retrieved. It returns an object with
     *                                online attempts, offline attempts, total number of attempts and last attempt.
     */
    self.getAttemptCount = function(scormId, siteId, userId, ignoreMissing, ignoreCache) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var result = {
                    lastAttempt: {
                        number: 0,
                        offline: false
                    }
                },
                promises = [];

            promises.push($mmaModScormOnline.getAttemptCount(siteId, scormId, userId, ignoreMissing, ignoreCache)
                        .then(function(count) {
                // Calculate numbers of online attempts.
                result.online = [];
                for (var i = 1; i <= count; i++) {
                    result.online.push(i);
                }
                // Calculate last attempt.
                if (count > result.lastAttempt.number) {
                    result.lastAttempt.number = count;
                    result.lastAttempt.offline = false;
                }
            }));

            promises.push($mmaModScormOffline.getAttempts(siteId, scormId, userId).then(function(attempts) {
                // Get only attempt numbers.
                result.offline = attempts.map(function(entry) {
                    // Calculate last attempt. We use >= to prioritize offline events if an attempt is both online and offline.
                    if (entry.attempt >= result.lastAttempt.number) {
                        result.lastAttempt.number = entry.attempt;
                        result.lastAttempt.offline = true;
                    }
                    return entry.attempt;
                });
            }));

            return $q.all(promises).then(function() {
                var total = result.online.length;
                result.offline.forEach(function(attempt) {
                    // Check if this attempt also exists in online, it might have been copied to local.
                    if (result.online.indexOf(attempt) == -1) {
                        total++;
                    }
                });
                result.total = total;
                return result;
            });
        });
    };

    /**
     * Get the grade for a certain SCORM and attempt.
     * Based on Moodle's scorm_grade_user_attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getAttemptGrade
     * @param {Number} scormid  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Boolean} offline True if attempt is offline, false otherwise.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the grade. If the attempt hasn't reported grade/completion, grade will be -1.
     */
    self.getAttemptGrade = function(scorm, attempt, offline, siteId) {
        var attemptscore = {
            scos: 0,
            values: 0,
            max: 0,
            sum: 0
        };

        return self.getScormUserData(scorm.id, attempt, offline, siteId).then(function(data) {
            angular.forEach(data, function(scodata) {
                var userdata = scodata.userdata;
                if (userdata.status == 'completed' || userdata.status == 'passed') {
                    attemptscore.scos++;
                }

                if (userdata.score_raw || (typeof scorm.scormtype != 'undefined' &&
                            scorm.scormtype == 'sco' && typeof userdata.score_raw != 'undefined')) {
                    var scoreraw = parseFloat(userdata.score_raw);
                    attemptscore.values++;
                    attemptscore.sum += scoreraw;
                    attemptscore.max = Math.max(scoreraw, attemptscore.max);
                }
            });

            var score = 0;
            switch (scorm.grademethod) {
                case self.GRADEHIGHEST:
                    score = attemptscore.max;
                break;
                case self.GRADEAVERAGE:
                    if (attemptscore.values > 0) {
                        score = attemptscore.sum / attemptscore.values;
                    } else {
                        score = 0;
                    }
                break;
                case self.GRADESUM:
                    score = attemptscore.sum;
                break;
                case self.GRADESCOES:
                    score = attemptscore.scos;
                break;
                default:
                    score = attemptscore.max;   // Remote Learner GRADEHIGHEST is default.
            }

            return score;
        });
    };

    /**
     * Get the list of a organizations defined in a SCORM package.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getOrganizations
     * @param  {Number} scormId SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the list of organizations.
     */
    self.getOrganizations = function(scormId, siteId) {
        return self.getScos(scormId, siteId).then(function(scos) {
            var organizations = [];
            angular.forEach(scos, function(sco) {
                // Is an organization entry?
                if (sco.organization == '' && sco.parent == '/' && sco.scormtype == '') {
                    organizations.push({
                        identifier: sco.identifier,
                        title: sco.title,
                        sortorder: sco.sortorder
                    });
                }
            });
            return organizations;
        });
    };

    /**
     * Get the organization Toc object
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getOrganizationToc
     * @param  {Number} scormId      SCORM ID.
     * @param  {String} organization Organization identifier.
     * @param  {Number} attempt      The attempt number (to populate SCO track data).
     * @param {Boolean} offline      True if attempt is offline, false otherwise.
     * @param {String} [siteId]      Site ID. If not defined, current site.
     * @return {Promise}             Promise resolved with the toc object.
     */
    self.getOrganizationToc = function(scormId, organization, attempt, offline, siteId) {

        return self.getScosWithData(scormId, organization, attempt, offline, false, siteId).then(function(scos) {
            var map = {},
                rootScos = [];

            angular.forEach(scos, function(sco, index) {
                sco.children = [];
                map[sco.identifier] = index;
                if (sco.parent !== '/') {
                    if (sco.parent == organization) {
                        // It's a root SCO, add it to the root array.
                        rootScos.push(sco);
                    } else {
                        // Add this sco to the parent.
                        scos[map[sco.parent]].children.push(sco);
                    }
                }
            });

            return rootScos;
        });
    };

    /**
     * Get the package URL of a given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getPackageUrl
     * @param  {Object} scorm SCORM.
     * @return {String}       Package URL.
     */
    self.getPackageUrl = function(scorm) {
        if (scorm.packageurl) {
            return scorm.packageurl;
        }
        if (scorm.reference) {
            return scorm.reference;
        }
        return '';
    };

    /**
     * Get the user data for a certain SCORM and attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormUserData
     * @param {Number} scormId      SCORM ID.
     * @param {Number} attempt      Attempt number.
     * @param {Boolean} offline     True if attempt is offline, false otherwise.
     * @param {String} [siteId]     Site ID. If not defined, current site.
     * @param {Object[]} [scos]     SCOs returned by $mmaModScorm#getScos. Recommended if offline=true.
     * @param {Boolean} ignoreCache True if it should ignore cached data for online attempts.
     * @return {Promise}            Promise resolved when the user data is retrieved.
     */
    self.getScormUserData = function(scormId, attempt, offline, siteId, scos, ignoreCache) {
        siteId = siteId || $mmSite.getId();
        if (offline) {
            var promise = scos ? $q.when(scos) : self.getScos(scormId, siteId);
            return promise.then(function(scos) {
                return $mmaModScormOffline.getScormUserData(siteId, scormId, attempt, undefined, scos);
            });
        } else {
            return $mmaModScormOnline.getScormUserData(siteId, scormId, attempt, ignoreCache);
        }
    };

    /**
     * Get cache key for get SCORM scos WS calls.
     *
     * @param  {Number} scormId SCORM ID.
     * @return {String}         Cache key.
     */
    function getScosCacheKey(scormId) {
        return 'mmaModScorm:scos:' + scormId;
    }

    /**
     * Retrieves the list of SCO objects for a given SCORM and organization.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScos
     * @param  {Number} scormId        SCORM ID.
     * @param  {String} [siteId]       Site ID. If not defined, current site.
     * @param  {String} [organization] Organization ID.
     * @param  {Boolean} ignoreCache   True if it should ignore cached data (it will always fail if offline or server down).
     * @return {Promise}               Promise resolved with a list of SCO objects.
     */
    self.getScos = function(scormId, siteId, organization, ignoreCache) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            organization = organization || '';

            // Don't send the organization to the WS, we'll filter them locally.
            var params = {
                    scormid: scormId
                },
                preSets = {
                    cacheKey: getScosCacheKey(scormId)
                };

            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }

            return site.read('mod_scorm_get_scorm_scoes', params, preSets).then(function(response) {
                if (response && response.scoes) {
                    var scos = [];
                    if (organization) {
                        // Filter SCOs by organization.
                        angular.forEach(response.scoes, function(sco) {
                            if (sco.organization == organization) {
                                scos.push(sco);
                            }
                        });
                    } else {
                        scos = response.scoes;
                    }
                    return scos;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Retrieves the list of SCO objects for a given SCORM and organization, including data about
     * a certain attempt (status, isvisible, ...).
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScosWithData
     * @param  {Number} scormId      SCORM ID.
     * @param  {String} organization Organization ID.
     * @param  {Number} attempt      Attempt number.
     * @param  {Boolean} offline     True if attempt is offline, false otherwise.
     * @param  {Boolean} ignoreCache True if it should ignore cached data for online attempts.
     * @param  {String} [siteId]     Site ID. If not defined, current site.
     * @return {Promise}             Promise resolved with a list of SCO objects.
     */
    self.getScosWithData = function(scormId, organization, attempt, offline, ignoreCache, siteId) {
        // Get organization SCOs.
        return self.getScos(scormId, siteId, organization, ignoreCache).then(function(scos) {
            // Get the track data for all the SCOs in the organization for the given attempt.
            // We'll use this data to set SCO data like isvisible, status and so.
            return self.getScormUserData(scormId, attempt, offline, siteId, scos, ignoreCache).then(function(data) {

                var trackDataBySCO = {};

                // First populate trackDataBySCO to index by SCO identifier.
                angular.forEach(scos, function(sco) {
                    trackDataBySCO[sco.identifier] = data[sco.id].userdata;
                });

                angular.forEach(scos, function(sco) {
                    // Add specific SCO information (related to tracked data).
                    var scodata = data[sco.id].userdata;
                    if (!scodata) {
                        return;
                    }
                    // Check isvisible attribute.
                    sco.isvisible = typeof scodata.isvisible != 'undefined' ?
                                            scodata.isvisible && scodata.isvisible !== 'false' : true;
                    // Check pre-requisites status.
                    sco.prereq = typeof scodata.prerequisites == 'undefined' ||
                                            self.evalPrerequisites(scodata.prerequisites, trackDataBySCO);
                    // Add status.
                    sco.status = (typeof scodata.status == 'undefined' || scodata.status === '') ?
                                            'notattempted' : scodata.status;
                    // Exit var.
                    sco.exitvar = typeof scodata.exitvar == 'undefined' ? 'cmi.core.exit' : scodata.exitvar;
                    sco.exitvalue = scodata[sco.exitvar];
                });

                return scos;
            });
        });
    };

    /**
     * Given a SCORM and a SCO, returns the full launch URL for the SCO.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScoSrc
     * @param  {Object} scorm   SCORM.
     * @param  {Object} sco     SCO.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the URL.
     */
    self.getScoSrc = function(scorm, sco, siteId) {
        if (sco.launch.match(/http(s)?:\/\//)) {
            // It's an online URL.
            return $q.when($sce.trustAsResourceUrl(sco.launch));
        }

        siteId = siteId || $mmSite.getId();

        return $mmFilepool.getDirectoryUrlByUrl(siteId, scorm.moduleurl).then(function(dirPath) {
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, sco.launch));
        });
    };

    /**
     * Get the path to the folder where a SCORM is downloaded.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormFolder
     * @param  {String} moduleUrl Module URL (returned by get_course_contents).
     * @param {String} [siteId]   Site ID. If not defined, current site.
     * @return {Promise}          Promise resolved with the folder path.
     */
    self.getScormFolder = function(moduleUrl, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmFilepool.getFilePathByUrl(siteId, moduleUrl);
    };

    /**
     * Gets a list of files to downlaod for a SCORM, using a format similar to module.contents from get_course_contents.
     * It will only return one file: the ZIP package.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormFileList
     * @param  {Object} scorm SCORM.
     * @return {Object[]}     File list.
     */
    self.getScormFileList = function(scorm) {
        var files = [];
        if (self.isScormSupported(scorm) === true && !scorm.warningmessage) {
            files.push({
                fileurl: self.getPackageUrl(scorm),
                filepath: '/',
                filename: scorm.reference,
                filesize: scorm.packagesize,
                type: 'file',
                timemodified: 0
            });
        }
        return files;
    };

    /**
     * Get the URL and description of the status icon.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScoStatusIcon
     * @param {Object} sco         SCO.
     * @param {Boolean} incomplete True if SCORM is incomplete, false otherwise.
     * @return {Object}            Image URL and description.
     */
    self.getScoStatusIcon = function(sco, incomplete) {
        var imagename = '',
            descname = '',
            status;

        if (sco.scormtype == 'sco') {
            // Not an asset, calculate image using status.
            status = sco.status;
            if (statuses.indexOf(status) < 0) {
                // Status empty or not valid, use 'notattempted'.
                status = 'notattempted';
            }
            if (!incomplete) {
                // Check if SCO is completed or not. If SCORM is incomplete there's no need to check SCO.
                incomplete = self.isStatusIncomplete(status);
            }

            if (incomplete && sco.exitvalue == 'suspend') {
                imagename = 'suspend';
                descname = 'suspended';
            } else {
                imagename = sco.status;
                descname = sco.status;
            }
        } else {
            imagename = 'asset';
            descname = (!sco.status || sco.status == 'notattempted') ? 'asset' : 'assetlaunched';
        }

        return {
            url: 'addons/mod_scorm/img/' + imagename + '.gif',
            description: $translate.instant('mma.mod_scorm.' + descname)
        };
    };

    /**
     * Get cache key for SCORM data WS calls.
     *
     * @param {Number} courseId Course ID.
     * @return {String}         Cache key.
     */
    function getScormDataCacheKey(courseId) {
        return 'mmaModScorm:scorm:' + courseId;
    }

    /**
     * Get a SCORM with key=value. If more than one is found, only the first will be returned.
     *
     * @param  {String} siteId    Site ID.
     * @param  {Number} courseId  Course ID.
     * @param  {String} key       Name of the property to check.
     * @param  {Mixed} value      Value to search.
     * @param  {String} moduleUrl Module URL.
     * @return {Promise}          Promise resolved when the SCORM is retrieved.
     */
    function getScorm(siteId, courseId, key, value, moduleUrl) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getScormDataCacheKey(courseId)
                };

            return site.read('mod_scorm_get_scorms_by_courses', params, preSets).then(function(response) {
                if (response && response.scorms) {
                    var currentScorm;
                    angular.forEach(response.scorms, function(scorm) {
                        if (!currentScorm && scorm[key] == value) {
                            currentScorm = scorm;
                        }
                    });
                    if (currentScorm) {
                        // If the SCORM isn't available the WS returns a warning and it doesn't return timeopen and timeclosed.
                        if (typeof currentScorm.timeopen == 'undefined') {
                            angular.forEach(response.warnings, function(warning) {
                                if (warning.itemid === currentScorm.id) {
                                    currentScorm.warningmessage = warning.message;
                                }
                            });
                        }
                        currentScorm.moduleurl = moduleUrl;
                        return currentScorm;
                    }
                }
                return $q.reject();
            });
        });
    }

    /**
     * Get a SCORM by module ID.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScorm
     * @param {Number} courseId  Course ID.
     * @param {Number} cmid      Course module ID.
     * @parma {String} moduleUrl Module URL.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when the SCORM is retrieved.
     */
    self.getScorm = function(courseId, cmid, moduleUrl, siteId) {
        siteId = siteId || $mmSite.getId();
        return getScorm(siteId, courseId, 'coursemodule', cmid, moduleUrl);
    };

    /**
     * Get a SCORM by SCORM ID.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormById
     * @param {Number} courseId  Course ID.
     * @param {Number} cmid      Course module ID.
     * @parma {String} moduleUrl Module URL.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when the SCORM is retrieved.
     */
    self.getScormById = function(courseId, id, moduleUrl, siteId) {
        siteId = siteId || $mmSite.getId();
        return getScorm(siteId, courseId, 'id', id, moduleUrl);
    };

    /**
     * Get a readable SCORM grade method.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#getScormGradingMethod
     * @param {Object} scorm SCORM.
     * @return {String}      Grading method.
     */
    self.getScormGradeMethod = function(scorm) {
        if (scorm.maxattempt == 1) {
            switch (parseInt(scorm.grademethod, 10)) {
                case self.GRADEHIGHEST:
                    return $translate.instant('mma.mod_scorm.gradehighest');
                case self.GRADEAVERAGE:
                    return $translate.instant('mma.mod_scorm.gradeaverage');
                case self.GRADESUM:
                    return $translate.instant('mma.mod_scorm.gradesum');
                case self.GRADESCOES:
                    return $translate.instant('mma.mod_scorm.gradescoes');
            }
        } else {
            switch (parseInt(scorm.whatgrade, 10)) {
                case self.HIGHESTATTEMPT:
                    return $translate.instant('mma.mod_scorm.highestattempt');
                case self.AVERAGEATTEMPT:
                    return $translate.instant('mma.mod_scorm.averageattempt');
                case self.FIRSTATTEMPT:
                    return $translate.instant('mma.mod_scorm.firstattempt');
                case self.LASTATTEMPT:
                    return $translate.instant('mma.mod_scorm.lastattempt');
            }
        }
    };

    /**
     * Invalidates all the data related to a certain SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateAllScormData
     * @param {Number} scormId  SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateAllScormData = function(scormId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        promises.push($mmaModScormOnline.invalidateAttemptCount(siteId, scormId, userId));
        promises.push(self.invalidateScos(scormId, siteId));
        promises.push($mmaModScormOnline.invalidateScormUserData(siteId, scormId));
        return $q.all(promises);
    };

    /**
     * Invalidate the prefetched content.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateContent
     * @param {Object} moduleId The module ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}
     */
    self.invalidateContent = function(moduleId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmFilepool.invalidateFilesByComponent(siteId, mmaModScormComponent, moduleId);
    };

    /**
     * Invalidates SCORM scos for all organizations.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateScos
     * @param {Number} scormId SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}       Promise resolved when the data is invalidated.
     */
    self.invalidateScos = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getScosCacheKey(scormId));
        });
    };

    /**
     * Invalidates SCORM data.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#invalidateScormData
     * @param {Number} courseId Course ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateScormData = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getScormDataCacheKey(courseId));
        });
    };

    /**
     * Check if a SCORM's attempt is incomplete.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isAttemptIncomplete
     * @param {Object} scormId      SCORM ID.
     * @param {Number} attempt      Attempt.
     * @param {Boolean} offline     True if attempt is offline, false otherwise.
     * @param {Boolean} ignoreCache True if it should ignore cached data for online attempts.
     * @param {String} [siteId]     Site ID. If not defined, current site.
     * @return {Promise}            Promise resolved with a boolean: true if incomplete, false otherwise.
     */
    self.isAttemptIncomplete = function(scormId, attempt, offline, ignoreCache, siteId) {
        return self.getScosWithData(scormId, undefined, attempt, offline, ignoreCache, siteId).then(function(scos) {
            var incomplete = false;

            angular.forEach(scos, function(sco) {
                // Ignore SCOs not visible or without launch URL.
                if (sco.isvisible && sco.launch) {
                    if (self.isStatusIncomplete(sco.status)) {
                        incomplete = true;
                    }
                }
            });

            return incomplete;
        });
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the scorm WS are available.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_scorm_get_scorm_attempt_count') &&
                    site.wsAvailable('mod_scorm_get_scorm_sco_tracks') &&
                    site.wsAvailable('mod_scorm_get_scorm_scoes') &&
                    site.wsAvailable('mod_scorm_get_scorm_user_data') &&
                    site.wsAvailable('mod_scorm_get_scorms_by_courses') &&
                    site.wsAvailable('mod_scorm_insert_scorm_tracks');
        });
    };

    /**
     * Check if a SCORM is being played right now.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormBeingPlayed
     * @param  {Number}  scormId SCORM ID.
     * @param {String} [siteId]  Site ID. If not defined, current site.
     * @return {Boolean}         True if it's being played, false otherwise.
     */
    self.isScormBeingPlayed = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSite.getId() == siteId && $state.current.name == 'site.mod_scorm-player' &&
                        $state.params.scorm && $state.params.scorm.id == scormId;
    };

    /**
     * Check if the given SCORM is closed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormClosed
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is closed, false if it hasn't closed yet.
     */
    self.isScormClosed = function(scorm) {
        var timeNow = $mmUtil.timestamp();
        if (scorm.timeclose > 0 && timeNow > scorm.timeclose) {
            return true;
        }
        return false;
    };

    /**
     * Check if the given SCORM is downloadable.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormDownloadable
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is downloadable, false otherwise.
     */
    self.isScormDownloadable = function(scorm) {
        return typeof scorm.protectpackagedownloads != 'undefined' && scorm.protectpackagedownloads === false;
    };

    /**
     * Check if the given SCORM is open.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormOpen
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is open, false if it hasn't opened yet.
     */
    self.isScormOpen = function(scorm) {
        var timeNow = $mmUtil.timestamp();
        if (scorm.timeopen > 0 && scorm.timeopen > timeNow) {
            return false;
        }
        return true;
    };

    /**
     * Check if a SCORM is supported in the app. If it's not, returns the error code to show.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormSupported
     * @param {Object} scorm    SCORM to check.
     * @return {Boolean|String} True if SCORM is supported, string with error code otherwise.
     */
    self.isScormSupported = function(scorm) {
        if (!self.isScormValidVersion(scorm)) {
            return 'mma.mod_scorm.errorinvalidversion';
        } else if (!self.isScormDownloadable(scorm)) {
            return 'mma.mod_scorm.errornotdownloadable';
        } else if (!self.isValidPackageUrl(self.getPackageUrl(scorm))) {
            return 'mma.mod_scorm.errorpackagefile';
        }

        return true;
    };

    /**
     * Check if it's a valid SCORM 1.2.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isScormValidVersion
     * @param {Object} scorm SCORM to check.
     * @return {Boolean}     True if SCORM is valid, false otherwise.
     */
    self.isScormValidVersion = function(scorm) {
        return scorm.version == 'SCORM_1.2';
    };

    /**
     * Check if a SCO status is incomplete.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isStatusIncomplete
     * @param  {String}  status SCO status.
     * @return {Boolean}        True if incomplete, false otherwise.
     */
    self.isStatusIncomplete = function(status) {
        return !status || status == 'notattempted' || status == 'incomplete' || status == 'browsed';
    };

    /**
     * Check if a package URL is valid.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#isValidPackageUrl
     * @param  {String}  packageUrl Package URL.
     * @return {Boolean}            True if valid, false otherwise.
     */
    self.isValidPackageUrl = function(packageUrl) {
        if (!packageUrl) {
            return false;
        }
        if (packageUrl.indexOf('imsmanifest.xml') > -1) {
            return false;
        }
        return true;
    };

    /**
     * Report a SCORM as being viewed.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#logView
     * @param {String} id       Module ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the WS call is successful.
     */
    self.logView = function(id, siteId) {
        siteId = siteId || $mmSite.getId();
        if (id) {
            return $mmSitesManager.getSite(siteId).then(function(site) {
                var params = {
                    scormid: id
                };
                return site.write('mod_scorm_view_scorm', params);
            });
        }
        return $q.reject();
    };

    /**
     * Report a SCO as being launched.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#logLaunchSco
     * @param {Number} scormId  SCORM ID.
     * @param {Number} scoId    SCO ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the WS call is successful.
     */
    self.logLaunchSco = function(scormId, scoId, siteId) {
        siteId = siteId || $mmSite.getId();
        var params = {
            scormid: scormId,
            scoid: scoId
        };
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.write('mod_scorm_launch_sco', params).then(function(response) {
                if (!response || !response.status) {
                    return $q.reject();
                }
            });
        });
    };

    /**
     * Prefetches and unzips the SCORM package, and also prefetches some WS calls.
     * @see $mmaModScorm#_downloadOrPrefetch
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#prefetch
     * @param {Object} scorm SCORM object returned by $mmaModScorm#getScorm.
     * @return {Promise}     Promise resolved when prefetch is done. Resolve param is a warning message (if needed).
     */
    self.prefetch = function(scorm) {
        var promises = [];

        promises.push(self.prefetchPackage(scorm));

        promises.push(self.prefetchData(scorm).catch(function() {
            // If prefetchData fails we don't want to fail the whole downloaded, so we'll ignore the error for now.
            // @todo Implement a warning system so the user knows which SCORMs have failed.
        }));

        return $q.all(promises);
    };

    /**
     * Prefetches some WS data for a SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#prefetchData
     * @param {Object} scorm    SCORM object returned by $mmaModScorm#getScorm.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the data is prefetched.
     */
    self.prefetchData = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];

        // Prefetch number of attempts (including not completed).
        promises.push($mmaModScormOnline.getAttemptCount(siteId, scorm.id).catch(function() {
            // If it fails, assume we have no attempts.
            return 0;
        }).then(function(numAttempts) {
            if (numAttempts > 0) {
                // Get user data for each attempt.
                var datapromises = [],
                    attempts = [];

                // Fill an attempts array to be able to use forEach and prevent problems with attempt variable changing.
                for (var i = 1; i <= numAttempts; i++) {
                    attempts.push(i);
                }

                attempts.forEach(function(attempt) {
                    datapromises.push($mmaModScormOnline.getScormUserData(siteId, scorm.id, attempt).catch(function(err) {
                        // Ignore failures of all the attempts that aren't the last one.
                        if (attempt == numAttempts) {
                            return $q.reject(err);
                        }
                    }));
                });

                return $q.all(datapromises);
            } else {
                // No attempts. We'll still try to get user data to be able to identify SCOs not visible and so.
                return $mmaModScormOnline.getScormUserData(siteId, scorm.id, 0);
            }
        }));

        // Prefetch SCOs.
        promises.push(self.getScos(scorm.id, siteId));

        return $q.all(promises);
    };

    /**
     * Prefetches and unzips the SCORM package.
     * @see $mmaModScorm#_downloadOrPrefetch
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#prefetchPackage
     * @param {Object} scorm SCORM object returned by $mmaModScorm#getScorm.
     * @return {Promise}     Promise resolved when the package is prefetched and unzipped.
     */
    self.prefetchPackage = function(scorm) {
        return self._downloadOrPrefetch(scorm, true);
    };

    /**
     * Saves a SCORM tracking record.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#saveTracks
     * @param  {Number} scoId      Sco ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Object[]} tracks   Tracking data to store.
     * @param  {Boolean} offline   True if attempt is offline, false otherwise.
     * @param  {Object} scorm      SCORM.
     * @param  {Object} [userData] User data for this attempt and SCO. If not defined, it will be retrieved from DB. Recommended.
     * @param  {String} [siteId]   Site ID. If not defined, current site.
     * @return {Promise}           Promise resolved when data is saved.
     */
    self.saveTracks = function(scoId, attempt, tracks, offline, scorm, userData, siteId) {
        siteId = siteId || $mmSite.getId();
        if (offline) {
            var promise = userData ? $q.when(userData) : self.getScormUserData(scorm.id, attempt, offline, siteId);
            return promise.then(function(userData) {
                return $mmaModScormOffline.saveTracks(siteId, scorm, scoId, attempt, tracks, userData);
            });
        } else {
            return $mmaModScormOnline.saveTracks(siteId, scorm.id, scoId, attempt, tracks);
        }
    };

    /**
     * Saves a SCORM tracking record using a synchronous call.
     * Please use this function only if synchronous is a must. It's recommended to use $mmaModScorm#saveTracks.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScorm#saveTracksSync
     * @param  {Number} scoId      Sco ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Object[]} tracks   Tracking data to store.
     * @param  {Boolean} offline   True if attempt is offline, false otherwise.
     * @param  {Object} [scorm]    SCORM. Required if offline=true.
     * @param  {Object} [userData] User data for this attempt and SCO. Required if offline=true.
     * @return {Boolean}           In online returns true if data is inserted, false otherwise.
     *                             In offline returns true if data to insert is valid, false otherwise. True doesn't mean that the
     *                             data has been stored, this function can return true but the insertion can still fail somehow.
     */
    self.saveTracksSync = function(scoId, attempt, tracks, offline, scorm, userData) {
        if (offline) {
            return $mmaModScormOffline.saveTracksSync(scorm, scoId, attempt, tracks, userData);
        } else {
            return $mmaModScormOnline.saveTracksSync(scoId, attempt, tracks);
        }
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

.constant('mmaModScormOfflineAttemptsStore', 'mod_scorm_offline_attempts')
.constant('mmaModScormOfflineTracksStore', 'mod_scorm_offline_scos_tracks')

.config(["$mmSitesFactoryProvider", "mmaModScormOfflineAttemptsStore", "mmaModScormOfflineTracksStore", function($mmSitesFactoryProvider, mmaModScormOfflineAttemptsStore, mmaModScormOfflineTracksStore) {
    var stores = [
        {
            name: mmaModScormOfflineAttemptsStore,
            keyPath: ['scormid', 'userid', 'attempt'],
            indexes: [
                {
                    name: 'attempt' // Attempt number.
                },
                {
                    name: 'userid'
                },
                {
                    name: 'scormid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'timemodified'
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'scormAndUser',
                    generator: function(obj) {
                        return [obj.scormid, obj.userid];
                    }
                }
            ]
        },
        {
            name: mmaModScormOfflineTracksStore,
            keyPath: ['userid', 'scormid', 'scoid', 'attempt', 'element'],
            indexes: [
                {
                    name: 'userid'
                },
                {
                    name: 'scormid'
                },
                {
                    name: 'scoid'
                },
                {
                    name: 'attempt'
                },
                {
                    name: 'element'
                },
                {
                    name: 'synced'
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'scormUserAttempt',
                    generator: function(obj) {
                        return [obj.scormid, obj.userid, obj.attempt];
                    }
                },
                {
                    // Not using compound indexes because they seem to have issues with where().
                    name: 'scormUserAttemptSynced',
                    generator: function(obj) {
                        return [obj.scormid, obj.userid, obj.attempt, obj.synced];
                    }
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * Service to handle SCORM offline features.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormOffline
 */
.factory('$mmaModScormOffline', ["$mmSite", "$mmUtil", "$q", "$log", "$mmSitesManager", "mmaModScormOfflineAttemptsStore", "mmaModScormOfflineTracksStore", function($mmSite, $mmUtil, $q, $log, $mmSitesManager, mmaModScormOfflineAttemptsStore,
            mmaModScormOfflineTracksStore) {
    $log = $log.getInstance('$mmaModScormOffline');

    var self = {},
        blockedScorms = {};

    /**
     * Changes an attempt number in the data stored in offline.
     * This function is used to convert attempts into new attempts, so the stored snapshot will be removed and
     * entries will be marked as not synced.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#changeAttemptNumber
     * @param {String} siteId     Site ID.
     * @param {Object} scormId    SCORM ID.
     * @param {Number} attempt    Number of the attempt to change.
     * @param {Number} newAttempt New attempt number.
     * @param {Number} [userId]   User ID. If not defined use site's current user.
     * @return {Promise}          Promise resolved when the attempt number changes.
     */
    self.changeAttemptNumber = function(siteId, scormId, attempt, newAttempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Change attempt number from ' + attempt + ' to ' + newAttempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            var db = site.getDb(),
                newEntry = {
                    scormid: scormId,
                    userid: userId,
                    attempt: newAttempt,
                    timemodified: $mmUtil.timestamp()
                };

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            blockedScorms[siteId][scormId] = true; // Block the SCORM so it can't be synced.

            // Get current data.
            return db.get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).then(function(entry) {
                newEntry.timecreated = entry.timecreated;
                newEntry.courseid = entry.courseid;

                // Insert new attempt.
                return db.insert(mmaModScormOfflineAttemptsStore, newEntry).then(function() {
                    // Copy tracking data to the new attempt.
                    return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                        var promises = [];
                        angular.forEach(entries, function(entry) {
                            entry.attempt = newAttempt;
                            entry.synced = 0;
                            promises.push(db.insert(mmaModScormOfflineTracksStore, entry));
                        });

                        return $mmUtil.allPromises(promises).then(function() {
                            // All entries inserted. Delete the old attempt.
                            return self.deleteAttempt(siteId, scormId, attempt).catch(function() {
                                // The delete failed, it shouldn't happen. Let's retry once.
                                return self.deleteAttempt(siteId, scormId, attempt).catch(function() {});
                            });
                        });
                    }).catch(function() {
                        // Failed to get the data, remove the new attempt.
                        return self.deleteAttempt(siteId, scormId, newAttempt).then(function() {
                            return $q.reject();
                        });
                    });
                });
            }).finally(function() {
                blockedScorms[siteId][scormId] = false; // Unblock the SCORM.
            });
        });
    };

    /**
     * Clear blocked SCORMs.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#clearBlockedScorms
     * @param {String} [siteId] If set, clear the blocked SCORMs only for this site. Otherwise clear all SCORMs.
     * @return {Void}
     */
    self.clearBlockedScorms = function(siteId) {
        if (siteId) {
            delete blockedScorms[siteId];
        } else {
            blockedScorms = {};
        }
    };

    /**
     * Creates a new offline attempt. It can be created from scratch or as a copy of another attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#createNewAttempt
     * @param {String} siteId     Site ID.
     * @param {Object} scorm      SCORM.
     * @param {Number} [userId]   User ID. If not defined use site's current user.
     * @param {Number} attempt    Number of the new attempt.
     * @param {Object} userData   User data to store in the attempt.
     * @param {Object} [snapshot] Optional. Snapshot to store in the attempt.
     * @return {Promise}          Promise resolved when the new attempt is created.
     */
    self.createNewAttempt = function(siteId, scorm, userId, attempt, userData, snapshot) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Creating new offline attempt ' + attempt + ' in SCORM ' + scorm.id);
            userId = userId || site.getUserId();

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            blockedScorms[siteId][scorm.id] = true; // Block the SCORM so it can't be synced.

            // Create attempt in DB.
            var db = site.getDb(),
                entry = {
                    scormid: scorm.id,
                    userid: userId,
                    attempt: attempt,
                    courseid: scorm.course,
                    timecreated: $mmUtil.timestamp(),
                    timemodified: $mmUtil.timestamp()
                };

            if (snapshot) {
                // Save a snapshot of the data we had when we created the attempt.
                // Remove the default data, we don't want to store it.
                entry.snapshot = removeDefaultData(snapshot);
            }

            return db.insert(mmaModScormOfflineAttemptsStore, entry).then(function() {
                // Store all the data in userData.
                var promises = [];
                angular.forEach(userData, function(sco) {
                    var tracks = [];
                    angular.forEach(sco.userdata, function(value, element) {
                        tracks.push({element: element, value: value});
                    });
                    promises.push(self.saveTracks(siteId, scorm, sco.scoid, attempt, tracks, userData));
                });
                return $q.all(promises);
            }).finally(function() {
                blockedScorms[siteId][scorm.id] = false; // Unblock the SCORM.
            });
        });
    };

    /**
     * Delete all the stored data from an attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#deleteAttempt
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when all the data has been deleted.
     */
    self.deleteAttempt = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Delete offline attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                var promises = [],
                    db = site.getDb();

                // Delete all the tracks.
                angular.forEach(entries, function(entry) {
                    var entryId = [entry.userid, entry.scormid, entry.scoid, entry.attempt, entry.element];
                    promises.push(db.remove(mmaModScormOfflineTracksStore, entryId));
                });

                // Delete the attempt.
                promises.push(db.remove(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]));

                return $q.all(promises);
            });
        });
    };

    /**
     * Helper function to return a formatted list of interactions for reports.
     * This function is based in Moodle's scorm_format_interactions.
     *
     * @param  {Object} scoUserData Userdata from a certain SCO.
     * @return {Object}             Formatted userdata.
     */
    function formatInteractions(scoUserData) {
        var formatted = {};

        // Defined in order to unify scorm1.2 and scorm2004.
        formatted.score_raw = '';
        formatted.status = '';
        formatted.total_time = '00:00:00';
        formatted.session_time = '00:00:00';

        angular.forEach(scoUserData, function(value, element) {
            // Ignore elements that are calculated.
            if (element == 'score_raw' || element == 'status' || element == 'total_time' || element == 'session_time') {
                return;
            }

            formatted[element] = value;
            switch (element) {
                case 'cmi.core.lesson_status':
                case 'cmi.completion_status':
                    if (value == 'not attempted') {
                        value = 'notattempted';
                    }
                    formatted.status = value;
                    break;
                case 'cmi.core.score.raw':
                case 'cmi.score.raw':
                    formatted.score_raw = $mmUtil.roundToDecimals(value, 2); // Round to 2 decimals max.
                    break;
                case 'cmi.core.session_time':
                case 'cmi.session_time':
                    formatted.session_time = value;
                    break;
                case 'cmi.core.total_time':
                case 'cmi.total_time':
                    formatted.total_time = value;
                    break;
            }
        });

        return formatted;
    }

    /**
     * Get launch URLs from a list of SCOs, indexing them by SCO ID.
     *
     * @param  {Object[]} scos List of SCOs. Each SCO needs to have 'id' and 'launch' properties.
     * @return {Object}        Launch URLs indexed by SCO ID.
     */
    function getLaunchUrlsFromScos(scos) {
        var response = {};
        angular.forEach(scos, function(sco) {
            response[sco.id] = sco.launch;
        });
        return response;
    }

    /**
     * Get all the offline attempts in a certain site.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAllAttempts
     * @param {String} [siteId] Site ID. If not set, use current site.
     * @return {Promise}        Promise resolved when the offline attempts are retrieved.
     */
    self.getAllAttempts = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            if (!db) {
                return $q.reject();
            }

            return db.getAll(mmaModScormOfflineAttemptsStore);
        });
    };

    /**
     * Get the offline attempts done by a user in the given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAttempts
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when the offline attempts are retrieved.
     */
    self.getAttempts = function(siteId, scormId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var db = site.getDb();
            return db.whereEqual(mmaModScormOfflineAttemptsStore, 'scormAndUser', [scormId, userId]).then(function(attempts) {
                return attempts;
            });
        });
    };

    /**
     * Get the snapshot of an attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAttemptSnapshot
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved with the snapshot or undefined if no snapshot.
     */
    self.getAttemptSnapshot = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).catch(function() {
                return {}; // Attempt not found.
            }).then(function(entry) {
                return entry.snapshot;
            });
        });
    };

    /**
     * Get the creation time of an attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getAttemptCreationTime
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved with time the attempt was created.
     */
    self.getAttemptCreationTime = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).catch(function() {
                return {}; // Attempt not found.
            }).then(function(entry) {
                return entry.timecreated;
            });
        });
    };

    /**
     * Get data stored in local DB for a certain scorm and attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getScormStoredData
     * @param {String} siteId            Site ID.
     * @param {Number} scormId           SCORM ID.
     * @param {Number} attempt           Attempt number.
     * @param {Number} [userId]          User ID. If not defined use site's current user.
     * @param {Boolean} excludeSynced    True if it should only return not synced entries.
     * @param {Boolean} excludeNotSynced True if it should only return synced entries.
     * @return {Promise}                 Promise resolved with the entries.
     */
    self.getScormStoredData = function(siteId, scormId, attempt, userId, excludeSynced, excludeNotSynced) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var where;

            if (excludeSynced && excludeNotSynced) {
                return $q.when([]);
            } else if (excludeSynced || excludeNotSynced) {
                where = ['scormUserAttemptSynced', '=', [scormId, userId, attempt, excludeNotSynced ? 1 : 0]];
            } else {
                where = ['scormUserAttempt', '=', [scormId, userId, attempt]];
            }
            return site.getDb().query(mmaModScormOfflineTracksStore, where);
        });
    };

    /**
     * Get the user data for a certain SCORM and offline attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#getScormUserData
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @param {Object[]} scos   SCOs returned by $mmaModScorm#getScos. Required.
     * @return {Promise}        Promise resolved when the user data is retrieved.
     */
    self.getScormUserData = function(siteId, scormId, attempt, userId, scos) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            // Get user data. Ordering when using a compound index is complex, so we won't order by scoid.
            return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                var response = {},
                    launchUrls = getLaunchUrlsFromScos(scos),
                    userId = site.getUserId(),
                    username = site.getInfo().username,
                    fullName = site.getInfo().fullname;

                // Gather user data retrieved from DB, grouping it by scoid.
                angular.forEach(entries, function(entry) {
                    var scoid = entry.scoid;
                    if (!response[scoid]) {
                        // Initialize SCO.
                        response[scoid] = {
                            scoid: scoid,
                            userdata: {
                                userid: userId,
                                scoid: scoid,
                                timemodified: 0
                            }
                        };
                    }
                    response[scoid].userdata[entry.element] = entry.value;
                    if (entry.timemodified > response[scoid].userdata.timemodified) {
                        response[scoid].userdata.timemodified = entry.timemodified;
                    }
                });

                // Format each user data retrieved.
                angular.forEach(response, function(sco) {
                    sco.userdata = formatInteractions(sco.userdata);
                });

                // Create empty entries for the SCOs without user data stored.
                angular.forEach(scos, function(sco) {
                    if (!response[sco.id]) {
                        response[sco.id] = {
                            scoid: sco.id,
                            userdata: {
                                status: '',
                                score_raw: ''
                            }
                        };
                    }
                });

                // Calculate defaultdata.
                angular.forEach(response, function(sco) {
                    sco.defaultdata = {};
                    sco.defaultdata['cmi.core.student_id'] = username;
                    sco.defaultdata['cmi.core.student_name'] = fullName;
                    sco.defaultdata['cmi.core.lesson_mode'] = 'normal'; // Overridden in player.
                    sco.defaultdata['cmi.core.credit'] = 'credit'; // Overridden in player.
                    if (sco.userdata.status === '') {
                        sco.defaultdata['cmi.core.entry'] = 'ab-initio';
                    } else if (sco.userdata['cmi.core.exit'] === 'suspend') {
                        sco.defaultdata['cmi.core.entry'] = 'resume';
                    } else {
                        sco.defaultdata['cmi.core.entry'] = '';
                    }
                    sco.defaultdata['cmi.student_data.mastery_score'] = scormIsset(sco.userdata, 'masteryscore');
                    sco.defaultdata['cmi.student_data.max_time_allowed'] = scormIsset(sco.userdata, 'max_time_allowed');
                    sco.defaultdata['cmi.student_data.time_limit_action'] = scormIsset(sco.userdata, 'time_limit_action');
                    sco.defaultdata['cmi.core.total_time'] = scormIsset(sco.userdata, 'cmi.core.total_time', '00:00:00');
                    sco.defaultdata['cmi.launch_data'] = launchUrls[sco.scoid];

                    // Now handle standard userdata items.
                    sco.defaultdata['cmi.core.lesson_location'] = scormIsset(sco.userdata, 'cmi.core.lesson_location');
                    sco.defaultdata['cmi.core.lesson_status'] = scormIsset(sco.userdata, 'cmi.core.lesson_status');
                    sco.defaultdata['cmi.core.score.raw'] = scormIsset(sco.userdata, 'cmi.core.score.raw');
                    sco.defaultdata['cmi.core.score.max'] = scormIsset(sco.userdata, 'cmi.core.score.max');
                    sco.defaultdata['cmi.core.score.min'] = scormIsset(sco.userdata, 'cmi.core.score.min');
                    sco.defaultdata['cmi.core.exit'] = scormIsset(sco.userdata, 'cmi.core.exit');
                    sco.defaultdata['cmi.suspend_data'] = scormIsset(sco.userdata, 'cmi.suspend_data');
                    sco.defaultdata['cmi.comments'] = scormIsset(sco.userdata, 'cmi.comments');
                    sco.defaultdata['cmi.student_preference.language'] = scormIsset(sco.userdata, 'cmi.student_preference.language');
                    sco.defaultdata['cmi.student_preference.audio'] = scormIsset(sco.userdata, 'cmi.student_preference.audio', '0');
                    sco.defaultdata['cmi.student_preference.speed'] = scormIsset(sco.userdata, 'cmi.student_preference.speed', '0');
                    sco.defaultdata['cmi.student_preference.text'] = scormIsset(sco.userdata, 'cmi.student_preference.text', '0');

                    // Some data needs to be both in default data and user data.
                    sco.userdata.student_id = username;
                    sco.userdata.student_name = fullName;
                    sco.userdata.mode = sco.defaultdata['cmi.core.lesson_mode'];
                    sco.userdata.credit = sco.defaultdata['cmi.core.credit'];
                    sco.userdata.entry = sco.defaultdata['cmi.core.entry'];
                });

                return response;
            });
        });
    };

    /**
     * Function to insert a track in the DB. Please do not use it directly, use insertTrack instead.
     *
     * @param  {Object} db           Site's DB.
     * @param  {Number} userId       User ID.
     * @param  {Number} scormId      SCORM ID.
     * @param  {Number} scoId        SCO ID.
     * @param  {Number} attempt      Attempt number.
     * @param  {String} element      Name of the element to insert.
     * @param  {Mixed} value         Value of the element to insert.
     * @param  {Boolean} synchronous True if insert should NOT return a promise. Please use it only if synchronous is a must.
     * @return {Boolean|Promise}     Returns a promise if synchronous=false, otherwise returns a boolean.
     */
    function insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, synchronous) {
        var entry = {
            userid: userId,
            scormid: scormId,
            scoid: scoId,
            attempt: attempt,
            element: element,
            value: value,
            timemodified: $mmUtil.timestamp(),
            synced: 0
        };
        if (synchronous) {
            return db.insertSync(mmaModScormOfflineTracksStore, entry);
        } else {
            return db.insert(mmaModScormOfflineTracksStore, entry);
        }
    }

    /**
     * Insert a track in the offline tracks store.
     * This function is based on Moodle's scorm_insert_track.
     *
     * @param {String} siteId           Site ID.
     * @param  {Number} [userId]        User ID. If not set use site's current user.
     * @param  {Number} scormId         SCORM ID.
     * @param  {Number} scoId           SCO ID.
     * @param  {Number} attempt         Attempt number.
     * @param  {String} element         Name of the element to insert.
     * @param  {Mixed} value            Value of the element to insert.
     * @param  {Boolean} forceCompleted True if SCORM forces completed.
     * @param  {Object} [scoData]       User data for the given SCO.
     * @return {Promise}                Promise resolved when the insert is done.
     */
    function insertTrack(siteId, userId, scormId, scoId, attempt, element, value, forceCompleted, scoData) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            scoData = scoData || {};

            var promises = [], // List of promises for actions previous to the real insert.
                lessonStatusInserted = false,
                scoUserData = scoData.userdata || {},
                db = site.getDb();

            if (forceCompleted) {
                if (element == 'cmi.core.lesson_status' && value == 'incomplete') {
                    if (scoUserData['cmi.core.score.raw']) {
                        value = 'completed';
                    }
                }
                if (element == 'cmi.core.score.raw') {
                    if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {
                        lessonStatusInserted = true;
                        promises.push(insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed'));
                    }
                }
            }

            return $q.all(promises).then(function() {
                // Don't update x.start.time, keep the original value.
                if (!scoUserData[element] || element != 'x.start.time') {

                    return insertTrackToDB(db, userId, scormId, scoId, attempt, element, value).catch(function() {
                        if (lessonStatusInserted) {
                            // Rollback previous insert.
                            return insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete')
                                    .then(function() {
                                return $q.reject();
                            });
                        }
                        return $q.reject();
                    });
                }
            });
        });
    }

    /**
     * Insert a track in the offline tracks store, returning a synchronous value.
     * Please use this function only if synchronous is a must. It's recommended to use insertTrack.
     * This function is based on Moodle's scorm_insert_track.
     *
     * @param  {Number} [userId]        User ID. If not set use current user.
     * @param  {Number} scormId         SCORM ID.
     * @param  {Number} scoId           SCO ID.
     * @param  {Number} attempt         Attempt number.
     * @param  {String} element         Name of the element to insert.
     * @param  {Mixed} value            Value of the element to insert.
     * @param  {Boolean} forceCompleted True if SCORM forces completed.
     * @param  {Object} [scoData]       User data for the given SCO.
     * @return {Promise}                Promise resolved when the insert is done.
     */
    function insertTrackSync(userId, scormId, scoId, attempt, element, value, forceCompleted, scoData) {
        userId = userId || $mmSite.getUserId();
        scoData = scoData || {};

        if (!$mmSite.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return false;
        }

        var lessonStatusInserted = false,
            scoUserData = scoData.userdata || {},
            db = $mmSite.getDb();

        if (forceCompleted) {
            if (element == 'cmi.core.lesson_status' && value == 'incomplete') {
                if (scoUserData['cmi.core.score.raw']) {
                    value = 'completed';
                }
            }
            if (element == 'cmi.core.score.raw') {
                if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {
                    lessonStatusInserted = true;
                    if (!insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed', true)) {
                        return false;
                    }
                }
            }
        }

        // Don't update x.start.time, keep the original value.
        if (!scoUserData[element] || element != 'x.start.time') {
            if (!insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, true)) {
                // Insert failed.
                if (lessonStatusInserted) {
                    // Rollback previous insert.
                    insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete', true);
                }
                return false;
            }
            return true;
        }
    }

    /**
     * Check if a SCORM is blocked by a writing function.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#isScormBlocked
     * @param  {String} siteId   Site ID.
     * @param  {Number} scormId  SCORM ID.
     * @return {Boolean}         True if blocked, false otherwise.
     */
    self.isScormBlocked = function(siteId, scormId) {
        if (!blockedScorms[siteId]) {
            return false;
        }
        return !!blockedScorms[siteId][scormId];
    };

    /**
     * Mark all the entries from a SCO and attempt as synced.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#markAsSynced
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @param {Number} scoId    SCO ID.
     * @return {Promise}        Promise resolved when marked.
     */
    self.markAsSynced = function(siteId, scormId, attempt, userId, scoId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Mark SCO ' + scoId + ' as synced for attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            return self.getScormStoredData(siteId, scormId, attempt, userId, true).then(function(entries) {
                var promises = [],
                    db = site.getDb();

                angular.forEach(entries, function(entry) {
                    if (entry.scoid == scoId) {
                        entry.synced = 1;
                        promises.push(db.insert(mmaModScormOfflineTracksStore, entry));
                    }
                });

                return $q.all(promises);
            });
        });
    };

    /**
     * Removes the default data form user data.
     *
     * @param  {Object} userData User data returned by $mmaModScorm#getScormUserData.
     * @return {Object}          User data without default data.
     */
    function removeDefaultData(userData) {
        var result = angular.copy(userData);
        angular.forEach(result, function(sco) {
            delete sco.defaultdata;
        });
        return result;
    }

    /**
     * Saves a SCORM tracking record in offline.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#saveTracks
     * @param {String} siteId      Site ID.
     * @param  {Object} scorm      SCORM.
     * @param  {Number} scoId      Sco ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Object[]} tracks   Tracking data to store.
     * @param  {Object} userData   User data for this attempt and SCO.
     * @return {Promise}           Promise resolved when data is saved.
     */
    self.saveTracks = function(siteId, scorm, scoId, attempt, tracks, userData) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var userId = site.getUserId(),
                initialBlocked;

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            initialBlocked = !!blockedScorms[siteId][scorm.id]; // Save initial blocked state.
            blockedScorms[siteId][scorm.id] = true; // Block the SCORM so it can't be synced.

            // Insert all the tracks.
            var promises = [];
            angular.forEach(tracks, function(track) {
                promises.push(insertTrack(siteId, userId, scorm.id, scoId, attempt,
                                            track.element, track.value, scorm.forcecompleted, userData[scoId]));
            });
            return $q.all(promises).finally(function() {
                if (!initialBlocked) {
                    blockedScorms[siteId][scorm.id] = false; // Unblock the SCORM only if it wasn't blocked by another function.
                }
            });
        });
    };

    /**
     * Saves a SCORM tracking record in offline returning a synchronous value.
     * Please use this function only if synchronous is a must. It's recommended to use $mmaModScormOffline#saveTracks.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#saveTracksSync
     * @param  {Object} scorm    SCORM.
     * @param  {Number} scoId    Sco ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {Object[]} tracks Tracking data to store.
     * @param  {Object} userData User data for this attempt and SCO.
     * @return {Boolean}         True if data to insert is valid, false otherwise. Returning true doesn't mean that the data
     *                           has been stored, this function can return true but the insertion can still fail somehow.
     */
    self.saveTracksSync = function(scorm, scoId, attempt, tracks, userData) {
        var userId = $mmSite.getUserId(),
            success = true;

        angular.forEach(tracks, function(track) {
            if (!insertTrackSync(userId, scorm.id, scoId, attempt, track.element, track.value,
                                    scorm.forcecompleted, userData[scoId])) {
                success = false;
            }
        });
        return success;
    };

    /**
     * Check for a parameter in userdata and return it if it's set or return 'ifempty' if it's empty.
     * Based on Moodle's scorm_isset function.
     *
     * @param  {Object} userdata  Contains user's data.
     * @param  {String} param     Name of parameter that should be checked.
     * @param  {Mixed}  [ifempty] Value to be replaced with if param is not set.
     * @return {Mixed}            Value from userdata[param] if set, ifempty otherwise.
     */
    function scormIsset(userdata, param, ifempty) {
        if (typeof ifempty == 'undefined') {
            ifempty = '';
        }

        if (typeof userdata[param] != 'undefined') {
            return userdata[param];
        }
        return ifempty;
    }

    /**
     * Set an attempt's snapshot.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOffline#setAttemptSnapshot
     * @param {String} siteId      Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} attempt  Attempt number.
     * @param {Object} userData User data to store as snapshot.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when snapshot has been stored.
     */
    self.setAttemptSnapshot = function(siteId, scormId, attempt, userData, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Set snapshot for attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();

            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).then(function(entry) {
                entry.snapshot = removeDefaultData(userData);
                entry.timemodified = $mmUtil.timestamp();
                return site.getDb().insert(mmaModScormOfflineAttemptsStore, entry);
            });
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

/**
 * Service to handle SCORM online features.
 * This service holds getters and setters that have some kind of equivalent feature in $mmaModScormOffline.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormOnline
 */
.factory('$mmaModScormOnline', ["$mmSitesManager", "$mmSite", "$q", "$mmWS", "$log", "mmCoreWSPrefix", function($mmSitesManager, $mmSite, $q, $mmWS, $log, mmCoreWSPrefix) {
    $log = $log.getInstance('$mmaModScormOnline');

    var self = {},
        blockedScorms = {};

    /**
     * Clear blocked SCORMs.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#clearBlockedScorms
     * @param {String} [siteId] If set, clear the blocked SCORMs only for this site. Otherwise clear all SCORMs.
     * @return {Void}
     */
    self.clearBlockedScorms = function(siteId) {
        if (siteId) {
            delete blockedScorms[siteId];
        } else {
            blockedScorms = {};
        }
    };

    /**
     * Get cache key for SCORM attempt count WS calls.
     *
     * @param {Number} scormId  SCORM ID.
     * @param {Number} [userId] User ID. If not defined, current user.
     * @return {String}         Cache key.
     */
    function getAttemptCountCacheKey(scormId, userId) {
        userId = userId || $mmSite.getUserId();
        return 'mmaModScorm:attemptcount:' + scormId + ':' + userId;
    }

    /**
     * Get the number of attempts done by a user in the given SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#getAttemptCount
     * @param {String} siteId         Site ID.
     * @param {Number} scormId        SCORM ID.
     * @param {Number} [userId]       User ID. If not defined use site's current user.
     * @param {Boolean} ignoreMissing True if it should ignore attempts that haven't reported a grade/completion.
     * @param {Boolean} ignoreCache   True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise}              Promise resolved when the attempt count is retrieved.
     */
    self.getAttemptCount = function(siteId, scormId, userId, ignoreMissing, ignoreCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();

            var params = {
                    scormid: scormId,
                    userid: userId,
                    ignoremissingcompletion: ignoreMissing ? 1 : 0
                },
                preSets = {
                    cacheKey: getAttemptCountCacheKey(scormId, userId)
                };

            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }

            return site.read('mod_scorm_get_scorm_attempt_count', params, preSets).then(function(response) {
                if (response && typeof response.attemptscount != 'undefined') {
                    return response.attemptscount;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Get cache key for SCORM user data WS calls.
     *
     * @param {Number} scormId SCORM ID.
     * @param {Number} attempt Attempt number.
     * @return {String}        Cache key.
     */
    function getScormUserDataCacheKey(scormId, attempt) {
        return getScormUserDataCommonCacheKey(scormId) + ':' + attempt;
    }

    /**
     * Get common cache key for SCORM user data WS calls.
     *
     * @param {Number} scormId SCORM ID.
     * @return {String}        Cache key.
     */
    function getScormUserDataCommonCacheKey(scormId) {
        return 'mmaModScorm:userdata:' + scormId;
    }

    /**
     * Get the user data for a certain SCORM and attempt.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#getScormUserData
     * @param {String} siteId       Site ID.
     * @param {Number} scormId      SCORM ID.
     * @param {Number} attempt      Attempt number.
     * @param {Boolean} ignoreCache True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise}            Promise resolved when the user data is retrieved.
     */
    self.getScormUserData = function(siteId, scormId, attempt, ignoreCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    scormid: scormId,
                    attempt: attempt
                },
                preSets = {
                    cacheKey: getScormUserDataCacheKey(scormId, attempt)
                };

            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }

            return site.read('mod_scorm_get_scorm_user_data', params, preSets).then(function(response) {
                if (response && response.data) {
                    // Format the response.
                    var data = {};
                    angular.forEach(response.data, function(sco) {
                        var formattedDefaultData = {},
                            formattedUserData = {};

                        angular.forEach(sco.defaultdata, function(entry) {
                            formattedDefaultData[entry.element] = entry.value;
                        });
                        angular.forEach(sco.userdata, function(entry) {
                            formattedUserData[entry.element] = entry.value;
                        });

                        sco.defaultdata = formattedDefaultData;
                        sco.userdata = formattedUserData;

                        data[sco.scoid] = sco;
                    });
                    return data;
                }
                return $q.reject();
            });
        });
    };

    /**
     * Invalidates attempt count.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#invalidateAttemptCount
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @param {Number} [userId] User ID. If not defined use site's current user.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateAttemptCount = function(siteId, scormId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(getAttemptCountCacheKey(scormId, userId));
        });
    };

    /**
     * Invalidates SCORM user data for all attempts.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#invalidateScormUserData
     * @param {String} siteId   Site ID.
     * @param {Number} scormId  SCORM ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateScormUserData = function(siteId, scormId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getScormUserDataCommonCacheKey(scormId));
        });
    };

    /**
     * Check if a SCORM is blocked by a writing function.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#isScormBlocked
     * @param  {String} siteId   Site ID. If not set, use current site.
     * @param  {Number} scormId  SCORM ID.
     * @return {Boolean}         True if blocked, false otherwise.
     */
    self.isScormBlocked = function(siteId, scormId) {
        if (!blockedScorms[siteId]) {
            return false;
        }
        return !!blockedScorms[siteId][scormId];
    };

    /**
     * Saves a SCORM tracking record.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#saveTracks
     * @param  {String} siteId   Site ID. If not set, use current site.
     * @param  {Number} scormId  SCORM ID.
     * @param  {Number} scoId    Sco ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {Object[]} tracks Tracking data.
     * @return {Promise}         Promise resolved when data is saved.
     */
    self.saveTracks = function(siteId, scormId, scoId, attempt, tracks) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                scoid: scoId,
                attempt: attempt,
                tracks: tracks
            };

            if (!tracks || !tracks.length) {
                return $q.when(); // Nothing to save.
            }

            if (!blockedScorms[siteId]) {
                blockedScorms[siteId] = {};
            }
            blockedScorms[siteId][scormId] = true;

            return site.write('mod_scorm_insert_scorm_tracks', params).then(function(response) {
                if (response && response.trackids) {
                    return response.trackids;
                }
                return $q.reject();
            }).finally(function() {
                blockedScorms[siteId][scormId] = false;
            });
        });
    };

    /**
     * Saves a SCORM tracking record using a synchronous call.
     * Please use this function only if synchronous is a must. It's recommended to use $mmaModScorm#saveTracks.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormOnline#saveTracksSync
     * @param  {Number} scoId    Sco ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {Object[]} tracks Tracking data.
     * @return {Boolean}         True if success, false otherwise.
     */
    self.saveTracksSync = function(scoId, attempt, tracks) {
        var params = {
                scoid: scoId,
                attempt: attempt,
                tracks: tracks
            },
            preSets = {
                siteurl: $mmSite.getURL(),
                wstoken: $mmSite.getToken()
            },
            wsFunction = $mmSite.getCompatibleFunction('mod_scorm_insert_scorm_tracks'),
            response;

        if (!tracks || !tracks.length) {
            return true; // Nothing to save.
        }

        // Check if the method is available, use a prefixed version if possible.
        if (!$mmSite.wsAvailable(wsFunction, false)) {
            if ($mmSite.wsAvailable(mmCoreWSPrefix + wsFunction, false)) {
                wsFunction = mmCoreWSPrefix + wsFunction;
            } else {
                $log.error("WS function '" + wsFunction + "' is not available, even in compatibility mode.");
                return false;
            }
        }

        response = $mmWS.syncCall(wsFunction, params, preSets);
        if (response && !response.error && response.trackids) {
            return true;
        }
        return false;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_scorm')

.constant('mmaModScormSynchronizationStore', 'mod_scorm_sync')

.config(["$mmSitesFactoryProvider", "mmaModScormSynchronizationStore", function($mmSitesFactoryProvider, mmaModScormSynchronizationStore) {
    var stores = [
        {
            name: mmaModScormSynchronizationStore,
            keyPath: 'scormid',
            indexes: []
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])

/**
 * SCORM synchronization service.
 *
 * @module mm.addons.mod_scorm
 * @ngdoc service
 * @name $mmaModScormSync
 */
.factory('$mmaModScormSync', ["$mmaModScorm", "$mmSite", "$q", "$translate", "$mmaModScormOnline", "$mmaModScormOffline", "$mmUtil", "$log", "mmaModScormSynchronizationStore", "mmaModScormSyncTime", "$mmConfig", "mmCoreSettingsSyncOnlyOnWifi", "$mmApp", "$mmEvents", "mmaModScormEventAutomSynced", "$mmSitesManager", function($mmaModScorm, $mmSite, $q, $translate, $mmaModScormOnline, $mmaModScormOffline, $mmUtil,
            $log, mmaModScormSynchronizationStore, mmaModScormSyncTime, $mmConfig, mmCoreSettingsSyncOnlyOnWifi, $mmApp,
            $mmEvents, mmaModScormEventAutomSynced, $mmSitesManager) {
    $log = $log.getInstance('$mmaModScormSync');

    var self = {},
        syncPromises = {}; // Store sync promises.

    /**
     * Get the synchronization time of a SCORM. Returns 0 if no time stored.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#getScormSyncTime
     * @param {Number} scormId  SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with the time.
     */
    self.getScormSyncTime = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            return db.get(mmaModScormSynchronizationStore, scormId).then(function(entry) {
                return entry.time;
            }).catch(function() {
                return 0;
            });
        });
    };

    /**
     * Set the synchronization time of a SCORM.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#setScormSyncTime
     * @param {Number} scormId  SCORM ID.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @param {Number} [time]   Time to set. If not defined, current time.
     * @return {Promise}        Promise resolved when the time is set.
     */
    self.setScormSyncTime = function(scormId, siteId, time) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            if (typeof time == 'undefined') {
                time = new Date().getTime();
            }
            return db.insert(mmaModScormSynchronizationStore, {scormid: scormId, time: time});
        });
    };

    /**
     * Try to synchronize all SCORMs from current site that need it and haven't been synchronized in a while.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#syncAllScorms
     * @param {String} [siteId] Site ID to sync. If not defined, sync all sites.
     * @return {Promise}        Promise resolved when the sync is done.
     */
    self.syncAllScorms = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all SCORMs because device is offline.');
            return $q.reject();
        }

        // We first check sync settings and current connection to see if we can sync.
        return $mmConfig.get(mmCoreSettingsSyncOnlyOnWifi, true).then(function(syncOnlyOnWifi) {

            if (syncOnlyOnWifi && $mmApp.isNetworkAccessLimited()) {
                $log.debug('Cannot sync all SCORMs because device isn\'t using a WiFi network.');
                return $q.reject();
            }

            var promise;
            if (!siteId) {
                // No site ID defined, sync all sites.
                $log.debug('Try to sync SCORMs in all sites.');
                promise = $mmSitesManager.getSitesIds();
            } else {
                $log.debug('Try to sync SCORMs in site ' + siteId);
                promise = $q.when([siteId]);
            }

            return promise.then(function(siteIds) {
                var sitePromises = [];

                angular.forEach(siteIds, function(siteId) {
                    sitePromises.push($mmaModScormOffline.getAllAttempts(siteId).then(function(attempts) {
                        var scorms = [],
                            ids = [], // To prevent duplicates.
                            promises = [];

                        // Get the IDs of all the SCORMs that have something to be synced.
                        angular.forEach(attempts, function(attempt) {
                            if (ids.indexOf(attempt.scormid) == -1) {
                                ids.push(attempt.scormid);
                                scorms.push({
                                    id: attempt.scormid,
                                    courseid: attempt.courseid
                                });
                            }
                        });

                        // Sync all SCORMs that haven't been synced for a while and that aren't played right now.
                        angular.forEach(scorms, function(scorm) {
                            if (!$mmaModScorm.isScormBeingPlayed(scorm.id, siteId)) {
                                promises.push($mmaModScorm.getScormById(scorm.courseid, scorm.id, '', siteId).then(function(scorm) {
                                    return self.syncScormIfNeeded(scorm, siteId).then(function(warnings) {
                                        if (typeof warnings != 'undefined') {
                                            // We tried to sync. Send event.
                                            $mmEvents.trigger(mmaModScormEventAutomSynced, {
                                                siteid: siteId,
                                                scormid: scorm.id
                                            });
                                        }
                                    });
                                }));
                            }
                        });

                        return $q.all(promises);
                    }));
                });

                return $q.all(sitePromises);
            });
        });
    };

    /**
     * Send data from a SCORM offline attempt to the site.
     * Reserved for core use, please use $mmaModScormSync#syncScorm to synchronize SCORM data.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#_syncAttempt
     * @param  {Number} scormId  SCORM ID.
     * @param  {Number} attempt  Attempt number.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when the attempt is successfully synced.
     * @protected
     */
    self._syncAttempt = function(scormId, attempt, siteId) {
        siteId = siteId || $mmSite.getId();
        $log.debug('Try to sync attempt ' + attempt + ' in SCORM ' + scormId + ' and site ' + siteId);
        // Get only not synced entries.
        return $mmaModScormOffline.getScormStoredData(siteId, scormId, attempt, undefined, true).then(function(entries) {
            var scos = {},
                promises = [],
                somethingSynced = false;

            // Get data to send (only elements with dots like cmi.core.exit, in Mobile we store more data to make offline work).
            angular.forEach(entries, function(entry) {
                if (entry.element.indexOf('.') > -1) {
                    if (!scos[entry.scoid]) {
                        scos[entry.scoid] = [];
                    }
                    scos[entry.scoid].push({
                        element: entry.element,
                        value: entry.value
                    });
                }
            });

            angular.forEach(scos, function(tracks, scoId) {
                promises.push($mmaModScormOnline.saveTracks(siteId, scormId, scoId, attempt, tracks).then(function() {
                    // Sco data successfully sent. Mark them as synced. This is needed because some SCOs sync might fail.
                    return $mmaModScormOffline.markAsSynced(siteId, scormId, attempt, undefined, scoId).catch(function() {
                        // Ignore errors.
                    }).then(function() {
                        somethingSynced = true;
                    });
                }));
            });

            return $mmUtil.allPromises(promises).then(function() {
                // Attempt has been sent. Let's delete it from local.
                return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                    // Failed to delete (shouldn't happen). Let's retry once.
                    return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                        // Maybe there's something wrong with the data or the storage implementation.
                        $log.error('After sync: error deleting attempt ' + attempt + ' in SCORM ' + scormId);
                    });
                });
            }).catch(function() {
                if (somethingSynced) {
                    // Some SCOs have been synced and some not. We'll try to store a snapshot of the current state
                    // to be able to re-try the synchronization later.
                    $log.error('Error synchronizing some SCOs for attempt ' + attempt + ' in SCORM ' + scormId + '. Saving snapshot.');
                    return saveSyncSnapshot(scormId, attempt, siteId).then(function() {
                        return $q.reject();
                    });
                } else {
                    $log.error('Error synchronizing attempt ' + attempt + ' in SCORM ' + scormId);
                }
                return $q.reject();
            });
        });
    };

    /**
     * Save a snapshot from a synchronization.
     *
     * @param  {Number} scormId SCORM ID.
     * @param  {Number} attempt Attemot number.
     * @param  {String} siteId  Site ID.
     * @return {Promise}        Promise resolved when the snapshot is stored.
     */
    function saveSyncSnapshot(scormId, attempt, siteId) {
        // Try to get current state from Moodle.
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, true).then(function(data) {
            return $mmaModScormOffline.setAttemptSnapshot(siteId, scormId, attempt, data);
        }, function() {
            // Error getting user data from Moodle. We'll have to build it ourselves.
            // Let's try to get cached data about the attempt.
            return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId).catch(function() {
                // No cached data, Moodle has no data stored.
                return {};
            }).then(function(data) {
                // We need to add the synced data to the snapshot.
                return $mmaModScormOffline.getScormStoredData(siteId, scormId, attempt, undefined, false, true)
                            .then(function(synced) {
                    angular.forEach(synced, function(entry) {
                        if (!data[entry.scoid]) {
                            data[entry.scoid] = {
                                scoid: entry.scoid,
                                userdata: {}
                            };
                        }
                        data[entry.scoid].userdata[entry.element] = entry.value;
                    });
                    return $mmaModScormOffline.setAttemptSnapshot(siteId, scormId, attempt, data);
                });
            });
        });
    }

    /**
     * Sync a SCORM only if a certain time has passed since the last time.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#syncScormIfNeeded
     * @param {Object} scorm    SCORM downloaded.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the SCORM is synced or if it doesn't need to be synced.
     */
    self.syncScormIfNeeded = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.getScormSyncTime(scorm.id, siteId).then(function(time) {
            if (new Date().getTime() - mmaModScormSyncTime >= time) {
                return self.syncScorm(scorm, siteId);
            }
        });
    };

    /**
     * Try to synchronize a SCORM's attempts.
     * The promise returned will be resolved with an array with warnings if the synchronization is successful. A successful
     * synchronization doesn't mean that all the data has been sent to the site, it's possible that some attempt can't be sent.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#syncScorm
     * @param  {Object} scorm   SCORM to sync.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved with warnings in success, rejected if synchronization fails.
     */
    self.syncScorm = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        var warnings = [],
            syncPromise,
            deleted = false;

        if (syncPromises[siteId] && syncPromises[siteId][scorm.id]) {
            // There's already a sync ongoing for this SCORM, return the promise.
            return syncPromises[siteId][scorm.id];
        } else if (!syncPromises[siteId]) {
            syncPromises[siteId] = {};
        }

        if ($mmaModScormOnline.isScormBlocked(siteId, scorm.id) || $mmaModScormOffline.isScormBlocked(siteId, scorm.id)) {
            $log.debug('Cannot sync SCORM ' + scorm.id + ' because it is blocked.');
            return $q.reject();
        }

        $log.debug('Try to sync SCORM ' + scorm.id + ' in site ' + siteId);

        // Prefetches data , set sync time and return warnings.
        function finishSync() {
            return $mmaModScorm.invalidateAllScormData(scorm.id, siteId).catch(function() {}).then(function() {
                return $mmaModScorm.prefetchData(scorm, siteId).then(function() {
                    return self.setScormSyncTime(scorm.id, siteId).catch(function() {
                        // Ignore errors.
                    }).then(function() {
                        return warnings; // No offline attempts, nothing to sync.
                    });
                });
            });
        }

        // Get attempts data. We ignore cache for online attempts, so this call will fail if offline or server down.
        syncPromise = $mmaModScorm.getAttemptCount(scorm.id, siteId, undefined, false, true).then(function(attemptsData) {
            if (!attemptsData.offline || !attemptsData.offline.length) {
                return finishSync();
            }

            var collisions = [],
                lastOnline = 0,
                promise;

            // Check if there are collisions between offline and online attempts (same number).
            angular.forEach(attemptsData.online, function(attempt) {
                lastOnline = Math.max(lastOnline, attempt);
                if (attemptsData.offline.indexOf(attempt) > -1) {
                    collisions.push(attempt);
                }
            });

            // Check if last online attempt is finished. Ignore cache.
            promise = lastOnline > 0 ? $mmaModScorm.isAttemptIncomplete(scorm.id, lastOnline, false, true, siteId) : $q.when(false);

            return promise.then(function(incomplete) {
                if (!collisions.length && !incomplete) {
                    // No collisions and last attempt is complete. Send offline attempts to Moodle.
                    var promises = [];
                    angular.forEach(attemptsData.offline, function(attempt) {
                        if (scorm.maxattempt == 0 || attempt <= scorm.maxattempt) {
                            promises.push(self._syncAttempt(scorm.id, attempt, siteId));
                        }
                    });
                    return $q.all(promises).then(function() {
                        return finishSync();
                    });

                } else if (collisions.length) {
                    // We have collisions, treat them.
                    return treatCollisions(scorm.id, siteId, collisions, lastOnline, attemptsData.offline).then(function(warns) {
                        warnings = warnings.concat(warns);

                        // The offline attempts might have changed since some collisions can be converted to new attempts.
                        return $mmaModScormOffline.getAttempts(siteId, scorm.id).then(function(entries) {
                            var promises = [],
                                cannotSyncSome = false;

                            entries = entries.map(function(entry) {
                                return entry.attempt; // Get only the attempt number.
                            });
                            if (incomplete && entries.indexOf(lastOnline) > -1) {
                                // Last online was incomplete, but it was continued in offline.
                                incomplete = false;
                            }

                            angular.forEach(entries, function(attempt) {
                                // We'll always sync attempts previous to lastOnline (failed sync or continued in offline).
                                // We'll only sync new attemps if last online attempt is completed.
                                if (!incomplete || attempt <= lastOnline) {
                                    if (scorm.maxattempt == 0 || attempt <= scorm.maxattempt) {
                                        promises.push(self._syncAttempt(scorm.id, attempt, siteId));
                                    }
                                } else {
                                    cannotSyncSome = true;
                                }
                            });
                            return $q.all(promises).then(function() {
                                if (cannotSyncSome) {
                                    warnings.push($translate.instant('mma.mod_scorm.warningsynconlineincomplete'));
                                }
                                return finishSync();
                            });
                        });
                    });
                } else {
                    // No collisions, but last online attempt is incomplete so we can't send offline attempts.
                    warnings.push($translate.instant('mma.mod_scorm.warningsynconlineincomplete'));
                    return finishSync();
                }
            });
        }).finally(function() {
            deleted = true;
            delete syncPromises[siteId][scorm.id];
        });

        if (!deleted) {
            syncPromises[siteId][scorm.id] = syncPromise;
        }
        return syncPromise;
    };

    /**
     * Treat collisions found in a SCORM synchronization process.
     *
     * @param  {Number} scormId           SCORM ID.
     * @param  {String} siteId            Site ID.
     * @param  {Number[]} collisions      Numbers of attempts that exist both in online and offline.
     * @param  {Number} lastOnline        Last online attempt.
     * @param  {Number[]} offlineAttempts Numbers of offline attempts.
     * @return {Promise}                  Promise resolved when the collisions have been treated. It returns warnings array.
     * @description
     *
     * Treat collisions found in a SCORM synchronization process. A collision is when an attempt exists both in offline
     * and online. A collision can be:
     *
     * - Two different attempts.
     * - An online attempt continued in offline.
     * - A failure in a previous sync.
     *
     * This function will move into new attempts the collisions that can't be merged. It will usually keep the order of the
     * offline attempts EXCEPT if the offline attempt was created after the last offline attempt (edge case).
     *
     * Edge case: A user creates offline attempts and when he syncs we retrieve an incomplete online attempt, so the offline
     * attempts cannot be synced. Then the user continues that online attempt and goes offline, so a collision is created.
     * When we perform the next sync we detect that this collision cannot be merged, so this offline attempt needs to be
     * created as a new attempt. Since this attempt was created after the last offline attempt, it will be added ot the end
     * of the list if the last attempt is completed. If the last attempt is not completed then the offline data will de deleted
     * because we can't create a new attempt.
     */
    function treatCollisions(scormId, siteId, collisions, lastOnline, offlineAttempts) {
        var warnings = [],
            promises = [],
            newAttemptsSameOrder = [], // Attempts that will be created as new attempts but keeping the current order.
            newAttemptsAtEnd = {}, // Attempts that will be created at the end of the list of attempts (should be max 1 attempt).
            lastCollision = Math.max.apply(Math, collisions),
            lastOffline = Math.max.apply(Math, offlineAttempts),
            lastOfflineIncomplete,
            lastOfflineCreated;

        // Get the creation time and the status (complete/incomplete) of the last offline attempt.
        function getLastOfflineAttemptData() {
            // Check if last offline attempt is incomplete.
            return $mmaModScorm.isAttemptIncomplete(scormId, lastOffline, true, false, siteId).then(function(incomplete) {
                lastOfflineIncomplete = incomplete;
                return $mmaModScormOffline.getAttemptCreationTime(siteId, scormId, lastOffline).then(function(time) {
                    lastOfflineCreated = time;
                });
            });
        }

        // Add an attempt to the right new attempts array if possible.
        // If the attempt cannot be created as a new attempt then it will be deleted.
        function addToNewOrDelete(attempt) {
            if (attempt == lastOffline) {
                newAttemptsSameOrder.push(attempt);
                return $q.when();
            }

            return $mmaModScormOffline.getAttemptCreationTime(siteId, scormId, attempt).then(function(time) {
                if (time > lastOfflineCreated) {
                    // This attempt was created after the last offline attempt, we'll add it to the end of the list if possible.
                    if (lastOfflineIncomplete) {
                        // It can't be added because the last offline attempt is incomplete, delete it.
                        $log.debug('Try to delete attempt ' + attempt + ' because it cannot be created as a new attempt.');
                        return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).then(function() {
                            warnings.push($translate.instant('mma.mod_scorm.warningofflinedatadeleted', {number: attempt}));
                        }).catch(function() {
                            // Maybe there's something wrong with the data or the storage implementation.
                        });
                    } else {
                        newAttemptsAtEnd[time] = attempt;
                    }

                } else {
                    newAttemptsSameOrder.push(attempt);
                }
            });
        }

        // Get needed data from the last offline attempt.
        return getLastOfflineAttemptData().then(function() {

            collisions.forEach(function(attempt) {
                // First get synced entries to detect if it was a failed synchronization.
                var getDataFn = $mmaModScormOffline.getScormStoredData,
                    promise = getDataFn(siteId, scormId, attempt, undefined, false, true).then(function(synced) {
                    if (synced && synced.length) {
                        // The attempt has synced entries, it seems to be a failed synchronization.
                        // Let's get the entries that haven't been synced, maybe it just failed to delete the attempt.
                        return getDataFn(siteId, scormId, attempt, undefined, true).then(function(entries) {
                            var hasDataToSend = false;
                            angular.forEach(entries, function(entry) {
                                if (entry.element.indexOf('.') > -1) {
                                    hasDataToSend = true;
                                }
                            });

                            if (hasDataToSend) {
                                // There are elements to sync. We need to check if it's possible to sync them or not.
                                return canRetrySync(scormId, siteId, attempt, lastOnline).catch(function() {
                                    // Cannot retry sync, we'll create a new offline attempt if possible.
                                    return addToNewOrDelete(attempt);
                                });
                            } else {
                                // Nothing to sync, delete the attempt.
                                return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                                    // Maybe there's something wrong with the data or the storage implementation.
                                });
                            }
                        });
                    } else {
                        // It's not a failed synchronization. Check if it's an attempt continued in offline.
                        return $mmaModScormOffline.getAttemptSnapshot(siteId, scormId, attempt).then(function(snapshot) {
                            if (snapshot && Object.keys(snapshot).length) {
                                // It has a snapshot, it means it continued an online attempt. We need to check if they've diverged.
                                // If it's the last attempt we don't need to ignore cache because we already did it.
                                var refresh = lastOnline != attempt;
                                return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, refresh)
                                            .then(function(data) {
                                    if (!snapshotEquals(snapshot, data)) {
                                        // Snapshot has diverged, it will be converted into a new attempt if possible.
                                        return addToNewOrDelete(attempt);
                                    }
                                });
                            } else {
                                // No snapshot, it's a different attempt.
                                newAttemptsSameOrder.push(attempt);
                            }
                        });
                    }
                });
                promises.push(promise);
            });

            return $q.all(promises).then(function() {
                return moveNewAttempts(scormId, siteId, newAttemptsSameOrder, lastOnline, lastCollision, offlineAttempts).then(function() {
                    // The new attempts that need to keep the order have been created. Now we'll create the new attempts
                    // at the end of the list of offline attempts. It should only be 1 attempt max.
                    lastOffline = lastOffline + newAttemptsSameOrder.length;
                    return createNewAttemptsAtEnd(scormId, siteId, newAttemptsAtEnd, lastOffline).then(function() {
                        return warnings;
                    });
                });
            });
        });
    }

    /**
     * Change the number of some offline attempts. We need to move all offline attempts after the collisions
     * too, otherwise we would overwrite data.
     * Example: We have offline attempts 1, 2 and 3. #1 and #2 have collisions. #1 can be synced, but #2 needs
     * to be a new attempt. #3 will now be #4, and #2 will now be #3.
     *
     * @param  {Number} scormId           SCORM ID.
     * @param  {String} siteId            Site ID.
     * @param  {Number[]} newAttempts     Attempts that need to be converted into new attempts.
     * @param  {Number} lastOnline        Last online attempt.
     * @param  {Number} lastCollision     Last attempt with collision (exists in online and offline).
     * @param  {Number[]} offlineAttempts Numbers of offline attempts.
     * @return {Promise}                  Promise resolved when attempts have been moved.
     */
    function moveNewAttempts(scormId, siteId, newAttempts, lastOnline, lastCollision, offlineAttempts) {
        if (!newAttempts.length) {
            return $q.when();
        }

        var promise = $q.when(),
            lastSuccessful;

        // Sort offline attempts in DESC order.
        offlineAttempts = offlineAttempts.sort(function(a, b) {
            return parseInt(a, 10) < parseInt(b, 10);
        });

        // First move the offline attempts after the collisions;
        angular.forEach(offlineAttempts, function(attempt) {
            if (attempt > lastCollision) {
                // We use a chain of promises because we need to move them in order.
                promise = promise.then(function() {
                    var newNumber = attempt + newAttempts.length;
                    return $mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, newNumber).then(function() {
                        lastSuccessful = attempt;
                    });
                });
            }
        });

        return promise.then(function() {
            var promises = [],
                successful = [];

            // Sort newAttempts in ASC order.
            newAttempts = newAttempts.sort(function(a, b) {
                return parseInt(a, 10) > parseInt(b, 10);
            });

            // Now move the attempts in newAttempts.
            angular.forEach(newAttempts, function(attempt, index) {
                // No need to use chain of promises.
                var newNumber = lastOnline + index + 1;
                promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, newNumber).then(function() {
                    successful.push(attempt);
                }));
            });

            return $q.all(promises).catch(function() {
                // Moving the new attempts failed (it shouldn't happen). Let's undo the new attempts move.
                promises = [];
                angular.forEach(successful, function(attempt) {
                    var newNumber = lastOnline + newAttempts.indexOf(attempt) + 1;
                    promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, newNumber, attempt));
                });
                return $mmUtil.allPromises(promises).then(function() {
                    return $q.reject(); // It will now enter the .catch that moves offline attempts after collisions.
                });
            });

        }).catch(function() {
            // Moving offline attempts after collisions failed (it shouldn't happen). Let's undo the changes.
            if (!lastSuccessful) {
                return $q.reject();
            }

            promise = $q.when();

            var attemptsToUndo = [];
            for (var i = lastSuccessful; offlineAttempts.indexOf(i) != -1; i++) {
                attemptsToUndo.push(i);
            }
            attemptsToUndo.forEach(function(attempt) {
                promise = promise.then(function() {
                    // Move it back.
                    return $mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt + newAttempts.length, attempt);
                });
            });
            return promise.then(function() {
                return $q.reject();
            });
        });
    }

    /**
     * Create new attempts at the end of the offline attempts list.
     *
     * @param  {Number} scormId     SCORM ID.
     * @param  {String} siteId      Site ID.
     * @param  {Object} newAttempts Attempts to create. The keys are the timecreated, the values are the attempt number.
     * @param  {Number} lastOffline Number of last offline attempt.
     * @return {Promise}            Promise resolved when the creation is finished.
     */
    function createNewAttemptsAtEnd(scormId, siteId, newAttempts, lastOffline) {
        var times = Object.keys(newAttempts).sort(), // Sort in ASC order.
            promises = [];

        if (!times.length) {
            return $q.when();
        }

        angular.forEach(times, function(time, index) {
            var attempt = newAttempts[time];
            promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, lastOffline + index + 1));
        });
        return $mmUtil.allPromises(promises);
    }

    /**
     * Check if can retry an attempt synchronization.
     *
     * @param  {Number} scormId    SCORM ID.
     * @param  {String} siteId     Site ID.
     * @param  {Number} attempt    Attempt number.
     * @param  {Number} lastOnline Last online attempt number.
     * @return {Promise}           Promise resolved if can retry the synchronization, false otherwise.
     */
    function canRetrySync(scormId, siteId, attempt, lastOnline) {
        // If it's the last attempt we don't need to ignore cache because we already did it.
        var refresh = lastOnline != attempt;
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, refresh).then(function(siteData) {
            // Get synchronization snapshot (if sync fails it should store a snapshot).
            return $mmaModScormOffline.getAttemptSnapshot(siteId, scormId, attempt).then(function(snapshot) {
                if (!snapshot || !Object.keys(snapshot).length || !snapshotEquals(snapshot, siteData)) {
                    // No snapshot or it doesn't match, we can't retry the synchronization.
                    return $q.reject();
                }
            });
        });
    }

    /**
     * Compares an attempt's snapshot with the data retrieved from the site.
     * It only compares elements with dot notation. This means that, if some SCO has been added to Moodle web
     * but the user hasn't generated data for it, then the snapshot will be detected as equal.
     *
     * @param  {Object} snapshot Attempt's snapshot.
     * @param  {Object} userData Data retrieved from the site.
     * @return {Boolean}         True if snapshot is equal to the user data, false otherwise.
     */
    function snapshotEquals(snapshot, userData) {
        var scoId,
            element,
            siteSco,
            snapshotSco;

        // Check that snapshot contains the data from the site.
        for (scoId in userData) {
            siteSco = userData[scoId];
            snapshotSco = snapshot[scoId];

            for (element in siteSco.userdata) {
                if (element.indexOf('.') > -1) {
                    if (!snapshotSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {
                        return false;
                    }
                }
            }
        }

        // Now check the opposite way: site userData contains the data from the snapshot.
        for (scoId in snapshot) {
            siteSco = userData[scoId];
            snapshotSco = snapshot[scoId];

            for (element in snapshotSco.userdata) {
                if (element.indexOf('.') > -1) {
                    if (!siteSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    /**
     * If there's an ongoing sync for a certain SCORM, wait for it to end.
     * If there's no sync ongoing the promise will be resolved right away.
     *
     * @module mm.addons.mod_scorm
     * @ngdoc method
     * @name $mmaModScormSync#waitForSync
     * @param  {Number} scormId  SCORM to check.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved when there's no sync going on for the SCORM.
     */
    self.waitForSync = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        if (syncPromises[siteId] && syncPromises[siteId][scormId]) {
            // There's a sync ongoing for this SCORM.
            return syncPromises[siteId][scormId].catch(function() {});
        }
        return $q.when();
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey')

/**
 * Survey index controller.
 *
 * @module mm.addons.mod_survey
 * @ngdoc controller
 * @name mmaModSurveyIndexCtrl
 */
.controller('mmaModSurveyIndexCtrl', ["$scope", "$stateParams", "$mmaModSurvey", "$mmUtil", "$q", "$mmCourse", "$translate", "$ionicPlatform", "$ionicScrollDelegate", function($scope, $stateParams, $mmaModSurvey, $mmUtil, $q, $mmCourse, $translate,
            $ionicPlatform, $ionicScrollDelegate) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        survey,
        scrollView;

    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleurl = module.url;
    $scope.courseid = courseid;
    $scope.answers = {};
    $scope.isTablet = $ionicPlatform.isTablet();

    // Convenience function to get survey data.
    function fetchSurveyData(refresh) {
        return $mmaModSurvey.getSurvey(courseid, module.id).then(function(surveydata) {
            survey = surveydata;

            $scope.title = survey.name || $scope.title;
            $scope.description = survey.intro || $scope.description;
            $scope.survey = survey;

            if (!survey.surveydone) {
                return fetchQuestions();
            }
        }).catch(function(message) {
            if (!refresh) {
                // Some call failed, retry without using cache since it might be a new activity.
                return refreshAllData();
            }

            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_survey.errorgetsurvey', true);
            }
            return $q.reject();
        });
    }

    // Convenience function to get survey questions.
    function fetchQuestions() {
        return $mmaModSurvey.getQuestions(survey.id).then(function(questions) {
            return $mmaModSurvey.formatQuestions(questions).then(function(formatted) {
                $scope.questions = formatted;

                // Init answers object.
                angular.forEach(formatted, function(q) {
                    if (q.name) {
                        var isTextArea = q.multi && q.multi.length === 0 && q.type === 0;
                        $scope.answers[q.name] = q.required ? -1 : (isTextArea ? '' : '0');
                    }
                });
            });
        });
    }

    // Convenience function to refresh all the data.
    function refreshAllData() {
        var p1 = $mmaModSurvey.invalidateSurveyData(courseid),
            p2 = survey ? $mmaModSurvey.invalidateQuestions(survey.id) : $q.when();

        return $q.all([p1, p2]).finally(function() {
            return fetchSurveyData(true);
        });
    }

    fetchSurveyData().then(function() {
        $mmaModSurvey.logView(survey.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.surveyLoaded = true;
    });

    // Check if answers are valid to be submitted.
    $scope.isValidResponse = function() {
        var valid = true;
        angular.forEach($scope.answers, function(a) {
            if (a === -1) {
                valid = false;
            }
        });
        return valid;
    };

    // Save options selected.
    $scope.submit = function() {
        $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
            var answers = [],
                modal = $mmUtil.showModalLoading('mm.core.sending', true);

            angular.forEach($scope.answers, function(value, key) {
                answers.push({
                    key: key,
                    value: value
                });
            });

            $mmaModSurvey.submitAnswers(survey.id, answers).then(function() {
                if (!scrollView) {
                    scrollView = $ionicScrollDelegate.$getByHandle('mmaModSurveyScroll');
                }
                scrollView && scrollView.scrollTop && scrollView.scrollTop();
                return refreshAllData();
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_survey.cannotsubmitsurvey', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };

    // Pull to refresh.
    $scope.refreshSurvey = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey')

/**
 * Mod survey handlers.
 *
 * @module mm.addons.mod_survey
 * @ngdoc service
 * @name $mmaModSurveyHandlers
 */
.factory('$mmaModSurveyHandlers', ["$mmCourse", "$mmaModSurvey", "$state", "$q", "$mmContentLinksHelper", function($mmCourse, $mmaModSurvey, $state, $q, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurveyHandlers#courseContent
     */
    self.courseContent = function() {

        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return $mmaModSurvey.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('survey');
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_survey', {module: module, courseid: courseid});
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurveyHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            return $mmaModSurvey.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
            });
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a survey URL.
            if (url.indexOf('/mod/survey/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_survey')

/**
 * Survey service.
 *
 * @module mm.addons.mod_survey
 * @ngdoc service
 * @name $mmaModSurvey
 */
.factory('$mmaModSurvey', ["$q", "$mmSite", "$translate", "$mmSitesManager", function($q, $mmSite, $translate, $mmSitesManager) {
    var self = {};

    /**
     * Turns a string with values separated by commas into an array.
     *
     * @param {String} value Value to convert.
     * @return {Array}       Array.
     */
    function commaStringToArray(value) {
        if (typeof value == 'string') {
            if (value !== '') {
                return value.split(',');
            } else {
                return [];
            }
        } else {
            return value;
        }
    }

    /**
     * Format a questions list, turning "multi" and "options" strings into arrays and adding the properties
     * 'num' and 'name'.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#formatQuestions
     * @param {Object[]} questions Questions.
     * @return {Promise}           Promise resolved with the formatted questions.
     */
    self.formatQuestions = function(questions) {
        var stringkeys = [
            'mma.mod_survey.ipreferthat',
            'mma.mod_survey.ifoundthat',
            'mm.core.choose'
        ];

        return $translate(stringkeys).then(function(translates) {
            var stripreferthat = translates[stringkeys[0]],
                strifoundthat = translates[stringkeys[1]],
                strchoose = translates[stringkeys[2]],
                formatted = [],
                parents = self.getParentQuestions(questions),
                num = 1;

            questions = angular.copy(questions); // Copy the array to prevent modifying the original.

            angular.forEach(questions, function(question) {
                var parent = parents[question.parent];

                // Turn multi and options into arrays.
                question.multi = commaStringToArray(question.multi);
                question.options = commaStringToArray(question.options);

                if (parent) {
                    // It's a sub-question.
                    question.required = true;

                    if (parent.type === 1 || parent.type === 2) {
                        // One answer question. Set its name and add it to the returned array.
                        question.name = 'q' + (parent.type == 2 ? 'P' : '') + question.id;
                        question.num = num++;
                    } else {
                        // Two answers per question (COLLES P&A). We'll add two questions.
                        var q2 = angular.copy(question);

                        question.text = stripreferthat + ' ' + question.text;
                        question.name = 'qP' + question.id;
                        question.num = num++;
                        formatted.push(question);

                        q2.text = strifoundthat + ' ' + q2.text;
                        q2.name = 'q' + question.id;
                        q2.num = num++;
                        formatted.push(q2);

                        return;
                    }
                } else if (question.multi && question.multi.length === 0) {
                    // It's a single question.
                    question.name = 'q' + question.id;
                    question.num = num++;
                    if (question.type > 0) { // Add "choose" option since this question is not required.
                        question.options.unshift(strchoose);
                    }
                }

                formatted.push(question);
            });

            return formatted;
        });
    };

    /**
     * Gets the parent questions and puts them in an object: ID -> question.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#getParentQuestions
     * @param {Object[]} questions Questions.
     * @return {Object}            Object with parent questions.
     */
    self.getParentQuestions = function(questions) {
        var parents = {};

        angular.forEach(questions, function(question) {
            if (question.parent === 0) {
                parents[question.id] = question;
            }
        });

        return parents;
    };

    /**
     * Get a survey's questions.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#getQuestions
     * @param {Number} id Survey ID.
     * @return {Promise}  Promise resolved when the questions are retrieved.
     */
    self.getQuestions = function(id) {
        var params = {
                surveyid: id
            },
            preSets = {
                cacheKey: getQuestionsCacheKey(id)
            };

        return $mmSite.read('mod_survey_get_questions', params, preSets).then(function(response) {
            if (response.questions) {
                return response.questions;
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for survey questions WS calls.
     *
     * @param {Number} id Survey ID.
     * @return {String}   Cache key.
     */
    function getQuestionsCacheKey(id) {
        return 'mmaModSurvey:questions:' + id;
    }

    /**
     * Get a survey.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#getSurvey
     * @param {Number} courseid Course ID.
     * @param {Number} cmid     Course module ID.
     * @return {Promise}        Promise resolved when the survey is retrieved.
     */
    self.getSurvey = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getSurveyDataCacheKey(courseid)
            };

        return $mmSite.read('mod_survey_get_surveys_by_courses', params, preSets).then(function(response) {
            if (response.surveys) {
                var currentSurvey;
                angular.forEach(response.surveys, function(survey) {
                    if (survey.coursemodule == cmid) {
                        currentSurvey = survey;
                    }
                });
                if (currentSurvey) {
                    return currentSurvey;
                }
            }
            return $q.reject();
        });
    };

    /**
     * Get cache key for survey data WS calls.
     *
     * @param {Number} courseid Course ID.
     * @return {String}         Cache key.
     */
    function getSurveyDataCacheKey(courseid) {
        return 'mmaModSurvey:survey:' + courseid;
    }

    /**
     * Invalidates survey questions.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#invalidateQuestions
     * @param {Number} id Survey ID.
     * @return {Promise}  Promise resolved when the data is invalidated.
     */
    self.invalidateQuestions = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getQuestionsCacheKey(courseid));
    };

    /**
     * Invalidates survey data.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#invalidateSurveyData
     * @param {Number} courseid Course ID.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    self.invalidateSurveyData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getSurveyDataCacheKey(courseid));
    };

    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the survey WS are available.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#isPluginEnabled
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}         Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();

        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_survey_get_questions') &&
                    site.wsAvailable('mod_survey_get_surveys_by_courses') &&
                    site.wsAvailable('mod_survey_submit_answers');
        });
    };

    /**
     * Report the survey as being viewed.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#logView
     * @param {String} id Survey ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                surveyid: id
            };
            return $mmSite.write('mod_survey_view_survey', params);
        }
        return $q.reject();
    };

    /**
     * Send survey answers to Moodle.
     *
     * @module mm.addons.mod_survey
     * @ngdoc method
     * @name $mmaModSurvey#submitAnswers
     * @param {Number} surveyid  urvey ID.
     * @param {Object[]} answers Answers.
     * @return {Promise}         Promise resolved when answers are successfully submitted.
     */
    self.submitAnswers = function(surveyid, answers) {
        var params = {
            surveyid: surveyid,
            answers: answers
        };
        return $mmSite.write('mod_survey_submit_answers', params).then(function(response) {
            if (!response.status) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url')

/**
 * URL index controller.
 *
 * @module mm.addons.mod_url
 * @ngdoc controller
 * @name mmaModUrlIndexCtrl
 */
.controller('mmaModUrlIndexCtrl', ["$scope", "$stateParams", "$mmaModUrl", "$mmCourse", function($scope, $stateParams, $mmaModUrl, $mmCourse) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.url = (module.contents && module.contents[0] && module.contents[0].fileurl) ? module.contents[0].fileurl : undefined;

    $scope.go = function() {
        $mmaModUrl.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
        $mmaModUrl.open($scope.url);
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url')

/**
 * Mod URL handlers.
 *
 * @module mm.addons.mod_url
 * @ngdoc service
 * @name $mmaModUrlHandlers
 */
.factory('$mmaModUrlHandlers', ["$mmCourse", "$mmaModUrl", "$state", "$mmUtil", "$mmContentLinksHelper", "$q", function($mmCourse, $mmaModUrl, $state, $mmUtil, $mmContentLinksHelper, $q) {

    var self = {};

    /**
     * Course content handler.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrlHandlers#courseContentHandler
     */
    self.courseContentHandler = function() {
        var self = {};

        /**
         * Whether or not the module is enabled for the site.
         *
         * @return {Boolean}
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Get the controller.
         *
         * @param {Object} module The module info.
         * @param {Number} courseid The course ID.
         * @return {Function}
         */
        self.getController = function(module, courseid) {
            return function($scope) {
                $scope.icon = $mmCourse.getModuleIconSrc('url');
                $scope.title = module.name;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_url', {module: module, courseid: courseid});
                };

                if (module.contents && module.contents[0] && module.contents[0].fileurl) {
                    $scope.buttons = [{
                        icon: 'ion-link',
                        label: 'mm.core.openinbrowser',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            $mmaModUrl.logView(module.instance).then(function() {
                                $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                            });
                            $mmaModUrl.open(module.contents[0].fileurl);
                        }
                    }];
                }
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrlHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Whether or not the handler is enabled for a certain site.
         *
         * @param  {String} siteId     Site ID.
         * @param  {Number} [courseId] Course ID related to the URL.
         * @return {Promise}           Promise resolved with true if enabled.
         */
        function isEnabled(siteId, courseId) {
            if (courseId) {
                return $q.when(true);
            }
            return $mmCourse.canGetModuleWithoutCourseId(siteId);
        }

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds  Site IDs the URL belongs to.
         * @param {String} url        URL to treat.
         * @param {Number} [courseId] Course ID related to the URL.
         * @return {Promise}          Promise resolved with the list of actions.
         *                            See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url, courseId) {
            // Check it's a mod_url URL.
            if (url.indexOf('/mod/url/view.php') > -1) {
                return $mmContentLinksHelper.treatModuleIndexUrl(siteIds, url, isEnabled, courseId);
            }
            return $q.when([]);
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.mod_url')

/**
 * URL service.
 *
 * @module mm.addons.mod_url
 * @ngdoc service
 * @name $mmaModUrl
 */
.factory('$mmaModUrl', ["$mmSite", "$mmUtil", "$q", function($mmSite, $mmUtil, $q) {
    var self = {};

    /**
     * Report a URL as being viewed.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrl#logView
     * @param {String} id Module ID.
     * @return {Promise}  Promise resolved when the WS call is successful.
     */
    self.logView = function(id) {
        if (id) {
            var params = {
                urlid: id
            };
            return $mmSite.write('mod_url_view_url', params);
        }
        return $q.reject();
    };

    /**
     * Opens a URL.
     *
     * @module mm.addons.mod_url
     * @ngdoc method
     * @name $mmaModUrl#open
     * @param {String} url The URL to go to.
     */
    self.open = function(url) {
        $mmUtil.openInBrowser(url);
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Controller to handle notes.
 *
 * @module mm.addons.notes
 * @ngdoc controller
 * @name mmaNotesListCtrl
 */
.controller('mmaNotesListCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaNotes", "$mmSite", "$translate", function($scope, $stateParams, $mmUtil, $mmaNotes, $mmSite, $translate) {

    var courseid = $stateParams.courseid,
        type = $stateParams.type;

    $scope.courseid = courseid;
    $scope.type = type;

    $translate('mma.notes.' + type + 'notes').then(function(string) {
        $scope.title = string;
    });

    function fetchNotes(refresh) {
        return $mmaNotes.getNotes(courseid, refresh).then(function(notes) {
            notes = notes[type + 'notes'];

            return $mmaNotes.getNotesUserData(notes, courseid).then(function(notes) {
                $scope.notes = notes;
            });

        }, function(message) {
            $mmUtil.showErrorModal(message);
        });
    }

    fetchNotes().then(function() {
        // Add log in Moodle.
        $mmSite.write('core_notes_view_notes', {
            courseid: courseid,
            userid: 0
        });
    })
    .finally(function() {
        $scope.notesLoaded = true;
    });

    $scope.refreshNotes = function() {
        fetchNotes(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Note types view controller.
 *
 * @module mm.addons.notes
 * @ngdoc controller
 * @name mmaNotesTypesCtrl
 */
.controller('mmaNotesTypesCtrl', ["$scope", "$stateParams", function($scope, $stateParams) {
    var course = $stateParams.course,
        courseid = course.id;
    $scope.courseid = courseid;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Notes handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.notes
 * @ngdoc service
 * @name $mmaNotesHandlers
 */
.factory('$mmaNotesHandlers', ["$mmaNotes", "$mmSite", "$mmApp", "$ionicModal", "$mmUtil", "mmCoursesAccessMethods", function($mmaNotes, $mmSite, $mmApp, $ionicModal, $mmUtil, mmCoursesAccessMethods) {

    var self = {};

    /**
     * Add a note handler.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotesHandlers#addNote
     */
    self.addNote = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaNotes.isPluginAddNoteEnabled();
        };

        /**
         * Check if handler is enabled for this user in this context.
         *
         * @param {Object} user     User to check.
         * @param {Number} courseId Course ID.
         * @return {Boolean}        True if handler is enabled, false otherwise.
         */
        self.isEnabledForUser = function(user, courseId) {
            // Active course required.
            return courseId && user.id != $mmSite.getUserId();
        };

        /**
         * Get the controller.
         *
         * @param {Object} user     Course ID.
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(user, courseid) {

            /**
             * Add note handler controller.
             *
             * @module mm.addons.notes
             * @ngdoc controller
             * @name $mmaNotesHandlers#addNote:controller
             */
            return function($scope) {

                // Button title.
                $scope.title = 'mma.notes.addnewnote';

                $ionicModal.fromTemplateUrl('addons/notes/templates/add.html', {
                    scope: $scope,
                    animation: 'slide-in-up'
                }).then(function(m) {
                    $scope.modal = m;
                });

                $scope.closeModal = function(){
                    $scope.modal.hide();
                };

                $scope.addNote = function(){

                    $mmApp.closeKeyboard();

                    var loadingModal = $mmUtil.showModalLoading('mm.core.sending', true);
                    // Freeze the add note button.
                    $scope.processing = true;

                    $mmaNotes.addNote(user.id, courseid, $scope.note.publishstate, $scope.note.text).then(function() {
                        $mmUtil.showModal('mm.core.success', 'mma.notes.eventnotecreated');
                        $scope.closeModal();
                    }, function(error) {
                        $mmUtil.showErrorModal(error);
                        $scope.processing = false;
                    }).finally(function() {
                        loadingModal.dismiss();
                    });
                };

                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();

                    $scope.note = {
                        publishstate: 'personal',
                        text: ''
                    };
                    $scope.processing = false;

                    $scope.modal.show();

                };
            };

        };

        return self;
    };

    /**
     * Course nav handler.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotesHandlers#coursesNav
     */
    self.coursesNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaNotes.isPluginViewNotesEnabled();
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean}          True if handler is enabled, false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return true;
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(courseId) {

            /**
             * Courses nav handler controller.
             *
             * @module mm.addons.notes
             * @ngdoc controller
             * @name $mmaNotesHandlers#coursesNav:controller
             */
            return function($scope, $state) {
                $scope.icon = 'ion-ios-list';
                $scope.title = 'mma.notes.notes';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.notes-types', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notes')

/**
 * Notes factory.
 *
 * @module mm.addons.notes
 * @ngdoc service
 * @name $mmaNotes
 */
.factory('$mmaNotes', ["$mmSite", "$log", "$q", "$mmUser", "$translate", function($mmSite, $log, $q, $mmUser, $translate) {
    $log = $log.getInstance('$mmaNotes');

    var self = {};

    /**
     * Add a note.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#addNote
     * @param {Number} userId       User ID of the person to add the note.
     * @param {Number} courseId     Course ID where the note belongs.
     * @param {String} publishState Personal, Site or Course.
     * @param {String} noteText     The note text.
     * @return {Promise}
     */
    self.addNote = function(userId, courseId, publishState, noteText) {
        var data = {
            "notes[0][userid]" : userId,
            "notes[0][publishstate]": publishState,
            "notes[0][courseid]": courseId,
            "notes[0][text]": noteText,
            "notes[0][format]": 1
        };
        return $mmSite.write('core_notes_create_notes', data);
    };

    /**
     * Returns whether or not the add note plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#isPluginAddNoteEnabled
     * @return {Boolean}
     */
    self.isPluginAddNoteEnabled = function() {
        var infos;

        if (!$mmSite.isLoggedIn()) {
            return false;
        } else if (!$mmSite.canUseAdvancedFeature('enablenotes')) {
            return false;
        } else if (!$mmSite.wsAvailable('core_notes_create_notes')) {
            return false;
        }

        return true;
    };

    /**
     * Returns whether or not the read notes plugin is enabled for the current site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#isPluginViewNotesEnabled
     * @return {Boolean}
     */
    self.isPluginViewNotesEnabled = function() {
        var infos;

        if (!$mmSite.isLoggedIn()) {
            return false;
        } else if (!$mmSite.canUseAdvancedFeature('enablenotes')) {
            return false;
        } else if (!$mmSite.wsAvailable('core_notes_get_course_notes')) {
            return false;
        }

        return true;
    };

    /**
     * Get users notes for a certain site, course and personal notes.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#getNotes
     * @param {Number} courseid ID of the course to get the notes from.
     * @param {Boolean} refresh True when we should not get the value from the cache.
     * @return {Promise}        Promise to be resolved when the notes are retrieved.
     */
    self.getNotes = function(courseid, refresh) {

        $log.debug('Get notes for course ' + courseid);

        var data = {
                courseid : courseid
            },
            presets = {};
        if (refresh) {
            presets.getFromCache = false;
        }

        return $mmSite.read('core_notes_get_course_notes', data, presets);
    };

    /**
     * Get user data for notes since they only have userid.
     *
     * @module mm.addons.notes
     * @ngdoc method
     * @name $mmaNotes#getNotesUserData
     * @param {Object[]} notes       Notes to get the data for.
     * @param {Number}   courseid    ID of the course the notes belong to.
     * @return {Promise}             Promise always resolved. Resolve param is the formatted notes.
     */
    self.getNotesUserData = function(notes, courseid) {
        var promises = [];

        angular.forEach(notes, function(note) {
            var promise = $mmUser.getProfile(note.userid, courseid, true).then(function(user) {
                note.userfullname = user.fullname;
                note.userprofileimageurl = user.profileimageurl;
            }, function() {
                // Error getting profile. Set default data.
                return $translate('mma.notes.userwithid', {id: note.userid}).then(function(str) {
                    note.userfullname = str;
                });
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return notes;
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Controller to handle notification list.
 *
 * @module mm.addons.notifications
 * @ngdoc controller
 * @name mmaNotificationsListCtrl
 */
.controller('mmaNotificationsListCtrl', ["$scope", "$mmUtil", "$mmaNotifications", "mmaNotificationsListLimit", function($scope, $mmUtil, $mmaNotifications, mmaNotificationsListLimit) {

    var readCount = 0,
        unreadCount = 0;

    $scope.notifications = [];

    // Convenience function to get notifications. Get unread notifications first.
    function fetchNotifications(refresh) {

        if (refresh) {
            readCount = 0;
            unreadCount = 0;
        }

        return $mmaNotifications.getUnreadNotifications(unreadCount, mmaNotificationsListLimit).then(function(unread) {
            // Don't add the unread notifications to $scope.notifications yet. If there are no unread notifications
            // that causes that the "There are no notifications" message is shown in pull to refresh.
            unreadCount += unread.length;

            if (unread.length < mmaNotificationsListLimit) {
                // Limit not reached. Get read notifications until reach the limit.
                var readLimit = mmaNotificationsListLimit - unread.length;
                return $mmaNotifications.getReadNotifications(readCount, readLimit).then(function(read) {
                    readCount += read.length;
                    if (refresh) {
                        $scope.notifications = unread.concat(read);
                    } else {
                        $scope.notifications = $scope.notifications.concat(unread).concat(read);
                    }
                    $scope.canLoadMore = read.length >= readLimit;
                }, function(error) {
                    if (unread.length == 0) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mma.notifications.errorgetnotifications', true);
                        }
                        $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
                    }
                });
            } else {
                if (refresh) {
                    $scope.notifications = unread;
                } else {
                    $scope.notifications = $scope.notifications.concat(unread);
                }
                $scope.canLoadMore = true;
            }
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.notifications.errorgetnotifications', true);
            }
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
        });
    }
    fetchNotifications().finally(function() {
        $scope.notificationsLoaded = true;
    });

    $scope.refreshNotifications = function() {
        $mmaNotifications.invalidateNotificationsList().finally(function() {
            fetchNotifications(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };

    $scope.loadMoreNotifications = function(){
        fetchNotifications().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Notification action directive.
 *
 * @module mm.addons.notifications
 * @ngdoc directive
 * @name mmaNotificationsActions
 */
.directive('mmaNotificationsActions', ["$log", "$mmContentLinksDelegate", function($log, $mmContentLinksDelegate) {
    $log = $log.getInstance('mmaNotificationsActions');

    // Directive link function.
    function link(scope) {
        if (scope.contexturl) {
            $mmContentLinksDelegate.getActionsFor(scope.contexturl, scope.courseid).then(function(actions) {
                scope.actions = actions;
            });
        }
    }

    return {
        link: link,
        restrict: 'E',
        scope: {
            contexturl: '=',
            courseid: '='
        },
        templateUrl: 'addons/notifications/templates/actions.html',
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Filter to format a notification.
 *
 * @module mm.addons.notifications
 * @ngdoc filter
 * @name mmaNotificationsFormat
 */
.filter('mmaNotificationsFormat', ["$mmText", function($mmText) {
  return function(text) {
    text = text.replace(/-{4,}/ig, '');
    text = $mmText.replaceNewLines(text, '<br />');
    return text;
  };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Notifications handlers factory.
 *
 * This factory holds the different handlers used for delegates.
 *
 * @module mm.addons.notifications
 * @ngdoc service
 * @name $mmaNotificationsHandlers
 */
.factory('$mmaNotificationsHandlers', ["$log", "$mmaNotifications", function($log, $mmaNotifications) {
    $log = $log.getInstance('$mmaNotificationsHandlers');

    var self = {};

    /**
     * Side menu nav handler.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotificationsHandlers#sideMenuNav
     */
    self.sideMenuNav = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return $mmaNotifications.isPluginEnabled();
        };

        /**
         * Get the controller.
         *
         * @return {Object} Controller.
         */
        self.getController = function() {

            /**
             * Side menu nav handler controller.
             *
             * @module mm.addons.notifications
             * @ngdoc controller
             * @name $mmaNotificationsHandlers#sideMenuNav:controller
             */
            return function($scope) {
                $scope.icon = 'ion-ios-bell';
                $scope.title = 'mma.notifications.notifications';
                $scope.state = 'site.notifications';
            };
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.notifications')

/**
 * Service to handle notifications (messages).
 *
 * @module mm.addons.notifications
 * @ngdoc service
 * @name $mmaNotifications
 */
.factory('$mmaNotifications', ["$q", "$log", "$mmSite", "$mmSitesManager", "mmaNotificationsListLimit", function($q, $log, $mmSite, $mmSitesManager, mmaNotificationsListLimit) {

    $log = $log.getInstance('$mmaNotifications');

    var self = {};

    // Function to format notification data.
    function formatNotificationsData(notifications) {
        angular.forEach(notifications, function(notification) {
            // Set message to show.
            if (notification.contexturl && notification.contexturl.indexOf('/mod/forum/')) {
                notification.mobiletext = notification.smallmessage;
            } else {
                notification.mobiletext = notification.fullmessage;
            }

            // Try to set courseid the notification belongs to.
            var cid = notification.fullmessagehtml.match(/course\/view\.php\?id=([^"]*)/);
            if (cid && cid[1]) {
                notification.courseid = cid[1];
            }
        });
    }

    /**
     * Get cache key for notification list WS calls.
     *
     * @return {String} Cache key.
     */
    function getNotificationsCacheKey() {
        return 'mmaNotifications:list';
    };

    /**
     * Get notifications from site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#getNotifications
     * @param {Boolean} read       True if should get read notifications, false otherwise.
     * @param {Number} limitFrom   Position of the first notification to get.
     * @param {Number} limitNumber Number of notifications to get.
     * @return {Promise}           Promise resolved with notifications.
     */
    self.getNotifications = function(read, limitFrom, limitNumber) {
        limitFrom = limitFrom || 0;
        limitNumber = limitNumber || mmaNotificationsListLimit;

        $log.debug('Get ' + (read ? 'read' : 'unread') + ' notifications from ' + limitFrom + '. Limit: ' + limitNumber);

        var data = {
            useridto: $mmSite.getUserId(),
            useridfrom: 0,
            type: 'notifications',
            read: read ? 1 : 0,
            newestfirst: 1,
            limitfrom: limitFrom,
            limitnum: limitNumber
        };
        var preSets = {
            cacheKey: getNotificationsCacheKey()
        };

        // Get unread notifications.
        return $mmSite.read('core_message_get_messages', data, preSets).then(function(response) {
            if (response.messages) {
                var notifications = response.messages;
                formatNotificationsData(notifications);
                return notifications;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Get read notifications from site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#getReadNotifications
     * @param {Number} limitFrom   Position of the first notification to get.
     * @param {Number} limitNumber Number of notifications to get.
     * @return {Promise}           Promise resolved with notifications.
     */
    self.getReadNotifications = function(limitFrom, limitNumber) {
        return self.getNotifications(true, limitFrom, limitNumber);
    };

    /**
     * Get unread notifications from site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#getUnreadNotifications
     * @param {Number} limitFrom   Position of the first notification to get.
     * @param {Number} limitNumber Number of notifications to get.
     * @return {Promise}           Promise resolved with notifications.
     */
    self.getUnreadNotifications = function(limitFrom, limitNumber) {
        return self.getNotifications(false, limitFrom, limitNumber);
    };

    /**
     * Invalidates notifications list WS calls.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#invalidateNotificationsList
     * @return {Promise} Promise resolved when the list is invalidated.
     */
    self.invalidateNotificationsList = function() {
        return $mmSite.invalidateWsCacheForKey(getNotificationsCacheKey());
    };

    /**
     * Check if plugin is available.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#isPluginEnabled
     * @return {Boolean} True if plugin is available, false otherwise.
     */
    self.isPluginEnabled = function() {
        return $mmSite.wsAvailable('core_message_get_messages');
    };

    /**
     * Check if plugin is available for a certain site.
     *
     * @module mm.addons.notifications
     * @ngdoc method
     * @name $mmaNotifications#isPluginEnabledForSite
     * @param {String} siteid Site ID.
     * @return {Promise}      Resolved when enabled, otherwise rejected.
     */
    self.isPluginEnabledForSite = function(siteid) {
        return $mmSitesManager.getSite(siteid).then(function(site) {
            if (!site.wsAvailable('core_message_get_messages')) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants')

/**
 * Controller to handle course participants.
 *
 * @module mm.addons.participants
 * @ngdoc controller
 * @name mmaParticipantsListCtrl
 */
.controller('mmaParticipantsListCtrl', ["$scope", "$state", "$stateParams", "$mmUtil", "$mmaParticipants", "$ionicPlatform", "$mmSite", "mmUserProfileState", function($scope, $state, $stateParams, $mmUtil, $mmaParticipants, $ionicPlatform, $mmSite,
            mmUserProfileState) {
    var course = $stateParams.course,
        courseid = course.id;

    $scope.participants = [];
    $scope.courseid = courseid;
    $scope.userStateName = mmUserProfileState;

    function fetchParticipants(refresh) {
        var firstToGet = refresh ? 0 : $scope.participants.length;
        return $mmaParticipants.getParticipants(courseid, firstToGet).then(function(data) {
            if (refresh) {
                $scope.participants = data.participants;
            } else {
                $scope.participants = $scope.participants.concat(data.participants);
            }
            $scope.canLoadMore = data.canLoadMore;
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
        });
    }

    // Get first participants.
    fetchParticipants(true).then(function() {
        // Add log in Moodle.
        $mmSite.write('core_user_view_user_list', {
            courseid: courseid
        });
    }).finally(function() {
        $scope.participantsLoaded = true;
    });

    // Load more participants.
    $scope.loadMoreParticipants = function(){
        fetchParticipants().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };

    $scope.refreshParticipants = function() {
        $mmaParticipants.invalidateParticipantsList(courseid).finally(function() {
            fetchParticipants(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants')

/**
 * Participants handlers.
 *
 * @module mm.addons.participants
 * @ngdoc service
 * @name $mmaParticipantsHandlers
 */
.factory('$mmaParticipantsHandlers', ["$mmaParticipants", "mmCoursesAccessMethods", "$mmUtil", "$mmContentLinksHelper", function($mmaParticipants, mmCoursesAccessMethods, $mmUtil, $mmContentLinksHelper) {
    var self = {};

    /**
     * Course nav handler.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipantsHandlers#coursesNavHandler
     */
    self.coursesNavHandler = function() {

        var self = {};

        /**
         * Check if handler is enabled.
         *
         * @return {Boolean} True if handler is enabled, false otherwise.
         */
        self.isEnabled = function() {
            return true;
        };

        /**
         * Check if handler is enabled for this course.
         *
         * @param {Number} courseId   Course ID.
         * @param {Object} accessData Type of access to the course: default, guest, ...
         * @return {Boolean|Promise}  Promise resolved  with true if handler is enabled,
         *                            false or promise rejected or resolved with false otherwise.
         */
        self.isEnabledForCourse = function(courseId, accessData) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false; // Not enabled for guests.
            }
            return $mmaParticipants.isPluginEnabledForCourse(courseId);
        };

        /**
         * Get the controller.
         *
         * @param {Number} courseId Course ID.
         * @return {Object}         Controller.
         */
        self.getController = function(courseId) {
            return function($scope, $state) {
                $scope.icon = 'ion-person-stalker';
                $scope.title = 'mma.participants.participants';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.participants', {
                        course: course
                    });
                };
            };
        };

        return self;
    };

    /**
     * Content links handler.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipantsHandlers#linksHandler
     */
    self.linksHandler = function() {

        var self = {};

        /**
         * Get actions to perform with the link.
         *
         * @param {String[]} siteIds Site IDs the URL belongs to.
         * @param {String} url       URL to treat.
         * @return {Object[]}        List of actions. See {@link $mmContentLinksDelegate#registerLinkHandler}.
         */
        self.getActions = function(siteIds, url) {
            // Check it's a user URL.
            if (url.indexOf('grade/report/user') == -1 && url.indexOf('/user/index.php') > -1) {
                var params = $mmUtil.extractUrlParams(url);
                if (typeof params.id != 'undefined') {
                    // Return actions.
                    return [{
                        message: 'mm.core.view',
                        icon: 'ion-eye',
                        sites: siteIds,
                        action: function(siteId) {
                            var stateParams = {
                                course: {id: parseInt(params.id, 10)}
                            };
                            $mmContentLinksHelper.goInSite('site.participants', stateParams, siteId);
                        }
                    }];
                }
            }
            return [];
        };

        return self;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.participants')

/**
 * Service to handle course participants.
 *
 * @module mm.addons.participants
 * @ngdoc service
 * @name $mmaParticipants
 */
.factory('$mmaParticipants', ["$log", "$mmSite", "$mmUser", "mmaParticipantsListLimit", function($log, $mmSite, $mmUser, mmaParticipantsListLimit) {

    $log = $log.getInstance('$mmaParticipants');

    var self = {};

    /**
     * Get cache key for participant list WS calls.
     *
     * @param  {Number} courseid Course ID.
     * @return {String}          Cache key.
     */
    function getParticipantsListCacheKey(courseid) {
        return 'mmaParticipants:list:'+courseid;
    }

    /**
     * Get participants for a certain course.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipants#getParticipants
     * @param {String} courseid    ID of the course.
     * @param {Number} limitFrom   Position of the first participant to get.
     * @param {Number} limitNumber Number of participants to get.
     * @return {Promise}           Promise to be resolved when the participants are retrieved.
     */
    self.getParticipants = function(courseid, limitFrom, limitNumber) {

        if (typeof limitFrom == 'undefined') {
            limitFrom = 0;
        }
        if (typeof limitNumber == 'undefined') {
            limitNumber = mmaParticipantsListLimit;
        }

        $log.debug('Get participants for course ' + courseid + ' starting at ' + limitFrom);

        var wsName,
            data = {
                courseid: courseid
            }, preSets = {
                cacheKey: getParticipantsListCacheKey(courseid)
            };

        if ($mmSite.wsAvailable('core_enrol_get_enrolled_users')) {
            wsName = 'core_enrol_get_enrolled_users';
            data.options = [
                {
                    name: 'limitfrom',
                    value: limitFrom
                },
                {
                    name: 'limitnumber',
                    value: limitNumber
                },
                {
                    name: 'sortby',
                    value: 'siteorder'
                }
            ];
        } else {
            wsName = 'moodle_enrol_get_enrolled_users';
            limitNumber = 9999999999; // Set a big limitNumber so canLoadMore is always false (WS not paginated).
        }

        return $mmSite.read(wsName, data, preSets).then(function(users) {
            // Format user data, moodle_enrol_get_enrolled_users returns some attributes with a different name.
            angular.forEach(users, function(user) {
                if (typeof user.id == 'undefined' && typeof user.userid != 'undefined') {
                    user.id = user.userid;
                }
                if (typeof user.profileimageurl == 'undefined' && typeof user.profileimgurl != 'undefined') {
                    user.profileimageurl = user.profileimgurl;
                }
            });

            var canLoadMore = users.length >= limitNumber;
            $mmUser.storeUsers(users);
            return {participants: users, canLoadMore: canLoadMore};
        });
    };

    /**
     * Invalidates participant list for a certain course.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipants#invalidateParticipantsList
     * @param  {Number} courseid Course ID.
     * @return {Promise}         Promise resolved when the list is invalidated.
     */
    self.invalidateParticipantsList = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getParticipantsListCacheKey(courseid));
    };

    /**
     * Returns whether or not the participants addon is enabled for a certain course.
     *
     * @module mm.addons.participants
     * @ngdoc method
     * @name $mmaParticipants#isPluginEnabledForCourse
     * @param {Number} courseId Course ID.
     * @return {Promise}        Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    self.isPluginEnabledForCourse = function(courseId) {
        if (!courseId) {
            return $q.reject();
        }

        // Retrieving one participant will fail if browsing users is disabled by capabilities.
        return self.getParticipants(courseId, 0, 1).then(function(parcitipants) {
            return true;
        }).catch(function(error) {
            return false;
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.pushnotifications')

/**
 * Service to handle push notifications clicks.
 *
 * @module mm.addons.pushnotifications
 * @ngdoc service
 * @name $mmPushNotificationsDelegate
 */
.factory('$mmPushNotificationsDelegate', ["$log", function($log) {

    $log = $log.getInstance('$mmPushNotificationsDelegate');

    var handlers = {},
        self = {};

    /**
     * Function called when a push notification is clicked. Sends notification to handlers.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmPushNotificationsDelegate#clicked
     * @param {Object} notification Notification clicked.
     * @return {Void}
     */
    self.clicked = function(notification) {
        for (var name in handlers) {
            var callback = handlers[name];
            if (typeof callback == 'function') {
                var treated = callback(notification);
                if (treated) {
                    return; // Stop execution when notification is treated.
                }
            }
        }
    };

    /**
     * Register a push notifications handler. The handler will receive a notification to treat.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmPushNotificationsDelegate#registerHandler
     * @param {String} name       Handler's name.
     * @param {Function} callback The callback function. Will get as parameter the URL to handle.
     * @description
     * The handler should return true if the notification is the one expected, false otherwise.
     * @see {@link $mmPushNotificationsDelegate#clicked}
     */
    self.registerHandler = function(name, callback) {
        $log.debug("Registered handler '" + name + "' as push notification handler.");
        handlers[name] = callback;
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.pushnotifications')

/**
 * Push notifications factory.
 *
 * @module mm.addons.pushnotifications
 * @ngdoc service
 * @name $mmaPushNotifications
 */
.factory('$mmaPushNotifications', ["$mmSite", "$log", "$cordovaPush", "$mmText", "$q", "$cordovaDevice", "$mmUtil", "mmCoreConfigConstants", "$mmApp", "$mmLocalNotifications", "$mmPushNotificationsDelegate", "$mmSitesManager", "mmaPushNotificationsComponent", function($mmSite, $log, $cordovaPush, $mmText, $q, $cordovaDevice, $mmUtil, mmCoreConfigConstants,
            $mmApp, $mmLocalNotifications, $mmPushNotificationsDelegate, $mmSitesManager, mmaPushNotificationsComponent) {
    $log = $log.getInstance('$mmaPushNotifications');

    var self = {},
        pushID;

    /**
     * Returns whether or not the plugin is enabled for the current site.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#isPluginEnabled
     * @return {Boolean} True if enabled, false otherwise.
     */
    self.isPluginEnabled = function() {
        return $mmSite.wsAvailable('core_user_add_user_device')
                && $mmSite.wsAvailable('message_airnotifier_is_system_configured')
                && $mmSite.wsAvailable('message_airnotifier_are_notification_preferences_configured');
    };

    /**
     * Function called when a push notification is clicked. Redirect the user to the right state.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#notificationClicked
     * @param {Object} data Notification data.
     */
    self.notificationClicked = function(data) {
        $mmApp.ready().then(function() {
            $mmPushNotificationsDelegate.clicked(data);
        });
    };

    /**
     * This function is called from the PushPlugin when we receive a Notification from GCM.
     * The app can be in foreground or background,
     * if we are in background this code is executed when we open the app clicking in the notification bar.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#onGCMReceived
     * @param {Object} notification Notification data.
     */
    self.onGCMReceived = function(notification) {
        $log.debug('GCM notification received. Type: '+notification.event);

        switch (notification.event) {
            case 'registered':
                if (notification.regid.length > 0) {
                    pushID = notification.regid;
                    return self.registerDeviceOnMoodle();
                } else {
                    $log.debug('Device NOT registered in GCM, invalid regid');
                    break;
                }

            case 'message':
                notification.payload.foreground = notification.foreground;
                return self.onMessageReceived(notification.payload);

            case 'error':
                $log.debug('Push messages error');
                break;

            default:
                $log.debug('Push unknown message');
        }
    };

    /**
     * This function is called when we receive a Notification from APNS or a message notification from GCM.
     * The app can be in foreground or background,
     * if we are in background this code is executed when we open the app clicking in the notification bar.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#onMessageReceived
     * @param {Object} data Notification data.
     */
    self.onMessageReceived = function(data) {
        var promise;

        if (data && data.site) {
            promise = $mmSitesManager.getSite(data.site); // Check if site exists.
        } else {
            promise = $q.when(); // No site specified, resolve.
        }

        promise.then(function() {
            if ($mmUtil.isTrueOrOne(data.foreground)) {
                // If the app is in foreground when the notification is received, it's not shown. Let's show it ourselves.
                if ($mmLocalNotifications.isAvailable()) {
                    // Apply formatText to title and message.
                    $mmText.formatText(data.title, true, true).then(function(formattedTitle) {
                        $mmText.formatText(data.message, true, true).then(function(formattedMessage) {
                            var localNotif = {
                                id: 1,
                                title: formattedTitle,
                                message: formattedMessage,
                                at: new Date(),
                                smallIcon: 'res://icon',
                                data: {
                                    notif: data.notif,
                                    site: data.site
                                }
                            };
                            $mmLocalNotifications.schedule(localNotif, mmaPushNotificationsComponent, data.site);
                        });
                    });
                }
            } else {
                self.notificationClicked(data);
            }
        });
    };

    /**
     * Register a device in Apple APNS or Google GCM.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#registerDevice
     * @return {Promise} Promise resolved when the device is registered.
     */
    self.registerDevice = function() {
        try {
            if (ionic.Platform.isIOS()) {
                return self._registerDeviceAPNS();
            } else if (ionic.Platform.isAndroid()) {
                return self._registerDeviceGCM();
            }
        } catch(ex) {}

        return $q.reject();
    };

    /**
     * Register a device in Apple APNS (Apple Push Notificaiton System) using the Phonegap PushPlugin.
     * It also registers the device in the Moodle site using the core_user_add_user_device WebService.
     * We need the device registered in Moodle so we can connect the device with the message output Moode plugin airnotifier.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#_registerDeviceAPNS
     * @return {Promise} Promise resolved when the device is registered.
     * @protected
     */
    self._registerDeviceAPNS = function() {
        var options = {
            alert: 'true',
            badge: 'true',
            sound: 'true'
        };
        return $cordovaPush.register(options).then(function(token) {
            pushID = token;
            return self.registerDeviceOnMoodle();
        }, function(error) {
            return $q.reject();
        });
    };

    /**
     * Register a device in Google GCM using the Phonegap PushPlugin.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#_registerDeviceGCM
     * @return {Promise} Promise resolved when the device is registered.
     * @protected
     */
    self._registerDeviceGCM = function() {
        if (mmCoreConfigConstants.gcmpn) {
            return $cordovaPush.register({
                senderID: mmCoreConfigConstants.gcmpn
            });
        }
        return $q.reject();
    };

    /**
     * Registers a device on current Moodle site.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#registerDeviceOnMoodle
     * @return {Promise}      Promise resolved when device is registered.
     */
    self.registerDeviceOnMoodle = function() {
        $log.debug('Register device on Moodle.');

        if (!$mmSite.isLoggedIn() || !pushID || !$mmApp.isDevice()) {
            return $q.reject();
        }

        var data = {
            appid:      mmCoreConfigConstants.app_id,
            name:       ionic.Platform.device().name || '',
            model:      $cordovaDevice.getModel(),
            platform:   $cordovaDevice.getPlatform(),
            version:    $cordovaDevice.getVersion(),
            pushid:     pushID,
            uuid:       $cordovaDevice.getUUID()
        };
        return $mmSite.write('core_user_add_user_device', data);
    };

    /**
     * Unregisters a device from a certain Moodle site.
     *
     * @module mm.addons.pushnotifications
     * @ngdoc method
     * @name $mmaPushNotifications#unregisterDeviceOnMoodle
     * @param {Object} site Site to unregister from.
     * @return {Promise}    Promise resolved when device is unregistered.
     */
    self.unregisterDeviceOnMoodle = function(site) {

        if (!site || !$mmApp.isDevice()) {
            return $q.reject();
        }

        $log.debug('Unregister device on Moodle: ' + site.id);

        var data = {
            appid: mmCoreConfigConstants.app_id,
            uuid:  $cordovaDevice.getUUID()
        };
        return site.write('core_user_remove_user_device', data).then(function(response) {
            if (!response || !response.removed) {
                return $q.reject();
            }
        });
    };

    return self;
}]);

// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm.addons.remotestyles')

/**
 * Service to handle remote styles.
 *
 * @module mm.addons.remotestyles
 * @ngdoc service
 * @name $mmaRemoteStyles
 */
.factory('$mmaRemoteStyles', ["$log", "$q", "$mmSite", "$mmSitesManager", "$mmFilepool", "$http", "$mmFS", "mmaRemoteStylesComponent", "mmCoreNotDownloaded", function($log, $q, $mmSite, $mmSitesManager, $mmFilepool, $http, $mmFS, mmaRemoteStylesComponent,
            mmCoreNotDownloaded) {

    $log = $log.getInstance('$mmaRemoteStyles');

    var self = {},
        remoteStylesEl = angular.element(document.querySelector('#mobilecssurl'));

    /**
     * Clear remote styles added to the DOM.
     *
     * @module mm.addons.remotestyles
     * @ngdoc method
     * @name $mmaRemoteStyles#clear
     */
    self.clear = function() {
        remoteStylesEl.html('');
    };

    /**
     * Get remote styles of a certain site.
     *
     * @module mm.addons.remotestyles
     * @ngdoc method
     * @name $mmaRemoteStyles#get
     * @param {String} siteid Site ID.
     * @return {Promise}      Promise resolved with the styles.
     */
    self.get = function(siteid) {
        var promise;

        siteid = siteid || $mmSite.getId();
        if (!siteid) {
            return $q.reject();
        }

        // Downloads a CSS file and remove old files if needed.
        function downloadFileAndRemoveOld(url) {
            return $mmFilepool.getFileStateByUrl(siteid, url).then(function(state) {
                return state !== mmCoreNotDownloaded;
            }).catch(function() {
                return true; // An error occurred while getting state (shouldn't happen). Don't delete downloaded file.
            }).then(function(isDownloaded) {
                if (!isDownloaded) {
                    // File not downloaded, URL has changed or first time. Delete downloaded CSS files.
                    return $mmFilepool.removeFilesByComponent(siteid, mmaRemoteStylesComponent, 1);
                }
            }).then(function() {
                return $mmFilepool.downloadUrl(siteid, url, false, mmaRemoteStylesComponent, 1);
            });
        }

        return $mmSitesManager.getSite(siteid).then(function(site) {
            var infos = site.getInfo();
            if (infos && infos.mobilecssurl) {
                if ($mmFS.isAvailable()) {
                    // The file system is available. Download the file and remove old CSS files if needed.
                    return downloadFileAndRemoveOld(infos.mobilecssurl);
                } else {
                    // We return the online URL. We're probably on browser.
                    return infos.mobilecssurl;
                }
            } else {
                if (infos.mobilecssurl === '') {
                    // CSS URL is empty. Delete downloaded files (if any).
                    $mmFilepool.removeFilesByComponent(siteid, mmaRemoteStylesComponent, 1)
                }
                return $q.reject();
            }
        }).then(function(url) {
            $log.debug('Loading styles from: '+url);
            return $http.get(url);
        }).then(function(response) {
            if (typeof response.data == 'string') {
                return response.data;
            } else {
                return $q.reject();
            }
        });
    };

    /**
     * Load styles for current site.
     *
     * @module mm.addons.remotestyles
     * @ngdoc method
     * @name $mmaRemoteStyles#load
     */
    self.load = function() {
        var siteid = $mmSite.getId();
        if (siteid) {
            self.get(siteid).then(function(styles) {
                if (siteid === $mmSite.getId()) { // Make sure it hasn't logout while retrieving styles.
                    remoteStylesEl.html(styles);
                }
            });
        }
    };

    return self;
}]);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5qcyIsIm1haW4uanMiLCJhZGRvbm1hbmFnZXIuanMiLCJhbmd1bGFyLWlvczktdWl3ZWJ2aWV3LnBhdGNoLmpzIiwiY29uZmlnLmpzIiwiZGIuanMiLCJlbXVsYXRvci5qcyIsImV2ZW50cy5qcyIsImZpbGVwb29sLmpzIiwiZnMuanMiLCJncm91cHMuanMiLCJpbml0LmpzIiwiaW9uaWMtaW9zOS1yYWRpby1maXguanMiLCJsYW5nLmpzIiwibG9jYWxub3RpZi5qcyIsImxvZy5qcyIsInNpdGUuanMiLCJzaXRlc2ZhY3RvcnkuanMiLCJzaXRlc21hbmFnZXIuanMiLCJ0ZXh0LmpzIiwidXBkYXRlbWFuYWdlci5qcyIsInVybGRlbGVnYXRlLmpzIiwidXRpbC5qcyIsIndzLmpzIiwiYnl0ZXN0b3NpemUuanMiLCJjcmVhdGVsaW5rcy5qcyIsImRhdGVfZGF5X29yX3RpbWUuanMiLCJmb3JtYXRkYXRlLmpzIiwibm90YWdzLmpzIiwidGltZWFnby5qcyIsInRvbG9jYWxlc3RyaW5nLmpzIiwiYXV0b2ZvY3VzLmpzIiwiYnJvd3Nlci5qcyIsImNvbXBsZXRpb24uanMiLCJleHRlcm5hbF9jb250ZW50LmpzIiwiZmlsZS5qcyIsImZvcm1hdHRleHQuanMiLCJpZnJhbWUuanMiLCJpbWFnZXZpZXdlci5qcyIsImxvYWRpbmcuanMiLCJuYXZpZ2F0aW9uYmFyLmpzIiwibm9pbnB1dHZhbGlkYXRpb24uanMiLCJzcGxpdHZpZXcuanMiLCJzcGxpdHZpZXdsaW5rLmpzIiwiY29udGVudGxpbmtzL21haW4uanMiLCJjb3Vyc2UvbWFpbi5qcyIsImNvdXJzZXMvbWFpbi5qcyIsImxvZ2luL21haW4uanMiLCJzZXR0aW5ncy9tYWluLmpzIiwic2lkZW1lbnUvbWFpbi5qcyIsInRleHR2aWV3ZXIvbWFpbi5qcyIsInVzZXIvbWFpbi5qcyIsImNvbnRlbnRsaW5rcy9jb250cm9sbGVycy9jaG9vc2VzaXRlLmpzIiwiY29udGVudGxpbmtzL3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwiY29udGVudGxpbmtzL3NlcnZpY2VzL2hlbHBlci5qcyIsImNvdXJzZS9jb250cm9sbGVycy9tb2Rjb250ZW50LmpzIiwiY291cnNlL2NvbnRyb2xsZXJzL3NlY3Rpb24uanMiLCJjb3Vyc2UvY29udHJvbGxlcnMvc2VjdGlvbnMuanMiLCJjb3Vyc2UvZGlyZWN0aXZlcy9tb2RfZGVzY3JpcHRpb24uanMiLCJjb3Vyc2Uvc2VydmljZXMvY29udGVudF9oYW5kbGVyLmpzIiwiY291cnNlL3NlcnZpY2VzL2NvdXJzZS5qcyIsImNvdXJzZS9zZXJ2aWNlcy9jb3Vyc2VzX25hdl9oYW5kbGVyLmpzIiwiY291cnNlL3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwiY291cnNlL3NlcnZpY2VzL2hlbHBlci5qcyIsImNvdXJzZS9zZXJ2aWNlcy9wcmVmZXRjaGRlbGVnYXRlLmpzIiwiY291cnNlcy9jb250cm9sbGVycy9saXN0LmpzIiwiY291cnNlcy9jb250cm9sbGVycy9zZWFyY2guanMiLCJjb3Vyc2VzL2NvbnRyb2xsZXJzL3ZpZXdyZXN1bHQuanMiLCJjb3Vyc2VzL3NlcnZpY2VzL2NvdXJzZXMuanMiLCJjb3Vyc2VzL3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwiY291cnNlcy9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsImxvZ2luL2NvbnRyb2xsZXJzL2NyZWRlbnRpYWxzLmpzIiwibG9naW4vY29udHJvbGxlcnMvaW5pdC5qcyIsImxvZ2luL2NvbnRyb2xsZXJzL3JlY29ubmVjdC5qcyIsImxvZ2luL2NvbnRyb2xsZXJzL3NpdGUuanMiLCJsb2dpbi9jb250cm9sbGVycy9zaXRlcy5qcyIsImxvZ2luL3NlcnZpY2VzL2hlbHBlci5qcyIsInNldHRpbmdzL2NvbnRyb2xsZXJzL2Fib3V0LmpzIiwic2V0dGluZ3MvY29udHJvbGxlcnMvZ2VuZXJhbC5qcyIsInNldHRpbmdzL2NvbnRyb2xsZXJzL3NwYWNlLXVzYWdlLmpzIiwic2V0dGluZ3MvY29udHJvbGxlcnMvc3luY2hyb25pemF0aW9uLmpzIiwic2lkZW1lbnUvY29udHJvbGxlcnMvbWVudS5qcyIsInNpZGVtZW51L3NlcnZpY2VzL2RlbGVnYXRlLmpzIiwidGV4dHZpZXdlci9jb250cm9sbGVycy9pbmRleC5qcyIsInVzZXIvY29udHJvbGxlcnMvcHJvZmlsZS5qcyIsInVzZXIvZGlyZWN0aXZlcy91c2VybGluay5qcyIsInVzZXIvc2VydmljZXMvZGVsZWdhdGUuanMiLCJ1c2VyL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwidXNlci9zZXJ2aWNlcy91c2VyLmpzIiwiY2FsZW5kYXIvbWFpbi5qcyIsImNvdXJzZWNvbXBsZXRpb24vbWFpbi5qcyIsImZpbGVzL21haW4uanMiLCJmcm9udHBhZ2UvbWFpbi5qcyIsImdyYWRlcy9tYWluLmpzIiwibWVzc2FnZXMvbWFpbi5qcyIsIm1vZF9hc3NpZ24vbWFpbi5qcyIsIm1vZF9ib29rL21haW4uanMiLCJtb2RfY2hhdC9tYWluLmpzIiwibW9kX2Nob2ljZS9tYWluLmpzIiwibW9kX2ZvbGRlci9tYWluLmpzIiwibW9kX2ZvcnVtL21haW4uanMiLCJtb2RfZ2xvc3NhcnkvbWFpbi5qcyIsIm1vZF9pbXNjcC9tYWluLmpzIiwibW9kX2xhYmVsL21haW4uanMiLCJtb2RfbHRpL21haW4uanMiLCJtb2RfcGFnZS9tYWluLmpzIiwibW9kX3Jlc291cmNlL21haW4uanMiLCJtb2Rfc2Nvcm0vbWFpbi5qcyIsIm1vZF9zdXJ2ZXkvbWFpbi5qcyIsIm1vZF91cmwvbWFpbi5qcyIsIm5vdGVzL21haW4uanMiLCJub3RpZmljYXRpb25zL21haW4uanMiLCJwYXJ0aWNpcGFudHMvbWFpbi5qcyIsInB1c2hub3RpZmljYXRpb25zL21haW4uanMiLCJyZW1vdGVzdHlsZXMvbWFpbi5qcyIsImNhbGVuZGFyL2NvbnRyb2xsZXJzL2V2ZW50LmpzIiwiY2FsZW5kYXIvY29udHJvbGxlcnMvbGlzdC5qcyIsImNhbGVuZGFyL3NlcnZpY2VzL2NhbGVuZGFyLmpzIiwiY2FsZW5kYXIvc2VydmljZXMvaGFuZGxlcnMuanMiLCJjb3Vyc2Vjb21wbGV0aW9uL2NvbnRyb2xsZXJzL3JlcG9ydC5qcyIsImNvdXJzZWNvbXBsZXRpb24vc2VydmljZXMvY291cnNlY29tcGxldGlvbi5qcyIsImNvdXJzZWNvbXBsZXRpb24vc2VydmljZXMvaGFuZGxlcnMuanMiLCJmaWxlcy9jb250cm9sbGVycy9jaG9vc2VzaXRlLmpzIiwiZmlsZXMvY29udHJvbGxlcnMvaW5kZXguanMiLCJmaWxlcy9jb250cm9sbGVycy9saXN0LmpzIiwiZmlsZXMvY29udHJvbGxlcnMvdXBsb2FkLmpzIiwiZmlsZXMvZGlyZWN0aXZlcy9vbmNoYW5nZS5qcyIsImZpbGVzL3NlcnZpY2VzL2ZpbGVzLmpzIiwiZmlsZXMvc2VydmljZXMvaGFuZGxlcnMuanMiLCJmaWxlcy9zZXJ2aWNlcy9oZWxwZXIuanMiLCJmcm9udHBhZ2Uvc2VydmljZXMvZnJvbnRwYWdlLmpzIiwiZnJvbnRwYWdlL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwiZ3JhZGVzL2NvbnRyb2xsZXJzL3RhYmxlLmpzIiwiZ3JhZGVzL3NlcnZpY2VzL2dyYWRlcy5qcyIsImdyYWRlcy9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1lc3NhZ2VzL2NvbnRyb2xsZXJzL2NvbnRhY3RzLmpzIiwibWVzc2FnZXMvY29udHJvbGxlcnMvZGlzY3Vzc2lvbi5qcyIsIm1lc3NhZ2VzL2NvbnRyb2xsZXJzL2Rpc2N1c3Npb25zLmpzIiwibWVzc2FnZXMvY29udHJvbGxlcnMvaW5kZXguanMiLCJtZXNzYWdlcy9maWx0ZXJzL2Zvcm1hdC5qcyIsIm1lc3NhZ2VzL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibWVzc2FnZXMvc2VydmljZXMvbWVzc2FnZXMuanMiLCJtb2RfYXNzaWduL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX2Fzc2lnbi9jb250cm9sbGVycy9zdWJtaXNzaW9uLmpzIiwibW9kX2Fzc2lnbi9zZXJ2aWNlcy9hc3NpZ24uanMiLCJtb2RfYXNzaWduL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX2Jvb2svY29udHJvbGxlcnMvaW5kZXguanMiLCJtb2RfYm9vay9kaXJlY3RpdmVzL2Fycm93cy5qcyIsIm1vZF9ib29rL3NlcnZpY2VzL2Jvb2suanMiLCJtb2RfYm9vay9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9ib29rL3NlcnZpY2VzL3ByZWZldGNoX2hhbmRsZXIuanMiLCJtb2RfY2hhdC9jb250cm9sbGVycy9jaGF0LmpzIiwibW9kX2NoYXQvY29udHJvbGxlcnMvaW5kZXguanMiLCJtb2RfY2hhdC9zZXJ2aWNlcy9jaGF0LmpzIiwibW9kX2NoYXQvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfY2hvaWNlL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX2Nob2ljZS9zZXJ2aWNlcy9jaG9pY2UuanMiLCJtb2RfY2hvaWNlL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX2ZvbGRlci9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9mb2xkZXIvc2VydmljZXMvZm9sZGVyLmpzIiwibW9kX2ZvbGRlci9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9mb2xkZXIvc2VydmljZXMvcHJlZmV0Y2hfaGFuZGxlci5qcyIsIm1vZF9mb3J1bS9jb250cm9sbGVycy9kaXNjdXNzaW9uLmpzIiwibW9kX2ZvcnVtL2NvbnRyb2xsZXJzL2Rpc2N1c3Npb25zLmpzIiwibW9kX2ZvcnVtL2NvbnRyb2xsZXJzL25ld2Rpc2N1c3Npb24uanMiLCJtb2RfZm9ydW0vZGlyZWN0aXZlcy9kaXNjdXNzaW9ucG9zdC5qcyIsIm1vZF9mb3J1bS9zZXJ2aWNlcy9mb3J1bS5qcyIsIm1vZF9mb3J1bS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9nbG9zc2FyeS9jb250cm9sbGVycy9lbnRyeS5qcyIsIm1vZF9nbG9zc2FyeS9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9nbG9zc2FyeS9zZXJ2aWNlcy9nbG9zc2FyeS5qcyIsIm1vZF9nbG9zc2FyeS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9pbXNjcC9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9pbXNjcC9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9pbXNjcC9zZXJ2aWNlcy9pbXNjcC5qcyIsIm1vZF9pbXNjcC9zZXJ2aWNlcy9wcmVmZXRjaF9oYW5kbGVyLmpzIiwibW9kX2xhYmVsL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX2xhYmVsL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX2x0aS9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9sdGkvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfbHRpL3NlcnZpY2VzL2x0aS5qcyIsIm1vZF9wYWdlL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX3BhZ2Uvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfcGFnZS9zZXJ2aWNlcy9wYWdlLmpzIiwibW9kX3BhZ2Uvc2VydmljZXMvcHJlZmV0Y2hfaGFuZGxlci5qcyIsIm1vZF9yZXNvdXJjZS9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF9yZXNvdXJjZS9kaXJlY3RpdmVzL2h0bWxfbGluay5qcyIsIm1vZF9yZXNvdXJjZS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9yZXNvdXJjZS9zZXJ2aWNlcy9wcmVmZXRjaF9oYW5kbGVyLmpzIiwibW9kX3Jlc291cmNlL3NlcnZpY2VzL3Jlc291cmNlLmpzIiwibW9kX3Njb3JtL2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX3Njb3JtL2NvbnRyb2xsZXJzL3BsYXllci5qcyIsIm1vZF9zY29ybS9zZXJ2aWNlcy9kYXRhX21vZGVsXzEyLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL2hlbHBlci5qcyIsIm1vZF9zY29ybS9zZXJ2aWNlcy9wcmVmZXRjaF9oYW5kbGVyLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL3Njb3JtLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL3Njb3JtX29mZmxpbmUuanMiLCJtb2Rfc2Nvcm0vc2VydmljZXMvc2Nvcm1fb25saW5lLmpzIiwibW9kX3Njb3JtL3NlcnZpY2VzL3Njb3JtX3N5bmMuanMiLCJtb2Rfc3VydmV5L2NvbnRyb2xsZXJzL2luZGV4LmpzIiwibW9kX3N1cnZleS9zZXJ2aWNlcy9oYW5kbGVycy5qcyIsIm1vZF9zdXJ2ZXkvc2VydmljZXMvc3VydmV5LmpzIiwibW9kX3VybC9jb250cm9sbGVycy9pbmRleC5qcyIsIm1vZF91cmwvc2VydmljZXMvaGFuZGxlcnMuanMiLCJtb2RfdXJsL3NlcnZpY2VzL3VybC5qcyIsIm5vdGVzL2NvbnRyb2xsZXJzL2xpc3QuanMiLCJub3Rlcy9jb250cm9sbGVycy90eXBlcy5qcyIsIm5vdGVzL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibm90ZXMvc2VydmljZXMvbm90ZXMuanMiLCJub3RpZmljYXRpb25zL2NvbnRyb2xsZXJzL2xpc3QuanMiLCJub3RpZmljYXRpb25zL2RpcmVjdGl2ZXMvYWN0aW9ucy5qcyIsIm5vdGlmaWNhdGlvbnMvZmlsdGVycy9mb3JtYXQuanMiLCJub3RpZmljYXRpb25zL3NlcnZpY2VzL2hhbmRsZXJzLmpzIiwibm90aWZpY2F0aW9ucy9zZXJ2aWNlcy9ub3RpZmljYXRpb25zLmpzIiwicGFydGljaXBhbnRzL2NvbnRyb2xsZXJzL2xpc3QuanMiLCJwYXJ0aWNpcGFudHMvc2VydmljZXMvaGFuZGxlcnMuanMiLCJwYXJ0aWNpcGFudHMvc2VydmljZXMvcGFydGljaXBhbnRzLmpzIiwicHVzaG5vdGlmaWNhdGlvbnMvc2VydmljZXMvZGVsZWdhdGUuanMiLCJwdXNobm90aWZpY2F0aW9ucy9zZXJ2aWNlcy9wdXNobm90aWZpY2F0aW9ucy5qcyIsInJlbW90ZXN0eWxlcy9zZXJ2aWNlcy9yZW1vdGVzdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsUUFBUSxPQUFPLE1BQU0sQ0FBQyxTQUFTLGFBQWEsZUFBZSwwQkFBMEIsVUFBVSx3QkFBd0I7O0NBRXRILHVCQUFJLFNBQVMs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a0IsUUFBUSxLQUFLLEtBQUssU0FBUyxPQUFPO2dCQUNuRSxPQUFPLFVBQVU7ZUFDbEIsTUFBTSxXQUFXO2dCQUNoQixPQUFPO2VBQ1IsS0FBSyxTQUFTLGNBQWM7Z0JBQzNCLElBQUksQ0FBQyxjQUFjOztvQkFFZixPQUFPLFlBQVksdUJBQXVCLFFBQVEsMEJBQTBCOztlQUVqRixLQUFLLFdBQVc7Z0JBQ2YsT0FBTyxZQUFZLFlBQVksUUFBUSxLQUFLLE9BQU8sMEJBQTBCOzs7O1FBSXJGLE9BQU8sZ0JBQWdCLFFBQVEsUUFBUSxLQUFLLFNBQVMsTUFBTTtZQUN2RCxJQUFJLFFBQVEsS0FBSztZQUNqQixJQUFJLFNBQVMsTUFBTSxjQUFjO2dCQUM3QixJQUFJLE1BQU0sZUFBZTs7b0JBRXJCLE9BQU8seUJBQXlCLE1BQU07dUJBQ25DOztvQkFFSCxPQUFPLE1BQU07O21CQUVkO2dCQUNILElBQUksTUFBTSxpQkFBaUIsSUFBSTs7b0JBRTNCLFlBQVksdUJBQXVCLFFBQVEsMEJBQTBCOztnQkFFekUsT0FBTyxHQUFHOztXQUVmLEtBQUssU0FBUyxLQUFLO1lBQ2xCLEtBQUssTUFBTSx3QkFBd0I7WUFDbkMsT0FBTyxNQUFNLElBQUk7V0FDbEIsS0FBSyxTQUFTLFVBQVU7WUFDdkIsSUFBSSxPQUFPLFNBQVMsUUFBUSxVQUFVO2dCQUNsQyxPQUFPLFNBQVM7bUJBQ2I7Z0JBQ0gsT0FBTyxHQUFHOzs7Ozs7Ozs7Ozs7SUFZdEIsS0FBSyxPQUFPLFdBQVc7UUFDbkIsSUFBSSxTQUFTLFFBQVE7UUFDckIsSUFBSSxRQUFRO1lBQ1IsS0FBSyxJQUFJLFFBQVEsS0FBSyxTQUFTLFFBQVE7Z0JBQ25DLElBQUksV0FBVyxRQUFRLFNBQVM7b0JBQzVCLGVBQWUsS0FBSzs7Ozs7O0lBTXBDLE9BQU87O0FBRVgiLCJmaWxlIjoibW0uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBGYWN0b3J5IHRvIHByb3ZpZGUgc29tZSBnbG9iYWwgZnVuY3Rpb25hbGl0aWVzLCBsaWtlIGFjY2VzcyB0byB0aGUgZ2xvYmFsIGFwcCBkYXRhYmFzZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBwcm92aWRlclxuICogQG5hbWUgJG1tQXBwXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgcHJvdmlkZXIgaXMgdGhlIGludGVyZmFjZSB3aXRoIHRoZSBhcHAgZGF0YWJhc2UuIFRoZSBtb2R1bGVzIHRoYXQgbmVlZCB0byBzdG9yZVxuICogaW5mb3JtYXRpb24gaGVyZSBuZWVkIHRvIHJlZ2lzdGVyIHRoZWlyIHN0b3Jlcy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIC5jb25maWcoZnVuY3Rpb24oJG1tQXBwUHJvdmlkZXIpIHtcbiAqICAgICAgJG1tQXBwUHJvdmlkZXIucmVnaXN0ZXJTdG9yZSh7XG4gKiAgICAgICAgICBuYW1lOiAnc2V0dGluZ3MnLFxuICogICAgICAgICAga2V5UGF0aDogJ25hbWUnXG4gKiAgICAgIH0pO1xuICogIH0pXG4gKi9cbi5wcm92aWRlcignJG1tQXBwJywgZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgIC8qKiBEZWZpbmUgdGhlIGFwcCBzdG9yYWdlIHNjaGVtYS4gKi9cbiAgICB2YXIgREJOQU1FID0gJ01vb2RsZU1vYmlsZScsXG4gICAgICAgIGRic2NoZW1hID0ge1xuICAgICAgICAgICAgc3RvcmVzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBkYm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhdXRvU2NoZW1hOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHN0b3JlIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc3RvcmUgVGhlIHN0b3JlIG9iamVjdCBkZWZpbml0aW9uLlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdGhpcy5yZWdpc3RlclN0b3JlID0gZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZihzdG9yZS5uYW1lKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCckbW1BcHA6IEVycm9yOiBzdG9yZSBuYW1lIGlzIHVuZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChzdG9yZUV4aXN0cyhzdG9yZS5uYW1lKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJyRtbUFwcDogRXJyb3I6IHN0b3JlICcgKyBzdG9yZS5uYW1lICsgJyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGJzY2hlbWEuc3RvcmVzLnB1c2goc3RvcmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBtdWx0aXBsZSBzdG9yZXMgYXQgb25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBzdG9yZXMgQXJyYXkgb2Ygc3RvcmUgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHRoaXMucmVnaXN0ZXJTdG9yZXMgPSBmdW5jdGlvbihzdG9yZXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goc3RvcmVzLCBmdW5jdGlvbihzdG9yZSkge1xuICAgICAgICAgICAgc2VsZi5yZWdpc3RlclN0b3JlKHN0b3JlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc3RvcmUgaXMgYWxyZWFkeSBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIHdoZW4gdGhlIHN0b3JlIHdhcyBhbHJlYWR5IGRlZmluZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmVFeGlzdHMobmFtZSkge1xuICAgICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYnNjaGVtYS5zdG9yZXMsIGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgIH1cblxuICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uKCRtbURCLCAkY29yZG92YU5ldHdvcmssICRsb2csICRpbmplY3RvciwgJGlvbmljUGxhdGZvcm0pIHtcblxuICAgICAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tQXBwJyk7XG5cbiAgICAgICAgdmFyIGRiLFxuICAgICAgICAgICAgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgc3RhdGUgaW4gdGhlIFVJLXJvdXRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQXBwI2NyZWF0ZVN0YXRlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgU3RhdGUgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBTdGF0ZSBjb25maWcuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmNyZWF0ZVN0YXRlID0gZnVuY3Rpb24obmFtZSwgY29uZmlnKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdBZGRpbmcgbmV3IHN0YXRlOiAnK25hbWUpO1xuICAgICAgICAgICAgJHN0YXRlUHJvdmlkZXIuc3RhdGUobmFtZSwgY29uZmlnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBrZXlib2FyZCBpZiBwbHVnaW4gaXMgYXZhaWxhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBsdWdpbiBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuY2xvc2VLZXlib2FyZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb3Jkb3ZhICE9ICd1bmRlZmluZWQnICYmIGNvcmRvdmEucGx1Z2lucyAmJiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQgJiYgY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYXBwbGljYXRpb24gZ2xvYmFsIGRhdGFiYXNlLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFwcCdzIERCLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXREQiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYiA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRiID0gJG1tREIuZ2V0REIoREJOQU1FLCBkYnNjaGVtYSwgZGJvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGRhdGFiYXNlIHNjaGVtYS5cbiAgICAgICAgICpcbiAgICAgICAgICogRG8gbm90IHVzZSB0aGlzIG1ldGhvZCB0byBtb2RpZnkgdGhlIHNjaGVtYS4gVXNlICRtbUFwcFByb3ZpZGVyI3JlZ2lzdGVyU3RvcmUgaW5zdGVhZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgc2NoZW1hLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRTY2hlbWEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkYnNjaGVtYTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29yZSBpbml0IHByb2Nlc3MgZm9yIHRoZSBhcHAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGlzIHNob3VsZCBiZSB0aGUgZmlyc3QgaW5pdCBwcm9jZXNzIG9mIGFsbCwgbm8gb3RoZXIgcHJvY2VzcyBzaG91bGQgcnVuIHVudGlsIHdlXG4gICAgICAgICAqIGFyZSBjZXJ0YWluIHRoYXQgdGhlIGNvcmRvdmEgcGx1Z2lucyBhcmUgbG9hZGVkLCB3aGljaCBpcyB3aGF0ICRpb25pY1BsYXRmb3JtIHRlbGxzIHVzLlxuICAgICAgICAgKiBUaGVyZSBzaG91bGQgbm90IGJlIGFueSBsb2dpYyBhY3Rpbmcgb24gdGhlIGRhdGFiYXNlIGhlcmUgYXMgdGhlIHVwZ3JhZGUgaXNcbiAgICAgICAgICogYW5vdGhlciBwcm9jZXNzIGFuZCBoYXMgbm90IHJ1biB5ZXQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICpcbiAgICAgICAgICogS2VlcCB0aGlzIGZhc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlc2VydmVkIGZvciBjb3JlIHVzZSwgZG8gbm90IGNhbGwgZGlyZWN0bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2Mgc2VydmljZVxuICAgICAgICAgKiBAbmFtZSAkbW1BcHAjaW5pdFByb2Nlc3NcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pbml0UHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRpb25pY1BsYXRmb3JtLnJlYWR5KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgYXBwIGlzIHJ1bm5pbmcgaW4gYSByZWFsIGRldmljZSB3aXRoIGNvcmRvdmEtcGx1Z2luLWRldmljZSBpbnN0YWxsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUFwcCNpc0RldmljZVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sfSBUcnVlIGlmIGRldmljZSBpcyBkZWZpbmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRGV2aWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gISF3aW5kb3cuZGV2aWNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgd2UgYXJlIG9ubGluZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQXBwI2lzT25saW5lXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2x9IFRydWUgd2hlbiB3ZSBhcmUuXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGlzIG1ldGhvZHMgcmV0dXJucyB3aGV0aGVyIHRoZSBhcHAgaXMgb25saW5lIG9yIG5vdC5cbiAgICAgICAgICogTm90ZSB0aGF0IGEgYnJvd3NlciBpcyBhbHdheXMgY29uc2lkZXJlZCBiZWluZyBvbmxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzT25saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb25saW5lID0gdHlwZW9mIG5hdmlnYXRvci5jb25uZWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAkY29yZG92YU5ldHdvcmsuaXNPbmxpbmUoKTtcbiAgICAgICAgICAgIC8vIERvdWJsZSBjaGVjayB3ZSBhcmUgbm90IG9ubGluZSBiZWNhdXNlIHdlIGNhbm5vdCByZWx5IDEwMCUgaW4gQ29yZG92YSBBUElzLlxuICAgICAgICAgICAgaWYgKCFvbmxpbmUgJiYgbmF2aWdhdG9yLm9uTGluZSkge1xuICAgICAgICAgICAgICAgIG9ubGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb25saW5lO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIENoZWNrIGlmIGRldmljZSB1c2VzIGEgbGltaXRlZCBjb25uZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1BcHAjaXNOZXR3b3JrQWNjZXNzTGltaXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGRldmljZSB1c2VkIGEgbGltaXRlZCBjb25uZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHVzIHRvIGZpcnN0IGNoZWNrIGlmIGNvcmRvdmEgaXMgbG9hZGVkLFxuICAgICAgICAgKiBvdGhlcndpc2UgZXhjZXB0aW9ucyBjYW4gYmUgdGhyb3duIHdoZW4gdHJ5aW5nIG9uIGEgYnJvd3Nlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNOZXR3b3JrQWNjZXNzTGltaXRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IuY29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBQbHVnaW4gbm90IGRlZmluZWQsIHByb2JhYmx5IGluIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHR5cGUgPSAkY29yZG92YU5ldHdvcmsuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgdmFyIGxpbWl0ZWQgPSBbQ29ubmVjdGlvbi5DRUxMXzJHLCBDb25uZWN0aW9uLkNFTExfM0csIENvbm5lY3Rpb24uQ0VMTF80RywgQ29ubmVjdGlvbi5DRUxMXTtcbiAgICAgICAgICAgIHJldHVybiBsaW1pdGVkLmluZGV4T2YodHlwZSkgPiAtMTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGx5IHJldHVybnMgaWYgdGhlIGFwcCBpcyByZWFkeS5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgYXBwIGlzIHJlYWR5LCByZWZlciB0byB7QGxpbmsgJG1tQXBwI3JlYWR5fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQXBwI3JlYWR5XG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgd2hlbiBpdCBpcywgZmFsc2Ugd2hlbiBub3QuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzUmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gJGluamVjdG9yLmdldCgnJG1tSW5pdERlbGVnYXRlJykucmVhZHkoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLiQkc3RhdGUuc3RhdHVzID09PSAxO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVuIHRoZSBrZXlib2FyZCBpZiBwbHVnaW4gaXMgYXZhaWxhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBsdWdpbiBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYub3BlbktleWJvYXJkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvcmRvdmEgIT0gJ3VuZGVmaW5lZCcgJiYgY29yZG92YS5wbHVnaW5zICYmIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZCAmJiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuc2hvdykge1xuICAgICAgICAgICAgICAgIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5zaG93KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmVzIHdoZW4gdGhlIGFwcCBpcyByZWFkeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQXBwI3JlYWR5XG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGlzIHJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgYXBwIGlzIGluaXRpYWxpc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2FnZTpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgJG1tQXBwLnJlYWR5KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgICAgIC8vIFdoYXQgeW91IHdhbnQgdG8gZG8uXG4gICAgICAgICAqICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhcHAgaXMgaW5pdGlhbGlzZWQuIE5ldmVyIHJlamVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5yZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gSW5qZWN0cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgIHJldHVybiAkaW5qZWN0b3IuZ2V0KCckbW1Jbml0RGVsZWdhdGUnKS5yZWFkeSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScsIFsncGFzY2FscHJlY2h0LnRyYW5zbGF0ZSddKVxuXG4uY29uc3RhbnQoJ21tQ29yZVNlc3Npb25FeHBpcmVkJywgJ21tQ29yZVNlc3Npb25FeHBpcmVkJylcbi5jb25zdGFudCgnbW1Db3JlVXNlckRlbGV0ZWQnLCAnbW1Db3JlVXNlckRlbGV0ZWQnKVxuLmNvbnN0YW50KCdtbUNvcmVTZWNvbmRzWWVhcicsIDMxNTM2MDAwKVxuLmNvbnN0YW50KCdtbUNvcmVTZWNvbmRzRGF5JywgODY0MDApXG4uY29uc3RhbnQoJ21tQ29yZVNlY29uZHNIb3VyJywgMzYwMClcbi5jb25zdGFudCgnbW1Db3JlU2Vjb25kc01pbnV0ZScsIDYwKVxuXG4vLyBTdGF0ZXMgZm9yIGRvd25sb2FkaW5nIGZpbGVzL21vZHVsZXMuXG4uY29uc3RhbnQoJ21tQ29yZURvd25sb2FkZWQnLCAnZG93bmxvYWRlZCcpXG4uY29uc3RhbnQoJ21tQ29yZURvd25sb2FkaW5nJywgJ2Rvd25sb2FkaW5nJylcbi5jb25zdGFudCgnbW1Db3JlTm90RG93bmxvYWRlZCcsICdub3Rkb3dubG9hZGVkJylcbi5jb25zdGFudCgnbW1Db3JlT3V0ZGF0ZWQnLCAnb3V0ZGF0ZWQnKVxuLmNvbnN0YW50KCdtbUNvcmVOb3REb3dubG9hZGFibGUnLCAnbm90ZG93bmxvYWRhYmxlJylcblxuLmNvbnN0YW50KCdtbUNvcmVXaWZpRG93bmxvYWRUaHJlc2hvbGQnLCAxMDQ4NTc2MDApIC8vIDEwME1CLlxuLmNvbnN0YW50KCdtbUNvcmVEb3dubG9hZFRocmVzaG9sZCcsIDEwNDg1NzYwKSAvLyAxME1CLlxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkcHJvdmlkZSwgJGlvbmljQ29uZmlnUHJvdmlkZXIsICRodHRwUHJvdmlkZXIsICRtbVV0aWxQcm92aWRlcixcbiAgICAgICAgJG1tTG9nUHJvdmlkZXIsICRjb21waWxlUHJvdmlkZXIsICRtbUluaXREZWxlZ2F0ZVByb3ZpZGVyLCBtbUluaXREZWxlZ2F0ZU1heEFkZG9uUHJpb3JpdHkpIHtcblxuICAgIC8vIFNldCB0YWJzIHRvIGJvdHRvbSBvbiBBbmRyb2lkLlxuICAgICRpb25pY0NvbmZpZ1Byb3ZpZGVyLnBsYXRmb3JtLmFuZHJvaWQudGFicy5wb3NpdGlvbignYm90dG9tJyk7XG5cbiAgICAvLyBEZWNvcmF0ZSAkaW9uaWNQbGF0Zm9ybS5cbiAgICAkcHJvdmlkZS5kZWNvcmF0b3IoJyRpb25pY1BsYXRmb3JtJywgWyckZGVsZWdhdGUnLCAnJHdpbmRvdycsIGZ1bmN0aW9uKCRkZWxlZ2F0ZSwgJHdpbmRvdykge1xuICAgICAgICAkZGVsZWdhdGUuaXNUYWJsZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBtcSA9ICdvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxKSc7XG4gICAgICAgICAgICByZXR1cm4gJHdpbmRvdy5tYXRjaE1lZGlhKG1xKS5tYXRjaGVzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJGRlbGVnYXRlO1xuICAgIH1dKTtcblxuICAgIC8qKlxuICAgICAqIERlY29yYXRlICRsb2cuIFVzYWdlOlxuICAgICAqICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdNeUZhY3RvcnknKVxuICAgICAqICRsb2cuZGVidWcoJ015IG1lc3NhZ2UnKSAtPiBcImRkL21tL2FhYWEgaGg6bW06c3MgTXlGYWN0b3J5OiBNeSBtZXNzYWdlXCJcbiAgICAgKi9cbiAgICAkcHJvdmlkZS5kZWNvcmF0b3IoJyRsb2cnLCBbJyRkZWxlZ2F0ZScsICRtbUxvZ1Byb3ZpZGVyLmxvZ0RlY29yYXRvcl0pO1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcbiAgICAgICAgLnN0YXRlKCdyZWRpcmVjdCcsIHtcbiAgICAgICAgICAgIHVybDogJy9yZWRpcmVjdCcsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBzaXRlaWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgY29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsICRzdGF0ZVBhcmFtcywgJG1tU2l0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCAkaW9uaWNIaXN0b3J5KSB7XG5cbiAgICAgICAgICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7ZGlzYWJsZUJhY2s6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWRTaXRlQW5kR28oKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5sb2FkU2l0ZSgkc3RhdGVQYXJhbXMuc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCRzdGF0ZVBhcmFtcy5zdGF0ZSwgJHN0YXRlUGFyYW1zLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2l0ZSBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdtbV9sb2dpbi5zaXRlcycpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmVudGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzdGF0ZVBhcmFtcy5zaXRlaWQgJiYgJHN0YXRlUGFyYW1zLnNpdGVpZCAhPSAkbW1TaXRlLmdldElkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RpZmljYXRpb24gYmVsb25ncyB0byBhIGRpZmZlcmVudCBzaXRlLiBDaGFuZ2Ugc2l0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1TaXRlc01hbmFnZXIubG9nb3V0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZFNpdGVBbmRHbygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJHN0YXRlUGFyYW1zLnN0YXRlLCAkc3RhdGVQYXJhbXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc3RhdGVQYXJhbXMuc2l0ZWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZFNpdGVBbmRHbygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ21tX2xvZ2luLnNpdGVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAvLyBUaGlzIGNvZGUgaXMgdG8gYmUgYWJsZSB0byBnZXQgZGF0YSBzZW50IHdpdGggJGh0dHAucG9zdCB1c2luZyAkX1BPU1QgdmFyaWFibGUuXG4gICAgLy8gT3RoZXJ3aXNlIGFsbCB0aGUgZGF0YSBlbmRzIHVwIGluIHBocDovL2lucHV0IGFuZCBzZWVtcyBsaWtlIGxvY2FsL21vYmlsZS9jaGVjay5waHAgZG9lc24ndCBsaWtlIGl0LlxuICAgICRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVycy5wb3N0WydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCc7XG4gICAgJGh0dHBQcm92aWRlci5kZWZhdWx0cy50cmFuc2Zvcm1SZXF1ZXN0ID0gW2Z1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNPYmplY3QoZGF0YSkgJiYgU3RyaW5nKGRhdGEpICE9PSAnW29iamVjdCBGaWxlXScgPyAkbW1VdGlsUHJvdmlkZXIucGFyYW0oZGF0YSkgOiBkYXRhO1xuICAgIH1dO1xuXG4gICAgLy8gQWRkIHNvbWUgcHJvdG9jb2xzIHRvIHNhZmUgcHJvdG9jb2xzLlxuICAgIGZ1bmN0aW9uIGFkZFByb3RvY29sSWZNaXNzaW5nKGxpc3QsIHByb3RvY29sKSB7XG4gICAgICAgIGlmIChsaXN0LmluZGV4T2YocHJvdG9jb2wpID09IC0xKSB7XG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5yZXBsYWNlKCdodHRwcz8nLCAnaHR0cHM/fCcgKyBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgdmFyIGhyZWZsaXN0ID0gJGNvbXBpbGVQcm92aWRlci5hSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdCgpLnNvdXJjZSxcbiAgICAgICAgaW1nbGlzdCA9ICRjb21waWxlUHJvdmlkZXIuaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0KCkuc291cmNlO1xuXG4gICAgaHJlZmxpc3QgPSBhZGRQcm90b2NvbElmTWlzc2luZyhocmVmbGlzdCwgJ2ZpbGUnKTtcbiAgICBocmVmbGlzdCA9IGFkZFByb3RvY29sSWZNaXNzaW5nKGhyZWZsaXN0LCAndGVsJyk7XG4gICAgaHJlZmxpc3QgPSBhZGRQcm90b2NvbElmTWlzc2luZyhocmVmbGlzdCwgJ21haWx0bycpO1xuICAgIGhyZWZsaXN0ID0gYWRkUHJvdG9jb2xJZk1pc3NpbmcoaHJlZmxpc3QsICdnZW8nKTtcbiAgICBocmVmbGlzdCA9IGFkZFByb3RvY29sSWZNaXNzaW5nKGhyZWZsaXN0LCAnZmlsZXN5c3RlbScpOyAvLyBGb3IgSFRNTDUgRmlsZVN5c3RlbS5cbiAgICBpbWdsaXN0ID0gYWRkUHJvdG9jb2xJZk1pc3NpbmcoaW1nbGlzdCwgJ2ZpbGVzeXN0ZW0nKTsgLy8gRm9yIEhUTUw1IEZpbGVTeXN0ZW0uXG5cbiAgICAkY29tcGlsZVByb3ZpZGVyLmFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0KGhyZWZsaXN0KTtcbiAgICAkY29tcGlsZVByb3ZpZGVyLmltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdChpbWdsaXN0KTtcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBjb3JlIGluaXQgcHJvY2VzcywgdGhpcyBzaG91bGQgYmUgdGhlIHZlcnkgZmlyc3QgdGhpbmcuXG4gICAgJG1tSW5pdERlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcm9jZXNzKCdtbUFwcEluaXQnLCAnJG1tQXBwLmluaXRQcm9jZXNzJywgbW1Jbml0RGVsZWdhdGVNYXhBZGRvblByaW9yaXR5ICsgNDAwLCB0cnVlKTtcblxuICAgIC8vIFJlZ2lzdGVyIHVwZ3JhZGUgY2hlY2sgcHJvY2VzcywgdGhpcyBzaG91bGQgaGFwcGVuIGFsbW9zdCBiZWZvcmUgZXZlcnl0aGluZyBlbHNlLlxuICAgICRtbUluaXREZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJvY2VzcygnbW1VcGRhdGVNYW5hZ2VyJywgJyRtbVVwZGF0ZU1hbmFnZXIuY2hlY2snLCBtbUluaXREZWxlZ2F0ZU1heEFkZG9uUHJpb3JpdHkgKyAzMDAsIHRydWUpO1xufSlcblxuLnJ1bihmdW5jdGlvbigkaW9uaWNQbGF0Zm9ybSwgJGlvbmljQm9keSwgJHdpbmRvdywgJG1tRXZlbnRzLCAkbW1Jbml0RGVsZWdhdGUsIG1tQ29yZUV2ZW50S2V5Ym9hcmRTaG93LCBtbUNvcmVFdmVudEtleWJvYXJkSGlkZSkge1xuICAgIC8vIEV4ZWN1dGUgYWxsIHRoZSBpbml0IHByb2Nlc3Nlcy5cbiAgICAkbW1Jbml0RGVsZWdhdGUuZXhlY3V0ZUluaXRQcm9jZXNzZXMoKTtcblxuICAgIC8vIFdoZW4gdGhlIHBsYXRmb3JtIGlzIHJlYWR5LlxuICAgICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hlY2tUYWJsZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRpb25pY0JvZHkuZW5hYmxlQ2xhc3MoJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSwgJ3RhYmxldCcpO1xuICAgICAgICB9O1xuICAgICAgICBpb25pYy5vbigncmVzaXplJywgY2hlY2tUYWJsZXQsICR3aW5kb3cpO1xuICAgICAgICBjaGVja1RhYmxldCgpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3Iga2V5Ym9hcmQgZXZlbnRzLiBXZSBkb24ndCB1c2UgJGNvcmRvdmFLZXlib2FyZCBiZWNhdXNlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBrZXlib2FyZEhlaWdodCBwcm9wZXJ0eS5cbiAgICAgICAgJHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRzaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRLZXlib2FyZFNob3csIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgJHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRoaWRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRLZXlib2FyZEhpZGUsIGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQWRkb25NYW5hZ2VyXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzZXJ2aWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyByZWxhdGVkIHRvIGFkZG9ucywgbGlrZSBjaGVja2luZyBpZiBhbiBhZGRvbiBpcyBhdmFpbGFibGUuXG4gKi9cbi5mYWN0b3J5KCckbW1BZGRvbk1hbmFnZXInLCBmdW5jdGlvbigkbG9nLCAkaW5qZWN0b3IpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1BZGRvbk1hbmFnZXInKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGluc3RhbmNlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc2VydmljZSBpbnN0YW5jZSBpZiBpdCdzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1BZGRvbk1hbmFnZXIjZ2V0XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgU2VydmljZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKHNlbGYuaXNBdmFpbGFibGUobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBzZXJ2aWNlIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1BZGRvbk1hbmFnZXIjaXNBdmFpbGFibGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU2VydmljZSBuYW1lLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNBdmFpbGFibGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlc1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2VzW25hbWVdID0gJGluamVjdG9yLmdldChuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAkbG9nLndhcm4oJ1NlcnZpY2Ugbm90IGF2YWlsYWJsZTogJytuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLyoqXG4gKiA9PT09PT09PT09PT09PT09PT0gIGFuZ3VsYXItaW9zOS11aXdlYnZpZXcucGF0Y2guanMgdjEuMS4wID09PT09PT09PT09PT09PT09PVxuICpcbiAqIFRoaXMgcGF0Y2ggd29ya3MgYXJvdW5kIGlPUzkgVUlXZWJWaWV3IHJlZ3Jlc3Npb24gdGhhdCBjYXVzZXMgaW5maW5pdGUgZGlnZXN0XG4gKiBlcnJvcnMgaW4gQW5ndWxhci5cbiAqXG4gKiBUaGUgcGF0Y2ggY2FuIGJlIGFwcGxpZWQgdG8gQW5ndWxhciAxLjIuMCDigJMgMS40LjUuIE5ld2VyIHZlcnNpb25zIG9mIEFuZ3VsYXJcbiAqIGhhdmUgdGhlIHdvcmthcm91bmQgYmFrZWQgaW4uXG4gKlxuICogVG8gYXBwbHkgdGhpcyBwYXRjaCBsb2FkL2J1bmRsZSB0aGlzIGZpbGUgd2l0aCB5b3VyIGFwcGxpY2F0aW9uIGFuZCBhZGQgYVxuICogZGVwZW5kZW5jeSBvbiB0aGUgXCJuZ0lPUzlQYXRjaFwiIG1vZHVsZSB0byB5b3VyIG1haW4gYXBwIG1vZHVsZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIGFuZ3VsYXIubW9kdWxlKCdteUFwcCcsIFsnbmdSb3V0ZSddKWBcbiAqIGBgYFxuICpcbiAqIGJlY29tZXNcbiAqXG4gKiBgYGBcbiAqIGFuZ3VsYXIubW9kdWxlKCdteUFwcCcsIFsnbmdSb3V0ZScsICduZ0lPUzlVSVdlYlZpZXdQYXRjaCddKVxuICogYGBgXG4gKlxuICpcbiAqIE1vcmUgaW5mbzpcbiAqIC0gaHR0cHM6Ly9vcGVucmFkYXIuYXBwc3BvdC5jb20vMjIxODYxMDlcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9pc3N1ZXMvMTIyNDFcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL2RyaWZ0eWNvL2lvbmljL2lzc3Vlcy80MDgyXG4gKlxuICpcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKU1xuICogKGMpIDIwMTAtMjAxNSBHb29nbGUsIEluYy4gaHR0cDovL2FuZ3VsYXJqcy5vcmdcbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmFuZ3VsYXIubW9kdWxlKCduZ0lPUzlVSVdlYlZpZXdQYXRjaCcsIFsnbmcnXSkuY29uZmlnKGZ1bmN0aW9uKCRwcm92aWRlKSB7XG4gICRwcm92aWRlLmRlY29yYXRvcignJGJyb3dzZXInLCBbJyRkZWxlZ2F0ZScsICckd2luZG93JywgZnVuY3Rpb24oJGRlbGVnYXRlLCAkd2luZG93KSB7XG5cbiAgICBpZiAoaXNJT1M5VUlXZWJWaWV3KCR3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIHJldHVybiBhcHBseUlPUzlTaGltKCRkZWxlZ2F0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICRkZWxlZ2F0ZTtcblxuICAgIGZ1bmN0aW9uIGlzSU9TOVVJV2ViVmlldyh1c2VyQWdlbnQpIHtcbiAgICAgIHJldHVybiAvKGlQaG9uZXxpUGFkfGlQb2QpLiogT1MgOV9cXGQvLnRlc3QodXNlckFnZW50KSAmJiAhL1ZlcnNpb25cXC85XFwuLy50ZXN0KHVzZXJBZ2VudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlJT1M5U2hpbShicm93c2VyKSB7XG4gICAgICB2YXIgcGVuZGluZ0xvY2F0aW9uVXJsID0gbnVsbDtcbiAgICAgIHZhciBvcmlnaW5hbFVybEZuPSBicm93c2VyLnVybDtcblxuICAgICAgYnJvd3Nlci51cmwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBwZW5kaW5nTG9jYXRpb25VcmwgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsVXJsRm4uYXBwbHkoYnJvd3NlciwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwZW5kaW5nTG9jYXRpb25VcmwgfHwgb3JpZ2luYWxVcmxGbi5hcHBseShicm93c2VyLCBhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgY2xlYXJQZW5kaW5nTG9jYXRpb25VcmwsIGZhbHNlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgY2xlYXJQZW5kaW5nTG9jYXRpb25VcmwsIGZhbHNlKTtcblxuICAgICAgZnVuY3Rpb24gY2xlYXJQZW5kaW5nTG9jYXRpb25VcmwoKSB7XG4gICAgICAgIHBlbmRpbmdMb2NhdGlvblVybCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicm93c2VyO1xuICAgIH1cbiAgfV0pO1xufSk7IiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLmNvbnN0YW50KCdtbUNvcmVDb25maWdTdG9yZScsICdjb25maWcnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUFwcFByb3ZpZGVyLCBtbUNvcmVDb25maWdTdG9yZSkge1xuICAgIHZhciBzdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1tQ29yZUNvbmZpZ1N0b3JlLFxuICAgICAgICAgICAga2V5UGF0aDogJ25hbWUnXG4gICAgICAgIH1cbiAgICBdO1xuICAgICRtbUFwcFByb3ZpZGVyLnJlZ2lzdGVyU3RvcmVzKHN0b3Jlcyk7XG59KVxuXG4vKipcbiAqIEZhY3RvcnkgdG8gcHJvdmlkZSBhY2Nlc3MgdG8gZHluYW1pYyBhbmQgcGVybWFuZW50IGNvbmZpZyBhbmQgc2V0dGluZ3MuXG4gKiBJdCBzaG91bGQgbm90IGJlIGFidXNlZCBpbnRvIGEgdGVtcG9yYXJ5IHN0b3JhZ2UuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQ29uZmlnXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgYXBwIHNldHRpbmdzLlxuICovXG4uZmFjdG9yeSgnJG1tQ29uZmlnJywgZnVuY3Rpb24oJHEsICRsb2csICRtbUFwcCwgbW1Db3JlQ29uZmlnU3RvcmUpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Db25maWcnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gYXBwIHNldHRpbmcuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ29uZmlnI2dldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICAgICAgICBUaGUgY29uZmlnIG5hbWUuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gIFtkZWZhdWx0VmFsdWVdIERlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHRoZSBlbnRyeSBpcyBub3QgZm91bmQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFJlc29sdmVzIHVwb24gc3VjY2VzcyBhbG9uZyB3aXRoIHRoZSBjb25maWcgZGF0YS4gUmVqZWN0IG9uIGZhaWx1cmUuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogR2V0IGFuIGFwcCBzZXR0aW5nLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0ID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5nZXQobW1Db3JlQ29uZmlnU3RvcmUsIG5hbWUpLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBhbiBhcHAgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBzZXJ2aWNlXG4gICAgICogQG5hbWUgJG1tQ29uZmlnI3NldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBjb25maWcgbmFtZS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgY29uZmlnIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgb24gc3VjY2VzcywgcHJvdmlkaW5nIG5vIGRhdGEuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2V0IGFuIGFwcCBzZXR0aW5nLlxuICAgICAqL1xuICAgIHNlbGYuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmluc2VydChtbUNvcmVDb25maWdTdG9yZSwge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIGFwcCBzZXR0aW5nLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvbmZpZyNkZWxldGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgY29uZmlnIG5hbWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgUHJvbWlzZSB3aGljaCByZXNvbHZlcyBvbiBzdWNjZXNzLCBwcm92aWRpbmcgbm8gZGF0YS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBEZWxldGUgYW4gYXBwIHNldHRpbmcuXG4gICAgICovXG4gICAgc2VsZi5kZWxldGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5yZW1vdmUobW1Db3JlQ29uZmlnU3RvcmUsIG5hbWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tREJcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHNlcnZpY2UgYWxsb3dzIHRvIGludGVyYWN0IHdpdGggdGhlIGxvY2FsIGRhdGFiYXNlIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBkYXRhLlxuICovXG4uZmFjdG9yeSgnJG1tREInLCBmdW5jdGlvbigkcSwgJGxvZykge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbURCJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBkYkluc3RhbmNlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVudCBoZWxwZXIgdG8gYXBwbHkgYW4gb3JkZXIgdG8gYSBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIFtxdWVyeV0gICBBIHF1ZXJ5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbb3JkZXJdICAgVGhlIGZpZWxkIHRvIG9yZGVyIG9uLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtyZXZlcnNlXSBXaGV0aGVyIHRvIHJldmVyc2UgdGhlIHJlc3VsdHMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgVGhlIHVwZGF0ZWQgcXVlcnkgb2JqZWN0IChvciBpbml0aWFsIG9uZSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwbHlPcmRlcihxdWVyeSwgb3JkZXIsIHJldmVyc2UpIHtcbiAgICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyKG9yZGVyKTtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbnQgaGVscGVyIHRvIGFwcGx5IGEgd2hlcmUgY29uZGl0aW9uIHRvIGEgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtxdWVyeV0gICBBIHF1ZXJ5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIFt3aGVyZV0gICBBcnJheSBvZiBwYXJhbWV0ZXJzLCBpbiBvcmRlcjpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBmaWVsZCB0byBmaWx0ZXIgb25cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBvcGVyYXRvcjogPCwgPD0sID0sID4sID49LCBeIChzdGFydHMgd2l0aClcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSB2YWx1ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQW4gYWRkaXRpb25hbCBvcGVyYXRvclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQW4gYWRkaXRpb25hbCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHVwZGF0ZWQgcXVlcnkgb2JqZWN0IChvciBpbml0aWFsIG9uZSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwbHlXaGVyZShxdWVyeSwgd2hlcmUpIHtcbiAgICAgICAgaWYgKHdoZXJlICYmIHdoZXJlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUuYXBwbHkocXVlcnksIHdoZXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBhIERCIHNpbXBsZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICBkYiAgICAgIERCIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBmdW5jICAgIE5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIG9wZXJhdGlvbiBmaW5pc2hlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsREJGdW5jdGlvbihkYiwgZnVuYykge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGRiKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRiW2Z1bmNdLmFwcGx5KGRiLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHJlc3VsdCkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciBleGVjdXRpbmcgZnVuY3Rpb24gJytmdW5jKycgdG8gREIgJytkYi5nZXROYW1lKCkpO1xuICAgICAgICAgICAgJGxvZy5lcnJvcihleC5uYW1lKyc6ICcrZXgubWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjb3VudCBvZiBlbnRyaWVzIG1hdGNoaW5nIGNlcnRhaW4gY29uZGl0aW9ucy5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICBkYiAgICAgICAgIERCIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBzdG9yZSAgICAgIE5hbWUgb2YgdGhlIHN0b3JlIHRvIGdldCB0aGUgZW50cmllcyBmcm9tLlxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgIHdoZXJlICAgICAgQXJyYXkgb2Ygd2hlcmUgY29uZGl0aW9ucywgc2VlIGFwcGx5V2hlcmUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsQ291bnQoZGIsIHN0b3JlLCB3aGVyZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgcXVlcnk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZGIpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBkYi5mcm9tKHN0b3JlKTtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IGFwcGx5V2hlcmUocXVlcnksIHdoZXJlKTtcbiAgICAgICAgICAgICAgICBxdWVyeS5jb3VudCgpLnRoZW4oZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShjb3VudCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgcXVlcnlpbmcgZGIgJytkYi5nZXROYW1lKCkrJy4gJytleC5uYW1lKyc6ICcrZXgubWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGVudHJpZXMgbWF0Y2hpbmcgY2VydGFpbiBjb25kaXRpb25zLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIGRiICAgICAgICAgREIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHN0b3JlICAgICAgTmFtZSBvZiB0aGUgc3RvcmUgdG8gZ2V0IHRoZSBlbnRyaWVzIGZyb20uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgZmllbGRfbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0aGF0IHNob3VsZCBtYXRjaCB0aGUgY29uZGl0aW9ucy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBvcCAgICAgICAgIEZpcnN0IG9wZXJhdG9yIHN5bWJvbC4gT25lIG9mICc8JywgJzw9JywgJz0nLCAnPicsICc+PScsICdeJy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB2YWx1ZSAgICAgIFZhbHVlIGZvciB0aGUgZmlyc3Qgb3BlcmF0b3IuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgb3AyICAgICAgICBTZWNvbmQgb3BlcmF0b3Igc3ltYm9sLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHZhbHVlMiAgICAgVmFsdWUgZm9yIHRoZSBzZWNvbmQgb3BlcmF0b3IuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGxpc3QgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGxXaGVyZShkYiwgc3RvcmUsIGZpZWxkX25hbWUsIG9wLCB2YWx1ZSwgb3AyLCB2YWx1ZTIpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihkYikgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkYi5mcm9tKHN0b3JlKS53aGVyZShmaWVsZF9uYW1lLCBvcCwgdmFsdWUsIG9wMiwgdmFsdWUyKS5saXN0KCkudGhlbihmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobGlzdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgcXVlcnlpbmcgZGIgJytkYi5nZXROYW1lKCkrJy4gJytleC5uYW1lKyc6ICcrZXgubWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGVudHJpZXMgd2hlcmUgYSBjZXJ0YWluIGZpZWxkIGlzIGVxdWFsIHRvIGEgY2VydGFpbiB2YWx1ZS5cbiAgICAgKiBJbXBvcnRhbnQ6IHRoZSBmaWVsZCBtdXN0IGJlIGFuIGluZGV4LlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIGRiICAgICAgICAgREIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHN0b3JlICAgICAgTmFtZSBvZiB0aGUgc3RvcmUgdG8gZ2V0IHRoZSBlbnRyaWVzIGZyb20uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgZmllbGRfbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB2YWx1ZSAgICAgIFZhbHVlIHRoZSBmaWVsZCBzaG91bGQgYmUgZXF1YWwgdG8uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGxpc3QgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGxXaGVyZUVxdWFsKGRiLCBzdG9yZSwgZmllbGRfbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihkYikgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkYi5mcm9tKHN0b3JlKS53aGVyZShmaWVsZF9uYW1lLCAnPScsIHZhbHVlKS5saXN0KCkudGhlbihmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobGlzdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgZ2V0dGluZyB3aGVyZSBlcXVhbCBmcm9tIGRiICcrZGIuZ2V0TmFtZSgpKycuICcrZXgubmFtZSsnOiAnK2V4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhbiBvcGVyYXRpb24gd2l0aCBldmVyeSBlbnRyeSBpbiBhIGNlcnRhaW4gc3RvcmUuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgIGRiICAgICAgIERCIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgc3RvcmUgICAgTmFtZSBvZiB0aGUgc3RvcmUgdG8gZ2V0IHRoZSBlbnRyaWVzIGZyb20uXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBlYWNoIGVudHJ5LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHRoZSBvcGVyYXRpb24gaGFzIGJlZW4gYXBwbGllZCB0byBhbGwgZW50cmllcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsRWFjaChkYiwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgY2FsbERCRnVuY3Rpb24oZGIsICd2YWx1ZXMnLCBzdG9yZSwgdW5kZWZpbmVkLCA5OTk5OTk5OSkudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbnRyaWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZW50cmllcyBtYXRjaGluZyBjZXJ0YWluIGNvbmRpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICBkYiAgICAgIERCIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBzdG9yZSAgIE5hbWUgb2YgdGhlIHN0b3JlIHRvIGdldCB0aGUgZW50cmllcyBmcm9tLlxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgIHdoZXJlICAgQXJyYXkgb2Ygd2hlcmUgY29uZGl0aW9ucywgc2VlIGFwcGx5V2hlcmUuXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgb3JkZXIgICBUaGUga2V5IHRvIG9yZGVyIG9uLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHJldmVyc2UgV2hldGhlciB0byByZXZlcnNlIHRoZSBvcmRlci5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBsaW1pdCAgIFRoZSBudW1iZXIgb2YgcmVzdWx0IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvUXVlcnkoZGIsIHN0b3JlLCB3aGVyZSwgb3JkZXIsIHJldmVyc2UsIGxpbWl0KSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICBxdWVyeTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihkYikgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IGRiLmZyb20oc3RvcmUpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gYXBwbHlXaGVyZShxdWVyeSwgd2hlcmUpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gYXBwbHlPcmRlcihxdWVyeSwgb3JkZXIsIHJldmVyc2UpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5Lmxpc3QobGltaXQpLnRoZW4oZnVuY3Rpb24obGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGxpc3QpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIHF1ZXJ5aW5nICcgKyBzdG9yZSArICcgb24gJyArIGRiLmdldE5hbWUoKSArICcuICcgKyBleC5uYW1lICsgJzogJyArIGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBsaXN0IG9mIGVudHJpZXMgbWF0Y2hpbmcgY29uZGl0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIGRiICAgICAgREIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHN0b3JlICAgTmFtZSBvZiB0aGUgc3RvcmUgdG8gZ2V0IHRoZSBlbnRyaWVzIGZyb20uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgdmFsdWVzICBUaGUgdmFsdWVzIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICB3aGVyZSAgIEFuIGFycmF5IG9mIHdoZXJlKCkgcGFyYW1ldGVycy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvVXBkYXRlKGRiLCBzdG9yZSwgdmFsdWVzLCB3aGVyZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgcXVlcnk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZGIpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBkYi5mcm9tKHN0b3JlKTtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IGFwcGx5V2hlcmUocXVlcnksIHdoZXJlKTtcbiAgICAgICAgICAgICAgICBxdWVyeS5wYXRjaCh2YWx1ZXMpLnRoZW4oZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShjb3VudCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgcXVlcnlpbmcgJyArIHN0b3JlICsgJyBvbiAnICsgZGIuZ2V0TmFtZSgpICsgJy4gJyArIGV4Lm5hbWUgKyAnOiAnICsgZXgubWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBkYXRhYmFzZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgZGF0YWJhc2Ugb2JqZWN0cyBhcmUgY2FjaGVkIHN0YXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tREIjZ2V0REJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgICAgREIgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjaGVtYSAgREIgc2NoZW1hLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBEQiBvcHRpb25zLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBEQi5cbiAgICAgKi9cbiAgICBzZWxmLmdldERCID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGJJbnN0YW5jZXNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgICAgIHZhciBpc1NhZmFyaSA9ICFpb25pYy5QbGF0Zm9ybS5pc0lPUygpICYmICFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1NhZmFyaScpICE9IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA9PSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PSAtMTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgSURCT2JqZWN0U3RvcmUgPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIElEQk9iamVjdFN0b3JlLnByb3RvdHlwZS5jb3VudCA9PSAndW5kZWZpbmVkJyB8fCBpc1NhZmFyaSkge1xuICAgICAgICAgICAgICAgIC8vIEluZGV4ZWREQiBub3QgaW1wbGVtZW50ZWQgb3Igbm90IGZ1bGx5IGltcGxlbWVudGVkIChHYWxheHkgUzQgTWluaSkuIFVzZSBXZWJTUUwuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1lY2hhbmlzbXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZWNoYW5pc21zID0gWyd3ZWJzcWwnLCAnc3FsaXRlJywgJ2xvY2Fsc3RvcmFnZScsICdzZXNzaW9uc3RvcmFnZScsICd1c2VyZGF0YScsICdtZW1vcnknXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBvcHRpb25zLm1lY2hhbmlzbXMuaW5kZXhPZignaW5kZXhlZGRiJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZWNoYW5pc21zLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYiA9IG5ldyB5ZG4uZGIuU3RvcmFnZShuYW1lLCBzY2hlbWEsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBkYkluc3RhbmNlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXQgREIgbmFtZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gREIgbmFtZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBnZXROYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLmdldE5hbWUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldCBhbiBlbnRyeSBmcm9tIGEgc3RvcmUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmUgTmFtZSBvZiB0aGUgc3RvcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gIGlkICAgIEVudHJ5J3MgaWRlbnRpZmllciAocHJpbWFyeSBrZXkgLyBrZXlQYXRoKS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBlbnRyeSBpcyByZXRyaWV2ZWQuIFJlc29sdmUgcGFyYW06IERCIGVudHJ5IChvYmplY3QpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oc3RvcmUsIGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsREJGdW5jdGlvbihkYiwgJ2dldCcsIHN0b3JlLCBpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXQgYWxsIHRoZSBlbnRyaWVzIGZyb20gYSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdG9yZSBOYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBlbnRyaWVzIGFyZSByZXRyaWV2ZWQuIFJlc29sdmUgcGFyYW06IERCIGVudHJpZXMgKGFycmF5KS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBnZXRBbGw6IGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsREJGdW5jdGlvbihkYiwgJ3ZhbHVlcycsIHN0b3JlLCB1bmRlZmluZWQsIDk5OTk5OTk5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiBhIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlIE5hbWUgb2YgdGhlIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFt3aGVyZV0gQXJyYXkgb2Ygd2hlcmUgY29uZGl0aW9ucywgc2VlIGFwcGx5V2hlcmUuXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY291bnQgaXMgZG9uZS4gUmVzb2x2ZSBwYXJhbTogbnVtYmVyIG9mIGVudHJpZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY291bnQ6IGZ1bmN0aW9uKHN0b3JlLCB3aGVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbENvdW50KGRiLCBzdG9yZSwgd2hlcmUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQWRkIGFuIGVudHJ5IHRvIGEgc3RvcmUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmUgTmFtZSBvZiB0aGUgc3RvcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIE9iamVjdCB0byBzdG9yZS4gUHJpbWFyeSBrZXkgKGtleVBhdGgpIGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SURiS2V5fSBpZCBUaGUga2V5IHdoZW4gbmVlZGVkLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJ5IGlzIGluc2VydGVkLiBSZXNvbHZlIHBhcmFtOiBuZXcgZW50cnkncyBwcmltYXJ5IGtleS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uKHN0b3JlLCB2YWx1ZSwgaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxEQkZ1bmN0aW9uKGRiLCAncHV0Jywgc3RvcmUsIHZhbHVlLCBpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBZGQgYW4gZW50cnkgdG8gYSBzdG9yZSwgcmV0dXJuaW5nIGEgc3luY2hyb25vdXMgdmFsdWUuXG4gICAgICAgICAgICAgICAgICogUGxlYXNlIHVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgaWYgc3luY2hyb25vdXMgaXMgYSBtdXN0LCB5b3Ugc2hvdWxkIGFsd2F5cyB1c2UgJG1tREIjaW5zZXJ0LlxuICAgICAgICAgICAgICAgICAqIFRha2UgaW50byBhY2NvdW50IHRoYXQgdGhlIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgQkVGT1JFIHRoZSB2YWx1ZSBpcyBhY3R1YWxseSBzdG9yZWQuIFRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgICAgICAgICAgICAgKiBib29sZWFuIHJldHVybmVkIG9ubHkgaW5kaWNhdGVzIGlmIGl0IGhhcyBwYXNzZWQgdGhlIGZpcnN0IHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmUgTmFtZSBvZiB0aGUgc3RvcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIE9iamVjdCB0byBzdG9yZS4gUHJpbWFyeSBrZXkgKGtleVBhdGgpIGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIGRhdGEgdG8gaW5zZXJ0IGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuIFJldHVybmluZyB0cnVlIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICBkYXRhIGhhcyBiZWVuIHN0b3JlZCwgdGhpcyBmdW5jdGlvbiBjYW4gcmV0dXJuIHRydWUgYnV0IHRoZSBpbnNlcnRpb24gY2FuIHN0aWxsIGZhaWwuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5zZXJ0U3luYzogZnVuY3Rpb24oc3RvcmUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5wdXQoc3RvcmUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciBleGVjdXRpbmcgZnVuY3Rpb24gc3luYyBwdXQgdG8gREIgJytkYi5nZXROYW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoZXgubmFtZSsnOiAnK2V4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUXVlcnkgdGhlIGRhdGFiYXNlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlIE5hbWUgb2YgdGhlIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFt3aGVyZV0gQXJyYXkgb2Ygd2hlcmUgY29uZGl0aW9ucywgc2VlIGFwcGx5V2hlcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcmRlcl0gVGhlIGtleSB0byBzb3J0IHRoZSByZXN1bHRzIHdpdGguXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbcmV2ZXJzZT1mYWxzZV0gV2hldGhlciB0byByZXZlcnNlIHRoZSByZXN1bHRzLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIFRoZSBudW1iZXIgb2YgcmVzdWx0cyB0byByZXR1cm4uXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIGVudHJpZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcXVlcnk6IGZ1bmN0aW9uKHN0b3JlLCB3aGVyZSwgb3JkZXIsIHJldmVyc2UsIGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb1F1ZXJ5KGRiLCBzdG9yZSwgd2hlcmUsIG9yZGVyLCByZXZlcnNlLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGFuIGVudHJ5IGZyb20gYSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdG9yZSBOYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSAgaWQgICAgRW50cnkncyBpZGVudGlmaWVyIChwcmltYXJ5IGtleSAvIGtleVBhdGgpLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJ5IGlzIGRlbGV0ZWQuIFJlc29sdmUgcGFyYW06IG51bWJlciBvZiBlbnRyaWVzIGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihzdG9yZSwgaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxEQkZ1bmN0aW9uKGRiLCAncmVtb3ZlJywgc3RvcmUsIGlkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYWxsIGVudHJpZXMgZnJvbSBhIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlIE5hbWUgb2YgdGhlIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJpZXMgYXJlIGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbihzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbERCRnVuY3Rpb24oZGIsICdjbGVhcicsIHN0b3JlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVwZGF0ZSByZWNvcmRzIG1hdGNoaW5nLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlIE5hbWUgb2YgdGhlIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW3doZXJlXSBBcnJheSBvZiB3aGVyZSBjb25kaXRpb25zLCBzZWUgYXBwbHlXaGVyZS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oc3RvcmUsIHZhbHVlcywgd2hlcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvVXBkYXRlKGRiLCBzdG9yZSwgdmFsdWVzLCB3aGVyZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGVudHJpZXMgd2hlcmUgYSBmaWVsZCBtYXRjaCBjZXJ0YWluIGNvbmRpdGlvbnMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmUgICAgICBOYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGRfbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3AgICAgICAgICBGaXJzdCBvcGVyYXRvciB0byBhcHBseSB0byB0aGUgZmllbGQuIDwsIDw9LCA9LCA+LCA+PSwgXiAoc3RhcnQgd2l0aCkuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gIHZhbHVlICAgICAgVmFsdWUgdG8gY29tcGFyZSB1c2luZyB0aGUgZmlyc3Qgb3BlcmF0b3IuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wMiAgICAgICAgU2Vjb25kIG9wZXJhdG9yIHRvIGFwcGx5IHRvIHRoZSBmaWVsZC4gT3B0aW9uYWwuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gIHZhbHVlMiAgICAgVmFsdWUgdG8gY29tcGFyZSB1c2luZyB0aGUgc2Vjb25kIG9wZXJhdG9yLiBPcHRpb25hbC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJpZXMgYXJlIHJldHJpZXZlZC4gUmVzb2x2ZSBwYXJhbTogZW50cmllcyAoYXJyYXkpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHdoZXJlOiBmdW5jdGlvbihzdG9yZSwgZmllbGRfbmFtZSwgb3AsIHZhbHVlLCBvcDIsIHZhbHVlMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdoZXJlKGRiLCBzdG9yZSwgZmllbGRfbmFtZSwgb3AsIHZhbHVlLCBvcDIsIHZhbHVlMik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGVudHJpZXMgd2hlcmUgYSBmaWVsZCBpcyBlcXVhbCB0byBhIGNlcnRhaW4gdmFsdWUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmUgICAgICBOYW1lIG9mIHRoZSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGRfbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSAgdmFsdWUgICAgICBWYWx1ZSB0byBjb21wYXJlIHRvIHRoZSBmaWVsZC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJpZXMgYXJlIHJldHJpZXZlZC4gUmVzb2x2ZSBwYXJhbTogZW50cmllcyAoYXJyYXkpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHdoZXJlRXF1YWw6IGZ1bmN0aW9uKHN0b3JlLCBmaWVsZF9uYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdoZXJlRXF1YWwoZGIsIHN0b3JlLCBmaWVsZF9uYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDYWxsIGEgZnVuY3Rpb24gd2l0aCBlYWNoIG9mIHRoZSBlbnRyaWVzIGZyb20gYSBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdG9yZSAgICAgIE5hbWUgb2YgdGhlIHN0b3JlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBlYWNoIGVudHJ5LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBhbGwgZW50cmllcy4gTm8gcmVzb2x2ZSBwYXJhbXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24oc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsRWFjaChkYiwgc3RvcmUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENsb3NlIHRoZSBkYXRhYmFzZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGRiID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2FsbCBhIGNhbGxiYWNrIG9uY2UgREIgaXMgcmVhZHkuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBjYWxsLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG9uUmVhZHk6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLm9uUmVhZHkoY2IpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogR2V0IHN0b3JhZ2UgdHlwZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RvcmFnZSB0eXBlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRiSW5zdGFuY2VzW25hbWVdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBEQi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1EQiNkZWxldGVEQlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSAgIERCIG5hbWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIERCIGlzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgc2VsZi5kZWxldGVEQiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICBmdW5jdGlvbiBkZWxldGVEQigpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkYkluc3RhbmNlc1tuYW1lXTtcbiAgICAgICAgICAgICRxLndoZW4oeWRuLmRiLmRlbGV0ZURhdGFiYXNlKG5hbWUpKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRiSW5zdGFuY2VzW25hbWVdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgREIgaW5zdGFuY2UuIFdhaXQgZm9yIGl0IHRvIGJlIHJlYWR5IGJlZm9yZSBkZWxldGluZyB0aGUgREIuXG4gICAgICAgICAgICBkYkluc3RhbmNlc1tuYW1lXS5vblJlYWR5KGRlbGV0ZURCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZURCKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tRW11bGF0b3JNYW5hZ2VyXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzZXJ2aWNlIGhhbmRsZXMgdGhlIGVtdWxhdGlvbiBvZiBDb3Jkb3ZhIHBsdWdpbnMgaW4gb3RoZXIgZW52aXJvbm1lbnRzIGxpa2UgYnJvd3Nlci5cbiAqL1xuLmZhY3RvcnkoJyRtbUVtdWxhdG9yTWFuYWdlcicsIGZ1bmN0aW9uKCRsb2csICRxLCAkaHR0cCwgJG1tRlMsICR3aW5kb3cpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1FbXVsYXRvck1hbmFnZXInKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBIVE1MIEFQSSB0byBzaW11bGF0ZSBDb3Jkb3ZhIEFQSXMuIFJlc2VydmVkIGZvciBjb3JlIHVzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1FbXVsYXRvck1hbmFnZXIjbG9hZEhUTUxBUElcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIEFQSSBpcyBsb2FkZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYubG9hZEhUTUxBUEkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnU3RvcCBsb2FkaW5nIEhUTUwgQVBJLCBpdCB3YXMgYWxyZWFkeSBsb2FkZWQgb3IgdGhlIGVudmlyb25tZW50IGRvZXNuXFwndCBuZWVkIGl0LicpO1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICBiYXNlUGF0aDtcblxuICAgICAgICAkbG9nLmRlYnVnKCdMb2FkaW5nIEhUTUwgQVBJLicpO1xuXG4gICAgICAgIC8vIEZpbGUgQVBJLlxuICAgICAgICAkd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtICA9ICR3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0gfHwgJHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbTtcbiAgICAgICAgJHdpbmRvdy5yZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMID0gJHdpbmRvdy5yZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMIHx8wqAkd2luZG93LndlYmtpdFJlc29sdmVMb2NhbEZpbGVTeXN0ZW1VUkw7XG5cbiAgICAgICAgJHdpbmRvdy5Mb2NhbEZpbGVTeXN0ZW0gPSB7XG4gICAgICAgICAgICBQRVJTSVNURU5UOiAxXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRmlsZVRyYW5zZmVyIEFQSS5cbiAgICAgICAgJHdpbmRvdy5GaWxlVHJhbnNmZXIgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgICAgICR3aW5kb3cuRmlsZVRyYW5zZmVyLnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uKHVybCwgZmlsZVBhdGgsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgJGh0dHAuZ2V0KHVybCwge3Jlc3BvbnNlVHlwZTogJ2Jsb2InfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGgucmVwbGFjZShiYXNlUGF0aCwgJycpOyAvLyBSZW1vdmUgYmFzZVBhdGggZnJvbSB0aGUgZmlsZVBhdGguXG4gICAgICAgICAgICAgICAgICAgICRtbUZTLndyaXRlRmlsZShmaWxlUGF0aCwgZGF0YS5kYXRhKS50aGVuKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29yZG92YSBaSVAgcGx1Z2luLlxuICAgICAgICAkd2luZG93LnppcCA9IHtcbiAgICAgICAgICAgIHVuemlwOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uLCBjYWxsYmFjaywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBiYXNlUGF0aCBmcm9tIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uLlxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKGJhc2VQYXRoLCAnJyk7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbi5yZXBsYWNlKGJhc2VQYXRoLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAkbW1GUy5yZWFkRmlsZShzb3VyY2UsICRtbUZTLkZPUk1BVEFSUkFZQlVGRkVSKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHppcCA9IG5ldyBKU1ppcChkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHppcC5maWxlcywgZnVuY3Rpb24oZmlsZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVwYXRoID0gJG1tRlMuY29uY2F0ZW5hdGVQYXRocyhkZXN0aW5hdGlvbiwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlLmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgYSBmaWxlLiBHZXQgdGhlIG1pbWV0eXBlIGFuZCB3cml0ZSB0aGUgZmlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJG1tRlMuZ2V0TWltZVR5cGUoJG1tRlMuZ2V0RmlsZUV4dGVuc2lvbihuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GUy53cml0ZUZpbGUoZmlsZXBhdGgsIG5ldyBCbG9iKFtmaWxlLmFzQXJyYXlCdWZmZXIoKV0sIHt0eXBlOiB0eXBlfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBhIGZvbGRlciwgY3JlYXRlIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GUy5jcmVhdGVEaXIoZmlsZXBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yLlxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygtMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQHRvZG86IEltcGxlbWVudCBGaWxlVHJhbnNmZXIudXBsb2FkLlxuXG4gICAgICAgIC8vIFJlcXVlc3QgNTAwTUIuXG4gICAgICAgICR3aW5kb3cud2Via2l0U3RvcmFnZUluZm8ucmVxdWVzdFF1b3RhKFBFUlNJU1RFTlQsIDUwMCAqIDEwMjQgKiAxMDI0LCBmdW5jdGlvbihncmFudGVkKSB7XG4gICAgICAgICAgICAkd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKFBFUlNJU1RFTlQsIGdyYW50ZWQsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgYmFzZVBhdGggPSBlbnRyeS5yb290LnRvVVJMKCk7XG4gICAgICAgICAgICAgICAgJG1tRlMuc2V0SFRNTEJhc2VQYXRoKGJhc2VQYXRoKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICB9LCBkZWZlcnJlZC5yZWplY3QpO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tSW5pdERlbGVnYXRlUHJvdmlkZXIsIG1tSW5pdERlbGVnYXRlTWF4QWRkb25Qcmlvcml0eSkge1xuICAgIGlmICghaW9uaWMuUGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcbiAgICAgICAgJG1tSW5pdERlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcm9jZXNzKCdtbUVtdWxhdG9yJywgJyRtbUVtdWxhdG9yTWFuYWdlci5sb2FkSFRNTEFQSScsXG4gICAgICAgICAgICAgICAgbW1Jbml0RGVsZWdhdGVNYXhBZGRvblByaW9yaXR5ICsgNTAwLCB0cnVlKTtcbiAgICB9XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi5jb25zdGFudCgnbW1Db3JlRXZlbnRLZXlib2FyZFNob3cnLCAna2V5Ym9hcmRfc2hvdycpXG4uY29uc3RhbnQoJ21tQ29yZUV2ZW50S2V5Ym9hcmRIaWRlJywgJ2tleWJvYXJkX2hpZGUnKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudFNlc3Npb25FeHBpcmVkJywgJ3Nlc3Npb25fZXhwaXJlZCcpXG4uY29uc3RhbnQoJ21tQ29yZUV2ZW50TG9naW4nLCAnbG9naW4nKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudExvZ291dCcsICdsb2dvdXQnKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudExhbmd1YWdlQ2hhbmdlZCcsICdsYW5ndWFnZV9jaGFuZ2VkJylcbi5jb25zdGFudCgnbW1Db3JlRXZlbnRTaXRlQWRkZWQnLCAnc2l0ZV9hZGRlZCcpXG4uY29uc3RhbnQoJ21tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQnLCAnc2l0ZV91cGRhdGVkJylcbi5jb25zdGFudCgnbW1Db3JlRXZlbnRTaXRlRGVsZXRlZCcsICdzaXRlX2RlbGV0ZWQnKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudFF1ZXVlRW1wdHknLCAnZmlsZXBvb2xfcXVldWVfZW1wdHknKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudENvbXBsZXRpb25Nb2R1bGVWaWV3ZWQnLCAnY29tcGxldGlvbl9tb2R1bGVfdmlld2VkJylcbi5jb25zdGFudCgnbW1Db3JlRXZlbnRVc2VyRGVsZXRlZCcsICd1c2VyX2RlbGV0ZWQnKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkJywgJ2ZpbGVwb29sX3BhY2thZ2Vfc3RhdHVzX2NoYW5nZWQnKVxuLmNvbnN0YW50KCdtbUNvcmVFdmVudFNlY3Rpb25TdGF0dXNDaGFuZ2VkJywgJ3NlY3Rpb25fc3RhdHVzX2NoYW5nZWQnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gc2VuZCBhbmQgbGlzdGVuIHRvIGV2ZW50cy5cbiAqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tRXZlbnRzXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzZXJ2aWNlIGFsbG93cyBzZW5kaW5nIGFuZCBsaXN0ZW5pbmcgdG8gZXZlbnRzIGluIHRoZSBNb29kbGUgTW9iaWxlIGFwcC5cbiAqL1xuLmZhY3RvcnkoJyRtbUV2ZW50cycsIGZ1bmN0aW9uKCRsb2csIG1kNSkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUV2ZW50cycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgb2JzZXJ2ZXJzID0ge30sXG4gICAgICAgIHVuaXF1ZUV2ZW50cyA9IHt9LFxuICAgICAgICB1bmlxdWVFdmVudHNEYXRhID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIG9ic2VydmVyIGZvciBhIGNlcnRhaW4gZXZlbnQuXG4gICAgICogVG8gZGVyZWdpc3RlciB0aGUgZXZlbnQ6XG4gICAgICogdmFyIG9ic2VydmVyID0gJG1tRXZlbnRzLm9uKCdzb21ldGhpbmcnLCBteUNhbGxCYWNrKTtcbiAgICAgKiBvYnNlcnZlci5vZmYoKTtcbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1FdmVudHMjb25cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnROYW1lICBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG8uXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxCYWNrICAgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgT2JqZWN0IHRvIGRlcmVnaXN0ZXIgdGhlIG9ic2VydmVyLiBVbmRlZmluZWQgaWYgaXQncyBhbiBhbHJlYWR5IHRyaWdnZXJlZCB1bmlxdWUgZXZlbnQuXG4gICAgICovXG4gICAgc2VsZi5vbiA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbEJhY2spIHtcblxuICAgICAgICAvLyBJZiBpdCdzIGEgdW5pcXVlIGV2ZW50IGFuZCBoYXMgYmVlbiB0cmlnZ2VyZWQgYWxyZWFkeSwgY2FsbCB0aGUgY2FsbEJhY2suXG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gc3RvcmUgdGhlIG9ic2VydmVyIGJlY2F1c2UgdGhlIGV2ZW50IHdvbid0IGJlIHRyaWdnZXJlZCBhZ2Fpbi5cbiAgICAgICAgaWYgKHVuaXF1ZUV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBjYWxsQmFjayh1bmlxdWVFdmVudHNEYXRhW2V2ZW50TmFtZV0pO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGEgZmFrZSBvYnNlcnZlciB0byBwcmV2ZW50IGVycm9ycy5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IC0xLFxuICAgICAgICAgICAgICAgIG9mZjogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvYnNlcnZlcklEO1xuXG4gICAgICAgIGlmICh0eXBlb2Yob2JzZXJ2ZXJzW2V2ZW50TmFtZV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzW2V2ZW50TmFtZV0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0eXBlb2Yob2JzZXJ2ZXJJRCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlSUQgPSBtZDUuY3JlYXRlSGFzaChNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihvYnNlcnZlcnNbZXZlbnROYW1lXVtjYW5kaWRhdGVJRF0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9ic2VydmVySUQgPSBjYW5kaWRhdGVJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAkbG9nLmRlYnVnKCdPYnNlcnZlciAnICsgb2JzZXJ2ZXJJRCArICcgbGlzdGVuaW5nIHRvIGV2ZW50ICcrZXZlbnROYW1lKTtcblxuICAgICAgICBvYnNlcnZlcnNbZXZlbnROYW1lXVtvYnNlcnZlcklEXSA9IGNhbGxCYWNrO1xuXG4gICAgICAgIC8vIENyZWF0ZSBvYnNlcnZlciBvYmplY3QgdG8gZGVyZWdpc3RlciB0aGUgbGlzdGVuZXIuXG4gICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIGlkOiBvYnNlcnZlcklELFxuICAgICAgICAgICAgb2ZmOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdEaXNhYmxlIG9ic2VydmVyICcgKyBvYnNlcnZlcklEICsgJyBmb3IgZXZlbnQgJytldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYnNlcnZlcnNbZXZlbnROYW1lXVtvYnNlcnZlcklEXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhbiBldmVudCwgbm90aWZ5aW5nIGFsbCB0aGUgb2JzZXJ2ZXJzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUV2ZW50cyN0cmlnZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyaWdnZXIuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gIGRhdGEgIERhdGEgdG8gcGFzcyB0byB0aGUgb2JzZXJ2ZXJzLlxuICAgICAqL1xuICAgIHNlbGYudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICAkbG9nLmRlYnVnKCdFdmVudCAnICsgZXZlbnROYW1lICsgJyB0cmlnZ2VyZWQuJyk7XG4gICAgICAgIHZhciBhZmZlY3RlZCA9IG9ic2VydmVyc1tldmVudE5hbWVdO1xuICAgICAgICBmb3IgKHZhciBvYnNlcnZlck5hbWUgaW4gYWZmZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoYWZmZWN0ZWRbb2JzZXJ2ZXJOYW1lXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZFtvYnNlcnZlck5hbWVdKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgdW5pcXVlIGV2ZW50LCBub3RpZnlpbmcgYWxsIHRoZSBvYnNlcnZlcnMuIElmIHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIHRyaWdnZXJlZCwgZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRXZlbnRzI3RyaWdnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJpZ2dlci5cbiAgICAgKiBAcGFyYW0ge01peGVkfSAgZGF0YSAgRGF0YSB0byBwYXNzIHRvIHRoZSBvYnNlcnZlcnMuXG4gICAgICovXG4gICAgc2VsZi50cmlnZ2VyVW5pcXVlID0gZnVuY3Rpb24oZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgIGlmICh1bmlxdWVFdmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVW5pcXVlIGV2ZW50ICcgKyBldmVudE5hbWUgKyAnIGlnbm9yZWQgYmVjYXVzZSBpdCB3YXMgYWxyZWFkeSB0cmlnZ2VyZWQuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdVbmlxdWUgZXZlbnQgJyArIGV2ZW50TmFtZSArICcgdHJpZ2dlcmVkLicpO1xuICAgICAgICAgICAgdW5pcXVlRXZlbnRzW2V2ZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgdW5pcXVlRXZlbnRzRGF0YVtldmVudE5hbWVdID0gZGF0YTtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZCA9IG9ic2VydmVyc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGFmZmVjdGVkLCBmdW5jdGlvbihjYWxsQmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbEJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEJhY2soZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi5jb25zdGFudCgnbW1GaWxlcG9vbFF1ZXVlUHJvY2Vzc0ludGVydmFsJywgMClcbi5jb25zdGFudCgnbW1GaWxlcG9vbEZvbGRlcicsICdmaWxlcG9vbCcpXG4uY29uc3RhbnQoJ21tRmlsZXBvb2xTdG9yZScsICdmaWxlcG9vbCcpXG4uY29uc3RhbnQoJ21tRmlsZXBvb2xRdWV1ZVN0b3JlJywgJ2ZpbGVzX3F1ZXVlJylcbi5jb25zdGFudCgnbW1GaWxlcG9vbExpbmtzU3RvcmUnLCAnZmlsZXNfbGlua3MnKVxuLmNvbnN0YW50KCdtbUZpbGVwb29sUGFja2FnZXNTdG9yZScsICdmaWxlcG9vbF9wYWNrYWdlcycpXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQXBwUHJvdmlkZXIsICRtbVNpdGVzRmFjdG9yeVByb3ZpZGVyLCBtbUZpbGVwb29sU3RvcmUsIG1tRmlsZXBvb2xMaW5rc1N0b3JlLCBtbUZpbGVwb29sUXVldWVTdG9yZSxcbiAgICAgICAgICAgIG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlKSB7XG4gICAgdmFyIHNpdGVTdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEZpbGUgc3RvcmUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRWFjaCBlbnRyeSBzaG91bGQgY29udGFpbjpcbiAgICAgICAgICAgIC8vIC0gZmlsZUlkOiBBIGhhc2ggb2YgdGhlIGZpbGUgaW5mby5cbiAgICAgICAgICAgIC8vIC0gdXJsOiBVUkwgdG8gZG93bmxvYWQgdGhlIGZpbGUuXG4gICAgICAgICAgICAvLyAtIG1vZGlmaWVkOiBUaGUgdGltZSBhdCB3aGljaCB0aGUgZmlsZSB3YXMgbGFzdCBkb3dubG9hZGVkLlxuICAgICAgICAgICAgLy8gLSBzdGFsZTogV2hlbiB0cnVlLCBpdCBtZWFucyB0aGF0IHRoZSBmaWxlIHNob3VsZCBiZSByZWRvd25sb2FkZWQuXG4gICAgICAgICAgICAvLyAtIGV0YWc6IFN0b3JlIHRoZSBFVEFHIGNvZGUgb2YgdGhlIGZpbGUuXG4gICAgICAgICAgICBuYW1lOiBtbUZpbGVwb29sU3RvcmUsXG4gICAgICAgICAgICBrZXlQYXRoOiAnZmlsZUlkJyxcbiAgICAgICAgICAgIGluZGV4ZXM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEFzc29jaWF0aW9ucyBiZXR3ZWVuIGZpbGVzIGFuZCBjb21wb25lbnRzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVhY2ggZW50cnkgc2hvdWxkIGNvbnRhaW46XG4gICAgICAgICAgICAvLyAtIGZpbGVJZDogSGFzaCB1c2VkIGluIHRoZSBmaWxlIHN0b3JlLlxuICAgICAgICAgICAgLy8gLSBjb21wb25lbnQ6IFRoZSBjb21wb25lbnQgbmFtZSAoZS5nLiBtbWFNb2RQYWdlKS5cbiAgICAgICAgICAgIC8vIC0gY29tcG9uZW50SWQ6IEFuIElEIHRoYXQgY2FuIGJlIHVzZWQgYnkgdGhlIGNvbXBvbmVudC4gLTEgd2hlbiBub3QgcHJvdmlkZWQuXG4gICAgICAgICAgICBuYW1lOiBtbUZpbGVwb29sTGlua3NTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6IFsnZmlsZUlkJywgJ2NvbXBvbmVudCcsICdjb21wb25lbnRJZCddLFxuICAgICAgICAgICAgaW5kZXhlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZpbGVJZCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb21wb25lbnQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgdXNpbmcgY29tcG91bmQgaW5kZXhlcyBiZWNhdXNlIHRoZXkgc2VlbSB0byBoYXZlIGlzc3VlcyB3aXRoIHdoZXJlKCkuXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb21wb25lbnRBbmRJZCcsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW29iai5jb21wb25lbnQsIG9iai5jb21wb25lbnRJZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBhY2thZ2VzIHN0b3JlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVhY2ggZW50cnkgc2hvdWxkIGNvbnRhaW46XG4gICAgICAgICAgICAvLyAtIGlkOiBUaGUgcGFja2FnZSBJRC4gU2VlIHtAbGluayAkbW1GaWxlcG9vbCNnZXRQYWNrYWdlSWR9XG4gICAgICAgICAgICAvLyAtIGNvbXBvbmVudDogUGFja2FnZSdzIGNvbXBvbmVudC5cbiAgICAgICAgICAgIC8vIC0gY29tcG9uZW50SWQ6IFBhY2thZ2UncyBjb21wb25lbnRJZC5cbiAgICAgICAgICAgIC8vIC0gc3RhdHVzOiBUaGUgcGFja2FnZSBzdGF0dXM6IG1tQ29yZURvd25sb2FkZWQsIG1tQ29yZURvd25sb2FkaW5nLCBldGMuXG4gICAgICAgICAgICAvLyAtIHByZXZpb3VzOiAob3B0aW9uYWwpIFRoZSBwYWNrYWdlIHByZXZpb3VzIHN0YXR1cy5cbiAgICAgICAgICAgIC8vIC0gcmV2aXNpb246IFRoZSBwYWNrYWdlIHJldmlzaW9uLlxuICAgICAgICAgICAgLy8gLSB0aW1lbW9kaWZpZWQ6IFRoZSBwYWNrYWdlIHRpbWVtb2RpZmllZC5cbiAgICAgICAgICAgIC8vIC0gdXBkYXRlZDogV2hlbiB3YXMgdGhlIGVudHJ5IHVwZGF0ZWQgZm9yIHRoZSBsYXN0IHRpbWUuXG4gICAgICAgICAgICBuYW1lOiBtbUZpbGVwb29sUGFja2FnZXNTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCcsXG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvbXBvbmVudElkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3N0YXR1cycsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgXTtcbiAgICB2YXIgYXBwU3RvcmVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyBGaWxlcyBxdWV1ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBFYWNoIGVudHJ5IHNob3VsZCBjb250YWluOlxuICAgICAgICAgICAgLy8gLSBzaXRlSWQ6IFRoZSBzaXRlIElELlxuICAgICAgICAgICAgLy8gLSBmaWxlSWQ6IEEgaGFzaCBvZiB0aGUgZmlsZSBpbmZvLlxuICAgICAgICAgICAgLy8gLSB1cmw6IFVSTCB0byBkb3dubG9hZCB0aGUgZmlsZS5cbiAgICAgICAgICAgIC8vIC0gYWRkZWQ6IFRpbWVzdGFtcCAoaW4gbWlsbGlzZWNvbmRzKSBhdCB3aGljaCB0aGUgZmlsZSB3YXMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgLy8gLSBwcmlvcml0eTogSW5kaWNhdGVzIHdoaWNoIGZpbGVzIHNob3VsZCBiZSB0cmVhdGVkIGZpcnN0LiBNYXhpbXVtIHZhbHVlIGlzIDk5OS5cbiAgICAgICAgICAgIC8vIC0gbGlua3M6IEFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBjb21wb25lbnQgYW5kIElEIHRvIGNyZWF0ZSBsaW5rcyBvbmNlIHRoZSBmaWxlIGhhcyBiZWVuIHByb2Nlc3NlZC5cbiAgICAgICAgICAgIG5hbWU6IG1tRmlsZXBvb2xRdWV1ZVN0b3JlLFxuICAgICAgICAgICAga2V5UGF0aDogWydzaXRlSWQnLCAnZmlsZUlkJ10sXG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2l0ZUlkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NvcnRvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGVzIGFuIGluZGV4IHRvIHNvcnQgdGhlIHF1ZXVlIGl0ZW1zIGJ5IHByaW9yaXR5LCBzb3J0IGlzIGFzY2VuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvbGRlc3QgYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIG1vc3QgaW1wb3J0YW50IG9uZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYWRkaXRpb25hbCBwcmlvcml0eSBhcmd1bWVudCBhbGxvd3MgdG8gYnVtcCBhbnkgcXVldWUgaXRlbSBvbiB0b3Agb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGluZGV4IHdpbGwgbG9vayBhcyBmb2xsb3c6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBbOTk5IC0gcHJpb3JpdHldICsgXCItXCIgKyB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIFwiOTk5LTE0MzE0OTEwODY5MTNcIjogaXRlbSB3aXRob3V0IHByaW9yaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgXCI5MDAtMTQzMTQ5MTA4NjkxM1wiOiBpdGVtIHdpdGggcHJpb3JpdHkgb2YgOTkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBcIjAwMC0xNDMxNDkxMDg2OTEzXCI6IGl0ZW0gd2l0aCBtYXggcHJpb3JpdHkuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0b3JkZXIgPSBwYXJzZUludChvYmouYWRkZWQsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9IDk5OSAtIE1hdGgubWF4KDAsIE1hdGgubWluKHBhcnNlSW50KG9iai5wcmlvcml0eSB8fCAwLCAxMCksIDk5OSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBcIjAwMFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0b3JkZXIgPSBcIlwiICsgc29ydG9yZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSBcIlwiICsgcHJpb3JpdHk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsIGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gcGFkZGluZy5zdWJzdHJpbmcoMCwgcGFkZGluZy5sZW5ndGggLSBwcmlvcml0eS5sZW5ndGgpICsgcHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0b3JkZXIgPSBwcmlvcml0eSArICctJyArIHNvcnRvcmRlcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRvcmRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIF07XG4gICAgJG1tQXBwUHJvdmlkZXIucmVnaXN0ZXJTdG9yZXMoYXBwU3RvcmVzKTtcbiAgICAkbW1TaXRlc0ZhY3RvcnlQcm92aWRlci5yZWdpc3RlclN0b3JlcyhzaXRlU3RvcmVzKTtcbn0pXG5cbi8qKlxuICogRmFjdG9yeSBmb3IgaGFuZGxpbmcgdGhlIGZpbGVzIGluIHRoZSBwb29sLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGZhY3RvcnlcbiAqIEBuYW1lICRtbUZpbGVwb29sXG4gKiBAdG9kbyBVc2UgdHJhbnNhY3Rpb25zIChlLmcuIHdoZW4gcXVlcnlpbmcsIHRoZW4gdXBkYXRpbmcpXG4gKiBAdG9kbyBTZXR0aW5nIGZpbGVzIGFzIHN0YWxlIGFmdGVyIGEgY2VydGFpbiB0aW1lXG4gKiBAdG9kbyBVc2UgRVRBR3NcbiAqIEB0b2RvIERvIG5vdCBkb3dubG9hZCBvbiBsaW1pdGVkIG5ldHdvcmtcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFRoaXMgZmFjdG9yeSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgZXh0ZXJuYWwgY29udGVudC5cbiAqXG4gKiBJdCB3aWxsIGFsd2F5cyB0cnkgdG8gZ2V0IGEgZmlsZSBmcm9tIHRoZSBmaWxlcG9vbCBhbmQgcmV0dXJuIGl0LCB3aGVuIHRoZSBmaWxlIGlzIG5vdFxuICogZm91bmQgaXQgd2lsbCBiZSBhZGRlZCB0byBhIHF1ZXVlIHRvIGJlIGRvd25sb2FkZWQgbGF0ZXIuIFRoZSB0d28gbWFpbiBnb2FscyBvZiB0aGlzXG4gKiBpcyB0byBrZWVwIHRoZSBjb250ZW50IGF2YWlsYWJsZSBvZmZsaW5lLCBhbmQgaW1wcm92ZSB0aGUgdXNlciBleHBlcmllbmNlIGJ5IGNhY2hpbmdcbiAqIHRoZSBjb250ZW50IGxvY2FsbHkuXG4gKlxuICogVGhlIGZpbGVwb29sIGhhcyBhIHZlcnkgbGltaXRlZCB1bmRlcnN0YW5kaW5nIG9mIHBsdWdpbmZpbGVzLCB5b3Ugc2hvdWxkIGFsd2F5cyBjYWxsXG4gKiB7QGxpbmsgJG1tVXRpbCNmaXhQbHVnaW5maWxlVVJMfSBwcmlvciB0byBwYXNzaW5nIHRoZSBVUkwuIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdG9cbiAqIGFsbG93IGZvciBhbnkgdHlwZSBvZiBVUkwgdG8gYmUgaGFuZGxlZCBoZXJlLiBXZSBjYW4gZG93bmxvYWQgYW5kIGNhY2hlIGNvbnRlbnRcbiAqIHRoYXQgaXMgbm90IHNlcnZlZCBieSBNb29kbGUuIFRoZSBvbmx5IGxpdHRsZSBoYW5kbGluZyBvZiBwbHVnaW5maWxlIGlzIGxvY2F0ZWQgaW5cbiAqIHtAbGluayAkbW1GaWxlcG9vbCNfZ2V0RmlsZUlkQnlVcmx9LlxuICovXG4uZmFjdG9yeSgnJG1tRmlsZXBvb2wnLCBmdW5jdGlvbigkcSwgJGxvZywgJHRpbWVvdXQsICRtbUFwcCwgJG1tRlMsICRtbVdTLCAkbW1TaXRlc01hbmFnZXIsICRtbUV2ZW50cywgbWQ1LCBtbUZpbGVwb29sU3RvcmUsXG4gICAgICAgIG1tRmlsZXBvb2xMaW5rc1N0b3JlLCBtbUZpbGVwb29sUXVldWVTdG9yZSwgbW1GaWxlcG9vbEZvbGRlciwgbW1GaWxlcG9vbFF1ZXVlUHJvY2Vzc0ludGVydmFsLCBtbUNvcmVFdmVudFF1ZXVlRW1wdHksXG4gICAgICAgIG1tQ29yZURvd25sb2FkZWQsIG1tQ29yZURvd25sb2FkaW5nLCBtbUNvcmVOb3REb3dubG9hZGVkLCBtbUNvcmVPdXRkYXRlZCwgbW1Db3JlTm90RG93bmxvYWRhYmxlLCBtbUZpbGVwb29sUGFja2FnZXNTdG9yZSxcbiAgICAgICAgbW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUZpbGVwb29sJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBleHRlbnNpb25SZWdleCA9IG5ldyBSZWdFeHAoJ15bYS16MC05XSskJyksXG4gICAgICAgIHRva2VuUmVnZXggPSBuZXcgUmVnRXhwKCcoXFxcXD98Jil0b2tlbj0oW0EtWmEtejAtOV0rKScpLFxuICAgICAgICBxdWV1ZVN0YXRlLFxuICAgICAgICB1cmxBdHRyaWJ1dGVzID0gW1xuICAgICAgICAgICAgdG9rZW5SZWdleCxcbiAgICAgICAgICAgIG5ldyBSZWdFeHAoJyhcXFxcP3wmKWZvcmNlZG93bmxvYWQ9WzAtMV0nKVxuICAgICAgICBdLFxuICAgICAgICByZXZpc2lvblJlZ2V4ID0gbmV3IFJlZ0V4cCgnL2NvbnRlbnQvKFswLTldKykvJyksXG4gICAgICAgIHF1ZXVlRGVmZXJyZWRzID0ge30sIC8vIFRvIGhhbmRsZSBmaWxlIGRvd25sb2FkcyB1c2luZyB0aGUgcXVldWUuXG4gICAgICAgIHBhY2thZ2VzUHJvbWlzZXMgPSB7fSwgLy8gVG8gcHJldmVudCBkb3dubG9hZGluZyBwYWNrYWdlcyB0d2ljZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICBmaWxlUHJvbWlzZXMgPSB7fTsgLy8gVG8gcHJldmVudCBkb3dubG9hZGluZyBmaWxlcyB0d2ljZSBhdCB0aGUgc2FtZSB0aW1lLlxuXG4gICAgLy8gUXVldWUgc3RhdHVzIGNvZGVzLlxuICAgIHZhciBRVUVVRV9SVU5OSU5HID0gJ21tRmlsZXBvb2w6UVVFVUVfUlVOTklORycsXG4gICAgICAgIFFVRVVFX1BBVVNFRCA9ICdtbUZpbGVwb29sOlFVRVVFX1BBVVNFRCc7XG5cbiAgICAvLyBFcnJvciBjb2Rlcy5cbiAgICB2YXIgRVJSX1FVRVVFX0lTX0VNUFRZID0gJ21tRmlsZXBvb2xFcnJvcjpFUlJfUVVFVUVfSVNfRU1QVFknLFxuICAgICAgICBFUlJfRlNfT1JfTkVUV09SS19VTkFWQUlMQUJMRSA9ICdtbUZpbGVwb29sRXJyb3I6RVJSX0ZTX09SX05FVFdPUktfVU5BVkFJTEFCTEUnLFxuICAgICAgICBFUlJfUVVFVUVfT05fUEFVU0UgPSAnbW1GaWxlcG9vbEVycm9yOkVSUl9RVUVVRV9PTl9QQVVTRSc7XG5cbiAgICAvKipcbiAgICAgKiBGaWxlcyBzdGF0ZXMuIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgY29yZSBjb25zdGFudHMgaW5zdGVhZDogbW1Db3JlRG93bmxvYWRlZCwgbW1Db3JlRG93bmxvYWRpbmcsIC4uLlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42XG4gICAgICovXG4gICAgc2VsZi5GSUxFRE9XTkxPQURFRCA9ICdkb3dubG9hZGVkJztcbiAgICBzZWxmLkZJTEVET1dOTE9BRElORyA9ICdkb3dubG9hZGluZyc7XG4gICAgc2VsZi5GSUxFTk9URE9XTkxPQURFRCA9ICdub3Rkb3dubG9hZGVkJztcbiAgICBzZWxmLkZJTEVPVVREQVRFRCA9ICdvdXRkYXRlZCc7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW50IHNpdGUgREIgZ2V0dGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNpdGVEYihzaXRlSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlRGIoc2l0ZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaW5rIGEgZmlsZSB3aXRoIGEgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19hZGRGaWxlTGlua1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCBUaGUgZmlsZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gbGluayB0aGUgZmlsZSB0by5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvbmVudElkXSBBbiBJRCB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIG9uIHN1Y2Nlc3MuIFJlamVjdGVkIG9uIGZhaWx1cmUuIEl0IGlzIGFkdmlzZWQgdG8gc2lsZW50bHkgaWdub3JlIGZhaWx1cmVzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9hZGRGaWxlTGluayA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRJZCA9IHNlbGYuX2ZpeENvbXBvbmVudElkKGNvbXBvbmVudElkKTtcbiAgICAgICAgcmV0dXJuIGdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQobW1GaWxlcG9vbExpbmtzU3RvcmUsIHtcbiAgICAgICAgICAgICAgICBmaWxlSWQ6IGZpbGVJZCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRJZDogY29tcG9uZW50SWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGluayBhIGZpbGUgd2l0aCBhIGNvbXBvbmVudCBieSBVUkwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjYWRkRmlsZUxpbmtCeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGZpbGUgVXJsLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgb24gc3VjY2Vzcy4gUmVqZWN0ZWQgb24gZmFpbHVyZS4gSXQgaXMgYWR2aXNlZCB0byBzaWxlbnRseSBpZ25vcmUgZmFpbHVyZXMuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhIGxpbmsgYmV0d2VlbiBhIFVSTCBhbmQgYSBjb21wb25lbnQuIFlvdSB1c3VhbGx5IGRvIG5vdCBuZWVkIHRvIGNhbGxcbiAgICAgKiB0aGlzIG1hbnVhbGx5IGFzIGFkZGluZyBhIGZpbGUgdG8gcXVldWUgYWxsb3dzIHlvdSB0byBkbyBzby4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kXG4gICAgICogZG9lcyBub3QgY2hlY2sgaWYgdGhlIGZpbGUgZXhpc3RzIGluIHRoZSBwb29sLCBzbyB5b3UgcHJvYmFibHkgd2FudCB0byB1c2UgaXMgYWZ0ZXJcbiAgICAgKiBhIHN1Y2Nlc3NmdWwge0BsaW5rICRtbUZpbGVwb29sI2Rvd25sb2FkVXJsfS5cbiAgICAgKi9cbiAgICBzZWxmLmFkZEZpbGVMaW5rQnlVcmwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9hZGRGaWxlTGluayhzaXRlSWQsIGZpbGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMaW5rIGEgZmlsZSB3aXRoIGEgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19hZGRGaWxlTGlua3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gbGlua3MgQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBsaW5rIGNvbXBvbmVudCBhbmQgb3B0aW9uYWxseSBjb21wb25lbnRJZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBvbiBzdWNjZXNzLiBSZWplY3RlZCBvbiBmYWlsdXJlLiBJdCBpcyBhZHZpc2VkIHRvIHNpbGVudGx5IGlnbm9yZSBmYWlsdXJlcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fYWRkRmlsZUxpbmtzID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQsIGxpbmtzKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobGlua3MsIGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5fYWRkRmlsZUxpbmsoc2l0ZUlkLCBmaWxlSWQsIGxpbmsuY29tcG9uZW50LCBsaW5rLmNvbXBvbmVudElkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZmlsZSB0byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfYWRkRmlsZVRvUG9vbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCBUaGUgZmlsZSBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIHN0b3JlIGFib3V0IHRoZSBmaWxlICh0aW1lbW9kaWZpZWQsIHVybCwgLi4uKS4gU2VlIG1tRmlsZXBvb2xTdG9yZSBzY2hlbWEuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHdpbGwgb3ZlcnJpZGUgYW55IGV4aXN0aW5nIGVudHJ5IHdpdGggdGhlIHNhbWUga2V5LlxuICAgICAqIFRoYXQgaXMgdGhlIG9ubHkgd2F5IHRvIHVwZGF0ZSBhbiBlbnRyeS5cbiAgICAgKi9cbiAgICBzZWxmLl9hZGRGaWxlVG9Qb29sID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQsIGRhdGEpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGFuZ3VsYXIuY29weShkYXRhKSB8fCB7fTtcbiAgICAgICAgdmFsdWVzLmZpbGVJZCA9IGZpbGVJZDtcbiAgICAgICAgcmV0dXJuIGdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQobW1GaWxlcG9vbFN0b3JlLCB2YWx1ZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGVudHJ5IHRvIHF1ZXVlIHVzaW5nIGEgVVJMLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2FkZFRvUXVldWVCeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGFic29sdXRlIFVSTCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbXBvbmVudF0gVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQgKG9wdGlvbmFsKS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZD0wXSBUaGUgdGltZSB0aGlzIGZpbGUgd2FzIG1vZGlmaWVkLiBDYW4gYmUgdXNlZCB0byBjaGVjayBmaWxlIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZmlsZVBhdGhdICAgICAgIEZpbGVwYXRoIHRvIGRvd25sb2FkIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHk9MF0gVGhlIHByaW9yaXR5IHRoaXMgZmlsZSBzaG91bGQgZ2V0IGluIHRoZSBxdWV1ZSAocmFuZ2UgMC05OTkpLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIG9uIHN1Y2Nlc3MuIFRoZSByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgaW5jb25zaXN0ZW50LCBkbyBub3QgdXNlLlxuICAgICAqL1xuICAgIHNlbGYuYWRkVG9RdWV1ZUJ5VXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCB0aW1lbW9kaWZpZWQsIGZpbGVQYXRoLCBwcmlvcml0eSkge1xuICAgICAgICB2YXIgZGIgPSAkbW1BcHAuZ2V0REIoKSxcbiAgICAgICAgICAgIGZpbGVJZCxcbiAgICAgICAgICAgIG5vdyA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgcmV2aXNpb24sXG4gICAgICAgICAgICBxdWV1ZURlZmVycmVkO1xuXG4gICAgICAgIGlmICghJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcblxuICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gdGltZW1vZGlmaWVkIHx8IDA7XG4gICAgICAgICAgICByZXZpc2lvbiA9IHNlbGYuZ2V0UmV2aXNpb25Gcm9tVXJsKGZpbGVVcmwpO1xuICAgICAgICAgICAgZmlsZUlkID0gc2VsZi5fZ2V0RmlsZUlkQnlVcmwoZmlsZVVybCk7XG4gICAgICAgICAgICBwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgY29tcG9uZW50LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGluayA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudElkOiBjb21wb25lbnRJZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBxdWV1ZSBkZWZlcnJlZCBub3cgaWYgaXQgZXhpc3RzIHRvIHByZXZlbnQgZXJyb3JzIGlmIGZpbGUgaXMgcmVtb3ZlZCBmcm9tIHF1ZXVlXG4gICAgICAgICAgICAvLyB3aGlsZSB3ZSdyZSBjaGVja2luZyBpZiB0aGUgZmlsZSBpcyBpbiBxdWV1ZS5cbiAgICAgICAgICAgIHF1ZXVlRGVmZXJyZWQgPSBzZWxmLl9nZXRRdWV1ZURlZmVycmVkKHNpdGVJZCwgZmlsZUlkLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkYi5nZXQobW1GaWxlcG9vbFF1ZXVlU3RvcmUsIFtzaXRlSWQsIGZpbGVJZF0pLnRoZW4oZnVuY3Rpb24oZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZExpbmsgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgdGhlIGZpbGUgaW4gcXVldWUsIHdlIHVwZGF0ZSB0aGUgcHJpb3JpdHkgYW5kIGxpbmtzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU9iamVjdC5wcmlvcml0eSA8IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU9iamVjdC5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXZpc2lvbiAmJiBmaWxlT2JqZWN0LnJldmlzaW9uICE9PSByZXZpc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVPYmplY3QucmV2aXNpb24gPSByZXZpc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW1vZGlmaWVkICYmIGZpbGVPYmplY3QudGltZW1vZGlmaWVkICE9PSB0aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlT2JqZWN0LnRpbWVtb2RpZmllZCA9IHRpbWVtb2RpZmllZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZVBhdGggJiYgZmlsZU9iamVjdC5wYXRoICE9PSBmaWxlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVPYmplY3QucGF0aCA9IGZpbGVQYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYWRkIHRoZSBuZXcgbGluayBpZiBpdCBkb2VzIG5vdCBleGlzdCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZmlsZU9iamVjdC5saW5rcywgZnVuY3Rpb24oZmlsZUxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUxpbmsuY29tcG9uZW50ID09IGxpbmsuY29tcG9uZW50ICYmIGZpbGVMaW5rLmNvbXBvbmVudElkID09IGxpbmsuY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRMaW5rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlT2JqZWN0LmxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgb25seSB3aGVuIHJlcXVpcmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVXBkYXRpbmcgZmlsZSAnICsgZmlsZUlkICsgJyB3aGljaCBpcyBhbHJlYWR5IGluIHF1ZXVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KG1tRmlsZXBvb2xRdWV1ZVN0b3JlLCBmaWxlT2JqZWN0KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRRdWV1ZVByb21pc2Uoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdGaWxlICcgKyBmaWxlSWQgKyAnIGFscmVhZHkgaW4gcXVldWUgYW5kIGRvZXMgbm90IHJlcXVpcmUgdXBkYXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZURlZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFibGUgdG8gcmV0cmlldmUgdGhlIHF1ZXVlIGRlZmVycmVkIGJlZm9yZSB3ZSB1c2UgdGhhdCBvbmUsIHNpbmNlIHRoZSBmaWxlIGRvd25sb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtaWdodCBoYXZlIGZpbmlzaGVkIG5vdyBhbmQgdGhlIGRlZmVycmVkIHdvdWxkbid0IGJlIGluIHRoZSBhcnJheSBhbnltb3JlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlRGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRRdWV1ZVByb21pc2Uoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZFRvUXVldWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBVbnN1cmUgd2h5IHdlIGNvdWxkIG5vdCBnZXQgdGhlIHJlY29yZCwgbGV0J3MgYWRkIHRvIHRoZSBxdWV1ZSBhbnl3YXkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZFRvUXVldWUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRUb1F1ZXVlKCkge1xuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0FkZGluZyAnICsgZmlsZUlkICsgJyB0byB0aGUgcXVldWUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KG1tRmlsZXBvb2xRdWV1ZVN0b3JlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGVJZDogc2l0ZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaWxlSWQ6IGZpbGVJZCxcbiAgICAgICAgICAgICAgICAgICAgYWRkZWQ6IG5vdy5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBmaWxlVXJsLFxuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbjogcmV2aXNpb24sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZDogdGltZW1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgbGlua3M6IGxpbmsgPyBbbGlua10gOiBbXVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBxdWV1ZSBpcyBydW5uaW5nLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNoZWNrUXVldWVQcm9jZXNzaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRRdWV1ZVByb21pc2Uoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIHF1ZXVlIHByb2Nlc3NpbmcuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjY2hlY2tRdWV1ZVByb2Nlc3NpbmdcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEluIG1vc2UgY2FzZXMsIHRoaXMgd2lsbCBlbmFibGUgdGhlIHF1ZXVlIHByb2Nlc3NpbmcgaWYgaXQgd2FzIHBhdXNlZC5cbiAgICAgKiBUaG91Z2gsIHRoaXMgd2lsbCBkaXNhYmxlIHRoZSBxdWV1ZSBpZiB3ZSBhcmUgbWlzc2luZyBuZXR3b3JrIG9yIGlmIHRoZSBmaWxlIHN5c3RlbVxuICAgICAqIGlzIG5vdCBhY2Nlc3NpYmxlLiBBbHNvLCB0aGlzIHdpbGwgaGF2ZSBubyBlZmZlY3QgaWYgdGhlIHF1ZXVlIGlzIGFscmVhZHkgcnVubmluZy5cbiAgICAgKlxuICAgICAqIERvIG5vdCB1c2UgZGlyZWN0bHksIGl0IGlzIHJlc2VydmVkIGZvciBjb3JlIHVzZS5cbiAgICAgKi9cbiAgICBzZWxmLmNoZWNrUXVldWVQcm9jZXNzaW5nID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCEkbW1GUy5pc0F2YWlsYWJsZSgpIHx8ICEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgcXVldWVTdGF0ZSA9IFFVRVVFX1BBVVNFRDtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9IGVsc2UgaWYgKHF1ZXVlU3RhdGUgPT09IFFVRVVFX1JVTk5JTkcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlU3RhdGUgPSBRVUVVRV9SVU5OSU5HO1xuICAgICAgICBzZWxmLl9wcm9jZXNzUXVldWUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIHBhY2thZ2VzIHN0YXR1cyBpbiBhIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjY2xlYXJBbGxQYWNrYWdlc1N0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgU2l0ZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgc3RhdHVzIGFyZSBjbGVhcmVkLlxuICAgICAqL1xuICAgIHNlbGYuY2xlYXJBbGxQYWNrYWdlc1N0YXR1cyA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgJGxvZy5kZWJ1ZygnQ2xlYXIgYWxsIHBhY2thZ2VzIHN0YXR1cyBmb3Igc2l0ZSAnICsgc2l0ZUlkKTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBzaXRlLmdldERiKCk7XG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0QWxsKG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYi5yZW1vdmUobW1GaWxlcG9vbFBhY2thZ2VzU3RvcmUsIGVudHJ5LmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBtb2R1bGUgc3RhdHVzIGNoYW5nZWQsIHNldHRpbmcgaXQgYXMgbm90IGRvd25sb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90cmlnZ2VyUGFja2FnZVN0YXR1c0NoYW5nZWQoc2l0ZUlkLCBlbnRyeS5jb21wb25lbnQsIGVudHJ5LmNvbXBvbmVudElkLCBtbUNvcmVOb3REb3dubG9hZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGZpbGVwb29sLiBVc2UgaXQgb25seSB3aGVuIGFsbCB0aGUgZmlsZXMgZnJvbSBhIHNpdGUgYXJlIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjY2xlYXJGaWxlcG9vbFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkIElEIG9mIHRoZSBzaXRlIHRvIGNsZWFyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZXBvb2wgaXMgY2xlYXJlZC5cbiAgICAgKi9cbiAgICBzZWxmLmNsZWFyRmlsZXBvb2wgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5yZW1vdmVBbGwobW1GaWxlcG9vbFN0b3JlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBhIGNvbXBvbmVudCBoYXMgZmlsZXMgaW4gdGhlIHBvb2wuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjY29tcG9uZW50SGFzRmlsZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgbWVhbnMgeWVzLCByZWplY3RlZCBtZWFucyBuby5cbiAgICAgKi9cbiAgICBzZWxmLmNvbXBvbmVudEhhc0ZpbGVzID0gZnVuY3Rpb24oc2l0ZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkKSB7XG4gICAgICAgIHJldHVybiBnZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICB2YXIgd2hlcmU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHdoZXJlID0gWydjb21wb25lbnRBbmRJZCcsICc9JywgW2NvbXBvbmVudCwgc2VsZi5fZml4Q29tcG9uZW50SWQoY29tcG9uZW50SWQpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoZXJlID0gWydjb21wb25lbnQnLCAnPScsIGNvbXBvbmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGIuY291bnQobW1GaWxlcG9vbExpbmtzU3RvcmUsIHdoZXJlKS50aGVuKGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgY3VycmVudCBzdGF0dXMgb2YgYSBsaXN0IG9mIHBhY2thZ2VzIGFuZCB0aGUgc3RhdHVzIG9mIG9uZSBvZiB0aGUgcGFja2FnZXMsXG4gICAgICogZGV0ZXJtaW5lIHRoZSBuZXcgc3RhdHVzIGZvciB0aGUgbGlzdCBvZiBwYWNrYWdlcy4gVGhlIHN0YXR1cyBvZiBhIGxpc3Qgb2YgcGFja2FnZXMgaXM6XG4gICAgICogICAgIC0gbW1Db3JlTm90RG93bmxvYWRhYmxlIGlmIHRoZXJlIGFyZSBubyBkb3dubG9hZGFibGUgcGFja2FnZXMuXG4gICAgICogICAgIC0gbW1Db3JlTm90RG93bmxvYWRlZCBpZiBhdCBsZWFzdCAxIHBhY2thZ2UgaGFzIHN0YXR1cyBtbUNvcmVOb3REb3dubG9hZGVkLlxuICAgICAqICAgICAtIG1tQ29yZURvd25sb2FkZWQgaWYgQUxMIHRoZSBkb3dubG9hZGFibGUgcGFja2FnZXMgaGF2ZSBzdGF0dXMgbW1Db3JlRG93bmxvYWRlZC5cbiAgICAgKiAgICAgLSBtbUNvcmVEb3dubG9hZGluZyBpZiBBTEwgdGhlIGRvd25sb2FkYWJsZSBwYWNrYWdlcyBoYXZlIHN0YXR1cyBtbUNvcmVEb3dubG9hZGluZyBvciBtbUNvcmVEb3dubG9hZGVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggYXQgbGVhc3QgMSBwYWNrYWdlIHdpdGggbW1Db3JlRG93bmxvYWRpbmcuXG4gICAgICogICAgIC0gbW1Db3JlT3V0ZGF0ZWQgaWYgQUxMIHRoZSBkb3dubG9hZGFibGUgcGFja2FnZXMgaGF2ZSBzdGF0dXMgbW1Db3JlT3V0ZGF0ZWQgb3IgbW1Db3JlRG93bmxvYWRlZCBvclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1tQ29yZURvd25sb2FkaW5nLCB3aXRoIGF0IGxlYXN0IDEgcGFja2FnZSB3aXRoIG1tQ29yZU91dGRhdGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2RldGVybWluZVBhY2thZ2VzU3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnQgICAgICAgQ3VycmVudCBzdGF0dXMgb2YgdGhlIGxpc3Qgb2YgcGFja2FnZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhY2thZ2VzdGF0dXMgU3RhdHVzIG9mIG9uZSBvZiB0aGUgcGFja2FnZXMuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgTmV3IHN0YXR1cyBmb3IgdGhlIGxpc3Qgb2YgcGFja2FnZXM7XG4gICAgICovXG4gICAgc2VsZi5kZXRlcm1pbmVQYWNrYWdlc1N0YXR1cyA9IGZ1bmN0aW9uKGN1cnJlbnQsIHBhY2thZ2VzdGF0dXMpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gbW1Db3JlTm90RG93bmxvYWRhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhY2thZ2VzdGF0dXMgPT09IG1tQ29yZU5vdERvd25sb2FkZWQpIHtcbiAgICAgICAgICAgIC8vIElmIDEgcGFja2FnZSBpcyBub3QgZG93bmxvYWRlZCB0aGUgc3RhdHVzIG9mIHRoZSB3aG9sZSBsaXN0IHdpbGwgYWx3YXlzIGJlIG5vdCBkb3dubG9hZGVkLlxuICAgICAgICAgICAgcmV0dXJuIG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAocGFja2FnZXN0YXR1cyA9PT0gbW1Db3JlRG93bmxvYWRlZCAmJiBjdXJyZW50ID09PSBtbUNvcmVOb3REb3dubG9hZGFibGUpIHtcbiAgICAgICAgICAgIC8vIElmIGFsbCBwYWNrYWdlcyBhcmUgZG93bmxvYWRlZCBvciBub3QgZG93bmxvYWRhYmxlIHdpdGggYXQgbGVhc3QgMSBkb3dubG9hZGVkLCBzdGF0dXMgd2lsbCBiZSBkb3dubG9hZGVkLlxuICAgICAgICAgICAgcmV0dXJuIG1tQ29yZURvd25sb2FkZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAocGFja2FnZXN0YXR1cyA9PT0gbW1Db3JlRG93bmxvYWRpbmcgJiYgKGN1cnJlbnQgPT09IG1tQ29yZU5vdERvd25sb2FkYWJsZSB8fCBjdXJyZW50ID09PSBtbUNvcmVEb3dubG9hZGVkKSkge1xuICAgICAgICAgICAgLy8gSWYgYWxsIHBhY2thZ2VzIGFyZSBkb3dubG9hZGluZy9kb3dubG9hZGVkL25vdGRvd25sb2FkYWJsZSB3aXRoIGF0IGxlYXN0IDEgZG93bmxvYWRpbmcsIHN0YXR1cyB3aWxsIGJlIGRvd25sb2FkaW5nLlxuICAgICAgICAgICAgcmV0dXJuIG1tQ29yZURvd25sb2FkaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKHBhY2thZ2VzdGF0dXMgPT09IG1tQ29yZU91dGRhdGVkICYmIGN1cnJlbnQgIT09IG1tQ29yZU5vdERvd25sb2FkZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYWNrYWdlcyBub3Rkb3dubG9hZGVkIGFuZCB0aGVyZSBpcyBhdCBsZWFzdCAxIG91dGRhdGVkLCBzdGF0dXMgd2lsbCBiZSBvdXRkYXRlZC5cbiAgICAgICAgICAgIHJldHVybiBtbUNvcmVPdXRkYXRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXR1cyByZW1haW5zIHRoZSBzYW1lLlxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIG9yIHByZWZldGNoZXMgYSBsaXN0IG9mIGZpbGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19kb3dubG9hZE9yUHJlZmV0Y2hQYWNrYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IGZpbGVMaXN0ICAgTGlzdCBvZiBmaWxlcyB0byBkb3dubG9hZC5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBwcmVmZXRjaCAgICBUcnVlIGlmIHNob3VsZCBwcmVmZXRjaCB0aGUgY29udGVudHMgKHF1ZXVlKSwgZmFsc2UgaWYgdGhleSBzaG91bGQgYmUgZG93bmxvYWRlZCByaWdodCBub3cuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgICAgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXZpc2lvbl0gICAgUGFja2FnZSdzIHJldmlzaW9uLiBJZiBub3QgZGVmaW5lZCwgaXQgd2lsbCBiZSBjYWxjdWxhdGVkIHVzaW5nIHRoZSBsaXN0IG9mIGZpbGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW1vZF0gICAgIFBhY2thZ2UncyB0aW1lbW9kaWZpZWQuIElmIG5vdCBkZWZpbmVkLCBpdCB3aWxsIGJlIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIGxpc3Qgb2YgZmlsZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkaXJQYXRoXSAgICAgTmFtZSBvZiB0aGUgZGlyZWN0b3J5IHdoZXJlIHRvIHN0b3JlIHRoZSBmaWxlcyAoaW5zaWRlIGZpbGVwb29sIGRpcikuIElmIG5vdCBkZWZpbmVkLCBzdG9yZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaWxlcyBkaXJlY3RseSBpbnNpZGUgdGhlIGZpbGVwb29sIGZvbGRlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGZpbGVzIGFyZSBkb3dubG9hZGVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9kb3dubG9hZE9yUHJlZmV0Y2hQYWNrYWdlID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlTGlzdCwgcHJlZmV0Y2gsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHJldmlzaW9uLCB0aW1lbW9kLCBkaXJQYXRoKSB7XG5cbiAgICAgICAgdmFyIHBhY2thZ2VJZCA9IHNlbGYuZ2V0UGFja2FnZUlkKGNvbXBvbmVudCwgY29tcG9uZW50SWQpO1xuXG4gICAgICAgIGlmIChwYWNrYWdlc1Byb21pc2VzW3NpdGVJZF0gJiYgcGFja2FnZXNQcm9taXNlc1tzaXRlSWRdW3BhY2thZ2VJZF0pIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIGRvd25sb2FkIG9uZ29pbmcgZm9yIHRoaXMgcGFja2FnZSwgcmV0dXJuIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgcmV0dXJuIHBhY2thZ2VzUHJvbWlzZXNbc2l0ZUlkXVtwYWNrYWdlSWRdO1xuICAgICAgICB9IGVsc2UgaWYgKCFwYWNrYWdlc1Byb21pc2VzW3NpdGVJZF0pIHtcbiAgICAgICAgICAgIHBhY2thZ2VzUHJvbWlzZXNbc2l0ZUlkXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV2aXNpb24gPSByZXZpc2lvbiB8fCBzZWxmLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KGZpbGVMaXN0KTtcbiAgICAgICAgdGltZW1vZCA9IHRpbWVtb2QgfHwgc2VsZi5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QoZmlsZUxpc3QpO1xuXG4gICAgICAgIHZhciBkd25Qcm9taXNlLFxuICAgICAgICAgICAgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCBwYWNrYWdlIGFzIGRvd25sb2FkaW5nLlxuICAgICAgICBkd25Qcm9taXNlID0gc2VsZi5zdG9yZVBhY2thZ2VTdGF0dXMoc2l0ZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCBtbUNvcmVEb3dubG9hZGluZywgcmV2aXNpb24sIHRpbWVtb2QpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICAgICAgcGFja2FnZUxvYWRlZCA9IDA7IC8vIFVzZSBhIGRlZmVycmVkIHRvIGJlIGFibGUgdG8gdXNlIG5vdGlmeS5cblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZpbGVMaXN0LCBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVMb2FkZWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpclBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwYXRoIHRvIHRoZSBmaWxlLlxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gZmlsZS5maWxlbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuZmlsZXBhdGggIT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGZpbGUuZmlsZXBhdGguc3Vic3RyKDEpICsgcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gJG1tRlMuY29uY2F0ZW5hdGVQYXRocyhkaXJQYXRoLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlZmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHNlbGYuYWRkVG9RdWV1ZUJ5VXJsKHNpdGVJZCwgZmlsZS5maWxldXJsLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCBmaWxlLnRpbWVtb2RpZmllZCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHNlbGYuZG93bmxvYWRVcmwoc2l0ZUlkLCBmaWxlLmZpbGV1cmwsIGZhbHNlLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCBmaWxlLnRpbWVtb2RpZmllZCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgdW5kZWZpbmVkIGZvciBzdWNjZXNzICYgZmFpbCB3aWxsIHBhc3MgdGhlIHN1Y2Nlc3MvZmFpbHVyZSB0byB0aGUgcGFyZW50IHByb21pc2UuXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlLnRoZW4odW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzcyAmJiBwcm9ncmVzcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV3IHNpemUgbG9hZGVkIHRvIHRoZSBwYWNrYWdlIGxvYWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2thZ2VMb2FkZWQgPSBwYWNrYWdlTG9hZGVkICsgKHByb2dyZXNzLmxvYWRlZCAtIGZpbGVMb2FkZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUxvYWRlZCA9IHByb2dyZXNzLmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZURvd25sb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZDogcGFja2FnZUxvYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlUHJvZ3Jlc3M6IHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2VzcyBwcmVmZXRjaGluZywgc3RvcmUgcGFja2FnZSBhcyBkb3dubG9hZGVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnN0b3JlUGFja2FnZVN0YXR1cyhzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIG1tQ29yZURvd25sb2FkZWQsIHJldmlzaW9uLCB0aW1lbW9kKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIGRvd25sb2FkaW5nLCBnbyBiYWNrIHRvIHByZXZpb3VzIHN0YXR1cyBhbmQgcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNldFBhY2thZ2VQcmV2aW91c1N0YXR1cyhzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBEb3dubG9hZCBmaW5pc2hlZCwgZGVsZXRlIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgZGVsZXRlIHBhY2thZ2VzUHJvbWlzZXNbc2l0ZUlkXVtwYWNrYWdlSWRdO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZGVsZXRlZCkgeyAvLyBJbiBjYXNlIHByb21pc2Ugd2FzIGZpbmlzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgcGFja2FnZXNQcm9taXNlc1tzaXRlSWRdW3BhY2thZ2VJZF0gPSBkd25Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkd25Qcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBsaXN0IG9mIGZpbGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2Rvd25sb2FkUGFja2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gZmlsZUxpc3QgICAgTGlzdCBvZiBmaWxlcyB0byBkb3dubG9hZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgICAgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb21wb25lbnRJZCAgICBBbiBJRCB0byBpZGVudGlmeSB0aGUgZG93bmxvYWQuIE11c3QgYmUgdW5pcXVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmV2aXNpb25dICAgICBQYWNrYWdlJ3MgcmV2aXNpb24uIElmIG5vdCBkZWZpbmVkLCBpdCB3aWxsIGJlIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIGxpc3Qgb2YgZmlsZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWRdIFBhY2thZ2UncyB0aW1lbW9kaWZpZWQuIElmIG5vdCBkZWZpbmVkLCBpdCB3aWxsIGJlIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIGxpc3Qgb2YgZmlsZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkaXJQYXRoXSAgICAgIE5hbWUgb2YgdGhlIGRpcmVjdG9yeSB3aGVyZSB0byBzdG9yZSB0aGUgZmlsZXMgKGluc2lkZSBmaWxlcG9vbCBkaXIpLiBJZiBub3QgZGVmaW5lZCwgc3RvcmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZpbGVzIGRpcmVjdGx5IGluc2lkZSB0aGUgZmlsZXBvb2wgZm9sZGVyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGZpbGVzIGFyZSBkb3dubG9hZGVkLlxuICAgICAqL1xuICAgIHNlbGYuZG93bmxvYWRQYWNrYWdlID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlTGlzdCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCwgZGlyUGF0aCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZG93bmxvYWRPclByZWZldGNoUGFja2FnZShzaXRlSWQsIGZpbGVMaXN0LCBmYWxzZSwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCwgZGlyUGF0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIGZpbGUgb24gdGhlIHNwb3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZG93bmxvYWRVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBmaWxlIFVSTC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVTdGFsZV0gVHJ1ZSBpZiAnc3RhbGUnIHNob3VsZCBiZSBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWQ9MF0gVGhlIHRpbWUgdGhpcyBmaWxlIHdhcyBtb2RpZmllZC4gQ2FuIGJlIHVzZWQgdG8gY2hlY2sgZmlsZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZpbGVQYXRoXSAgICAgICBGaWxlcGF0aCB0byBkb3dubG9hZCB0aGUgZmlsZSB0by5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIGludGVybmFsIFVSTCBvbiBzdWNjZXNzLCByZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRG93bmxvYWRzIGEgZmlsZSBvbiB0aGUgc3BvdC5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBhbHNvIHRha2UgY2FyZSBvZiBhZGRpbmcgdGhlIGZpbGUgdG8gdGhlIHBvb2wgaWYgaXQncyBtaXNzaW5nLlxuICAgICAqIEhvd2V2ZXIsIHBsZWFzZSBub3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBmb3JjZSBhIGZpbGUgdG8gYmUgcmUtZG93bmxvYWRlZFxuICAgICAqIGlmIGl0IGlzIGFscmVhZHkgcGFydCBvZiB0aGUgcG9vbC4gWW91IHNob3VsZCBtYXJrIGEgZmlsZSBhcyBzdGFsZSB1c2luZ1xuICAgICAqIHtAbGluayAkbW1GaWxlcG9vbCNpbnZhbGlkYXRlRmlsZUJ5VXJsfSB0byB0cmlnZ2VyIGEgZG93bmxvYWQuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rICRtbUZpbGVwb29sI19nZXRJbnRlcm5hbFVybEJ5SWR9IGZvciB0aGUgdHlwZSBvZiBsb2NhbCBVUkwgcmV0dXJuZWQuXG4gICAgICovXG4gICAgc2VsZi5kb3dubG9hZFVybCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZVVybCwgaWdub3JlU3RhbGUsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHRpbWVtb2RpZmllZCwgZmlsZVBhdGgpIHtcbiAgICAgICAgdmFyIGZpbGVJZCxcbiAgICAgICAgICAgIHJldmlzaW9uLFxuICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgICAgICAgICB0aW1lbW9kaWZpZWQgPSB0aW1lbW9kaWZpZWQgfHwgMDtcbiAgICAgICAgICAgICAgICByZXZpc2lvbiA9IHNlbGYuZ2V0UmV2aXNpb25Gcm9tVXJsKGZpbGVVcmwpO1xuICAgICAgICAgICAgICAgIGZpbGVJZCA9IHNlbGYuX2dldEZpbGVJZEJ5VXJsKGZpbGVVcmwpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2hhc0ZpbGVJblBvb2woc2l0ZUlkLCBmaWxlSWQpLnRoZW4oZnVuY3Rpb24oZmlsZU9iamVjdCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZU9iamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBoYXZlIHRoZSBmaWxlLCBkb3dubG9hZCBhbmQgYWRkIHRvIHBvb2wuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZG93bmxvYWRGb3JQb29sQnlVcmwoc2l0ZUlkLCBmaWxlVXJsLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkLCBmaWxlUGF0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLl9pc0ZpbGVPdXRkYXRlZChmaWxlT2JqZWN0LCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKSAmJiAkbW1BcHAuaXNPbmxpbmUoKSAmJiAhaWdub3JlU3RhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIGlzIG91dGRhdGVkLCBmb3JjZSB0aGUgZG93bmxvYWQgYW5kIHVwZGF0ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9kb3dubG9hZEZvclBvb2xCeVVybChzaXRlSWQsIGZpbGVVcmwsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQsIGZpbGVQYXRoLCBmaWxlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZXJ5dGhpbmcgaXMgZmluZSwgcmV0dXJuIHRoZSBmaWxlIG9uIGRpc2suXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHNlbGYuX2dldEludGVybmFsVXJsQnlQYXRoKGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBzZWxmLl9nZXRJbnRlcm5hbFVybEJ5SWQoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSB3YXMgbm90IGZvdW5kIGluIHRoZSBwb29sLCB3ZWlyZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9kb3dubG9hZEZvclBvb2xCeVVybChzaXRlSWQsIGZpbGVVcmwsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQsIGZpbGVQYXRoLCBmaWxlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpbGUgaXMgbm90IGluIHRoZSBwb29sIGp1c3QgeWV0LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZG93bmxvYWRGb3JQb29sQnlVcmwoc2l0ZUlkLCBmaWxlVXJsLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkLCBmaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZEZpbGVMaW5rKHNpdGVJZCwgZmlsZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9ub3RpZnlGaWxlRG93bmxvYWRlZChzaXRlSWQsIGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbm90aWZ5RmlsZURvd25sb2FkRXJyb3Ioc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBVUkwgYW5kIHVwZGF0ZSBvciBhZGQgaXQgdG8gdGhlIHBvb2wuXG4gICAgICpcbiAgICAgKiBUaGlzIHVzZXMgdGhlIGZpbGUgc3lzdGVtLCB5b3Ugc2hvdWxkIGFsd2F5cyBtYWtlIHN1cmUgdGhhdCBpdCBpc1xuICAgICAqIGFjY2Vzc2libGUgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX2Rvd25sb2FkRm9yUG9vbEJ5VXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgICAgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgICAgICAgICAgVGhlIGZpbGUgVVJMLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmV2aXNpb25dICAgICAgIEZpbGUgcmV2aXNpb24gbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW1vZGlmaWVkXSAgIFRoZSB0aW1lIHRoaXMgZmlsZSB3YXMgbW9kaWZpZWQuIENhbiBiZSB1c2VkIHRvIGNoZWNrIGZpbGUgc3RhdGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtmaWxlUGF0aF0gICAgICAgRmlsZXBhdGggdG8gZG93bmxvYWQgdGhlIGZpbGUgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb29sRmlsZU9iamVjdF0gV2hlbiBzZXQsIHRoZSBvYmplY3Qgd2lsbCBiZSB1cGRhdGVkLCBhIG5ldyBlbnRyeSB3aWxsIG5vdCBiZSBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggaW50ZXJuYWwgVVJMIG9uIHN1Y2Nlc3MsIHJlamVjdGVkIG90aGVyd2lzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZG93bmxvYWRGb3JQb29sQnlVcmwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQsIGZpbGVQYXRoLCBwb29sRmlsZU9iamVjdCkge1xuICAgICAgICB2YXIgZmlsZUlkID0gc2VsZi5fZ2V0RmlsZUlkQnlVcmwoZmlsZVVybCk7XG4gICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGggfHwgc2VsZi5fZ2V0RmlsZVBhdGgoc2l0ZUlkLCBmaWxlSWQpO1xuXG4gICAgICAgIGlmIChwb29sRmlsZU9iamVjdCAmJiBwb29sRmlsZU9iamVjdC5maWxlSWQgIT09IGZpbGVJZCkge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignSW52YWxpZCBvYmplY3QgdG8gdXBkYXRlIHBhc3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRvd25sb2FkSWQgPSBzZWxmLmdldEZpbGVEb3dubG9hZElkKGZpbGVVcmwsIGZpbGVQYXRoKSxcbiAgICAgICAgICAgIGRlbGV0ZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgaWYgKGZpbGVQcm9taXNlc1tzaXRlSWRdICYmIGZpbGVQcm9taXNlc1tzaXRlSWRdW2Rvd25sb2FkSWRdKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSBkb3dubG9hZCBvbmdvaW5nIGZvciB0aGlzIGZpbGUgaW4gdGhpcyBsb2NhdGlvbiwgcmV0dXJuIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgcmV0dXJuIGZpbGVQcm9taXNlc1tzaXRlSWRdW2Rvd25sb2FkSWRdO1xuICAgICAgICB9IGVsc2UgaWYgKCFmaWxlUHJvbWlzZXNbc2l0ZUlkXSkge1xuICAgICAgICAgICAgZmlsZVByb21pc2VzW3NpdGVJZF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UgPSAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuXG4gICAgICAgICAgICBpZiAoIXNpdGUuY2FuRG93bmxvYWRGaWxlcygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJG1tV1MuZG93bmxvYWRGaWxlKGZpbGVVcmwsIGZpbGVQYXRoKS50aGVuKGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcG9vbEZpbGVPYmplY3QgfHwge307XG5cbiAgICAgICAgICAgICAgICBkYXRhLmRvd25sb2FkZWQgPSBub3cuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkYXRhLnVybCA9IGZpbGVVcmw7XG4gICAgICAgICAgICAgICAgZGF0YS5yZXZpc2lvbiA9IHJldmlzaW9uO1xuICAgICAgICAgICAgICAgIGRhdGEudGltZW1vZGlmaWVkID0gdGltZW1vZGlmaWVkO1xuICAgICAgICAgICAgICAgIGRhdGEucGF0aCA9IGZpbGVQYXRoO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2FkZEZpbGVUb1Bvb2woc2l0ZUlkLCBmaWxlSWQsIGRhdGEpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlRW50cnkudG9VUkwoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gRG93bmxvYWQgZmluaXNoZWQsIGRlbGV0ZSB0aGUgcHJvbWlzZS5cbiAgICAgICAgICAgIGRlbGV0ZSBmaWxlUHJvbWlzZXNbc2l0ZUlkXVtkb3dubG9hZElkXTtcbiAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWRlbGV0ZWQpIHsgLy8gSW4gY2FzZSBwcm9taXNlIHdhcyBmaW5pc2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIGZpbGVQcm9taXNlc1tzaXRlSWRdW2Rvd25sb2FkSWRdID0gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRml4IGEgY29tcG9uZW50IElEIHRvIGFsd2F5cyBiZSBhIE51bWJlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfZml4Q29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8dW5kZWZpbmVkfSBUaGUgY29tcG9uZW50IElELlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG5vcm1hbGlzZWQgY29tcG9uZW50IElELiAtMSB3aGVuIHVuZGVmaW5lZCB3YXMgcGFzc2VkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9maXhDb21wb25lbnRJZCA9IGZ1bmN0aW9uKGNvbXBvbmVudElkKSB7XG4gICAgICAgIHZhciBpZCA9IHBhcnNlSW50KGNvbXBvbmVudElkLCAxMCk7XG4gICAgICAgIGlmIChpc05hTihpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgd3N0b2tlbiB1cmwgYW5kIHBvaW50cyB0byB0aGUgY29ycmVjdCBzY3JpcHQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX2ZpeFBsdWdpbmZpbGVVUkxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCBUaGUgZmlsZSBVUkwuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUmVzb2x2ZWQgd2l0aCBmaXhlZCBVUkwgb24gc3VjY2VzcywgcmVqZWN0ZWQgb3RoZXJ3aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9maXhQbHVnaW5maWxlVVJMID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUuZml4UGx1Z2luZmlsZVVSTChmaWxlVXJsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSUQgb2YgYSBmaWxlIGRvd25sb2FkLiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgZmlsZVByb21pc2VzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldEZpbGVEb3dubG9hZElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgIFRoZSBmaWxlIFVSTC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVBhdGggVGhlIGZpbGUgZGVzdGluYXRpb24gcGF0aC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgRmlsZSBkb3dubG9hZCBJRC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5nZXRGaWxlRG93bmxvYWRJZCA9IGZ1bmN0aW9uKGZpbGVVcmwsIGZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiBtZDUuY3JlYXRlSGFzaChmaWxlVXJsICsgJyMjIycgKyBmaWxlUGF0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdXNlZCB0byBub3RpZnkgZG93bmxvYWQgZXZlbnRzICgkbW1FdmVudHMpLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldEZpbGVFdmVudE5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBFdmVudCBuYW1lLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRGaWxlRXZlbnROYW1lID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQpIHtcbiAgICAgICAgcmV0dXJuICdtbUZpbGVwb29sRmlsZTonK3NpdGVJZCsnOicrZmlsZUlkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHVzZWQgdG8gbm90aWZ5IGRvd25sb2FkIGV2ZW50cyAoJG1tRXZlbnRzKS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNnZXRGaWxlRXZlbnROYW1lQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCBUaGUgYWJzb2x1dGUgVVJMIHRvIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBldmVudCBuYW1lLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZUV2ZW50TmFtZUJ5VXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9maXhQbHVnaW5maWxlVVJMKHNpdGVJZCwgZmlsZVVybCkudGhlbihmdW5jdGlvbihmaWxlVXJsKSB7XG4gICAgICAgICAgICB2YXIgZmlsZUlkID0gc2VsZi5fZ2V0RmlsZUlkQnlVcmwoZmlsZVVybCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0RmlsZUV2ZW50TmFtZShzaXRlSWQsIGZpbGVJZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBkb3dubG9hZCBwcm9taXNlLiBJZiB0aGUgcHJvbWlzZSBpcyBub3Qgc2V0LCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldFBhY2thZ2VEb3dubG9hZFByb21pc2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgICAgIFRoZSBjb21wb25lbnQgb2YgdGhlIHBhY2thZ2UuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb25lbnRJZF0gQW4gSUQgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgIERvd25sb2FkIHByb21pc2Ugb3IgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UGFja2FnZURvd25sb2FkUHJvbWlzZSA9IGZ1bmN0aW9uKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCkge1xuICAgICAgICB2YXIgcGFja2FnZUlkID0gc2VsZi5nZXRQYWNrYWdlSWQoY29tcG9uZW50LCBjb21wb25lbnRJZCk7XG4gICAgICAgIGlmIChwYWNrYWdlc1Byb21pc2VzW3NpdGVJZF0gJiYgcGFja2FnZXNQcm9taXNlc1tzaXRlSWRdW3BhY2thZ2VJZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBwYWNrYWdlc1Byb21pc2VzW3NpdGVJZF1bcGFja2FnZUlkXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIElEIG9mIGEgcGFja2FnZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNnZXRQYWNrYWdlSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgICBQYWNrYWdlJ3MgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgUGFja2FnZSBJRC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFBhY2thZ2VJZCA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgY29tcG9uZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIG1kNS5jcmVhdGVIYXNoKGNvbXBvbmVudCArICcjJyArIHNlbGYuX2ZpeENvbXBvbmVudElkKGNvbXBvbmVudElkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHBhY2thZ2UgcHJldmlvdXMgc3RhdHVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldFBhY2thZ2VQcmV2aW91c1N0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgICAgICAgUGFja2FnZSdzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvbmVudElkXSAgICBBbiBJRCB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgc3RhdHVzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UGFja2FnZVByZXZpb3VzU3RhdHVzID0gZnVuY3Rpb24oc2l0ZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdmFyIGRiID0gc2l0ZS5nZXREYigpLFxuICAgICAgICAgICAgICAgIHBhY2thZ2VJZCA9IHNlbGYuZ2V0UGFja2FnZUlkKGNvbXBvbmVudCwgY29tcG9uZW50SWQpO1xuICAgICAgICAgICAgcmV0dXJuIGRiLmdldChtbUZpbGVwb29sUGFja2FnZXNTdG9yZSwgcGFja2FnZUlkKS50aGVuKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnByZXZpb3VzIHx8wqBtbUNvcmVOb3REb3dubG9hZGVkO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHBhY2thZ2Ugc3RhdHVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldFBhY2thZ2VTdGF0dXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgICAgICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgICAgICAgICAgIFBhY2thZ2UncyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb25lbnRJZF0gICAgICAgQW4gSUQgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtyZXZpc2lvbj0wXSBQYWNrYWdlJ3MgcmV2aXNpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWQ9MF0gICAgUGFja2FnZSdzIHRpbWVtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHN0YXR1cy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFBhY2thZ2VTdGF0dXMgPSBmdW5jdGlvbihzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgcmV2aXNpb24gPSByZXZpc2lvbiB8fCAwO1xuICAgICAgICB0aW1lbW9kaWZpZWQgPSB0aW1lbW9kaWZpZWQgfHwgMDtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBzaXRlLmdldERiKCksXG4gICAgICAgICAgICAgICAgcGFja2FnZUlkID0gc2VsZi5nZXRQYWNrYWdlSWQoY29tcG9uZW50LCBjb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgIC8vIEdldCBzdGF0dXMuXG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0KG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlLCBwYWNrYWdlSWQpLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuc3RhdHVzID09PSBtbUNvcmVEb3dubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXZpc2lvbiAhPSBlbnRyeS5yZXZpc2lvbiB8fCB0aW1lbW9kaWZpZWQgPiBlbnRyeS50aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbGUgaXMgb3V0ZGF0ZWQuIExldCdzIGNoYW5nZSBpdHMgc3RhdHVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuc3RhdHVzID0gbW1Db3JlT3V0ZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS51cGRhdGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5pbnNlcnQobW1GaWxlcG9vbFBhY2thZ2VzU3RvcmUsIGVudHJ5KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MgaW5zZXJ0aW5nLCB0cmlnZ2VyIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyaWdnZXJQYWNrYWdlU3RhdHVzQ2hhbmdlZChzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIG1tQ29yZU91dGRhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbnRyeS5zdGF0dXMgPT09IG1tQ29yZU91dGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXZpc2lvbiA9PT0gZW50cnkucmV2aXNpb24gJiYgdGltZW1vZGlmaWVkID09PSBlbnRyeS50aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbGUgaXNuJ3Qgb3V0ZGF0ZWQgYW55bW9yZS4gTGV0J3MgY2hhbmdlIGl0cyBzdGF0dXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdGF0dXMgPSBtbUNvcmVEb3dubG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkudXBkYXRlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuaW5zZXJ0KG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlLCBlbnRyeSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzIGluc2VydGluZywgdHJpZ2dlciBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90cmlnZ2VyUGFja2FnZVN0YXR1c0NoYW5nZWQoc2l0ZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCBtbUNvcmVEb3dubG9hZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5zdGF0dXM7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW1Db3JlTm90RG93bmxvYWRlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWZlcnJlZCBvYmplY3QgZm9yIGEgZmlsZSBpbiB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX2dldFF1ZXVlRGVmZXJyZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgICAgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCAgICAgICAgIFRoZSBmaWxlIElELlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NyZWF0ZT10cnVlXSBUcnVlIGlmIGl0IHNob3VsZCBjcmVhdGUgYSBuZXcgZGVmZXJyZWQgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgRGVmZXJyZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2dldFF1ZXVlRGVmZXJyZWQgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVJZCwgY3JlYXRlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3JlYXRlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjcmVhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFxdWV1ZURlZmVycmVkc1tzaXRlSWRdKSB7XG4gICAgICAgICAgICBpZiAoIWNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlRGVmZXJyZWRzW3NpdGVJZF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXF1ZXVlRGVmZXJyZWRzW3NpdGVJZF1bZmlsZUlkXSkge1xuICAgICAgICAgICAgaWYgKCFjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZURlZmVycmVkc1tzaXRlSWRdW2ZpbGVJZF0gPSAkcS5kZWZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWV1ZURlZmVycmVkc1tzaXRlSWRdW2ZpbGVJZF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJvbWlzZSBmb3IgYSBmaWxlIGluIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfZ2V0UXVldWVQcm9taXNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgICAgICAgICBUaGUgZmlsZSBJRC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjcmVhdGU9dHJ1ZV0gVHJ1ZSBpZiBpdCBzaG91bGQgY3JlYXRlIGEgbmV3IHByb21pc2UgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgUHJvbWlzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0UXVldWVQcm9taXNlID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlSWQsIGNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZ2V0UXVldWVEZWZlcnJlZChzaXRlSWQsIGZpbGVJZCwgY3JlYXRlKS5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgZmlsZSBhbHJlYWR5IGluIHRoZSBwb29sP1xuICAgICAqXG4gICAgICogVGhpcyBkb2VzIG5vdCBjaGVjayBpZiB0aGUgZmlsZSBpcyBvbiB0aGUgZGlzay5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfaGFzRmlsZUluUG9vbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGZpbGUgVVJMLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggZmlsZSBvYmplY3QgZnJvbSBEQiBvbiBzdWNjZXNzLCByZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2hhc0ZpbGVJblBvb2wgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVJZCkge1xuICAgICAgICByZXR1cm4gZ2V0U2l0ZURiKHNpdGVJZCkudGhlbihmdW5jdGlvbihkYikge1xuICAgICAgICAgICAgcmV0dXJuIGRiLmdldChtbUZpbGVwb29sU3RvcmUsIGZpbGVJZCkudGhlbihmdW5jdGlvbihmaWxlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlT2JqZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlT2JqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgZmlsZSBpbiBxdWV1ZT9cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfaGFzRmlsZUluUXVldWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBmaWxlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIGZpbGUgb2JqZWN0IGZyb20gREIgb24gc3VjY2VzcywgcmVqZWN0ZWQgb3RoZXJ3aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9oYXNGaWxlSW5RdWV1ZSA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5nZXQobW1GaWxlcG9vbFF1ZXVlU3RvcmUsIFtzaXRlSWQsIGZpbGVJZF0pLnRoZW4oZnVuY3Rpb24oZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlT2JqZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlT2JqZWN0O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWwgVVJMIG9mIGEgZHJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0SW50ZXJuYWxVcmxCeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBmaWxlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBSZXNvbHZlZCB3aXRoIHRoZSBVUkwuIFJlamVjdGVkIG90aGVyd2lzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5nZXREaXJlY3RvcnlVcmxCeVVybCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZVVybCkge1xuICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUlkID0gc2VsZi5fZ2V0RmlsZUlkQnlVcmwoZmlsZVVybCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUZTLmdldERpcihzZWxmLl9nZXRGaWxlUGF0aChzaXRlSWQsIGZpbGVJZCkpLnRoZW4oZnVuY3Rpb24oZGlyRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpckVudHJ5LnRvVVJMKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB1bmlxdWUgSUQgYmFzZWQgb24gYSBVUkwuXG4gICAgICpcbiAgICAgKiBUaGlzIGhhcyBhIG1pbmltYWwgaGFuZGxpbmcgb2YgcGx1Z2luZmlsZXMgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgYSBjbGVhblxuICAgICAqIGZpbGUgSUQgd2hpY2ggd2lsbCBub3QgY2hhbmdlIGlmIHBvaW50aW5nIHRvIHRoZSBzYW1lIHBsdWdpbmZpbGUgVVJMIGV2ZW5cbiAgICAgKiBpZiB0aGUgdG9rZW4gb3IgZXh0cmEgYXR0cmlidXRlcyBoYXZlIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX2dldEZpbGVJZEJ5VXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGFic29sdXRlIFVSTCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgZmlsZSBJRC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0RmlsZUlkQnlVcmwgPSBmdW5jdGlvbihmaWxlVXJsKSB7XG4gICAgICAgIHZhciB1cmwgPSBzZWxmLl9yZW1vdmVSZXZpc2lvbkZyb21VcmwoZmlsZVVybCksXG4gICAgICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgICAgICBleHRlbnNpb24gPSAnJztcblxuICAgICAgICBpZiAodXJsLmluZGV4T2YoJy93ZWJzZXJ2aWNlL3BsdWdpbmZpbGUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhdHRyaWJ1dGVzIHRoYXQgZG8gbm90IG1hdHRlci5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1cmxBdHRyaWJ1dGVzLCBmdW5jdGlvbihyZWdleCkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKHJlZ2V4LCAnJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRm9yIG5vdyBvbmx5IGd1ZXNzZXMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgcGx1Z2luIGZpbGVzLiBXZSBuZWVkIHRoZSBleHRlbnNpb25cbiAgICAgICAgICAgIC8vIGZvciB0aGUgaW5BcHBCcm93c2VyIHRvIG9wZW4gdGhlIGZpbGVzIHByb3Blcmx5LCBlLmcuIHRoZSBleHRlbnNpb24gbmVlZHMgdG8gYmVcbiAgICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIGZpbGUgbmFtZS4gQWxzbywgd2UgbmVlZCB0aGUgbWltZXR5cGUgdG8gb3BlbiB0aGUgZmlsZSB3aXRoXG4gICAgICAgICAgICAvLyB3ZWIgaW50ZW50cy4gVGhlIGVhc2llc3Qgd2F5IHRvIHByb3ZpZGUgc3VjaCBpbmZvcm1hdGlvbiBpcyB0byBrZWVwIHRoZSBleHRlbnNpb25cbiAgICAgICAgICAgIC8vIGluIHRoZSBmaWxlIElELiBEZXZlbG9wZXJzIHNob3VsZCBub3QgY2FyZSBhYm91dCBpdCwgYnV0IGFzIHdlIGFyZSB1c2luZyB0aGVcbiAgICAgICAgICAgIC8vIGZpbGUgSUQgaW4gdGhlIGZpbGUgcGF0aCwgZGV2cyBhbmQgc3lzdGVtIGNhbiBndWVzcyBpdC5cbiAgICAgICAgICAgIGNhbmRpZGF0ZSA9IHNlbGYuX2d1ZXNzRXh0ZW5zaW9uRnJvbVVybCh1cmwpO1xuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUgIT09ICdwaHAnKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gJy4nICsgY2FuZGlkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZDUuY3JlYXRlSGFzaCgndXJsOicgKyB1cmwpICsgZXh0ZW5zaW9uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFic29sdXRlIFVSTCB0byBhY2Nlc3MgdGhlIGZpbGUgVVJMLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19nZXRGaWxlVXJsQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBhYnNvbHV0ZSBVUkwgdG8gdGhlIGZpbGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFttb2RlPXVybF0gVGhlIHR5cGUgb2YgVVJMIHRvIHJldHVybi4gQWNjZXB0cyAndXJsJyBvciAnc3JjJy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gbGluayB0aGUgZmlsZSB0by5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvbmVudElkXSBBbiBJRCB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW1vZGlmaWVkPTBdIFRoZSB0aW1lIHRoaXMgZmlsZSB3YXMgbW9kaWZpZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCB0aGUgVVJMIHRvIHVzZS4gV2hlbiByZWplY3RlZCwgbm90aGluZyBjb3VsZCBiZSBkb25lLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoaXMgd2lsbCByZXR1cm4gYSBVUkwgcG9pbnRpbmcgdG8gdGhlIGNvbnRlbnQgb2YgdGhlIHJlcXVlc3RlZCBVUkwuXG4gICAgICpcbiAgICAgKiBUaGlzIGhhbmRsZXMgdGhlIHF1ZXVlIGFuZCB2YWxpZGl0eSBvZiB0aGUgZmlsZS4gV2hlbiB3ZSBoYXZlIGEgbG9jYWwgY29weSBvZiB0aGUgZmlsZVxuICAgICAqIHdlIHdpbGwgYXNzZXNzIHdoZXRoZXIgb3Igbm90IGl0IGlzIHN0aWxsIHZhbGlkLiBJZiBpdCBpcyBub3QgdmFsaWQsIG9yIHdlIGRpZCBub3QgZmluZFxuICAgICAqIHRoZSBmaWxlLCB3ZSB3aWxsIGFkZCBpdCB0byB0aGUgcXVldWUgdG8gYmUgZG93bmxvYWRlZCBsYXRlciBhbmQgd2Ugd2lsbCByZXR1cm4gdGhlIFVSTFxuICAgICAqIHdlIHJlY2VpdmVkLiBXaGVuIHRoZSBmaWxlIGlzIHZhbGlkIHdlIHJldHVybiBhIGxvY2FsIFVSTCB0byBpdC5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGZpbGUgY2Fubm90IGJlIGZvdW5kLCBhbmQgd2UgYXJlIG9mZmxpbmUsIHRoZW4gd2UgcmVqZWN0IHRoZSBwcm9taXNlIGJlY2F1c2VcbiAgICAgKiB0aGVyZSB3YXMgbm90aGluZyB3ZSBjb3VsZCBkby5cbiAgICAgKi9cbiAgICBzZWxmLl9nZXRGaWxlVXJsQnlVcmwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwsIG1vZGUsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHRpbWVtb2RpZmllZCkge1xuICAgICAgICB2YXIgZmlsZUlkLFxuICAgICAgICAgICAgcmV2aXNpb247XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgICAgIHRpbWVtb2RpZmllZCA9IHRpbWVtb2RpZmllZCB8fCAwO1xuICAgICAgICAgICAgcmV2aXNpb24gPSBzZWxmLmdldFJldmlzaW9uRnJvbVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgIHZhciBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9oYXNGaWxlSW5Qb29sKHNpdGVJZCwgZmlsZUlkKS50aGVuKGZ1bmN0aW9uKGZpbGVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGFkZFRvUXVldWUgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZm47XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVPYmplY3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBoYXZlIHRoZSBmaWxlLCBhZGQgaXQgdG8gdGhlIHF1ZXVlLCBhbmQgcmV0dXJuIHJlYWwgVVJMLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZFRvUXVldWVCeVVybChzaXRlSWQsIGZpbGVVcmwsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHRpbWVtb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZmlsZVVybDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5faXNGaWxlT3V0ZGF0ZWQoZmlsZU9iamVjdCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCkgJiYgJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpbGUgaXMgb3V0ZGF0ZWQsIHdlIGFkZCB0byB0aGUgcXVldWUgYW5kIHJldHVybiByZWFsIFVSTC5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRUb1F1ZXVlQnlVcmwoc2l0ZUlkLCBmaWxlVXJsLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCB0aW1lbW9kaWZpZWQpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGZpbGVVcmw7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCB0aGUgZmlsZSBlbnRyeSwgbm93IGxvb2sgZm9yIHRoZSBmaWxlIG9uIGRpc2suXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdzcmMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbiA9IHNlbGYuX2dldEludGVybmFsU3JjQnlJZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gc2VsZi5fZ2V0SW50ZXJuYWxVcmxCeUlkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBmbihzaXRlSWQsIGZpbGVJZCkudGhlbihmdW5jdGlvbihpbnRlcm5hbFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVyZmVjdCwgdGhlIGZpbGUgaXMgb24gZGlzay5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgdGltZSBiZWluZyB3ZSBhc3N1bWUgdGhhdCB0aGUgY29tcG9uZW50IGxpbmsgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxVcmw7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHByb2JsZW0gaGVyZSwgd2UgY291bGQgbm90IHJldHJpZXZlIHRoZSBmaWxlIHRob3VnaCB3ZSB0aG91Z2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYWQgaXQsIHdlIHdpbGwgZGVsZXRlIHRoZSBlbnRyaWVzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IElELlxuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRmlsZSAnICsgZmlsZUlkICsgJyBub3QgZm91bmQgb24gZGlzaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlRmlsZUJ5SWQoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRUb1F1ZXVlQnlVcmwoc2l0ZUlkLCBmaWxlVXJsLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCB0aW1lbW9kaWZpZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzdGlsbCBoYXZlIGEgY2hhbmNlIHRvIHNlcnZlIHRoZSByaWdodCBjb250ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlVXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBoYXZlIHRoZSBmaWxlIGluIHN0b3JlIHlldC5cbiAgICAgICAgICAgICAgICBzZWxmLmFkZFRvUXVldWVCeVVybChzaXRlSWQsIGZpbGVVcmwsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHRpbWVtb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVVcmw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGF0aCB0byBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGRvZXMgbm90IGNoZWNrIGlmIHRoZSBmaWxlIGV4aXN0cyBvciBub3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX2dldEZpbGVQYXRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZUlkIFRoZSBmaWxlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHBhdGggdG8gdGhlIGZpbGUgcmVsYXRpdmUgdG8gc3RvcmFnZSByb290LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRGaWxlUGF0aCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkKSB7XG4gICAgICAgIHJldHVybiAkbW1GUy5nZXRTaXRlRm9sZGVyKHNpdGVJZCkgKyAnLycgKyBtbUZpbGVwb29sRm9sZGVyICsgJy8nICsgZmlsZUlkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhdGggdG8gYSBmaWxlIGZyb20gaXRzIFVSTC5cbiAgICAgKlxuICAgICAqIFRoaXMgZG9lcyBub3QgY2hlY2sgaWYgdGhlIGZpbGUgZXhpc3RzIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNnZXRGaWxlUGF0aEJ5VXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVVcmwgVGhlIGZpbGUgVVJMLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgcGF0aCB0byB0aGUgZmlsZSByZWxhdGl2ZSB0byBzdG9yYWdlIHJvb3QuXG4gICAgICovXG4gICAgc2VsZi5nZXRGaWxlUGF0aEJ5VXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9maXhQbHVnaW5maWxlVVJMKHNpdGVJZCwgZmlsZVVybCkudGhlbihmdW5jdGlvbihmaWxlVXJsKSB7XG4gICAgICAgICAgICB2YXIgZmlsZUlkID0gc2VsZi5fZ2V0RmlsZUlkQnlVcmwoZmlsZVVybCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0RmlsZVBhdGgoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlsZSBzdGF0ZTogbW1Db3JlRG93bmxvYWRlZCwgbW1Db3JlRG93bmxvYWRpbmcsIG1tQ29yZU5vdERvd25sb2FkZWQgb3IgbW1Db3JlT3V0ZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0RmlsZVN0YXRlQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgICAgICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCAgICAgICAgICBGaWxlIFVSTC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVtb2RpZmllZD0wXSBUaGUgdGltZSB0aGlzIGZpbGUgd2FzIG1vZGlmaWVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZmlsZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVTdGF0ZUJ5VXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsLCB0aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgdmFyIGZpbGVJZCxcbiAgICAgICAgICAgIHJldmlzaW9uO1xuXG4gICAgICAgIHJldHVybiBzZWxmLl9maXhQbHVnaW5maWxlVVJMKHNpdGVJZCwgZmlsZVVybCkudGhlbihmdW5jdGlvbihmaWxlVXJsKSB7XG4gICAgICAgICAgICB0aW1lbW9kaWZpZWQgPSB0aW1lbW9kaWZpZWQgfHwgMDtcbiAgICAgICAgICAgIHJldmlzaW9uID0gc2VsZi5nZXRSZXZpc2lvbkZyb21VcmwoZmlsZVVybCk7XG4gICAgICAgICAgICBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2hhc0ZpbGVJblF1ZXVlKHNpdGVJZCwgZmlsZUlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtbUNvcmVEb3dubG9hZGluZztcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9oYXNGaWxlSW5Qb29sKHNpdGVJZCwgZmlsZUlkKS50aGVuKGZ1bmN0aW9uKGZpbGVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2lzRmlsZU91dGRhdGVkKGZpbGVPYmplY3QsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW1Db3JlT3V0ZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW1Db3JlRG93bmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW1Db3JlTm90RG93bmxvYWRlZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgU1JDIG9mIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm5lZCBVUkwgZnJvbSB0aGlzIG1ldGhvZCBpcyB0eXBpY2FsbHkgdXNlZCB3aXRoIElNRyB0YWdzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19nZXRJbnRlcm5hbFNyY0J5SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCB0aGUgaW50ZXJuYWwgVVJMLiBSZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2dldEludGVybmFsU3JjQnlJZCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkKSB7XG4gICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tRlMuZ2V0RmlsZShzZWxmLl9nZXRGaWxlUGF0aChzaXRlSWQsIGZpbGVJZCkpLnRoZW4oZnVuY3Rpb24oZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIHRvSW50ZXJuYWxVUkwgc28gaW1hZ2VzIGFyZSBsb2FkZWQgaW4gaU9TOCB1c2luZyBpbWcgSFRNTCB0YWdzLFxuICAgICAgICAgICAgICAgIC8vIHdpdGggdG9VUkwgdGhlIE9TIGlzIHVuYWJsZSB0byBmaW5kIHRoZSBpbWFnZSBmaWxlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRlMuZ2V0SW50ZXJuYWxVUkwoZmlsZUVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWwgVVJMIG9mIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfZ2V0SW50ZXJuYWxVcmxCeUlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZUlkIFRoZSBmaWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggdGhlIFVSTC4gUmVqZWN0ZWQgb3RoZXJ3aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRJbnRlcm5hbFVybEJ5SWQgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVJZCkge1xuICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUZTLmdldEZpbGUoc2VsZi5fZ2V0RmlsZVBhdGgoc2l0ZUlkLCBmaWxlSWQpKS50aGVuKGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlRW50cnkudG9VUkwoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWwgVVJMIG9mIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfZ2V0SW50ZXJuYWxVcmxCeVBhdGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCB0aGUgVVJMLiBSZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2dldEludGVybmFsVXJsQnlQYXRoID0gZnVuY3Rpb24oZmlsZVBhdGgpIHtcbiAgICAgICAgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1GUy5nZXRGaWxlKGZpbGVQYXRoKS50aGVuKGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlRW50cnkudG9VUkwoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHBhY2thZ2UgcmV2aXNpb24gbnVtYmVyIGZyb20gYSBsaXN0IG9mIGZpbGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldFJldmlzaW9uRnJvbUZpbGVMaXN0XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZmlsZXMgUGFja2FnZSBmaWxlcy5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICBQYWNrYWdlIHJldmlzaW9uLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QgPSBmdW5jdGlvbihmaWxlcykge1xuICAgICAgICB2YXIgcmV2aXNpb24gPSAwO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChmaWxlcywgZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgaWYgKGZpbGUuZmlsZXVybCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gc2VsZi5nZXRSZXZpc2lvbkZyb21VcmwoZmlsZS5maWxldXJsKTtcbiAgICAgICAgICAgICAgICBpZiAociA+IHJldmlzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmlzaW9uID0gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXZpc2lvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZXZpc2lvbiBudW1iZXIgZnJvbSBhIGZpbGUgVVJMLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19nZXRSZXZpc2lvbkZyb21VcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBnZXQgdGhlIHJldmlzaW9uIG51bWJlci5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgIFJldmlzaW9uIG51bWJlci5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5nZXRSZXZpc2lvbkZyb21VcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSB1cmwubWF0Y2gocmV2aXNpb25SZWdleCk7XG4gICAgICAgIGlmIChtYXRjaGVzICYmIHR5cGVvZiBtYXRjaGVzWzFdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hlc1sxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhYnNvbHV0ZSBVUkwgdG8gdXNlIGluIElNRyB0YWdzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldFNyY0J5VXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCBUaGUgYWJzb2x1dGUgVVJMIHRvIHRoZSBmaWxlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWRdIFRoZSB0aW1lIHRoaXMgZmlsZSB3YXMgbW9kaWZpZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCB0aGUgVVJMIHRvIHVzZS4gV2hlbiByZWplY3RlZCwgbm90aGluZyBjb3VsZCBiZSBkb25lLFxuICAgICAqICAgICAgICAgICAgICAgICAgIHdoaWNoIG1lYW5zIHRoYXQgeW91IHNob3VsZCBub3QgZXZlbiB1c2UgdGhlIGZpbGVVcmwgcGFzc2VkLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoaXMgd2lsbCByZXR1cm4gYSBVUkwgcG9pbnRpbmcgdG8gdGhlIGNvbnRlbnQgb2YgdGhlIHJlcXVlc3RlZCBVUkwuXG4gICAgICogVGhlIFVSTCByZXR1cm5lZCBpcyBjb21wYXRpYmxlIHRvIHVzZSB3aXRoIElNRyB0YWdzLlxuICAgICAqIFNlZSB7QGxpbmsgJG1tRmlsZXBvb2wjX2dldEZpbGVVcmxCeVVybH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNyY0J5VXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCB0aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2dldEZpbGVVcmxCeVVybChzaXRlSWQsIGZpbGVVcmwsICdzcmMnLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCB0aW1lbW9kaWZpZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGFja2FnZSB0aW1lbW9kaWZpZWQgZnJvbSBhIGxpc3Qgb2YgZmlsZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZmlsZXMgUGFja2FnZSBmaWxlcy5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICBQYWNrYWdlIHRpbWUgbW9kaWZpZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QgPSBmdW5jdGlvbihmaWxlcykge1xuICAgICAgICB2YXIgdGltZW1vZCA9IDA7XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZpbGVzLCBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICBpZiAoZmlsZS50aW1lbW9kaWZpZWQgPiB0aW1lbW9kKSB7XG4gICAgICAgICAgICAgICAgdGltZW1vZCA9IGZpbGUudGltZW1vZGlmaWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGltZW1vZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhYnNvbHV0ZSBVUkwgdG8gYWNjZXNzIHRoZSBmaWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2dldFVybEJ5VXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCBUaGUgYWJzb2x1dGUgVVJMIHRvIHRoZSBmaWxlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWRdIFRoZSB0aW1lIHRoaXMgZmlsZSB3YXMgbW9kaWZpZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCB0aGUgVVJMIHRvIHVzZS4gV2hlbiByZWplY3RlZCwgbm90aGluZyBjb3VsZCBiZSBkb25lLFxuICAgICAqICAgICAgICAgICAgICAgICAgIHdoaWNoIG1lYW5zIHRoYXQgeW91IHNob3VsZCBub3QgZXZlbiB1c2UgdGhlIGZpbGVVcmwgcGFzc2VkLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoaXMgd2lsbCByZXR1cm4gYSBVUkwgcG9pbnRpbmcgdG8gdGhlIGNvbnRlbnQgb2YgdGhlIHJlcXVlc3RlZCBVUkwuXG4gICAgICogVGhlIFVSTCByZXR1cm5lZCBpcyBjb21wYXRpYmxlIHRvIHVzZSB3aXRoIGEgbG9jYWwgYnJvd3Nlci5cbiAgICAgKiBTZWUge0BsaW5rICRtbUZpbGVwb29sI19nZXRGaWxlVXJsQnlVcmx9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgc2VsZi5nZXRVcmxCeVVybCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZVVybCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgdGltZW1vZGlmaWVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9nZXRGaWxlVXJsQnlVcmwoc2l0ZUlkLCBmaWxlVXJsLCAndXJsJywgY29tcG9uZW50LCBjb21wb25lbnRJZCwgdGltZW1vZGlmaWVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR3Vlc3MgdGhlIGV4dGVuc2lvbiBvZiBhIGZpbGUgZnJvbSBpdHMgVVJMLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB2ZXJ5IHdlYWsgYW5kIHVucmVsaWFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX2d1ZXNzRXh0ZW5zaW9uRnJvbVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsIFRoZSBmaWxlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBsb3dlcmNhc2VkIGV4dGVuc2lvbiB3aXRob3V0IHRoZSBkb3QsIG9yIHVuZGVmaW5lZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ3Vlc3NFeHRlbnNpb25Gcm9tVXJsID0gZnVuY3Rpb24oZmlsZVVybCkge1xuICAgICAgICB2YXIgc3BsaXQgPSBmaWxlVXJsLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgICAgICBleHRlbnNpb247XG5cbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZSA9IHNwbGl0LnBvcCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uUmVnZXgudGVzdChjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBhbGwgdGhlIGZpbGVzIGluIGEgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNpbnZhbGlkYXRlQWxsRmlsZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIG9uIHN1Y2Nlc3MuIFJlamVjdGVkIG9uIGZhaWx1cmUuIEl0IGlzIGFkdmlzZWQgdG8gaWdub3JlIGEgZmFpbHVyZS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJbnZhbGlkYXRlcyBhbGwgZmlsZXMgYnkgbWFya2luZyBpdCBzdGFsZS4gU2VlIHtAbGluayAkbW1GaWxlcG9vbCNpbnZhbGlkYXRlRmlsZUJ5VXJsfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUFsbEZpbGVzID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0QWxsKG1tRmlsZXBvb2xTdG9yZSkudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYi5pbnNlcnQobW1GaWxlcG9vbFN0b3JlLCBpdGVtKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgYSBmaWxlIGJ5IFVSTC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNpbnZhbGlkYXRlRmlsZUJ5VXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCBUaGUgZmlsZSBVUkwuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgb24gc3VjY2Vzcy4gUmVqZWN0ZWQgb24gZmFpbHVyZS4gSXQgaXMgYWR2aXNlZCB0byBpZ25vcmUgYSBmYWlsdXJlLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEludmFsaWRhdGVzIGEgZmlsZSBieSBtYXJraW5nIGl0IHN0YWxlLiBJdCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgcXVldWUgYXV0b21hdGljYWxseSxcbiAgICAgKiBidXQgdGhlIG5leHQgdGltZSB0aGlzIGZpbGUgd2lsbCBiZSByZXF1ZXN0ZWQgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgcXVldWUuIFRoaXMgaXMgdG8gYWxsb3dcbiAgICAgKiBmb3IgY2FjaGUgaW52YWxpZGF0aW9uIHdpdGhvdXQgbmVjZXNzYXJpbHkgcmUtdHJpZ2dlcmluZyBkb3dubG9hZHMuXG4gICAgICogWW91IGNhbiBtYW51bGx5IGNhbGwge0BsaW5rICRtbUZpbGVwb29sI2FkZFRvUXVldWVCeVVybH0gdG8gY291bnRlciB0aGlzIGJlaGF2aW91ci5cbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHdoZW4gYSBmaWxlIGlzIG1hcmtlZCBhcyBzdGFsZSwgdGhlIHVzZXIgd2lsbCBiZSBwcmVzZW50ZWQgdGhlIHN0YWxlIGZpbGVcbiAgICAgKiBvbmx5IGlmIHRoZXkgZG8gbm90IGhhdmUgbmV0d29yayBhY2Nlc3MuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlRmlsZUJ5VXJsID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlVXJsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9maXhQbHVnaW5maWxlVVJMKHNpdGVJZCwgZmlsZVVybCkudGhlbihmdW5jdGlvbihmaWxlVXJsKSB7XG4gICAgICAgICAgICB2YXIgZmlsZUlkID0gc2VsZi5fZ2V0RmlsZUlkQnlVcmwoZmlsZVVybCk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2l0ZURiKHNpdGVJZCkudGhlbihmdW5jdGlvbihkYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYi5nZXQobW1GaWxlcG9vbFN0b3JlLCBmaWxlSWQpLnRoZW4oZnVuY3Rpb24oZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8sIHdlIGRvIG5vdCBoYXZlIHRoZSBmaWxlIGluIHN0b3JlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbGVPYmplY3Quc3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KG1tRmlsZXBvb2xTdG9yZSwgZmlsZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgYWxsIHRoZSBtYXRjaGluZyBmaWxlcyBmcm9tIGEgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI2ludmFsaWRhdGVGaWxlc0J5Q29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gbGluayB0aGUgZmlsZSB0by5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvbmVudElkXSBBbiBJRCB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIG9uIHN1Y2Nlc3MuIFJlamVjdGVkIG9uIGZhaWx1cmUuIEl0IGlzIGFkdmlzZWQgdG8gaWdub3JlIGEgZmFpbHVyZS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJbnZhbGlkYXRlcyBhIGZpbGUgYnkgbWFya2luZyBpdCBzdGFsZS4gU2VlIHtAbGluayAkbW1GaWxlcG9vbCNpbnZhbGlkYXRlRmlsZUJ5VXJsfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUZpbGVzQnlDb21wb25lbnQgPSBmdW5jdGlvbihzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHsgc3RhbGU6IHRydWUgfSxcbiAgICAgICAgICAgIHdoZXJlO1xuICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2hlcmUgPSBbJ2NvbXBvbmVudEFuZElkJywgJz0nLCBbY29tcG9uZW50LCBzZWxmLl9maXhDb21wb25lbnRJZChjb21wb25lbnRJZCldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZXJlID0gWydjb21wb25lbnQnLCAnPScsIGNvbXBvbmVudF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0U2l0ZURiKHNpdGVJZCkudGhlbihmdW5jdGlvbihkYikge1xuICAgICAgICAgICAgcmV0dXJuIGRiLnF1ZXJ5KG1tRmlsZXBvb2xMaW5rc1N0b3JlLCB3aGVyZSkudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBkYi5nZXQobW1GaWxlcG9vbFN0b3JlLCBpdGVtLmZpbGVJZCkudGhlbihmdW5jdGlvbihmaWxlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUVudHJ5LnN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQobW1GaWxlcG9vbFN0b3JlLCBmaWxlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGZpbGUgaXMgZG93bmxvYWRpbmcuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjaXNGaWxlRG93bmxvYWRpbmdCeVVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgICAgIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlVXJsICAgICAgICAgIEZpbGUgVVJMLlxuICAgICAqIEBwYXJhbSB7UHJvbWlzZX0gICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgaWYgZmlsZSBpcyBkb3dubG9hZGluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNGaWxlRG93bmxvYWRpbmdCeVVybCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZVVybCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZml4UGx1Z2luZmlsZVVSTChzaXRlSWQsIGZpbGVVcmwpLnRoZW4oZnVuY3Rpb24oZmlsZVVybCkge1xuICAgICAgICAgICAgZmlsZUlkID0gc2VsZi5fZ2V0RmlsZUlkQnlVcmwoZmlsZVVybCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5faGFzRmlsZUluUXVldWUoc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBmaWxlIGlzIG91dGRhdGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19pc0ZpbGVPdXRkYXRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlT2JqZWN0ICAgICBGaWxlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3JldmlzaW9uXSAgICAgRmlsZSByZXZpc2lvbiBudW1iZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWRdIFRoZSB0aW1lIHRoaXMgZmlsZSB3YXMgbW9kaWZpZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgICAgICAgIFRydWUgaWYgZmlsZSBpcyBvdXRkYXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuX2lzRmlsZU91dGRhdGVkID0gZnVuY3Rpb24oZmlsZU9iamVjdCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCkge1xuICAgICAgICByZXR1cm4gZmlsZU9iamVjdC5zdGFsZSB8fCByZXZpc2lvbiA+IGZpbGVPYmplY3QucmV2aXNpb24gfHwgdGltZW1vZGlmaWVkID4gZmlsZU9iamVjdC50aW1lbW9kaWZpZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSBhIGZpbGUgaGFzIGJlZW4gZG93bmxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfbm90aWZ5RmlsZURvd25sb2FkZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICovXG4gICAgc2VsZi5fbm90aWZ5RmlsZURvd25sb2FkZWQgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVJZCkge1xuICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihzZWxmLl9nZXRGaWxlRXZlbnROYW1lKHNpdGVJZCwgZmlsZUlkKSwge3N1Y2Nlc3M6IHRydWV9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IGVycm9yIG9jY3VycmVkIHdoaWxlIGRvd25sb2FkaW5nIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfbm90aWZ5RmlsZURvd25sb2FkRXJyb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICovXG4gICAgc2VsZi5fbm90aWZ5RmlsZURvd25sb2FkRXJyb3IgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVJZCkge1xuICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihzZWxmLl9nZXRGaWxlRXZlbnROYW1lKHNpdGVJZCwgZmlsZUlkKSwge3N1Y2Nlc3M6IGZhbHNlfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoZXMgYSBsaXN0IG9mIGZpbGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI3ByZWZldGNoUGFja2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gZmlsZUxpc3QgICAgTGlzdCBvZiBmaWxlcyB0byBkb3dubG9hZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgICAgVGhlIGNvbXBvbmVudCB0byBsaW5rIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb21wb25lbnRJZCAgICBBbiBJRCB0byBpZGVudGlmeSB0aGUgZG93bmxvYWQuIE11c3QgYmUgdW5pcXVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmV2aXNpb25dICAgICBQYWNrYWdlJ3MgcmV2aXNpb24uIElmIG5vdCBkZWZpbmVkLCBpdCB3aWxsIGJlIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIGxpc3Qgb2YgZmlsZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWRdIFBhY2thZ2UncyB0aW1lbW9kaWZpZWQuIElmIG5vdCBkZWZpbmVkLCBpdCB3aWxsIGJlIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIGxpc3Qgb2YgZmlsZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkaXJQYXRoXSAgICAgIE5hbWUgb2YgdGhlIGRpcmVjdG9yeSB3aGVyZSB0byBzdG9yZSB0aGUgZmlsZXMgKGluc2lkZSBmaWxlcG9vbCBkaXIpLiBJZiBub3QgZGVmaW5lZCwgc3RvcmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZpbGVzIGRpcmVjdGx5IGluc2lkZSB0aGUgZmlsZXBvb2wgZm9sZGVyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGZpbGVzIGFyZSBkb3dubG9hZGVkLlxuICAgICAqL1xuICAgIHNlbGYucHJlZmV0Y2hQYWNrYWdlID0gZnVuY3Rpb24oc2l0ZUlkLCBmaWxlTGlzdCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCwgZGlyUGF0aCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZG93bmxvYWRPclByZWZldGNoUGFja2FnZShzaXRlSWQsIGZpbGVMaXN0LCB0cnVlLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkLCBkaXJQYXRoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX3Byb2Nlc3NRdWV1ZVxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUHJvY2Vzc2VzIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbG9vcHMgb3ZlciBpdHNlbGYgdG8ga2VlcCBvbiBwcm9jZXNzaW5nIHRoZSBxdWV1ZSBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICAgKiBUaGUgcXVldWUgcHJvY2VzcyBpcyBzaXRlIGFnbm9zdGljLlxuICAgICAqL1xuICAgIHNlbGYuX3Byb2Nlc3NRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICBpZiAocXVldWVTdGF0ZSAhPT0gUVVFVUVfUlVOTklORykge1xuICAgICAgICAgICAgLy8gU2lsZW50bHkgaWdub3JlLCB0aGUgcXVldWUgaXMgb24gcGF1c2UuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoRVJSX1FVRVVFX09OX1BBVVNFKTtcbiAgICAgICAgICAgIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoISRtbUZTLmlzQXZhaWxhYmxlKCkgfHwgISRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoRVJSX0ZTX09SX05FVFdPUktfVU5BVkFJTEFCTEUpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBzZWxmLl9wcm9jZXNzSW1wb3J0YW50UXVldWVJdGVtKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBBbGwgZ29vZCwgd2Ugc2NoZWR1bGUgbmV4dCBleGVjdXRpb24uXG4gICAgICAgICAgICAkdGltZW91dChzZWxmLl9wcm9jZXNzUXVldWUsIG1tRmlsZXBvb2xRdWV1ZVByb2Nlc3NJbnRlcnZhbCk7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcblxuICAgICAgICAgICAgLy8gV2UgaGFkIGFuIGVycm9yLCBpbiB3aGljaCBjYXNlIHdlIHBhdXNlIHRoZSBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgaWYgKGVycm9yID09PSBFUlJfRlNfT1JfTkVUV09SS19VTkFWQUlMQUJMRSkge1xuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0ZpbGVzeXNlbSBvciBuZXR3b3JrIHVuYXZhaWxhYmxlLCBwYXVzaW5nIHF1ZXVlIHByb2Nlc3NpbmcuJyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgPT09IEVSUl9RVUVVRV9JU19FTVBUWSkge1xuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1F1ZXVlIGlzIGVtcHR5LCBwYXVzaW5nIHF1ZXVlIHByb2Nlc3NpbmcuJyk7XG4gICAgICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRRdWV1ZUVtcHR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcXVldWVTdGF0ZSA9IFFVRVVFX1BBVVNFRDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIG1vc3QgaW1wb3J0YW50IHF1ZXVlIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX3Byb2Nlc3NJbXBvcnRhbnRRdWV1ZUl0ZW1cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBvbiBzdWNjZXNzLiBSZWplY3RlZCBvbiBmYWlsdXJlLlxuICAgICAqL1xuICAgIHNlbGYuX3Byb2Nlc3NJbXBvcnRhbnRRdWV1ZUl0ZW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLnF1ZXJ5KG1tRmlsZXBvb2xRdWV1ZVN0b3JlLCB1bmRlZmluZWQsICdzb3J0b3JkZXInLCB1bmRlZmluZWQsIDEpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChFUlJfUVVFVUVfSVNfRU1QVFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3Byb2Nlc3NRdWV1ZUl0ZW0oaXRlbSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChFUlJfUVVFVUVfSVNfRU1QVFkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHF1ZXVlIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX3Byb2Nlc3NRdWV1ZUl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgb2JqZWN0IGZyb20gdGhlIHF1ZXVlIHN0b3JlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIG9uIHN1Y2Nlc3MuIFJlamVjdGVkIG9uIGZhaWx1cmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX3Byb2Nlc3NRdWV1ZUl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBzaXRlSWQgPSBpdGVtLnNpdGVJZCxcbiAgICAgICAgICAgIGZpbGVJZCA9IGl0ZW0uZmlsZUlkLFxuICAgICAgICAgICAgZmlsZVVybCA9IGl0ZW0udXJsLFxuICAgICAgICAgICAgcmV2aXNpb24gPSBpdGVtLnJldmlzaW9uLFxuICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gaXRlbS50aW1lbW9kaWZpZWQsXG4gICAgICAgICAgICBmaWxlUGF0aCA9IGl0ZW0ucGF0aCxcbiAgICAgICAgICAgIGxpbmtzID0gaXRlbS5saW5rcyB8fCBbXTtcblxuICAgICAgICAkbG9nLmRlYnVnKCdQcm9jZXNzaW5nIHF1ZXVlIGl0ZW06ICcgKyBzaXRlSWQgKyAnLCAnICsgZmlsZUlkKTtcbiAgICAgICAgcmV0dXJuIGdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5nZXQobW1GaWxlcG9vbFN0b3JlLCBmaWxlSWQpLnRoZW4oZnVuY3Rpb24oZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlT2JqZWN0ICYmICFzZWxmLl9pc0ZpbGVPdXRkYXRlZChmaWxlT2JqZWN0LCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRoZSBmaWxlLCBpdCBpcyBub3Qgc3RhbGUsIHdlIGNhbiB1cGRhdGUgbGlua3MgYW5kIHJlbW92ZSBmcm9tIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdRdWV1ZWQgZmlsZSBhbHJlYWR5IGluIHN0b3JlLCBpZ25vcmluZy4uLicpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRGaWxlTGlua3Moc2l0ZUlkLCBmaWxlSWQsIGxpbmtzKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlRnJvbVF1ZXVlKHNpdGVJZCwgZmlsZUlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJlYXRRdWV1ZURlZmVycmVkKHNpdGVJZCwgZmlsZUlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX25vdGlmeUZpbGVEb3dubG9hZGVkKHNpdGVJZCwgZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSBkb2VzIG5vdCBleGlzdCwgb3IgaXMgc3RhbGUsIC4uLiBkb3dubG9hZCBpdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gZG93bmxvYWQoc2l0ZUlkLCBmaWxlVXJsLCBmaWxlT2JqZWN0LCBsaW5rcyk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSBkb2VzIG5vdCBleGlzdCwgZG93bmxvYWQgaXQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvd25sb2FkKHNpdGVJZCwgZmlsZVVybCwgdW5kZWZpbmVkLCBsaW5rcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDb3VsZG4ndCBnZXQgc2l0ZSBEQiwgc2l0ZSB3YXMgcHJvYmFibHkgZGVsZXRlZC5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0l0ZW0gZHJvcHBlZCBmcm9tIHF1ZXVlIGR1ZSB0byBzaXRlIERCIG5vdCByZXRyaWV2ZWQ6ICcgKyBmaWxlVXJsKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZW1vdmVGcm9tUXVldWUoc2l0ZUlkLCBmaWxlSWQpLmNhdGNoKGZ1bmN0aW9uKCkge30pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fdHJlYXRRdWV1ZURlZmVycmVkKHNpdGVJZCwgZmlsZUlkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fbm90aWZ5RmlsZURvd25sb2FkRXJyb3Ioc2l0ZUlkLCBmaWxlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb3dubG9hZCBoZWxwZXIgdG8gYXZvaWQgY29kZSBkdXBsaWNhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRvd25sb2FkKHNpdGVJZCwgZmlsZVVybCwgZmlsZU9iamVjdCwgbGlua3MpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9kb3dubG9hZEZvclBvb2xCeVVybChzaXRlSWQsIGZpbGVVcmwsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQsIGZpbGVQYXRoLCBmaWxlT2JqZWN0KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcywgd2UgYWRkIGxpbmtzIGFuZCByZW1vdmUgZnJvbSBxdWV1ZS5cbiAgICAgICAgICAgICAgICBzZWxmLl9hZGRGaWxlTGlua3Moc2l0ZUlkLCBmaWxlSWQsIGxpbmtzKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gc2VsZi5fcmVtb3ZlRnJvbVF1ZXVlKHNpdGVJZCwgZmlsZUlkKTtcblxuICAgICAgICAgICAgICAgIHNlbGYuX3RyZWF0UXVldWVEZWZlcnJlZChzaXRlSWQsIGZpbGVJZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fbm90aWZ5RmlsZURvd25sb2FkZWQoc2l0ZUlkLCBmaWxlSWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGl0ZW0gdG8gYmUgcmVtb3ZlZCBmcm9tIHF1ZXVlIGJlZm9yZSByZXNvbHZpbmcgdGhlIHByb21pc2UuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGl0ZW0gY291bGQgbm90IGJlIHJlbW92ZWQgZnJvbSBxdWV1ZSB3ZSBzdGlsbCByZXNvbHZlIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uKCkge30pO1xuXG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIFdob29wcywgd2UgaGF2ZSBhbiBlcnJvci4uLlxuICAgICAgICAgICAgICAgIHZhciBkcm9wRnJvbVF1ZXVlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yT2JqZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBlcnJvck9iamVjdC5zb3VyY2UgPT09IGZpbGVVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBtb3N0IGxpa2VseSBhICRjb3Jkb3ZhRmlsZVRyYW5zZmVyIGVycm9yLlxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvck9iamVjdC5jb2RlID09PSAxKSB7IC8vIEZJTEVfTk9UX0ZPVU5EX0VSUi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIHdhcyBub3QgZm91bmQsIG1vc3QgbGlrZWx5IGEgNDA0LCB3ZSByZW1vdmUgZnJvbSBxdWV1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BGcm9tUXVldWUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JPYmplY3QuY29kZSA9PT0gMikgeyAvLyBJTlZBTElEX1VSTF9FUlIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgVVJMIGlzIGludmFsaWQsIHdlIGRyb3AgdGhlIGZpbGUgZnJvbSB0aGUgcXVldWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wRnJvbVF1ZXVlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yT2JqZWN0LmNvZGUgPT09IDMpIHsgLy8gQ09OTkVDVElPTl9FUlIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gSFRUUCBzdGF0dXMsIHRoZW4gbGV0J3MgcmVtb3ZlIGZyb20gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEZyb21RdWV1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JPYmplY3QuY29kZSA9PT0gNCkgeyAvLyBBQk9SVEVEX0VSUi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0cmFuc2ZlciB3YXMgYWJvcnRlZCwgd2Ugd2lsbCBrZWVwIHRoZSBmaWxlIGluIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yT2JqZWN0LmNvZGUgPT09IDUpIHsgLy8gTk9UX01PRElGSUVEX0VSUi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoZSBmaWxlLCBIVFRQIDMwNCBzdGF0dXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wRnJvbVF1ZXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVua25vd24gZXJyb3IsIGxldCdzIHJlbW92ZSB0aGUgZmlsZSBmcm9tIHRoZSBxdWV1ZSB0byBhdm9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9ja2luZyBkb3duIHRoZSBxdWV1ZSBiZWNhdXNlIG9mIG9uZSBmaWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEZyb21RdWV1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkcm9wRnJvbVF1ZXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZHJvcEZyb21RdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdJdGVtIGRyb3BwZWQgZnJvbSBxdWV1ZSBkdWUgdG8gZXJyb3I6ICcgKyBmaWxlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHNlbGYuX3JlbW92ZUZyb21RdWV1ZShzaXRlSWQsIGZpbGVJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhpcyBhcyBhIHNpbGVudCBlcnJvciwgbmV2ZXIgcmVqZWN0IHRoZSBwcm9taXNlIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uKCkge30pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90cmVhdFF1ZXVlRGVmZXJyZWQoc2l0ZUlkLCBmaWxlSWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX25vdGlmeUZpbGVEb3dubG9hZEVycm9yKHNpdGVJZCwgZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY29uc2lkZXJlZCB0aGUgZmlsZSBhcyBsZWdpdCBidXQgZGlkIG5vdCBnZXQgaXQsIGZhaWx1cmUuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyZWF0UXVldWVEZWZlcnJlZChzaXRlSWQsIGZpbGVJZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9ub3RpZnlGaWxlRG93bmxvYWRFcnJvcihzaXRlSWQsIGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgcHJvZ3Jlc3Mgb2JqZWN0IHRvIHRoZSBxdWV1ZSBkZWZlcnJlZC5cbiAgICAgICAgICAgICAgICBpZiAocXVldWVEZWZlcnJlZHNbc2l0ZUlkXSAmJiBxdWV1ZURlZmVycmVkc1tzaXRlSWRdW2ZpbGVJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVEZWZlcnJlZHNbc2l0ZUlkXVtmaWxlSWRdLm5vdGlmeShwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBmaWxlIGZyb20gdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19yZW1vdmVGcm9tUXVldWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlSWQgVGhlIGZpbGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgb24gc3VjY2Vzcy4gUmVqZWN0ZWQgb24gZmFpbHVyZS4gSXQgaXMgYWR2aXNlZCB0byBzaWxlbnRseSBpZ25vcmUgZmFpbHVyZXMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX3JlbW92ZUZyb21RdWV1ZSA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5yZW1vdmUobW1GaWxlcG9vbFF1ZXVlU3RvcmUsIFtzaXRlSWQsIGZpbGVJZF0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBmaWxlIGZyb20gdGhlIHBvb2wuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRmlsZXBvb2wjX3JlbW92ZUZpbGVCeUlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZUlkIFRoZSBmaWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIG9uIHN1Y2Nlc3MuIFJlamVjdGVkIG9uIGZhaWx1cmUuIEl0IGlzIGFkdmlzZWQgdG8gc2lsZW50bHkgaWdub3JlIGZhaWx1cmVzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9yZW1vdmVGaWxlQnlJZCA9IGZ1bmN0aW9uKHNpdGVJZCwgZmlsZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICB2YXIgcDEsIHAyLCBwMztcbiAgICAgICAgICAgIHAxID0gZGIucmVtb3ZlKG1tRmlsZXBvb2xTdG9yZSwgZmlsZUlkKTtcbiAgICAgICAgICAgIHAyID0gZGIud2hlcmUobW1GaWxlcG9vbExpbmtzU3RvcmUsICdmaWxlSWQnLCAnPScsIGZpbGVJZCkudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChlbnRyaWVzLm1hcChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIucmVtb3ZlKG1tRmlsZXBvb2xMaW5rc1N0b3JlLCBbZW50cnkuZmlsZUlkLCBlbnRyeS5jb21wb25lbnQsIGVudHJ5LmNvbXBvbmVudElkXSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwMyA9ICRtbUZTLmlzQXZhaWxhYmxlKCkgPyAkbW1GUy5yZW1vdmVGaWxlKHNlbGYuX2dldEZpbGVQYXRoKHNpdGVJZCwgZmlsZUlkKSkgOiAkcS53aGVuKCk7XG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKFtwMSwgcDIsIHAzXSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYWxsIHRoZSBtYXRjaGluZyBmaWxlcyBmcm9tIGEgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI3JlbW92ZUZpbGVzQnlDb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgICBUaGUgY29tcG9uZW50IHRvIGxpbmsgdGhlIGZpbGUgdG8uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb25lbnRJZF0gQW4gSUQgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBSZXNvbHZlZCBvbiBzdWNjZXNzLiBSZWplY3RlZCBvbiBmYWlsdXJlLlxuICAgICAqL1xuICAgIHNlbGYucmVtb3ZlRmlsZXNCeUNvbXBvbmVudCA9IGZ1bmN0aW9uKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCkge1xuICAgICAgICB2YXIgd2hlcmU7XG4gICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aGVyZSA9IFsnY29tcG9uZW50QW5kSWQnLCAnPScsIFtjb21wb25lbnQsIHNlbGYuX2ZpeENvbXBvbmVudElkKGNvbXBvbmVudElkKV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlcmUgPSBbJ2NvbXBvbmVudCcsICc9JywgY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGIucXVlcnkobW1GaWxlcG9vbExpbmtzU3RvcmUsIHdoZXJlKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChpdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZW1vdmVGaWxlQnlJZChzaXRlSWQsIGl0ZW0uZmlsZUlkKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGZpbGUgZnJvbSB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNyZW1vdmVGaWxlQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICBUaGUgc2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVVybCBUaGUgZmlsZSBVUkwuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUmVzb2x2ZWQgb24gc3VjY2VzcywgcmVqZWN0ZWQgb24gZmFpbHVyZS4gSXQgaXMgYWR2aXNlZCB0byBzaWxlbnRseSBpZ25vcmUgZmFpbHVyZXMuXG4gICAgICovXG4gICAgc2VsZi5yZW1vdmVGaWxlQnlVcmwgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVVcmwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpeFBsdWdpbmZpbGVVUkwoc2l0ZUlkLCBmaWxlVXJsKS50aGVuKGZ1bmN0aW9uKGZpbGVVcmwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlSWQgPSBzZWxmLl9nZXRGaWxlSWRCeVVybChmaWxlVXJsKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZW1vdmVGaWxlQnlJZChzaXRlSWQsIGZpbGVJZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSByZXZpc2lvbiBudW1iZXIgZnJvbSBhIGZpbGUgVVJMLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI19yZW1vdmVSZXZpc2lvbkZyb21VcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byByZW1vdmUgdGhlIHJldmlzaW9uIG51bWJlci5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgIFVSTCB3aXRob3V0IHJldmlzaW9uIG51bWJlci5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIHJldmlzaW9uIGlzIHVzZWQgdG8ga25vdyBpZiBhIGZpbGUgaGFzIGNoYW5nZWQuIFdlIHJlbW92ZSBpdCBmcm9tIHRoZSBVUkwgdG8gcHJldmVudCBzdG9yaW5nIGEgZmlsZSBwZXIgcmV2aXNpb24uXG4gICAgICovXG4gICAgc2VsZi5fcmVtb3ZlUmV2aXNpb25Gcm9tVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHJldHVybiB1cmwucmVwbGFjZShyZXZpc2lvblJlZ2V4LCAnL2NvbnRlbnQvMC8nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBwYWNrYWdlIHN0YXR1cywgc2V0dGluZyBpdCB0byB0aGUgcHJldmlvdXMgc3RhdHVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI3NldFBhY2thZ2VQcmV2aW91c1N0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgICAgUGFja2FnZSdzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvbmVudElkXSBBbiBJRCB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgc3RhdHVzIGlzIGNoYW5nZWQuIFJlc29sdmUgcGFyYW06IG5ldyBzdGF0dXMuXG4gICAgICovXG4gICAgc2VsZi5zZXRQYWNrYWdlUHJldmlvdXNTdGF0dXMgPSBmdW5jdGlvbihzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnU2V0IHByZXZpb3VzIHN0YXR1cyBmb3IgcGFja2FnZSAnICsgY29tcG9uZW50ICsgJyAnICsgY29tcG9uZW50SWQpO1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciBkYiA9IHNpdGUuZ2V0RGIoKSxcbiAgICAgICAgICAgICAgICBwYWNrYWdlSWQgPSBzZWxmLmdldFBhY2thZ2VJZChjb21wb25lbnQsIGNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgc3RvcmVkIGRhdGEsIHdlJ2xsIG9ubHkgdXBkYXRlICdzdGF0dXMnIGFuZCAndXBkYXRlZCcgZmllbGRzLlxuICAgICAgICAgICAgcmV0dXJuIGRiLmdldChtbUZpbGVwb29sUGFja2FnZXNTdG9yZSwgcGFja2FnZUlkKS50aGVuKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgZW50cnkuc3RhdHVzID0gZW50cnkucHJldmlvdXMgfHwgbW1Db3JlTm90RG93bmxvYWRlZDtcbiAgICAgICAgICAgICAgICBlbnRyeS51cGRhdGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnU2V0IHN0YXR1cyBcXCcnICsgZW50cnkuc3RhdHVzICsgJ1xcJyBmb3IgcGFja2FnZSAnICsgY29tcG9uZW50ICsgJyAnICsgY29tcG9uZW50SWQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRiLmluc2VydChtbUZpbGVwb29sUGFja2FnZXNTdG9yZSwgZW50cnkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MgdXBkYXRpbmcsIHRyaWdnZXIgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyaWdnZXJQYWNrYWdlU3RhdHVzQ2hhbmdlZChzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIGVudHJ5LnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIHBhY2thZ2Ugc3RhdHVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI3N0b3JlUGFja2FnZVN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgICAgICAgUGFja2FnZSdzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvbmVudElkXSAgICBBbiBJRCB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0dXMgICAgICAgICAgIE5ldyBwYWNrYWdlIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3JldmlzaW9uPTBdICAgICBQYWNrYWdlJ3MgcmV2aXNpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWQ9MF0gUGFja2FnZSdzIHRpbWVtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gc3RhdHVzIGlzIHN0b3JlZC5cbiAgICAgKi9cbiAgICBzZWxmLnN0b3JlUGFja2FnZVN0YXR1cyA9IGZ1bmN0aW9uKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgc3RhdHVzLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ1NldCBzdGF0dXMgXFwnJyArIHN0YXR1cyArICdcXCcgZm9yIHBhY2thZ2UgJyArIGNvbXBvbmVudCArICcgJyArIGNvbXBvbmVudElkKTtcbiAgICAgICAgcmV2aXNpb24gPSByZXZpc2lvbiB8fCAwO1xuICAgICAgICB0aW1lbW9kaWZpZWQgPSB0aW1lbW9kaWZpZWQgfHwgMDtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciBkYiA9IHNpdGUuZ2V0RGIoKSxcbiAgICAgICAgICAgICAgICBwYWNrYWdlSWQgPSBzZWxmLmdldFBhY2thZ2VJZChjb21wb25lbnQsIGNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgLy8gU2VhcmNoIGN1cnJlbnQgc3RhdHVzIHRvIHNldCBpdCBhcyBwcmV2aW91cyBzdGF0dXMuXG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0KG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlLCBwYWNrYWdlSWQpLnRoZW4oZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuc3RhdHVzO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gTm8gcHJldmlvdXMgc3RhdHVzLlxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihwcmV2aW91c1N0YXR1cykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1N0YXR1cyA9PT0gc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwYWNrYWdlIGFscmVhZHkgaGFzIHRoaXMgc3RhdHVzLCBubyBuZWVkIHRvIGNoYW5nZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gZGIuaW5zZXJ0KG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcGFja2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJZDogY29tcG9uZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzOiBwcmV2aW91c1N0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmlzaW9uOiByZXZpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZDogdGltZW1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZDogbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2VzcyBpbnNlcnRpbmcsIHRyaWdnZXIgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyaWdnZXJQYWNrYWdlU3RhdHVzQ2hhbmdlZChzaXRlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIG9yIHJlamVjdHMgYSBxdWV1ZSBkZWZlcnJlZCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZpbGVwb29sI190cmVhdFF1ZXVlRGVmZXJyZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgVGhlIHNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVJZCAgIFRoZSBmaWxlIElELlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzb2x2ZSBUcnVlIGlmIHByb21pc2Ugc2hvdWxkIGJlIHJlc29sdmVkLCBmYWxzZSBpZiBpdCBzaG91bGQgYmUgcmVqZWN0ZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIERlZmVycmVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl90cmVhdFF1ZXVlRGVmZXJyZWQgPSBmdW5jdGlvbihzaXRlSWQsIGZpbGVJZCwgcmVzb2x2ZSkge1xuICAgICAgICBpZiAocXVldWVEZWZlcnJlZHNbc2l0ZUlkXSAmJiBxdWV1ZURlZmVycmVkc1tzaXRlSWRdW2ZpbGVJZF0pIHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgcXVldWVEZWZlcnJlZHNbc2l0ZUlkXVtmaWxlSWRdLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVEZWZlcnJlZHNbc2l0ZUlkXVtmaWxlSWRdLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHF1ZXVlRGVmZXJyZWRzW3NpdGVJZF1bZmlsZUlkXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQgd2l0aCB0aGUgcmlnaHQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GaWxlcG9vbCNfdHJpZ2dlclBhY2thZ2VTdGF0dXNDaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50ICAgICBQYWNrYWdlJ3MgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdIEFuIElEIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXR1cyAgICAgICAgTmV3IHBhY2thZ2Ugc3RhdHVzLlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX3RyaWdnZXJQYWNrYWdlU3RhdHVzQ2hhbmdlZCA9IGZ1bmN0aW9uKHNpdGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgc3RhdHVzKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgc2l0ZWlkOiBzaXRlSWQsXG4gICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGNvbXBvbmVudElkOiBjb21wb25lbnRJZCxcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzXG4gICAgICAgIH07XG4gICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsIGRhdGEpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pXG5cbi5ydW4oZnVuY3Rpb24oJGxvZywgJGlvbmljUGxhdGZvcm0sICR0aW1lb3V0LCAkbW1GaWxlcG9vbCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1GaWxlcG9vbCcpO1xuXG4gICAgJGlvbmljUGxhdGZvcm0ucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdhaXRpbmcgZm9yIHRoZSBwbGF0Zm9ybSB0byBiZSByZWFkeSwgYW5kIGEgZmV3IG1vcmUgYmVmb3JlIHdlIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIHF1ZXVlLlxuICAgICAgICAkdGltZW91dCgkbW1GaWxlcG9vbC5jaGVja1F1ZXVlUHJvY2Vzc2luZywgMTAwMCk7XG4gICAgfSk7XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLmNvbnN0YW50KCdtbUZzU2l0ZXNGb2xkZXInLCAnc2l0ZXMnKVxuLmNvbnN0YW50KCdtbUZzVG1wRm9sZGVyJywgJ3RtcCcpXG5cbi8qKlxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUZTXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzZXJ2aWNlIGhhbmRsZXMgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIEZpbGVTeXN0ZW0uXG4gKi9cbi5mYWN0b3J5KCckbW1GUycsIGZ1bmN0aW9uKCRpb25pY1BsYXRmb3JtLCAkY29yZG92YUZpbGUsICRsb2csICRxLCAkaHR0cCwgJGNvcmRvdmFaaXAsIG1tRnNTaXRlc0ZvbGRlciwgbW1Gc1RtcEZvbGRlcikge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUZTJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBpbml0aWFsaXplZCA9IGZhbHNlLFxuICAgICAgICBiYXNlUGF0aCA9ICcnLFxuICAgICAgICBpc0hUTUxBUEkgPSBmYWxzZSxcbiAgICAgICAgbWltZVR5cGVzID0ge307XG5cbiAgICAvLyBMb2FkaW5nIGFsbCB0aGUgbWltZXR5cGVzLlxuICAgICRodHRwLmdldCgnY29yZS9hc3NldHMvbWltZXR5cGVzLmpzb24nKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIG1pbWVUeXBlcyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEl0IGZhaWxlZCwgbmV2ZXIgbWluZC4uLlxuICAgIH0pO1xuXG4gICAgLy8gRm9ybWF0cyB0byByZWFkIGEgZmlsZS5cbiAgICBzZWxmLkZPUk1BVFRFWFQgICAgICAgICA9IDA7XG4gICAgc2VsZi5GT1JNQVREQVRBVVJMICAgICAgPSAxO1xuICAgIHNlbGYuRk9STUFUQklOQVJZU1RSSU5HID0gMjtcbiAgICBzZWxmLkZPUk1BVEFSUkFZQlVGRkVSICA9IDM7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGJhc2VQYXRoIHRvIHVzZSB3aXRoIEhUTUwgQVBJLiBSZXNlcnZlZCBmb3IgY29yZSB1c2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjc2V0SFRNTEJhc2VQYXRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggQmFzZSBwYXRoIHRvIHVzZS5cbiAgICAgKi9cbiAgICBzZWxmLnNldEhUTUxCYXNlUGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgaXNIVE1MQVBJID0gdHJ1ZTtcbiAgICAgICAgYmFzZVBhdGggPSBwYXRoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgd2UncmUgdXNpbmcgSFRNTCBBUEkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjdXNlc0hUTUxBUElcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHVzZXMgSFRNTCBBUEksIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLnVzZXNIVE1MQVBJID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc0hUTUxBUEk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYmFzZVBhdGggYmFzZWQgb24gdGhlIE9TIGlmIGl0J3Mgbm90IGluaXRpYWxpemVkIGFscmVhZHkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjaW5pdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgaW5pdGlhbGl6YXRpb24gaXMgZmluaXNoZWQuXG4gICAgICovXG4gICAgc2VsZi5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgJGlvbmljUGxhdGZvcm0ucmVhZHkoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgICAgICAgICAgIGJhc2VQYXRoID0gY29yZG92YS5maWxlLmV4dGVybmFsQXBwbGljYXRpb25TdG9yYWdlRGlyZWN0b3J5O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICAgICAgICAgICAgYmFzZVBhdGggPSBjb3Jkb3ZhLmZpbGUuZG9jdW1lbnRzRGlyZWN0b3J5O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc2VsZi5pc0F2YWlsYWJsZSgpIHx8IGJhc2VQYXRoID09PSAnJykge1xuICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZGV2aWNlIE9TLicpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRlMgaW5pdGlhbGl6ZWQ6ICcrYmFzZVBhdGgpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBsdWdpbiBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIHdoZW4gY29yZG92YSBpcyBpbml0aWFsaXNlZC5cbiAgICAgKi9cbiAgICBzZWxmLmlzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93LnJlc29sdmVMb2NhbEZpbGVTeXN0ZW1VUkwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBGaWxlVHJhbnNmZXIgIT09ICd1bmRlZmluZWQnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBmaWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2dldEZpbGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBwYXRoIFJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGZpbGUgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW5pdCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdHZXQgZmlsZTogJytwYXRoKTtcbiAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUuY2hlY2tGaWxlKGJhc2VQYXRoLCBwYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGRpcmVjdG9yeS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNnZXREaXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBwYXRoIFJlbGF0aXZlIHBhdGggdG8gdGhlIGRpcmVjdG9yeS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZGlyZWN0b3J5IGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldERpciA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW5pdCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdHZXQgZGlyZWN0b3J5OiAnK3BhdGgpO1xuICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5jaGVja0RpcihiYXNlUGF0aCwgcGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2l0ZSBmb2xkZXIgcGF0aC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNnZXRTaXRlRm9sZGVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgU2l0ZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICBTaXRlIGZvbGRlciBwYXRoLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2l0ZUZvbGRlciA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICByZXR1cm4gbW1Gc1NpdGVzRm9sZGVyICsgJy8nICsgc2l0ZUlkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkaXJlY3Rvcnkgb3IgYSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXNEaXJlY3RvcnkgIFRydWUgaWYgYSBkaXJlY3Rvcnkgc2hvdWxkIGJlIGNyZWF0ZWQsIGZhbHNlIGlmIGl0IHNob3VsZCBjcmVhdGUgYSBmaWxlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHBhdGggICAgICAgICBSZWxhdGl2ZSBwYXRoIHRvIHRoZSBkaXIvZmlsZS5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBmYWlsSWZFeGlzdHMgVHJ1ZSBpZiBpdCBzaG91bGQgZmFpbCBpZiB0aGUgZGlyL2ZpbGUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgYmFzZSAgICAgICAgIEJhc2UgcGF0aCB0byBjcmVhdGUgdGhlIGRpci9maWxlIGluLiBJZiBub3Qgc2V0LCB1c2UgYmFzZVBhdGguXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZGlyL2ZpbGUgaXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoaXNEaXJlY3RvcnksIHBhdGgsIGZhaWxJZkV4aXN0cywgYmFzZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlIHx8IGJhc2VQYXRoO1xuXG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCcvJykgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ3JlYXRlIGRpciAnICsgcGF0aCArICcgaW4gJyArIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLmNyZWF0ZURpcihiYXNlLCBwYXRoLCAhZmFpbElmRXhpc3RzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdDcmVhdGUgZmlsZSAnICsgcGF0aCArICcgaW4gJyArIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLmNyZWF0ZUZpbGUoYmFzZSwgcGF0aCwgIWZhaWxJZkV4aXN0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAkY29yZG92YUZpbGUgZG9lc24ndCBhbGxvdyBjcmVhdGluZyBtb3JlIHRoYW4gMSBsZXZlbCBhdCBhIHRpbWUgKGUuZy4gdG1wL2ZvbGRlcikuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjcmVhdGUgdGhlbSAxIGJ5IDEuXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0RGlyID0gcGF0aC5zdWJzdHIoMCwgcGF0aC5pbmRleE9mKCcvJykpO1xuICAgICAgICAgICAgICAgIHZhciByZXN0T2ZQYXRoID0gcGF0aC5zdWJzdHIocGF0aC5pbmRleE9mKCcvJykgKyAxKTtcblxuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0NyZWF0ZSBkaXIgJyArIGZpcnN0RGlyICsgJyBpbiAnICsgYmFzZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLmNyZWF0ZURpcihiYXNlLCBmaXJzdERpciwgdHJ1ZSkudGhlbihmdW5jdGlvbihuZXdEaXJFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKGlzRGlyZWN0b3J5LCByZXN0T2ZQYXRoLCBmYWlsSWZFeGlzdHMsIG5ld0RpckVudHJ5LnRvVVJMKCkpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGRpcmVjdG9yeSAnICsgZmlyc3REaXIgKyAnIGluICcgKyBiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRpcmVjdG9yeS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNjcmVhdGVEaXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBwYXRoICAgICAgICAgUmVsYXRpdmUgcGF0aCB0byB0aGUgZGlyZWN0b3J5LlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGZhaWxJZkV4aXN0cyBUcnVlIGlmIGl0IHNob3VsZCBmYWlsIGlmIHRoZSBkaXJlY3RvcnkgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZGlyZWN0b3J5IGlzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5jcmVhdGVEaXIgPSBmdW5jdGlvbihwYXRoLCBmYWlsSWZFeGlzdHMpIHtcbiAgICAgICAgZmFpbElmRXhpc3RzID0gZmFpbElmRXhpc3RzIHx8wqBmYWxzZTsgLy8gRGVmYXVsdCB2YWx1ZSBmYWxzZS5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZSh0cnVlLCBwYXRoLCBmYWlsSWZFeGlzdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBmaWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2NyZWF0ZUZpbGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBwYXRoICAgICAgICAgUmVsYXRpdmUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBmYWlsSWZFeGlzdHMgVHJ1ZSBpZiBpdCBzaG91bGQgZmFpbCBpZiB0aGUgZmlsZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZS4uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZSBpcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuY3JlYXRlRmlsZSA9IGZ1bmN0aW9uKHBhdGgsIGZhaWxJZkV4aXN0cykge1xuICAgICAgICBmYWlsSWZFeGlzdHMgPSBmYWlsSWZFeGlzdHMgfHzCoGZhbHNlOyAvLyBEZWZhdWx0IHZhbHVlIGZhbHNlLlxuICAgICAgICByZXR1cm4gY3JlYXRlKGZhbHNlLCBwYXRoLCBmYWlsSWZFeGlzdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZGlyZWN0b3J5IGFuZCBhbGwgaXRzIGNvbnRlbnRzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI3JlbW92ZURpclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHBhdGggICAgUmVsYXRpdmUgcGF0aCB0byB0aGUgZGlyZWN0b3J5LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBkaXJlY3RvcnkgaXMgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLnJlbW92ZURpciA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW5pdCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdSZW1vdmUgZGlyZWN0b3J5OiAnICsgcGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLnJlbW92ZVJlY3Vyc2l2ZWx5KGJhc2VQYXRoLCBwYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBmaWxlIGFuZCBhbGwgaXRzIGNvbnRlbnRzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI3JlbW92ZUZpbGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBwYXRoICAgIFJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGZpbGUgaXMgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLnJlbW92ZUZpbGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmluaXQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnUmVtb3ZlIGZpbGU6ICcgKyBwYXRoKTtcbiAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUucmVtb3ZlRmlsZShiYXNlUGF0aCwgcGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY29udGVudHMgb2YgYSBkaXJlY3RvcnkgKG5vdCBzdWJkaXJlY3RvcmllcykuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjZ2V0RGlyZWN0b3J5Q29udGVudHNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggUmVsYXRpdmUgcGF0aCB0byB0aGUgZGlyZWN0b3J5LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGNvbnRlbnRzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXREaXJlY3RvcnlDb250ZW50cyA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnR2V0IGNvbnRlbnRzIG9mIGRpcjogJyArIHBhdGgpO1xuICAgICAgICByZXR1cm4gc2VsZi5nZXREaXIocGF0aCkudGhlbihmdW5jdGlvbihkaXJFbnRyeSkge1xuXG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgICAgICB2YXIgZGlyZWN0b3J5UmVhZGVyID0gZGlyRW50cnkuY3JlYXRlUmVhZGVyKCk7XG4gICAgICAgICAgICBkaXJlY3RvcnlSZWFkZXIucmVhZEVudHJpZXMoZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNpemUgb2YgYSBkaXJlY3Rvcnkgb3IgYSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoIFJlbGF0aXZlIHBhdGggdG8gdGhlIGRpcmVjdG9yeSBvciBmaWxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHNpemUgaXMgY2FsY3VsYXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaXplKGVudHJ5KSB7XG5cbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcblxuICAgICAgICAgICAgdmFyIGRpcmVjdG9yeVJlYWRlciA9IGVudHJ5LmNyZWF0ZVJlYWRlcigpO1xuICAgICAgICAgICAgZGlyZWN0b3J5UmVhZGVyLnJlYWRFbnRyaWVzKGZ1bmN0aW9uKGVudHJpZXMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGdldFNpemUoZW50cmllc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihzaXplcykge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3RvcnlTaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVTaXplID0gcGFyc2VJbnQoc2l6ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGZpbGVTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeVNpemUgKz0gZmlsZVNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkaXJlY3RvcnlTaXplKTtcblxuICAgICAgICAgICAgICAgIH0sIGRlZmVycmVkLnJlamVjdCk7XG5cbiAgICAgICAgICAgIH0sIGRlZmVycmVkLnJlamVjdCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgICAgIGVudHJ5LmZpbGUoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZmlsZS5zaXplKTtcbiAgICAgICAgICAgIH0sIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNpemUgb2YgYSBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjZ2V0RGlyZWN0b3J5U2l6ZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBSZWxhdGl2ZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgc2l6ZSBpcyBjYWxjdWxhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RGlyZWN0b3J5U2l6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnR2V0IHNpemUgb2YgZGlyOiAnICsgcGF0aCk7XG4gICAgICAgIHJldHVybiBzZWxmLmdldERpcihwYXRoKS50aGVuKGZ1bmN0aW9uKGRpckVudHJ5KSB7XG4gICAgICAgICAgIHJldHVybiBnZXRTaXplKGRpckVudHJ5KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjZ2V0RmlsZVNpemVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggUmVsYXRpdmUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXplIGlzIGNhbGN1bGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRGaWxlU2l6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnR2V0IHNpemUgb2YgZmlsZTogJyArIHBhdGgpO1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRGaWxlKHBhdGgpLnRoZW4oZnVuY3Rpb24oZmlsZUVudHJ5KSB7XG4gICAgICAgICAgIHJldHVybiBnZXRTaXplKGZpbGVFbnRyeSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZSBvYmplY3QgZnJvbSBhIEZpbGVFbnRyeS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNnZXRGaWxlU2l6ZUZyb21GaWxlRW50cnlcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggUmVsYXRpdmUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXplIGlzIGNhbGN1bGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRGaWxlT2JqZWN0RnJvbUZpbGVFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICRsb2cuZGVidWcoJ0dldCBmaWxlIG9iamVjdCBvZjogJyArIGVudHJ5LmZ1bGxQYXRoKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgZW50cnkuZmlsZShmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGZpbGUpO1xuICAgICAgICB9LCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmcmVlIHNwYWNlIGluIHRoZSBkaXNrLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2NhbGN1bGF0ZUZyZWVTcGFjZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZXN0aW1hdGVkIGZyZWUgc3BhY2UgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgc2VsZi5jYWxjdWxhdGVGcmVlU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGlvbmljLlBsYXRmb3JtLmlzSU9TKCkgfHwgaXNIVE1MQVBJKSB7XG4gICAgICAgICAgICAvLyBnZXRGcmVlRGlza1NwYWNlIGRvZXNuJ3Qgd29yayBvbiBpT1MuIFNlZSBodHRwczovL3RyYWNrZXIubW9vZGxlLm9yZy9icm93c2UvTU9CSUxFLTk1Ni5cbiAgICAgICAgICAgIC8vIFVnbHkgZml4OiByZXF1ZXN0IGEgZmlsZSBzeXN0ZW0gaW5zdGFuY2Ugd2l0aCBhIG1pbmltdW0gc2l6ZSB1bnRpbCB3ZSBnZXQgYW4gZXJyb3IuXG5cbiAgICAgICAgICAgIGlmICh3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0pIHtcblxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbWF4SXRlcmF0aW9ucyA9IDUwLFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYWxjdWxhdGVCeVJlcXVlc3Qoc2l6ZSwgcmF0aW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0oTG9jYWxGaWxlU3lzdGVtLlBFUlNJU1RFTlQsIHNpemUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPiBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVCeVJlcXVlc3Qoc2l6ZSAqIHJhdGlvLCByYXRpbykudGhlbihkZWZlcnJlZC5yZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHNpemUgLyByYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBHZW5lcmFsIGNhbGN1bGF0aW9uLCBiYXNlIDFNQiBhbmQgaW5jcmVhc2luZyBmYWN0b3IgMS4zLlxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUJ5UmVxdWVzdCgxMDQ4NTc2LCAxLjMpLnRoZW4oZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3JlIGFjY3VyYXRlLiBGYWN0b3IgaXMgMS4xLlxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVCeVJlcXVlc3Qoc2l6ZSwgMS4xKS50aGVuKGRlZmVycmVkLnJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5nZXRGcmVlRGlza1NwYWNlKCkudGhlbihmdW5jdGlvbihzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemUgKiAxMDI0OyAvLyBHZXRGcmVlRGlza1NwYWNlIHJldHVybnMgS0IuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgYSBmaWxlbmFtZSB0aGF0IHVzdWFsbHkgY29tZXMgVVJMIGVuY29kZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjbm9ybWFsaXplRmlsZU5hbWVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVuYW1lIFRoZSBmaWxlIG5hbWUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICBUaGUgZmlsZSBuYW1lIG5vcm1hbGl6ZWQuXG4gICAgICovXG4gICAgc2VsZi5ub3JtYWxpemVGaWxlTmFtZSA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gICAgICAgIGZpbGVuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgZmlsZSBmcm9tIGxvY2FsIGZpbGUgc3lzdGVtLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI3JlYWRGaWxlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgcGF0aCAgIFJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgZm9ybWF0IEZvcm1hdCB0byByZWFkIHRoZSBmaWxlLiBCeSBkZWZhdWx0LCBGT1JNQVRURVhULiBNdXN0IGJlIG9uZSBvZjpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1GUy5GT1JNQVRURVhUXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tRlMuRk9STUFUREFUQVVSTFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUZTLkZPUk1BVEJJTkFSWVNUUklOR1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUZTLkZPUk1BVEFSUkFZQlVGRkVSXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZSBpcyByZWFkLlxuICAgICAqL1xuICAgIHNlbGYucmVhZEZpbGUgPSBmdW5jdGlvbihwYXRoLCBmb3JtYXQpIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IHNlbGYuRk9STUFUVEVYVDtcbiAgICAgICAgJGxvZy5kZWJ1ZygnUmVhZCBmaWxlICcgKyBwYXRoICsgJyB3aXRoIGZvcm1hdCAnK2Zvcm1hdCk7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIHNlbGYuRk9STUFUREFUQVVSTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLnJlYWRBc0RhdGFVUkwoYmFzZVBhdGgsIHBhdGgpO1xuICAgICAgICAgICAgY2FzZSBzZWxmLkZPUk1BVEJJTkFSWVNUUklORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLnJlYWRBc0JpbmFyeVN0cmluZyhiYXNlUGF0aCwgcGF0aCk7XG4gICAgICAgICAgICBjYXNlIHNlbGYuRk9STUFUQVJSQVlCVUZGRVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5yZWFkQXNBcnJheUJ1ZmZlcihiYXNlUGF0aCwgcGF0aCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUucmVhZEFzVGV4dChiYXNlUGF0aCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBmaWxlIGNvbnRlbnRzIGZyb20gYSBmaWxlIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI3JlYWRGaWxlRGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIGZpbGVEYXRhIEZpbGUncyBkYXRhLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gIGZvcm1hdCAgIEZvcm1hdCB0byByZWFkIHRoZSBmaWxlLiBCeSBkZWZhdWx0LCBGT1JNQVRURVhULiBNdXN0IGJlIG9uZSBvZjpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1GUy5GT1JNQVRURVhUXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tRlMuRk9STUFUREFUQVVSTFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUZTLkZPUk1BVEJJTkFSWVNUUklOR1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUZTLkZPUk1BVEFSUkFZQlVGRkVSXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBmaWxlIGlzIHJlYWQuXG4gICAgICovXG4gICAgc2VsZi5yZWFkRmlsZURhdGEgPSBmdW5jdGlvbihmaWxlRGF0YSwgZm9ybWF0KSB7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCBzZWxmLkZPUk1BVFRFWFQ7XG4gICAgICAgICRsb2cuZGVidWcoJ1JlYWQgZmlsZSBmcm9tIGZpbGUgZGF0YSB3aXRoIGZvcm1hdCAnK2Zvcm1hdCk7XG5cbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgaWYgKGV2dC50YXJnZXQucmVzdWx0ICE9PSB1bmRlZmluZWQgfHwgZXZ0LnRhcmdldC5yZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGV2dC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LnRhcmdldC5lcnJvciAhPT0gdW5kZWZpbmVkIHx8IGV2dC50YXJnZXQuZXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXZ0LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCh7Y29kZTogbnVsbCwgbWVzc2FnZTogJ1JFQURFUl9PTkxPQURFTkRfRVJSJ30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIHNlbGYuRk9STUFUREFUQVVSTDpcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlRGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNlbGYuRk9STUFUQklOQVJZU1RSSU5HOlxuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcoZmlsZURhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzZWxmLkZPUk1BVEFSUkFZQlVGRkVSOlxuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlRGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGVEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgc29tZSBkYXRhIGluIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyN3cml0ZUZpbGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBwYXRoIFJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgZGF0YSBEYXRhIHRvIHdyaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBmaWxlIGlzIHdyaXR0ZW4uXG4gICAgICovXG4gICAgc2VsZi53cml0ZUZpbGUgPSBmdW5jdGlvbihwYXRoLCBkYXRhKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ1dyaXRlIGZpbGU6ICcgKyBwYXRoKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW5pdCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgZmlsZSAoYW5kIHBhcmVudCBmb2xkZXJzKSB0byBwcmV2ZW50IGVycm9ycy5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNyZWF0ZUZpbGUocGF0aCkudGhlbihmdW5jdGlvbihmaWxlRW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIVE1MQVBJICYmIHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gd3JpdGUgQmxvYnMuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc2VsZi5nZXRNaW1lVHlwZShzZWxmLmdldEZpbGVFeHRlbnNpb24ocGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdLCB7dHlwZTogdHlwZcKgfHwgJ3RleHQvcGxhaW4nfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUud3JpdGVGaWxlKGJhc2VQYXRoLCBwYXRoLCBkYXRhLCB0cnVlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUVudHJ5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgZmlsZSB0aGF0IG1pZ2h0IGJlIG91dHNpZGUgdGhlIGFwcCdzIGZvbGRlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNnZXRFeHRlcm5hbEZpbGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBmdWxsUGF0aCBBYnNvbHV0ZSBwYXRoIHRvIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRFeHRlcm5hbEZpbGUgPSBmdW5jdGlvbihmdWxsUGF0aCkge1xuICAgICAgICByZXR1cm4gJGNvcmRvdmFGaWxlLmNoZWNrRmlsZShmdWxsUGF0aCwgJycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZmlsZSB0aGF0IG1pZ2h0IGJlIG91dHNpZGUgdGhlIGFwcCdzIGZvbGRlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNyZW1vdmVFeHRlcm5hbEZpbGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBmdWxsUGF0aCBBYnNvbHV0ZSBwYXRoIHRvIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZmlsZSBpcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHNlbGYucmVtb3ZlRXh0ZXJuYWxGaWxlID0gZnVuY3Rpb24oZnVsbFBhdGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlRmlsZShmdWxsUGF0aCwgJycpIGRvZXMgbm90IHdvcmssIHdlIG5lZWQgdG8gcGFzcyB0d28gdmFsaWQgcGFyYW1ldGVycy5cbiAgICAgICAgdmFyIGRpcmVjdG9yeSA9IGZ1bGxQYXRoLnN1YnN0cmluZygwLCBmdWxsUGF0aC5sYXN0SW5kZXhPZignLycpICk7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGZ1bGxQYXRoLnN1YnN0cihmdWxsUGF0aC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgIHJldHVybiAkY29yZG92YUZpbGUucmVtb3ZlRmlsZShkaXJlY3RvcnksIGZpbGVuYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBiYXNlIHBhdGggd2hlcmUgdGhlIGFwcGxpY2F0aW9uIGZpbGVzIGFyZSBzdG9yZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjZ2V0QmFzZVBhdGhcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGJhc2UgcGF0aCBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRCYXNlUGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChiYXNlUGF0aC5zbGljZSgtMSkgPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VQYXRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVBhdGggKyAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhc2UgcGF0aCB3aGVyZSB0aGUgYXBwbGljYXRpb24gZmlsZXMgYXJlIHN0b3JlZCBpbiB0aGUgZm9ybWF0IHRvIGJlIHVzZWQgZm9yIGRvd25sb2Fkcy5cbiAgICAgKiBpT1M6IEludGVybmFsIFVSTCAoY2R2ZmlsZTovLykuXG4gICAgICogT3RoZXJzOiBiYXNlUGF0aCAoZmlsZTovLylcbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNnZXRCYXNlUGF0aFRvRG93bmxvYWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGJhc2UgcGF0aCBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRCYXNlUGF0aFRvRG93bmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW5pdCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgICAgICAgICAgIC8vIEluIGlPUyB3ZSB3YW50IHRoZSBpbnRlcm5hbCBVUkwgKGNkdmZpbGU6Ly9sb2NhbGhvc3QvcGVyc2lzdGVudC8uLi4pLlxuICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUuY2hlY2tEaXIoYmFzZVBhdGgsICcnKS50aGVuKGZ1bmN0aW9uKGRpckVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJFbnRyeS50b0ludGVybmFsVVJMKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBvdGhlciBwbGF0Zm9ybXMgd2UgdXNlIHRoZSBiYXNlUGF0aCBhcyBpdCBpcyAoZmlsZTovLy4uLikuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRlbXBvcmFyeSBkaXJlY3RvcnkgcGF0aC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNnZXRUbXBGb2xkZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRtcCBkaXJlY3RvcnkgcGF0aC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFRtcEZvbGRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbW1Gc1RtcEZvbGRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZSBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjbW92ZUVudHJ5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpbmFsUGF0aCBQYXRoIHRvIHRoZSBmaWxlIHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1BhdGggICAgICBOZXcgcGF0aCBvZiB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZW50cnkgaXMgbW92ZWQuXG4gICAgICovXG4gICAgc2VsZi5tb3ZlRmlsZSA9IGZ1bmN0aW9uKG9yaWdpbmFsUGF0aCwgbmV3UGF0aCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChpc0hUTUxBUEkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBDb3Jkb3ZhIEFQSSB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgbG9uZ2VzdCBtYXRjaGluZyBwYXRoIHRvIG1ha2UgaXQgd29yay5cbiAgICAgICAgICAgICAgICAvLyAkY29yZG92YUZpbGUubW92ZUZpbGUoJ2EvJywgJ2IvYy5leHQnLCAnYS8nLCAnYi9kLmV4dCcpIGRvZXNuJ3Qgd29yay5cbiAgICAgICAgICAgICAgICAvLyBjb3Jkb3ZhRmlsZS5tb3ZlRmlsZSgnYS9iLycsICdjLmV4dCcsICdhL2IvJywgJ2QuZXh0Jykgd29ya3MuXG4gICAgICAgICAgICAgICAgdmFyIGNvbW1vblBhdGggPSBiYXNlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGlyc0EgPSBvcmlnaW5hbFBhdGguc3BsaXQoJy8nKSxcbiAgICAgICAgICAgICAgICAgICAgZGlyc0IgPSBuZXdQYXRoLnNwbGl0KCcvJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXIgPSBkaXJzQVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcnNCW2ldID09PSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgY29tbW9uIGZvbGRlciwgYWRkIGl0IHRvIGNvbW1vbiBwYXRoIGFuZCByZW1vdmUgaXQgZnJvbSBlYWNoIHNwZWNpZmljIHBhdGguXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSBkaXIgKyAnLyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tb25QYXRoID0gc2VsZi5jb25jYXRlbmF0ZVBhdGhzKGNvbW1vblBhdGgsIGRpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFBhdGggPSBvcmlnaW5hbFBhdGgucmVwbGFjZShkaXIsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhdGggPSBuZXdQYXRoLnJlcGxhY2UoZGlyLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb2xkZXIgZG9lc24ndCBtYXRjaCwgc3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUubW92ZUZpbGUoY29tbW9uUGF0aCwgb3JpZ2luYWxQYXRoLCBjb21tb25QYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5tb3ZlRmlsZShiYXNlUGF0aCwgb3JpZ2luYWxQYXRoLCBiYXNlUGF0aCwgbmV3UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNjb3B5RmlsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tICAgUGF0aCB0byB0aGUgZmlsZSB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0byAgICAgTmV3IHBhdGggb2YgdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGVudHJ5IGlzIGNvcGllZC5cbiAgICAgKi9cbiAgICBzZWxmLmNvcHlGaWxlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW5pdCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0byBjb250YWlucyBhIGRpcmVjdG9yeS5cbiAgICAgICAgICAgIHZhciB0b0ZpbGUgPSBzZWxmLmdldEZpbGVBbmREaXJlY3RvcnlGcm9tUGF0aCh0byk7XG4gICAgICAgICAgICBpZiAodG9GaWxlLmRpcmVjdG9yeSA9PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUZpbGUuY29weUZpbGUoYmFzZVBhdGgsIGZyb20sIGJhc2VQYXRoLCB0byk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBkaXJlY3RvcnkgaXMgY3JlYXRlZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jcmVhdGVEaXIodG9GaWxlLmRpcmVjdG9yeSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZS5jb3B5RmlsZShiYXNlUGF0aCwgZnJvbSwgYmFzZVBhdGgsIHRvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIGZpbGUgbmFtZSBhbmQgZGlyZWN0b3J5IGZyb20gYSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2dldEZpbGVBbmREaXJlY3RvcnlGcm9tUGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoICAgUGF0aCB0byBiZSBleHRyYWN0ZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBQbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZSBuYW1lIGFuZCBkaXJlY3RvcnkuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogZmlsZS5wZGYgICAgICAgICAtPiBkaXJlY3Rvcnk6ICcnLCBuYW1lOiAnZmlsZS5wZGYnXG4gICAgICogL2ZpbGUucGRmICAgICAgICAtPiBkaXJlY3Rvcnk6ICcnLCBuYW1lOiAnZmlsZS5wZGYnXG4gICAgICogcGF0aC9maWxlLnBkZiAgICAtPiBkaXJlY3Rvcnk6ICdwYXRoJywgbmFtZTogJ2ZpbGUucGRmJ1xuICAgICAqIHBhdGgvICAgICAgICAgICAgLT4gZGlyZWN0b3J5OiAncGF0aCcsIG5hbWU6ICcnXG4gICAgICogcGF0aCAgICAgICAgICAgICAtPiBkaXJlY3Rvcnk6ICcnLCBuYW1lOiAncGF0aCdcbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVBbmREaXJlY3RvcnlGcm9tUGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgdmFyIGZpbGUgPSB7XG4gICAgICAgICAgICBkaXJlY3Rvcnk6ICcnLFxuICAgICAgICAgICAgbmFtZTogJydcbiAgICAgICAgfTtcblxuICAgICAgICBmaWxlLmRpcmVjdG9yeSA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGFzdEluZGV4T2YoJy8nKSApO1xuICAgICAgICBmaWxlLm5hbWUgPSBwYXRoLnN1YnN0cihwYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcblxuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29uY2F0ZW5hdGUgdHdvIHBhdGhzLCBhZGRpbmcgYSBzbGFzaCBiZXR3ZWVuIHRoZW0gaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2NvbmNhdGVuYXRlUGF0aHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGVmdFBhdGggIExlZnQgcGF0aC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmlnaHRQYXRoIFJpZ2h0IHBhdGguXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICBDb25jYXRlbmF0ZWQgcGF0aC5cbiAgICAgKi9cbiAgICBzZWxmLmNvbmNhdGVuYXRlUGF0aHMgPSBmdW5jdGlvbihsZWZ0UGF0aCwgcmlnaHRQYXRoKSB7XG4gICAgICAgIHZhciBsYXN0Q2hhckxlZnQgPSBsZWZ0UGF0aC5zbGljZSgtMSksXG4gICAgICAgICAgICBmaXJzdENoYXJSaWdodCA9IHJpZ2h0UGF0aC5jaGFyQXQoMCk7XG5cbiAgICAgICAgaWYgKGxhc3RDaGFyTGVmdCA9PT0gJy8nICYmIGZpcnN0Q2hhclJpZ2h0ID09PSAnLycpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0UGF0aCArIHJpZ2h0UGF0aC5zdWJzdHIoMSk7XG4gICAgICAgIH0gZWxzZSBpZihsYXN0Q2hhckxlZnQgIT09ICcvJyAmJiBmaXJzdENoYXJSaWdodCAhPT0gJy8nKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdFBhdGggKyAnLycgKyByaWdodFBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdFBhdGggKyByaWdodFBhdGg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbnRlcm5hbCBVUkwgb2YgYSBmaWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUZTI2dldEludGVybmFsVVJMXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBmaWxlRW50cnkgRmlsZSBFbnRyeS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBJbnRlcm5hbCBVUkwuXG4gICAgICovXG4gICAgc2VsZi5nZXRJbnRlcm5hbFVSTCA9IGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICBpZiAoaXNIVE1MQVBJKSB7XG4gICAgICAgICAgICAvLyBIVE1MIEFQSSBkb2Vzbid0IGltcGxlbWVudCB0b0ludGVybmFsVVJMLlxuICAgICAgICAgICAgcmV0dXJuIGZpbGVFbnRyeS50b1VSTCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlRW50cnkudG9JbnRlcm5hbFVSTCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBmaWxlIGljb24gVVJMIGJhc2VkIG9uIGl0cyBmaWxlIG5hbWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVXRpbCNnZXRGaWxlSWNvblxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcGF0aCB0byBhIGZpbGUgaWNvbi5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVJY29uID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIGV4dCA9IHNlbGYuZ2V0RmlsZUV4dGVuc2lvbihmaWxlbmFtZSksXG4gICAgICAgICAgICBpY29uO1xuXG4gICAgICAgIGlmIChleHQgJiYgbWltZVR5cGVzW2V4dF0gJiYgbWltZVR5cGVzW2V4dF0uaWNvbikge1xuICAgICAgICAgICAgaWNvbiA9IG1pbWVUeXBlc1tleHRdLmljb24gKyAnLTY0LnBuZyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpY29uID0gJ3Vua25vd24tNjQucG5nJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnaW1nL2ZpbGVzLycgKyBpY29uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZvbGRlciBpY29uIFVSTC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1VdGlsI2dldEZvbGRlckljb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwYXRoIHRvIGEgZm9sZGVyIGljb24uXG4gICAgICovXG4gICAgc2VsZi5nZXRGb2xkZXJJY29uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnaW1nL2ZpbGVzL2ZvbGRlci02NC5wbmcnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWxlIGV4dGVuc2lvbiBvZiBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBmaWxlIGRvZXMgbm90IGhhdmUgYW4gZXh0ZW5zaW9uLCBpdCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1VdGlsI2dldEZpbGVFeHRlbnNpb25cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVuYW1lIFRoZSBmaWxlIG5hbWUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICBUaGUgbG93ZXJjYXNlZCBleHRlbnNpb24sIG9yIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVFeHRlbnNpb24gPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICAgICAgICB2YXIgZG90ID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCIuXCIpLFxuICAgICAgICAgICAgZXh0O1xuXG4gICAgICAgIGlmIChkb3QgPiAtMSkge1xuICAgICAgICAgICAgZXh0ID0gZmlsZW5hbWUuc3Vic3RyKGRvdCArIDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1pbWV0eXBlIG9mIGFuIGV4dGVuc2lvbi4gUmV0dXJucyB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVV0aWwjYWxsUHJvbWlzZXNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV4dGVuc2lvbiBFeHRlbnNpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgTWltZXR5cGUuXG4gICAgICovXG4gICAgc2VsZi5nZXRNaW1lVHlwZSA9IGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgICAgICBpZiAobWltZVR5cGVzW2V4dGVuc2lvbl0gJiYgbWltZVR5cGVzW2V4dGVuc2lvbl0udHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbWVUeXBlc1tleHRlbnNpb25dLnR5cGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBleHRlbnNpb24gZnJvbSBhIHBhdGggKGlmIGFueSkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjcmVtb3ZlRXh0ZW5zaW9uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoIFBhdGguXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgIFBhdGggd2l0aG91dCBleHRlbnNpb24uXG4gICAgICovXG4gICAgc2VsZi5yZW1vdmVFeHRlbnNpb24gPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLnN1YnN0cigwLCBpbmRleCk7IC8vIFJlbW92ZSBleHRlbnNpb24uXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGJhc2VQYXRoIHRvIGEgcGF0aCBpZiBpdCBkb2Vzbid0IGhhdmUgaXQgYWxyZWFkeS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1GUyNhZGRCYXNlUGF0aElmTmVlZGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggUGF0aCB0byB0cmVhdC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBQYXRoIHdpdGggYmFzZVBhdGggYWRkZWQuXG4gICAgICovXG4gICAgc2VsZi5hZGRCYXNlUGF0aElmTmVlZGVkID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5pbmRleE9mKGJhc2VQYXRoKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbmNhdGVuYXRlUGF0aHMoYmFzZVBhdGgsIHBhdGgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVuemlwcyBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tRlMjdW56aXBGaWxlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoICAgICAgICAgUGF0aCB0byB0aGUgWklQIGZpbGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbZGVzdEZvbGRlcl0gUGF0aCB0byB0aGUgZGVzdGluYXRpb24gZm9sZGVyLiBJZiBub3QgZGVmaW5lZCwgYSBuZXcgZm9sZGVyIHdpbGwgYmUgY3JlYXRlZCB3aXRoIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgbG9jYXRpb24gYW5kIG5hbWUgYXMgdGhlIFpJUCBmaWxlICh3aXRob3V0IGV4dGVuc2lvbikuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBmaWxlIGlzIHVuemlwcGVkLlxuICAgICAqL1xuICAgIHNlbGYudW56aXBGaWxlID0gZnVuY3Rpb24ocGF0aCwgZGVzdEZvbGRlcikge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSBhbnNvbHV0ZSBwYXRocyAoaW5jbHVkaW5nIGJhc2VQYXRoKS5cbiAgICAgICAgcGF0aCA9IHNlbGYuYWRkQmFzZVBhdGhJZk5lZWRlZChwYXRoKTtcbiAgICAgICAgIC8vIElmIGRlc3RGb2xkZXIgaXMgbm90IHNldCwgdXNlIHNhbWUgbG9jYXRpb24gYXMgWklQIGZpbGUuXG4gICAgICAgIGRlc3RGb2xkZXIgPSBzZWxmLmFkZEJhc2VQYXRoSWZOZWVkZWQoZGVzdEZvbGRlciB8fCBzZWxmLnJlbW92ZUV4dGVuc2lvbihwYXRoKSk7XG4gICAgICAgIHJldHVybiAkY29yZG92YVppcC51bnppcChwYXRoLCBkZXN0Rm9sZGVyKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgZ3JvdXBzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5ncm91cHNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Hcm91cHNcbiAqL1xuLmZhY3RvcnkoJyRtbUdyb3VwcycsIGZ1bmN0aW9uKCRsb2csICRxLCAkbW1TaXRlLCAkbW1TaXRlc01hbmFnZXIpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Hcm91cHMnKTtcblxuICAgIC8vIEdyb3VwIG1vZGUgY29uc3RhbnRzLlxuICAgIHNlbGYuTk9HUk9VUFMgICAgICAgPSAwO1xuICAgIHNlbGYuU0VQQVJBVEVHUk9VUFMgPSAxO1xuICAgIHNlbGYuVklTSUJMRUdST1VQUyAgPSAyO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBncm91cHMgYWxsb3dlZCBpbiBhbiBhY3Rpdml0eS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5ncm91cHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tR3JvdXBzI2dldEFjdGl2aXR5QWxsb3dlZEdyb3Vwc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbWlkICAgICBDb3Vyc2UgbW9kdWxlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcmlkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBncm91cHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEFjdGl2aXR5QWxsb3dlZEdyb3VwcyA9IGZ1bmN0aW9uKGNtaWQsIHVzZXJpZCkge1xuICAgICAgICB1c2VyaWQgPSB1c2VyaWQgfHzCoCRtbVNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjbWlkOiBjbWlkLFxuICAgICAgICAgICAgICAgIHVzZXJpZDogdXNlcmlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0QWN0aXZpdHlBbGxvd2VkR3JvdXBzQ2FjaGVLZXkoY21pZCwgdXNlcmlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdjb3JlX2dyb3VwX2dldF9hY3Rpdml0eV9hbGxvd2VkX2dyb3VwcycsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmdyb3VwcztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGdyb3VwIG1vZGUgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY21pZCBDb3Vyc2UgbW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBY3Rpdml0eUFsbG93ZWRHcm91cHNDYWNoZUtleShjbWlkLCB1c2VyaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbUdyb3VwczphbGxvd2VkZ3JvdXBzOicgKyBjbWlkICsgJzonICsgdXNlcmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZ3JvdXAgbW9kZSBvZiBhbiBhY3Rpdml0eS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5ncm91cHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tR3JvdXBzI2dldEFjdGl2aXR5R3JvdXBNb2RlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNtaWQgQ291cnNlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGdyb3VwIG1vZGUgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QWN0aXZpdHlHcm91cE1vZGUgPSBmdW5jdGlvbihjbWlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY21pZDogY21pZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldEFjdGl2aXR5R3JvdXBNb2RlQ2FjaGVLZXkoY21pZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnY29yZV9ncm91cF9nZXRfYWN0aXZpdHlfZ3JvdXBtb2RlJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8IHR5cGVvZiByZXNwb25zZS5ncm91cG1vZGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZ3JvdXBtb2RlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZ3JvdXAgbW9kZSBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbWlkIENvdXJzZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFjdGl2aXR5R3JvdXBNb2RlQ2FjaGVLZXkoY21pZCkge1xuICAgICAgICByZXR1cm4gJ21tR3JvdXBzOmdyb3VwbW9kZTonICsgY21pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBncm91cHMgaW4gY291cnNlcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5ncm91cHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tR3JvdXBzI2dldFVzZXJHcm91cHNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfE51bWJlcltdfSBjb3Vyc2VzIExpc3Qgb2YgY291cnNlcyBvciBjb3Vyc2UgaWRzIHRvIGdldCB0aGUgZ3JvdXBzIGZyb20uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVmcmVzaF0gICAgICAgICBUcnVlIHdoZW4gd2Ugc2hvdWxkIG5vdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZWlkXSAgICAgICAgICAgU2l0ZSB0byBnZXQgdGhlIGdyb3VwcyBmcm9tLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJpZF0gICAgICAgICAgIElEIG9mIHRoZSB1c2VyLiBJZiBub3QgZGVmaW5lZCwgdXNlIHRoZSB1c2VyaWQgcmVsYXRlZCB0byBzaXRlaWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGdyb3VwcyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0VXNlckdyb3VwcyA9IGZ1bmN0aW9uKGNvdXJzZXMsIHJlZnJlc2gsIHNpdGVpZCwgdXNlcmlkKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgZ3JvdXBzID0gW10sXG4gICAgICAgICAgICBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvdXJzZXMsIGZ1bmN0aW9uKGNvdXJzZSkge1xuICAgICAgICAgICAgdmFyIGNvdXJzZWlkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb3Vyc2UgPT0gJ29iamVjdCcpIHsgLy8gUGFyYW0gaXMgYXJyYXkgb2YgY291cnNlcy5cbiAgICAgICAgICAgICAgICBjb3Vyc2VpZCA9IGNvdXJzZS5pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIFBhcmFtIGlzIGFycmF5IG9mIGNvdXJzZWlkcy5cbiAgICAgICAgICAgICAgICBjb3Vyc2VpZCA9IGNvdXJzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gc2VsZi5nZXRVc2VyR3JvdXBzSW5Db3Vyc2UoY291cnNlaWQsIHJlZnJlc2gsIHNpdGVpZCwgdXNlcmlkKS50aGVuKGZ1bmN0aW9uKGNvdXJzZWdyb3Vwcykge1xuICAgICAgICAgICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5jb25jYXQoY291cnNlZ3JvdXBzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHEuYWxsKHByb21pc2VzKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gVXNlIGZpbmFsbHkgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGJsb2NrIHRoZSBsb2FkIG9mIGV2ZW50cyBpZiBhIHJlcXVlc3QgZmFpbHMuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGdyb3Vwcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBncm91cHMgaW4gYSBjb3Vyc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuZ3JvdXBzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUdyb3VwcyNnZXRVc2VyR3JvdXBzSW5Db3Vyc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgICBJRCBvZiB0aGUgY291cnNlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlZnJlc2hdIFRydWUgd2hlbiB3ZSBzaG91bGQgbm90IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlaWRdICAgU2l0ZSB0byBnZXQgdGhlIGdyb3VwcyBmcm9tLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJpZF0gICBJRCBvZiB0aGUgdXNlci4gSWYgbm90IGRlZmluZWQsIHVzZSBJRCByZWxhdGVkIHRvIHNpdGVpZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBncm91cHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFVzZXJHcm91cHNJbkNvdXJzZSA9IGZ1bmN0aW9uKGNvdXJzZWlkLCByZWZyZXNoLCBzaXRlaWQsIHVzZXJpZCkge1xuICAgICAgICBzaXRlaWQgPSBzaXRlaWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlaWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdmFyIHByZXNldHMgPSB7fSxcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICB1c2VyaWQ6IHVzZXJpZCB8fCBzaXRlLmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlaWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICBwcmVzZXRzLmdldEZyb21DYWNoZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpdGUucmVhZCgnY29yZV9ncm91cF9nZXRfY291cnNlX3VzZXJfZ3JvdXBzJywgZGF0YSwgcHJlc2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5ncm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmdyb3VwcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBhY3Rpdml0eSBhbGxvd2VkIGdyb3Vwcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5ncm91cHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tR3JvdXBzI2ludmFsaWRhdGVBY3Rpdml0eUFsbG93ZWRHcm91cHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY21pZCAgICAgQ291cnNlIG1vZHVsZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJpZF0gVXNlciBJRC4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVBY3Rpdml0eUFsbG93ZWRHcm91cHMgPSBmdW5jdGlvbihjbWlkLCB1c2VyaWQpIHtcbiAgICAgICAgdXNlcmlkID0gdXNlcmlkIHx8wqAkbW1TaXRlLmdldFVzZXJJZCgpO1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRBY3Rpdml0eUFsbG93ZWRHcm91cHNDYWNoZUtleShjbWlkLCB1c2VyaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgYWN0aXZpdHkgZ3JvdXAgbW9kZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5ncm91cHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tR3JvdXBzI2ludmFsaWRhdGVBY3Rpdml0eUdyb3VwTW9kZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbWlkIENvdXJzZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUFjdGl2aXR5R3JvdXBNb2RlID0gZnVuY3Rpb24oY21pZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRBY3Rpdml0eUdyb3VwTW9kZUNhY2hlS2V5KGNtaWQpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgcHJpb3JpdHkgZm9yIGluaXQgcHJvY2Vzc2VzLlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgY29uc3RhbnRcbiAqIEBuYW1lIG1tSW5pdERlbGVnYXRlRGVmYXVsdFByaW9yaXR5XG4gKi9cbi5jb25zdGFudCgnbW1Jbml0RGVsZWdhdGVEZWZhdWx0UHJpb3JpdHknLCAxMDApXG5cbi8qKlxuICogVGhlIG1heGltdW0gcHJpb3JpdHkgdGhhdCBhbiBhZGRvbiBjYW4gdXNlIGZvciBpbml0IHByb2Nlc3MsIGFueXRoaW5nIG92ZXIgdGhhdCBpcyByZXNlcnZlZCBmb3IgY29yZSB1c2UuXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBjb25zdGFudFxuICogQG5hbWUgbW1Jbml0RGVsZWdhdGVNYXhBZGRvblByaW9yaXR5XG4gKi9cbi5jb25zdGFudCgnbW1Jbml0RGVsZWdhdGVNYXhBZGRvblByaW9yaXR5JywgNTk5KVxuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBpbml0aWFsaXNhdGlvbiBtZWNoYW5pc21zLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIHByb3ZpZGVyXG4gKiBAbmFtZSAkbW1Jbml0RGVsZWdhdGVcbiAqL1xuLnByb3ZpZGVyKCckbW1Jbml0RGVsZWdhdGUnLCBmdW5jdGlvbihtbUluaXREZWxlZ2F0ZURlZmF1bHRQcmlvcml0eSkge1xuICAgIHZhciBpbml0UHJvY2Vzc2VzID0ge30sXG4gICAgICAgIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpbml0aWFsaXNhdGlvbiBwcm9jZXNzLlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogSW5pdCBwcm9jZXNzZXMgY2FuIGJlIHVzZWQgdG8gYWRkIGluaXRpYWxpc2F0aW9uIGxvZ2ljIHRvIHRoZSBhcHAuIEFueXRoaW5nIHRoYXQgc2hvdWxkXG4gICAgICogYmxvY2sgdGhlIHVzZXIgaW50ZXJmYWNlIHdoaWxlIHNvbWUgcHJvY2Vzc2VzIGFyZSBkb25lIHNob3VsZCBiZSBhbiBpbml0IHByb2Nlc3MuIFdoZW4gZGVmaW5pbmdcbiAgICAgKiBhbiBpbml0IHByb2Nlc3MgbWFrZSBzdXJlIHlvdSBkbyBub3Qgc2V0IGEgcHJpb3JpdHkgaGlnaGVyIHRoYW4gbW1Jbml0RGVsZWdhdGVNYXhBZGRvblByaW9yaXR5XG4gICAgICogaW4geW91ciBhZGRvbnMuIFRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoYXQgeW91ciBwcm9jZXNzIGRvZXMgbm90IGhhcHBlbiBiZWZvcmUgc29tZSBlc3NlbnRpYWxcbiAgICAgKiBvdGhlciBjb3JlIHByb2Nlc3NlcyBzdWNoIGFzIHRoZSB1cGdyYWRlLCBhbmQgcmVzdG9yaW5nIHRoZSB1c2VyIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBBbiBpbml0IHByb2Nlc3Mgc2hvdWxkIG5ldmVyIGNoYW5nZSBzdGF0ZSBvciBwcm9tcHQgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Jbml0RGVsZWdhdGVQcm92aWRlciNyZWdpc3RlclByb2Nlc3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gY2FsbGFibGUgVGhlIGNhbGxhYmxlIG9mIHRoZSBwcm9jZXNzLiBTZWUge0BsaW5rICRtbVV0aWwucmVzb2x2ZU9iamVjdH0uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSByZXNvbHZlZCBmdW5jdGlvbiB3aWxsIGdldCAkaW5qZWN0b3IgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eT0xMDBdIFRoZSBwcmlvcml0eSBvZiB0aGUgcHJvY2VzcywgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgaXMgZXhlY3V0ZWQgZmlyc3QuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYmxvY2tpbmc9ZmFsc2VdIFNldCB0aGlzIHRvIHRydWUgd2hlbiB0aGlzIHByb2Nlc3Mgc2hvdWxkIGJlIHJlc29sdmVkIGJlZm9yZSBhbnkgZm9sbG93aW5nIG9uZS5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNlbGYucmVnaXN0ZXJQcm9jZXNzID0gZnVuY3Rpb24obmFtZSwgY2FsbGFibGUsIHByaW9yaXR5LCBibG9ja2luZykge1xuICAgICAgICBwcmlvcml0eSA9IHR5cGVvZiBwcmlvcml0eSA9PT0gJ3VuZGVmaW5lZCcgPyBtbUluaXREZWxlZ2F0ZURlZmF1bHRQcmlvcml0eSA6IHByaW9yaXR5O1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdFByb2Nlc3Nlc1tuYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCckbW1Jbml0RGVsZWdhdGVQcm92aWRlcjogUHJvY2VzcyBcXCcnICsgbmFtZSArICdcXCcgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJyRtbUluaXREZWxlZ2F0ZVByb3ZpZGVyOiBSZWdpc3RlcmVkIHByb2Nlc3MgXFwnJyArIG5hbWUgKyAnXFwnLicpO1xuICAgICAgICBpbml0UHJvY2Vzc2VzW25hbWVdID0ge1xuICAgICAgICAgICAgYmxvY2tpbmc6IGJsb2NraW5nLFxuICAgICAgICAgICAgY2FsbGFibGU6IGNhbGxhYmxlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBzZWxmLiRnZXQgPSBmdW5jdGlvbigkcSwgJGxvZywgJGluamVjdG9yLCAkbW1VdGlsKSB7XG5cbiAgICAgICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUluaXREZWxlZ2F0ZScpO1xuXG4gICAgICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgICAgICByZWFkaW5lc3M7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgdGhlIHByb2Nlc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvZiB0aGUgcHJvY2Vzcy5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBwcmVwYXJlUHJvY2VzcyhkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZuO1xuXG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRXhlY3V0aW5nIGluaXQgcHJvY2VzcyBcXCcnICsgZGF0YS5uYW1lICsgJ1xcJycpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSAkbW1VdGlsLnJlc29sdmVPYmplY3QoZGF0YS5jYWxsYWJsZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdDb3VsZCBub3QgcmVzb2x2ZSBvYmplY3Qgb2YgaW5pdCBwcm9jZXNzIFxcJycgKyBkYXRhLm5hbWUgKyAnXFwnLiAnICsgZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gZm4oJGluamVjdG9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIHdoaWxlIGNhbGxpbmcgdGhlIGluaXQgcHJvY2VzcyBcXCcnICsgZGF0YS5uYW1lICsgJ1xcJy4gJyArIGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGVzIHRoZSByZWdpc3RlcmVkIGluaXQgcHJvY2Vzc2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXNlcnZlZCBmb3IgY29yZSB1c2UsIGRvIG5vdCBjYWxsIGRpcmVjdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIHNlcnZpY2VcbiAgICAgICAgICogQG5hbWUgJG1tSW5pdERlbGVnYXRlI2V4ZWN1dGVJbml0UHJvY2Vzc2VzXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZXhlY3V0ZUluaXRQcm9jZXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvcmRlcmVkID0gW10sXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gJHEud2hlbigpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRpbmVzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZWFkaW5lc3MgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZS1vcmRlcmluZyBieSBwcmlvcml0eS5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChpbml0UHJvY2Vzc2VzLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgb3JkZXJlZC5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvcmRlcmVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIGFsbCB0aGUgcHJvY2Vzc2VzLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG9yZGVyZWQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcHJvY2VzcyB0byB0aGUgZGVwZW5kZW5jeSBzdGFjay5cbiAgICAgICAgICAgICAgICBwcm9taXNlID0gZGVwZW5kZW5jeS5maW5hbGx5KHByZXBhcmVQcm9jZXNzKGRhdGEpKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5ldyBwcm9jZXNzIGlzIGJsb2NraW5nLCB3ZSBzZXQgaXQgYXMgdGhlIGRlcGVuZGVuY3kuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuYmxvY2tpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IHByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICRxLmFsbChwcm9taXNlcykuZmluYWxseShyZWFkaW5lc3MucmVzb2x2ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGlmaWVzIHdoZW4gdGhlIGFwcCBpcyByZWFkeS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIGFwcCBpcyBpbml0aWFsaXNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogUmVzZXJ2ZWQgZm9yIGNvcmUgdXNlLCBkbyBub3QgY2FsbCBkaXJlY3RseSwgdXNlIHtAbGluayAkbW1BcHAucmVhZHl9IGluc3RlYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2Mgc2VydmljZVxuICAgICAgICAgKiBAbmFtZSAkbW1Jbml0RGVsZWdhdGUjcmVhZHlcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhcHAgaXMgaW5pdGlhbGlzZWQuIE5ldmVyIHJlamVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5yZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkaW5lc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCByYWNlIGNvbmRpdGlvbnMgaWYgdGhpcyBpcyBjYWxsZWQgYmVmb3JlIGV4ZWN1dGVJbml0UHJvY2Vzc2VzLlxuICAgICAgICAgICAgICAgIHJlYWRpbmVzcyA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZWFkaW5lc3MucHJvbWlzZTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8qKlxuICogaW9uUmFkaW9GaXggLSBmaXhlcyBhIGJ1ZyBpbiBpT1MgOSBVSVdlYlZpZXcgdGhhdCBicmVha3MgdGhlIHRpbGRlIHNlbGVjdG9yIGluIENTUy4gVG9cbiAqIHVzZSB0aGlzIGZpeCwgaW5jbHVkZSBpdCBhZnRlciB5b3VyIElvbmljIGJ1bmRsZSBKUy5cbiAqXG4gKiBOb3RlOiBkdWUgdG8gQW5ndWxhciBkaXJlY3RpdmUgb3ZlcnJpZGUgbGltaXRhdGlvbnMsIHlvdSdsbCBuZWVkIHRvIGNoYW5nZSBhbnkgcmVmZXJlbmNlXG4gKiB0byA8aW9uLXJhZGlvPiB0byA8aW9uLXJhZGlvLWZpeD4gdG8gYXBwbHkgdGhpcyBwYXRjaGVkIHJhZGlvIGJ1dHRvbi5cbiAqXG4gKiBBbHNvLCBtYWtlIHN1cmUgdG8gYWRkIHRoZSBuZXcgQ1NTIGZyb20gdGhlIHNlY29uZCBwYXJ0IG9mIHRoaXMgZ2lzdC5cbiAqL1xuYW5ndWxhci5tb2R1bGUoJ2lvbmljJykuZGlyZWN0aXZlKCdpb25SYWRpb0ZpeCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICByZXF1aXJlOiAnP25nTW9kZWwnLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgdGVtcGxhdGU6XG4gICAgICAnPGxhYmVsIGNsYXNzPVwiaXRlbSBpdGVtLXJhZGlvXCI+JyArXG4gICAgICAgICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cInJhZGlvLWdyb3VwXCI+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwicmFkaW8tY29udGVudFwiPicgK1xuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaXRlbS1jb250ZW50IGRpc2FibGUtcG9pbnRlci1ldmVudHNcIiBuZy10cmFuc2NsdWRlPjwvZGl2PicgK1xuICAgICAgICAgICc8aSBjbGFzcz1cInJhZGlvLWljb24gZGlzYWJsZS1wb2ludGVyLWV2ZW50cyBpY29uIGlvbi1jaGVja21hcmtcIj48L2k+JyArXG4gICAgICAgICc8L2Rpdj4nICtcbiAgICAgICc8L2xhYmVsPicsXG5cbiAgICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICBpZiAoYXR0ci5pY29uKSB7XG4gICAgICAgIHZhciBpY29uRWxtID0gZWxlbWVudC5maW5kKCdpJyk7XG4gICAgICAgIGljb25FbG0ucmVtb3ZlQ2xhc3MoJ2lvbi1jaGVja21hcmsnKS5hZGRDbGFzcyhhdHRyLmljb24pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXQgPSBlbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG4gICAgICBhbmd1bGFyLmZvckVhY2goe1xuICAgICAgICAgICduYW1lJzogYXR0ci5uYW1lLFxuICAgICAgICAgICd2YWx1ZSc6IGF0dHIudmFsdWUsXG4gICAgICAgICAgJ2Rpc2FibGVkJzogYXR0ci5kaXNhYmxlZCxcbiAgICAgICAgICAnbmctdmFsdWUnOiBhdHRyLm5nVmFsdWUsXG4gICAgICAgICAgJ25nLW1vZGVsJzogYXR0ci5uZ01vZGVsLFxuICAgICAgICAgICduZy1kaXNhYmxlZCc6IGF0dHIubmdEaXNhYmxlZCxcbiAgICAgICAgICAnbmctY2hhbmdlJzogYXR0ci5uZ0NoYW5nZSxcbiAgICAgICAgICAnbmctcmVxdWlyZWQnOiBhdHRyLm5nUmVxdWlyZWQsXG4gICAgICAgICAgJ3JlcXVpcmVkJzogYXR0ci5yZXF1aXJlZFxuICAgICAgfSwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgaW5wdXQuYXR0cihuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xuICAgICAgICBzY29wZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzY29wZS5uZ1ZhbHVlIHx8IGF0dHIudmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn0pOyIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUxhbmdcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHNlcnZpY2UgYWxsb3dzIHRvIGFkZCBuZXcgbGFuZ3VhZ2VzIHN0cmluZ3MuXG4gKi9cbi5mYWN0b3J5KCckbW1MYW5nJywgZnVuY3Rpb24oJHRyYW5zbGF0ZSwgJHRyYW5zbGF0ZVBhcnRpYWxMb2FkZXIsICRtbUNvbmZpZywgJGNvcmRvdmFHbG9iYWxpemF0aW9uLCAkcSwgbW1Db3JlQ29uZmlnQ29uc3RhbnRzKSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBjdXJyZW50TGFuZ3VhZ2U7IC8vIFNhdmUgY3VycmVudCBsYW5ndWFnZSBpbiBhIHZhcmlhYmxlIHRvIHNwZWVkIHVwIHRoZSBnZXQgZnVuY3Rpb24uXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGZvbGRlciB0byBzZWFyY2ggbGFuZ3VhZ2UgZmlsZXMgaW50byBpdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1MYW5nI3JlZ2lzdGVyTGFuZ3VhZ2VGb2xkZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggUGF0aCBvZiB0aGUgZm9sZGVyIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGZpbGUgaXMgbG9hZGVkLlxuICAgICAqL1xuICAgIHNlbGYucmVnaXN0ZXJMYW5ndWFnZUZvbGRlciA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgJHRyYW5zbGF0ZVBhcnRpYWxMb2FkZXIuYWRkUGFydChwYXRoKTtcbiAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUucmVmcmVzaCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1MYW5nI2dldEN1cnJlbnRMYW5ndWFnZVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHNlbGYuZ2V0Q3VycmVudExhbmd1YWdlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50TGFuZ3VhZ2UgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKGN1cnJlbnRMYW5ndWFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgY3VycmVudCBsYW5ndWFnZSBmcm9tIGNvbmZpZyAodXNlciBtaWdodCBoYXZlIGNoYW5nZWQgaXQpLlxuICAgICAgICByZXR1cm4gJG1tQ29uZmlnLmdldCgnY3VycmVudF9sYW5ndWFnZScpLnRoZW4oZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgaGFzbid0IGRlZmluZWQgYSBsYW5ndWFnZS4gR2V0IGl0IGZyb20gY29yZG92YSBnbG9iYWxpemF0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVybiAkY29yZG92YUdsb2JhbGl6YXRpb24uZ2V0UHJlZmVycmVkTGFuZ3VhZ2UoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ3VhZ2UgPSByZXN1bHQudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMYW5ndWFnZSBjb2RlIGRlZmluZWQgYnkgbG9jYWxlIGhhcyBhIGRhc2gsIGxpa2UgZW4tVVMgb3IgZXMtRVMuIENoZWNrIGlmIGl0J3Mgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5sYW5ndWFnZXMgJiYgdHlwZW9mIG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5sYW5ndWFnZXNbbGFuZ3VhZ2VdID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29kZSBpcyBOT1Qgc3VwcG9ydGVkLiBGYWxsYmFjayB0byBsYW5ndWFnZSB3aXRob3V0IGRhc2guIEUuZy4gJ2VuLVVTJyB3b3VsZCBmYWxsYmFjayB0byAnZW4nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlID0gbGFuZ3VhZ2Uuc3Vic3RyKDAsIGxhbmd1YWdlLmluZGV4T2YoJy0nKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIGdldHRpbmcgbG9jYWxlLiBVc2UgZGVmYXVsdCBsYW5ndWFnZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5kZWZhdWx0X2xhbmcgfHwgJ2VuJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gRXJyb3IgZ2V0dGluZyBsb2NhbGUuIFVzZSBkZWZhdWx0IGxhbmd1YWdlLlxuICAgICAgICAgICAgICAgIHJldHVybiBtbUNvcmVDb25maWdDb25zdGFudHMuZGVmYXVsdF9sYW5nIHx8ICdlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMYW5ndWFnZSA9IGxhbmd1YWdlOyAvLyBTYXZlIGl0IGZvciBsYXRlci5cbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBjdXJyZW50IGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxhbmcjY2hhbmdlQ3VycmVudExhbmd1YWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxhbmd1YWdlIE5ldyBsYW5ndWFnZSB0byB1c2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY2hhbmdlIGlzIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIHNlbGYuY2hhbmdlQ3VycmVudExhbmd1YWdlID0gZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgICAgICAgdmFyIHAxID0gJHRyYW5zbGF0ZS51c2UobGFuZ3VhZ2UpLFxuICAgICAgICAgICAgcDIgPSAkbW1Db25maWcuc2V0KCdjdXJyZW50X2xhbmd1YWdlJywgbGFuZ3VhZ2UpO1xuICAgICAgICBtb21lbnQubG9jYWxlKGxhbmd1YWdlKTtcbiAgICAgICAgY3VycmVudExhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgICAgIHJldHVybiAkcS5hbGwoW3AxLCBwMl0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGFuIGVycm9yIG1lc3NhZ2UgYW5kIHJldHVybnMgYSByZWplY3RlZCBwcm9taXNlIHdpdGggdGhlIHRyYW5zbGF0ZWQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1MYW5nI3RyYW5zbGF0ZUFuZFJlamVjdFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXJyb3JrZXkgS2V5IG9mIHRoZSBtZXNzYWdlIHRvIHNob3cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBSZWplY3RlZCBwcm9taXNlLlxuICAgICAqL1xuICAgIHNlbGYudHJhbnNsYXRlQW5kUmVqZWN0ID0gZnVuY3Rpb24oZXJyb3JrZXkpIHtcbiAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUoZXJyb3JrZXkpLnRoZW4oZnVuY3Rpb24oZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnJvcmtleSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGFuIGVycm9yIG1lc3NhZ2UgYW5kIHJlamVjdHMgYSBkZWZlcnJlZCB3aXRoIHRoZSB0cmFuc2xhdGVkIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTGFuZyN0cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZGVmZXJyZWQgRGVmZXJyZWQgb2JqZWN0IHRvIHJlamVjdC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVycm9ya2V5IEtleSBvZiB0aGUgbWVzc2FnZSB0byBzaG93LlxuICAgICAqL1xuICAgIHNlbGYudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQgPSBmdW5jdGlvbihkZWZlcnJlZCwgZXJyb3JrZXkpIHtcbiAgICAgICAgJHRyYW5zbGF0ZShlcnJvcmtleSkudGhlbihmdW5jdGlvbihlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcmtleSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJHRyYW5zbGF0ZVByb3ZpZGVyLCAkdHJhbnNsYXRlUGFydGlhbExvYWRlclByb3ZpZGVyKSB7XG5cbiAgICAkdHJhbnNsYXRlUHJvdmlkZXIudXNlTG9hZGVyKCckdHJhbnNsYXRlUGFydGlhbExvYWRlcicsIHtcbiAgICAgICAgdXJsVGVtcGxhdGU6ICd7cGFydH0ve2xhbmd9Lmpzb24nXG4gICAgfSk7XG5cbiAgICAvLyBMb2FkIHRoZSBidWlsdCBsYW5ndWFnZSBmaWxlcyBmcm9tIGJ1aWxkL2xhbmcuXG4gICAgJHRyYW5zbGF0ZVBhcnRpYWxMb2FkZXJQcm92aWRlci5hZGRQYXJ0KCdidWlsZC9sYW5nJyk7XG5cbiAgICAvLyBTZXQgZmFsbGJhY2sgbGFuZ3VhZ2UuXG4gICAgJHRyYW5zbGF0ZVByb3ZpZGVyLmZhbGxiYWNrTGFuZ3VhZ2UoJ2VuJyk7XG4gICAgJHRyYW5zbGF0ZVByb3ZpZGVyLnByZWZlcnJlZExhbmd1YWdlKCdlbicpOyAvLyBTZXQgRW5nbGlzaCB1bnRpbCB3ZSBrbm93IHdoaWNoIGxhbmd1YWdlIHRvIHVzZS5cbn0pXG5cbi5ydW4oZnVuY3Rpb24oJGlvbmljUGxhdGZvcm0sICR0cmFuc2xhdGUsICRtbUxhbmcpIHtcbiAgICAkaW9uaWNQbGF0Zm9ybS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tTGFuZy5nZXRDdXJyZW50TGFuZ3VhZ2UoKS50aGVuKGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICAkdHJhbnNsYXRlLnVzZShsYW5ndWFnZSk7XG4gICAgICAgICAgICBtb21lbnQubG9jYWxlKGxhbmd1YWdlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTsiLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vLyBTdG9yZXMgdXNlZCB0byBjcmVhdGUgdW5pcXVlIElEcyBmb3Igbm90aWZpY2F0aW9ucy5cbi5jb25zdGFudCgnbW1Db3JlTm90aWZpY2F0aW9uc1NpdGVzU3RvcmUnLCAnbm90aWZpY2F0aW9uX3NpdGVzJylcbi5jb25zdGFudCgnbW1Db3JlTm90aWZpY2F0aW9uc0NvbXBvbmVudHNTdG9yZScsICdub3RpZmljYXRpb25fY29tcG9uZW50cycpXG4uY29uc3RhbnQoJ21tQ29yZU5vdGlmaWNhdGlvbnNUcmlnZ2VyZWRTdG9yZScsICdub3RpZmljYXRpb25zX3RyaWdnZXJlZCcpXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQXBwUHJvdmlkZXIsIG1tQ29yZU5vdGlmaWNhdGlvbnNTaXRlc1N0b3JlLCBtbUNvcmVOb3RpZmljYXRpb25zQ29tcG9uZW50c1N0b3JlLFxuICAgICAgICBtbUNvcmVOb3RpZmljYXRpb25zVHJpZ2dlcmVkU3RvcmUpIHtcbiAgICB2YXIgc3RvcmVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBtbUNvcmVOb3RpZmljYXRpb25zU2l0ZXNTdG9yZSwgLy8gU3RvcmUgdG8gYXNpZ25lIHVuaXF1ZSBjb2RlcyB0byBlYWNoIHNpdGUuXG4gICAgICAgICAgICBrZXlQYXRoOiAnaWQnLFxuICAgICAgICAgICAgaW5kZXhlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogbW1Db3JlTm90aWZpY2F0aW9uc0NvbXBvbmVudHNTdG9yZSwgLy8gU3RvcmUgdG8gYXNpZ25lIHVuaXF1ZSBjb2RlcyB0byBlYWNoIGNvbXBvbmVudC5cbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCcsXG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29kZScsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBtbUNvcmVOb3RpZmljYXRpb25zVHJpZ2dlcmVkU3RvcmUsIC8vIFN0b3JlIHRvIHByZXZlbnQgcmUtdHJpZ2dlcmluZyBub3RpZmljYXRpb25zLlxuICAgICAgICAgICAga2V5UGF0aDogJ2lkJyxcbiAgICAgICAgICAgIGluZGV4ZXM6IFtdXG4gICAgICAgIH1cbiAgICBdO1xuICAgICRtbUFwcFByb3ZpZGVyLnJlZ2lzdGVyU3RvcmVzKHN0b3Jlcyk7XG59KVxuXG4vKipcbiAqIEZhY3RvcnkgdG8gaGFuZGxlIGxvY2FsIG5vdGlmaWNhdGlvbnMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tTG9jYWxOb3RpZmljYXRpb25zXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVzIG1ldGhvZHMgdG8gdHJpZ2dlciBub3RpZmljYXRpb25zLCBsaXN0ZW4gY2xpY2tzIG9uIHRoZW0sIGV0Yy5cbiAqL1xuLmZhY3RvcnkoJyRtbUxvY2FsTm90aWZpY2F0aW9ucycsIGZ1bmN0aW9uKCRsb2csICRjb3Jkb3ZhTG9jYWxOb3RpZmljYXRpb24sICRtbUFwcCwgJHEsXG4gICAgICAgIG1tQ29yZU5vdGlmaWNhdGlvbnNTaXRlc1N0b3JlLCBtbUNvcmVOb3RpZmljYXRpb25zQ29tcG9uZW50c1N0b3JlLCBtbUNvcmVOb3RpZmljYXRpb25zVHJpZ2dlcmVkU3RvcmUpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Mb2NhbE5vdGlmaWNhdGlvbnMnKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIG9ic2VydmVycyA9IHt9LFxuICAgICAgICBjb2RlcyA9IHt9OyAvLyBTdG9yZSBjb2RlcyBpbiBtZW1vcnkgdG8gbWFrZSBnZXRDb2RlIGZ1bmN0aW9uIGZhc3Rlci5cblxuICAgIC8vIFdlIG5lZWQgYSBxdWV1ZSB0byByZXF1ZXN0IHVuaXF1ZSBjb2RlcywgdG8gaGFuZGxlIHNpbXVsdGFuZW91cyByZXF1ZXN0cy5cbiAgICB2YXIgY29kZVJlcXVlc3RzUXVldWUgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGNvZGUgdG8gY3JlYXRlIHVuaXF1ZSBub3RpZmljYXRpb25zLiBJZiB0aGVyZSdzIG5vIGNvZGUgYXNzaWduZWQsIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0b3JlIFN0b3JlIHRvIHNlYXJjaCBpbiBsb2NhbCBEQi5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlkICAgIElEIG9mIHRoZSBlbGVtZW50IHRvIGdldCBpdHMgY29kZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY29kZSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q29kZShzdG9yZSwgaWQpIHtcbiAgICAgICAgdmFyIGRiID0gJG1tQXBwLmdldERCKCksXG4gICAgICAgICAgICBrZXkgPSBzdG9yZSArICcjJyArIGlkO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29kZXNba2V5XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oY29kZXNba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGIuZ2V0KHN0b3JlLCBpZCkudGhlbihmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChlbnRyeS5jb2RlKTtcbiAgICAgICAgICAgIGNvZGVzW2tleV0gPSBjb2RlO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gU2l0ZSBpcyBub3QgaW4gdGhlIERCLiBDcmVhdGUgYSBuZXcgSUQgZm9yIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRiLnF1ZXJ5KHN0b3JlLCB1bmRlZmluZWQsICdjb2RlJywgdHJ1ZSkudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NvZGUgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29kZSA9IHBhcnNlSW50KGVudHJpZXNbMF0uY29kZSkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KHN0b3JlLCB7aWQ6IGlkLCBjb2RlOiBuZXdDb2RlfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXNba2V5XSA9IG5ld0NvZGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb2RlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNpdGUgY29kZSB0byBiZSB1c2VkLlxuICAgICAqIElmIGl0J3MgdGhlIGZpcnN0IHRpbWUgdGhpcyBzaXRlIGlzIHVzZWQgdG8gc2VuZCBub3RpZmljYXRpb25zLCBjcmVhdGUgYSBuZXcgY29kZSBmb3IgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVpZCAgIFNpdGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHNpdGUgY29kZSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2l0ZUNvZGUoc2l0ZWlkKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0Q29kZShtbUNvcmVOb3RpZmljYXRpb25zU2l0ZXNTdG9yZSwgc2l0ZWlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBub3RpZmljYXRpb24gY29tcG9uZW50IGNvZGUgdG8gYmUgdXNlZC5cbiAgICAgKiBJZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gc2VuZCBub3RpZmljYXRpb25zLCBjcmVhdGUgYSBuZXcgY29kZSBmb3IgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50IENvbXBvbmVudCBuYW1lLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjb21wb25lbnQgY29kZSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q29kZShjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RDb2RlKG1tQ29yZU5vdGlmaWNhdGlvbnNDb21wb25lbnRzU3RvcmUsIGNvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdW5pcXVlIG5vdGlmaWNhdGlvbiBJRCwgdHJ5aW5nIHRvIHByZXZlbnQgY29sbGlzaW9ucy4gR2VuZXJhdGVkIElEIG11c3QgYmUgYSBOdW1iZXIgKEFuZHJvaWQpLlxuICAgICAqIFRoZSBnZW5lcmF0ZWQgSUQgc2hvdWxkbid0IGJlIGhpZ2hlciB0aGFuIDIxNDc0ODM2NDcgb3IgaXQncyBnb2luZyB0byBjYXVzZSBwcm9ibGVtcyBpbiBBbmRyb2lkLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwcmV2ZW50IGNvbGxpc2lvbnMgYW5kIGtlZXAgdGhlIG51bWJlciB1bmRlciBBbmRyb2lkIGxpbWl0IGlmOlxuICAgICAqICAgICAtVXNlciBoYXMgdXNlZCBsZXNzIHRoYW4gMjEgc2l0ZXMuXG4gICAgICogICAgIC1UaGVyZSBhcmUgbGVzcyB0aGFuIDExIGNvbXBvbmVudHMuXG4gICAgICogICAgIC1UaGUgbm90aWZpY2F0aW9uaWQgcGFzc2VkIGFzIHBhcmFtZXRlciBpcyBsb3dlciB0aGFuIDEwMDAwMDAwLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBub3RpZmljYXRpb25pZCBOb3RpZmljYXRpb24gSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgICAgICBDb21wb25lbnQgdHJpZ2dlcmluZyB0aGUgbm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZWlkICAgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbm90aWZpY2F0aW9uIElEIGlzIGdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRVbmlxdWVOb3RpZmljYXRpb25JZChub3RpZmljYXRpb25pZCwgY29tcG9uZW50LCBzaXRlaWQpIHtcbiAgICAgICAgaWYgKCFzaXRlaWQgfHwgIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFNpdGVDb2RlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvZGUoY29tcG9uZW50KS50aGVuKGZ1bmN0aW9uKGNvbXBvbmVudGNvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhlICUgb3BlcmF0aW9uIHRvIGtlZXAgdGhlIG51bWJlciB1bmRlciBBbmRyb2lkJ3MgbGltaXQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChzaXRlY29kZSAqIDEwMDAwMDAwMCArIGNvbXBvbmVudGNvZGUgKiAxMDAwMDAwMCArIHBhcnNlSW50KG5vdGlmaWNhdGlvbmlkKSkgJSAyMTQ3NDgzNjQ3O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIG5leHQgcmVxdWVzdCBpbiBxdWV1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzTmV4dFJlcXVlc3QoKSB7XG4gICAgICAgIHZhciBuZXh0S2V5ID0gT2JqZWN0LmtleXMoY29kZVJlcXVlc3RzUXVldWUpWzBdLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0S2V5ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBObyBtb3JlIHJlcXVlc3RzIGluIHF1ZXVlLCBzdG9wLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdCA9IGNvZGVSZXF1ZXN0c1F1ZXVlW25leHRLZXldO1xuICAgICAgICAvLyBDaGVjayBpZiByZXF1ZXN0IGlzIHZhbGlkLlxuICAgICAgICBpZiAoYW5ndWxhci5pc09iamVjdChyZXF1ZXN0KSAmJiB0eXBlb2YgcmVxdWVzdC5zdG9yZSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcmVxdWVzdC5pZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjb2RlIGFuZCByZXNvbHZlL3JlamVjdCBhbGwgdGhlIHByb21pc2VzIG9mIHRoaXMgcmVxdWVzdC5cbiAgICAgICAgICAgIHByb21pc2UgPSBnZXRDb2RlKHJlcXVlc3Quc3RvcmUsIHJlcXVlc3QuaWQpLnRoZW4oZnVuY3Rpb24oY29kZSkge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXF1ZXN0LnByb21pc2VzLCBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHAucmVzb2x2ZShjb2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlcXVlc3QucHJvbWlzZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25jZSB0aGlzIGl0ZW0gaXMgdHJlYXRlZCwgcmVtb3ZlIGl0IGFuZCBwcm9jZXNzIG5leHQuXG4gICAgICAgIHByb21pc2UuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb2RlUmVxdWVzdHNRdWV1ZVtuZXh0S2V5XTtcbiAgICAgICAgICAgIHByb2Nlc3NOZXh0UmVxdWVzdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGEgdW5pcXVlIGNvZGUuIFRoZSByZXF1ZXN0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHF1ZXVlIGFuZCB0aGUgcXVldWUgaXMgZ29pbmcgdG8gYmUgc3RhcnRlZCBpZiBpdCdzIHBhdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RvcmUgU3RvcmUgdG8gc2VhcmNoIGluIGxvY2FsIERCLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gaWQgICAgSUQgb2YgdGhlIGVsZW1lbnQgdG8gZ2V0IGl0cyBjb2RlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjb2RlIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXF1ZXN0Q29kZShzdG9yZSwgaWQpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKSxcbiAgICAgICAgICAgIGtleSA9IHN0b3JlKycjJytpZCxcbiAgICAgICAgICAgIGlzUXVldWVFbXB0eSA9IE9iamVjdC5rZXlzKGNvZGVSZXF1ZXN0c1F1ZXVlKS5sZW5ndGggPT0gMDtcblxuICAgICAgICBpZiAodHlwZW9mIGNvZGVSZXF1ZXN0c1F1ZXVlW2tleV0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHBlbmRpbmcgcmVxdWVzdCBmb3IgdGhpcyBzdG9yZSBhbmQgSUQsIGFkZCB0aGUgcHJvbWlzZSB0byBpdC5cbiAgICAgICAgICAgIGNvZGVSZXF1ZXN0c1F1ZXVlW2tleV0ucHJvbWlzZXMucHVzaChkZWZlcnJlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBZGQgYSBwZW5kaW5nIHJlcXVlc3QgdG8gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgY29kZVJlcXVlc3RzUXVldWVba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHByb21pc2VzOiBbZGVmZXJyZWRdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUXVldWVFbXB0eSkge1xuICAgICAgICAgICAgcHJvY2Vzc05leHRSZXF1ZXN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYSBsb2NhbCBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTG9jYWxOb3RpZmljYXRpb25zI2NhbmNlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAgICAgICAgTm90aWZpY2F0aW9uIGlkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgQ29tcG9uZW50IG9mIHRoZSBub3RpZmljYXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVpZCAgICBTaXRlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBub3RpZmljYXRpb24gaXMgY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIHNlbGYuY2FuY2VsID0gZnVuY3Rpb24oaWQsIGNvbXBvbmVudCwgc2l0ZWlkKSB7XG4gICAgICAgIHJldHVybiBnZXRVbmlxdWVOb3RpZmljYXRpb25JZChpZCwgY29tcG9uZW50LCBzaXRlaWQpLnRoZW4oZnVuY3Rpb24odW5pcXVlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkY29yZG92YUxvY2FsTm90aWZpY2F0aW9uLmNhbmNlbCh1bmlxdWVJZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYWxsIHRoZSBzY2hlZHVsZWQgbm90aWZpY2F0aW9ucyBiZWxvbmdpbmcgdG8gYSBjZXJ0YWluIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTG9jYWxOb3RpZmljYXRpb25zI2NhbmNlbFNpdGVOb3RpZmljYXRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVpZCBTaXRlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbm90aWZpY2F0aW9ucyBhcmUgY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIHNlbGYuY2FuY2VsU2l0ZU5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbihzaXRlaWQpIHtcblxuICAgICAgICBpZiAoIXNlbGYuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICghc2l0ZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJGNvcmRvdmFMb2NhbE5vdGlmaWNhdGlvbi5nZXRBbGxTY2hlZHVsZWQoKS50aGVuKGZ1bmN0aW9uKHNjaGVkdWxlZCkge1xuICAgICAgICAgICAgdmFyIGlkcyA9IFtdO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NoZWR1bGVkLCBmdW5jdGlvbihub3RpZikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm90aWYuZGF0YSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBub3RpZi5kYXRhID0gSlNPTi5wYXJzZShub3RpZi5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vdGlmLmRhdGEgPT0gJ29iamVjdCcgJiYgbm90aWYuZGF0YS5zaXRlaWQgPT09IHNpdGVpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChub3RpZi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkY29yZG92YUxvY2FsTm90aWZpY2F0aW9uLmNhbmNlbChpZHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGxvY2FsIG5vdGlmaWNhdGlvbnMgcGx1Z2luIGlzIGluc3RhbGxlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMjaXNBdmFpbGFibGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIHdoZW4gbG9jYWwgbm90aWZpY2F0aW9ucyBwbHVnaW4gaXMgaW5zdGFsbGVkLlxuICAgICAqL1xuICAgIHNlbGYuaXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wbHVnaW4gJiYgd2luZG93LnBsdWdpbi5ub3RpZmljYXRpb24gJiYgd2luZG93LnBsdWdpbi5ub3RpZmljYXRpb24ubG9jYWwgPyB0cnVlOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBub3RpZmljYXRpb24gaGFzIGJlZW4gdHJpZ2dlcmVkIHdpdGggdGhlIHNhbWUgdHJpZ2dlciB0aW1lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvY2FsTm90aWZpY2F0aW9ucyNpc1RyaWdnZXJlZFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIG5vdGlmaWNhdGlvbiBOb3RpZmljYXRpb24gdG8gY2hlY2suIE5lZWRzIHRvIGhhdmUgJ2lkJyBhbmQgJ2F0JyBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggYSBib29sZWFuIGluZGljYXRpbmcgaWYgcHJvbWlzZSBpcyB0cmlnZ2VyZWQgKHRydWUpIG9yIG5vdC5cbiAgICAgKi9cbiAgICBzZWxmLmlzVHJpZ2dlcmVkID0gZnVuY3Rpb24obm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5nZXQobW1Db3JlTm90aWZpY2F0aW9uc1RyaWdnZXJlZFN0b3JlLCBub3RpZmljYXRpb24uaWQpLnRoZW4oZnVuY3Rpb24oc3RvcmVkKSB7XG4gICAgICAgICAgICB2YXIgbm90aWZUaW1lID0gbm90aWZpY2F0aW9uLmF0LmdldFRpbWUoKSAvIDEwMDA7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVkLmF0ID09PSBub3RpZlRpbWU7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IG5vdGlmaWNhdGlvbiBjbGljayB0byBvYnNlcnZlci4gT25seSB0aGUgb2JzZXJ2ZXIgd2l0aCB0aGUgc2FtZSBjb21wb25lbnQgYXMgdGhlIG5vdGlmaWNhdGlvbiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvY2FsTm90aWZpY2F0aW9ucyNub3RpZnlDbGlja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIERhdGEgcmVjZWl2ZWQgYnkgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBzZWxmLm5vdGlmeUNsaWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gZGF0YS5jb21wb25lbnQ7XG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IG9ic2VydmVyc1tjb21wb25lbnRdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gb2JzZXJ2ZXIgdG8gYmUgbm90aWZpZWQgd2hlbiBhIG5vdGlmaWNhdGlvbiBiZWxvbmdpbmcgdG8gYSBjZXJ0YWluIGNvbXBvbmVudCBpcyBjbGlja2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvY2FsTm90aWZpY2F0aW9ucyNyZWdpc3RlckNsaWNrXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgQ29tcG9uZW50IHRvIGxpc3RlbiBub3RpZmljYXRpb25zIGZvci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBjYWxsIHdpdGggdGhlIGRhdGEgcmVjZWl2ZWQgYnkgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBzZWxmLnJlZ2lzdGVyQ2xpY2sgPSBmdW5jdGlvbihjb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICRsb2cuZGVidWcoXCJSZWdpc3RlciBvYnNlcnZlciAnXCIrY29tcG9uZW50K1wiJyBmb3Igbm90aWZpY2F0aW9uIGNsaWNrLlwiKTtcbiAgICAgICAgb2JzZXJ2ZXJzW2NvbXBvbmVudF0gPSBjYWxsYmFjaztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbm90aWZpY2F0aW9uIGZyb20gdHJpZ2dlcmVkIHN0b3JlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvY2FsTm90aWZpY2F0aW9ucyNyZW1vdmVUcmlnZ2VyZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgTm90aWZpY2F0aW9uIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gaXQgaXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBzZWxmLnJlbW92ZVRyaWdnZXJlZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5yZW1vdmUobW1Db3JlTm90aWZpY2F0aW9uc1RyaWdnZXJlZFN0b3JlLCBpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIGEgbG9jYWwgbm90aWZpY2F0aW9uLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2thdHplci9jb3Jkb3ZhLXBsdWdpbi1sb2NhbC1ub3RpZmljYXRpb25zL3dpa2kvMDQuLVNjaGVkdWxpbmdcbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMjc2NoZWR1bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm90aWZpY2F0aW9uIE5vdGlmaWNhdGlvbiB0byBzY2hlZHVsZS4gSXRzIElEIHNob3VsZCBiZSBsb3dlciB0aGFuIDEwMDAwMDAwIGFuZCBpdCBzaG91bGQgYmUgdW5pcXVlIGluc2lkZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRzIGNvbXBvbmVudCBhbmQgc2l0ZS4gSWYgdGhlIElEIGlzIGhpZ2hlciB0aGFuIHRoYXQgbnVtYmVyIHRoZXJlIG1pZ2h0IGJlIGNvbGxpc2lvbnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgICBDb21wb25lbnQgdHJpZ2dlcmluZyB0aGUgbm90aWZpY2F0aW9uLiBJdCBpcyB1c2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVpZCAgICAgICBTaXRlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBub3RpZmljYXRpb24gaXMgc2NoZWR1bGVkLlxuICAgICAqL1xuICAgIHNlbGYuc2NoZWR1bGUgPSBmdW5jdGlvbihub3RpZmljYXRpb24sIGNvbXBvbmVudCwgc2l0ZWlkKSB7XG4gICAgICAgIHJldHVybiBnZXRVbmlxdWVOb3RpZmljYXRpb25JZChub3RpZmljYXRpb24uaWQsIGNvbXBvbmVudCwgc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHVuaXF1ZUlkKSB7XG4gICAgICAgICAgICBub3RpZmljYXRpb24uaWQgPSB1bmlxdWVJZDtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5kYXRhID0gbm90aWZpY2F0aW9uLmRhdGEgfHwge307XG4gICAgICAgICAgICBub3RpZmljYXRpb24uZGF0YS5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICBub3RpZmljYXRpb24uZGF0YS5zaXRlaWQgPSBzaXRlaWQ7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmlzVHJpZ2dlcmVkKG5vdGlmaWNhdGlvbikudGhlbihmdW5jdGlvbih0cmlnZ2VyZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyaWdnZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0cmlnZ2VyZWQsIHNpbmNlIHRoZSBub3RpZmljYXRpb24gY291bGQgYmUgaW4gdGhlcmUgd2l0aCBhIGRpZmZlcmVudCB0aW1lLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZVRyaWdnZXJlZChub3RpZmljYXRpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFMb2NhbE5vdGlmaWNhdGlvbi5zY2hlZHVsZShub3RpZmljYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgbm90aWZpY2F0aW9uIGlzIHRyaWdnZXJlZC4gU3RvcmVzIHRoZSBub3RpZmljYXRpb24gc28gaXQncyBub3Qgc2NoZWR1bGVkIGFnYWluIHVubGVzcyB0aGVcbiAgICAgKiB0aW1lIGlzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTG9jYWxOb3RpZmljYXRpb25zI3RyaWdnZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm90aWZpY2F0aW9uIFRyaWdnZXJlZCBub3RpZmljYXRpb24uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gc3RvcmVkLCByZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi50cmlnZ2VyID0gZnVuY3Rpb24obm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHZhciBpZCA9IHBhcnNlSW50KG5vdGlmaWNhdGlvbi5pZCk7XG4gICAgICAgIGlmICghaXNOYU4oaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkuaW5zZXJ0KG1tQ29yZU5vdGlmaWNhdGlvbnNUcmlnZ2VyZWRTdG9yZSwge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBhdDogcGFyc2VJbnQobm90aWZpY2F0aW9uLmF0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KVxuXG4ucnVuKGZ1bmN0aW9uKCRyb290U2NvcGUsICRsb2csICRtbUxvY2FsTm90aWZpY2F0aW9ucywgJG1tRXZlbnRzLCBtbUNvcmVFdmVudFNpdGVEZWxldGVkKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUxvY2FsTm90aWZpY2F0aW9ucycpO1xuXG4gICAgJHJvb3RTY29wZS4kb24oJyRjb3Jkb3ZhTG9jYWxOb3RpZmljYXRpb246dHJpZ2dlcicsIGZ1bmN0aW9uKGUsIG5vdGlmaWNhdGlvbiwgc3RhdGUpIHtcbiAgICAgICAgJG1tTG9jYWxOb3RpZmljYXRpb25zLnRyaWdnZXIobm90aWZpY2F0aW9uKTtcbiAgICB9KTtcblxuICAgICRyb290U2NvcGUuJG9uKCckY29yZG92YUxvY2FsTm90aWZpY2F0aW9uOmNsaWNrJywgZnVuY3Rpb24oZSwgbm90aWZpY2F0aW9uLCBzdGF0ZSkge1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uICYmIG5vdGlmaWNhdGlvbi5kYXRhKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdOb3RpZmljYXRpb24gY2xpY2tlZDogJytub3RpZmljYXRpb24uZGF0YSk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2Uobm90aWZpY2F0aW9uLmRhdGEpO1xuICAgICAgICAgICAgJG1tTG9jYWxOb3RpZmljYXRpb25zLm5vdGlmeUNsaWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRTaXRlRGVsZXRlZCwgZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICBpZiAoc2l0ZSkge1xuICAgICAgICAgICAgJG1tTG9jYWxOb3RpZmljYXRpb25zLmNhbmNlbFNpdGVOb3RpZmljYXRpb25zKHNpdGUuaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi5jb25zdGFudCgnbW1Db3JlTG9nRW5hYmxlZERlZmF1bHQnLCB0cnVlKSAvLyBEZWZhdWx0IHZhbHVlIGZvciBsb2dFbmFibGVkLlxuLmNvbnN0YW50KCdtbUNvcmVMb2dFbmFibGVkQ29uZmlnTmFtZScsICdkZWJ1Z19lbmFibGVkJylcblxuLyoqXG4gKiBQcm92aWRlciB0byBkZWNvcmF0ZSBhbmd1bGFyJ3MgJGxvZyBzZXJ2aWNlLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIHByb3ZpZGVyXG4gKiBAbmFtZSAkbW1Mb2dcbiAqIEBkZXNjcmlwdGlvblxuICogJG1tTG9nUHJvdmlkZXIubG9nRGVjb3JhdG9yIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGRlY29yYXRlICckbG9nJy4gSXQgc2hvdWxkIGJlIHVzZWQgbGlrZSB0aGlzOlxuICogICAgICRwcm92aWRlLmRlY29yYXRvcignJGxvZycsIFsnJGRlbGVnYXRlJywgJG1tTG9nUHJvdmlkZXIubG9nRGVjb3JhdG9yXSk7XG4gKlxuICogRGVjb3JhdGVkICRsb2cgdXNhZ2U6XG4gKiAgICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ015RmFjdG9yeScpXG4gKiAgICAgJGxvZy5kZWJ1ZygnTXkgbWVzc2FnZScpIC0+IFwiZGQvbW0vYWFhYSBoaDptbTpzcyBNeUZhY3Rvcnk6IE15IG1lc3NhZ2VcIlxuICpcbiAqIFRvIHBlcm1hbmVudGx5IGVuYWJsZS9kaXNhYmxlIGxvZ2dpbmcgbWVzc2FnZXMsIHVzZTpcbiAqICAgICAkbW1Mb2cuZW5hYmxlZCh0cnVlL2ZhbHNlKVxuICovXG4ucHJvdmlkZXIoJyRtbUxvZycsIGZ1bmN0aW9uKG1tQ29yZUxvZ0VuYWJsZWREZWZhdWx0KSB7XG5cbiAgICB2YXIgaXNFbmFibGVkID0gbW1Db3JlTG9nRW5hYmxlZERlZmF1bHQsXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gRnVuY3Rpb24gdG8gcHJlLWNhcHR1cmUgYSBsb2dnZXIgZnVuY3Rpb24uXG4gICAgZnVuY3Rpb24gcHJlcGFyZUxvZ0ZuKGxvZ0ZuLCBjbGFzc05hbWUpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xuICAgICAgICAvLyBJbnZva2UgdGhlIHNwZWNpZmllZCAnbG9nRm4nIHdpdGggb3VyIG5ldyBjb2RlLlxuICAgICAgICB2YXIgZW5oYW5jZWRMb2dGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgbm93ICA9IG1vbWVudCgpLmZvcm1hdCgnbCBMVFMnKTtcblxuICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBub3cgKyAnICcgKyBjbGFzc05hbWUgKyAnOiAnICsgYXJnc1swXTsgLy8gUHJlcGVuZCB0aW1lc3RhbXAgYW5kIGNsYXNzTmFtZSB0byB0aGUgb3JpZ2luYWwgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICBsb2dGbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTcGVjaWFsLCBvbmx5IG5lZWRlZCB0byBzdXBwb3J0IGFuZ3VsYXItbW9ja3MgZXhwZWN0YXRpb25zLlxuICAgICAgICBlbmhhbmNlZExvZ0ZuLmxvZ3MgPSBbXTtcblxuICAgICAgICByZXR1cm4gZW5oYW5jZWRMb2dGbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlcyAkbG9nIHNlcnZpY2UsIGFkZGluZyBkYXRlIGFuZCBjb21wb25lbnQgdG8gdGhlIGxvZ2dlZCBtZXNzYWdlLCBhbmQgYWxsb3dpbmcgZGlzYWJsZSBsb2cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTZXJ2aWNlfSAkbG9nIEFuZ3VsYXIncyAkbG9nIHNlcnZpY2UgdG8gZGVjb3JhdGUuXG4gICAgICogQHJldHVybiB7U2VydmljZX0gICAgICBEZWNvcmF0ZWQgJGxvZy5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ0RlY29yYXRvciA9IGZ1bmN0aW9uKCRsb2cpIHtcbiAgICAgICAgLy8gQ29weSB0aGUgb3JpZ2luYWwgbWV0aG9kcy5cbiAgICAgICAgdmFyIF8kbG9nID0gKGZ1bmN0aW9uKCRsb2cpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG9nICAgOiAkbG9nLmxvZyxcbiAgICAgICAgICAgICAgICBpbmZvICA6ICRsb2cuaW5mbyxcbiAgICAgICAgICAgICAgICB3YXJuICA6ICRsb2cud2FybixcbiAgICAgICAgICAgICAgICBkZWJ1ZyA6ICRsb2cuZGVidWcsXG4gICAgICAgICAgICAgICAgZXJyb3IgOiAkbG9nLmVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgkbG9nKTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGdldEluc3RhbmNlIG1ldGhvZCBzbyBzZXJ2aWNlcy9jb250cm9sbGVycyBjYW4gY29uZmlndXJlIHRoZSBjbGFzc05hbWUgdG8gYmUgc2hvd24uXG4gICAgICAgIHZhciBnZXRJbnN0YW5jZSA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb2cgICA6IHByZXBhcmVMb2dGbihfJGxvZy5sb2csIGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAgaW5mbyAgOiBwcmVwYXJlTG9nRm4oXyRsb2cuaW5mbywgY2xhc3NOYW1lKSxcbiAgICAgICAgICAgICAgICB3YXJuICA6IHByZXBhcmVMb2dGbihfJGxvZy53YXJuLCBjbGFzc05hbWUpLFxuICAgICAgICAgICAgICAgIGRlYnVnIDogcHJlcGFyZUxvZ0ZuKF8kbG9nLmRlYnVnLCBjbGFzc05hbWUpLFxuICAgICAgICAgICAgICAgIGVycm9yIDogcHJlcGFyZUxvZ0ZuKF8kbG9nLmVycm9yLCBjbGFzc05hbWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERlY29yYXRlIG9yaWdpbmFsICRsb2cgZnVuY3Rpb25zIHRvby4gVGhpcyB3YXkgaWYgYSBzZXJ2aWNlL2NvbnRyb2xsZXIgdXNlcyAkbG9nIHdpdGhvdXQgJGxvZy5nZXRJbnN0YW5jZSxcbiAgICAgICAgLy8gaXQncyBnb2luZyB0byBwcmVwZW5kIHRoZSBkYXRlIGFuZCAnQ29yZScuXG4gICAgICAgICRsb2cubG9nICAgPSBwcmVwYXJlTG9nRm4oJGxvZy5sb2cpO1xuICAgICAgICAkbG9nLmluZm8gID0gcHJlcGFyZUxvZ0ZuKCRsb2cuaW5mbyk7XG4gICAgICAgICRsb2cud2FybiAgPSBwcmVwYXJlTG9nRm4oJGxvZy53YXJuKTtcbiAgICAgICAgJGxvZy5kZWJ1ZyA9IHByZXBhcmVMb2dGbigkbG9nLmRlYnVnKTtcbiAgICAgICAgJGxvZy5lcnJvciA9IHByZXBhcmVMb2dGbigkbG9nLmVycm9yKTtcbiAgICAgICAgJGxvZy5nZXRJbnN0YW5jZSA9IGdldEluc3RhbmNlO1xuXG4gICAgICAgIHJldHVybiAkbG9nO1xuICAgIH07XG5cbiAgICB0aGlzLiRnZXQgPSBmdW5jdGlvbigkbW1Db25maWcsIG1tQ29yZUxvZ0VuYWJsZWREZWZhdWx0LCBtbUNvcmVMb2dFbmFibGVkQ29uZmlnTmFtZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIGxvZ2dpbmcsIGVuYWJsaW5nL2Rpc2FibGluZyBpdCBiYXNlZCBvbiBzZXR0aW5ncyBhbmQgbW1Db3JlTG9nRW5hYmxlZERlZmF1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUxvZyNpbml0XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbUNvbmZpZy5nZXQobW1Db3JlTG9nRW5hYmxlZENvbmZpZ05hbWUpLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlzRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3Qgc2V0LCB1c2UgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpc0VuYWJsZWQgPSBtbUNvcmVMb2dFbmFibGVkRGVmYXVsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZS9kaXNhYmxlIGxvZ2dpbmcgaW4gdGhlIGFwcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tTG9nI2VuYWJsZWRcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBmbGFnIFRydWUgaWYgbG9nIHNob3VsZCBiZSBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmVuYWJsZWQgPSBmdW5jdGlvbihmbGFnKSB7XG4gICAgICAgICAgICAkbW1Db25maWcuc2V0KG1tQ29yZUxvZ0VuYWJsZWRDb25maWdOYW1lLCBmbGFnKTtcbiAgICAgICAgICAgIGlzRW5hYmxlZCA9IGZsYWc7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGFwcCBsb2dnaW5nIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUxvZyNpc0VuYWJsZWRcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBsb2cgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0VuYWJsZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbn0pXG5cbi5ydW4oZnVuY3Rpb24oJG1tTG9nKSB7XG4gICAgJG1tTG9nLmluaXQoKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIHByb3ZpZGUgZnVuY3Rpb25hbGl0aWVzIHJlbGF0ZWQgdG8gY3VycmVudCBzaXRlLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGZhY3RvcnlcbiAqIEBuYW1lICRtbVNpdGVcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzZXJ2aWNlcyBwcm92aWRlcyBhIHNldCBvZiBmdW5jdGlvbmFsaXRpZXMgcmVsYXRlZCB0byBjdXJyZW50IHNpdGUuIFRoZSBjdXJyZW50IHNpdGUgaW5zdGFuY2UgaXMgc3RvcmVkIGluICRtbVNpdGVzTWFuYWdlci5cbiAqIFRoaXMgc2VydmljZSBjYW4gYmUgc2VlbiBhcyBhbiBpbnN0YW5jZSBvZiBTaXRlIGRlZmluZWQgaW4gJG1tU2l0ZXNGYWN0b3J5LCB3aXRoIG9uZSBtZXRob2QgYWRkZWQ6ICRtbVNpdGUuaXNMb2dnZWRJbi5cbiAqL1xuLmZhY3RvcnkoJyRtbVNpdGUnLCBmdW5jdGlvbigkbW1TaXRlc01hbmFnZXIsICRtbVNpdGVzRmFjdG9yeSkge1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgc2l0ZU1ldGhvZHMgPSAkbW1TaXRlc0ZhY3RvcnkuZ2V0U2l0ZU1ldGhvZHMoKTtcblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2dldElkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDdXJyZW50IHNpdGUgSUQuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBHZXQgY3VycmVudCBzaXRlIElELlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjZ2V0VVJMXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDdXJyZW50IHNpdGUgVVJMLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogR2V0IGN1cnJlbnQgc2l0ZSBVUkwuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNnZXRUb2tlblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ3VycmVudCBzaXRlIHRva2VuLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogR2V0IGN1cnJlbnQgc2l0ZSB0b2tlbi5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2dldEluZm9cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgc2l0ZSBpbmZvLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogR2V0IGN1cnJlbnQgc2l0ZSBpbmZvLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjZ2V0RGJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgc2l0ZSBEQi5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEdldCBjdXJyZW50IHNpdGUgREIuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNnZXRVc2VySWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFVzZXIncyBJRC5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEdldCBjdXJyZW50IHNpdGUgdXNlcidzIElELlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjc2V0SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gTmV3IElELlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogU2V0IGN1cnJlbnQgc2l0ZSBJRC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI3NldFRva2VuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IE5ldyB0b2tlbi5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFNldCBjdXJyZW50IHNpdGUgdG9rZW4uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNjYW5BY2Nlc3NNeUZpbGVzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gRmFsc2Ugd2hlbiB0aGV5IGNhbm5vdC5cbiAgICAgKiAjZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHVzZXIgY2FuIGFjY2VzcyBwcml2YXRlIGZpbGVzIGluIGN1cnJlbnQgc2l0ZS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2NhbkRvd25sb2FkRmlsZXNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBGYWxzZSB3aGVuIHRoZXkgY2Fubm90LlxuICAgICAqICNkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgdXNlciBjYW4gZG93bmxvYWQgZmlsZXMgaW4gY3VycmVudCBzaXRlLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjY2FuVXNlQWR2YW5jZWRGZWF0dXJlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZlYXR1cmUgVGhlIG5hbWUgb2YgdGhlIGZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbd2hlblVuZGVmaW5lZD10cnVlXSBUaGUgdmFsdWUgdG8gcmV0dXJuIHdoZW4gdGhlIHBhcmFtZXRlciBpcyB1bmRlZmluZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBGYWxzZSB3aGVuIHRoZXkgY2Fubm90LlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQ2FuIHRoZSB1c2VyIHVzZSBhbiBhZHZhbmNlZCBmZWF0dXJlP1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjY2FuVXBsb2FkRmlsZXNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBGYWxzZSB3aGVuIHRoZXkgY2Fubm90LlxuICAgICAqICNkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgdXNlciBjYW4gdXBsb2FkIGZpbGVzIGluIGN1cnJlbnQgc2l0ZS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZldGNoIHNpdGUgaW5mbyBmcm9tIHRoZSBNb29kbGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2ZldGNoU2l0ZUluZm9cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgc2l0ZSBpbmZvIGlzIHJldHJpZXZlZC5cbiAgICAgKiAjZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEZldGNoIHNpdGUgaW5mbyBmcm9tIHRoZSBjdXJyZW50IE1vb2RsZSBzaXRlLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjcmVhZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcmVhZCAgV1MgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgICAgRGF0YSB0byBzZW5kIHRvIHRoZSBXUy5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHByZVNldHMgT3B0aW9ucy4gQHNlZSAkbW1TaXRlI3JlcXVlc3QuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgcmVxdWVzdCBpcyBmaW5pc2hlZC5cbiAgICAgKiAjZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlYWQgc29tZSBkYXRhIGZyb20gdGhlIGN1cnJlbnQgTW9vZGxlIHNpdGUgdXNpbmcgV1MuIFJlcXVlc3RzIGFyZSBjYWNoZWQgYnkgZGVmYXVsdC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI3dyaXRlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBtZXRob2QgIFdTIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhICAgIERhdGEgdG8gc2VuZCB0byB0aGUgV1MuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwcmVTZXRzIE9wdGlvbnMuIEBzZWUgJG1tU2l0ZSNyZXF1ZXN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIHJlcXVlc3QgaXMgZmluaXNoZWQuXG4gICAgICogI2Rlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBTZW5kcyBzb21lIGRhdGEgdG8gdGhlIGN1cnJlbnQgTW9vZGxlIHNpdGUgdXNpbmcgV1MuIFJlcXVlc3RzIGFyZSBOT1QgY2FjaGVkIGJ5IGRlZmF1bHQuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNyZXF1ZXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgV2ViU2VydmljZSBtZXRob2QgdG8gYmUgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZVNldHMgRXh0cmEgc2V0dGluZ3MuXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gZ2V0RnJvbUNhY2hlIGJvb2xlYW4gKGZhbHNlKSBVc2UgdGhlIGNhY2hlIHdoZW4gcG9zc2libGUuXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gc2F2ZVRvQ2FjaGUgYm9vbGVhbiAoZmFsc2UpIFNhdmUgdGhlIGNhbGwgcmVzdWx0cyB0byB0aGUgY2FjaGUuXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gb21pdEV4cGlyZXMgYm9vbGVhbiAoZmFsc2UpIElnbm9yZSBjYWNoZSBleHBpcnkuXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gc3luYyBib29sZWFuIChmYWxzZSkgQWRkIGNhbGwgdG8gcXVldWUgaWYgZGV2aWNlIGlzIG5vdCBjb25uZWN0ZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gY2FjaGVLZXkgKHN0cmluZykgRXh0cmEga2V5IHRvIGFkZCB0byB0aGUgY2FjaGUgd2hlbiBzdG9yaW5nIHRoaXMgY2FsbC4gVGhpcyBrZXkgaXMgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFnIHRoZSBjYWNoZSBlbnRyeSwgaXQgZG9lc24ndCBhZmZlY3QgdGhlIGRhdGEgcmV0cmlldmVkIGluIHRoaXMgY2FsbC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBnZXRDYWNoZVVzaW5nQ2FjaGVLZXkgKGJvb2xlYW4pIFRydWUgaWYgaXQgc2hvdWxkIHJldHJpZXZlIGNhY2hlZCBkYXRhIGJ5IGNhY2hlS2V5LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIGlmIGl0IHNob3VsZCBnZXQgdGhlIGRhdGEgYmFzZWQgb24gdGhlIHBhcmFtcyBwYXNzZWQgKHVzdWFsIGJlaGF2aW9yKS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogU2VuZHMgYSB3ZWJzZXJ2aWNlIHJlcXVlc3QgdG8gdGhlIHNpdGUuIFRoaXMgbWV0aG9kIHdpbGwgYXV0b21hdGljYWxseSBhZGQgdGhlXG4gICAgICogcmVxdWlyZWQgcGFyYW1ldGVycyBhbmQgcGFzcyBpdCBvbiB0byB0aGUgbG93IGxldmVsIEFQSSBpbiAkbW1XUy5jYWxsKCkuXG4gICAgICpcbiAgICAgKiBDYWNoaW5nIGlzIGFsc28gaW1wbGVtZW50ZWQsIHdoZW4gZW5hYmxlZCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybmVkIGEgY2FjaGVkXG4gICAgICogdmVyc2lvbiBvZiBpdHNlbGYgcmF0aGVyIHRoYW4gY29udGFjdGluZyB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgc21hcnQgd2hpY2ggbWVhbnMgdGhhdCBpdCB3aWxsIHRyeSB0byBtYXAgdGhlIG1ldGhvZCB0byBhXG4gICAgICogY29tcGF0aWJpbGl0eSBvbmUgaWYgbmVlZCBiZSwgdXN1YWxseSB0aGF0IG1lYW5zIHRoYXQgaXQgd2lsbCBmYWxsYmFjayBvblxuICAgICAqIHRoZSAnbG9jYWxfbW9iaWxlXycgcHJlZml4ZWQgZnVuY3Rpb24gaWYgaXQgaXMgYXZhaWxhYmxlIGFuZCB0aGUgbm9uLXByZWZpeGVkIGlzIG5vdC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI3dzQXZhaWxhYmxlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBtZXRob2QgICAgICBXUyBuYW1lLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW49dHJ1ZX0gY2hlY2tQcmVmaXggV2hlbiB0cnVlIGFsc28gY2hlY2tzIHdpdGggdGhlIGNvbXBhdGliaWxpdHkgcHJlZml4LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgVHJ1ZSBpZiB0aGUgV1MgaXMgYXZhaWxhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQ2hlY2sgaWYgYSBXUyBpcyBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBhIHdlYiBzZXJ2aWNlIGZ1bmN0aW9uIGlzIGF2YWlsYWJsZS4gQnkgZGVmYXVsdCBpdCB3aWxsXG4gICAgICogYWxzbyBjaGVjayBpZiB0aGVyZSBpcyBhIGNvbXBhdGliaWxpdHkgZnVuY3Rpb24gZm9yIGl0LCBlLmcuIGEgcHJlZml4ZWQgb25lLlxuICAgICAqL1xuXG4gICAgLypcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSN1cGxvYWRGaWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVyaSBGaWxlIFVSSS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBGaWxlIHNldHRpbmdzOiBmaWxlS2V5LCBmaWxlTmFtZSBhbmQgbWltZVR5cGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIHRvIHRoZSBjdXJyZW50IHNpdGUgdXNpbmcgQ29yZG92YSBGaWxlIEFQSS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2ludmFsaWRhdGVXc0NhY2hlRm9yS2V5XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBrZXkgS2V5IHRvIHNlYXJjaC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNhY2hlIGVudHJpZXMgYXJlIGludmFsaWRhdGVkLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogSW52YWxpZGF0ZXMgYWxsIHRoZSBjYWNoZSBlbnRyaWVzIHdpdGggYSBjZXJ0YWluIGtleS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2ludmFsaWRhdGVXc0NhY2hlRm9yS2V5U3RhcnRpbmdXaXRoXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBrZXkgS2V5IHRvIHNlYXJjaC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNhY2hlIGVudHJpZXMgYXJlIGludmFsaWRhdGVkLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogSW52YWxpZGF0ZXMgYWxsIHRoZSBjYWNoZSBlbnRyaWVzIHdob3NlIGtleSBzdGFydHMgd2l0aCBhIGNlcnRhaW4gdmFsdWUuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNmaXhQbHVnaW5maWxlVVJMXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgIFRoZSB1cmwgdG8gYmUgZml4ZWQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgIEZpeGVkIFVSTC5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEdlbmVyaWMgZnVuY3Rpb24gZm9yIGFkZGluZyB0aGUgd3N0b2tlbiB0byBNb29kbGUgdXJscyBhbmQgZm9yIHBvaW50aW5nIHRvIHRoZSBjb3JyZWN0IHNjcmlwdC5cbiAgICAgKiBVc2VzICRtbVV0aWwuZml4UGx1Z2luZmlsZVVSTCwgcGFzc2luZyBjdXJyZW50IHNpdGUncyB0b2tlbi5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2RlbGV0ZURCXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBEQiBpcyBkZWxldGVkLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRGVsZXRlcyBjdXJyZW50IHNpdGUncyBEQi5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2RlbGV0ZUZvbGRlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZm9sZGVyIGlzIGRlbGV0ZWQuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBEZWxldGVzIGN1cnJlbnQgc2l0ZSdzIGZvbGRlci5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2dldFNwYWNlVXNhZ2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHNpdGUgc3BhY2UgdXNhZ2UgKHNpemUpLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogR2V0IHNwYWNlIHVzYWdlIG9mIHRoZSBzaXRlLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGUjZ2V0RG9jc1VybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFnZV0gICAgRG9jcyBwYWdlIHRvIGdvIHRvLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBNb29kbGUgZG9jcyBVUkwuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBVUkwgdG8gdGhlIGRvY3VtZW50YXRpb24gb2YgdGhlIGFwcCwgYmFzZWQgb24gTW9vZGxlIHZlcnNpb24gYW5kIGN1cnJlbnQgbGFuZ3VhZ2UuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNjaGVja0xvY2FsTW9iaWxlUGx1Z2luXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjaGVjayBpcyBkb25lLiBSZXNvbHZlIHBhcmFtczpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge051bWJlcn0gY29kZSBDb2RlIHRvIGlkZW50aWZ5IHRoZSBhdXRoZW50aWNhdGlvbiBtZXRob2QgdG8gdXNlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBbc2VydmljZV0gSWYgZGVmaW5lZCwgbmFtZSBvZiB0aGUgc2VydmljZSB0byB1c2UuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IFt3YXJuaW5nXSBJZiBkZWZpbmVkLCBjb2RlIG9mIHRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiB0aGUgbG9jYWxfbW9iaWxlIHBsdWdpbiBpcyBpbnN0YWxsZWQgaW4gdGhlIE1vb2RsZSBzaXRlLlxuICAgICAqIFRoaXMgcGx1Z2luIHByb3ZpZGUgZXh0ZW5kZWQgc2VydmljZXMuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNjaGVja0xvY2FsTW9iaWxlUGx1Z2luXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCBpdCBsb2NhbF9tb2JpbGUgd2FzIGFkZGVkLCByZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiBsb2NhbF9tb2JpbGUgaGFzIGJlZW4gaW5zdGFsbGVkIGluIE1vb2RsZSBidXQgdGhlIGFwcCBpcyBub3QgdXNpbmcgaXQuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNjb250YWluc1VybFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHVybCBVUkwgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUgaWYgVVJMIGJlbG9uZ3MgdG8gdGhpcyBzaXRlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiBhIFVSTCBiZWxvbmdzIHRvIHRoaXMgc2l0ZS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlI2dldENvbXBhdGlibGVGdW5jdGlvblxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbWV0aG9kIFdTIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIE1ldGhvZCB0byB1c2UgYmFzZWQgaW4gdGhlIGF2YWlsYWJsZSBmdW5jdGlvbnMuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXR1cm4gdGhlIGZ1bmN0aW9uIHRvIGJlIHVzZWQsIGJhc2VkIG9uIHRoZSBhdmFpbGFibGUgZnVuY3Rpb25zIGluIHRoZSBzaXRlLiBJdCdsbCB0cnkgdG8gdXNlIG5vbi1kZXByZWNhdGVkXG4gICAgICogZnVuY3Rpb25zIGZpcnN0LCBhbmQgZmFsbGJhY2sgdG8gZGVwcmVjYXRlZCBvbmVzIGlmIG5lZWRlZC5cbiAgICAgKi9cblxuICAgIC8vIFJlcGxpY2F0ZSBhbGwgU2l0ZSBtZXRob2RzIHJlZmluZWQgaW4gJG1tU2l0ZXNGYWN0b3J5IHRvIGJlIHVzZWQgd2l0aCBjdXJyZW50IHNpdGUuXG4gICAgYW5ndWxhci5mb3JFYWNoKHNpdGVNZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgc2VsZlttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNpdGUgPSAkbW1TaXRlc01hbmFnZXIuZ2V0Q3VycmVudFNpdGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudFNpdGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNpdGVbbWV0aG9kXS5hcHBseShjdXJyZW50U2l0ZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB1c2VyIGlzIGxvZ2dlZCBpbiBhIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZSNpc0xvZ2dlZEluXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXNlciBpcyBsb2dnZWQgaW4gYSBzaXRlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc0xvZ2dlZEluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJyZW50U2l0ZSA9ICRtbVNpdGVzTWFuYWdlci5nZXRDdXJyZW50U2l0ZSgpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGN1cnJlbnRTaXRlICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjdXJyZW50U2l0ZS50b2tlbiAhPSAndW5kZWZpbmVkJyAmJiBjdXJyZW50U2l0ZS50b2tlbiAhPSAnJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi52YWx1ZSgnbW1Db3JlV1NQcmVmaXgnLCAnbG9jYWxfbW9iaWxlXycpXG5cbi5jb25zdGFudCgnbW1Db3JlV1NDYWNoZVN0b3JlJywgJ3dzY2FjaGUnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbVNpdGVzRmFjdG9yeVByb3ZpZGVyLCBtbUNvcmVXU0NhY2hlU3RvcmUpIHtcbiAgICB2YXIgc3RvcmVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBtbUNvcmVXU0NhY2hlU3RvcmUsXG4gICAgICAgICAgICBrZXlQYXRoOiAnaWQnLFxuICAgICAgICAgICAgaW5kZXhlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2tleSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICBdO1xuICAgICRtbVNpdGVzRmFjdG9yeVByb3ZpZGVyLnJlZ2lzdGVyU3RvcmVzKHN0b3Jlcyk7XG59KVxuXG4vKipcbiAqIFByb3ZpZGVyIHRvIGNyZWF0ZSBzaXRlcyBpbnN0YW5jZXMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgcHJvdmlkZXJcbiAqIEBuYW1lICRtbVNpdGVzRmFjdG9yeVxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHByb3ZpZGVyIGlzIHRoZSBpbnRlcmZhY2Ugd2l0aCB0aGUgREIgZGF0YWJhc2UuIFRoZSBtb2R1bGVzIHRoYXQgbmVlZCB0byBzdG9yZVxuICogaW5mb3JtYXRpb24gaGVyZSBuZWVkIHRvIHJlZ2lzdGVyIHRoZWlyIHN0b3Jlcy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIC5jb25maWcoZnVuY3Rpb24oJG1tU2l0ZXNGYWN0b3J5UHJvdmlkZXIpIHtcbiAqICAgICAgJG1tU2l0ZXNGYWN0b3J5UHJvdmlkZXIucmVnaXN0ZXJTdG9yZSh7XG4gKiAgICAgICAgICBuYW1lOiAnY291cnNlcycsXG4gKiAgICAgICAgICBrZXlQYXRoOiAnaWQnXG4gKiAgICAgIH0pO1xuICogIH0pXG4gKlxuICogVGhlIHNlcnZpY2UgJG1tU2l0ZXNGYWN0b3J5IGlzIHVzZWQgdG8gY3JlYXRlIHNpdGUgaW5zdGFuY2VzLiBJdCdzIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIGRpcmVjdGx5LCBpdHMgdXNhZ2UgaXNcbiAqIHJlc3RyaWN0ZWQgdG8gY29yZS4gRGV2ZWxvcGVycyBzaG91bGQgb25seSB1c2UgJG1tU2l0ZXNGYWN0b3J5UHJvdmlkZXIsICRtbVNpdGVzTWFuYWdlciBhbmQgJG1tU2l0ZS5cbiAqL1xuLnByb3ZpZGVyKCckbW1TaXRlc0ZhY3RvcnknLCBmdW5jdGlvbigpIHtcblxuICAgIC8qKiBEZWZpbmUgdGhlIHNpdGUgc3RvcmFnZSBzY2hlbWEuICovXG4gICAgdmFyIHNpdGVTY2hlbWEgPSB7XG4gICAgICAgICAgICBzdG9yZXM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIGRib3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGF1dG9TY2hlbWE6IHRydWVcbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgc3RvcmUgc2NoZW1hLlxuICAgICAqIElNUE9SVEFOVDogTW9kaWZ5aW5nIHRoZSBzY2hlbWEgb2YgYW4gYWxyZWFkeSBleGlzdGluZyBzdG9yZSBkZWxldGVzIGFsbCBpdHMgZGF0YSBpbiBXZWJTUUwgU3RvcmFnZS5cbiAgICAgKiBJZiBhIHN0b3JlIHNjaGVtYSBuZWVkcyB0byBiZSBtb2RpZmllZCwgdGhlIGRhdGEgc2hvdWxkIGJlIG1hbnVhbGx5IG1pZ3JhdGVkIHRvIHRoZSBuZXcgc3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0b3JlIFRoZSBzdG9yZSBvYmplY3QgZGVmaW5pdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHRoaXMucmVnaXN0ZXJTdG9yZSA9IGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgIGlmICh0eXBlb2Yoc3RvcmUubmFtZSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnJG1tU2l0ZTogRXJyb3I6IHN0b3JlIG5hbWUgaXMgdW5kZWZpbmVkLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHN0b3JlRXhpc3RzKHN0b3JlLm5hbWUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnJG1tU2l0ZTogRXJyb3I6IHN0b3JlICcgKyBzdG9yZS5uYW1lICsgJyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2l0ZVNjaGVtYS5zdG9yZXMucHVzaChzdG9yZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIG11bHRpcGxlIHN0b3JlcyBhdCBvbmNlLlxuICAgICAqIElNUE9SVEFOVDogTW9kaWZ5aW5nIHRoZSBzY2hlbWEgb2YgYW4gYWxyZWFkeSBleGlzdGluZyBzdG9yZSBkZWxldGVzIGFsbCBpdHMgZGF0YSBpbiBXZWJTUUwgU3RvcmFnZS5cbiAgICAgKiBJZiBhIHN0b3JlIHNjaGVtYSBuZWVkcyB0byBiZSBtb2RpZmllZCwgdGhlIGRhdGEgc2hvdWxkIGJlIG1hbnVhbGx5IG1pZ3JhdGVkIHRvIHRoZSBuZXcgc3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gc3RvcmVzIEFycmF5IG9mIHN0b3JlIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlZ2lzdGVyU3RvcmVzID0gZnVuY3Rpb24oc3RvcmVzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHN0b3JlcywgZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgICAgIHNlbGYucmVnaXN0ZXJTdG9yZShzdG9yZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHN0b3JlIGlzIGFscmVhZHkgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RvcmUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSB3aGVuIHRoZSBzdG9yZSB3YXMgYWxyZWFkeSBkZWZpbmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3JlRXhpc3RzKG5hbWUpIHtcbiAgICAgICAgdmFyIGV4aXN0cyA9IGZhbHNlO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goc2l0ZVNjaGVtYS5zdG9yZXMsIGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgIH1cblxuICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uKCRodHRwLCAkcSwgJG1tV1MsICRtbURCLCAkbG9nLCBtZDUsICRtbUFwcCwgJG1tTGFuZywgJG1tVXRpbCwgJG1tRlMsIG1tQ29yZVdTQ2FjaGVTdG9yZSxcbiAgICAgICAgICAgIG1tQ29yZVdTUHJlZml4LCBtbUNvcmVTZXNzaW9uRXhwaXJlZCwgJG1tRXZlbnRzLCBtbUNvcmVFdmVudFNlc3Npb25FeHBpcmVkLCBtbUNvcmVVc2VyRGVsZXRlZCwgbW1Db3JlRXZlbnRVc2VyRGVsZXRlZCxcbiAgICAgICAgICAgICRtbVRleHQsIG1tQ29yZUNvbmZpZ0NvbnN0YW50cykge1xuXG4gICAgICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1TaXRlJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgZGVwcmVjYXRlZCBXUyBmdW5jdGlvbnMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIE5PVCBkZXByZWNhdGVkIG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgYW4gZXF1aXZhbGVudCBzZXQgaXRzIHZhbHVlIHRvIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZGVwcmVjYXRlZEZ1bmN0aW9ucyA9IHtcbiAgICAgICAgICAgIFwiY29yZV9ncmFkZV9nZXRfZGVmaW5pdGlvbnNcIjogXCJjb3JlX2dyYWRpbmdfZ2V0X2RlZmluaXRpb25zXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9jb3Vyc2VfY3JlYXRlX2NvdXJzZXNcIjogXCJjb3JlX2NvdXJzZV9jcmVhdGVfY291cnNlc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfY291cnNlX2dldF9jb3Vyc2VzXCI6IFwiY29yZV9jb3Vyc2VfZ2V0X2NvdXJzZXNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX2Vucm9sX2dldF91c2Vyc19jb3Vyc2VzXCI6IFwiY29yZV9lbnJvbF9nZXRfdXNlcnNfY291cnNlc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfZmlsZV9nZXRfZmlsZXNcIjogXCJjb3JlX2ZpbGVzX2dldF9maWxlc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfZmlsZV91cGxvYWRcIjogXCJjb3JlX2ZpbGVzX3VwbG9hZFwiLFxuICAgICAgICAgICAgXCJtb29kbGVfZ3JvdXBfYWRkX2dyb3VwbWVtYmVyc1wiOiBcImNvcmVfZ3JvdXBfYWRkX2dyb3VwX21lbWJlcnNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX2dyb3VwX2NyZWF0ZV9ncm91cHNcIjogXCJjb3JlX2dyb3VwX2NyZWF0ZV9ncm91cHNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX2dyb3VwX2RlbGV0ZV9ncm91cG1lbWJlcnNcIjogXCJjb3JlX2dyb3VwX2RlbGV0ZV9ncm91cF9tZW1iZXJzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9ncm91cF9kZWxldGVfZ3JvdXBzXCI6IFwiY29yZV9ncm91cF9kZWxldGVfZ3JvdXBzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9ncm91cF9nZXRfY291cnNlX2dyb3Vwc1wiOiBcImNvcmVfZ3JvdXBfZ2V0X2NvdXJzZV9ncm91cHNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX2dyb3VwX2dldF9ncm91cG1lbWJlcnNcIjogXCJjb3JlX2dyb3VwX2dldF9ncm91cF9tZW1iZXJzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9ncm91cF9nZXRfZ3JvdXBzXCI6IFwiY29yZV9ncm91cF9nZXRfZ3JvdXBzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9tZXNzYWdlX3NlbmRfaW5zdGFudG1lc3NhZ2VzXCI6IFwiY29yZV9tZXNzYWdlX3NlbmRfaW5zdGFudF9tZXNzYWdlc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfbm90ZXNfY3JlYXRlX25vdGVzXCI6IFwiY29yZV9ub3Rlc19jcmVhdGVfbm90ZXNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX3JvbGVfYXNzaWduXCI6IFwiY29yZV9yb2xlX2Fzc2lnbl9yb2xlXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV9yb2xlX3VuYXNzaWduXCI6IFwiY29yZV9yb2xlX3VuYXNzaWduX3JvbGVcIixcbiAgICAgICAgICAgIFwibW9vZGxlX3VzZXJfY3JlYXRlX3VzZXJzXCI6IFwiY29yZV91c2VyX2NyZWF0ZV91c2Vyc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfdXNlcl9kZWxldGVfdXNlcnNcIjogXCJjb3JlX3VzZXJfZGVsZXRlX3VzZXJzXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV91c2VyX2dldF9jb3Vyc2VfcGFydGljaXBhbnRzX2J5X2lkXCI6IFwiY29yZV91c2VyX2dldF9jb3Vyc2VfdXNlcl9wcm9maWxlc1wiLFxuICAgICAgICAgICAgXCJtb29kbGVfdXNlcl9nZXRfdXNlcnNfYnlfY291cnNlaWRcIjogXCJjb3JlX2Vucm9sX2dldF9lbnJvbGxlZF91c2Vyc1wiLFxuICAgICAgICAgICAgLy8gQm90aCAqX3VzZXJfZ2V0X3VzZXJzX2J5X2lkIGFyZSBkZXByZWNhdGVkLCBidXQgdGhlcmUgaXMgbm8gZXF1aXZhbGVudCBhdmFpbGFibGUgaW4gdGhlIE1vYmlsZSBzZXJ2aWNlLlxuICAgICAgICAgICAgXCJtb29kbGVfdXNlcl9nZXRfdXNlcnNfYnlfaWRcIjogXCJjb3JlX3VzZXJfZ2V0X3VzZXJzX2J5X2lkXCIsXG4gICAgICAgICAgICBcIm1vb2RsZV91c2VyX3VwZGF0ZV91c2Vyc1wiOiBcImNvcmVfdXNlcl91cGRhdGVfdXNlcnNcIixcbiAgICAgICAgICAgIFwibW9vZGxlX3dlYnNlcnZpY2VfZ2V0X3NpdGVpbmZvXCI6IFwiY29yZV93ZWJzZXJ2aWNlX2dldF9zaXRlX2luZm9cIixcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXRlIG9iamVjdCB0byBzdG9yZSBzaXRlIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRldXJsIFNpdGUgVVJMLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gICBVc2VyJ3MgdG9rZW4gaW4gdGhlIHNpdGUuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvcyAgIFNpdGUncyBpbmZvLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gU2l0ZShpZCwgc2l0ZXVybCwgdG9rZW4sIGluZm9zKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnNpdGV1cmwgPSBzaXRldXJsO1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy5pbmZvcyA9IGluZm9zO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGIgPSAkbW1EQi5nZXREQignU2l0ZS0nICsgdGhpcy5pZCwgc2l0ZVNjaGVtYSwgZGJvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc2l0ZSBJRC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBDdXJyZW50IHNpdGUgSUQuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzaXRlIFVSTC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBDdXJyZW50IHNpdGUgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuZ2V0VVJMID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXRldXJsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc2l0ZSB0b2tlbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBDdXJyZW50IHNpdGUgdG9rZW4uXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzaXRlIGluZm8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBzaXRlIGluZm8uXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5nZXRJbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmZvcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHNpdGUgREIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBzaXRlIERCLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuZ2V0RGIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc2l0ZSB1c2VyJ3MgSUQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVXNlcidzIElELlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuZ2V0VXNlcklkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW5mb3MgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMuaW5mb3MudXNlcmlkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5mb3MudXNlcmlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgc2l0ZSBJRC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IE5ldyBJRC5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLnNldElkID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuZGIgPSAkbW1EQi5nZXREQignU2l0ZS0nICsgdGhpcy5pZCwgc2l0ZVNjaGVtYSwgZGJvcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHNpdGUgdG9rZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBOZXcgdG9rZW4uXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5zZXRUb2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBzaXRlIGluZm8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBOZXcgaW5mby5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLnNldEluZm8gPSBmdW5jdGlvbihpbmZvcykge1xuICAgICAgICAgICAgdGhpcy5pbmZvcyA9IGluZm9zO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW4gdGhlIHVzZXIgYWNjZXNzIHRoZWlyIHByaXZhdGUgZmlsZXM/XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IEZhbHNlIHdoZW4gdGhleSBjYW5ub3QuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5jYW5BY2Nlc3NNeUZpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5mb3MgPSB0aGlzLmdldEluZm8oKTtcbiAgICAgICAgICAgIHJldHVybiBpbmZvcyAmJiAodHlwZW9mIGluZm9zLnVzZXJjYW5tYW5hZ2Vvd25maWxlcyA9PT0gJ3VuZGVmaW5lZCcgfHwgaW5mb3MudXNlcmNhbm1hbmFnZW93bmZpbGVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIHRoZSB1c2VyIGRvd25sb2FkIGZpbGVzP1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBGYWxzZSB3aGVuIHRoZXkgY2Fubm90LlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuY2FuRG93bmxvYWRGaWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGluZm9zID0gdGhpcy5nZXRJbmZvKCk7XG4gICAgICAgICAgICByZXR1cm4gaW5mb3MgJiYgaW5mb3MuZG93bmxvYWRmaWxlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIHRoZSB1c2VyIHVzZSBhbiBhZHZhbmNlZCBmZWF0dXJlP1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmVhdHVyZSBUaGUgbmFtZSBvZiB0aGUgZmVhdHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbd2hlblVuZGVmaW5lZD10cnVlXSBUaGUgdmFsdWUgdG8gcmV0dXJuIHdoZW4gdGhlIHBhcmFtZXRlciBpcyB1bmRlZmluZWRcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gRmFsc2Ugd2hlbiB0aGV5IGNhbm5vdC5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmNhblVzZUFkdmFuY2VkRmVhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHdoZW5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbmZvcyA9IHRoaXMuZ2V0SW5mbygpLFxuICAgICAgICAgICAgICAgIGNhblVzZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHdoZW5VbmRlZmluZWQgPSAodHlwZW9mIHdoZW5VbmRlZmluZWQgPT09ICd1bmRlZmluZWQnKSA/IHRydWUgOiB3aGVuVW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZm9zLmFkdmFuY2VkZmVhdHVyZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY2FuVXNlID0gd2hlblVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaW5mb3MuYWR2YW5jZWRmZWF0dXJlcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5uYW1lID09PSBmZWF0dXJlICYmIHBhcnNlSW50KGl0ZW0udmFsdWUsIDEwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuVXNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FuVXNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW4gdGhlIHVzZXIgdXBsb2FkIGZpbGVzP1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBGYWxzZSB3aGVuIHRoZXkgY2Fubm90LlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuY2FuVXBsb2FkRmlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbmZvcyA9IHRoaXMuZ2V0SW5mbygpO1xuICAgICAgICAgICAgcmV0dXJuIGluZm9zICYmIGluZm9zLnVwbG9hZGZpbGVzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBzaXRlIGluZm8gZnJvbSB0aGUgTW9vZGxlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIGluZm8gaXMgcmV0cmlldmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuZmV0Y2hTaXRlSW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKSxcbiAgICAgICAgICAgICAgICBzaXRlID0gdGhpcztcblxuICAgICAgICAgICAgLy8gZ2V0X3NpdGVfaW5mbyB3b24ndCBiZSBjYWNoZWQuXG4gICAgICAgICAgICB2YXIgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBnZXRGcm9tQ2FjaGU6IDAsXG4gICAgICAgICAgICAgICAgc2F2ZVRvQ2FjaGU6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNpdGUucmVhZCgnY29yZV93ZWJzZXJ2aWNlX2dldF9zaXRlX2luZm8nLCB7fSwgcHJlU2V0cykudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIHNpdGUucmVhZCgnbW9vZGxlX3dlYnNlcnZpY2VfZ2V0X3NpdGVpbmZvJywge30sIHByZVNldHMpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZCBzb21lIGRhdGEgZnJvbSB0aGUgTW9vZGxlIHNpdGUgdXNpbmcgV1MuIFJlcXVlc3RzIGFyZSBjYWNoZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSByZWFkICBXUyBtZXRob2QgdG8gdXNlLlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgICAgRGF0YSB0byBzZW5kIHRvIHRoZSBXUy5cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBwcmVTZXRzIE9wdGlvbnM6IEBzZWUgU2l0ZSNyZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGZpbmlzaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG1ldGhvZCwgZGF0YSwgcHJlU2V0cykge1xuICAgICAgICAgICAgcHJlU2V0cyA9IHByZVNldHMgfHwge307XG4gICAgICAgICAgICBpZiAodHlwZW9mKHByZVNldHMuZ2V0RnJvbUNhY2hlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwcmVTZXRzLmdldEZyb21DYWNoZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mKHByZVNldHMuc2F2ZVRvQ2FjaGUpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByZVNldHMuc2F2ZVRvQ2FjaGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZihwcmVTZXRzLnN5bmMpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByZVNldHMuc3luYyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1ldGhvZCwgZGF0YSwgcHJlU2V0cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmRzIHNvbWUgZGF0YSB0byB0aGUgTW9vZGxlIHNpdGUgdXNpbmcgV1MuIFJlcXVlc3RzIGFyZSBOT1QgY2FjaGVkIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gbWV0aG9kICBXUyBtZXRob2QgdG8gdXNlLlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgICAgRGF0YSB0byBzZW5kIHRvIHRoZSBXUy5cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBwcmVTZXRzIE9wdGlvbnM6IEBzZWUgU2l0ZSNyZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGZpbmlzaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihtZXRob2QsIGRhdGEsIHByZVNldHMpIHtcbiAgICAgICAgICAgIHByZVNldHMgPSBwcmVTZXRzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZihwcmVTZXRzLmdldEZyb21DYWNoZSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcHJlU2V0cy5nZXRGcm9tQ2FjaGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZihwcmVTZXRzLnNhdmVUb0NhY2hlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwcmVTZXRzLnNhdmVUb0NhY2hlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YocHJlU2V0cy5zeW5jKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwcmVTZXRzLnN5bmMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXRob2QsIGRhdGEsIHByZVNldHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXUyByZXF1ZXN0IHRvIHRoZSBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSBXZWJTZXJ2aWNlIG1ldGhvZCB0byBiZSBjYWxsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVTZXRzIEV4dHJhIHNldHRpbmdzLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBnZXRGcm9tQ2FjaGUgYm9vbGVhbiAoZmFsc2UpIFVzZSB0aGUgY2FjaGUgd2hlbiBwb3NzaWJsZS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgIC0gc2F2ZVRvQ2FjaGUgYm9vbGVhbiAoZmFsc2UpIFNhdmUgdGhlIGNhbGwgcmVzdWx0cyB0byB0aGUgY2FjaGUuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAtIG9taXRFeHBpcmVzIGJvb2xlYW4gKGZhbHNlKSBJZ25vcmUgY2FjaGUgZXhwaXJ5LlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBlbWVyZ2VuY3lDYWNoZSBib29sZWFuICh0cnVlKSBJZiBwb3NzaWJsZSwgdXNlIHRoZSBjYWNoZSB3aGVuIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBzeW5jIGJvb2xlYW4gKGZhbHNlKSBBZGQgY2FsbCB0byBxdWV1ZSBpZiBkZXZpY2UgaXMgbm90IGNvbm5lY3RlZC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgIC0gY2FjaGVLZXkgKHN0cmluZykgRXh0cmEga2V5IHRvIGFkZCB0byB0aGUgY2FjaGUgd2hlbiBzdG9yaW5nIHRoaXMgY2FsbC4gVGhpcyBrZXkgaXMgdG9cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyB0aGUgY2FjaGUgZW50cnksIGl0IGRvZXNuJ3QgYWZmZWN0IHRoZSBkYXRhIHJldHJpZXZlZCBpbiB0aGlzIGNhbGwuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAtIGdldENhY2hlVXNpbmdDYWNoZUtleSAoYm9vbGVhbikgVHJ1ZSBpZiBpdCBzaG91bGQgcmV0cmlldmUgY2FjaGVkIGRhdGEgYnkgY2FjaGVLZXksXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIGlmIGl0IHNob3VsZCBnZXQgdGhlIGRhdGEgYmFzZWQgb24gdGhlIHBhcmFtcyBwYXNzZWQgKHVzdWFsIGJlaGF2aW9yKS5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlbmRzIGEgd2Vic2VydmljZSByZXF1ZXN0IHRvIHRoZSBzaXRlLiBUaGlzIG1ldGhvZCB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkIHRoZVxuICAgICAgICAgKiByZXF1aXJlZCBwYXJhbWV0ZXJzIGFuZCBwYXNzIGl0IG9uIHRvIHRoZSBsb3cgbGV2ZWwgQVBJIGluICRtbVdTLmNhbGwoKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2FjaGluZyBpcyBhbHNvIGltcGxlbWVudGVkLCB3aGVuIGVuYWJsZWQgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5lZCBhIGNhY2hlZFxuICAgICAgICAgKiB2ZXJzaW9uIG9mIGl0c2VsZiByYXRoZXIgdGhhbiBjb250YWN0aW5nIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHNtYXJ0IHdoaWNoIG1lYW5zIHRoYXQgaXQgd2lsbCB0cnkgdG8gbWFwIHRoZSBtZXRob2QgdG8gYVxuICAgICAgICAgKiBjb21wYXRpYmlsaXR5IG9uZSBpZiBuZWVkIGJlLCB1c3VhbGx5IHRoYXQgbWVhbnMgdGhhdCBpdCB3aWxsIGZhbGxiYWNrIG9uXG4gICAgICAgICAqIHRoZSAnbG9jYWxfbW9iaWxlXycgcHJlZml4ZWQgZnVuY3Rpb24gaWYgaXQgaXMgYXZhaWxhYmxlIGFuZCB0aGUgbm9uLXByZWZpeGVkIGlzIG5vdC5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIGRhdGEsIHByZVNldHMpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICAgICAgc2l0ZSA9IHRoaXM7XG4gICAgICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBtZXRob2QgdG8gdXNlIGJhc2VkIG9uIHRoZSBhdmFpbGFibGUgb25lcy5cbiAgICAgICAgICAgIG1ldGhvZCA9IHNpdGUuZ2V0Q29tcGF0aWJsZUZ1bmN0aW9uKG1ldGhvZCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBtZXRob2QgaXMgYXZhaWxhYmxlLCB1c2UgYSBwcmVmaXhlZCB2ZXJzaW9uIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgLy8gV2UgaWdub3JlIHRoaXMgY2hlY2sgd2hlbiB3ZSBkbyBub3QgaGF2ZSB0aGUgc2l0ZSBpbmZvLCBhcyB0aGUgbGlzdCBvZiBmdW5jdGlvbnMgaXMgbm90IGxvYWRlZCB5ZXQuXG4gICAgICAgICAgICBpZiAoc2l0ZS5nZXRJbmZvKCkgJiYgIXNpdGUud3NBdmFpbGFibGUobWV0aG9kLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2l0ZS53c0F2YWlsYWJsZShtbUNvcmVXU1ByZWZpeCArIG1ldGhvZCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuaW5mbyhcIlVzaW5nIGNvbXBhdGliaWxpdHkgV1MgbWV0aG9kICdcIiArIG1tQ29yZVdTUHJlZml4ICsgbWV0aG9kICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBtbUNvcmVXU1ByZWZpeCArIG1ldGhvZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKFwiV1MgZnVuY3Rpb24gJ1wiICsgbWV0aG9kICsgXCInIGlzIG5vdCBhdmFpbGFibGUsIGV2ZW4gaW4gY29tcGF0aWJpbGl0eSBtb2RlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgJ21tLmNvcmUud3NmdW5jdGlvbm5vdGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZVNldHMgPSBhbmd1bGFyLmNvcHkocHJlU2V0cykgfHwge307XG4gICAgICAgICAgICBwcmVTZXRzLndzdG9rZW4gPSBzaXRlLnRva2VuO1xuICAgICAgICAgICAgcHJlU2V0cy5zaXRldXJsID0gc2l0ZS5zaXRldXJsO1xuXG4gICAgICAgICAgICAvLyBFbmFibGUgdGV4dCBmaWx0ZXJpbmcuXG4gICAgICAgICAgICBkYXRhLm1vb2RsZXdzc2V0dGluZ2ZpbHRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGdldEZyb21DYWNoZShzaXRlLCBtZXRob2QsIGRhdGEsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgcGFzcyB0aG9zZSBvcHRpb25zIHRvIHRoZSBjb3JlIFdTIGZhY3RvcnkuXG4gICAgICAgICAgICAgICAgdmFyIHdzUHJlU2V0cyA9IGFuZ3VsYXIuY29weShwcmVTZXRzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgd3NQcmVTZXRzLmdldEZyb21DYWNoZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgd3NQcmVTZXRzLnNhdmVUb0NhY2hlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3c1ByZVNldHMub21pdEV4cGlyZXM7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHdzUHJlU2V0cy5jYWNoZUtleTtcbiAgICAgICAgICAgICAgICBkZWxldGUgd3NQcmVTZXRzLmVtZXJnZW5jeUNhY2hlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3c1ByZVNldHMuZ2V0Q2FjaGVVc2luZ0NhY2hlS2V5O1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogU3luY1xuXG4gICAgICAgICAgICAgICAgJG1tV1MuY2FsbChtZXRob2QsIGRhdGEsIHdzUHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVTZXRzLnNhdmVUb0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlVG9DYWNoZShzaXRlLCBtZXRob2QsIGRhdGEsIHJlc3BvbnNlLCBwcmVTZXRzLmNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHBhc3MgYmFjayBhIGNsb25lIG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHRoaXMgbWF5XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZXJyb3JzIGlmIGluIHRoZSBjYWxsYmFjayB0aGUgb2JqZWN0IGlzIG1vZGlmaWVkLlxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGFuZ3VsYXIuY29weShyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA9PT0gbW1Db3JlU2Vzc2lvbkV4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlc3Npb24gZXhwaXJlZCwgdHJpZ2dlciBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsICdtbS5jb3JlLmxvc3Rjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbUNvcmVFdmVudFNlc3Npb25FeHBpcmVkLCBzaXRlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvciA9PT0gbW1Db3JlVXNlckRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgZGVsZXRlZCwgdHJpZ2dlciBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsICdtbS5jb3JlLnVzZXJkZWxldGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbUNvcmVFdmVudFVzZXJEZWxldGVkLCB7c2l0ZWlkOiBzaXRlLmlkLCBwYXJhbXM6IGRhdGF9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJlU2V0cy5lbWVyZ2VuY3lDYWNoZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIXByZVNldHMuZW1lcmdlbmN5Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1dTIGNhbGwgJyArIG1ldGhvZCArICcgZmFpbGVkLiBFbWVyZ2VuY3kgY2FjaGUgaXMgZm9yYmlkZGVuLCByZWplY3RpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnV1MgY2FsbCAnICsgbWV0aG9kICsgJyBmYWlsZWQuIFRyeWluZyB0byB1c2UgdGhlIGVtZXJnZW5jeSBjYWNoZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVNldHMub21pdEV4cGlyZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlU2V0cy5nZXRGcm9tQ2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RnJvbUNhY2hlKHNpdGUsIG1ldGhvZCwgZGF0YSwgcHJlU2V0cykudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBhIFdTIGlzIGF2YWlsYWJsZSBpbiB0aGlzIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gbWV0aG9kIFdTIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSAge0Jvb2xlYW49dHJ1ZX0gY2hlY2tQcmVmaXggV2hlbiB0cnVlIGFsc28gY2hlY2tzIHdpdGggdGhlIGNvbXBhdGliaWxpdHkgcHJlZml4LlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICBUcnVlIGlmIHRoZSBXUyBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBhIHdlYiBzZXJ2aWNlIGZ1bmN0aW9uIGlzIGF2YWlsYWJsZS4gQnkgZGVmYXVsdCBpdCB3aWxsXG4gICAgICAgICAqIGFsc28gY2hlY2sgaWYgdGhlcmUgaXMgYSBjb21wYXRpYmlsaXR5IGZ1bmN0aW9uIGZvciBpdCwgZS5nLiBhIHByZWZpeGVkIG9uZS5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLndzQXZhaWxhYmxlID0gZnVuY3Rpb24obWV0aG9kLCBjaGVja1ByZWZpeCkge1xuICAgICAgICAgICAgY2hlY2tQcmVmaXggPSAodHlwZW9mIGNoZWNrUHJlZml4ID09PSAndW5kZWZpbmVkJykgPyB0cnVlIDogY2hlY2tQcmVmaXg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbmZvcyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZm9zLmZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmID0gdGhpcy5pbmZvcy5mdW5jdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGYubmFtZSA9PSBtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMZXQncyB0cnkgYWdhaW4gd2l0aCB0aGUgY29tcGF0aWJpbGl0eSBwcmVmaXguXG4gICAgICAgICAgICBpZiAoY2hlY2tQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53c0F2YWlsYWJsZShtbUNvcmVXU1ByZWZpeCArIG1ldGhvZCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgICogVXBsb2FkcyBhIGZpbGUgdXNpbmcgQ29yZG92YSBGaWxlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVyaSBGaWxlIFVSSS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgRmlsZSBzZXR0aW5nczogZmlsZUtleSwgZmlsZU5hbWUgYW5kIG1pbWVUeXBlLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUudXBsb2FkRmlsZSA9IGZ1bmN0aW9uKHVyaSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuICRtbVdTLnVwbG9hZEZpbGUodXJpLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgc2l0ZXVybDogdGhpcy5zaXRldXJsLFxuICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLnRva2VuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW52YWxpZGF0ZXMgYWxsIHRoZSBjYWNoZSBlbnRyaWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNhY2hlIGVudHJpZXMgYXJlIGludmFsaWRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuaW52YWxpZGF0ZVdzQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkYiA9IHRoaXMuZGI7XG4gICAgICAgICAgICBpZiAoIWRiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdJbnZhbGlkYXRlIGFsbCB0aGUgY2FjaGUgZm9yIHNpdGU6ICcrIHRoaXMuaWQpO1xuICAgICAgICAgICAgcmV0dXJuIGRiLmdldEFsbChtbUNvcmVXU0NhY2hlU3RvcmUpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW52YWxpZGF0ZVdzQ2FjaGVFbnRyaWVzKGRiLCBlbnRyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW52YWxpZGF0ZXMgYWxsIHRoZSBjYWNoZSBlbnRyaWVzIHdpdGggYSBjZXJ0YWluIGtleS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBrZXkgS2V5IHRvIHNlYXJjaC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjYWNoZSBlbnRyaWVzIGFyZSBpbnZhbGlkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgZGIgPSB0aGlzLmRiO1xuICAgICAgICAgICAgaWYgKCFkYiB8fCAha2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdJbnZhbGlkYXRlIGNhY2hlIGZvciBrZXk6ICcra2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkYi53aGVyZUVxdWFsKG1tQ29yZVdTQ2FjaGVTdG9yZSwgJ2tleScsIGtleSkudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMgJiYgZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkYXRlV3NDYWNoZUVudHJpZXMoZGIsIGVudHJpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZhbGlkYXRlcyBhbGwgdGhlIGNhY2hlIGVudHJpZXMgd2hvc2Uga2V5IHN0YXJ0cyB3aXRoIGEgY2VydGFpbiB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBrZXkgS2V5IHRvIHNlYXJjaC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjYWNoZSBlbnRyaWVzIGFyZSBpbnZhbGlkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5U3RhcnRpbmdXaXRoID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgZGIgPSB0aGlzLmRiO1xuICAgICAgICAgICAgaWYgKCFkYiB8fCAha2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdJbnZhbGlkYXRlIGNhY2hlIGZvciBrZXkgc3RhcnRpbmcgd2l0aDogJytrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGRiLndoZXJlKG1tQ29yZVdTQ2FjaGVTdG9yZSwgJ2tleScsICdeJywga2V5KS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcyAmJiBlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludmFsaWRhdGVXc0NhY2hlRW50cmllcyhkYiwgZW50cmllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyaWMgZnVuY3Rpb24gZm9yIGFkZGluZyB0aGUgd3N0b2tlbiB0byBNb29kbGUgdXJscyBhbmQgZm9yIHBvaW50aW5nIHRvIHRoZSBjb3JyZWN0IHNjcmlwdC5cbiAgICAgICAgICogVXNlcyAkbW1VdGlsLmZpeFBsdWdpbmZpbGVVUkwsIHBhc3Npbmcgc2l0ZSdzIHRva2VuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgVGhlIHVybCB0byBiZSBmaXhlZC5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgIEZpeGVkIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmZpeFBsdWdpbmZpbGVVUkwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1VdGlsLmZpeFBsdWdpbmZpbGVVUkwodXJsLCB0aGlzLnRva2VuKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGVzIHNpdGUncyBEQi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBEQiBpcyBkZWxldGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuZGVsZXRlREIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1EQi5kZWxldGVEQignU2l0ZS0nICsgdGhpcy5pZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZXMgc2l0ZSdzIGZvbGRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBEQiBpcyBkZWxldGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuZGVsZXRlRm9sZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzaXRlRm9sZGVyID0gJG1tRlMuZ2V0U2l0ZUZvbGRlcih0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRlMucmVtb3ZlRGlyKHNpdGVGb2xkZXIpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW55IGVycm9ycywgJG1tRlMucmVtb3ZlRGlyIGZhaWxzIGlmIGZvbGRlciBkb2Vzbid0IGV4aXN0cy5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHNwYWNlIHVzYWdlIG9mIHRoZSBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHNpdGUgc3BhY2UgdXNhZ2UgKHNpemUpLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuZ2V0U3BhY2VVc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l0ZUZvbGRlclBhdGggPSAkbW1GUy5nZXRTaXRlRm9sZGVyKHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GUy5nZXREaXJlY3RvcnlTaXplKHNpdGVGb2xkZXJQYXRoKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBVUkwgdG8gdGhlIGRvY3VtZW50YXRpb24gb2YgdGhlIGFwcCwgYmFzZWQgb24gTW9vZGxlIHZlcnNpb24gYW5kIGN1cnJlbnQgbGFuZ3VhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFnZV0gICAgRG9jcyBwYWdlIHRvIGdvIHRvLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgTW9vZGxlIGRvY3MgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuZ2V0RG9jc1VybCA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgICAgICAgICAgIHZhciByZWxlYXNlID0gdGhpcy5pbmZvcy5yZWxlYXNlID8gdGhpcy5pbmZvcy5yZWxlYXNlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuICRtbVV0aWwuZ2V0RG9jc1VybChyZWxlYXNlLCBwYWdlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgdGhlIGxvY2FsX21vYmlsZSBwbHVnaW4gaXMgaW5zdGFsbGVkIGluIHRoZSBNb29kbGUgc2l0ZS5cbiAgICAgICAgICogVGhpcyBwbHVnaW4gcHJvdmlkZSBleHRlbmRlZCBzZXJ2aWNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSByZXRyeWluZyBUcnVlIGlmIHdlJ3JlIHJldHJ5aW5nIHRoZSBjaGVjay5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNoZWNrIGlzIGRvbmUuIFJlc29sdmUgcGFyYW1zOlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7TnVtYmVyfSBjb2RlIENvZGUgdG8gaWRlbnRpZnkgdGhlIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCB0byB1c2UuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IFtzZXJ2aWNlXSBJZiBkZWZpbmVkLCBuYW1lIG9mIHRoZSBzZXJ2aWNlIHRvIHVzZS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gW3dhcm5pbmddIElmIGRlZmluZWQsIGNvZGUgb2YgdGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmNoZWNrTG9jYWxNb2JpbGVQbHVnaW4gPSBmdW5jdGlvbihyZXRyeWluZykge1xuICAgICAgICAgICAgdmFyIHNpdGV1cmwgPSB0aGlzLnNpdGV1cmwsXG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgc2VydmljZSA9IG1tQ29yZUNvbmZpZ0NvbnN0YW50cy53c2V4dHNlcnZpY2U7XG5cbiAgICAgICAgICAgIGlmICghc2VydmljZSkge1xuICAgICAgICAgICAgICAgIC8vIEV4dGVybmFsIHNlcnZpY2Ugbm90IGRlZmluZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oe2NvZGU6IDB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICRodHRwLnBvc3Qoc2l0ZXVybCArICcvbG9jYWwvbW9iaWxlL2NoZWNrLnBocCcsIHtzZXJ2aWNlOiBzZXJ2aWNlfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcmVzcG9uc2UuZGF0YTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPSAndW5kZWZpbmVkJyAmJiBkYXRhLmVycm9yY29kZSA9PT0gJ3JlcXVpcmVjb3JyZWN0YWNjZXNzJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJldHJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNpdGV1cmwgPSAkbW1UZXh0LmFkZE9yUmVtb3ZlV1dXKHNpdGV1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2hlY2tMb2NhbE1vYmlsZVBsdWdpbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZGF0YS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09ICd1bmRlZmluZWQnIHx8wqB0eXBlb2YgZGF0YS5jb2RlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvY2FsX21vYmlsZSByZXR1cm5lZCBzb21ldGhpbmcgd2UgZGlkbid0IGV4cGVjdC4gTGV0J3MgYXNzdW1lIGl0J3Mgbm90IGluc3RhbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2RlOiAwLCB3YXJuaW5nOiAnbW0ubG9naW4ubG9jYWxtb2JpbGV1bmV4cGVjdGVkcmVzcG9uc2UnfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHBhcnNlSW50KGRhdGEuY29kZSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpdGUgaW4gbWFpbnRlbmFuY2UgbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmxvZ2luLnNpdGVpbm1haW50ZW5hbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2ViIHNlcnZpY2VzIG5vdCBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0ubG9naW4ud2Vic2VydmljZXNub3RlbmFibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kZWQgc2VydmljZSBub3QgZW5hYmxlZCwgYnV0IHRoZSBvZmZpY2lhbCBpcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29kZTogMH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVpdGhlciBleHRlbmRlZCBvciBvZmZpY2lhbCBzZXJ2aWNlcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0ubG9naW4ubW9iaWxlc2VydmljZXNub3RlbmFibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0uY29yZS51bmV4cGVjdGVkZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29kZTogY29kZSwgc2VydmljZTogc2VydmljZX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtjb2RlOiAwfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBsb2NhbF9tb2JpbGUgaGFzIGJlZW4gaW5zdGFsbGVkIGluIE1vb2RsZSBidXQgdGhlIGFwcCBpcyBub3QgdXNpbmcgaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgaXQgbG9jYWxfbW9iaWxlIHdhcyBhZGRlZCwgcmVqZWN0ZWQgb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgU2l0ZS5wcm90b3R5cGUuY2hlY2tJZkxvY2FsTW9iaWxlSW5zdGFsbGVkQW5kTm90VXNlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFwcFVzZXNMb2NhbE1vYmlsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHRoaXMuaW5mb3MuZnVuY3Rpb25zLCBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMubmFtZS5pbmRleE9mKG1tQ29yZVdTUHJlZml4KSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBVc2VzTG9jYWxNb2JpbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoYXBwVXNlc0xvY2FsTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwIGFscmVhZHkgdXNlcyBsb2NhbF9tb2JpbGUsIGl0IHdhc24ndCBhZGRlZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrTG9jYWxNb2JpbGVQbHVnaW4oKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuc2VydmljZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBsb2NhbF9tb2JpbGUgTk9UIGluc3RhbGxlZC4gUmVqZWN0LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGEgVVJMIGJlbG9uZ3MgdG8gdGhpcyBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB1cmwgVVJMIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSBpZiBVUkwgYmVsb25ncyB0byB0aGlzIHNpdGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIFNpdGUucHJvdG90eXBlLmNvbnRhaW5zVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaXRldXJsID0gJG1tVGV4dC5yZW1vdmVQcm90b2NvbEFuZFdXVyh0aGlzLnNpdGV1cmwpO1xuICAgICAgICAgICAgdXJsID0gJG1tVGV4dC5yZW1vdmVQcm90b2NvbEFuZFdXVyh1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIHVybC5pbmRleE9mKHNpdGV1cmwpID09IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludmFsaWRhdGUgZW50cmllcyBmcm9tIHRoZSBjYWNoZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBkYiAgICAgIERCIHRoZSBlbnRyaWVzIGJlbG9uZyB0by5cbiAgICAgICAgICogQHBhcmFtICB7QXJyYXl9ICBlbnRyaWVzIEVudHJpZXMgdG8gaW52YWxpZGF0ZS5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY2FjaGUgZW50cmllcyBhcmUgaW52YWxpZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpbnZhbGlkYXRlV3NDYWNoZUVudHJpZXMoZGIsIGVudHJpZXMpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgZW50cnkuZXhwaXJhdGlvbnRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZGIuaW5zZXJ0KG1tQ29yZVdTQ2FjaGVTdG9yZSwgZW50cnkpO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgZnVuY3Rpb24gdG8gYmUgdXNlZCwgYmFzZWQgb24gdGhlIGF2YWlsYWJsZSBmdW5jdGlvbnMgaW4gdGhlIHNpdGUuIEl0J2xsIHRyeSB0byB1c2Ugbm9uLWRlcHJlY2F0ZWRcbiAgICAgICAgICogZnVuY3Rpb25zIGZpcnN0LCBhbmQgZmFsbGJhY2sgdG8gZGVwcmVjYXRlZCBvbmVzIGlmIG5lZWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBtZXRob2QgV1MgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIE1ldGhvZCB0byB1c2UgYmFzZWQgaW4gdGhlIGF2YWlsYWJsZSBmdW5jdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBTaXRlLnByb3RvdHlwZS5nZXRDb21wYXRpYmxlRnVuY3Rpb24gPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVwcmVjYXRlZEZ1bmN0aW9uc1ttZXRob2RdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVwcmVjYXRlZCBmdW5jdGlvbiBpcyBiZWluZyB1c2VkLiBXYXJuIHRoZSBkZXZlbG9wZXIuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud3NBdmFpbGFibGUoZGVwcmVjYXRlZEZ1bmN0aW9uc1ttZXRob2RdKSkge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLndhcm4oXCJZb3UgYXJlIHVzaW5nIGRlcHJlY2F0ZWQgV2ViIFNlcnZpY2VzOiBcIiArIG1ldGhvZCArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiB5b3UgbXVzdCByZXBsYWNlIGl0IHdpdGggdGhlIG5ld2VyIGZ1bmN0aW9uOiBcIiArIGRlcHJlY2F0ZWRGdW5jdGlvbnNbbWV0aG9kXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXByZWNhdGVkRnVuY3Rpb25zW21ldGhvZF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy53YXJuKFwiWW91IGFyZSB1c2luZyBkZXByZWNhdGVkIFdlYiBTZXJ2aWNlcy4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJZb3VyIHJlbW90ZSBzaXRlIHNlZW1zIHRvIGJlIG91dGRhdGVkLCBjb25zaWRlciB1cGdyYWRlIGl0IHRvIHRoZSBsYXRlc3QgTW9vZGxlIHZlcnNpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMud3NBdmFpbGFibGUobWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIC8vIE1ldGhvZCBub3QgYXZhaWxhYmxlLiBDaGVjayBpZiB0aGVyZSBpcyBhIGRlcHJlY2F0ZWQgbWV0aG9kIHRvIHVzZS5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBvbGRGdW5jIGluIGRlcHJlY2F0ZWRGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHJlY2F0ZWRGdW5jdGlvbnNbb2xkRnVuY10gPT09IG1ldGhvZCAmJiB0aGlzLndzQXZhaWxhYmxlKG9sZEZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9nLndhcm4oXCJZb3VyIHJlbW90ZSBzaXRlIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZnVuY3Rpb24gXCIgKyBtZXRob2QgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLCBpdCBzZWVtcyB0byBiZSBvdXRkYXRlZCwgY29uc2lkZXIgdXBncmFkZSBpdCB0byB0aGUgbGF0ZXN0IE1vb2RsZSB2ZXJzaW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRGdW5jOyAvLyBVc2UgZGVwcmVjYXRlZCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIFdTIHJlc3BvbnNlIGZyb20gY2FjaGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaXRlICAgIFNpdGUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgIFRoZSBXZWJTZXJ2aWNlIG1ldGhvZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByZVNldHMgRXh0cmEgc2V0dGluZ3MuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2l0aCB0aGUgV1MgcmVzcG9uc2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRGcm9tQ2FjaGUoc2l0ZSwgbWV0aG9kLCBkYXRhLCBwcmVTZXRzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgICAgIGRiID0gc2l0ZS5kYixcbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICAgICAgaWYgKCFkYikge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcHJlU2V0cy5nZXRGcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWQgPSBtZDUuY3JlYXRlSGFzaChtZXRob2QgKyAnOicgKyBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG5cbiAgICAgICAgICAgIGlmIChwcmVTZXRzLmdldENhY2hlVXNpbmdDYWNoZUtleSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSBkYi53aGVyZUVxdWFsKG1tQ29yZVdTQ2FjaGVTdG9yZSwgJ2tleScsIHByZVNldHMuY2FjaGVLZXkpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUga2V5IG5vdCBmb3VuZCwgZ2V0IGJ5IHBhcmFtcyBzZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLmdldChtbUNvcmVXU0NhY2hlU3RvcmUsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cmllc1swXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IGRiLmdldChtbUNvcmVXU0NhY2hlU3RvcmUsIGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgcHJlU2V0cy5vbWl0RXhwaXJlcyA9IHByZVNldHMub21pdEV4cGlyZXMgfHwgISRtbUFwcC5pc09ubGluZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcmVTZXRzLm9taXRFeHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3cgPiBlbnRyeS5leHBpcmF0aW9udGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ2FjaGVkIGVsZW1lbnQgZm91bmQsIGJ1dCBpdCBpcyBleHBpcmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGVudHJ5LmRhdGEgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGlyZXMgPSAoZW50cnkuZXhwaXJhdGlvbnRpbWUgLSBub3cpIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5pbmZvKCdDYWNoZWQgZWxlbWVudCBmb3VuZCwgaWQ6ICcgKyBpZCArICcgZXhwaXJlcyBpbiAnICsgZXhwaXJlcyArICcgc2Vjb25kcycpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGVudHJ5LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYXZlIGEgV1MgcmVzcG9uc2UgdG8gY2FjaGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaXRlICAgIFNpdGUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgICBUaGUgV2ViU2VydmljZSBtZXRob2QuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlU2V0cyAgRXh0cmEgc2V0dGluZ3MuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYWNoZUtleSAoT3B0aW9uYWwpIEV4dHJhIGtleSB0byBhZGQgdG8gdGhlIGNhY2hlIG9iamVjdCB0byBpZGVudGlmeSBzaW1pbGFyIGNhbGxzLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSByZXNwb25zZSBpcyBzYXZlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNhdmVUb0NhY2hlKHNpdGUsIG1ldGhvZCwgZGF0YSwgcmVzcG9uc2UsIGNhY2hlS2V5KSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBzaXRlLmRiLFxuICAgICAgICAgICAgICAgIGlkID0gbWQ1LmNyZWF0ZUhhc2gobWV0aG9kICsgJzonICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkpLFxuICAgICAgICAgICAgICAgIGNhY2hlRXhwaXJhdGlvblRpbWUgPSBtbUNvcmVDb25maWdDb25zdGFudHMuY2FjaGVfZXhwaXJhdGlvbl90aW1lLFxuICAgICAgICAgICAgICAgIGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFkYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FjaGVFeHBpcmF0aW9uVGltZSA9IGlzTmFOKGNhY2hlRXhwaXJhdGlvblRpbWUpID8gMzAwMDAwIDogY2FjaGVFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgICBlbnRyeS5leHBpcmF0aW9udGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgY2FjaGVFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkua2V5ID0gY2FjaGVLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQobW1Db3JlV1NDYWNoZVN0b3JlLCBlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZSBhIHNpdGUgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1TaXRlc0ZhY3RvcnkjbWFrZVNpdGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlkICAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGV1cmwgU2l0ZSBVUkwuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiAgIFVzZXIncyB0b2tlbiBpbiB0aGUgc2l0ZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGluZm9zICAgU2l0ZSdzIGluZm8uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGN1cnJlbnQgc2l0ZSBvYmplY3QuXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGlzIHJldHVybnMgYSBzaXRlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYubWFrZVNpdGUgPSBmdW5jdGlvbihpZCwgc2l0ZXVybCwgdG9rZW4sIGluZm9zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpdGUoaWQsIHNpdGV1cmwsIHRva2VuLCBpbmZvcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGxpc3Qgb2YgU2l0ZSBtZXRob2RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1TaXRlc0ZhY3RvcnkjZ2V0U2l0ZU1ldGhvZHNcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IExpc3Qgb2YgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0U2l0ZU1ldGhvZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2RzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIFNpdGUucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLmNvbnN0YW50KCdtbUNvcmVTaXRlc1N0b3JlJywgJ3NpdGVzJylcbi5jb25zdGFudCgnbW1Db3JlQ3VycmVudFNpdGVTdG9yZScsICdjdXJyZW50X3NpdGUnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUFwcFByb3ZpZGVyLCBtbUNvcmVTaXRlc1N0b3JlLCBtbUNvcmVDdXJyZW50U2l0ZVN0b3JlKSB7XG4gICAgdmFyIHN0b3JlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogbW1Db3JlU2l0ZXNTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogbW1Db3JlQ3VycmVudFNpdGVTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCdcbiAgICAgICAgfVxuICAgIF07XG4gICAgJG1tQXBwUHJvdmlkZXIucmVnaXN0ZXJTdG9yZXMoc3RvcmVzKTtcbn0pXG5cbi8qKlxuICogU2l0ZXMgbWFuYWdlciBzZXJ2aWNlLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbVNpdGVzTWFuYWdlclxuICovXG4uZmFjdG9yeSgnJG1tU2l0ZXNNYW5hZ2VyJywgZnVuY3Rpb24oJGh0dHAsICRxLCAkbW1TaXRlc0ZhY3RvcnksIG1kNSwgJG1tTGFuZywgJG1tQXBwLCAkbW1VdGlsLCAkbW1FdmVudHMsICRzdGF0ZSxcbiAgICAgICAgICAgICR0cmFuc2xhdGUsIG1tQ29yZVNpdGVzU3RvcmUsIG1tQ29yZUN1cnJlbnRTaXRlU3RvcmUsIG1tQ29yZUV2ZW50TG9naW4sIG1tQ29yZUV2ZW50TG9nb3V0LCAkbG9nLCBtbUNvcmVXU1ByZWZpeCxcbiAgICAgICAgICAgIG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsIG1tQ29yZUV2ZW50U2l0ZUFkZGVkLCBtbUNvcmVFdmVudFNlc3Npb25FeHBpcmVkLCBtbUNvcmVFdmVudFNpdGVEZWxldGVkLCAkbW1UZXh0LFxuICAgICAgICAgICAgbW1Db3JlQ29uZmlnQ29uc3RhbnRzKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tU2l0ZXNNYW5hZ2VyJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBzZXJ2aWNlcyA9IHt9LFxuICAgICAgICBzZXNzaW9uUmVzdG9yZWQgPSBmYWxzZSxcbiAgICAgICAgY3VycmVudFNpdGUsXG4gICAgICAgIHNpdGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlbW8gZGF0YSBvZiB0aGUgc2l0ZXVybCBpZiBpdCBpcyBhIGRlbW8gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjZ2V0RGVtb1NpdGVEYXRhXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRldXJsIFVSTCBvZiB0aGUgc2l0ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgU2l0ZSBkYXRhIGlmIGl0J3MgYSBkZW1vIHNpdGUsIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5nZXREZW1vU2l0ZURhdGEgPSBmdW5jdGlvbihzaXRldXJsKSB7XG4gICAgICAgIHZhciBkZW1vU2l0ZXMgPSBtbUNvcmVDb25maWdDb25zdGFudHMuZGVtb19zaXRlcztcbiAgICAgICAgaWYgKHR5cGVvZiBkZW1vU2l0ZXMgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlbW9TaXRlc1tzaXRldXJsXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGRlbW9TaXRlc1tzaXRldXJsXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHNpdGUgaXMgdmFsaWQgYW5kIGlmIGl0IGhhcyBzcGVjaWZpY3Mgc2V0dGluZ3MgZm9yIGF1dGhlbnRpY2F0aW9uXG4gICAgICogKGxpa2UgZm9yY2UgdG8gbG9nIGluIHVzaW5nIHRoZSBicm93c2VyKS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjY2hlY2tTaXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGV1cmwgIFVSTCBvZiB0aGUgc2l0ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgdG8gdXNlLiBJZiBub3QgZGVmaW5lZCwgdXNlIGh0dHBzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBBIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgc2l0ZSBpcyBjaGVja2VkLiBSZXNvbHZlIHBhcmFtczpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBjb2RlICAgICAgQ29kZSB0byBpZGVudGlmeSB0aGUgYXV0aGVudGljYXRpb24gbWV0aG9kIHRvIHVzZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBzaXRldXJsICAgU2l0ZSB1cmwgdG8gdXNlIChtaWdodCBoYXZlIGNoYW5nZWQgZHVyaW5nIHRoZSBwcm9jZXNzKS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbd2FybmluZ10gQ29kZSBvZiB0aGUgd2FybmluZyBtZXNzYWdlIHRvIHNob3cgdG8gdGhlIHVzZXIuXG4gICAgICovXG4gICAgc2VsZi5jaGVja1NpdGUgPSBmdW5jdGlvbihzaXRldXJsLCBwcm90b2NvbCkge1xuXG4gICAgICAgIC8vIGZvcm1hdFVSTCBhZGRzIHRoZSBwcm90b2NvbCBpZiBpcyBtaXNzaW5nLlxuICAgICAgICBzaXRldXJsID0gJG1tVXRpbC5mb3JtYXRVUkwoc2l0ZXVybCk7XG5cbiAgICAgICAgaWYgKHNpdGV1cmwuaW5kZXhPZignOi8vbG9jYWxob3N0JykgPT0gLTEgJiYgISRtbVV0aWwuaXNWYWxpZFVSTChzaXRldXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5sb2dpbi5pbnZhbGlkc2l0ZScpO1xuICAgICAgICB9IGVsc2UgaWYgKCEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5jb3JlLm5ldHdvcmtlcnJvcm1zZycpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBwcm90b2NvbCA9IHByb3RvY29sIHx8IFwiaHR0cHM6Ly9cIjtcblxuICAgICAgICAgICAgLy8gTm93LCByZXBsYWNlIHRoZSBzaXRldXJsIHdpdGggdGhlIHByb3RvY29sLlxuICAgICAgICAgICAgc2l0ZXVybCA9IHNpdGV1cmwucmVwbGFjZSgvXmh0dHAocyk/XFw6XFwvXFwvL2ksIHByb3RvY29sKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2l0ZUV4aXN0cyhzaXRldXJsKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBzaXRlIHRvIGNoZWNrIGlmIGxvY2FsX21vYmlsZSBpcyBpbnN0YWxsZWQuXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBvcmFyeVNpdGUgPSAkbW1TaXRlc0ZhY3RvcnkubWFrZVNpdGUodW5kZWZpbmVkLCBzaXRldXJsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcG9yYXJ5U2l0ZS5jaGVja0xvY2FsTW9iaWxlUGx1Z2luKCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGV1cmwgPSB0ZW1wb3JhcnlTaXRlLmdldFVSTCgpO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlc1tzaXRldXJsXSA9IGRhdGEuc2VydmljZTsgLy8gTm8gbmVlZCB0byBzdG9yZSBpdCBpbiBEQi5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtzaXRldXJsOiBzaXRldXJsLCBjb2RlOiBkYXRhLmNvZGUsIHdhcm5pbmc6IGRhdGEud2FybmluZ307XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBTaXRlIGRvZXNuJ3QgZXhpc3QuXG5cbiAgICAgICAgICAgICAgICBpZiAoc2l0ZXVybC5pbmRleE9mKFwiaHR0cHM6Ly9cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0cnkgd2l0aG91dCBIVFRQUy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2hlY2tTaXRlKHNpdGV1cmwsIFwiaHR0cDovL1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0uY29yZS5jYW5ub3Rjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBzaXRlIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjc2l0ZUV4aXN0c1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZXVybCBVUkwgb2YgdGhlIHNpdGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIEEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBpZiB0aGUgc2l0ZSBleGlzdHMuXG4gICAgICovXG4gICAgc2VsZi5zaXRlRXhpc3RzID0gZnVuY3Rpb24oc2l0ZXVybCkge1xuICAgICAgICB2YXIgdXJsID0gc2l0ZXVybCArICcvbG9naW4vdG9rZW4ucGhwJztcbiAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc1dlYlZpZXcoKSkge1xuICAgICAgICAgICAgLy8gV2UgcGFzcyBmYWtlIHBhcmFtZXRlcnMgdG8gbWFrZSBDT1JTIHdvcmsgKHdpdGhvdXQgcGFyYW1zLCB0aGUgc2NyaXB0IHN0b3BzIGJlZm9yZSBhbGxvd2luZyBDT1JTKS5cbiAgICAgICAgICAgIHVybCA9IHVybCArICc/dXNlcm5hbWU9YSZwYXNzd29yZD1iJnNlcnZpY2U9Yyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRodHRwLmdldCh1cmwsIHt0aW1lb3V0OiAzMDAwMH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdXNlciB0b2tlbiBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2dldFVzZXJUb2tlblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRldXJsICAgVGhlIHNpdGUgdXJsLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZSAgVXNlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCAgUGFzc3dvcmQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZXJ2aWNlXSBTZXJ2aWNlIHRvIHVzZS4gSWYgbm90IGRlZmluZWQsIGl0IHdpbGwgYmUgc2VhcmNoZWQgaW4gbWVtb3J5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0cnkgICAgV2UgYXJlIHJldHJ5aW5nIHdpdGggYSBwcmVmaXhlZCBVUkwuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBBIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgdG9rZW4gaXMgcmV0cmlldmVkLiBJZiBzdWNjZXNzLCByZXR1cm5zIGFuIG9iamVjdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgdG9rZW4gYW5kIHRoZSBzaXRldXJsIHRvIHVzZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldFVzZXJUb2tlbiA9IGZ1bmN0aW9uKHNpdGV1cmwsIHVzZXJuYW1lLCBwYXNzd29yZCwgc2VydmljZSwgcmV0cnkpIHtcbiAgICAgICAgcmV0cnkgPSByZXRyeSB8fCBmYWxzZTtcblxuICAgICAgICBpZiAoISRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmNvcmUubmV0d29ya2Vycm9ybXNnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlcnZpY2UpIHtcbiAgICAgICAgICAgIHNlcnZpY2UgPSBkZXRlcm1pbmVTZXJ2aWNlKHNpdGV1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2ludXJsID0gc2l0ZXVybCArICcvbG9naW4vdG9rZW4ucGhwJztcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXG4gICAgICAgICAgICBzZXJ2aWNlOiBzZXJ2aWNlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRodHRwLnBvc3QobG9naW51cmwsIGRhdGEpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gcmVzcG9uc2UuZGF0YTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5jb3JlLmNhbm5vdGNvbm5lY3QnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLnRva2VuICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7dG9rZW46IGRhdGEudG9rZW4sIHNpdGV1cmw6IHNpdGV1cmx9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS5lcnJvciAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBhbGxvdyBvbmUgcmV0cnkgKHRvIGF2b2lkIGxvb3BzKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmV0cnkgJiYgZGF0YS5lcnJvcmNvZGUgPT0gXCJyZXF1aXJlY29ycmVjdGFjY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZXVybCA9ICRtbVRleHQuYWRkT3JSZW1vdmVXV1coc2l0ZXVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VXNlclRva2VuKHNpdGV1cmwsIHVzZXJuYW1lLCBwYXNzd29yZCwgc2VydmljZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZGF0YS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmxvZ2luLmludmFsaWRhY2NvdW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5jb3JlLmNhbm5vdGNvbm5lY3QnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBzaXRlIHRvIHRoZSBzaXRlIGxpc3QgYW5kIGF1dGhlbnRpY2F0ZSB0aGUgdXNlciBpbiB0aGlzIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI25ld1NpdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZXVybCAgVGhlIHNpdGUgdXJsLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiAgICBVc2VyJ3MgdG9rZW4uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIEEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIGlzIGFkZGVkIGFuZCB0aGUgdXNlciBpcyBhdXRoZW50aWNhdGVkLlxuICAgICAqL1xuICAgIHNlbGYubmV3U2l0ZSA9IGZ1bmN0aW9uKHNpdGV1cmwsIHRva2VuKSB7XG5cbiAgICAgICAgdmFyIGNhbmRpZGF0ZVNpdGUgPSAkbW1TaXRlc0ZhY3RvcnkubWFrZVNpdGUodW5kZWZpbmVkLCBzaXRldXJsLCB0b2tlbik7XG5cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZVNpdGUuZmV0Y2hTaXRlSW5mbygpLnRoZW4oZnVuY3Rpb24oaW5mb3MpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkTW9vZGxlVmVyc2lvbihpbmZvcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGlvbiA9IHZhbGlkYXRlU2l0ZUluZm8oaW5mb3MpO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXRlaWQgPSBzZWxmLmNyZWF0ZVNpdGVJRChpbmZvcy5zaXRldXJsLCBpbmZvcy51c2VybmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzaXRlIHRvIHNpdGVzIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkU2l0ZShzaXRlaWQsIHNpdGV1cmwsIHRva2VuLCBpbmZvcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFR1cm4gY2FuZGlkYXRlIHNpdGUgaW50byBjdXJyZW50IHNpdGUuXG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVNpdGUuc2V0SWQoc2l0ZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlU2l0ZS5zZXRJbmZvKGluZm9zKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpdGUgPSBjYW5kaWRhdGVTaXRlO1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBzZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZ2luKHNpdGVpZCk7XG4gICAgICAgICAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50U2l0ZUFkZGVkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZSh2YWxpZGF0aW9uLmVycm9yLCB2YWxpZGF0aW9uLnBhcmFtcykudGhlbihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5sb2dpbi5pbnZhbGlkbW9vZGxldmVyc2lvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2l0ZSBJRCBiYXNlZCBvbiBzaXRlIFVSTCBhbmQgdXNlcm5hbWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2NyZWF0ZVNpdGVJRFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRldXJsICBUaGUgc2l0ZSB1cmwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lIFVzZXJuYW1lLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBTaXRlIElELlxuICAgICAqL1xuICAgIHNlbGYuY3JlYXRlU2l0ZUlEID0gZnVuY3Rpb24oc2l0ZXVybCwgdXNlcm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1kNS5jcmVhdGVIYXNoKHNpdGV1cmwgKyB1c2VybmFtZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGZvciBkZXRlcm1pbmUgd2hpY2ggc2VydmljZSB3ZSBzaG91bGQgdXNlIChkZWZhdWx0IG9yIGV4dGVuZGVkIHBsdWdpbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGV1cmwgVGhlIHNpdGUgVVJMLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBUaGUgc2VydmljZSBzaG9ydG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lU2VydmljZShzaXRldXJsKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdHJ5IHNpdGV1cmwgaW4gYm90aCBodHRwcyBvciBodHRwIChkdWUgdG8gbG9naW5odHRwcyBzZXR0aW5nKS5cblxuICAgICAgICAvLyBGaXJzdCBodHRwOi8vXG4gICAgICAgIHNpdGV1cmwgPSBzaXRldXJsLnJlcGxhY2UoXCJodHRwczovL1wiLCBcImh0dHA6Ly9cIik7XG4gICAgICAgIGlmIChzZXJ2aWNlc1tzaXRldXJsXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VzW3NpdGV1cmxdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IGh0dHBzOi8vXG4gICAgICAgIHNpdGV1cmwgPSBzaXRldXJsLnJlcGxhY2UoXCJodHRwOi8vXCIsIFwiaHR0cHM6Ly9cIik7XG4gICAgICAgIGlmIChzZXJ2aWNlc1tzaXRldXJsXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VzW3NpdGV1cmxdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIGRlZmF1bHQgc2VydmljZS5cbiAgICAgICAgcmV0dXJuIG1tQ29yZUNvbmZpZ0NvbnN0YW50cy53c3NlcnZpY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIHRoZSBtaW5pbXVtIHJlcXVpcmVkIHZlcnNpb24gKE1vb2RsZSAyLjQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gc2l0ZWZ1bmN0aW9ucyBMaXN0IG9mIGZ1bmN0aW9ucyBvZiB0aGUgTW9vZGxlIHNpdGUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICBUcnVlIGlmIHRoZSBtb29kbGUgdmVyc2lvbiBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRNb29kbGVWZXJzaW9uKGluZm9zKSB7XG4gICAgICAgIGlmICghaW5mb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5WZXJzaW9uID0gMjAxMjEyMDMwMCwgLy8gTW9vZGxlIDIuNCB2ZXJzaW9uLlxuICAgICAgICAgICAgbWluUmVsZWFzZSA9IFwiMi40XCI7XG5cbiAgICAgICAgLy8gVHJ5IHRvIHZhbGlkYXRlIGJ5IHZlcnNpb24uXG4gICAgICAgIGlmIChpbmZvcy52ZXJzaW9uKSB7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IHBhcnNlSW50KGluZm9zLnZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKCFpc05hTih2ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uID49IG1pblZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBjb3VsZG4ndCB2YWxpZGF0ZSBieSB2ZXJzaW9uIG51bWJlci4gTGV0J3MgdHJ5IHRvIHZhbGlkYXRlIGJ5IHJlbGVhc2UgbnVtYmVyLlxuICAgICAgICBpZiAoaW5mb3MucmVsZWFzZSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBpbmZvcy5yZWxlYXNlLm1hdGNoKC9eKFtcXGR8XFwuXSopLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXSA+PSBtaW5SZWxlYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ291bGRuJ3QgdmFsaWRhdGUgYnkgcmVsZWFzZSBlaXRoZXIuIENoZWNrIGlmIGl0IHVzZXMgbG9jYWxfbW9iaWxlIHBsdWdpbi5cbiAgICAgICAgdmFyIGFwcFVzZXNMb2NhbE1vYmlsZSA9IGZhbHNlO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goaW5mb3MuZnVuY3Rpb25zLCBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICBpZiAoZnVuYy5uYW1lLmluZGV4T2YobW1Db3JlV1NQcmVmaXgpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgYXBwVXNlc0xvY2FsTW9iaWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFwcFVzZXNMb2NhbE1vYmlsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBzaXRlIGluZm8gaXMgdmFsaWQuIElmIGl0J3Mgbm90LCByZXR1cm4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvcyAgICBTaXRlIGluZm8uXG4gICAgICogQHJldHVybiB7T2JqZWN0fEJvb2xlYW59IE9iamVjdCB3aXRoIGVycm9yIG1lc3NhZ2UgdG8gc2hvdyBhbmQgaXRzIHBhcmFtcyBpZiBpbmZvIGlzIG5vdCB2YWxpZCwgdHJ1ZSBpZiBpbmZvIGlzIHZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU2l0ZUluZm8oaW5mb3MpIHtcbiAgICAgICAgaWYgKCFpbmZvcy5maXJzdG5hbWUgfHwgIWluZm9zLmxhc3RuYW1lKSB7XG4gICAgICAgICAgICB2YXIgbW9vZGxlTGluayA9ICc8YSBtbS1icm93c2VyIGhyZWY9XCInICsgaW5mb3Muc2l0ZXVybCArICdcIj4nICsgaW5mb3Muc2l0ZXVybCArICc8L2E+JztcbiAgICAgICAgICAgIHJldHVybiB7ZXJyb3I6ICdtbS5jb3JlLnJlcXVpcmVkdXNlcmRhdGFtaXNzaW5nJywgcGFyYW1zOiB7JyRhJzogbW9vZGxlTGlua319O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgc2l0ZSBpbiBsb2NhbCBEQi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjYWRkU2l0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGV1cmwgU2l0ZSBVUkwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuICAgVXNlcidzIHRva2VuIGluIHRoZSBzaXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvcyAgIFNpdGUncyBpbmZvLlxuICAgICAqL1xuICAgIHNlbGYuYWRkU2l0ZSA9IGZ1bmN0aW9uKGlkLCBzaXRldXJsLCB0b2tlbiwgaW5mb3MpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmluc2VydChtbUNvcmVTaXRlc1N0b3JlLCB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBzaXRldXJsOiBzaXRldXJsLFxuICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgaW5mb3M6IGluZm9zXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2dpbiBhIHVzZXIgdG8gYSBzaXRlIGZyb20gdGhlIGxpc3Qgb2Ygc2l0ZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2xvYWRTaXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVpZCBJRCBvZiB0aGUgc2l0ZSB0byBsb2FkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIGlzIGxvYWRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmxvYWRTaXRlID0gZnVuY3Rpb24oc2l0ZWlkKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ0xvYWQgc2l0ZSAnK3NpdGVpZCk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2l0ZShzaXRlaWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgY3VycmVudFNpdGUgPSBzaXRlO1xuICAgICAgICAgICAgc2VsZi5sb2dpbihzaXRlaWQpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBsb2NhbF9tb2JpbGUgd2FzIGluc3RhbGxlZCB0byBNb29kbGUuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5jaGVja0lmTG9jYWxNb2JpbGVJbnN0YWxsZWRBbmROb3RVc2VkKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2NhbCBtb2JpbGUgd2FzIGFkZGVkLiBUaHJvdyBpbnZhbGlkIHNlc3Npb24gdG8gZm9yY2UgcmVjb25uZWN0IGFuZCBjcmVhdGUgYSBuZXcgdG9rZW4uXG4gICAgICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3JlRXZlbnRTZXNzaW9uRXhwaXJlZCwgc2l0ZWlkKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzaXRlIGluZm8uIFdlIGRvbid0IGJsb2NrIHRoZSBVSS5cbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVNpdGVJbmZvKHNpdGVpZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZm9zID0gc2l0ZS5nZXRJbmZvKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uID0gdmFsaWRhdGVTaXRlSW5mbyhpbmZvcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaXRlIGluZm8gaXMgbm90IHZhbGlkLiBMb2dvdXQgdGhlIHVzZXIgYW5kIHNob3cgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9nb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ21tX2xvZ2luLnNpdGVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdHJhbnNsYXRlKHZhbGlkYXRpb24uZXJyb3IsIHZhbGlkYXRpb24ucGFyYW1zKS50aGVuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciNnZXRDdXJyZW50U2l0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBzaXRlLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Q3VycmVudFNpdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBzaXRlIGZyb20gdGhlIHNpdGVzIGxpc3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2RlbGV0ZVNpdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZWlkIElEIG9mIHRoZSBzaXRlIHRvIGRlbGV0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgc2l0ZSBpcyBkZWxldGVkLlxuICAgICAqL1xuICAgIHNlbGYuZGVsZXRlU2l0ZSA9IGZ1bmN0aW9uKHNpdGVpZCkge1xuICAgICAgICAkbG9nLmRlYnVnKCdEZWxldGUgc2l0ZSAnK3NpdGVpZCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50U2l0ZSAhPSAndW5kZWZpbmVkJyAmJiBjdXJyZW50U2l0ZS5pZCA9PSBzaXRlaWQpIHtcbiAgICAgICAgICAgIHNlbGYubG9nb3V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5kZWxldGVEQigpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNpdGVzW3NpdGVpZF07XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLnJlbW92ZShtbUNvcmVTaXRlc1N0b3JlLCBzaXRlaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXRlLmRlbGV0ZUZvbGRlcigpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEQiByZW1vdmUgc2hvdWxkbid0IGZhaWwsIGJ1dCB3ZSdsbCBnbyBhaGVhZCBldmVuIGlmIGl0IGRvZXMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXRlLmRlbGV0ZUZvbGRlcigpO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50U2l0ZURlbGV0ZWQsIHNpdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGVyZSBhcmUgbm8gc2l0ZXMgc3RvcmVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciNoYXNOb1NpdGVzXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCBpZiB0aGVyZSBhcmUgbm8gc2l0ZXMsIGFuZCByZWplY3RlZCBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUuXG4gICAgICovXG4gICAgc2VsZi5oYXNOb1NpdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5jb3VudChtbUNvcmVTaXRlc1N0b3JlKS50aGVuKGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgYXJlIHNpdGVzIHN0b3JlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjaGFzU2l0ZXNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzaXRlLCBhbmQgcmVqZWN0ZWQgaWYgdGhlcmUgYXJlbid0LlxuICAgICAqL1xuICAgIHNlbGYuaGFzU2l0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmNvdW50KG1tQ29yZVNpdGVzU3RvcmUpLnRoZW4oZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpdGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciNnZXRTaXRlXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzaXRlSWQgVGhlIHNpdGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmdldFNpdGUgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgaWYgKCFzaXRlSWQpIHtcbiAgICAgICAgICAgIC8vIFNpdGUgSUQgbm90IHZhbGlkLCByZWplY3QuXG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFNpdGUgJiYgY3VycmVudFNpdGUuZ2V0SWQoKSA9PT0gc2l0ZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihjdXJyZW50U2l0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNpdGVzW3NpdGVJZF0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKHNpdGVzW3NpdGVJZF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmdldChtbUNvcmVTaXRlc1N0b3JlLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBzaXRlID0gJG1tU2l0ZXNGYWN0b3J5Lm1ha2VTaXRlKHNpdGVJZCwgZGF0YS5zaXRldXJsLCBkYXRhLnRva2VuLCBkYXRhLmluZm9zKTtcbiAgICAgICAgICAgICAgICBzaXRlc1tzaXRlSWRdID0gc2l0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l0ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGFiYXNlIG9iamVjdCBvZiBhIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2dldFNpdGVEYlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2l0ZUlkIFRoZSBzaXRlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5nZXRTaXRlRGIgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUuZ2V0RGIoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBzaXRlcyBzdG9yZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2dldFNpdGVzXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gW2lkc10gSURzIG9mIHRoZSBzaXRlcyB0byBnZXQuIElmIG5vdCBkZWZpbmVkLCByZXR1cm4gYWxsIHNpdGVzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgc2l0ZXMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNpdGVzID0gZnVuY3Rpb24oaWRzKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5nZXRBbGwobW1Db3JlU2l0ZXNTdG9yZSkudGhlbihmdW5jdGlvbihzaXRlcykge1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFNpdGVzID0gW107XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2l0ZXMsIGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlkcyB8fCBpZHMuaW5kZXhPZihzaXRlLmlkKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFNpdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNpdGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXRldXJsOiBzaXRlLnNpdGV1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsbmFtZTogc2l0ZS5pbmZvcy5mdWxsbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVuYW1lOiBzaXRlLmluZm9zLnNpdGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXZhdGFyOiBzaXRlLmluZm9zLnVzZXJwaWN0dXJldXJsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFNpdGVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIElEcyBvZiBzaXRlcyBzdG9yZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2dldFNpdGVzSWRzXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlcyBJRHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNpdGVzSWRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5nZXRBbGwobW1Db3JlU2l0ZXNTdG9yZSkudGhlbihmdW5jdGlvbihzaXRlcykge1xuICAgICAgICAgICAgdmFyIGlkcyA9IFtdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNpdGVzLCBmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goc2l0ZS5pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpZHM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2dpbiB0aGUgdXNlciBpbiBhIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI2xvZ2luXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlaWQgSUQgb2YgdGhlIHNpdGUgdGhlIHVzZXIgaXMgYWNjZXNzaW5nLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBjdXJyZW50IHNpdGUgaXMgc3RvcmVkLlxuICAgICAqL1xuICAgIHNlbGYubG9naW4gPSBmdW5jdGlvbihzaXRlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmluc2VydChtbUNvcmVDdXJyZW50U2l0ZVN0b3JlLCB7XG4gICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgIHNpdGVpZDogc2l0ZWlkXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbUNvcmVFdmVudExvZ2luKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvZ291dCB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjbG9nb3V0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSB1c2VyIGlzIGxvZ2dlZCBvdXQuXG4gICAgICovXG4gICAgc2VsZi5sb2dvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY3VycmVudFNpdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50TG9nb3V0KTtcbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLnJlbW92ZShtbUNvcmVDdXJyZW50U2l0ZVN0b3JlLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyB0aGUgc2Vzc2lvbiB0byB0aGUgcHJldmlvdXMgb25lIHNvIHRoZSB1c2VyIGRvZXNuJ3QgaGFzIHRvIGxvZ2luIGV2ZXJ5dGltZSB0aGUgYXBwIGlzIHN0YXJ0ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI3Jlc3RvcmVTZXNzaW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCBpZiBhIHNlc3Npb24gaXMgcmVzdG9yZWQuXG4gICAgICovXG4gICAgc2VsZi5yZXN0b3JlU2Vzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2Vzc2lvblJlc3RvcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvblJlc3RvcmVkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkuZ2V0KG1tQ29yZUN1cnJlbnRTaXRlU3RvcmUsIDEpLnRoZW4oZnVuY3Rpb24oY3VycmVudF9zaXRlKSB7XG4gICAgICAgICAgICB2YXIgc2l0ZWlkID0gY3VycmVudF9zaXRlLnNpdGVpZDtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1Jlc3RvcmUgc2Vzc2lvbiBpbiBzaXRlICcrc2l0ZWlkKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmxvYWRTaXRlKHNpdGVpZCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpOyAvLyBSZWplY3Qgd2l0aG91dCBwYXJhbXMuXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgc2l0ZSdzIHRva2VuLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVNpdGVzTWFuYWdlciN1cGRhdGVTaXRlVG9rZW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZXVybCAgU2l0ZSdzIFVSTC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgVXNlcm5hbWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuICAgIFVzZXIncyBuZXcgdG9rZW4uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIEEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIGlzIHVwZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi51cGRhdGVTaXRlVG9rZW4gPSBmdW5jdGlvbihzaXRldXJsLCB1c2VybmFtZSwgdG9rZW4pIHtcbiAgICAgICAgdmFyIHNpdGVpZCA9IHNlbGYuY3JlYXRlU2l0ZUlEKHNpdGV1cmwsIHVzZXJuYW1lKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2l0ZShzaXRlaWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgc2l0ZS50b2tlbiA9IHRva2VuO1xuXG4gICAgICAgICAgICByZXR1cm4gJG1tQXBwLmdldERCKCkuaW5zZXJ0KG1tQ29yZVNpdGVzU3RvcmUsIHtcbiAgICAgICAgICAgICAgICBpZDogc2l0ZWlkLFxuICAgICAgICAgICAgICAgIHNpdGV1cmw6IHNpdGUuZ2V0VVJMKCksXG4gICAgICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgIGluZm9zOiBzaXRlLmdldEluZm8oKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgc2l0ZSdzIGluZm8uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI3VwZGF0ZVNpdGVJbmZvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVpZCBTaXRlJ3MgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBBIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgc2l0ZSBpcyB1cGRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYudXBkYXRlU2l0ZUluZm8gPSBmdW5jdGlvbihzaXRlaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2l0ZShzaXRlaWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUuZmV0Y2hTaXRlSW5mbygpLnRoZW4oZnVuY3Rpb24oaW5mb3MpIHtcbiAgICAgICAgICAgICAgICBzaXRlLnNldEluZm8oaW5mb3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5pbnNlcnQobW1Db3JlU2l0ZXNTdG9yZSwge1xuICAgICAgICAgICAgICAgICAgICBpZDogc2l0ZWlkLFxuICAgICAgICAgICAgICAgICAgICBzaXRldXJsOiBzaXRlLmdldFVSTCgpLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogc2l0ZS5nZXRUb2tlbigpLFxuICAgICAgICAgICAgICAgICAgICBpbmZvczogaW5mb3NcbiAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCBzaXRlaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgc2l0ZSdzIGluZm8uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2l0ZXNNYW5hZ2VyI3VwZGF0ZVNpdGVJbmZvQnlVcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZXVybCAgU2l0ZSdzIFVSTC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgVXNlcm5hbWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIEEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBzaXRlIGlzIHVwZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi51cGRhdGVTaXRlSW5mb0J5VXJsID0gZnVuY3Rpb24oc2l0ZXVybCwgdXNlcm5hbWUpIHtcbiAgICAgICAgdmFyIHNpdGVpZCA9IHNlbGYuY3JlYXRlU2l0ZUlEKHNpdGV1cmwsIHVzZXJuYW1lKTtcbiAgICAgICAgcmV0dXJuIHNlbGYudXBkYXRlU2l0ZUluZm8oc2l0ZWlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaXRlIElEcyBhIFVSTCBiZWxvbmdzIHRvLlxuICAgICAqIFNvbWVvbmUgY2FuIGhhdmUgbW9yZSB0aGFuIG9uZSBhY2NvdW50IGluIHRoZSBzYW1lIHNpdGUsIHRoYXQncyB3aHkgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGFycmF5IG9mIElEcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1TaXRlc01hbmFnZXIjZ2V0U2l0ZXNVcmxzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgIFVSTCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByaW9yaXRpemUgVHJ1ZSBpZiBpdCBzaG91bGQgcHJpb3JpdGl6ZSBjdXJyZW50IHNpdGUuIElmIHRoZSBVUkwgYmVsb25ncyB0byBjdXJyZW50IHNpdGUgdGhlbiBpdCB3b24ndFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVjayBhbnkgb3RoZXIgc2l0ZSwgaXQgd2lsbCBvbmx5IHJldHVybiBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgc2l0ZSBJRHMgKGFycmF5KS5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNpdGVJZHNGcm9tVXJsID0gZnVuY3Rpb24odXJsLCBwcmlvcml0aXplKSB7XG4gICAgICAgIC8vIENoZWNrIGN1cnJlbnQgc2l0ZSBmaXJzdCwgaXQgaGFzIHByaW9yaXR5IG92ZXIgdGhlIHJlc3Qgb2Ygc2l0ZXMuXG4gICAgICAgIGlmIChwcmlvcml0aXplICYmIGN1cnJlbnRTaXRlICYmIGN1cnJlbnRTaXRlLmNvbnRhaW5zVXJsKHVybCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtjdXJyZW50U2l0ZS5nZXRJZCgpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBVUkwgaGFzIGh0dHAocykgcHJvdG9jb2wuXG4gICAgICAgIGlmICghdXJsLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy9pKSkge1xuICAgICAgICAgICAgLy8gVVJMIGRvZXNuJ3QgaGF2ZSBodHRwKHMpIHByb3RvY29sLiBDaGVjayBpZiBpdCBoYXMgYW55IHByb3RvY29sLlxuICAgICAgICAgICAgaWYgKHVybC5tYXRjaCgvXlteOl17MiwxMH06XFwvXFwvL2kpKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIHNvbWUgcHJvdG9jb2wuIFJldHVybiBlbXB0eSBhcnJheS5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIHByb3RvY29sLCBwcm9iYWJseSBhIHJlbGF0aXZlIFVSTC4gUmV0dXJuIGN1cnJlbnQgc2l0ZS5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW2N1cnJlbnRTaXRlLmdldElkKCldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbUFwcC5nZXREQigpLmdldEFsbChtbUNvcmVTaXRlc1N0b3JlKS50aGVuKGZ1bmN0aW9uKHNpdGVzKSB7XG4gICAgICAgICAgICB2YXIgaWRzID0gW107XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2l0ZXMsIGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNpdGVzW3NpdGUuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGVzW3NpdGUuaWRdID0gJG1tU2l0ZXNGYWN0b3J5Lm1ha2VTaXRlKHNpdGUuaWQsIHNpdGUuc2l0ZXVybCwgc2l0ZS50b2tlbiwgc2l0ZS5pbmZvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaXRlc1tzaXRlLmlkXS5jb250YWluc1VybCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKHNpdGUuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBTaG91bGRuJ3QgaGFwcGVuLlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tVGV4dFxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgc2VydmljZSBwcm92aWRlcyBmdW5jdGlvbnMgcmVsYXRlZCB0byB0ZXh0LCBsaWtlIGZvcm1hdHRpbmcgdGV4dHMgZnJvbSBNb29kbGUuXG4gKi9cbi5mYWN0b3J5KCckbW1UZXh0JywgZnVuY3Rpb24oJHEsICRtbUxhbmcsICR0cmFuc2xhdGUpIHtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHNpemUgaW4gYnl0ZXMgaW50byBodW1hbiByZWFkYWJsZSBmb3JtYXRcbiAgICAgKiBodHRwOi8vY29kZWFpZC5uZXQvamF2YXNjcmlwdC9jb252ZXJ0LXNpemUtaW4tYnl0ZXMtdG8taHVtYW4tcmVhZGFibGUtZm9ybWF0LShqYXZhc2NyaXB0KVxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVRleHQjYnl0ZXNUb1NpemVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYnl0ZXMgICAgICAgICBOdW1iZXIgb2YgYnl0ZXMgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByZWNpc2lvbj0yXSBOdW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHNlcGFyYXRvci5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICBTaXplIGluIGh1bWFuIHJlYWRhYmxlIGZvcm1hdC5cbiAgICAgKi9cbiAgICBzZWxmLmJ5dGVzVG9TaXplID0gZnVuY3Rpb24oYnl0ZXMsIHByZWNpc2lvbikge1xuXG4gICAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT0gJ3VuZGVmaW5lZCcgfHwgYnl0ZXMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLm5vdGFwcGxpY2FibGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJlY2lzaW9uID09ICd1bmRlZmluZWQnIHx8IHByZWNpc2lvbiA8IDApIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IFsnbW0uY29yZS5zaXplYicsICdtbS5jb3JlLnNpemVrYicsICdtbS5jb3JlLnNpemVtYicsICdtbS5jb3JlLnNpemVnYicsICdtbS5jb3JlLnNpemV0YiddO1xuICAgICAgICB2YXIgdW5pdHMgPSAkdHJhbnNsYXRlLmluc3RhbnQoa2V5cyk7XG4gICAgICAgIHZhciBwb3N0dHh0ID0gMDtcbiAgICAgICAgaWYgKGJ5dGVzID49IDEwMjQpIHtcbiAgICAgICAgICAgIHdoaWxlIChieXRlcyA+PSAxMDI0KSB7XG4gICAgICAgICAgICAgICAgcG9zdHR4dCsrO1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMgLyAxMDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnl0ZXMgPSBOdW1iZXIoTWF0aC5yb3VuZChieXRlcysnZSsnK3ByZWNpc2lvbikgKyAnZS0nK3ByZWNpc2lvbik7IC8vIFJvdW5kIHRvIFwicHJlY2lzaW9uXCIgZGVjaW1hbHMgaWYgbmVlZGVkLlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUuaHVtYW5yZWFkYWJsZXNpemUnLCB7c2l6ZTogTnVtYmVyKGJ5dGVzKSwgdW5pdDogdW5pdHNba2V5c1twb3N0dHh0XV19KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY2xlYW4gSFRNTCB0YWdzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVRleHQjY2xlYW5UYWdzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgdGV4dCAgICAgICAgIFRoZSB0ZXh0IHRvIGJlIGNsZWFuZWQuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3NpbmdsZUxpbmVdIFRydWUgaWYgbmV3IGxpbmVzIHNob3VsZCBiZSByZW1vdmVkIChhbGwgdGhlIHRleHQgaW4gYSBzaW5nbGUgbGluZSkuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgIFRleHQgY2xlYW5lZC5cbiAgICAgKi9cbiAgICBzZWxmLmNsZWFuVGFncyA9IGZ1bmN0aW9uKHRleHQsIHNpbmdsZUxpbmUpIHtcbiAgICAgICAgLy8gRmlyc3QsIHdlIHVzZSBhIHJlZ2V4cHIuXG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLFwiXCIpO1xuICAgICAgICAvLyBUaGVuLCB3ZSByZWx5IG9uIHRoZSBicm93c2VyLiBXZSBuZWVkIHRvIHdyYXAgdGhlIHRleHQgdG8gYmUgc3VyZSBpcyBIVE1MLlxuICAgICAgICB0ZXh0ID0gYW5ndWxhci5lbGVtZW50KCc8cD4nKS5odG1sKHRleHQpLnRleHQoKTsgLy8gR2V0IGRpcmVjdGl2ZSdzIGNvbnRlbnQuXG4gICAgICAgIC8vIFJlY292ZXIgb3IgcmVtb3ZlIG5ldyBsaW5lcy5cbiAgICAgICAgdGV4dCA9IHNlbGYucmVwbGFjZU5ld0xpbmVzKHRleHQsIHNpbmdsZUxpbmUgPyAnICcgOiAnPGJyIC8+Jyk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIGFsbCB0aGUgbmV3IGxpbmVzIG9uIGEgY2VydGFpbiB0ZXh0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVRleHQjcmVwbGFjZU5ld0xpbmVzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgdGV4dCAgICAgVGhlIHRleHQgdG8gYmUgdHJlYXRlZC5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBuZXdWYWx1ZSBUZXh0IHRvIHBsYWNlIG9uIGVhY2ggbmV3IGxpbmUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVHJlYXRlZCB0ZXh0LlxuICAgICAqL1xuICAgIHNlbGYucmVwbGFjZU5ld0xpbmVzID0gZnVuY3Rpb24odGV4dCwgbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvKD86XFxyXFxufFxccnxcXG4pL2csIG5ld1ZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIHRleHQsIHRyZWF0aW5nIG11bHRpbGFuZyB0YWdzIGFuZCBjbGVhbmluZyBIVE1MIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1UZXh0I2Zvcm1hdFRleHRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgICAgICAgICAgICAgVGV4dCB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYW4gICAgICAgICAgIFRydWUgaWYgSFRNTCB0YWdzIHNob3VsZCBiZSByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3NpbmdsZUxpbmVdICAgIFRydWUgaWYgbmV3IGxpbmVzIHNob3VsZCBiZSByZW1vdmVkLiBPbmx5IHZhbGlkIGlmIGNsZWFuIGlzIHRydWUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgW3Nob3J0ZW5MZW5ndGhdIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHNob3J0ZW4gdGhlIHRleHQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZm9ybWF0dGVkIHRleHQuXG4gICAgICovXG4gICAgc2VsZi5mb3JtYXRUZXh0ID0gZnVuY3Rpb24odGV4dCwgY2xlYW4sIHNpbmdsZUxpbmUsIHNob3J0ZW5MZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudHJlYXRNdWx0aWxhbmdUYWdzKHRleHQpLnRoZW4oZnVuY3Rpb24oZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICBpZiAoY2xlYW4pIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQgPSBzZWxmLmNsZWFuVGFncyhmb3JtYXR0ZWQsIHNpbmdsZUxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3J0ZW5MZW5ndGggJiYgcGFyc2VJbnQoc2hvcnRlbkxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkID0gc2VsZi5zaG9ydGVuVGV4dChmb3JtYXR0ZWQsIHBhcnNlSW50KHNob3J0ZW5MZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGVucyBhIHRleHQgdG8gbGVuZ3RoIGFuZCBhZGRzIGFuIGVsbGlwc2lzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVRleHQjc2hvcnRlblRleHRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gYmUgc2hvcnRlbmVkLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGVuZ3RoIFRoZSBkZXNpcmVkIGxlbmd0aC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNob3J0ZW5lZCB0ZXh0LlxuICAgICAqL1xuICAgIHNlbGYuc2hvcnRlblRleHQgPSBmdW5jdGlvbih0ZXh0LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgbGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gTm93LCB0cnVuY2F0ZSBhdCB0aGUgbGFzdCB3b3JkIGJvdW5kYXJ5IChpZiBleGlzdHMpLlxuICAgICAgICAgICAgdmFyIGxhc3RXb3JkUG9zID0gdGV4dC5sYXN0SW5kZXhPZignICcpO1xuICAgICAgICAgICAgaWYgKGxhc3RXb3JkUG9zID4gMCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cigwLCBsYXN0V29yZFBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ICs9ICcmaGVsbGlwOyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyZWF0IHRoZSBtdWx0aWxhbmcgdGFncyBmcm9tIGEgSFRNTCBjb2RlLCBsZWF2aW5nIG9ubHkgdGhlIGN1cnJlbnQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVGV4dCN0cmVhdE11bHRpbGFuZ1RhZ3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAgIFRoZSB0ZXh0IHRvIGJlIGZvcm1hdHRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkIElEIG9mIHRoZSBzaXRlIHRvIHVzZS4gSWYgbm90IHNldCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZm9ybWF0dGVkIHRleHQuXG4gICAgICovXG4gICAgc2VsZi50cmVhdE11bHRpbGFuZ1RhZ3MgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbUxhbmcuZ2V0Q3VycmVudExhbmd1YWdlKCkudGhlbihmdW5jdGlvbihsYW5ndWFnZSkge1xuICAgICAgICAgICAgLy8gTWF0Y2ggdGhlIGN1cnJlbnQgbGFuZ3VhZ2VcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGFuZ1JlID0gbmV3IFJlZ0V4cCgnPCg/Omxhbmd8c3BhbilbXj5dK2xhbmc9XCInICsgbGFuZ3VhZ2UgKyAnXCJbXj5dKj4oLio/KTxcXC8oPzpsYW5nfHNwYW4pPicsICdnJyksXG4gICAgICAgICAgICAgICAgYW55TGFuZ1JFID0gLzwoPzpsYW5nfHNwYW4pW14+XStsYW5nPVwiW2EtekEtWjAtOV8tXStcIltePl0qPiguKj8pPFxcLyg/Omxhbmd8c3Bhbik+L2c7XG5cbiAgICAgICAgICAgIGlmICghdGV4dC5tYXRjaChjdXJyZW50TGFuZ1JlKSkge1xuICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgbGFuZyBub3QgZm91bmQuIFRyeSB0byBmaW5kIHRoZSBmaXJzdCBsYW5ndWFnZS5cbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRleHQubWF0Y2goYW55TGFuZ1JFKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlID0gbWF0Y2hlc1swXS5tYXRjaCgvbGFuZz1cIihbYS16QS1aMC05Xy1dKylcIi8pWzFdO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGFuZ1JlID0gbmV3IFJlZ0V4cCgnPCg/Omxhbmd8c3BhbilbXj5dK2xhbmc9XCInICsgbGFuZ3VhZ2UgKyAnXCJbXj5dKj4oLio/KTxcXC8oPzpsYW5nfHNwYW4pPicsICdnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gbXVsdGktbGFuZyB0YWcgZm91bmQsIHN0b3AuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgY29udGVudHMgb2YgY3VycmVudCBsYW5ndWFnZS5cbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoY3VycmVudExhbmdSZSwgJyQxJyk7XG4gICAgICAgICAgICAvLyBEZWxldGUgdGhlIHJlc3Qgb2YgbGFuZ3VhZ2VzXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGFueUxhbmdSRSwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGUgYW4gSFRNTCB0ZXh0LiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIFBIUCdzIGh0bWxzcGVjaWFsY2hhcnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVGV4dCNlc2NhcGVIVE1MXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0IFRleHQgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICBFc2NhcGVkIHRleHQuXG4gICAgICovXG4gICAgc2VsZi5lc2NhcGVIVE1MID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT0gJ3VuZGVmaW5lZCcgfHwgdGV4dCA9PT0gbnVsbCB8fCAodHlwZW9mIHRleHQgPT0gJ251bWJlcicgJiYgaXNOYU4odGV4dCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRleHQgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCImIzAzOTtcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBvciByZW1vdmUgJ3d3dycgZnJvbSBhIFVSTC4gVGhlIHVybCBuZWVkcyB0byBoYXZlIGh0dHAgb3IgaHR0cHMgcHJvdG9jb2wuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVGV4dCNhZGRPclJlbW92ZVdXV1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgIE1vZGlmaWVkIFVSTC5cbiAgICAgKi9cbiAgICBzZWxmLmFkZE9yUmVtb3ZlV1dXID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodXJsLm1hdGNoKC9odHRwKHMpPzpcXC9cXC93d3dcXC4vKSkge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgaGFzIHd3dy4gUmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCd3d3cuJywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgnaHR0cHM6Ly8nLCAnaHR0cHM6Ly93d3cuJyk7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ2h0dHA6Ly8nLCAnaHR0cDovL3d3dy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcHJvdG9jb2wgYW5kIHd3dyBmcm9tIGEgVVJMLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVRleHQjcmVtb3ZlUHJvdG9jb2xBbmRXV1dcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybCBVUkwgdG8gdHJlYXQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgVHJlYXRlZCBVUkwuXG4gICAgICovXG4gICAgc2VsZi5yZW1vdmVQcm90b2NvbEFuZFdXVyA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAvLyBSZW1vdmUgcHJvdG9jb2wuXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC8uKj86XFwvXFwvL2csICcnKTtcbiAgICAgICAgLy8gUmVtb3ZlIHd3dy5cbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL153d3cuLywgJycpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLmNvbnN0YW50KCdtbUNvcmVWZXJzaW9uQXBwbGllZCcsICd2ZXJzaW9uX2FwcGxpZWQnKVxuXG4vKipcbiAqIEZhY3RvcnkgdG8gaGFuZGxlIGFwcCB1cGRhdGVzLiBUaGlzIGZhY3Rvcnkgc2hvdWxkbid0IGJlIHVzZWQgb3V0c2lkZSBvZiBjb3JlLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbVVwZGF0ZU1hbmFnZXJcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzZXJ2aWNlIGhhbmRsZXMgcHJvY2Vzc2VzIHRoYXQgbmVlZCB0byBiZSBydW4gd2hlbiB1cGRhdGluZyB0aGUgYXBwLCBsaWtlIG1pZ3JhdGUgTU0xIHNpdGVzIHRvIE1NMi5cbiAqL1xuLmZhY3RvcnkoJyRtbVVwZGF0ZU1hbmFnZXInLCBmdW5jdGlvbigkbG9nLCAkcSwgJG1tQ29uZmlnLCAkbW1TaXRlc01hbmFnZXIsICRtbUZTLCAkY29yZG92YUxvY2FsTm90aWZpY2F0aW9uLCAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICAkbW1BcHAsICRtbUV2ZW50cywgbW1Db3JlU2l0ZXNTdG9yZSwgbW1Db3JlVmVyc2lvbkFwcGxpZWQsIG1tQ29yZUV2ZW50U2l0ZUFkZGVkLCBtbUNvcmVFdmVudFNpdGVVcGRhdGVkLFxuICAgICAgICAgICAgbW1Db3JlRXZlbnRTaXRlRGVsZXRlZCwgJGluamVjdG9yLCAkbW1GaWxlcG9vbCwgbW1Db3JlQ291cnNlTW9kdWxlc1N0b3JlLCBtbUZpbGVwb29sTGlua3NTdG9yZSxcbiAgICAgICAgICAgIG1tRmlsZXBvb2xQYWNrYWdlc1N0b3JlLCBtbUNvcmVDb25maWdDb25zdGFudHMpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1VcGRhdGVNYW5hZ2VyJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBzaXRlc0ZpbGVQYXRoID0gJ21pZ3JhdGlvbi9zaXRlcy5qc29uJztcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBhcHAgaGFzIGJlZW4gdXBkYXRlZCBhbmQgcGVyZm9ybXMgdGhlIG5lZWRlZCBwcm9jZXNzZXMuXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3QgYmUgdXNlZCBvdXRzaWRlIG9mIGNvcmUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVXBkYXRlTWFuYWdlciNjaGVja1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgdXBkYXRlIHByb2Nlc3MgZmluaXNoZXMuXG4gICAgICovXG4gICAgc2VsZi5jaGVjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgIHZlcnNpb25Db2RlID0gbW1Db3JlQ29uZmlnQ29uc3RhbnRzLnZlcnNpb25jb2RlO1xuXG4gICAgICAgIHJldHVybiAkbW1Db25maWcuZ2V0KG1tQ29yZVZlcnNpb25BcHBsaWVkLCAwKS50aGVuKGZ1bmN0aW9uKHZlcnNpb25BcHBsaWVkKSB7XG5cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uQ29kZSA+PSAzOTEgJiYgdmVyc2lvbkFwcGxpZWQgPCAzOTEpIHtcbiAgICAgICAgICAgICAgICAvLyBNaWdyYXRpbmcgZnJvbSBNTTEgdG8gTU0yLlxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobWlncmF0ZU1NMVNpdGVzKCkpO1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMgaW4gY2xlYXJBcHBGb2xkZXIuIFdlIGRvbid0IHdhbnQgdG8gY2xlYXIgdGhlIGZvbGRlclxuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5dGltZSB0aGUgYXBwIGlzIG9wZW5lZCBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZy5cbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNsZWFyQXBwRm9sZGVyKCkuY2F0Y2goZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmVyc2lvbkNvZGUgPj0gMjAwMyAmJiB2ZXJzaW9uQXBwbGllZCA8IDIwMDMpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNhbmNlbEFuZHJvaWROb3RpZmljYXRpb25zKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmVyc2lvbkNvZGUgPj0gMjAwMykge1xuICAgICAgICAgICAgICAgIHNldFN0b3JlU2l0ZXNJbkZpbGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZlcnNpb25Db2RlID49IDIwMDcgJiYgdmVyc2lvbkFwcGxpZWQgPCAyMDA3KSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtaWdyYXRlTW9kdWxlc1N0YXR1cygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29uZmlnLnNldChtbUNvcmVWZXJzaW9uQXBwbGllZCwgdmVyc2lvbkNvZGUpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgYXBwbHlpbmcgdXBkYXRlIGZyb20gJyArIHZlcnNpb25BcHBsaWVkICsgJyB0byAnICsgdmVyc2lvbkNvZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgYXBwIGZvbGRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZm9sZGVyIGlzIGNsZWFyZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xlYXJBcHBGb2xkZXIoKSB7XG4gICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tRlMuZ2V0RGlyZWN0b3J5Q29udGVudHMoJycpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBBbmRyb2lkLCBkb24ndCBkZWxldGUgJ2NhY2hlJyBhbmQgJ2ZpbGVzJyBmb2xkZXJzLCBjcmVhdGVkIGJ5IHRoZSBPUy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbkRlbGV0ZUFuZHJvaWQgPSBpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSAmJiBlbnRyeS5uYW1lICE9PSAnY2FjaGUnICYmIGVudHJ5Lm5hbWUgIT09ICdmaWxlcyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW5EZWxldGVJT1MgPSBpb25pYy5QbGF0Zm9ybS5pc0lPUygpICYmIGVudHJ5Lm5hbWUgIT09ICdOb0Nsb3VkJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkRlbGV0ZUlPUyB8fCBjYW5EZWxldGVBbmRyb2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbUZTLnJlbW92ZURpcihlbnRyeS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pZ3JhdGUgTW9vZGxlTW9iaWxlIDEgc2l0ZXMgdG8gTW9vZGxlTW9iaWxlIDIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHNpdGVzIGFyZSBtaWdyYXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaWdyYXRlTU0xU2l0ZXMoKSB7XG4gICAgICAgIHZhciBzaXRlcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzaXRlcycpLFxuICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBpZiAoc2l0ZXMpIHtcbiAgICAgICAgICAgIHNpdGVzID0gc2l0ZXMuc3BsaXQoJywnKTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNpdGVzLCBmdW5jdGlvbihzaXRlaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNpdGVpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnTWlncmF0aW5nIHNpdGUgZnJvbSBNb29kbGVNb2JpbGUgMTogJyArIHNpdGVpZCk7XG4gICAgICAgICAgICAgICAgdmFyIHNpdGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc2l0ZXMtJytzaXRlaWQpLFxuICAgICAgICAgICAgICAgICAgICBpbmZvcztcblxuICAgICAgICAgICAgICAgIGlmIChzaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXRlID0gSlNPTi5wYXJzZShzaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBzaXRlLiBTaG91bGRuJ3QgaGFwcGVuLlxuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy53YXJuKCdTaXRlICcgKyBzaXRlaWQgKyAnIGRhdGEgaXMgaW52YWxpZC4gSWdub3JpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBNTTEgc2l0ZSBpbmZvIGlzIG1peGVkIHdpdGggc2l0ZSBiYXNpYyBkYXRhIChpZCwgdG9rZW4sIHNpdGV1cmwpLlxuICAgICAgICAgICAgICAgICAgICBpbmZvcyA9IGFuZ3VsYXIuY29weShzaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGluZm9zLmlkO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaW5mb3MudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tU2l0ZXNNYW5hZ2VyLmFkZFNpdGUoc2l0ZS5pZCwgc2l0ZS5zaXRldXJsLCBzaXRlLnRva2VuLCBpbmZvcykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cud2FybignU2l0ZSAnICsgc2l0ZWlkICsgJyBub3QgZm91bmQgaW4gbG9jYWwgc3RvcmFnZS4gSWdub3JpbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHNpdGVzKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCBhbGwgQW5kcm9pZCBub3RpZmljYXRpb25zLiBNTSAyLjAgd2FzIHJlbGVhc2VkIHdpdGggYSBidWcgaW4gbm90aWZpY2F0aW9ucyBJRCAoQW5kcm9pZCkuIFRoZXNlIElEcyB3ZXJlIHN0b3JlZCBpblxuICAgICAqIFNoYXJlZFByZWZlcmVuY2VzLCBjYW5jZWwgdGhlbSBhbGwgd2lsbCBjbGVhciB0aGUgc3RvcmVkIHZhbHVlcy4gQHNlZSBNT0JJTEUtMTE0OC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbm90aWZpY2F0aW9ucyBhcmUgY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbmNlbEFuZHJvaWROb3RpZmljYXRpb25zKCkge1xuICAgICAgICBpZiAoJG1tTG9jYWxOb3RpZmljYXRpb25zLmlzQXZhaWxhYmxlKCkgJiYgaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkY29yZG92YUxvY2FsTm90aWZpY2F0aW9uLmNhbmNlbEFsbCgpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIGNhbmNlbGxpbmcgQW5kcm9pZCBub3RpZmljYXRpb25zLicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBldmVudHMgdG8gc3RvcmUgdGhlIHNpdGVzIGluIGEgZmlsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRTdG9yZVNpdGVzSW5GaWxlKCkge1xuICAgICAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRTaXRlQWRkZWQsIHN0b3JlU2l0ZXNJbkZpbGUpO1xuICAgICAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRTaXRlVXBkYXRlZCwgc3RvcmVTaXRlc0luRmlsZSk7XG4gICAgICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFNpdGVEZWxldGVkLCBzdG9yZVNpdGVzSW5GaWxlKTtcbiAgICAgICAgc3RvcmVTaXRlc0luRmlsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBzaXRlcyBzdG9yZWQgaW4gYSBmaWxlLiBJdCdsbCBiZSB1c2VkIHRvIG1pZ3JhdGUgdG8gQ3Jvc3N3YWxrIGlmIHVzZXJzIHNraXBwZWQgU1FMaXRlIG1pZ3JhdGlvbiB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIHNpdGVzIGFyZSByZXRyaWV2ZWQuIFJlc29sdmUgcGFyYW0gaXMgdGhlIHNpdGVzIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2l0ZXNTdG9yZWRJbkZpbGUoKSB7XG4gICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tRlMucmVhZEZpbGUoc2l0ZXNGaWxlUGF0aCkudGhlbihmdW5jdGlvbihzaXRlcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGVzID0gSlNPTi5wYXJzZShzaXRlcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpdGVzO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gRXJyb3IgcmVhZGluZywgcHJvYmFibHkgZmlsZSBkb2Vzbid0IGV4aXN0LiBSZXR1cm4gZW1wdHkgbGlzdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlIHNpdGVzIGluIGEgZmlsZS4gSXQnbGwgYmUgdXNlZCB0byBtaWdyYXRlIHRvIENyb3Nzd2FsayBpZiB1c2VycyBza2lwcGVkIFNRTGl0ZSBtaWdyYXRpb24gdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiBmaWxlIGlzIHdyaXR0ZW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmVTaXRlc0luRmlsZSgpIHtcbiAgICAgICAgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1BcHAuZ2V0REIoKS5nZXRBbGwobW1Db3JlU2l0ZXNTdG9yZSkudGhlbihmdW5jdGlvbihzaXRlcykge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzaXRlcywgZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzaXRlLnRva2VuID0gJ3ByaXZhdGUnOyAvLyBSZW1vdmUgdGhlIHRva2VuLCB3ZSBkb24ndCB3YW50IGl0IHdyaXR0ZW4gaW4gYSBmaWxlLlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GUy53cml0ZUZpbGUoc2l0ZXNGaWxlUGF0aCwgSlNPTi5zdHJpbmdpZnkoc2l0ZXMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBmaWxlIHdpdGggc2l0ZXMgc3RvcmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIGZpbGUgaXMgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWxldGVTaXRlc0ZpbGUoKSB7XG4gICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tRlMucmVtb3ZlRmlsZShzaXRlc0ZpbGVQYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaWdyYXRlIG1tQ29yZUNvdXJzZU1vZHVsZXNTdG9yZSB0byBtbUZpbGVwb29sUGFja2FnZXNTdG9yZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbWlncmF0aW9uIGlzIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pZ3JhdGVNb2R1bGVzU3RhdHVzKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goJGluamVjdG9yLmdldCgnbW1hTW9kQm9va0NvbXBvbmVudCcpKTtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKCRpbmplY3Rvci5nZXQoJ21tYU1vZEltc2NwQ29tcG9uZW50JykpO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goJGluamVjdG9yLmdldCgnbW1hTW9kUGFnZUNvbXBvbmVudCcpKTtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKCRpbmplY3Rvci5nZXQoJ21tYU1vZFJlc291cmNlQ29tcG9uZW50JykpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZXNJZHMoKS50aGVuKGZ1bmN0aW9uKHNpdGVzKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzaXRlcywgZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtaWdyYXRlU2l0ZU1vZHVsZXNTdGF0dXMoc2l0ZUlkLCBjb21wb25lbnRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaWdyYXRlcyB0aGUgbW9kdWxlcyBzdGF0dXMgZnJvbSBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBjb21wb25lbnRzIENvbXBvbmVudHMgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHNpdGUgbWlncmF0aW9uIGlzIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pZ3JhdGVTaXRlTW9kdWxlc1N0YXR1cyhzaXRlSWQsIGNvbXBvbmVudHMpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnTWlncmF0ZSBzaXRlIG1vZHVsZXMgc3RhdHVzIGZyb20gc2l0ZSAnICsgc2l0ZUlkKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGVEYihzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5nZXRBbGwobW1Db3JlQ291cnNlTW9kdWxlc1N0b3JlKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlSW50KGVudHJ5LmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUaGUgaWQgaXMgbm90IGEgbnVtYmVyLCBpZ25vcmUgaXQuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRldGVybWluZUNvbXBvbmVudChkYiwgZW50cnkuaWQsIGNvbXBvbmVudHMpLnRoZW4oZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGEgbmV3IGVudHJ5IGluIGZpbGVwb29sIHN0b3JlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHVzZSAkbW1GaWxlcG9vbCNzdG9yZVBhY2thZ2VTdGF0dXMgYmVjYXVzZSB3ZSB3YW50IHRvIGtlZXAgcHJldmlvdXNTdGF0dXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmNvbXBvbmVudElkID0gZW50cnkuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuaWQgPSAkbW1GaWxlcG9vbC5nZXRQYWNrYWdlSWQoY29tcG9uZW50LCBlbnRyeS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYi5pbnNlcnQobW1GaWxlcG9vbFBhY2thZ2VzU3RvcmUsIGVudHJ5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MgY3JlYXRpbmcgYWxsIHRoZSBuZXcgZW50cmllcy4gTGV0J3MgcmVtb3ZlIHRoZSBvbGQgb25lcy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLnJlbW92ZUFsbChtbUNvcmVDb3Vyc2VNb2R1bGVzU3RvcmUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgY29tcG9uZW50IG9mIGEgbW9kdWxlIHN0YXR1cyBlbnRyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZGIgICAgICAgICAgIFNpdGUgZGF0YWJhc2UuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjb21wb25lbnRJZCAgQ29tcG9uZW50IElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ1tdfSBjb21wb25lbnRzIExpc3Qgb2YgY29tcG9uZW50cyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGNvbXBvbmVudCBvciB1bmRlZmluZWQgaWYgbm8gY29tcG9uZW50IGZvdW5kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGVybWluZUNvbXBvbmVudChkYiwgY29tcG9uZW50SWQsIGNvbXBvbmVudHMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW10sXG4gICAgICAgICAgICBjb21wb25lbnQ7XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbXBvbmVudHMsIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYi5xdWVyeShtbUZpbGVwb29sTGlua3NTdG9yZSwgWydjb21wb25lbnRBbmRJZCcsICc9JywgW2MsIGNvbXBvbmVudElkXV0pLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciByZWplY3QuXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgY3VzdG9tIFVSTHMgc2NoZW1lcy4gTm90aWZpZXMgYWxsIHRoZSBvYnNlcnZlcnMgd2hlbiB0aGUgYXBwIGlzIGludm9rZWQgd2l0aCBhIGN1c3RvbSBVUkwuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tVVJMRGVsZWdhdGVcbiAqL1xuLmZhY3RvcnkoJyRtbVVSTERlbGVnYXRlJywgZnVuY3Rpb24oJGxvZykge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbVVSTERlbGVnYXRlJyk7XG5cbiAgICB2YXIgb2JzZXJ2ZXJzID0ge30sXG4gICAgICAgIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIG9ic2VydmVyIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGFwcCBpcyBsYXVuY2hlZCB2aWEgY3VzdG9tIFVSTCBzY2hlbWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVVJMRGVsZWdhdGUjcmVnaXN0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgICAgICBPYnNlcnZlcidzIG5hbWUuIE11c3QgYmUgdW5pcXVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGNhbGwgd2l0aCB0aGUgVVJMcyByZWNlaXZlZCBieSB0aGUgYXBwLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBjaGVjayBpZiB0aGUgVVJMXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdGhlIG9uZSBleHBlY3RlZCBieSB0aGUgb2JzZXJ2ZXIgYW5kIHJldHVybiB0cnVlIGlmIGl0IGlzLCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYucmVnaXN0ZXIgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAkbG9nLmRlYnVnKFwiUmVnaXN0ZXIgb2JzZXJ2ZXIgJ1wiK25hbWUrXCInIGZvciBjdXN0b20gVVJMLlwiKTtcbiAgICAgICAgb2JzZXJ2ZXJzW25hbWVdID0gY2FsbGJhY2s7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSBhbGwgb2JzZXJ2ZXJzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVVSTERlbGVnYXRlI25vdGlmeVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIG5vdGlmeSB0byB0aGUgb2JzZXJ2ZXJzLlxuICAgICAqL1xuICAgIHNlbGYubm90aWZ5ID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHZhciB0cmVhdGVkID0gZmFsc2U7IC8vIE9uY2UgYW4gb2JzZXJ2ZXIgYWNjZXB0cyBhIFVSTCAocmV0dXJuIHRydWUpIHdlIHN0b3Agbm90aWZ5aW5nLlxuICAgICAgICBhbmd1bGFyLmZvckVhY2gob2JzZXJ2ZXJzLCBmdW5jdGlvbihjYWxsYmFjaywgbmFtZSkge1xuICAgICAgICAgICAgaWYgKCF0cmVhdGVkICYmIHR5cGVvZihjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cmVhdGVkID0gY2FsbGJhY2sodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSlcblxuLnJ1bihmdW5jdGlvbigkbW1VUkxEZWxlZ2F0ZSwgJGxvZykge1xuICAgIHdpbmRvdy5oYW5kbGVPcGVuVVJMID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ0FwcCBsYXVuY2hlZCBieSBVUkwuJyk7XG4gICAgICAgICRtbVVSTERlbGVnYXRlLm5vdGlmeSh1cmwpO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogUHJvdmlkZXIgd2l0aCBzb21lICd1dGlsJyBmdW5jdGlvbmFsaXRpZXMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgcHJvdmlkZXJcbiAqIEBuYW1lICRtbVV0aWxcbiAqL1xuLnByb3ZpZGVyKCckbW1VdGlsJywgZnVuY3Rpb24obW1Db3JlU2Vjb25kc1llYXIsIG1tQ29yZVNlY29uZHNEYXksIG1tQ29yZVNlY29uZHNIb3VyLCBtbUNvcmVTZWNvbmRzTWludXRlKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXMsIC8vIFVzZSAnc2VsZicgdG8gYmUgY29oZXJlbnQgd2l0aCB0aGUgcmVzdCBvZiBzZXJ2aWNlcy5cbiAgICAgICAgcHJvdmlkZXIgPSB0aGlzOyAvLyBUbyBhY2Nlc3MgcHJvdmlkZXIgbWV0aG9kcyBmcm9tIHRoZSBzZXJ2aWNlLlxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIGFuIG9iamVjdCB0byBiZSB1c2VkIGluIGEgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1VdGlsUHJvdmlkZXIjcGFyYW1cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gc2VyaWFsaXplLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIFNlcmlhbGl6YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzZWxmLnBhcmFtID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBxdWVyeSA9ICcnLCBuYW1lLCB2YWx1ZSwgZnVsbFN1Yk5hbWUsIHN1Yk5hbWUsIHN1YlZhbHVlLCBpbm5lck9iaiwgaTtcblxuICAgICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbFN1Yk5hbWUgPSBuYW1lICsgJ1snICsgaSArICddJztcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmogPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmpbZnVsbFN1Yk5hbWVdID0gc3ViVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ICs9IHNlbGYucGFyYW0oaW5uZXJPYmopICsgJyYnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChzdWJOYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVbc3ViTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxTdWJOYW1lID0gbmFtZSArICdbJyArIHN1Yk5hbWUgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyT2JqID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlubmVyT2JqW2Z1bGxTdWJOYW1lXSA9IHN1YlZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSArPSBzZWxmLnBhcmFtKGlubmVyT2JqKSArICcmJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSBxdWVyeSArPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpICsgJyYnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5Lmxlbmd0aCA/IHF1ZXJ5LnN1YnN0cigwLCBxdWVyeS5sZW5ndGggLSAxKSA6IHF1ZXJ5O1xuICAgIH07XG5cbiAgICB0aGlzLiRnZXQgPSBmdW5jdGlvbigkaW9uaWNMb2FkaW5nLCAkaW9uaWNQb3B1cCwgJGluamVjdG9yLCAkdHJhbnNsYXRlLCAkaHR0cCwgJGxvZywgJHEsICRtbUxhbmcsICRtbUZTLCAkdGltZW91dCwgJG1tQXBwLFxuICAgICAgICAgICAgICAgICRtbVRleHQsIG1tQ29yZVdpZmlEb3dubG9hZFRocmVzaG9sZCwgbW1Db3JlRG93bmxvYWRUaHJlc2hvbGQpIHtcblxuICAgICAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tVXRpbCcpO1xuXG4gICAgICAgIHZhciBzZWxmID0ge307IC8vIFVzZSAnc2VsZicgdG8gYmUgY29oZXJlbnQgd2l0aCB0aGUgcmVzdCBvZiBzZXJ2aWNlcy5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybWF0cyBhIFVSTCwgdHJpbSwgbG93ZXJjYXNlLCBldGMuLi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNmb3JtYXRVUkxcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmwgVGhlIHVybCB0byBiZSBmb3JtYXR0ZWQuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIEZyb21hdHRlZCB1cmwuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmZvcm1hdFVSTCA9IGZ1bmN0aW9uKHVybCkge1xuXG4gICAgICAgICAgICB1cmwgPSB1cmwudHJpbSgpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgVVJMIHN0YXJ0cyBieSBodHRwIG9yIGh0dHBzLlxuICAgICAgICAgICAgaWYgKCEgL15odHRwKHMpP1xcOlxcL1xcLy4qL2kudGVzdCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGVzdCBmaXJzdCBhbGx3YXlzIGh0dHBzLlxuICAgICAgICAgICAgICAgIHVybCA9IFwiaHR0cHM6Ly9cIiArIHVybDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaHR0cCBhbGx3YXlzIGluIGxvd2VyY2FzZS5cbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC9eaHR0cC9pLCAnaHR0cCcpO1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL15odHRwcy9pLCAnaHR0cHMnKTtcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSBsYXN0IHNsYXNoLlxuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZXMgYW4gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogVGhpcyBpcyB1c2VkIHRvIHJlc29sdmUgd2hhdCBhIGNhbGxiYWNrIHNob3VsZCBiZSB3aGVuIGF0dGFjaGVkIHRvIGEgZGVsZWdhdGUuXG4gICAgICAgICAqIEZvciBpbnN0YW5jZSwgaWYgdGhlIG9iamVjdCBhdHRhY2hlZCBpcyBhIGZ1bmN0aW9uLCBpdCBpcyByZXR1cm5lZCBhcyBpcywgYnV0XG4gICAgICAgICAqIHdlIGFsc28gc3VwcG9ydCBjb21wbGV4IGRlZmluaXRpb24gb2Ygb2JqZWN0cy4gSWYgd2UgcmVjZWl2ZSBhIHN0cmluZyB3ZSB3aWxsIHBhcnNlXG4gICAgICAgICAqIGl0IGFuZCB0byBpbmplY3QgaXRzIHNlcnZpY2UgdXNpbmcgJGluamVjdG9yIGZyb20gQW5ndWxhci5cbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZXM6XG4gICAgICAgICAqIC0gKEZ1bmN0aW9uKTogcmV0dXJucyB0aGUgc2FtZSBmdW5jdGlvbi5cbiAgICAgICAgICogLSAoT2JqZWN0KTogcmV0dXJucyB0aGUgc2FtZSBvYmplY3QuXG4gICAgICAgICAqIC0gJyRtbVNvbWV0aGluZyc6IEluamVjdHMgYW5kIHJldHVybnMgJG1tU29tZXRoaW5nLlxuICAgICAgICAgKiAtICckbW1Tb21ldGhpbmcubWV0aG9kJzogSW5qZWN0ZXMgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGZ1bmN0aW9uICdtZXRob2QnLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI3Jlc29sdmVPYmplY3RcbiAgICAgICAgICogQHBhcmFtICB7TWl4ZWR9IG9iamVjdCBTdHJpbmcsIG9iamVjdCBvciBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2luc3RhbnRpYXRlPWZhbHNlXSBXaGVuIHRydWUsIGlmIHRoZSBvYmplY3QgcmVzb2x2ZWQgaXMgYSBmdW5jdGlvbiwgaW5zdGFudGlhdGVzIGl0LlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdCByZXNvbHZlZC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgaW5zdGFudGlhdGUpIHtcbiAgICAgICAgICAgIHZhciB0b0luamVjdCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZDtcblxuICAgICAgICAgICAgaW5zdGFudGlhdGUgPSBhbmd1bGFyLmlzVW5kZWZpbmVkKGluc3RhbnRpYXRlKSA/IGZhbHNlIDogaW5zdGFudGlhdGU7XG5cbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24ob2JqZWN0KSB8fCBhbmd1bGFyLmlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IG9iamVjdDtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICB0b0luamVjdCA9IG9iamVjdC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gJGluamVjdG9yLmdldCh0b0luamVjdFswXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9JbmplY3QubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHJlc29sdmVkW3RvSW5qZWN0WzFdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24ocmVzb2x2ZWQpICYmIGluc3RhbnRpYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSByZXNvbHZlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudCBwYXNzZWQgcGFzc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgaWYgYSBVUkwgaXMgZG93bmxvYWRhYmxlOiBwbHVnaW4gZmlsZSBPUiB0aGVtZS9pbWFnZS5waHAgT1IgZ3JhdmF0YXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjaXNEb3dubG9hZGFibGVVcmxcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSAgdXJsIFRoZSBVUkwgdG8gdGVzdC5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUgd2hlbiB0aGUgVVJMIGlzIGRvd25sb2FkYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNEb3dubG9hZGFibGVVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmlzUGx1Z2luRmlsZVVybCh1cmwpIHx8IHNlbGYuaXNUaGVtZUltYWdlVXJsKHVybCkgfHwgc2VsZi5pc0dyYXZhdGFyVXJsKHVybCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgaWYgYSBVUkwgaXMgYSBncmF2YXRhciBVUkwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjaXNHcmF2YXRhclVybFxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB1cmwgVGhlIFVSTCB0byB0ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSB3aGVuIHRoZSBVUkwgaXMgYSBncmF2YXRhciBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzR3JhdmF0YXJVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmwgJiYgdXJsLmluZGV4T2YoJ2dyYXZhdGFyLmNvbS9hdmF0YXInKSAhPT0gLTE7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgaWYgYSBVUkwgaXMgYSBwbHVnaW5maWxlIFVSTC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNpc1BsdWdpbkZpbGVVcmxcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSAgdXJsIFRoZSBVUkwgdG8gdGVzdC5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUgd2hlbiB0aGUgVVJMIGlzIGEgcGx1Z2luZmlsZSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzUGx1Z2luRmlsZVVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHVybCAmJiB1cmwuaW5kZXhPZignL3BsdWdpbmZpbGUucGhwJykgIT09IC0xO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGlmIGEgVVJMIGlzIGEgdGhlbWUgaW1hZ2UgVVJMLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2lzVGhlbWVJbWFnZVVybFxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB1cmwgVGhlIFVSTCB0byB0ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSB3aGVuIHRoZSBVUkwgaXMgYSB0aGVtZSBpbWFnZSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzVGhlbWVJbWFnZVVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHVybCAmJiB1cmwuaW5kZXhPZignL3RoZW1lL2ltYWdlLnBocCcpICE9PSAtMTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGVzIGEgVVJMIGZvciBhIHNwZWNpZmljIHBhdHRlcm4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjaXNWYWxpZFVSTFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cmwgdG8gdGVzdCBhZ2FpbnN0IHRoZSBwYXR0ZXJuXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgVFJVRSBpZiB0aGUgdXJsIG1hdGNoZXMgdGhlIGV4cGVjdGVkIHBhdHRlcm4uXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgRkFMU0Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc1ZhbGlkVVJMID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gL15odHRwKHMpP1xcOlxcL1xcLyhbXFxkYS16QS1aXFwuLV0rKVxcLihbXFxkYS16QS1aXFwuXXsyLDZ9KShbXFwvXFx3IFxcLi1dKikqXFwvPy9pLnRlc3QodXJsKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJpYyBmdW5jdGlvbiBmb3IgYWRkaW5nIHRoZSB3c3Rva2VuIHRvIE1vb2RsZSB1cmxzIGFuZCBmb3IgcG9pbnRpbmcgdG8gdGhlIGNvcnJlY3Qgc2NyaXB0LlxuICAgICAgICAgKiBGb3IgZG93bmxvYWQgcmVtb3RlIGZpbGVzIGZyb20gTW9vZGxlIHdlIG5lZWQgdG8gdXNlIHRoZSBzcGVjaWFsIC93ZWJzZXJ2aWNlL3BsdWdpbmZpbGUgcGFzc2luZ1xuICAgICAgICAgKiB0aGUgd3MgdG9rZW4gYXMgYSBnZXQgcGFyYW1ldGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2ZpeFBsdWdpbmZpbGVVUkxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgIFRoZSB1cmwgdG8gYmUgZml4ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBUb2tlbiB0byB1c2UuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICBGaXhlZCBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmZpeFBsdWdpbmZpbGVVUkwgPSBmdW5jdGlvbih1cmwsIHRva2VuKSB7XG5cbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbiByZWdleHAgY2FsbGJhY2tzLCBiZXR0ZXIgbm90IHRvIHJpc2shIVxuICAgICAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHdlIG5lZWQgdG8gZml4IHRoaXMgdXJsIG9yIGlzIGFscmVhZHkgZml4ZWQuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJ3Rva2VuPScpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBVUkwgKGNvbnRhaW5zIHRoZSBwbHVnaW5maWxlIGVuZHBvaW50KS5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZigncGx1Z2luZmlsZScpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW4gd2hpY2ggd2F5IHRoZSBzZXJ2ZXIgaXMgc2VydmluZyB0aGUgZmlsZXM/IEFyZSB3ZSB1c2luZyBzbGFzaCBwYXJhbWV0ZXJzP1xuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCc/ZmlsZT0nKSAhPSAtMSB8fCB1cmwuaW5kZXhPZignP2ZvcmNlZG93bmxvYWQ9JykgIT0gLTEgfHwgdXJsLmluZGV4T2YoJz9yZXY9JykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJyYnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJsICs9ICd0b2tlbj0nICsgdG9rZW47XG5cbiAgICAgICAgICAgIC8vIFNvbWUgd2Vic2VydmljZXMgcmV0dXJucyBkaXJlY3RseSB0aGUgY29ycmVjdCBkb3dubG9hZCB1cmwsIG90aGVycyBub3QuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy93ZWJzZXJ2aWNlL3BsdWdpbmZpbGUnKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCcvcGx1Z2luZmlsZScsICcvd2Vic2VydmljZS9wbHVnaW5maWxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVuIGEgZmlsZSB1c2luZyBwbGF0Zm9ybSBzcGVjaWZpYyBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIG5vZGUtd2Via2l0OiBVc2luZyB0aGUgZGVmYXVsdCBhcHBsaWNhdGlvbiBjb25maWd1cmVkLlxuICAgICAgICAgKiBBbmRyb2lkOiBVc2luZyB0aGUgV2ViSW50ZW50IHBsdWdpbi5cbiAgICAgICAgICogaU9zOiBVc2luZyB0aGUgd2luZG93Lm9wZW4gbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI29wZW5GaWxlXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBUaGUgbG9jYWwgcGF0aCBvZiB0aGUgZmlsZSB0byBiZSBvcGVuLlxuICAgICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5vcGVuRmlsZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gUmVzdG9yZSBub2RlLXdlYmtpdCBzdXBwb3J0LlxuXG4gICAgICAgICAgICAgICAgLy8gTGluayBpcyB0aGUgZmlsZSBwYXRoIGluIHRoZSBmaWxlIHN5c3RlbS5cbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhlIG5vZGUtd2Via2l0IHNoZWxsIGZvciBvcGVuIHRoZSBmaWxlIChwZGYsIGRvYykgdXNpbmcgdGhlIGRlZmF1bHQgYXBwbGljYXRpb24gY29uZmlndXJlZCBpbiB0aGUgb3MuXG4gICAgICAgICAgICAgICAgLy8gdmFyIGd1aSA9IHJlcXVpcmUoJ253Lmd1aScpO1xuICAgICAgICAgICAgICAgIC8vIGd1aS5TaGVsbC5vcGVuSXRlbShwYXRoKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LnBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gJG1tRlMuZ2V0RmlsZUV4dGVuc2lvbihwYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgbWltZXR5cGUgPSAkbW1GUy5nZXRNaW1lVHlwZShleHRlbnNpb24pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpICYmIHdpbmRvdy5wbHVnaW5zLndlYmludGVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJhbmRyb2lkLmludGVudC5hY3Rpb24uVklFV1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWltZXR5cGVcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucGx1Z2lucy53ZWJpbnRlbnQuc3RhcnRBY3Rpdml0eShcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdJbnRlbnQgbGF1bmNoZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnSW50ZW50IGxhdW5jaGluZyBmYWlsZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnYWN0aW9uOiAnICsgaVBhcmFtcy5hY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ3VybDogJyArIGlQYXJhbXMudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCd0eXBlOiAnICsgaVBhcmFtcy50eXBlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXh0ZW5zaW9uIHx8IGV4dGVuc2lvbi5pbmRleE9mKCcvJykgPiAtMSB8fCBleHRlbnNpb24uaW5kZXhPZignXFxcXCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5zaW9uIG5vdCBmb3VuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgJ21tLmNvcmUuZXJyb3JvcGVuZmlsZW5vZXh0ZW5zaW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgJ21tLmNvcmUuZXJyb3JvcGVuZmlsZW5vYXBwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lPUygpICYmIHR5cGVvZiBoYW5kbGVEb2N1bWVudFdpdGhVUkwgPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICAgICAgICAgICRtbUZTLmdldEJhc2VQYXRoKCkudGhlbihmdW5jdGlvbihmc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZS9kZWNvZGUgdGhlIHNwZWNpZmljIGZpbGUgcGF0aCwgbm90ZSB0aGF0IGEgcGF0aCBtYXkgY29udGFpbiBkaXJlY3Rvcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB3aGl0ZSBzcGFjZXMsIHNwZWNpYWwgY2hhcmFjdGVycy4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZihmc1Jvb3QgPiAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKGZzUm9vdCwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQocGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBmc1Jvb3QgKyBwYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVEb2N1bWVudFdpdGhVUkwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0ZpbGUgb3BlbmVkIHdpdGggaGFuZGxlRG9jdW1lbnRXaXRoVVJMJyArIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdFcnJvciBvcGVuaW5nIHdpdGggaGFuZGxlRG9jdW1lbnRXaXRoVVJMJyArIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlcnJvciA9PSA1Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignTm8gYXBwIHRoYXQgaGFuZGxlcyB0aGlzIGZpbGUgdHlwZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9wZW5JbkJyb3dzZXIocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCB0cnksIGxhdW5jaCB0aGUgZmlsZSB3aXRoIHRoZSBicm93c2VyLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLm9wZW5JbkJyb3dzZXIocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENoYW5naW5nIF9ibGFuayBmb3IgX3N5c3RlbSBtYXkgd29yayBpbiBjb3Jkb3ZhIDIuNCBhbmQgb253YXJkcy5cbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdPcGVuaW5nIGV4dGVybmFsIGZpbGUgdXNpbmcgd2luZG93Lm9wZW4oKScpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKHBhdGgsICdfYmxhbmsnKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVuIGEgVVJMIHVzaW5nIGEgYnJvd3Nlci5cbiAgICAgICAgICpcbiAgICAgICAgICogRG8gbm90IHVzZSBmb3IgZmlsZXMsIHJlZmVyIHRvIHtAbGluayAkbW1VdGlsI29wZW5GaWxlfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNvcGVuSW5Ccm93c2VyXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gb3Blbi5cbiAgICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYub3BlbkluQnJvd3NlciA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgd2luZG93Lm9wZW4odXJsLCAnX3N5c3RlbScpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVuIGEgVVJMIHVzaW5nIEluQXBwQnJvd3Nlci5cbiAgICAgICAgICpcbiAgICAgICAgICogRG8gbm90IHVzZSBmb3IgZmlsZXMsIHJlZmVyIHRvIHtAbGluayAkbW1VdGlsI29wZW5GaWxlfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNvcGVuSW5BcHBcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBvcGVuLlxuICAgICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5vcGVuSW5BcHAgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5cyBhIGxvYWRpbmcgbW9kYWwgd2luZG93LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI3Nob3dNb2RhbExvYWRpbmdcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICB0ZXh0ICAgICAgICAgICBUaGUgdGV4dCBvZiB0aGUgbW9kYWwgd2luZG93LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5lZWRzVHJhbnNsYXRlIFRydWUgaWYgdGhlICd0ZXh0JyBpcyBhICR0cmFuc2xhdGUga2V5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgT2JqZWN0IHdpdGggYSAnZGlzbWlzcycgZnVuY3Rpb24gdG8gY2xvc2UgdGhlIG1vZGFsLlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogVXNhZ2U6XG4gICAgICAgICAqICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcobXlUZXh0KTtcbiAgICAgICAgICogICAgIC4uLlxuICAgICAgICAgKiAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5zaG93TW9kYWxMb2FkaW5nID0gZnVuY3Rpb24odGV4dCwgbmVlZHNUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgIHZhciBtb2RhbENsb3NlZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1vZGFsU2hvd24gPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9ICdtbS5jb3JlLmxvYWRpbmcnO1xuICAgICAgICAgICAgICAgIG5lZWRzVHJhbnNsYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc2hvd01vZGFsKHRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1vZGFsQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICRpb25pY0xvYWRpbmcuc2hvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogICAnPGlvbi1zcGlubmVyPjwvaW9uLXNwaW5uZXI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHA+Jyt0ZXh0Kyc8L3A+J1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWxTaG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmVlZHNUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgICAgICAkdHJhbnNsYXRlKHRleHQpLnRoZW4oc2hvd01vZGFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hvd01vZGFsKHRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc21pc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RhbENsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RhbFNob3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaW9uaWNMb2FkaW5nLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgYSBtb2RhbCB3aXRoIGFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjc2hvd0Vycm9yTW9kYWxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yTWVzc2FnZSAgICBNZXNzYWdlIHRvIHNob3cuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVlZHNUcmFuc2xhdGUgVHJ1ZSBpZiB0aGUgZXJyb3JNZXNzYWdlIGlzIGEgJHRyYW5zbGF0ZSBrZXksIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFthdXRvY2xvc2VUaW1lXSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgdG8gY2xvc2UgdGhlIG1vZGFsLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBkZWZpbmVkLCBtb2RhbCB3b24ndCBiZSBhdXRvbWF0aWNhbGx5IGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuc2hvd0Vycm9yTW9kYWwgPSBmdW5jdGlvbihlcnJvck1lc3NhZ2UsIG5lZWRzVHJhbnNsYXRlLCBhdXRvY2xvc2VUaW1lKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JLZXkgPSAnbW0uY29yZS5lcnJvcicsXG4gICAgICAgICAgICAgICAgbGFuZ0tleXMgPSBbZXJyb3JLZXldO1xuXG4gICAgICAgICAgICBpZiAobmVlZHNUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgICAgICBsYW5nS2V5cy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICR0cmFuc2xhdGUobGFuZ0tleXMpLnRoZW4oZnVuY3Rpb24odHJhbnNsYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcHVwID0gJGlvbmljUG9wdXAuYWxlcnQoe1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdHJhbnNsYXRpb25zW2Vycm9yS2V5XSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IG5lZWRzVHJhbnNsYXRlID8gdHJhbnNsYXRpb25zW2Vycm9yTWVzc2FnZV0gOiBlcnJvck1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXV0b2Nsb3NlVGltZSAhPSAndW5kZWZpbmVkJyAmJiAhaXNOYU4ocGFyc2VJbnQoYXV0b2Nsb3NlVGltZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXAuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcGFyc2VJbnQoYXV0b2Nsb3NlVGltZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwb3B1cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBhIG1vZGFsIHdpdGggYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNzaG93TW9kYWxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlICAgICAgICBMYW5ndWFnZSBrZXkuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlICAgICAgTGFuZ3VhZ2Uga2V5LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5zaG93TW9kYWwgPSBmdW5jdGlvbih0aXRsZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW1xuICAgICAgICAgICAgICAgICR0cmFuc2xhdGUodGl0bGUpLFxuICAgICAgICAgICAgICAgICR0cmFuc2xhdGUobWVzc2FnZSksXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24odHJhbnNsYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgJGlvbmljUG9wdXAuYWxlcnQoe1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdHJhbnNsYXRpb25zWzBdLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdHJhbnNsYXRpb25zWzFdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBhIGNvbmZpcm0gbW9kYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjc2hvd0NvbmZpcm1cbiAgICAgICAgICogQHBhcmFtICB7TWl4ZWR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHNob3cgaW4gdGhlIG1vZGFsIGJvZHkuIENhbiBiZSBhIHN0cmluZyBvciBhIHByb21pc2UuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIGlmIHRoZSB1c2VyIGNvbmZpcm1zIGFuZCByZWplY3RlZCBpZiBoZSBjYW5jZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5zaG93Q29uZmlybSA9IGZ1bmN0aW9uKHRlbXBsYXRlLCB0aXRsZSkge1xuICAgICAgICAgICAgdmFyIG9rID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLnllcycpLFxuICAgICAgICAgICAgICAgIGNhbmNlbCA9ICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS5ubycpO1xuXG4gICAgICAgICAgICByZXR1cm4gJGlvbmljUG9wdXAuY29uZmlybSh7dGVtcGxhdGU6IHRlbXBsYXRlLCB0aXRsZTogdGl0bGUsIG9rVGV4dDogb2ssIGNhbmNlbFRleHQ6IGNhbmNlbH0pLnRoZW4oZnVuY3Rpb24oY29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IGEgcHJvbXB0IG1vZGFsIHRvIGlucHV0IHNvbWUgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNzaG93UHJvbXB0XG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gYm9keSAgICAgICAgICAgICBNb2RhbCBib2R5LlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlICAgICAgICAgICAgTW9kYWwgdGl0bGUuXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gaW5wdXRQbGFjZWhvbGRlciBQbGFjZWhvbGRlciBvZiB0aGUgaW5wdXQgYm94LiBCeSBkZWZhdWx0LCBcIlBhc3N3b3JkXCIuXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gW2lucHV0VHlwZV0gICAgICBUeXBlIG9mIHRoZSBpbnB1dCBib3guIEJ5IGRlZmF1bHQsIHBhc3N3b3JkLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBpbnB1dCBkYXRhIGlmIHRoZSB1c2VyIGNsaWNrcyBPSywgcmVqZWN0ZWQgaWYgY2FuY2Vscy5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuc2hvd1Byb21wdCA9IGZ1bmN0aW9uKGJvZHksIHRpdGxlLCBpbnB1dFBsYWNlaG9sZGVyLCBpbnB1dFR5cGUpIHtcbiAgICAgICAgICAgIGlucHV0VHlwZSA9IGlucHV0VHlwZSB8fCAncGFzc3dvcmQnO1xuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYm9keSxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAgICAgaW5wdXRQbGFjZWhvbGRlcjogaW5wdXRQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBpbnB1dFR5cGU6IGlucHV0VHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAkaW9uaWNQb3B1cC5wcm9tcHQob3B0aW9ucykudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZHMgYW5kIHBhcnNlcyBhIEpTT04gZmlsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNyZWFkSlNPTkZpbGVcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoIFBhdGggdG8gdGhlIGZpbGUuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIGZpbGUgaXMgcGFyc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5yZWFkSlNPTkZpbGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KHBhdGgpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY291bnRyeSBuYW1lIGJhc2VkIG9uIGNvdW50cnkgY29kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNnZXRDb3VudHJ5TmFtZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZSBDb3VudHJ5IGNvZGUgKEFGLCBFUywgVVMsIC4uLikuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIENvdW50cnkgbmFtZS4gSWYgdGhlIGNvdW50cnkgaXMgbm90IGZvdW5kLCByZXR1cm4gdGhlIGNvdW50cnkgY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q291bnRyeU5hbWUgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgICAgICAgICB2YXIgY291bnRyeUtleSA9ICdtbS5jb3JlLmNvdW50cnktJyArIGNvZGUsXG4gICAgICAgICAgICAgICAgY291bnRyeU5hbWUgPSAkdHJhbnNsYXRlLmluc3RhbnQoY291bnRyeUtleSk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb3VudHJ5TmFtZSAhPT0gY291bnRyeUtleSA/IGNvdW50cnlOYW1lIDogY29kZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgVVJMIHRvIHRoZSBkb2N1bWVudGF0aW9uIG9mIHRoZSBhcHAsIGJhc2VkIG9uIE1vb2RsZSB2ZXJzaW9uIGFuZCBjdXJyZW50IGxhbmd1YWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlbGVhc2VdIE1vb2RsZSByZWxlYXNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhZ2VdICAgIERvY3MgcGFnZSB0byBnbyB0by5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIE1vb2RsZSBkb2NzIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0RG9jc1VybCA9IGZ1bmN0aW9uKHJlbGVhc2UsIHBhZ2UpIHtcbiAgICAgICAgICAgIHBhZ2UgPSBwYWdlIHx8wqAnTW9iaWxlX2FwcCc7XG5cbiAgICAgICAgICAgIHZhciBkb2NzdXJsID0gJ2h0dHBzOi8vZG9jcy5tb29kbGUub3JnL2VuLycgKyBwYWdlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlbGVhc2UgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmVyc2lvbiA9IHJlbGVhc2Uuc3Vic3RyKDAsIDMpLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlzIGEgdmFsaWQgbnVtYmVyLlxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUludCh2ZXJzaW9uKSA+PSAyNCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgcmVsZWFzZSBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGRvY3N1cmwgPSBkb2NzdXJsLnJlcGxhY2UoJ2h0dHBzOi8vZG9jcy5tb29kbGUub3JnLycsICdodHRwczovL2RvY3MubW9vZGxlLm9yZy8nICsgdmVyc2lvbiArICcvJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb2NzdXJsID0gJ2h0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL21pcmFjbGVmaXNoLmNvbS9iaXJrYmVjay8nO1xuXG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy5nZXRDdXJyZW50TGFuZ3VhZ2UoKS50aGVuKGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jc3VybC5yZXBsYWNlKCcvZW4vJywgJy8nICsgbGFuZyArICcvJyk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jc3VybDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgdGltZXN0YW1wIChVTklYIGZvcm1hdCwgc2Vjb25kcykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjdGltZXN0YW1wXG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgdGltZXN0YW1wIGluIHNlY29uZHMuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHBhcmFtIGlzIGZhbHNlIChib29sKSwgMCAobnVtYmVyKSBvciBcIjBcIiAoc3RyaW5nKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNpc0ZhbHNlT3JaZXJvXG4gICAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFZhbHVlIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBUcnVlIGlmIHZhbHVlIGlzIGZhbHNlLCAwIG9yIFwiMFwiLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0ZhbHNlT3JaZXJvID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT0gJ3VuZGVmaW5lZCcgJiYgKHZhbHVlID09PSBmYWxzZSB8fCBwYXJzZUludCh2YWx1ZSkgPT09IDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcGFyYW0gaXMgdHJ1ZSAoYm9vbCksIDEgKG51bWJlcikgb3IgXCIxXCIgKHN0cmluZykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjaXNUcnVlT3JPbmVcbiAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVmFsdWUgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgIFRydWUgaWYgdmFsdWUgaXMgdHJ1ZSwgMSBvciBcIjFcIi5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNUcnVlT3JPbmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPSAndW5kZWZpbmVkJyAmJiAodmFsdWUgPT09IHRydWUgfHwgcGFyc2VJbnQodmFsdWUpID09PSAxKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBob3VycywgbWludXRlcyBhbmQgc2Vjb25kcyBpbiBhIGh1bWFuIHJlYWRhYmxlIGZvcm1hdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2Zvcm1hdFRpbWVcbiAgICAgICAgICogQHBhcmFtICB7SW50ZWdlcn0gc2Vjb25kcyBBIG51bWJlciBvZiBzZWNvbmRzXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBIdW1hbiByZWFkYWJsZSBzZWNvbmRzIGZvcm1hdHRlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5mb3JtYXRUaW1lID0gZnVuY3Rpb24oc2Vjb25kcykge1xuICAgICAgICAgICAgdmFyIGxhbmdLZXlzID0gWydtbS5jb3JlLmRheScsICdtbS5jb3JlLmRheXMnLCAnbW0uY29yZS5ob3VyJywgJ21tLmNvcmUuaG91cnMnLCAnbW0uY29yZS5taW4nLCAnbW0uY29yZS5taW5zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbW0uY29yZS5zZWMnLCAnbW0uY29yZS5zZWNzJywgJ21tLmNvcmUueWVhcicsICdtbS5jb3JlLnllYXJzJywgJ21tLmNvcmUubm93J107XG5cbiAgICAgICAgICAgIHJldHVybiAkdHJhbnNsYXRlKGxhbmdLZXlzKS50aGVuKGZ1bmN0aW9uKHRyYW5zbGF0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgdG90YWxTZWNzID0gTWF0aC5hYnMoc2Vjb25kcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgeWVhcnMgICAgID0gTWF0aC5mbG9vcih0b3RhbFNlY3MgLyBtbUNvcmVTZWNvbmRzWWVhcik7XG4gICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IHRvdGFsU2VjcyAtICh5ZWFycyAqIG1tQ29yZVNlY29uZHNZZWFyKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF5cyAgICAgID0gTWF0aC5mbG9vcihyZW1haW5kZXIgLyBtbUNvcmVTZWNvbmRzRGF5KTtcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSB0b3RhbFNlY3MgLSAoZGF5cyAqIG1tQ29yZVNlY29uZHNEYXkpO1xuICAgICAgICAgICAgICAgIHZhciBob3VycyAgICAgPSBNYXRoLmZsb29yKHJlbWFpbmRlciAvIG1tQ29yZVNlY29uZHNIb3VyKTtcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSByZW1haW5kZXIgLSAoaG91cnMgKiBtbUNvcmVTZWNvbmRzSG91cik7XG4gICAgICAgICAgICAgICAgdmFyIG1pbnMgICAgICA9IE1hdGguZmxvb3IocmVtYWluZGVyIC8gbW1Db3JlU2Vjb25kc01pbnV0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHNlY3MgICAgICA9IHJlbWFpbmRlciAtIChtaW5zICogbW1Db3JlU2Vjb25kc01pbnV0ZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3MgPSAoc2VjcyA9PSAxKSAgPyB0cmFuc2xhdGlvbnNbJ21tLmNvcmUuc2VjJ10gIDogdHJhbnNsYXRpb25zWydtbS5jb3JlLnNlY3MnXTtcbiAgICAgICAgICAgICAgICB2YXIgc20gPSAobWlucyA9PSAxKSAgPyB0cmFuc2xhdGlvbnNbJ21tLmNvcmUubWluJ10gIDogdHJhbnNsYXRpb25zWydtbS5jb3JlLm1pbnMnXTtcbiAgICAgICAgICAgICAgICB2YXIgc2ggPSAoaG91cnMgPT0gMSkgPyB0cmFuc2xhdGlvbnNbJ21tLmNvcmUuaG91ciddIDogdHJhbnNsYXRpb25zWydtbS5jb3JlLmhvdXJzJ107XG4gICAgICAgICAgICAgICAgdmFyIHNkID0gKGRheXMgPT0gMSkgID8gdHJhbnNsYXRpb25zWydtbS5jb3JlLmRheSddICA6IHRyYW5zbGF0aW9uc1snbW0uY29yZS5kYXlzJ107XG4gICAgICAgICAgICAgICAgdmFyIHN5ID0gKHllYXJzID09IDEpID8gdHJhbnNsYXRpb25zWydtbS5jb3JlLnllYXInXSA6IHRyYW5zbGF0aW9uc1snbW0uY29yZS55ZWFycyddO1xuXG4gICAgICAgICAgICAgICAgdmFyIG95ZWFycyA9ICcnLFxuICAgICAgICAgICAgICAgICAgICBvZGF5cyA9ICcnLFxuICAgICAgICAgICAgICAgICAgICBvaG91cnMgPSAnJyxcbiAgICAgICAgICAgICAgICAgICAgb21pbnMgPSAnJyxcbiAgICAgICAgICAgICAgICAgICAgb3NlY3MgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmICh5ZWFycykge1xuICAgICAgICAgICAgICAgICAgICBveWVhcnMgID0geWVhcnMgKyAnICcgKyBzeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2RheXMgID0gZGF5cyArICcgJyArIHNkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaG91cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2hvdXJzID0gaG91cnMgKyAnICcgKyBzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1pbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb21pbnMgID0gbWlucyArICcgJyArIHNtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2Vjcykge1xuICAgICAgICAgICAgICAgICAgICBvc2VjcyAgPSBzZWNzICsgJyAnICsgc3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHllYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBveWVhcnMgKyAnICcgKyBvZGF5cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9kYXlzICsgJyAnICsgb2hvdXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaG91cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ob3VycyArICcgJyArIG9taW5zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWlucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb21pbnMgKyAnICcgKyBvc2VjcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9zZWNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb25zWydtbS5jb3JlLm5vdyddO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtcHRpZXMgYW4gYXJyYXkgd2l0aG91dCBsb3NpbmcgaXRzIHJlZmVyZW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNlbXB0eUFycmF5XG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJheSBBcnJheSB0byBlbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZW1wdHlBcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICBhcnJheS5sZW5ndGggPSAwOyAvLyBFbXB0eSBhcnJheSB3aXRob3V0IGxvc2luZyBpdHMgcmVmZXJlbmNlLlxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaW1pbGFyIHRvICRxLmFsbCwgYnV0IGlmIGEgcHJvbWlzZSBmYWlscyB0aGlzIGZ1bmN0aW9uJ3MgcHJvbWlzZSB3b24ndCBiZSByZWplY3RlZCB1bnRpbCBBTEwgcHJvbWlzZXMgaGF2ZSBmaW5pc2hlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNhbGxQcm9taXNlc1xuICAgICAgICAgKiBAcGFyYW0gIHtQcm9taXNlW119IHByb21pc2VzIFByb21pc2VzLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgaWYgYWxsIHByb21pc2VzIGFyZSByZXNvbHZlZCBhbmQgcmVqZWN0ZWQgaWYgYXQgbGVhc3QgMSBwcm9taXNlIGZhaWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5hbGxQcm9taXNlcyA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gICAgICAgICAgICBpZiAoIXByb21pc2VzIHx8ICFwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgICAgICAgIGZhaWxlZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHByb21pc2VzLCBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gcHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgcHJvbWlzZXMgaGF2ZSBmaW5pc2hlZCwgcmVqZWN0L3Jlc29sdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIHR3byBvYmplY3RzLiBUaGlzIGZ1bmN0aW9uIHdvbid0IGNvbXBhcmUgZnVuY3Rpb25zIGFuZCBwcm90byBwcm9wZXJ0aWVzLCBpdCdzIGEgYmFzaWMgY29tcGFyZS5cbiAgICAgICAgICogQWxzbywgdGhpcyB3aWxsIG9ubHkgY2hlY2sgaWYgaXRlbUEncyBwcm9wZXJ0aWVzIGFyZSBpbiBpdGVtQiB3aXRoIHNhbWUgdmFsdWUuIFRoaXMgZnVuY3Rpb24gd2lsbCBzdGlsbFxuICAgICAgICAgKiByZXR1cm4gdHJ1ZSBpZiBpdGVtQiBoYXMgbW9yZSBwcm9wZXJ0aWVzIHRoYW4gaXRlbUEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVV0aWwjYmFzaWNMZWZ0Q29tcGFyZVxuICAgICAgICAgKiBAcGFyYW0ge01peGVkfSAgaXRlbUEgICAgICAgICBGaXJzdCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7TWl4ZWR9ICBpdGVtQiAgICAgICAgIFNlY29uZCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4TGV2ZWxzPTBdIE51bWJlciBvZiBsZXZlbHMgdG8gcmVhY2ggaWYgMiBvYmplY3RzIGFyZSBjb21wYXJlZC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsZXZlbD0wXSAgICAgQ3VycmVudCBkZWVwIGxldmVsICh3aGVuIGNvbXBhcmluZyBvYmplY3RzKS5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgVHJ1ZSBpZiBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5iYXNpY0xlZnRDb21wYXJlID0gZnVuY3Rpb24oaXRlbUEsIGl0ZW1CLCBtYXhMZXZlbHMsIGxldmVsKSB7XG4gICAgICAgICAgICBsZXZlbCA9IGxldmVsIHx8wqAwO1xuICAgICAgICAgICAgbWF4TGV2ZWxzID0gbWF4TGV2ZWxzwqB8fCAwO1xuXG4gICAgICAgICAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKGl0ZW1BKSB8fMKgYW5ndWxhci5pc0Z1bmN0aW9uKGl0ZW1CKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBEb24ndCBjb21wYXJlIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc09iamVjdChpdGVtQSkgJiYgYW5ndWxhci5pc09iamVjdChpdGVtQikpIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gbWF4TGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBNYXggZGVlcCByZWFjaGVkLlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGl0ZW1BLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuYmFzaWNMZWZ0Q29tcGFyZSh2YWx1ZSwgaXRlbUJbbmFtZV0sIG1heExldmVscywgbGV2ZWwgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UnbGwgdHJlYXQgXCIyXCIgYW5kIDIgYXMgdGhlIHNhbWUgdmFsdWUuXG4gICAgICAgICAgICAgICAgdmFyIGZsb2F0QSA9IHBhcnNlRmxvYXQoaXRlbUEpLFxuICAgICAgICAgICAgICAgICAgICBmbG9hdEIgPSBwYXJzZUZsb2F0KGl0ZW1CKTtcblxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oZmxvYXRBKSAmJiAhaXNOYU4oZmxvYXRCKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvYXRBID09IGZsb2F0QjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1BID09PSBpdGVtQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGRvd25sb2FkIHNpemUgaXMgaGlnaGVyIHRoYW4gYSBjZXJ0YWluIHRocmVzaG9sZCBzaG93cyBhIGNvbmZpcm0gZGlhbG9nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2NvbmZpcm1Eb3dubG9hZFNpemVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgICAgICAgICAgICAgICAgIFNpemUgdG8gZG93bmxvYWQgKGluIGJ5dGVzKS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSAgICAgICAgICAgIENvZGUgb2YgdGhlIG1lc3NhZ2UgdG8gc2hvdy4gRGVmYXVsdDogJ21tLmNvdXJzZS5jb25maXJtZG93bmxvYWQnLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3Vua25vd25zaXplbWVzc2FnZV0gQ29kZSBvZiB0aGUgbWVzc2FnZSB0byBzaG93IGlmIHNpemUgaXMgdW5rbm93bi5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQ6ICdtbS5jb3Vyc2UuY29uZmlybWRvd25sb2FkdW5rbm93bnNpemUnLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZmlUaHJlc2hvbGRdICAgICAgVGhyZXNob2xkIHRvIHNob3cgY29uZmlybSBpbiBXaUZpIGNvbm5lY3Rpb24uIERlZmF1bHQ6IG1tQ29yZVdpZmlEb3dubG9hZFRocmVzaG9sZC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdGVkVGhyZXNob2xkXSAgIFRocmVzaG9sZCB0byBzaG93IGNvbmZpcm0gaW4gbGltaXRlZCBjb25uZWN0aW9uLiBEZWZhdWx0OiBtbUNvcmVEb3dubG9hZFRocmVzaG9sZC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSB1c2VyIGNvbmZpcm1zIG9yIGlmIG5vIGNvbmZpcm0gbmVlZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5jb25maXJtRG93bmxvYWRTaXplID0gZnVuY3Rpb24oc2l6ZSwgbWVzc2FnZSwgdW5rbm93bnNpemVtZXNzYWdlLCB3aWZpVGhyZXNob2xkLCBsaW1pdGVkVGhyZXNob2xkKSB7XG4gICAgICAgICAgICB3aWZpVGhyZXNob2xkID0gdHlwZW9mIHdpZmlUaHJlc2hvbGQgPT0gJ3VuZGVmaW5lZCcgPyBtbUNvcmVXaWZpRG93bmxvYWRUaHJlc2hvbGQgOiB3aWZpVGhyZXNob2xkO1xuICAgICAgICAgICAgbGltaXRlZFRocmVzaG9sZCA9IHR5cGVvZiBsaW1pdGVkVGhyZXNob2xkID09ICd1bmRlZmluZWQnID8gbW1Db3JlRG93bmxvYWRUaHJlc2hvbGQgOiBsaW1pdGVkVGhyZXNob2xkO1xuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHzCoCdtbS5jb3Vyc2UuY29uZmlybWRvd25sb2FkJztcbiAgICAgICAgICAgIHVua25vd25zaXplbWVzc2FnZSA9IHVua25vd25zaXplbWVzc2FnZSB8fMKgJ21tLmNvdXJzZS5jb25maXJtZG93bmxvYWR1bmtub3duc2l6ZSc7XG5cbiAgICAgICAgICAgIGlmIChzaXplIDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTZWVtcyBzaXplIHdhcyB1bmFibGUgdG8gYmUgY2FsY3VsYXRlZC4gU2hvdyBhIHdhcm5pbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSh1bmtub3duc2l6ZW1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPj0gd2lmaVRocmVzaG9sZCB8fCAoJG1tQXBwLmlzTmV0d29ya0FjY2Vzc0xpbWl0ZWQoKSAmJiBzaXplID49IGxpbWl0ZWRUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRhYmxlU2l6ZSA9ICRtbVRleHQuYnl0ZXNUb1NpemUoc2l6ZSwgMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZShtZXNzYWdlLCB7c2l6ZTogcmVhZGFibGVTaXplfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybWF0cyBhIHNpemUgdG8gYmUgdXNlZCBhcyB3aWR0aC9oZWlnaHQgb2YgYW4gZWxlbWVudC5cbiAgICAgICAgICogSWYgdGhlIHNpemUgaXMgYWxyZWFkeSB2YWxpZCAobGlrZSAnNTAwcHgnIG9yICc1MCUnKSBpdCB3b24ndCBiZSBtb2RpZmllZC5cbiAgICAgICAgICogUmV0dXJuZWQgc2l6ZSB3aWxsIGhhdmUgYSBmb3JtYXQgbGlrZSAnNTAwcHgnLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2Zvcm1hdFBpeGVsc1NpemVcbiAgICAgICAgICogQHBhcmFtICB7TWl4ZWR9IHNpemUgU2l6ZSB0byBmb3JtYXQuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIEZvcm1hdHRlZCBzaXplLiBJZiBzaXplIGlzIG5vdCB2YWxpZCwgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmZvcm1hdFBpeGVsc1NpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNpemUgPT0gJ3N0cmluZycgJiYgKHNpemUuaW5kZXhPZigncHgnKSA+IC0xIHx8IHNpemUuaW5kZXhPZignJScpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgc2VlbXMgdG8gYmUgYSB2YWxpZCBzaXplLlxuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICAgICAgICAgICAgaWYgKCFpc05hTihzaXplKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXplICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VyaWFsaXplIGFuIG9iamVjdCB0byBiZSB1c2VkIGluIGEgcmVxdWVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNwYXJhbVxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gc2VyaWFsaXplLlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBTZXJpYWxpemF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnBhcmFtID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIucGFyYW0ob2JqKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUm91bmRzIGEgbnVtYmVyIHRvIHVzZSBhIGNlcnRhaW4gYW1vdXQgb2YgZGVjaW1hbHMgb3IgbGVzcy5cbiAgICAgICAgICogRGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgZnVuY3Rpb24gYW5kIGZsb2F0J3MgdG9GaXhlZDpcbiAgICAgICAgICogNy50b0ZpeGVkKDIpIC0+IDcuMDBcbiAgICAgICAgICogcm91bmRUb0RlY2ltYWxzKDcsIDIpIC0+IDdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXRpbCNyb3VuZFRvRGVjaW1hbHNcbiAgICAgICAgICogQHBhcmFtICB7RmxvYXR9ICBudW1iZXIgICAgICAgRmxvYXQgdG8gcm91bmQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2RlY2ltYWxzPTJdIE51bWJlciBvZiBkZWNpbWFscy4gQnkgZGVmYXVsdCwgMi5cbiAgICAgICAgICogQHJldHVybiB7RmxvYXR9ICAgICAgICAgICAgICAgUm91bmRlZCBudW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnJvdW5kVG9EZWNpbWFscyA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVjaW1hbHMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFscyA9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobnVtYmVyKSAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0cmFjdHMgdGhlIHBhcmFtZXRlcnMgZnJvbSBhIFVSTCBhbmQgc3RvcmVzIHRoZW0gaW4gYW4gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1VdGlsI2V4dHJhY3RVcmxQYXJhbXNcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmwgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICBPYmplY3Qgd2l0aCB0aGUgcGFyYW1zLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5leHRyYWN0VXJsUGFyYW1zID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICB2YXIgcmVnZXggPSAvWz8mXSsoW149Jl0rKT0/KFteJl0qKT8vZ2ksXG4gICAgICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgICAgICB1cmwucmVwbGFjZShyZWdleCwgZnVuY3Rpb24obWF0Y2gsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6ICcnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogV2ViIHNlcnZpY2UgbW9kdWxlLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbVdTXG4gKi9cbi5mYWN0b3J5KCckbW1XUycsIGZ1bmN0aW9uKCRodHRwLCAkcSwgJGxvZywgJG1tTGFuZywgJGNvcmRvdmFGaWxlVHJhbnNmZXIsICRtbUFwcCwgJG1tRlMsICRtbVRleHQsIG1tQ29yZVNlc3Npb25FeHBpcmVkLFxuICAgICAgICAgICAgbW1Db3JlVXNlckRlbGV0ZWQsICR0cmFuc2xhdGUsICR3aW5kb3csICRtbVV0aWwpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1XUycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgd3JhcHBlciBmdW5jdGlvbiBmb3IgYSBtb29kbGUgV2ViU2VydmljZSBjYWxsLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVdTI2NhbGxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSBXZWJTZXJ2aWNlIG1ldGhvZCB0byBiZSBjYWxsZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlU2V0cyBFeHRyYSBzZXR0aW5ncyBhbmQgaW5mb3JtYXRpb24uXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gc2l0ZXVybCBzdHJpbmcgVGhlIHNpdGUgVVJMLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIHdzdG9rZW4gc3RyaW5nIFRoZSBXZWJzZXJ2aWNlIHRva2VuLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIHJlc3BvbnNlRXhwZWN0ZWQgYm9vbGVhbiBEZWZhdWx0cyB0byB0cnVlLiBTZXQgdG8gZmFsc2Ugd2hlbiB0aGUgZXhwZWN0ZWQgcmVzcG9uc2UgaXMgbnVsbC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSB0eXBlRXhwZWN0ZWQgc3RyaW5nIERlZmF1bHRzIHRvICdvYmplY3QnLiBVc2UgaXQgd2hlbiB5b3UgZXhwZWN0IGEgdHlwZSB0aGF0J3Mgbm90IGFuIG9iamVjdHxhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHJlc3BvbnNlIGRhdGEgaW4gc3VjY2VzcyBhbmQgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IgbWVzc2FnZSBpZiBpdCBmYWlscy5cbiAgICAgKi9cbiAgICBzZWxmLmNhbGwgPSBmdW5jdGlvbihtZXRob2QsIGRhdGEsIHByZVNldHMpIHtcblxuICAgICAgICB2YXIgc2l0ZXVybDtcblxuICAgICAgICBkYXRhID0gY29udmVydFZhbHVlc1RvU3RyaW5nKGRhdGEpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJlU2V0cyA9PSAndW5kZWZpbmVkJyB8fCBwcmVTZXRzID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHByZVNldHMud3N0b2tlbiA9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcHJlU2V0cy5zaXRldXJsID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmNvcmUudW5leHBlY3RlZGVycm9yJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoISRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmNvcmUubmV0d29ya2Vycm9ybXNnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmVTZXRzLnR5cGVFeHBlY3RlZCA9IHByZVNldHMudHlwZUV4cGVjdGVkIHx8ICdvYmplY3QnO1xuICAgICAgICBpZiAodHlwZW9mIHByZVNldHMucmVzcG9uc2VFeHBlY3RlZCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcHJlU2V0cy5yZXNwb25zZUV4cGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEud3NmdW5jdGlvbiA9IG1ldGhvZDtcbiAgICAgICAgZGF0YS53c3Rva2VuID0gcHJlU2V0cy53c3Rva2VuO1xuICAgICAgICBzaXRldXJsID0gcHJlU2V0cy5zaXRldXJsICsgJy93ZWJzZXJ2aWNlL3Jlc3Qvc2VydmVyLnBocD9tb29kbGV3c3Jlc3Rmb3JtYXQ9anNvbic7XG5cbiAgICAgICAgdmFyIGFqYXhEYXRhID0gZGF0YTtcblxuICAgICAgICByZXR1cm4gJGh0dHAucG9zdChzaXRldXJsLCBhamF4RGF0YSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgICAgIC8vIFNvbWUgbW9vZGxlIHdlYiBzZXJ2aWNlcyByZXR1cm4gbnVsbC5cbiAgICAgICAgICAgIC8vIElmIHRoZSByZXNwb25zZUV4cGVjdGVkIHZhbHVlIGlzIHNldCB0aGVuIHNvIGxvbmcgYXMgbm8gZGF0YVxuICAgICAgICAgICAgLy8gaXMgcmV0dXJuZWQsIHdlIGNyZWF0ZSBhIGJsYW5rIG9iamVjdC5cbiAgICAgICAgICAgIGlmICgoIWRhdGEgfHwgIWRhdGEuZGF0YSkgJiYgIXByZVNldHMucmVzcG9uc2VFeHBlY3RlZCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbS5jb3JlLnNlcnZlcmNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgIT0gcHJlU2V0cy50eXBlRXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAkbG9nLndhcm4oJ1Jlc3BvbnNlIG9mIHR5cGUgXCInICsgdHlwZW9mIGRhdGEgKyAnXCIgcmVjZWl2ZWQsIGV4cGVjdGluZyBcIicgKyBwcmVTZXRzLnR5cGVFeHBlY3RlZCArICdcIicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0uY29yZS5lcnJvcmludmFsaWRyZXNwb25zZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mKGRhdGEuZXhjZXB0aW9uKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvcmNvZGUgPT0gJ2ludmFsaWR0b2tlbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkYXRhLmVycm9yY29kZSA9PSAnYWNjZXNzZXhjZXB0aW9uJyAmJiBkYXRhLm1lc3NhZ2UuaW5kZXhPZignSW52YWxpZCB0b2tlbiAtIHRva2VuIGV4cGlyZWQnKSA+IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKFwiQ3JpdGljYWwgZXJyb3I6IFwiICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KG1tQ29yZVNlc3Npb25FeHBpcmVkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3Jjb2RlID09PSAndXNlcmRlbGV0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QobW1Db3JlVXNlckRlbGV0ZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YoZGF0YS5kZWJ1Z2luZm8pICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgnRXJyb3IuICcgKyBkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkbG9nLmluZm8oJ1dTOiBEYXRhIHJlY2VpdmVkIGZyb20gV1MgJyArIHR5cGVvZihkYXRhKSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YoZGF0YSkgPT0gJ29iamVjdCcgJiYgdHlwZW9mKGRhdGEubGVuZ3RoKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICRsb2cuaW5mbygnV1M6IERhdGEgbnVtYmVyIG9mIGVsZW1lbnRzICcrIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tLmNvcmUuc2VydmVyY29ubmVjdGlvbicpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0cyB2YWx1ZXMgdG8gc3RyaW5ncyB3aGVyZSBhcHByb3ByaWF0ZS5cbiAgICAgKiBBcnJheXMgKGFzc29jaWF0aXZlIG9yIG90aGVyd2lzZSkgd2lsbCBiZSBtYWludGFpbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgdGhhdCBuZWVkcyBhbGwgdGhlIG5vbi1vYmplY3QgdmFsdWVzIHNldCB0byBzdHJpbmdzLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsZWFuZWQgb2JqZWN0LCB3aXRoIG11bHRpbGV2ZWwgYXJyYXkgYW5kIG9iamVjdHMgcHJlc2VydmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZXNUb1N0cmluZyhkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKCFhbmd1bGFyLmlzQXJyYXkoZGF0YSkgJiYgYW5ndWxhci5pc09iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgZWwgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNPYmplY3QoZGF0YVtlbF0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2VsXSA9IGNvbnZlcnRWYWx1ZXNUb1N0cmluZyhkYXRhW2VsXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtlbF0gPSBkYXRhW2VsXSArICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgZmlsZSBmcm9tIE1vb2RsZSB1c2luZyBDb3Jkb3ZhIEZpbGUgQVBJLlxuICAgICAqIEB0b2RvIFVzZSBXZWIgV29ya2Vycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIHVybCAgICAgICAgRG93bmxvYWQgdXJsLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIHBhdGggICAgICAgTG9jYWwgcGF0aCB0byBzdG9yZSB0aGUgZmlsZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICBiYWNrZ3JvdW5kIFRydWUgaWYgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgZXhlY3V0ZWQgaW4gYmFja2dyb3VuZCB1c2luZyBXZWIgV29ya2Vycy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFRoZSBzdWNjZXNzIHJldHVybnMgdGhlIGZpbGVFbnRyeSwgdGhlIHJlamVjdCB3aWxsIGNvbnRhaW4gdGhlIGVycm9yIG9iamVjdC5cbiAgICAgKi9cbiAgICBzZWxmLmRvd25sb2FkRmlsZSA9IGZ1bmN0aW9uKHVybCwgcGF0aCwgYmFja2dyb3VuZCkge1xuICAgICAgICAkbG9nLmRlYnVnKCdEb3dubG9hZGluZyBmaWxlICcgKyB1cmwpO1xuXG4gICAgICAgIHJldHVybiAkbW1GUy5nZXRCYXNlUGF0aFRvRG93bmxvYWQoKS50aGVuKGZ1bmN0aW9uKGJhc2VQYXRoKSB7XG4gICAgICAgICAgICAvLyBVc2UgYSB0bXAgcGF0aCB0byBkb3dubG9hZCB0aGUgZmlsZSBhbmQgdGhlbiBtb3ZlIGl0IHRvIGZpbmFsIGxvY2F0aW9uLiBUaGlzIGlzIGJlY2F1c2UgaWYgdGhlIGRvd25sb2FkIGZhaWxzLFxuICAgICAgICAgICAgLy8gdGhlIGxvY2FsIGZpbGUgaXMgZGVsZXRlZC5cbiAgICAgICAgICAgIHZhciB0bXBQYXRoID0gYmFzZVBhdGggKyBwYXRoICsgJy50bXAnO1xuICAgICAgICAgICAgcmV0dXJuICRjb3Jkb3ZhRmlsZVRyYW5zZmVyLmRvd25sb2FkKHVybCwgdG1wUGF0aCwgeyBlbmNvZGVVUkk6IGZhbHNlIH0sIHRydWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUZTLm1vdmVGaWxlKHBhdGggKyAnLnRtcCcsIHBhdGgpLnRoZW4oZnVuY3Rpb24obW92ZWRFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdTdWNjZXNzIGRvd25sb2FkaW5nIGZpbGUgJyArIHVybCArICcgdG8gJyArIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW92ZWRFbnRyeTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIGRvd25sb2FkaW5nICcgKyB1cmwgKyAnIHRvICcgKyBwYXRoKTtcbiAgICAgICAgICAgICAgICAkbG9nLmVycm9yKEpTT04uc3RyaW5naWZ5KGVycikpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSB1c2luZyBDb3Jkb3ZhIEZpbGUgQVBJLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVdTI3VwbG9hZEZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXJpIEZpbGUgVVJJLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEZpbGUgc2V0dGluZ3M6IGZpbGVLZXksIGZpbGVOYW1lIGFuZCBtaW1lVHlwZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlc2V0cyBDb250YWlucyBzaXRldXJsIGFuZCB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYudXBsb2FkRmlsZSA9IGZ1bmN0aW9uKHVyaSwgb3B0aW9ucywgcHJlc2V0cykge1xuICAgICAgICAkbG9nLmRlYnVnKCdUcnlpbmcgdG8gdXBsb2FkIGZpbGU6ICcgKyB1cmkpO1xuXG4gICAgICAgIHZhciBmdE9wdGlvbnMgPSB7fSxcbiAgICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICBmdE9wdGlvbnMuZmlsZUtleSA9IG9wdGlvbnMuZmlsZUtleTtcbiAgICAgICAgZnRPcHRpb25zLmZpbGVOYW1lID0gb3B0aW9ucy5maWxlTmFtZTtcbiAgICAgICAgZnRPcHRpb25zLmh0dHBNZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGZ0T3B0aW9ucy5taW1lVHlwZSA9IG9wdGlvbnMubWltZVR5cGU7XG4gICAgICAgIGZ0T3B0aW9ucy5wYXJhbXMgPSB7XG4gICAgICAgICAgICB0b2tlbjogcHJlc2V0cy50b2tlblxuICAgICAgICB9O1xuICAgICAgICBmdE9wdGlvbnMuY2h1bmtlZE1vZGUgPSBmYWxzZTtcbiAgICAgICAgZnRPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICBDb25uZWN0aW9uOiBcImNsb3NlXCJcbiAgICAgICAgfTtcblxuICAgICAgICAkbG9nLmRlYnVnKCdJbml0aWFsaXppbmcgdXBsb2FkJyk7XG4gICAgICAgICRjb3Jkb3ZhRmlsZVRyYW5zZmVyLnVwbG9hZChwcmVzZXRzLnNpdGV1cmwgKyAnL3dlYnNlcnZpY2UvdXBsb2FkLnBocCcsIHVyaSwgZnRPcHRpb25zLCB0cnVlKS50aGVuKGZ1bmN0aW9uKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1N1Y2Nlc3NmdWxseSB1cGxvYWRlZCBmaWxlJyk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHN1Y2Nlc3MpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3Igd2hpbGUgdXBsb2FkaW5nIGZpbGU6ICcgKyBlcnJvci5leGNlcHRpb24pO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSwgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShwcm9ncmVzcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFBlcmZvcm0gYSBIRUFEIHJlcXVlc3QgdG8gZ2V0IHRoZSBzaXplIG9mIGEgcmVtb3RlIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tV1MjZ2V0UmVtb3RlRmlsZVNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXJpIEZpbGUgVVJJLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBzaXplIG9yIC0xIGlmIGZhaWx1cmUuXG4gICAgICovXG4gICAgc2VsZi5nZXRSZW1vdGVGaWxlU2l6ZSA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICByZXR1cm4gJGh0dHAuaGVhZCh1cmwpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludChkYXRhLmhlYWRlcnMoJ0NvbnRlbnQtTGVuZ3RoJyksIDEwKTtcbiAgICAgICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGZ1bmN0aW9uIGZvciBhIHN5bmNocm9ub3VzIE1vb2RsZSBXZWJTZXJ2aWNlIGNhbGwuXG4gICAgICogV2FybmluZzogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSB1c2VkIGlmIHN5bmNocm9ub3VzIGlzIGEgbXVzdC4gSXQncyByZWNvbW1lbmRlZCB0byB1c2UgJG1tV1MjY2FsbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1XUyNzeW5jQ2FsbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIFdlYlNlcnZpY2UgbWV0aG9kIHRvIGJlIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVTZXRzIEV4dHJhIHNldHRpbmdzIGFuZCBpbmZvcm1hdGlvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBzaXRldXJsIHN0cmluZyBUaGUgc2l0ZSBVUkwuXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gd3N0b2tlbiBzdHJpbmcgVGhlIFdlYnNlcnZpY2UgdG9rZW4uXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gcmVzcG9uc2VFeHBlY3RlZCBib29sZWFuIERlZmF1bHRzIHRvIHRydWUuIFNldCB0byBmYWxzZSB3aGVuIHRoZSBleHBlY3RlZCByZXNwb25zZSBpcyBudWxsLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIHR5cGVFeHBlY3RlZCBzdHJpbmcgRGVmYXVsdHMgdG8gJ29iamVjdCcuIFVzZSBpdCB3aGVuIHlvdSBleHBlY3QgYSB0eXBlIHRoYXQncyBub3QgYW4gb2JqZWN0fGFycmF5LlxuICAgICAqIEByZXR1cm4ge01peGVkfSBSZXF1ZXN0IHJlc3BvbnNlLiBJZiB0aGUgcmVxdWVzdCBmYWlscywgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCAnZXJyb3InPXRydWUgYW5kICdtZXNzYWdlJyBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNlbGYuc3luY0NhbGwgPSBmdW5jdGlvbihtZXRob2QsIGRhdGEsIHByZVNldHMpIHtcbiAgICAgICAgdmFyIHNpdGV1cmwsXG4gICAgICAgICAgICB4aHIsXG4gICAgICAgICAgICBlcnJvclJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGRhdGEgPSBjb252ZXJ0VmFsdWVzVG9TdHJpbmcoZGF0YSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVTZXRzID09ICd1bmRlZmluZWQnIHx8IHByZVNldHMgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJlU2V0cy53c3Rva2VuID09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcmVTZXRzLnNpdGV1cmwgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGVycm9yUmVzcG9uc2UubWVzc2FnZSA9ICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS51bmV4cGVjdGVkZXJyb3InKTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvclJlc3BvbnNlO1xuICAgICAgICB9IGVsc2UgaWYgKCEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgZXJyb3JSZXNwb25zZS5tZXNzYWdlID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLm5ldHdvcmtlcnJvcm1zZycpO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yUmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmVTZXRzLnR5cGVFeHBlY3RlZCA9IHByZVNldHMudHlwZUV4cGVjdGVkIHx8ICdvYmplY3QnO1xuICAgICAgICBpZiAodHlwZW9mIHByZVNldHMucmVzcG9uc2VFeHBlY3RlZCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcHJlU2V0cy5yZXNwb25zZUV4cGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEud3NmdW5jdGlvbiA9IG1ldGhvZDtcbiAgICAgICAgZGF0YS53c3Rva2VuID0gcHJlU2V0cy53c3Rva2VuO1xuICAgICAgICBzaXRldXJsID0gcHJlU2V0cy5zaXRldXJsICsgJy93ZWJzZXJ2aWNlL3Jlc3Qvc2VydmVyLnBocD9tb29kbGV3c3Jlc3Rmb3JtYXQ9anNvbic7XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIGRhdGEuXG4gICAgICAgIGRhdGEgPSAkbW1VdGlsLnBhcmFtKGRhdGEpO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gc3luYyByZXF1ZXN0IHVzaW5nIFhNTEh0dHBSZXF1ZXN0LlxuICAgICAgICB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbigncG9zdCcsIHNpdGV1cmwsIGZhbHNlKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuXG4gICAgICAgIHhoci5zZW5kKGRhdGEpO1xuXG4gICAgICAgIC8vIEdldCByZXNwb25zZS5cbiAgICAgICAgZGF0YSA9ICgncmVzcG9uc2UnIGluIHhocikgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuXG4gICAgICAgIC8vIENoZWNrIHN0YXR1cy5cbiAgICAgICAgeGhyLnN0YXR1cyA9IE1hdGgubWF4KHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzLCAwKTtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPCAyMDAgfHwgeGhyLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgZmFpbGVkLlxuICAgICAgICAgICAgZXJyb3JSZXNwb25zZS5tZXNzYWdlID0gZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvclJlc3BvbnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJlYXQgcmVzcG9uc2UuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfSBjYXRjaChleCkge31cblxuICAgICAgICAvLyBTb21lIG1vb2RsZSB3ZWIgc2VydmljZXMgcmV0dXJuIG51bGwuXG4gICAgICAgIC8vIElmIHRoZSByZXNwb25zZUV4cGVjdGVkIHZhbHVlIGlzIHNldCB0aGVuIHNvIGxvbmcgYXMgbm8gZGF0YSBpcyByZXR1cm5lZCwgd2UgY3JlYXRlIGEgYmxhbmsgb2JqZWN0LlxuICAgICAgICBpZiAoKCFkYXRhIHx8ICFkYXRhLmRhdGEpICYmICFwcmVTZXRzLnJlc3BvbnNlRXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZXJyb3JSZXNwb25zZS5tZXNzYWdlID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLnNlcnZlcmNvbm5lY3Rpb24nKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSAhPSBwcmVTZXRzLnR5cGVFeHBlY3RlZCkge1xuICAgICAgICAgICAgJGxvZy53YXJuKCdSZXNwb25zZSBvZiB0eXBlIFwiJyArIHR5cGVvZiBkYXRhICsgJ1wiIHJlY2VpdmVkLCBleHBlY3RpbmcgXCInICsgcHJlU2V0cy50eXBlRXhwZWN0ZWQgKyAnXCInKTtcbiAgICAgICAgICAgIGVycm9yUmVzcG9uc2UubWVzc2FnZSA9ICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS5lcnJvcmludmFsaWRyZXNwb25zZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV4Y2VwdGlvbiAhPSAndW5kZWZpbmVkJyB8fMKgdHlwZW9mIGRhdGEuZGVidWdpbmZvICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBlcnJvclJlc3BvbnNlLm1lc3NhZ2UgPSBkYXRhLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3JSZXNwb25zZS5tZXNzYWdlICE9PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yUmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICAkbG9nLmluZm8oJ1N5bmNocm9ub3VzOiBEYXRhIHJlY2VpdmVkIGZyb20gV1MgJyArIHR5cGVvZiBkYXRhKTtcblxuICAgICAgICBpZiAodHlwZW9mKGRhdGEpID09ICdvYmplY3QnICYmIHR5cGVvZihkYXRhLmxlbmd0aCkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICRsb2cuaW5mbygnU3luY2hyb25vdXM6IERhdGEgbnVtYmVyIG9mIGVsZW1lbnRzICcrIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIEZpbHRlciB0byB0dXJuIGEgbnVtYmVyIGluIGJ5dGVzIHRvIGEgaHVtYW4gcmVhZGFibGUgc2l6ZSAoZS5nLiA1LDI1IE1CKS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tQnl0ZXNUb1NpemVcbiAqL1xuLmZpbHRlcignbW1CeXRlc1RvU2l6ZScsIGZ1bmN0aW9uKCRtbVRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICByZXR1cm4gJG1tVGV4dC5ieXRlc1RvU2l6ZSh0ZXh0KTtcbiAgICB9O1xufSk7IiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBGaWx0ZXIgdG8gc2VhcmNoIFVSTHMgdGhhdCBhcmUgbm90IGluc2lkZSA8YT4gdGFncyBhbmQgYWRkIHRoZSBjb3JyZXNwb25kaW5nIDxhPiB0YWdzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgbW1DcmVhdGVMaW5rc1xuICovXG4uZmlsdGVyKCdtbUNyZWF0ZUxpbmtzJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlcGxhY2VQYXR0ZXJuID0gLyhcXGIoaHR0cHM/fGZ0cCk6XFwvXFwvWy1BLVowLTkrJkAjXFwvJT89fl98ITosLjtdKlstQS1aMC05KyZAI1xcLyU9fl98XSkoPyFbXjxdKj58W148Pl0qPFxcLykvZ2ltO1xuICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UocmVwbGFjZVBhdHRlcm4sICc8YSBocmVmPVwiJDFcIj4kMTwvYT4nKTtcbiAgICB9O1xuXG59KTsiLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIEZpbHRlciB0byBkaXNwbGF5IGEgZGF0ZSB1c2luZyB0aGUgZGF5LCBvciB0aGUgdGltZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIG1tRGF0ZURheU9yVGltZVxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHNob3dzIGEgc2hvcnQgdmVyc2lvbiBvZiBhIGRhdGUuIFVzZSB0aGlzIGZpbHRlciB3aGVuIHlvdSB3YW50XG4gKiB0aGUgdXNlciB0byB2aXN1YWxpc2Ugd2hlbiB0aGUgYWN0aW9uIHdhcyBkb25lIHJlbGF0aXZlbHkgdG8gdG9kYXkncyBkYXRlLlxuICpcbiAqIEZvciBpbnN0YW5jZSwgaWYgdGhlIGFjdGlvbiBoYXBwZW5lZCBkdXJpbmcgdGhpcyBkYXkgaXQgd2lsbCBkaXNwbGF5IHRoZSB0aW1lLFxuICogYnV0IHdoZW4gdGhlIGFjdGlvbiBoYXBwZW5lZCBmZXcgZGF5cyBhZ28sIGl0IHdpbGwgZGlzcGxheSB0aGUgZGF5IG9mIHRoZSB3ZWVrLlxuICpcbiAqIFRoZSBvbGRlciB0aGUgZGF0ZSBpcywgdGhlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaXQgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gKlxuICogVGhpcyBmaWx0ZXIgZXhwZWN0cyBhIHRpbWVzdGFtcCBOT1QgaW5jbHVkaW5nIG1pbGxpc2Vjb25kcy5cbiAqL1xuLmZpbHRlcignbW1EYXRlRGF5T3JUaW1lJywgZnVuY3Rpb24oJHRyYW5zbGF0ZSkge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgICAgICByZXR1cm4gbW9tZW50KHRpbWVzdGFtcCAqIDEwMDApLmNhbGVuZGFyKG51bGwsIHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS5kZnRpbWVkYXRlJyksXG4gICAgICAgICAgICBsYXN0RGF5OiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUuZGZsYXN0d2Vla2RhdGUnKSxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUuZGZsYXN0d2Vla2RhdGUnKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRmlsdGVyIHRvIGZvcm1hdCBhIGRhdGUuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZmlsdGVyXG4gKiBAbmFtZSBtbUZvcm1hdERhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBmb3JtYXRzIGEgdGltZXN0YW1wIGludG8gYSBkYXRlLiBQYXJhbWV0ZXJzOlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lc3RhbXAgVGltZXN0YW1wIHRvIGZvcm1hdCAoaW4gc2Vjb25kcykuIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCB0aW1lLlxuICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCAgICBGb3JtYXQgdG8gdXNlLiBJdCBzaG91bGQgYmUgYSBzdHJpbmcgY29kZSB0byBoYW5kbGUgaTE4biAoZS5nLiBtbS5jb3JlLmRmdGltZWRhdGUpLiBJZiB0aGUgY29kZSBkb2Vzbid0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUgYSBwcmVmaXgsICdtbS5jb3JlJyB3aWxsIGJlIHVzZWQgYnkgZGVmYXVsdC4gRS5nLiAnZGZ0aW1lZGF0ZScgLT4gJ21tLmNvcmUuZGZ0aW1lZGF0ZScuXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIEZvcm1hdHRlZCBkYXRlLlxuICovXG4uZmlsdGVyKCdtbUZvcm1hdERhdGUnLCBmdW5jdGlvbigkdHJhbnNsYXRlKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24odGltZXN0YW1wLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT0gLTEpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9ICdtbS5jb3JlLicgKyBmb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aW1lc3RhbXApLmZvcm1hdCgkdHJhbnNsYXRlLmluc3RhbnQoZm9ybWF0KSk7XG4gICAgfTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIEZpbHRlciB0byByZW1vdmUgSFRNTCB0YWdzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgbW1Ob1RhZ3NcbiAqL1xuLmZpbHRlcignbW1Ob1RhZ3MnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRleHQpLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCAnJyk7XG4gICAgfVxufSk7IiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBGaWx0ZXIgdG8gdHVybiBhIFVOSVggdGltZXN0YW1wIHRvIFwidGltZSBhZ29cIi5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIG1tVGltZUFnb1xuICovXG4uZmlsdGVyKCdtbVRpbWVBZ28nLCBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aW1lc3RhbXAgKiAxMDAwKS5mcm9tTm93KHRydWUpO1xuICAgIH07XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBGaWx0ZXIgdG8gZm9ybWF0IGEgdGltZXN0YW1wIHRvIGEgbG9jYWxlIHN0cmluZy4gVGltZXN0YW1wIGNhbiBiZSBpbiBzZWNvbmRzIG9yIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIG1tVG9Mb2NhbGVTdHJpbmdcbiAqL1xuLmZpbHRlcignbW1Ub0xvY2FsZVN0cmluZycsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBwYXJzZUludCh0ZXh0KTtcblxuICAgICAgICBpZiAoaXNOYU4odGltZXN0YW1wKSB8fCB0aW1lc3RhbXAgPCAwKSB7XG4gICAgICAgICAgICAvLyBEYXRlIG5vdCB2YWxpZC5cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXN0YW1wIDwgMTAwMDAwMDAwMDAwKSB7XG4gICAgICAgICAgICAvLyBUaW1lc3RhbXAgaXMgaW4gc2Vjb25kcywgY29udmVydCBpdCB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSB0aW1lc3RhbXAgKiAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXApLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gYXV0byBmb2N1cyBhbiBlbGVtZW50IHdoZW4gYSB2aWV3IGlzIGxvYWRlZC5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tQXV0b0ZvY3VzXG4gKi9cbi5kaXJlY3RpdmUoJ21tQXV0b0ZvY3VzJywgZnVuY3Rpb24oJG1tQXBwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsKSB7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0cmFuc2l0aW9uIHRvIGZpbmlzaCBiZWZvcmUgYXV0by1mb2N1cy5cbiAgICAgICAgICAgIHZhciB1bnJlZ2lzdGVyID0gc2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpb25pYy50cmFuc2l0aW9uLmlzQWN0aXZlO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsWzBdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIoKTsgLy8gU3RvcCB3YXRjaGluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiBzb21lIEFuZHJvaWQgdmVyc2lvbnMgdGhlIGtleWJvYXJkIGRvZXNuJ3Qgb3BlbiBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgJG1tQXBwLm9wZW5LZXlib2FyZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBvcGVuIGEgbGluayBpbiBleHRlcm5hbCBicm93c2VyLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1Ccm93c2VyXG4gKi9cbi5kaXJlY3RpdmUoJ21tQnJvd3NlcicsIGZ1bmN0aW9uKCRtbVV0aWwsICRtbUNvbnRlbnRMaW5rc0hlbHBlcikge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgcHJpb3JpdHk6IDEwMCxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICBlbGVtZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBlbGVtZW50WzBdLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICRtbUNvbnRlbnRMaW5rc0hlbHBlci5oYW5kbGVMaW5rKGhyZWYpLnRoZW4oZnVuY3Rpb24odHJlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJlZi5pbmRleE9mKCdjZHZmaWxlOi8vJykgPT09IDAgfHwgaHJlZi5pbmRleE9mKCdmaWxlOi8vJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGxvY2FsIGZpbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwub3BlbkZpbGUoaHJlZikuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIGFuIGV4dGVybmFsIGxpbmssIHdlIHdpbGwgb3BlbiB3aXRoIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwub3BlbkluQnJvd3NlcihocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gaGFuZGxlIGFjdGl2aXR5IGNvbXBsZXRpb24uIEl0IGNhbiBiZSBhZGFwdGVkIHRvIGhhbmRsZSBjb3Vyc2UgY29tcGxldGlvbiBvbmNlIGl0J3MgaW1wbGVtZW50ZWQuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbUNvbXBsZXRpb25cbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBkaXJlY3RpdmUgd2lsbCBzaG93IGEgY2hlY2tib3ggdG8gc2hvdyBjb21wbGV0aW9uIHN0YXR1cyBhbmQgdG8gYWxsb3cgbWFudWFsbHkgY2hhbmdpbmcgdGhlIGNvbXBsZXRpb24gaWYgaXQncyBhbGxvd2VkLlxuICogQXR0cmlidXRlczpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcGxldGlvbiAgICBDb21wbGV0aW9uIHN0YXR1cyBvZiB0aGUgYWN0aXZpdHkuIFJlcXVpcmVkIHByb3BlcnRpZXM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBjbWlkOiBNb2R1bGUgSUQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBzdGF0ZTogQ3VycmVudCBjb21wbGV0aW9uIHN0YXRlOiAwIGluY29tcGxldGUsIDEgY29tcGxldGUsIDIgY29tcGxldGUgcGFzcywgMyBjb21wbGV0ZSBmYWlsLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gdHJhY2tpbmc6IDAgbWVhbnMgbm9uZSwgMSBtYW51YWwsIDIgYXV0b21hdGljLlxuICogQHBhcmFtIHtTdHJpbmd9IGFmdGVyLWNoYW5nZSAgTmFtZSBvZiBhIHNjb3BlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBjb21wbGV0aW9uIGNoYW5nZXMuXG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kdWxlLW5hbWUgICBOYW1lIG9mIHRoZSBtb2R1bGUgdGhpcyBjb21wbGV0aW9uIHJlZmVycyB0by5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1Db21wbGV0aW9uJywgZnVuY3Rpb24oJG1tU2l0ZSwgJG1tVXRpbCwgJG1tVGV4dCwgJHRyYW5zbGF0ZSwgJHEpIHtcblxuICAgIC8vIFNldCBpbWFnZSBhbmQgZGVzY3JpcHRpb24gdG8gc2hvdyBhcyBjb21wbGV0aW9uIGljb24uXG4gICAgZnVuY3Rpb24gc2hvd1N0YXR1cyhzY29wZSkge1xuICAgICAgICB2YXIgbGFuZ0tleSxcbiAgICAgICAgICAgIG1vZHVsZU5hbWUgPSBzY29wZS5tb2R1bGVOYW1lIHx8ICcnO1xuXG4gICAgICAgIGlmIChzY29wZS5jb21wbGV0aW9uLnRyYWNraW5nID09PSAxICYmIHNjb3BlLmNvbXBsZXRpb24uc3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgIHNjb3BlLmNvbXBsZXRpb25JbWFnZSA9ICdpbWcvY29tcGxldGlvbi9jb21wbGV0aW9uLW1hbnVhbC1uLnN2Zyc7XG4gICAgICAgICAgICBsYW5nS2V5ID0gJ21tLmNvcmUuY29tcGxldGlvbi1hbHQtbWFudWFsLW4nO1xuICAgICAgICB9IGVsc2UgaWYoc2NvcGUuY29tcGxldGlvbi50cmFja2luZyA9PT0gMSAmJiBzY29wZS5jb21wbGV0aW9uLnN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICBzY29wZS5jb21wbGV0aW9uSW1hZ2UgPSAnaW1nL2NvbXBsZXRpb24vY29tcGxldGlvbi1tYW51YWwteS5zdmcnO1xuICAgICAgICAgICAgbGFuZ0tleSA9ICdtbS5jb3JlLmNvbXBsZXRpb24tYWx0LW1hbnVhbC15JztcbiAgICAgICAgfSBlbHNlIGlmKHNjb3BlLmNvbXBsZXRpb24udHJhY2tpbmcgPT09IDIgJiYgc2NvcGUuY29tcGxldGlvbi5zdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgc2NvcGUuY29tcGxldGlvbkltYWdlID0gJ2ltZy9jb21wbGV0aW9uL2NvbXBsZXRpb24tYXV0by1uLnN2Zyc7XG4gICAgICAgICAgICBsYW5nS2V5ID0gJ21tLmNvcmUuY29tcGxldGlvbi1hbHQtYXV0by1uJztcbiAgICAgICAgfSBlbHNlIGlmKHNjb3BlLmNvbXBsZXRpb24udHJhY2tpbmcgPT09IDIgJiYgc2NvcGUuY29tcGxldGlvbi5zdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgc2NvcGUuY29tcGxldGlvbkltYWdlID0gJ2ltZy9jb21wbGV0aW9uL2NvbXBsZXRpb24tYXV0by15LnN2Zyc7XG4gICAgICAgICAgICBsYW5nS2V5ID0gJ21tLmNvcmUuY29tcGxldGlvbi1hbHQtYXV0by15JztcbiAgICAgICAgfSBlbHNlIGlmKHNjb3BlLmNvbXBsZXRpb24udHJhY2tpbmcgPT09IDIgJiYgc2NvcGUuY29tcGxldGlvbi5zdGF0ZSA9PT0gMikge1xuICAgICAgICAgICAgc2NvcGUuY29tcGxldGlvbkltYWdlID0gJ2ltZy9jb21wbGV0aW9uL2NvbXBsZXRpb24tYXV0by1wYXNzLnN2Zyc7XG4gICAgICAgICAgICBsYW5nS2V5ID0gJ21tLmNvcmUuY29tcGxldGlvbi1hbHQtYXV0by1wYXNzJztcbiAgICAgICAgfSBlbHNlIGlmKHNjb3BlLmNvbXBsZXRpb24udHJhY2tpbmcgPT09IDIgJiYgc2NvcGUuY29tcGxldGlvbi5zdGF0ZSA9PT0gMykge1xuICAgICAgICAgICAgc2NvcGUuY29tcGxldGlvbkltYWdlID0gJ2ltZy9jb21wbGV0aW9uL2NvbXBsZXRpb24tYXV0by1mYWlsLnN2Zyc7XG4gICAgICAgICAgICBsYW5nS2V5ID0gJ21tLmNvcmUuY29tcGxldGlvbi1hbHQtYXV0by1mYWlsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2R1bGVOYW1lKSB7XG4gICAgICAgICAgICAkbW1UZXh0LmZvcm1hdFRleHQobW9kdWxlTmFtZSwgdHJ1ZSwgdHJ1ZSwgNTApLnRoZW4oZnVuY3Rpb24oZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICAgICAgJHRyYW5zbGF0ZShsYW5nS2V5LCB7JGE6IGZvcm1hdHRlZH0pLnRoZW4oZnVuY3Rpb24odHJhbnNsYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5jb21wbGV0aW9uRGVzY3JpcHRpb24gPSB0cmFuc2xhdGVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICBwcmlvcml0eTogMTAwLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgY29tcGxldGlvbjogJz0nLFxuICAgICAgICAgICAgYWZ0ZXJDaGFuZ2U6ICc9JyxcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6ICc9PydcbiAgICAgICAgfSxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL3RlbXBsYXRlcy9jb21wbGV0aW9uLmh0bWwnLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5jb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2hvd1N0YXR1cyhzY29wZSk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY29wZS5jb21wbGV0aW9uLmNtaWQgPT0gJ3VuZGVmaW5lZCcgfHwgc2NvcGUuY29tcGxldGlvbi50cmFja2luZyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWlkOiBzY29wZS5jb21wbGV0aW9uLmNtaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkOiBzY29wZS5jb21wbGV0aW9uLnN0YXRlID09PSAxID8gMCA6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgJG1tU2l0ZS53cml0ZSgnY29yZV9jb21wbGV0aW9uX3VwZGF0ZV9hY3Rpdml0eV9jb21wbGV0aW9uX3N0YXR1c19tYW51YWxseScsIHBhcmFtcykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24oc2NvcGUuYWZ0ZXJDaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuYWZ0ZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3JlLmVycm9yY2hhbmdlY29tcGxldGlvbicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIGhhbmRsZSBleHRlcm5hbCBjb250ZW50LlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1FeHRlcm5hbENvbnRlbnRcbiAqIEBkZXNjcmlwdGlvblxuICogRGlyZWN0aXZlIHRvIGhhbmRsZSBleHRlcm5hbCBjb250ZW50LlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIHNob3VsZCBiZSB1c2VkIHdpdGggYW55IGVsZW1lbnQgdGhhdCBsaW5rcyB0byBleHRlcm5hbCBjb250ZW50XG4gKiB3aGljaCB3ZSB3YW50IHRvIGhhdmUgYXZhaWxhYmxlIHdoZW4gdGhlIGFwcCBpcyBvZmZsaW5lLiBUeXBpY2FsbHkgaW1hZ2VzIGFuZCBsaW5rcy5cbiAqXG4gKiBJdCB1c2VzIHtAbGluayAkbW1GaWxlcG9vbH0gaW4gdGhlIGJhY2tncm91bmQuXG4gKlxuICogQXR0cmlidXRlcyBhY2NlcHRlZDpcbiAqICAgICAtIHNpdGVpZDogUmVmZXJlbmNlIHRvIHRoZSBzaXRlIElEIGlmIGRpZmZlcmVudCB0aGFuIHRoZSBzaXRlIHRoZSB1c2VyIGlzIGNvbm5lY3RlZCB0by5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1FeHRlcm5hbENvbnRlbnQnLCBmdW5jdGlvbigkbG9nLCAkbW1GaWxlcG9vbCwgJG1tU2l0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCAkbW1VdGlsKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tRXh0ZXJuYWxDb250ZW50Jyk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFeHRlcm5hbENvbnRlbnQoc2l0ZUlkLCBkb20sIHRhcmdldEF0dHIsIHVybCwgY29tcG9uZW50LCBjb21wb25lbnRJZCkge1xuXG4gICAgICAgIGlmICghdXJsIHx8ICEkbW1VdGlsLmlzRG93bmxvYWRhYmxlVXJsKHVybCkpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0lnbm9yaW5nIG5vbi1kb3dubG9hZGFibGUgVVJMOiAnICsgdXJsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgd2Vic2VydmljZSBwbHVnaW5maWxlIFVSTCwgd2UgaWdub3JlIGZhaWx1cmVzIGhlcmUuXG4gICAgICAgICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICBpZiAoIXNpdGUuY2FuRG93bmxvYWRGaWxlcygpICYmICRtbVV0aWwuaXNQbHVnaW5GaWxlVXJsKHVybCkpIHtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlKCk7IC8vIFJlbW92ZSBlbGVtZW50IHNpbmNlIGl0J2xsIGJlIGJyb2tlbi5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmbjtcblxuICAgICAgICAgICAgaWYgKHRhcmdldEF0dHIgPT09ICdzcmMnKSB7XG4gICAgICAgICAgICAgICAgZm4gPSAkbW1GaWxlcG9vbC5nZXRTcmNCeVVybDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm4gPSAkbW1GaWxlcG9vbC5nZXRVcmxCeVVybDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4oc2l0ZUlkLCB1cmwsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpLnRoZW4oZnVuY3Rpb24oZmluYWxVcmwpIHtcbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdVc2luZyBVUkwgJyArIGZpbmFsVXJsICsgJyBmb3IgJyArIHVybCk7XG4gICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZSh0YXJnZXRBdHRyLCBmaW5hbFVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgIHNpdGVpZDogJz0nXG4gICAgICAgIH0sXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgdmFyIGRvbSA9IGVsZW1lbnRbMF0sXG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gYXR0cnMuY29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudElkID0gYXR0cnMuY29tcG9uZW50SWQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0QXR0cixcbiAgICAgICAgICAgICAgICBvYnNlcnZlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgdXJsO1xuXG4gICAgICAgICAgICBpZiAoZG9tLnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICAgICAgICAgIHRhcmdldEF0dHIgPSAnaHJlZic7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KCduZ0hyZWYnKSkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9tLnRhZ05hbWUgPT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0QXR0ciA9ICdzcmMnO1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eSgnbmdTcmMnKSkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVW5zdXBwb3J0ZWQgdGFnLlxuICAgICAgICAgICAgICAgICRsb2cud2FybignRGlyZWN0aXZlIGF0dGFjaGVkIHRvIG5vbi1zdXBwb3J0ZWQgdGFnOiAnICsgZG9tLnRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9ic2VydmUpIHtcbiAgICAgICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSh0YXJnZXRBdHRyLCBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFeHRlcm5hbENvbnRlbnQoc2NvcGUuc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKSwgZG9tLCB0YXJnZXRBdHRyLCB1cmwsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFeHRlcm5hbENvbnRlbnQoc2NvcGUuc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKSwgZG9tLCB0YXJnZXRBdHRyLCBhdHRyc1t0YXJnZXRBdHRyXSwgY29tcG9uZW50LCBjb21wb25lbnRJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIGhhbmRsZSBhIGZpbGUgKG15IGZpbGVzLCBhdHRhY2htZW50cywgZXRjLikuIFRoZSBmaWxlIGlzIG5vdCBkb3dubG9hZGVkIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbUZpbGVcbiAqIEBkZXNjcmlwdGlvblxuICogRGlyZWN0aXZlIHRvIGhhbmRsZSBmaWxlcyAobXkgZmlsZXMsIGF0dGFjaG1lbnRzLCBldGMuKS4gU2hvd3MgdGhlIGZpbGUgbmFtZSwgaWNvbiAoZGVwZW5kaW5nIG9uIG1pbWV0eXBlKSBhbmQgYSBidXR0b25cbiAqIHRvIGRvd25sb2FkL3JlZnJlc2ggaXQuXG4gKlxuICogQXR0cmlidXRlczpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlICAgICAgICAgICAgUmVxdWlyZWQuIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmaWxlbmFtZSc6IE5hbWUgb2YgdGhlIGZpbGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmlsZXVybCcgb3IgJ3VybCc6IEZpbGUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IFtjb21wb25lbnRdICAgICBDb21wb25lbnQgdGhlIGZpbGUgYmVsb25ncyB0by5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9uZW50SWRdICAgQ29tcG9uZW50IElELlxuICogQHBhcmFtIHtCb29sZWFufSBbdGltZW1vZGlmaWVkXSBJZiBzZXQsIHRoZSB2YWx1ZSB3aWxsIGJlIHVzZWQgdG8gY2hlY2sgaWYgdGhlIGZpbGUgaXMgb3V0ZGF0ZWQuXG4gKi9cbi5kaXJlY3RpdmUoJ21tRmlsZScsIGZ1bmN0aW9uKCRxLCAkbW1VdGlsLCAkbW1GaWxlcG9vbCwgJG1tU2l0ZSwgJG1tQXBwLCAkbW1FdmVudHMsICRtbUZTLCBtbUNvcmVEb3dubG9hZGVkLCBtbUNvcmVEb3dubG9hZGluZyxcbiAgICAgICAgICAgIG1tQ29yZU5vdERvd25sb2FkZWQsIG1tQ29yZU91dGRhdGVkKSB7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIGZpbGUgc3RhdGUgYW5kIHNldCBzY29wZSB2YXJpYWJsZXMgYmFzZWQgb24gaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3BlICAgICAgICAgIERpcmVjdGl2ZSdzIHNjb3BlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZWlkICAgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGV1cmwgICAgICAgIEZpbGUgVVJMLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW3RpbWVtb2RpZmllZF0gRmlsZSdzIHRpbWVtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN0YXRlKHNjb3BlLCBzaXRlaWQsIGZpbGV1cmwsIHRpbWVtb2RpZmllZCkge1xuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZ2V0RmlsZVN0YXRlQnlVcmwoc2l0ZWlkLCBmaWxldXJsLCB0aW1lbW9kaWZpZWQpLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBjYW5Eb3dubG9hZCA9ICRtbVNpdGUuY2FuRG93bmxvYWRGaWxlcygpO1xuICAgICAgICAgICAgc2NvcGUuaXNEb3dubG9hZGVkID0gc3RhdGUgPT09IG1tQ29yZURvd25sb2FkZWQgfHzCoHN0YXRlID09PSBtbUNvcmVPdXRkYXRlZDtcbiAgICAgICAgICAgIHNjb3BlLmlzRG93bmxvYWRpbmcgPSBjYW5Eb3dubG9hZCAmJiBzdGF0ZSA9PT0gbW1Db3JlRG93bmxvYWRpbmc7XG4gICAgICAgICAgICBzY29wZS5zaG93RG93bmxvYWQgPSBjYW5Eb3dubG9hZCAmJiAoc3RhdGUgPT09IG1tQ29yZU5vdERvd25sb2FkZWQgfHzCoHN0YXRlID09PSBtbUNvcmVPdXRkYXRlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGRvd25sb2FkIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2NvcGUgICAgICAgICAgRGlyZWN0aXZlJ3Mgc2NvcGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlaWQgICAgICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZXVybCAgICAgICAgRmlsZSBVUkwuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBjb21wb25lbnQgICAgICBDb21wb25lbnQgdGhlIGZpbGUgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbXBvbmVudGlkICAgIENvbXBvbmVudCBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWRdIEZpbGUncyB0aW1lbW9kaWZpZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gZmlsZSBpcyBkb3dubG9hZGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvd25sb2FkRmlsZShzY29wZSwgc2l0ZWlkLCBmaWxldXJsLCBjb21wb25lbnQsIGNvbXBvbmVudGlkLCB0aW1lbW9kaWZpZWQpIHtcbiAgICAgICAgaWYgKCEkbW1TaXRlLmNhbkRvd25sb2FkRmlsZXMoKSkge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5jYW5ub3Rkb3dubG9hZGZpbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS5pc0Rvd25sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmRvd25sb2FkVXJsKHNpdGVpZCwgZmlsZXVybCwgdHJ1ZSwgY29tcG9uZW50LCBjb21wb25lbnRpZCwgdGltZW1vZGlmaWVkKS50aGVuKGZ1bmN0aW9uKGxvY2FsVXJsKSB7XG4gICAgICAgICAgICBnZXRTdGF0ZShzY29wZSwgc2l0ZWlkLCBmaWxldXJsLCB0aW1lbW9kaWZpZWQpOyAvLyBVcGRhdGUgc3RhdGUuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxVcmw7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0YXRlKHNjb3BlLCBzaXRlaWQsIGZpbGV1cmwsIHRpbWVtb2RpZmllZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUuaXNEb3dubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFVybDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS90ZW1wbGF0ZXMvZmlsZS5odG1sJyxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgIGZpbGU6ICc9J1xuICAgICAgICB9LFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgIHZhciBmaWxldXJsID0gc2NvcGUuZmlsZS5maWxldXJsIHx8wqBzY29wZS5maWxlLnVybCxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHNjb3BlLmZpbGUuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gYXR0cnMudGltZW1vZGlmaWVkIHx8IDAsXG4gICAgICAgICAgICAgICAgc2l0ZWlkID0gJG1tU2l0ZS5nZXRJZCgpLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGF0dHJzLmNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRpZCA9IGF0dHJzLmNvbXBvbmVudElkLFxuICAgICAgICAgICAgICAgIG9ic2VydmVyO1xuXG4gICAgICAgICAgICBzY29wZS5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgc2NvcGUuZmlsZWljb24gPSAkbW1GUy5nZXRGaWxlSWNvbihmaWxlbmFtZSk7XG4gICAgICAgICAgICBnZXRTdGF0ZShzY29wZSwgc2l0ZWlkLCBmaWxldXJsLCB0aW1lbW9kaWZpZWQpO1xuXG4gICAgICAgICAgICAkbW1GaWxlcG9vbC5nZXRGaWxlRXZlbnROYW1lQnlVcmwoc2l0ZWlkLCBmaWxldXJsKS50aGVuKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyID0gJG1tRXZlbnRzLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBnZXRTdGF0ZShzY29wZSwgc2l0ZWlkLCBmaWxldXJsLCB0aW1lbW9kaWZpZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzY29wZS5kb3dubG9hZCA9IGZ1bmN0aW9uKGUsIG9wZW5BZnRlckRvd25sb2FkKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUuaXNEb3dubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEkbW1BcHAuaXNPbmxpbmUoKSAmJiAoIW9wZW5BZnRlckRvd25sb2FkIHx8IChvcGVuQWZ0ZXJEb3dubG9hZCAmJiAhc2NvcGUuaXNEb3dubG9hZGVkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5uZXR3b3JrZXJyb3Jtc2cnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcGVuQWZ0ZXJEb3dubG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIG5lZWRzIHRvIGJlIG9wZW5lZCBub3cuIElmIGZpbGUgbmVlZHMgdG8gYmUgZG93bmxvYWRlZCwgc2tpcCB0aGUgcXVldWUuXG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkRmlsZShzY29wZSwgc2l0ZWlkLCBmaWxldXJsLCBjb21wb25lbnQsIGNvbXBvbmVudGlkLCB0aW1lbW9kaWZpZWQpLnRoZW4oZnVuY3Rpb24obG9jYWxVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwub3BlbkZpbGUobG9jYWxVcmwpLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsZSBkb2Vzbid0IG5lZWQgdG8gYmUgb3BlbmVkLCBhZGQgaXQgdG8gcXVldWUuXG4gICAgICAgICAgICAgICAgICAgICRtbUZpbGVwb29sLmludmFsaWRhdGVGaWxlQnlVcmwoc2l0ZWlkLCBmaWxldXJsKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuaXNEb3dubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1GaWxlcG9vbC5hZGRUb1F1ZXVlQnlVcmwoc2l0ZWlkLCBmaWxldXJsLCBjb21wb25lbnQsIGNvbXBvbmVudGlkLCB0aW1lbW9kaWZpZWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIgJiYgb2JzZXJ2ZXIub2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9mZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gZm9ybWF0IHRleHQgcmVuZGVyZWQuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbUZvcm1hdFRleHRcbiAqIEBkZXNjcmlwdGlvblxuICogRGlyZWN0aXZlIHRvIGZvcm1hdCB0ZXh0IHJlbmRlcmVkLiBBdHRyaWJ1dGVzIGl0IGFjY2VwdHM6XG4gKiAgICAgLXNpdGVpZDogU2l0ZSBJRCB0byB1c2UuXG4gKiAgICAgLWNvbXBvbmVudDogVGhlIGNvbXBvbmVudCBmb3IgbW1FeHRlcm5hbENvbnRlbnRcbiAqICAgICAtY29tcG9uZW50LWlkOiBUaGUgY29tcG9uZW50IElEIGZvciBtbUV4dGVybmFsQ29udGVudFxuICogICAgIC1hZnRlci1yZW5kZXI6IFNjb3BlIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSB0aGUgY29udGVudCBpcyByZW5kZXJlcmVkLiBQYXNzZXMgdGhlIGN1cnJlbnQgc2NvcGUgYXMgYXJndW1lbnQuXG4gKiAgICAgLWNsZWFuOiBUcnVlIGlmIGFsbCBIVE1MIHRhZ3Mgc2hvdWxkIGJlIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqICAgICAtc2luZ2xlbGluZTogVHJ1ZSBpZiBuZXcgbGluZXMgc2hvdWxkIGJlIHJlbW92ZWQgKGFsbCB0aGUgdGV4dCBpbiBhIHNpbmdsZSBsaW5lKS4gT25seSB2YWxpZCBpZiBjbGVhbiBpcyB0cnVlLlxuICogICAgIC1zaG9ydGVuOiBUbyBzaG9ydGVuIHRoZSB0ZXh0LiBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgaXQgd2lsbCBzaG9ydGVuIHRoZSB0ZXh0IHRvIHRoYXQgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gKiAgICAgICAgICAgICAgIElmIGEgcGVyY2VudGFnZSBpcyBzdXBwbGllZCB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gc2hvcnQgd2lsbCBiZSB0aGUgcGVyY2VudGFnZSBvZiBlbGVtZW50J3Mgd2lkdGguXG4gKiAgICAgICAgICAgICAgIEUuZy4gNTAlIG9mIGFuIGVsZW1lbnQgd2l0aCAxMDAwcHggd2lkdGggPSA1MDAgY2hhcmFjdGVycy5cbiAqICAgICAgICAgICAgICAgSWYgdGhlIGVsZW1lbnQgaGFzIG5vIHdpZHRoIGl0J2xsIHVzZSAxMDAgY2hhcmFjdGVycy4gSWYgdGhlIGF0dHJpYnV0ZSBpcyBlbXB0eSBpdCdsbCB1c2UgMzAlIHdpZHRoLlxuICogICAgIC1leHBhbmQtb24tY2xpY2s6IEluZGljYXRlIGlmIGNvbnRlbnRzIHNob3VsZCBiZSBleHBhbmRlZCBvbiBjbGljayAodW5kbyBzaG9ydGVuKS4gT25seSBhcHBsaWVkIGlmIFwic2hvcnRlblwiIGlzIHNldC5cbiAqICAgICAtZnVsbHZpZXctb24tY2xpY2s6IEluZGljYXRlIGlmIHNob3VsZCBvcGVuIGEgbmV3IHN0YXRlIHdpdGggdGhlIGZ1bGwgY29udGVudHMgb24gY2xpY2suIE9ubHkgYXBwbGllZCBpZiBcInNob3J0ZW5cIiBpcyBzZXQuXG4gKiAgICAgLXdhdGNoOiBUcnVlIGlmIHRoZSB2YXJpYWJsZSB1c2VkIGluc2lkZSB0aGUgZGlyZWN0aXZlIHNob3VsZCBiZSB3YXRjaGVkIGZvciBjaGFuZ2VzLiBJZiB0aGUgdmFyaWFibGUgZGF0YSBpcyByZXRyaWV2ZWRcbiAqICAgICAgICAgICAgIGFzeW5jaHJvbm91c2x5LCB0aGlzIHZhbHVlIG11c3QgYmUgc2V0IHRvIHRydWUsIG9yIHRoZSBkaXJlY3RpdmUgc2hvdWxkIGJlIGluc2lkZSBhIG5nLWlmLCBuZy1yZXBlYXQgb3Igc2ltaWxhci5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1Gb3JtYXRUZXh0JywgZnVuY3Rpb24oJGludGVycG9sYXRlLCAkbW1UZXh0LCAkY29tcGlsZSwgJHRyYW5zbGF0ZSwgJHN0YXRlKSB7XG5cbiAgICB2YXIgZXh0cmFjdFZhcmlhYmxlUmVnZXggPSBuZXcgUmVnRXhwKCd7eyhbXnxdKykofC4qKT99fScsICdpJyksXG4gICAgICAgIHRhZ3NUb0lnbm9yZSA9IFsnQVVESU8nLCAnVklERU8nLCAnQlVUVE9OJywgJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQScsICdBJ107XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBzaG9ydGVuIHRoZSB0ZXh0LiBJZiB0aGUgdGV4dCBzaG91bGRuJ3QgYmUgc2hvcnRlbmVkLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZWxlbWVudCAgIERpcmVjdGl2ZSByb290IERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3Nob3J0ZW5dIFNob3J0ZW4gYXR0cmlidXRlLiBDYW4gYmUgdW5kZWZpbmVkIG9yIGEgc3RyaW5nOiBlbXB0eSwgbnVtYmVyIG9yIGEgcGVyY2VudGFnZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBOdW1iZXIgb2YgY2hhcmFjdGVycyB0byBzaG9ydGVuIHRoZSB0ZXh0IHRvLiBVbmRlZmluZWQgaWYgaXQgc2hvdWxkbid0IHNob3J0ZW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU2hvcnRlbihlbGVtZW50LCBzaG9ydGVuKSB7XG4gICAgICAgIHZhciBtdWx0aXBsaWVyO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2hvcnRlbiA9PSAnc3RyaW5nJyAmJiBzaG9ydGVuLmluZGV4T2YoJyUnKSA+IC0xKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGEgcGVyY2VudGFnZS4gRXh0cmFjdCB0aGUgbXVsdGlwbGllci5cbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSBwYXJzZUludChzaG9ydGVuLnJlcGxhY2UoLyUvZywgJycpLnRyaW0oKSkgLyAxMDA7XG4gICAgICAgICAgICBpZiAoaXNOYU4obXVsdGlwbGllcikpIHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gMC4zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzaG9ydGVuICE9ICd1bmRlZmluZWQnICYmIHNob3J0ZW4gPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBOb3QgZGVmaW5lZCwgdXNlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gMC4zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IHBhcnNlSW50KHNob3J0ZW4pO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFJldHVybiB1bmRlZmluZWQgc28gaXQncyBub3Qgc2hvcnRlbmVkLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsID0gZWxlbWVudFswXSxcbiAgICAgICAgICAgIGVsV2lkdGggPSBlbC5vZmZzZXRXaWR0aCB8fMKgZWwud2lkdGggfHzCoGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBpZiAoIWVsV2lkdGgpIHtcbiAgICAgICAgICAgIC8vIENhbm5vdCBjYWxjdWxhdGUgZWxlbWVudCdzIHdpZHRoLCB1c2UgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChlbFdpZHRoICogbXVsdGlwbGllcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgY29udGVudHMgYW5kIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2NvcGUgICBEaXJlY3RpdmUgc2NvcGUuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBlbGVtZW50IERpcmVjdGl2ZSByb290IERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gYXR0cnMgICBEaXJlY3RpdmUgYXR0cmlidXRlcy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgICAgRGlyZWN0aXZlIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0QW5kUmVuZGVyQ29udGVudHMoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCB0ZXh0KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdoaWRlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhdHRycy5zaG9ydGVuID0gY2FsY3VsYXRlU2hvcnRlbihlbGVtZW50LCBhdHRycy5zaG9ydGVuKTtcblxuICAgICAgICAvLyBJZiBleHBhbmRPbkNsaWNrIG9yIGZ1bGx2aWV3T25DbGljayBhcmUgc2V0IHdlIHdvbid0IHNob3J0ZW4gdGhlIHRleHQgb24gZm9ybWF0Q29udGVudHMsIHdlJ2xsIGRvIGl0IGxhdGVyLlxuICAgICAgICB2YXIgc2hvcnRlbiA9IChhdHRycy5leHBhbmRPbkNsaWNrIHx8IGF0dHJzLmZ1bGx2aWV3T25DbGljaykgPyAwIDogYXR0cnMuc2hvcnRlbjtcblxuICAgICAgICB0ZXh0ID0gJGludGVycG9sYXRlKHRleHQpKHNjb3BlKTsgLy8gXCJFdmFsdWF0ZVwiIHNjb3BlIHZhcmlhYmxlcy5cbiAgICAgICAgdGV4dCA9IHRleHQudHJpbSgpO1xuXG4gICAgICAgIGZvcm1hdENvbnRlbnRzKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdGV4dCwgc2hvcnRlbikudGhlbihmdW5jdGlvbihmdWxsVGV4dCkge1xuICAgICAgICAgICAgaWYgKGF0dHJzLnNob3J0ZW4gJiYgKGF0dHJzLmV4cGFuZE9uQ2xpY2sgfHwgYXR0cnMuZnVsbHZpZXdPbkNsaWNrKSkge1xuICAgICAgICAgICAgICAgIHZhciBzaG9ydGVuZWQgPSAkbW1UZXh0LnNob3J0ZW5UZXh0KCRtbVRleHQuY2xlYW5UYWdzKGZ1bGxUZXh0LCBmYWxzZSksIHBhcnNlSW50KGF0dHJzLnNob3J0ZW4pKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmIChzaG9ydGVuZWQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29udGVudCBjb3VsZCBoYXZlIGltYWdlcyBvciBtZWRpYSB0aGF0IHdlcmUgcmVtb3ZlZCB3aXRoIHNob3J0ZW5UZXh0LiBDaGVjayBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWFuaW5nZnVsVGFncyA9IFsnaW1nJywgJ3ZpZGVvJywgJ2F1ZGlvJ107XG5cbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1lYW5pbmdmdWxUYWdzLCBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdWxsVGV4dC5pbmRleE9mKCc8Jyt0YWcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb250ZW50IGhhcyBtZWFuaW5nZnVsIHRhZ3MuIFNob3cgYSBwbGFjZWhvbGRlciB0byBleHBhbmQgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG9ydGVuZWQgPSAkdHJhbnNsYXRlLmluc3RhbnQoYXR0cnMuZXhwYW5kT25DbGljayA/ICdtbS5jb3JlLmNsaWNrdG9oaWRlc2hvdycgOiAnbW0uY29yZS5jbGlja3Rvc2VlZnVsbCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnc1RvSWdub3JlLmluZGV4T2YodGFyZ2V0LnRhZ05hbWUpID09PSAtMSB8fCAodGFyZ2V0LnRhZ05hbWUgPT09ICdBJyAmJiAhdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzLmV4cGFuZE9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQvY29sbGFwc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSAhZXhwYW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5odG1sKCBleHBhbmRlZCA/IGZ1bGxUZXh0IDogc2hvcnRlbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNvbXBpbGUoZWxlbWVudC5jb250ZW50cygpKShzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIGEgbmV3IHN0YXRlIHdpdGggdGhlIGludGVycG9sYXRlZCBjb250ZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW1fdGV4dHZpZXdlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS5kZXNjcmlwdGlvbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJlbmRlclRleHQoc2NvcGUsIGVsZW1lbnQsIHNob3J0ZW5lZCwgYXR0cnMuYWZ0ZXJSZW5kZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0KHNjb3BlLCBlbGVtZW50LCBmdWxsVGV4dCwgYXR0cnMuYWZ0ZXJSZW5kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBmb3JtYXRUZXh0IGFuZCBzZXQgc3ViLWRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3BlICAgICBEaXJlY3RpdmUgc2NvcGUuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBlbGVtZW50ICAgRGlyZWN0aXZlIHJvb3QgRE9NIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBhdHRycyAgICAgRGlyZWN0aXZlIGF0dHJpYnV0ZXMuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0ICAgICAgRGlyZWN0aXZlIGNvbnRlbnRzLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW3Nob3J0ZW5dIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHNob3J0ZW4gY29udGVudHMgdG8uIElmIG5vdCBkZWZpbmVkLCBkb24ndCBzaG9ydGVuIHRoZSB0ZXh0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZm9ybWF0dGVkIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0Q29udGVudHMoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCB0ZXh0LCBzaG9ydGVuKSB7XG5cbiAgICAgICAgdmFyIHNpdGVJZCA9IHNjb3BlLnNpdGVpZCxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGF0dHJzLmNvbXBvbmVudCxcbiAgICAgICAgICAgIGNvbXBvbmVudElkID0gYXR0cnMuY29tcG9uZW50SWQ7XG5cbiAgICAgICAgLy8gQXBwbHkgZm9ybWF0IHRleHQgZnVuY3Rpb24uXG4gICAgICAgIHJldHVybiAkbW1UZXh0LmZvcm1hdFRleHQodGV4dCwgYXR0cnMuY2xlYW4sIGF0dHJzLnNpbmdsZWxpbmUsIHNob3J0ZW4pLnRoZW4oZnVuY3Rpb24oZm9ybWF0dGVkKSB7XG5cbiAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRbMF0sXG4gICAgICAgICAgICAgICAgZWxXaWR0aCA9IGVsLm9mZnNldFdpZHRoIHx8wqBlbC53aWR0aCB8fMKgZWwuY2xpZW50V2lkdGg7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1lZGlhQWRhcHRDbGFzcyhlbCkge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudChlbCkuYWRkQ2xhc3MoJ21tLW1lZGlhLWFkYXB0LXdpZHRoJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGNvbnRlbnQgaW50byBET00uXG4gICAgICAgICAgICB2YXIgZG9tID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2PicpLmh0bWwoZm9ybWF0dGVkKTtcblxuICAgICAgICAgICAgLy8gV2FsayB0aHJvdWdoIHRoZSBjb250ZW50IHRvIGZpbmQgdGhlIGxpbmtzIGFuZCBhZGQgb3VyIGRpcmVjdGl2ZSB0byBpdC5cbiAgICAgICAgICAgIC8vIEltcG9ydGFudDogV2UgbmVlZCB0byBsb29rIGZvciBsaW5rcyBmaXJzdCBiZWNhdXNlIGluICdpbWcnIHdlIGFkZCBuZXcgbGlua3Mgd2l0aG91dCBtbS1icm93c2VyLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRvbS5maW5kKCdhJyksIGZ1bmN0aW9uKGFuY2hvcikge1xuICAgICAgICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ21tLWV4dGVybmFsLWNvbnRlbnQnLCAnJyk7XG4gICAgICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnbW0tYnJvd3NlcicsICcnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ2NvbXBvbmVudCcsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnY29tcG9uZW50LWlkJywgY29tcG9uZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnc2l0ZWlkJywgc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gV2FsayB0aHJvdWdoIHRoZSBjb250ZW50IHRvIGZpbmQgaW1hZ2VzLCBhbmQgYWRkIG91ciBkaXJlY3RpdmUuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZG9tLmZpbmQoJ2ltZycpLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgICAgICBhZGRNZWRpYUFkYXB0Q2xhc3MoaW1nKTtcbiAgICAgICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdtbS1leHRlcm5hbC1jb250ZW50JywgJycpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnY29tcG9uZW50JywgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdjb21wb25lbnQtaWQnLCBjb21wb25lbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpdGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdzaXRlaWQnLCBzaXRlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpbWFnZSB3aWR0aCBoYXMgYmVlbiBhZGFwdGVkLiBJZiBzbywgYWRkIGFuIGljb24gdG8gdmlldyB0aGUgaW1hZ2UgYXQgZnVsbCBzaXplLlxuICAgICAgICAgICAgICAgIHZhciBpbWdXaWR0aCA9IGltZy5vZmZzZXRXaWR0aCB8fMKgaW1nLndpZHRoIHx8IGltZy5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoaW1nV2lkdGggPiBlbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgdGhlIGltYWdlIGluIGEgbmV3IGRpdiB3aXRoIHBvc2l0aW9uIHJlbGF0aXZlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGl2ID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IGNsYXNzPVwibW0tYWRhcHRlZC1pbWctY29udGFpbmVyXCI+PC9kaXY+JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBqcUltZyA9IGFuZ3VsYXIuZWxlbWVudChpbWcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSAkbW1UZXh0LmVzY2FwZUhUTUwoJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLm9wZW5mdWxsaW1hZ2UnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdTcmMgPSAkbW1UZXh0LmVzY2FwZUhUTUwoaW1nLmdldEF0dHJpYnV0ZSgnc3JjJykpO1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3R5bGUuZmxvYXQgPSAnJzsgLy8gRGlzYWJsZSBmbG9hdCBzaW5jZSBpbWFnZSB3aWxsIGZpbGwgdGhlIHdob2xlIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBqcUltZy53cmFwKGRpdik7XG4gICAgICAgICAgICAgICAgICAgIGpxSW1nLmFmdGVyKCc8YSBocmVmPVwiI1wiIGNsYXNzPVwibW0taW1hZ2Utdmlld2VyLWljb25cIiBtbS1pbWFnZS12aWV3ZXIgaW1nPVwiJyArIGltZ1NyYyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCIgYXJpYS1sYWJlbD1cIicgKyBsYWJlbCArICdcIj48aSBjbGFzcz1cImljb24gaW9uLWlvcy1zZWFyY2gtc3Ryb25nXCI+PC9pPjwvYT4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRvbS5maW5kKCdhdWRpbycpLCBhZGRNZWRpYUFkYXB0Q2xhc3MpO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRvbS5maW5kKCd2aWRlbycpLCBhZGRNZWRpYUFkYXB0Q2xhc3MpO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRvbS5maW5kKCdpZnJhbWUnKSwgYWRkTWVkaWFBZGFwdENsYXNzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRvbS5odG1sKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzb21lIHRleHQgb24gdGhlIGRpcmVjdGl2ZSdzIGVsZW1lbnQsIGNvbXBpbGUgaXQgYW5kIGNhbGwgYWZ0ZXJSZW5kZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3BlICAgICAgICAgRGlyZWN0aXZlIHNjb3BlLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZWxlbWVudCAgICAgICBEaXJlY3RpdmUgcm9vdCBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgICAgICAgICAgRGlyZWN0aXZlIGNvbnRlbnRzLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW2FmdGVyUmVuZGVyXSBTY29wZSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgdGhlIGNvbnRlbnQgaXMgcmVuZGVyZXJlZC5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbmRlclRleHQoc2NvcGUsIGVsZW1lbnQsIHRleHQsIGFmdGVyUmVuZGVyKSB7XG4gICAgICAgIGVsZW1lbnQuaHRtbCh0ZXh0KTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnaGlkZScpO1xuICAgICAgICAkY29tcGlsZShlbGVtZW50LmNvbnRlbnRzKCkpKHNjb3BlKTtcbiAgICAgICAgLy8gQ2FsbCB0aGUgYWZ0ZXIgcmVuZGVyIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoYWZ0ZXJSZW5kZXIgJiYgc2NvcGVbYWZ0ZXJSZW5kZXJdKSB7XG4gICAgICAgICAgICBzY29wZVthZnRlclJlbmRlcl0oc2NvcGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgc2NvcGU6IHRydWUsXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRDbGFzcygnaGlkZScpOyAvLyBIaWRlIGNvbnRlbnRzIHVudGlsIHRoZXkncmUgdHJlYXRlZC5cbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gZWxlbWVudC5odG1sKCk7IC8vIEdldCBkaXJlY3RpdmUncyBjb250ZW50LlxuXG4gICAgICAgICAgICBpZiAoYXR0cnMud2F0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBXYXRjaCB0aGUgdmFyaWFibGUgaW5zaWRlIHRoZSBkaXJlY3RpdmUuXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoKGV4dHJhY3RWYXJpYWJsZVJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAmJiB0eXBlb2YgbWF0Y2hlc1sxXSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRjaGVzWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKHZhcmlhYmxlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdEFuZFJlbmRlckNvbnRlbnRzKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0QW5kUmVuZGVyQ29udGVudHMoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIGRpc3BsYXkgY29udGVudCBpbiBhbiBpZnJhbWUuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbUlmcmFtZVxuICogQGRlc2NyaXB0aW9uXG4gKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjICAgICAgICAgIFRoZSBzb3VyY2Ugb2YgdGhlIGlmcmFtZS5cbiAqIEBwYXJhbSB7TWl4ZWR9IFt3aWR0aD0xMDAlXSAgV2lkdGggb2YgdGhlIGlmcmFtZS4gSWYgbm90IGRlZmluZWQsIHVzZSAxMDAlLlxuICogQHBhcmFtIHtNaXhlZH0gW2hlaWdodD0xMDAlXSBIZWlnaHQgb2YgdGhlIGlmcmFtZS4gSWYgbm90IGRlZmluZWQsIHVzZSAxMDAlLlxuICovXG4uZGlyZWN0aXZlKCdtbUlmcmFtZScsIGZ1bmN0aW9uKCRtbVV0aWwpIHtcblxuICAgIHZhciBlcnJvclNob3duVGltZSA9IDAsXG4gICAgICAgIHRhZ3MgPSBbJ2lmcmFtZScsICdmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnXTtcblxuICAgIC8qKlxuICAgICAqIEludGVyY2VwdCB3aW5kb3cub3BlbiBpbiBhIGZyYW1lIGFuZCBpdHMgc3ViZnJhbWVzLCBzaG93cyBhbiBlcnJvciBtb2RhbCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHRyZWF0LlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJjZXB0UG9wdXBzKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFJlZGVmaW5lIHdpbmRvdy5vcGVuIGluIHRoaXMgZWxlbWVudCBhbmQgc3ViIGZyYW1lcywgaXQgbWlnaHQgaGF2ZSBiZWVuIGxvYWRlZCBhbHJlYWR5LlxuICAgICAgICAgICAgcmVkZWZpbmVXaW5kb3dPcGVuKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBlbGVtZW50Lm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gRWxlbWVudCBsb2FkZWQsIHJlZGVmaW5lIHdpbmRvdy5vcGVuIGFnYWluLlxuICAgICAgICAgICAgICAgIHJlZGVmaW5lV2luZG93T3BlbihlbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkZWZpbmUgdGhlIG9wZW4gbWV0aG9kIGluIHRoZSBjb250ZW50V2luZG93IG9mIGFuIGVsZW1lbnQgYW5kIHRoZSBzdWIgZnJhbWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHRyZWF0LlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkZWZpbmVXaW5kb3dPcGVuKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGVsID0gZWxlbWVudFswXSxcbiAgICAgICAgICAgIGNvbnRlbnRXaW5kb3cgPSBlbGVtZW50LmNvbnRlbnRXaW5kb3cgfHwgZWwuY29udGVudFdpbmRvdyxcbiAgICAgICAgICAgIGNvbnRlbnRzID0gZWxlbWVudC5jb250ZW50cygpO1xuXG4gICAgICAgIGlmICghY29udGVudFdpbmRvdyAmJiBlbCAmJiBlbC5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgcHJvYmFibHkgYW4gPG9iamVjdD4uIFRyeSB0byBnZXQgdGhlIHdpbmRvdy5cbiAgICAgICAgICAgIGNvbnRlbnRXaW5kb3cgPSBlbC5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbnRlbnRXaW5kb3cgJiYgZWwgJiYgZWwuZ2V0U1ZHRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgcHJvYmFibHkgYW4gPGVtYmVkPi4gVHJ5IHRvIGdldCB0aGUgd2luZG93LlxuICAgICAgICAgICAgdmFyIHN2Z0RvYyA9IGVsLmdldFNWR0RvY3VtZW50O1xuICAgICAgICAgICAgaWYgKHN2Z0RvYyAmJiBzdmdEb2MuZGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IGFuZ3VsYXIuZWxlbWVudChzdmdkb2MpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRXaW5kb3cgPSBzdmdkb2MuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsLndpbmRvdykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRXaW5kb3cgPSBlbC53aW5kb3c7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsLmdldFdpbmRvdykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRXaW5kb3cgPSBlbC5nZXRXaW5kb3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAvLyBJbnRlcmNlcHQgd2luZG93Lm9wZW4uXG4gICAgICAgICAgICBjb250ZW50V2luZG93Lm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBzaG93aW5nIG1vcmUgdGhhbiBvbmUgY29uc2VjdXRpdmUgZXJyb3IuIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBvZnRlbiBiZWNhdXNlIGl0IG1lYW5zIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyB1c2luZyBtb3JlIHRoYW4gb25lIHdpbmRvdy5vcGVuLCBidXQgaXQncyBiZXR0ZXIgdG8gaGFuZGxlIGl0IGp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgLSBlcnJvclNob3duVGltZSA+IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvclNob3duVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3JlLmVycm9yb3BlbnBvcHVwJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7fTsgLy8gUmV0dXJuIGVtcHR5IFwid2luZG93XCIgb2JqZWN0LlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlYXJjaCBzdWIgZnJhbWVzLlxuICAgICAgICBhbmd1bGFyLmZvckVhY2godGFncywgZnVuY3Rpb24odGFnKSB7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGVudHMuZmluZCh0YWcpLCBmdW5jdGlvbihzdWJlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJjZXB0UG9wdXBzKGFuZ3VsYXIuZWxlbWVudChzdWJlbGVtZW50KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwiaWZyYW1lLXdyYXBwZXJcIj48aWZyYW1lIGNsYXNzPVwibW0taWZyYW1lXCIgbmctc3R5bGU9XCJ7XFwnd2lkdGhcXCc6IHdpZHRoLCBcXCdoZWlnaHRcXCc6IGhlaWdodH1cIiBuZy1zcmM9XCJ7e3NyY319XCI+PC9pZnJhbWU+PC9kaXY+JyxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgIHNyYzogJz0nXG4gICAgICAgIH0sXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgc2NvcGUud2lkdGggPSAkbW1VdGlsLmZvcm1hdFBpeGVsc1NpemUoYXR0cnMuaWZyYW1lV2lkdGgpIHx8ICcxMDAlJztcbiAgICAgICAgICAgIHNjb3BlLmhlaWdodCA9ICRtbVV0aWwuZm9ybWF0UGl4ZWxzU2l6ZShhdHRycy5pZnJhbWVIZWlnaHQpIHx8ICcxMDAlJztcblxuICAgICAgICAgICAgdmFyIGlmcmFtZSA9IGFuZ3VsYXIuZWxlbWVudChlbGVtZW50LmZpbmQoJ2lmcmFtZScpWzBdKTtcbiAgICAgICAgICAgIGludGVyY2VwdFBvcHVwcyhpZnJhbWUpO1xuICAgICAgICAgICAgaWZyYW1lLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGlmcmFtZS5jb250ZW50cygpLmZpbmQoJ2EnKSwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhyZWYgJiYgaHJlZi5pbmRleE9mKCdodHRwJykgPT09IDApIHsgLy8gQ2hlY2sgdGhhdCBocmVmIGlzIG5vdCBudWxsLlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5lbGVtZW50KGVsKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5vcGVuSW5Ccm93c2VyKGhyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gcHJldmVudCBpbnB1dCB2YWxpZGF0aW9uIG9uIGlucHV0IGZpZWxkcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tTm9JbnB1dFZhbGlkYXRpb25cbiAqIEBkZXNjcmlwdGlvblxuICogU29tZXRpbWVzIHdlIG1pZ2h0IHdhbnQgdG8gZGlzYWJsZSBhdXRvbWF0aWMgdmFsaWRhdGlvbiBvbiBzb21lIGlucHV0IGZpZWxkcyAobGlrZSBVUkxzKS5cbiAqIFRoaXMgZGlyZWN0aXZlIGFsbG93cyB1cyB0byBkbyBzby5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1JbWFnZVZpZXdlcicsIGZ1bmN0aW9uKCRpb25pY01vZGFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgcHJpb3JpdHk6IDUwMCxcbiAgICAgICAgc2NvcGU6IHRydWUsXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgaWYgKGF0dHJzLmltZykge1xuICAgICAgICAgICAgICAgIHNjb3BlLmltZyA9IGF0dHJzLmltZztcblxuICAgICAgICAgICAgICAgIHNjb3BlLmNsb3NlTW9kYWwgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5tb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZS5tb2RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCdjb3JlL3RlbXBsYXRlcy9pbWFnZXZpZXdlci5odG1sJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246ICdzbGlkZS1pbi11cCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLm1vZGFsID0gbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5tb2RhbC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLm1vZGFsLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUubW9kYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLm1vZGFsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBzaG93IGEgbG9hZGluZyBzcGlubmVyIGFuZCBtZXNzYWdlIHdoaWxlIGRhdGEgaXMgYmVpbmcgbG9hZGVkLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1Mb2FkaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIFVzYWdlOlxuICogPG1tLWxvYWRpbmcgbWVzc2FnZT1cInt7bG9hZGluZ01lc3NhZ2V9fVwiIGhpZGUtdW50aWw9XCJkYXRhTG9hZGVkXCIgbG9hZGluZy1wYWRkaW5nLXRvcD1cInBhZGRpbmdUb3BcIj5cbiAqICAgICA8IS0tIENPTlRFTlQgVE8gSElERSBVTlRJTCBMT0FERUQgLS0+XG4gKiA8L21tLWxvYWRpbmc+XG4gKiBUaGlzIGRpcmVjdGl2ZSB3aWxsIHNob3cgYSBpb24tc3Bpbm5lciB3aXRoIGEgbWVzc2FnZSBhbmQgaGlkZSBhbGwgdGhlIGNvbnRlbnQgdW50aWwgJ2RhdGFMb2FkZWQnIHZhcmlhYmxlIGlzIHNldCB0byB0cnVlLlxuICogSWYgJ21lc3NhZ2UnIGF0dHJpYnV0ZSBpcyBub3Qgc2V0LCBkZWZhdWx0IG1lc3NhZ2UgXCJMb2FkaW5nXCIgaXMgc2hvd24uXG4gKiAnbWVzc2FnZScgYXR0cmlidXRlIGFjY2VwdHMgaGFyZGNvZGVkIHN0cmluZ3MsIHZhcmlhYmxlcywgZmlsdGVycywgZXRjLiBFLmcuIG1lc3NhZ2U9XCJ7eyAnbW0uY29yZS5sb2FkaW5nJyB8IHRyYW5zbGF0ZX19XCIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSAgICAgICAgICAgTWVzc2FnZSB0byBzaG93IHdoaWxlIGxvYWRpbmcuIElmIG5vdCBzZXQsIGRlZmF1bHQgXCJMb2FkaW5nXCIgbWVzc2FnZSBpcyBzaG93bi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBoaWRlVW50aWwgICAgICAgICAgIFNjb3BlIHZhcmlhYmxlIHRvIGRldGVybWluZSB3aGVuIHNob3VsZCB0aGUgY29udGVudHMgYmUgc2hvd24uIFdoZW4gdGhlIHZhcmlhYmxlIGlzIHNldFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdHJ1ZSwgdGhlIGxvYWRpbmcgaXMgaGlkZGVuIGFuZCB0aGUgY29udGVudHMgYXJlIHNob3duLlxuICogQHBhcmFtIHtTdHJpbmd9IFtsb2FkaW5nUGFkZGluZ1RvcF0gUGFkZGluZyB0b3AgdG8gc2V0IHRvIGxvYWRpbmcgdmlldy4gSWYgbm90IHNldCwgbm8gcGFkZGluZyB0b3AgaXMgc2V0LiBUaGlzIGF0dHJpYnV0ZSBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhbnQgdG8gYmUgdXNlZCB3aXRoIGR5bmFtaWMgcGFkZGluZ3MgKGUuZy4gdG8gbW92ZSB0aGUgbG9hZGluZyBzcGlubmVyIHRvIHRoZSB1c2VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3ApLiBTdGF0aWMgcGFkZGluZy10b3Agc2hvdWxkIGJlIHNldCB1c2luZyBDU1MuXG4gKi9cbi5kaXJlY3RpdmUoJ21tTG9hZGluZycsIGZ1bmN0aW9uKCR0cmFuc2xhdGUpIHtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS90ZW1wbGF0ZXMvbG9hZGluZy5odG1sJyxcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgIGhpZGVVbnRpbDogJz0/JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdAPycsXG4gICAgICAgICAgICBsb2FkaW5nUGFkZGluZ1RvcDogJz0/J1xuICAgICAgICB9LFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRbMF0sXG4gICAgICAgICAgICAgICAgbG9hZGluZyA9IGFuZ3VsYXIuZWxlbWVudChlbC5xdWVyeVNlbGVjdG9yKCcubW0tbG9hZGluZy1jb250YWluZXInKSk7XG5cbiAgICAgICAgICAgIGlmICghYXR0cnMubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgbG9hZGluZyBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICR0cmFuc2xhdGUoJ21tLmNvcmUubG9hZGluZycpLnRoZW4oZnVuY3Rpb24obG9hZGluZ1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5tZXNzYWdlID0gbG9hZGluZ1N0cmluZztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF0dHJzLmxvYWRpbmdQYWRkaW5nVG9wKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCdsb2FkaW5nUGFkZGluZ1RvcCcsIGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcnNlSW50IG9mIGFuIGludmFsaWQgc3RyaW5nIGlzIE5hTiwgYnV0IHBhcnNlSW50KCdhJykgPT0gTmFOIGlzIEZBTFNFIGFuZCB0eXBlb2YgTmFOID0gJ251bWJlcicuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoYXQncyB3aHkgd2UgdXNlIG51bSA+PSAwIG9yIG51bSA8IDAgdG8gY2hlY2sgaWYgaXQncyBhIHZhbGlkIG51bWJlci5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlSW50KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bSA+PSAwIHx8IG51bSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmcuY3NzKCdwYWRkaW5nLXRvcCcsIG5ld1ZhbHVlICsgJ3B4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YgbmV3VmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIHRoZXkgc2V0IGEgdmFsdWUgbGlrZSAnMjAwcHgnLlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZy5jc3MoJ3BhZGRpbmctdG9wJywgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIFRoaXMgZGlyZWN0aXZlIGFkZHMgYSBcImJhclwiIHdpdGggYXJyb3dzIHRvIG5hdmlnYXRlIGZvcndhcmQvYmFja3dhcmQgYW5kIGEgXCJpbmZvXCIgaWNvbiB0byBkaXNwbGF5IG1vcmUgZGF0YS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tTmF2aWdhdGlvbkJhclxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGRpcmVjdGl2ZSB3aWxsIHNob3cgdHdvIGFycm93cyBhdCB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIHNjcmVlbiB0byBuYXZpZ2F0ZSB0byBwcmV2aW91cy9uZXh0IGl0ZW0gd2hlbiBjbGlja2VkLlxuICogSWYgbm8gcHJldmlvdXMvbmV4dCBpdGVtIGlzIGRlZmluZWQsIHRoYXQgYXJyb3cgd29uJ3QgYmUgc2hvd24uIEl0IHdpbGwgYWxzbyBzaG93IGEgYnV0dG9uIHRvIHNob3cgbW9yZSBpbmZvLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9ICAgIFtwcmV2aW91c10gUHJldmlvdXMgaXRlbS4gSWYgbm90IGRlZmluZWQsIHRoZSBwcmV2aW91cyBhcnJvdyB3b24ndCBiZSBzaG93bi5cbiAqIEBwYXJhbSB7TWl4ZWR9ICAgIFtuZXh0XSAgICAgTmV4dCBpdGVtLiBJZiBub3QgZGVmaW5lZCwgdGhlIG5leHQgYXJyb3cgd29uJ3QgYmUgc2hvd24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbYWN0aW9uXSAgIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhbiBhcnJvdyBpcyBjbGlja2VkLiBXaWxsIHJlY2VpdmUgYXMgYSBwYXJhbSB0aGUgaXRlbSB0byBsb2FkLlxuICogQHBhcmFtIHtTdHJpbmd9ICAgW2luZm9dICAgICBJbmZvIHRvIHNob3cgd2hlbiBjbGlja2luZyB0aGUgaW5mbyBidXR0b24uIElmIG5vdCBkZWZpbmVkLCB0aGUgaW5mbyBidXR0b24gd29uJ3QgYmUgc2hvd24uXG4gKiBAcGFyYW0ge1N0cmluZ30gICBbdGl0bGVdICAgIFRpdGxlIHRvIHNob3cgd2hlbiBzZWVpbmcgdGhlIGluZm8gKG5ldyBzdGF0ZSkuXG4gKi9cbi5kaXJlY3RpdmUoJ21tTmF2aWdhdGlvbkJhcicsIGZ1bmN0aW9uKCRzdGF0ZSwgJHRyYW5zbGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICBwcmV2aW91czogJz0/JyxcbiAgICAgICAgICAgIG5leHQ6ICc9PycsXG4gICAgICAgICAgICBhY3Rpb246ICc9PycsXG4gICAgICAgICAgICBpbmZvOiAnPT8nXG4gICAgICAgIH0sXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS90ZW1wbGF0ZXMvbmF2aWdhdGlvbmJhci5odG1sJyxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICBzY29wZS50aXRsZSA9IGF0dHJzLnRpdGxlIHx8wqAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUuaW5mbycpO1xuICAgICAgICAgICAgc2NvcGUuc2hvd0luZm8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW1fdGV4dHZpZXdlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNjb3BlLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzY29wZS5pbmZvXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gcHJldmVudCBpbnB1dCB2YWxpZGF0aW9uIG9uIGlucHV0IGZpZWxkcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tTm9JbnB1dFZhbGlkYXRpb25cbiAqIEBkZXNjcmlwdGlvblxuICogU29tZXRpbWVzIHdlIG1pZ2h0IHdhbnQgdG8gZGlzYWJsZSBhdXRvbWF0aWMgdmFsaWRhdGlvbiBvbiBzb21lIGlucHV0IGZpZWxkcyAobGlrZSBVUkxzKS5cbiAqIFRoaXMgZGlyZWN0aXZlIGFsbG93cyB1cyB0byBkbyBzby5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1Ob0lucHV0VmFsaWRhdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgIHByaW9yaXR5OiA1MDAsXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGVsLCBhdHRycykge1xuICAgICAgICAgICAgYXR0cnMuJHNldCgndHlwZScsXG4gICAgICAgICAgICAgICAgbnVsbCwgICAgICAgICAgICAgICAgLy90byBkZWxldGUgdHlwZSBmcm9tIGF0dHJpYnV0ZXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgZmFsc2UgICAgICAgICAgICAgICAgLy90byBwcmVzZXJ2ZSB0eXBlIGF0dHJpYnV0ZSBpbiBET01cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi5jb25zdGFudCgnbW1Db3JlU3BsaXRWaWV3TG9hZCcsICdtbVNwbGl0Vmlldzpsb2FkJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gY3JlYXRlIGEgc3BsaXQgdmlldyBsYXlvdXQuIFRoaXMgZGlyZWN0aXZlIHNob3VsZCBiZSB1c2VkIGFsb25nIHdpdGggbW0tc3BsaXQtdmlldy1saW5rLlxuICpcbiAqIElNUE9SVEFOVDogRHVlIHRvIGEgbGltaXRhdGlvbiBpbiBBbmd1bGFyIHVpLXJvdXRlciwgdGhlIGxlZnQgcGFuZSBzdGF0ZSBhbmQgdGhlIHJpZ2h0IHBhbmUgc3RhdGUgc2hvdWxkIE5PVCBoYXZlXG4gKiBwYXJhbWV0ZXJzIHdpdGggdGhlIHNhbWUgbmFtZSBidXQgZGlmZmVyZW50IHZhbHVlLiBJdCBjYW4gY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvcnMuXG4gKiBFeGFtcGxlOiBpZiB0aGUgbGVmdCBwYW5lIGxvYWRzIGEgc3RhdGUgd2l0aCBwYXJhbSAnY291cnNlaWQnLCB0aGVuIGFsbCB0aGUgc3RhdGVzIHRoYXQgY2FuIGJlIGxvYWRlZCBpbiB0aGUgcmlnaHQgcGFuZVxuICogc2hvdWxkIGF2b2lkIGhhdmluZyBhIHBhcmFtZXRlciBuYW1lZCAnY291cnNlaWQnLiBUaGUgcmlnaHQgcGFuZSBzdGF0ZSBjYW4gaGF2ZSBhICdjb3Vyc2VpZCcgcGFyYW0gb25seSBpZiBpdCB3aWxsIGFsd2F5c1xuICogaGF2ZSB0aGUgc2FtZSB2YWx1ZSB0aGFuIGluIGxlZnQgcGFuZSBzdGF0ZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmVcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tU3BsaXRWaWV3XG4gKiBAZGVzY3JpcHRpb25cbiAqIFVzYWdlOlxuICogPG1tLXNwbGl0LXZpZXcgY29tcG9uZW50PVwibW1hQ2FsZW5kYXJFdmVudHNMaXN0XCI+XG4gKiAgICAgPCEtLSBDT05URU5UIFRPIFNIT1cgT04gVEhFIExFRlQgUEFORUwgKE1FTlUpIC0tPlxuICogPC9tbS1zcGxpdC12aWV3PlxuICpcbiAqIFRvIGNoYW5nZSB0aGUgcmlnaHQgcGFuZSBjb250ZW50cyAoY29udGVudCBwYW5lKSwgbW1TcGxpdFZpZXdMaW5rIGRpcmVjdGl2ZSBpcyBuZWVkZWQuXG4gKiBtbVNwbGl0VmlldyB3aWxsIGF1dG9tYXRpY2FsbHkgdHJ5IHRvIGxvYWQgYSBtbVNwbGl0Vmlld0xpbmsgd2hlbiB0aGUgdmlldyBpcyBsb2FkZWQuIFRoaXMgY2FuIGJlIGNvbmZpZ3VyZWQgdXNpbmdcbiAqIHRoZSBhdHRyaWJ1dGVzIFwibG9hZFwiIGFuZCBcImxvYWRXaGVuXCIuXG4gKlxuICogSWYgeW91IGRvbid0IGhhdmUgYWNjZXNzIHRvIHRoZSBkaXJlY3RpdmUncyBzY29wZSBidXQgeW91IHN0aWxsIHdhbnQgdG8gY29uZmlndXJlIHdoZW4gc2hvdWxkIHRoZSBkYXRhIGJlIGxvYWRlZCBhbmQgd2hpY2hcbiAqIGVsZW1lbnQgc2hvdWxkIGl0IGxvYWQgeW91IGNhbiB1c2UgdGhlIG1tQ29yZVNwbGl0Vmlld0xvYWQgZXZlbnQuIFdoZW4gdGhlIGRpcmVjdGl2ZSByZWNlaXZlcyB0aGlzIGV2ZW50IGl0IHdpbGwgdHJ5IHRvXG4gKiBpbW1lZGlhdGVseSBsb2FkIHRoZSBsaW5rIHNldCAoaWYgbm8gbGluayBpcyBzZXQgaXQgd2lsbCBsb2FkIHRoZSBmaXJzdCBsaW5rIGZvdW5kKS4gRXhhbXBsZTpcbiAqICRyb290U2NvcGUuJGJyb2FkY2FzdChtbUNvcmVTcGxpdFZpZXdMb2FkLCB7bG9hZDogMn0pO1xuICpcbiAqIElNUE9SVEFOVDogRHVlIHRvIGEgbGltaXRhdGlvbiBpbiBBbmd1bGFyIHVpLXJvdXRlciwgdGhlIGxlZnQgcGFuZSBzdGF0ZSBhbmQgdGhlIHJpZ2h0IHBhbmUgc3RhdGUgc2hvdWxkIE5PVCBoYXZlXG4gKiBwYXJhbWV0ZXJzIHdpdGggdGhlIHNhbWUgbmFtZSBidXQgZGlmZmVyZW50IHZhbHVlLiBJdCBjYW4gY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvcnMuXG4gKiBFeGFtcGxlOiBpZiB0aGUgbGVmdCBwYW5lIGxvYWRzIGEgc3RhdGUgd2l0aCBwYXJhbSAnY291cnNlaWQnLCB0aGVuIGFsbCB0aGUgc3RhdGVzIHRoYXQgY2FuIGJlIGxvYWRlZCBpbiB0aGUgcmlnaHQgcGFuZVxuICogc2hvdWxkIGF2b2lkIGhhdmluZyBhIHBhcmFtZXRlciBuYW1lZCAnY291cnNlaWQnLiBUaGUgcmlnaHQgcGFuZSBzdGF0ZSBjYW4gaGF2ZSBhICdjb3Vyc2VpZCcgcGFyYW0gb25seSBpZiBpdCB3aWxsIGFsd2F5c1xuICogaGF2ZSB0aGUgc2FtZSB2YWx1ZSB0aGFuIGluIGxlZnQgcGFuZSBzdGF0ZS5cbiAqXG4gKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcGFyYW1zOlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVudVdpZHRoXSBXaWR0aCBvZiB0aGUgbGVmdCBtZW51LiBDYW4gYmUgc3BlY2lmaWVkIGluIHBpeGVscyAoJzIwMHB4Jykgb3IgaW4gcGVyY2VudGFnZSAoJzMwJScpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbG9hZFdoZW5dICBOYW1lIG9mIGEgc2NvcGUgdmFyaWFibGUuIFdoZW4gdGhhdCB2YXJpYWJsZSBpcyBzZXQgdG8gdHJ1ZSwgYSBtbS1zcGxpdC12aWV3LWxpbmsgd2lsbCBiZSBsb2FkZWQgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgY29udGVudHMgcGFuZS4gSWYgbm90IHNldCwgdHJ5IHRvIGxvYWQgaXQgcmlnaHQgYXQgdGhlIHN0YXJ0LiBTZWUgXCJsb2FkXCIgcGFyYW0uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAgIENvbXBvbmVudC4gSW4gdGFibGV0LCB0aGUgbmV3IHZpZXcgd2lsbCBiZSBuYW1lZCBhZnRlciB0aGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbG9hZF0gTGluayB0byBsb2FkLiBJZiBub3Qgc2V0IHRoZW4gdGhlIGZpcnN0IGxpbmsgd2lsbCBiZSBsb2FkZWQgYnkgZGVmYXVsdC4gSWYgaXQncyBzZXQgdGhlbiBpdCB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB0byBsb2FkIHRoZSBudGggbGluay4gRS5nLiBsb2FkPTIgd2lsbCBsb2FkIHRoZSBzZWNvbmQgbGluayBpbiB0aGUgcGFnZS5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1TcGxpdFZpZXcnLCBmdW5jdGlvbigkbG9nLCAkc3RhdGUsICRpb25pY1BsYXRmb3JtLCAkdGltZW91dCwgJG1tVXRpbCwgJGludGVycG9sYXRlLCBtbUNvcmVTcGxpdFZpZXdMb2FkKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1TcGxpdFZpZXcnKTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgY2xpY2sgb24gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbGluayBET00gZWxlbWVudCB0byB0cmlnZ2VyIGNsaWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIHN1Y2Nlc3MsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyQ2xpY2sobGluaykge1xuICAgICAgICBpZiAobGluayAmJiBsaW5rLmxlbmd0aCAmJiBsaW5rLnRyaWdnZXJIYW5kbGVyKSB7XG4gICAgICAgICAgICBsaW5rLnRyaWdnZXJIYW5kbGVyKCdjbGljaycpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERpcmVjdGl2ZSBjb250cm9sbGVyLlxuICAgIGZ1bmN0aW9uIGNvbnRyb2xsZXIoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBtZW51U3RhdGUsXG4gICAgICAgICAgICBsaW5rVG9Mb2FkLFxuICAgICAgICAgICAgY29tcG9uZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgbGlua3MgbWFya2VkIGFzIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhck1hcmtlZExpbmtzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbbW0tc3BsaXQtdmlldy1saW5rXScpKS5yZW1vdmVDbGFzcygnbW0tc3BsaXQtaXRlbS1zZWxlY3RlZCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IENvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc3BsaXQgdmlldyBtZW51J3Mgc3RhdGUgbmFtZSAobGVmdCBwYW5lKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBNZW51IHN0YXRlIG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE1lbnVTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lbnVTdGF0ZSB8fMKgJHN0YXRlLmN1cnJlbnQubmFtZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTG9hZCBhIG1tLXNwbGl0LXZpZXctbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gICAgICAgICAgIERpcmVjdGl2ZSdzIHNjb3BlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtsb2FkQXR0cl0gTnVtYmVyIG9mIGxpbmsgdG8gbG9hZC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSByZXRyeWluZyAgICAgICAgIFRydWUgaWYgd2UncmUgcmV0cnlpbmcgYmVjYXVzZSB0aGUgZnVuY3Rpb24gZmFpbGVkIChsaW5rIHdhc24ndCByZWFkeSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvYWRMaW5rID0gZnVuY3Rpb24oc2NvcGUsIGxvYWRBdHRyLCByZXRyeWluZykge1xuICAgICAgICAgICAgaWYgKCRpb25pY1BsYXRmb3JtLmlzVGFibGV0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmtUb0xvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gbGluayBzZXQuIExldCdzIGRldGVybWluZSBpZiBsb2FkQXR0ciBpcyBzZXQgYW5kIGl0cyByZWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRBdHRyICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBwYXJzZUludChsb2FkQXR0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlbXMgaXQncyBub3QgYSBudW1iZXIuIFRyeSB0byBpbnRlcnBvbGF0ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBhcnNlSW50KCRpbnRlcnBvbGF0ZShsb2FkQXR0cikoc2NvcGUpLCAxMCk7IC8vIFwiRXZhbHVhdGVcIiBzY29wZSB2YXJpYWJsZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlua3MgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1ttbS1zcGxpdC12aWV3LWxpbmtdJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA+IGxpbmtzLmxlbmd0aCA/IDAgOiBwb3NpdGlvbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua1RvTG9hZCA9IGFuZ3VsYXIuZWxlbWVudChsaW5rc1twb3NpdGlvbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIGZpcnN0IGxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rVG9Mb2FkID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnQucXVlcnlTZWxlY3RvcignW21tLXNwbGl0LXZpZXctbGlua10nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIGZpcnN0IGxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtUb0xvYWQgPSBhbmd1bGFyLmVsZW1lbnQoZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdbbW0tc3BsaXQtdmlldy1saW5rXScpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdHJpZ2dlckNsaWNrKGxpbmtUb0xvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExpbmsgbm90IGZvdW5kLiBMZXQncyByZXRyeSBvbmNlIGluIHRoZSBuZXh0IGRpZ2VzdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXRyeWluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua1RvTG9hZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZExpbmsoc2NvcGUsIGxvYWRBdHRyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY21wIENvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50ID0gZnVuY3Rpb24oY21wKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBjbXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBkaXJlY3RpdmUncyBET00gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVsIERpcmVjdGl2ZSdzIERPTSBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRFbGVtZW50ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IG1tLXNwbGl0LXZpZXctbGluayB0byBsb2FkLiBVc2VkIHRvIHJlLWxvYWQgbGFzdCBzdGF0ZSBpZiBuZWVkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaW5rIExpbmsgdG8gc2V0IChET00gZWxlbWVudCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldExpbmsgPSBmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgICBsaW5rVG9Mb2FkID0gbGluaztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHNwbGl0IHZpZXcgbWVudSdzIHN0YXRlIG5hbWUgKGxlZnQgcGFuZSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZSBTdGF0ZSBuYW1lIHRvIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0TWVudVN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIG1lbnVTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS90ZW1wbGF0ZXMvc3BsaXR2aWV3Lmh0bWwnLFxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgICAgICBjb250cm9sbGVyOiBjb250cm9sbGVyLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRbMF0sXG4gICAgICAgICAgICAgICAgbWVudSA9IGFuZ3VsYXIuZWxlbWVudChlbC5xdWVyeVNlbGVjdG9yKCcubW0tc3BsaXQtcGFuZS1tZW51JykpLFxuICAgICAgICAgICAgICAgIG1lbnVTdGF0ZSA9ICRzdGF0ZS4kY3VycmVudC5uYW1lLFxuICAgICAgICAgICAgICAgIG1lbnVQYXJhbXMgPSAkc3RhdGUucGFyYW1zLFxuICAgICAgICAgICAgICAgIG1lbnVXaWR0aCA9IGF0dHJzLm1lbnVXaWR0aCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBhdHRycy5jb21wb25lbnQgfHwgJ3RhYmxldCc7XG5cbiAgICAgICAgICAgIHNjb3BlLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblxuICAgICAgICAgICAgY29udHJvbGxlci5zZXRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0RWxlbWVudChlbCk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNldE1lbnVTdGF0ZShtZW51U3RhdGUpO1xuXG4gICAgICAgICAgICBpZiAobWVudVdpZHRoICYmICRpb25pY1BsYXRmb3JtLmlzVGFibGV0KCkpIHtcbiAgICAgICAgICAgICAgICBtZW51LmNzcygnd2lkdGgnLCBtZW51V2lkdGgpO1xuICAgICAgICAgICAgICAgIG1lbnUuY3NzKCctd2Via2l0LWZsZXgtYmFzaXMnLCBtZW51V2lkdGgpO1xuICAgICAgICAgICAgICAgIG1lbnUuY3NzKCctbW96LWZsZXgtYmFzaXMnLCBtZW51V2lkdGgpO1xuICAgICAgICAgICAgICAgIG1lbnUuY3NzKCctbXMtZmxleC1iYXNpcycsIG1lbnVXaWR0aCk7XG4gICAgICAgICAgICAgICAgbWVudS5jc3MoJ2ZsZXgtYmFzaXMnLCBtZW51V2lkdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSdsbCBzZXQgYWxsIHRoZSBsaXN0ZW5lcnMgZXZlbiBpZiBpdCdzIG5vdCBhIHRhYmxldCwgdG8gc3VwcG9ydCBjaGFuZ2UgYmV0d2VlbiB0YWJsZXQtc21hcnRwaG9uZSBtb2RlLlxuXG4gICAgICAgICAgICBpZiAoYXR0cnMubG9hZFdoZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBMb2FkIGxpbmsgd2hlbiB2YXJpYWJsZSBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goYXR0cnMubG9hZFdoZW4sIGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5sb2FkTGluayhzY29wZSwgYXR0cnMubG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5sb2FkTGluayhzY29wZSwgYXR0cnMubG9hZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExvYWQgbGFzdCBvcGVuZWQgbGluayB3aGVuIHdlIHJlLWVudGVyIHRoZSBzYW1lIHN0YXRlLiBXZSB1c2UgJHN0YXRlQ2hhbmdlU3VjY2VzcyBpbnN0ZWFkIG9mICRpb25pY1ZpZXcuZW50ZXJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgJGlvbmljVmlldy5lbnRlciBpcyBub3QgdHJpZ2dlcmVkIHdoZW4gZ29pbmcgdG8gdGhlIHNhbWUgc3RhdGUuXG4gICAgICAgICAgICBzY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN1Y2Nlc3MnLCBmdW5jdGlvbihldmVudCwgdG9TdGF0ZSwgdG9QYXJhbXMsIGZyb21TdGF0ZSwgZnJvbVBhcmFtcykge1xuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgdGhhdCBuYW1lIGFuZCBwYXJhbXMgYXJlIHNpbWlsYXIuIFdlJ2xsIG9ubHkgY29tcGFyZSAxc3QgbGV2ZWwgb2YgcGFyYW1zLCBpdCdzIG5vdCBhIGRlZXAgY29tcGFyZS5cbiAgICAgICAgICAgICAgICBpZiAodG9TdGF0ZS5uYW1lID09PSBtZW51U3RhdGUgJiYgJG1tVXRpbC5iYXNpY0xlZnRDb21wYXJlKHRvUGFyYW1zLCBtZW51UGFyYW1zLCAxKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmxvYWRMaW5rKCk7IC8vIE5vIG5lZWQgdG8gcGFzcyBzY29wZSBhbmQgbG9hZCwgbGluayBzaG91bGQgYmUgc2V0LlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGV2ZW50IHRvIGxvYWQgbGluay5cbiAgICAgICAgICAgIHNjb3BlLiRvbihtbUNvcmVTcGxpdFZpZXdMb2FkLCBmdW5jdGlvbihlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIubG9hZExpbmsoc2NvcGUsIGRhdGEubG9hZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5sb2FkTGluayhzY29wZSwgYXR0cnMubG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBsb2FkIGEgc3RhdGUgaW4gYSBzcGxpdC12aWV3LWNvbnRlbnQgcGFuZSBpbiB0YWJsZXQgb3IgaW4gYSBuZXcgcGFnZSBpbiBwaG9uZS5cbiAqIFJlcXVpcmVzIGJlaW5nIGEgY2hpbGQgb2YgbW1TcGxpdFZpZXcuXG4gKlxuICogSU1QT1JUQU5UOiBEdWUgdG8gYSBsaW1pdGF0aW9uIGluIEFuZ3VsYXIgdWktcm91dGVyLCB0aGUgbGVmdCBwYW5lIHN0YXRlIGFuZCB0aGUgcmlnaHQgcGFuZSBzdGF0ZSBzaG91bGQgTk9UIGhhdmVcbiAqIHBhcmFtZXRlcnMgd2l0aCB0aGUgc2FtZSBuYW1lIGJ1dCBkaWZmZXJlbnQgdmFsdWUuIEl0IGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAqIEV4YW1wbGU6IGlmIHRoZSBsZWZ0IHBhbmUgbG9hZHMgYSBzdGF0ZSB3aXRoIHBhcmFtICdjb3Vyc2VpZCcsIHRoZW4gYWxsIHRoZSBzdGF0ZXMgdGhhdCBjYW4gYmUgbG9hZGVkIGluIHRoZSByaWdodCBwYW5lXG4gKiBzaG91bGQgYXZvaWQgaGF2aW5nIGEgcGFyYW1ldGVyIG5hbWVkICdjb3Vyc2VpZCcuIFRoZSByaWdodCBwYW5lIHN0YXRlIGNhbiBoYXZlIGEgJ2NvdXJzZWlkJyBwYXJhbSBvbmx5IGlmIGl0IHdpbGwgYWx3YXlzXG4gKiBoYXZlIHRoZSBzYW1lIHZhbHVlIHRoYW4gaW4gbGVmdCBwYW5lIHN0YXRlLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1TcGxpdFZpZXdMaW5rXG4gKiBAZGVzY3JpcHRpb25cbiAqIFVzYWdlOlxuICogPC4uLiBtbS1zcGxpdC12aWV3LWxpbms9XCJzaXRlLm1tX3VzZXItcHJvZmlsZSh7Y291cnNlaWQ6IGNvdXJzZWlkLCB1c2VyaWQ6IHBhcnRpY2lwYW50LmlkfSlcIiA+XG4gKlxuICogVGhpcyBkaXJlY3RpdmUgYWNjZXB0cyBhIHNyZWYgc3RyaW5nIHRoYXQgaW5kaWNhdGVzIHRoZSBzdGF0ZSB0byBnbyB0byBhbmQgdGhlIHBhcmFtcy4gU2NvcGUgdmFyaWFibGUgbmVlZCB0byBiZVxuICogaW5zaWRlIGN1cmx5IGJyYWNrZXRzOiB7e3ZhcmlhYmxlX25hbWV9fS5cbiAqIEluIHRhYmxldCwgdGhlIG5ldyBzdGF0ZSBjb250ZW50cyB3aWxsIGJlIGxvYWRlZCBpbiBzcGxpdC1wYW5lIGNvbnRlbnRzIHBhbmUuXG4gKiBJbiBwaG9uZSwgdGhlIG5ldyBzdGF0ZSBjb250ZW50cyB3aWxsIGJlIGxvYWRlZCBpbiBhIG5ldyBwYWdlLlxuICovXG4uZGlyZWN0aXZlKCdtbVNwbGl0Vmlld0xpbmsnLCBmdW5jdGlvbigkbG9nLCAkaW9uaWNQbGF0Zm9ybSwgJHN0YXRlLCAkbW1BcHApIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1TcGxpdFZpZXdMaW5rJyk7XG5cbiAgICB2YXIgc3JlZlJlZ2V4ID0gbmV3IFJlZ0V4cCgvKFteXFwoXSopKFxcKCguKilcXCkpPyQvKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzdGF0ZSBmb3IgdGFibGV0IHZpZXcgKHNwbGl0LXZpZXcpLiBUaGUgc3RhdGUgY3JlYXRlZCB3aWxsIGJlIGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhlIHRhcmdldCBzdGF0ZVxuICAgICAqIChzdGF0ZU5hbWUpLCBidXQgY2hhbmdpbmcgdGhlIG5hbWUgYW5kIHRoZSB2aWV3IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0YXRlTmFtZSAgICAgICBOYW1lIG9mIHRoZSBzdGF0ZSB0byBjb3B5LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGFibGV0U3RhdGVOYW1lIE5hbWUgb2YgdGhlIG5ldyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5ld1ZpZXdOYW1lICAgICBOYW1lIG9mIHRoZSBuZXcgdmlldy5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICBUcnVlIGlmIHN1Y2Nlc3MsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUYWJsZXRTdGF0ZShzdGF0ZU5hbWUsIHRhYmxldFN0YXRlTmFtZSwgbmV3Vmlld05hbWUpIHtcbiAgICAgICAgdmFyIHRhcmdldFN0YXRlID0gJHN0YXRlLmdldChzdGF0ZU5hbWUpLFxuICAgICAgICAgICAgbmV3Q29uZmlnLFxuICAgICAgICAgICAgdmlld05hbWU7XG5cbiAgICAgICAgaWYgKHRhcmdldFN0YXRlKSB7XG4gICAgICAgICAgICBuZXdDb25maWcgPSBhbmd1bGFyLmNvcHkodGFyZ2V0U3RhdGUpO1xuXG4gICAgICAgICAgICAvLyBDaGFuZ2UgZmlyc3QgdmlldyBuYW1lIHRvICd0YWJsZXQnIHNvIGl0J3MgbG9hZGVkIGluIHRoZSBzcGxpdC12aWV3IGNvbnRlbnQgcGFuZS5cbiAgICAgICAgICAgIHZpZXdOYW1lID0gT2JqZWN0LmtleXMobmV3Q29uZmlnLnZpZXdzKVswXTtcbiAgICAgICAgICAgIG5ld0NvbmZpZy52aWV3c1tuZXdWaWV3TmFtZV0gPSBuZXdDb25maWcudmlld3Nbdmlld05hbWVdO1xuICAgICAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy52aWV3c1t2aWV3TmFtZV07XG4gICAgICAgICAgICBkZWxldGUgbmV3Q29uZmlnWyduYW1lJ107XG5cbiAgICAgICAgICAgICRtbUFwcC5jcmVhdGVTdGF0ZSh0YWJsZXRTdGF0ZU5hbWUsIG5ld0NvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRsb2cuZXJyb3IoJ1N0YXRlIGRvZXNuXFwndCBleGlzdDogJytzdGF0ZU5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYSBzdHJpbmcgdXNpbmcgc2NvcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3BlIFNjb3BlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdmFsdWUgU3RyaW5nIHRvIGV2YWwuXG4gICAgICogQHJldHVybiB7TWl4ZWR9ICAgICAgICBFdmFsdWF0ZWQgdmFsdWUgb3IgdW5kZWZpbmVkIGlmIG5vdCB2YWxpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY29wZUV2YWwoc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLiRldmFsKHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciBldmFsdWF0aW5nIHN0cmluZzogJyArIHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgIHJlcXVpcmU6ICdebW1TcGxpdFZpZXcnLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIHNwbGl0Vmlld0NvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHZhciBzcmVmID0gYXR0cnMubW1TcGxpdFZpZXdMaW5rLFxuICAgICAgICAgICAgICAgIG1lbnVTdGF0ZSA9IHNwbGl0Vmlld0NvbnRyb2xsZXIuZ2V0TWVudVN0YXRlKCksXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBzdGF0ZU5hbWUsXG4gICAgICAgICAgICAgICAgc3RhdGVQYXJhbXMsXG4gICAgICAgICAgICAgICAgc3RhdGVQYXJhbXNTdHJpbmcsXG4gICAgICAgICAgICAgICAgdGFibGV0U3RhdGVOYW1lO1xuXG4gICAgICAgICAgICBpZiAoc3JlZikge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBzcmVmLm1hdGNoKHNyZWZSZWdleCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVOYW1lID0gbWF0Y2hlc1sxXTsgLy8gRS5nLiBzaXRlLm1tX3VzZXItcHJvZmlsZVxuICAgICAgICAgICAgICAgICAgICB0YWJsZXRTdGF0ZU5hbWUgPSBtZW51U3RhdGUgKyAnLicgKyBzdGF0ZU5hbWUuc3Vic3RyKHN0YXRlTmFtZS5sYXN0SW5kZXhPZignLicpICsgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXJhbXNTdHJpbmcgPSBtYXRjaGVzWzNdOyAvLyBFLmcuIHtjb3Vyc2VpZDogY291cnNlaWQsIHVzZXJpZDogdXNlcmlkfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVBhcmFtcyA9IHNjb3BlRXZhbChzY29wZSwgc3RhdGVQYXJhbXNTdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhdGNoIGZvciBjaGFuZ2VzIG9uIHN0YXRlUGFyYW1zLlxuICAgICAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goc3RhdGVQYXJhbXNTdHJpbmcsIGZ1bmN0aW9uKG5ld1ZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXJhbXMgPSBuZXdWYWw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpb25pY1BsYXRmb3JtLmlzVGFibGV0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzdGF0ZS5nZXQodGFibGV0U3RhdGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGF0ZSBkb2Vzbid0IGV4aXN0cy4gTGV0J3MgY3JlYXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNyZWF0ZVRhYmxldFN0YXRlKHN0YXRlTmFtZSwgdGFibGV0U3RhdGVOYW1lLCBzcGxpdFZpZXdDb250cm9sbGVyLmdldENvbXBvbmVudCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0Vmlld0NvbnRyb2xsZXIuc2V0TGluayhlbGVtZW50KTsgLy8gU2V0IGxhc3QgbGluayBsb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRWaWV3Q29udHJvbGxlci5jbGVhck1hcmtlZExpbmtzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRDbGFzcygnbW0tc3BsaXQtaXRlbS1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbyh0YWJsZXRTdGF0ZU5hbWUsIHN0YXRlUGFyYW1zLCB7bG9jYXRpb246J3JlcGxhY2UnfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbyhzdGF0ZU5hbWUsIHN0YXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignSW52YWxpZCBzcmVmLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJGxvZy5lcnJvcignSW52YWxpZCBzcmVmLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvbnRlbnRsaW5rcycsIFtdKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdtbV9jb250ZW50bGlua3MnLCB7XG4gICAgICAgIHVybDogJy9tbV9jb250ZW50bGlua3MnLFxuICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvY29udGVudGxpbmtzL3RlbXBsYXRlcy9iYXNlLmh0bWwnLFxuICAgICAgICBjYWNoZTogZmFsc2UsICAgLy8gRGlzYWJsZSBjYWNoaW5nIHRvIGZvcmNlIGNvbnRyb2xsZXIgcmVsb2FkLlxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ21tX2NvbnRlbnRsaW5rcy5jaG9vc2VzaXRlJywge1xuICAgICAgICB1cmw6ICcvY2hvb3Nlc2l0ZScsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2NvbnRlbnRsaW5rcy90ZW1wbGF0ZXMvY2hvb3Nlc2l0ZS5odG1sJyxcbiAgICAgICAgY29udHJvbGxlcjogJ21tQ29udGVudExpbmtzQ2hvb3NlU2l0ZUN0cmwnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHVybDogbnVsbFxuICAgICAgICB9XG4gICAgfSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2UnLCBbJ21tLmNvcmUuY291cnNlcyddKVxuXG4uY29uc3RhbnQoJ21tQ29yZUNvdXJzZVByaW9yaXR5JywgODAwKVxuLmNvbnN0YW50KCdtbUNvcmVDb3Vyc2VBbGxTZWN0aW9uc0lkJywgLTEpXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICRtbUNvdXJzZXNEZWxlZ2F0ZVByb3ZpZGVyLCBtbUNvcmVDb3Vyc2VQcmlvcml0eSkge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tbV9jb3Vyc2UnLCB7XG4gICAgICAgIHVybDogJy9tbV9jb3Vyc2UnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGNvdXJzZWlkOiBudWxsLFxuICAgICAgICAgICAgc2lkOiBudWxsLCAvLyBTZWN0aW9uIHRvIGxvYWQuIE5vdCBuYW1pbmcgaXQgc2VjdGlvbmlkIGJlY2F1c2UgaXQgY29sbGlkZXMgd2l0aCAnbW1fY291cnNlLXNlY3Rpb24nIHBhcmFtIGluIHNwbGl0LXZpZXcuXG4gICAgICAgICAgICBtb2R1bGVpZDogbnVsbCAvLyBNb2R1bGUgdG8gbG9hZC5cbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2NvdXJzZS90ZW1wbGF0ZXMvc2VjdGlvbnMuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tQ291cnNlU2VjdGlvbnNDdHJsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tbV9jb3Vyc2Utc2VjdGlvbicsIHtcbiAgICAgICAgdXJsOiAnL21tX2NvdXJzZS1zZWN0aW9uJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBzZWN0aW9uaWQ6IG51bGwsXG4gICAgICAgICAgICBjaWQ6IG51bGwsIC8vIE5vdCBuYW1pbmcgaXQgY291cnNlaWQgYmVjYXVzZSBpdCBjb2xsaWRlcyB3aXRoICdzaXRlLm1tX2NvdXJzZScgcGFyYW0gaW4gc3BsaXQtdmlldy5cbiAgICAgICAgICAgIG1pZDogbnVsbCAvLyBOb3QgbmFtaW5nIGl0IG1vZHVsZWlkIGJlY2F1c2UgaXQgY29sbGlkZXMgd2l0aCAnc2l0ZS5tbV9jb3Vyc2UnIHBhcmFtIGluIHNwbGl0LXZpZXcuXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9jb3Vyc2UvdGVtcGxhdGVzL3NlY3Rpb24uaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tQ291cnNlU2VjdGlvbkN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1tX2NvdXJzZS1tb2Rjb250ZW50Jywge1xuICAgICAgICB1cmw6ICcvbW1fY291cnNlLW1vZGNvbnRlbnQnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgc2l0ZToge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2NvdXJzZS90ZW1wbGF0ZXMvbW9kY29udGVudC5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1Db3Vyc2VNb2RDb250ZW50Q3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJG1tQ291cnNlc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJOYXZIYW5kbGVyKCdtbUNvdXJzZScsICckbW1Db3Vyc2VDb3Vyc2VzTmF2SGFuZGxlcicsIG1tQ29yZUNvdXJzZVByaW9yaXR5KTtcbn0pXG5cbi5ydW4oZnVuY3Rpb24oJG1tRXZlbnRzLCBtbUNvcmVFdmVudExvZ2luLCBtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCAkbW1Db3Vyc2VEZWxlZ2F0ZSkge1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudExvZ2luLCAkbW1Db3Vyc2VEZWxlZ2F0ZS51cGRhdGVDb250ZW50SGFuZGxlcnMpO1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCAkbW1Db3Vyc2VEZWxlZ2F0ZS51cGRhdGVDb250ZW50SGFuZGxlcnMpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlcycsIFtdKVxuXG4uY29uc3RhbnQoJ21tQ291cnNlc1NlYXJjaENvbXBvbmVudCcsICdtbUNvdXJzZXNTZWFyY2gnKVxuLmNvbnN0YW50KCdtbUNvdXJzZXNTZWFyY2hQZXJQYWdlJywgMjApIC8vIE1heCBvZiBjb3Vyc2VzIHBlciBwYWdlIHdoZW4gc2VhcmNoaW5nIGNvdXJzZXMuXG4uY29uc3RhbnQoJ21tQ291cnNlc0Vucm9sSW52YWxpZEtleScsICdtbUNvdXJzZXNFbnJvbEludmFsaWRLZXknKVxuLmNvbnN0YW50KCdtbUNvdXJzZXNFdmVudE15Q291cnNlc1VwZGF0ZWQnLCAnbXlfY291cnNlc191cGRhdGVkJylcbi5jb25zdGFudCgnbW1Db3Vyc2VzQWNjZXNzTWV0aG9kcycsIHtcbiAgICAgZ3Vlc3Q6ICdndWVzdCcsXG4gICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tbV9jb3Vyc2VzJywge1xuICAgICAgICB1cmw6ICcvbW1fY291cnNlcycsXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9jb3Vyc2VzL3RlbXBsYXRlcy9saXN0Lmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbUNvdXJzZXNMaXN0Q3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ3NpdGUubW1fc2VhcmNoY291cnNlcycsIHtcbiAgICAgICAgdXJsOiAnL21tX3NlYXJjaGNvdXJzZXMnLFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvY291cnNlcy90ZW1wbGF0ZXMvc2VhcmNoLmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbUNvdXJzZXNTZWFyY2hDdHJsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tbV92aWV3cmVzdWx0Jywge1xuICAgICAgICB1cmw6ICcvbW1fdmlld3Jlc3VsdCcsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgY291cnNlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9jb3Vyc2VzL3RlbXBsYXRlcy92aWV3cmVzdWx0Lmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbUNvdXJzZXNWaWV3UmVzdWx0Q3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tQ291cnNlcycsICckbW1Db3Vyc2VzSGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KVxuXG4ucnVuKGZ1bmN0aW9uKCRtbUV2ZW50cywgbW1Db3JlRXZlbnRMb2dpbiwgbW1Db3JlRXZlbnRTaXRlVXBkYXRlZCwgbW1Db3JlRXZlbnRMb2dvdXQsICRtbUNvdXJzZXNEZWxlZ2F0ZSwgJG1tQ291cnNlcykge1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudExvZ2luLCAkbW1Db3Vyc2VzRGVsZWdhdGUudXBkYXRlTmF2SGFuZGxlcnMpO1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCAkbW1Db3Vyc2VzRGVsZWdhdGUudXBkYXRlTmF2SGFuZGxlcnMpO1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudExvZ291dCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbUNvdXJzZXNEZWxlZ2F0ZS5jbGVhckNvdXJzZXNIYW5kbGVycygpO1xuICAgICAgICAkbW1Db3Vyc2VzLmNsZWFyQ3VycmVudENvdXJzZXMoKTtcbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmxvZ2luJywgW10pXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICR1cmxSb3V0ZXJQcm92aWRlciwgJG1tSW5pdERlbGVnYXRlUHJvdmlkZXIsIG1tSW5pdERlbGVnYXRlTWF4QWRkb25Qcmlvcml0eSkge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnbW1fbG9naW4nLCB7XG4gICAgICAgIHVybDogJy9tbV9sb2dpbicsXG4gICAgICAgIGFic3RyYWN0OiB0cnVlLFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9sb2dpbi90ZW1wbGF0ZXMvYmFzZS5odG1sJyxcbiAgICAgICAgY2FjaGU6IGZhbHNlLCAgIC8vIERpc2FibGUgY2FjaGluZyB0byBmb3JjZSBjb250cm9sbGVyIHJlbG9hZC5cbiAgICAgICAgb25FbnRlcjogZnVuY3Rpb24oJGlvbmljSGlzdG9yeSkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgbm8gaGlzdG9yeSBzdGFjayB3aGVuIGdldHRpbmcgaGVyZS5cbiAgICAgICAgICAgICRpb25pY0hpc3RvcnkuY2xlYXJIaXN0b3J5KCk7XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdtbV9sb2dpbi5pbml0Jywge1xuICAgICAgICB1cmw6ICcvaW5pdCcsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2xvZ2luL3RlbXBsYXRlcy9pbml0Lmh0bWwnLFxuICAgICAgICBjb250cm9sbGVyOiAnbW1Mb2dpbkluaXRDdHJsJyxcbiAgICAgICAgY2FjaGU6IGZhbHNlIC8vIERpc2FibGUgY2FjaGluZyB0byBmb3JjZSBjb250cm9sbGVyIHJlbG9hZC5cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdtbV9sb2dpbi5zaXRlcycsIHtcbiAgICAgICAgdXJsOiAnL3NpdGVzJyxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvbG9naW4vdGVtcGxhdGVzL3NpdGVzLmh0bWwnLFxuICAgICAgICBjb250cm9sbGVyOiAnbW1Mb2dpblNpdGVzQ3RybCcsXG4gICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uKCRtbUxvZ2luSGVscGVyLCAkbW1TaXRlc01hbmFnZXIpIHtcbiAgICAgICAgICAgIC8vIFNraXAgdGhpcyBwYWdlIGlmIHRoZXJlIGFyZSBubyBzaXRlcyB5ZXQuXG4gICAgICAgICAgICAkbW1TaXRlc01hbmFnZXIuaGFzTm9TaXRlcygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJG1tTG9naW5IZWxwZXIuZ29Ub0FkZFNpdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnbW1fbG9naW4uc2l0ZScsIHtcbiAgICAgICAgdXJsOiAnL3NpdGUnLFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9sb2dpbi90ZW1wbGF0ZXMvc2l0ZS5odG1sJyxcbiAgICAgICAgY29udHJvbGxlcjogJ21tTG9naW5TaXRlQ3RybCdcbiAgICB9KVxuXG4gICAgLnN0YXRlKCdtbV9sb2dpbi5jcmVkZW50aWFscycsIHtcbiAgICAgICAgdXJsOiAnL2NyZWQnLFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9sb2dpbi90ZW1wbGF0ZXMvY3JlZGVudGlhbHMuaHRtbCcsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdtbUxvZ2luQ3JlZGVudGlhbHNDdHJsJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBzaXRldXJsOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBvbkVudGVyOiBmdW5jdGlvbigkc3RhdGUsICRzdGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGFjY2VzcyB0byB0aGlzIHBhZ2Ugd2hlbiB0aGUgVVJMIHdhcyBub3QgcGFzc2VkLlxuICAgICAgICAgICAgaWYgKCEkc3RhdGVQYXJhbXMuc2l0ZXVybCkge1xuICAgICAgICAgICAgICAkc3RhdGUuZ28oJ21tX2xvZ2luLmluaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ21tX2xvZ2luLnJlY29ubmVjdCcsIHtcbiAgICAgICAgdXJsOiAnL3JlY29ubmVjdCcsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2xvZ2luL3RlbXBsYXRlcy9yZWNvbm5lY3QuaHRtbCcsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdtbUxvZ2luUmVjb25uZWN0Q3RybCcsXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBzaXRldXJsOiAnJyxcbiAgICAgICAgICAgIHVzZXJuYW1lOiAnJyxcbiAgICAgICAgICAgIGluZm9zaXRldXJsOiAnJ1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEZWZhdWx0IHJlZGlyZWN0IHRvIHRoZSBsb2dpbiBwYWdlLlxuICAgICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoZnVuY3Rpb24oJGluamVjdG9yKSB7XG4gICAgICAgIHZhciAkc3RhdGUgPSAkaW5qZWN0b3IuZ2V0KCckc3RhdGUnKTtcbiAgICAgICAgcmV0dXJuICRzdGF0ZS5ocmVmKCdtbV9sb2dpbi5pbml0JykucmVwbGFjZSgnIycsICcnKTtcbiAgICB9KTtcblxuICAgIC8vIFJlc3RvcmUgdGhlIHNlc3Npb24uXG4gICAgJG1tSW5pdERlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcm9jZXNzKCdtbUxvZ2luJywgJyRtbVNpdGVzTWFuYWdlci5yZXN0b3JlU2Vzc2lvbicsIG1tSW5pdERlbGVnYXRlTWF4QWRkb25Qcmlvcml0eSArIDIwMCk7XG59KVxuXG4ucnVuKGZ1bmN0aW9uKCRsb2csICRzdGF0ZSwgJG1tVXRpbCwgJHRyYW5zbGF0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCAkcm9vdFNjb3BlLCAkbW1TaXRlLCAkbW1VUkxEZWxlZ2F0ZSwgJGlvbmljSGlzdG9yeSxcbiAgICAgICAgICAgICAgICAkbW1FdmVudHMsICRtbUxvZ2luSGVscGVyLCBtbUNvcmVFdmVudFNlc3Npb25FeHBpcmVkLCAkbW1BcHApIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbUxvZ2luJyk7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHNlc3Npb25FeHBpcmVkIGV2ZW50IHRvIHJlY29ubmVjdCB0aGUgdXNlci5cbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRTZXNzaW9uRXhwaXJlZCwgc2Vzc2lvbkV4cGlyZWQpO1xuXG4gICAgLy8gUmVnaXN0ZXIgb2JzZXJ2ZXIgdG8gY2hlY2sgaWYgdGhlIGFwcCB3YXMgbGF1bmNoZWQgdmlhIFVSTCBzY2hlbWUuXG4gICAgJG1tVVJMRGVsZWdhdGUucmVnaXN0ZXIoJ21tTG9naW5TU08nLCBhcHBMYXVuY2hlZEJ5VVJMKTtcblxuICAgIC8vIFJlZGlyZWN0IGRlcGVuZGluZyBvbiB1c2VyIHNlc3Npb24uXG4gICAgJHJvb3RTY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN0YXJ0JywgZnVuY3Rpb24oZXZlbnQsIHRvU3RhdGUsIHRvUGFyYW1zLCBmcm9tU3RhdGUsIGZyb21QYXJhbXMpIHtcblxuICAgICAgICAvLyBQcmV2ZW50IHN0YXRlIGNoYW5nZXMgd2hpbGUgdGhlIGFwcCBpcyBub3QgcmVhZHkuXG4gICAgICAgIGlmICghJG1tQXBwLmlzUmVhZHkoKSAmJiB0b1N0YXRlLm5hbWUgIT09ICdtbV9sb2dpbi5pbml0Jykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oJ21tX2xvZ2luLmluaXQnKTtcbiAgICAgICAgICAgICRsb2cud2FybignRm9yYmlkZGluZyBzdGF0ZSBjaGFuZ2UgdG8gXFwnJyArIHRvU3RhdGUubmFtZSArICdcXCcuIEFwcCBpcyBub3QgcmVhZHkgeWV0LicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvU3RhdGUubmFtZS5zdWJzdHIoMCwgOCkgPT09ICdyZWRpcmVjdCcgfHzCoHRvU3RhdGUubmFtZS5zdWJzdHIoMCwgMTUpID09PSAnbW1fY29udGVudGxpbmtzJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKCh0b1N0YXRlLm5hbWUuc3Vic3RyKDAsIDgpICE9PSAnbW1fbG9naW4nIHx8IHRvU3RhdGUubmFtZSA9PT0gJ21tX2xvZ2luLnJlY29ubmVjdCcpICYmICEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIG5vdCBsb2dnZWQgaW4uXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnUmVkaXJlY3QgdG8gbG9naW4gcGFnZSwgcmVxdWVzdCB3YXM6ICcgKyB0b1N0YXRlLm5hbWUpO1xuICAgICAgICAgICAgLy8gRGlzYWJsZSBhbmltYXRpb24gYW5kIGJhY2sgYnV0dG9uIGZvciB0aGUgbmV4dCB0cmFuc2l0aW9uLlxuICAgICAgICAgICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGRpc2FibGVBbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVCYWNrOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oJ21tX2xvZ2luLmluaXQnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b1N0YXRlLm5hbWUuc3Vic3RyKDAsIDgpID09PSAnbW1fbG9naW4nICYmIHRvU3RhdGUubmFtZSAhPT0gJ21tX2xvZ2luLnJlY29ubmVjdCcgJiYgJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBsb2dnZWQgaW4gYW5kIHJlcXVlc3RlZCB0aGUgbG9naW4gcGFnZS5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdSZWRpcmVjdCB0byBjb3Vyc2UgcGFnZSwgcmVxdWVzdCB3YXM6ICcgKyB0b1N0YXRlLm5hbWUpO1xuICAgICAgICAgICAgLy8gRGlzYWJsZSBhbmltYXRpb24gYW5kIGJhY2sgYnV0dG9uIGZvciB0aGUgbmV4dCB0cmFuc2l0aW9uLlxuICAgICAgICAgICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGRpc2FibGVBbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVCYWNrOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oJ3NpdGUubW1fY291cnNlcycpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIEZ1bmN0aW9uIHRvIGhhbmRsZSBzZXNzaW9uIGV4cGlyZWQgZXZlbnRzLlxuICAgIGZ1bmN0aW9uIHNlc3Npb25FeHBpcmVkKHNpdGVpZCkge1xuXG4gICAgICAgIHZhciBzaXRldXJsID0gJG1tU2l0ZS5nZXRVUkwoKTtcblxuICAgICAgICBpZiAodHlwZW9mKHNpdGV1cmwpICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICBpZiAoc2l0ZWlkICYmIHNpdGVpZCAhPT0gJG1tU2l0ZS5nZXRJZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTaXRlIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudCBpcyBub3QgY3VycmVudCBzaXRlLlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBhdXRoZW50aWNhdGlvbiBtZXRob2QuXG4gICAgICAgICAgICAkbW1TaXRlc01hbmFnZXIuY2hlY2tTaXRlKHNpdGV1cmwpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lndhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChyZXN1bHQud2FybmluZywgdHJ1ZSwgNDAwMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCRtbUxvZ2luSGVscGVyLmlzU1NPTG9naW5OZWVkZWQocmVzdWx0LmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNTTy4gVXNlciBuZWVkcyB0byBhdXRoZW50aWNhdGUgaW4gYSBicm93c2VyLlxuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dDb25maXJtKCR0cmFuc2xhdGUoJ21tLmxvZ2luLnJlY29ubmVjdHNzb2Rlc2NyaXB0aW9uJykpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1Mb2dpbkhlbHBlci5vcGVuQnJvd3NlckZvclNTT0xvZ2luKHJlc3VsdC5zaXRldXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSAkbW1TaXRlLmdldEluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihpbmZvKSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mKGluZm8udXNlcm5hbWUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe2Rpc2FibGVCYWNrOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ21tX2xvZ2luLnJlY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3NpdGV1cmw6IHJlc3VsdC5zaXRldXJsLCB1c2VybmFtZTogaW5mby51c2VybmFtZSwgaW5mb3NpdGV1cmw6IGluZm8uc2l0ZXVybH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGdW5jdGlvbiB0byBoYW5kbGUgVVJMIHJlY2VpdmVkIGJ5IEN1c3RvbSBVUkwgU2NoZW1lLiBJZiBpdCdzIGEgU1NPIGxvZ2luLCBwZXJmb3JtIGF1dGhlbnRpY2F0aW9uLlxuICAgIGZ1bmN0aW9uIGFwcExhdW5jaGVkQnlVUkwodXJsKSB7XG4gICAgICAgIHZhciBzc29TY2hlbWUgPSAnbW9vZGxlbW9iaWxlOi8vdG9rZW49JztcbiAgICAgICAgaWYgKHVybC5pbmRleE9mKHNzb1NjaGVtZSkgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcCBvcGVuZWQgdXNpbmcgY3VzdG9tIFVSTCBzY2hlbWUuIFByb2JhYmx5IGFuIFNTTyBhdXRoZW50aWNhdGlvbi5cbiAgICAgICAgJGxvZy5kZWJ1ZygnQXBwIGxhdW5jaGVkIGJ5IFVSTCcpO1xuXG4gICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW0ubG9naW4uYXV0aGVudGljYXRpbmcnLCB0cnVlKTtcblxuICAgICAgICAvLyBEZWxldGUgdGhlIHNzbyBzY2hlbWUgZnJvbSB0aGUgVVJMLlxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShzc29TY2hlbWUsICcnKTtcbiAgICAgICAgLy8gRGVjb2RlIGZyb20gYmFzZTY0LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXJsID0gYXRvYih1cmwpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgLy8gRXJyb3IgZGVjb2RpbmcgdGhlIHBhcmFtZXRlci5cbiAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIGRlY29kaW5nIHBhcmFtZXRlciByZWNlaXZlZCBmb3IgbG9naW4gU1NPJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAkbW1Mb2dpbkhlbHBlci52YWxpZGF0ZUJyb3dzZXJTU09Mb2dpbih1cmwpLnRoZW4oZnVuY3Rpb24oc2l0ZWRhdGEpIHtcblxuICAgICAgICAgICAgJG1tTG9naW5IZWxwZXIuaGFuZGxlU1NPTG9naW5BdXRoZW50aWNhdGlvbihzaXRlZGF0YS5zaXRldXJsLCBzaXRlZGF0YS50b2tlbikudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW1fY291cnNlcycpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGVycm9yTWVzc2FnZSkgPT09ICdzdHJpbmcnICYmIGVycm9yTWVzc2FnZSAhPSAnJykge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuc2V0dGluZ3MnLCBbXSlcblxuLmNvbnN0YW50KCdtbUNvcmVTZXR0aW5nc0Rvd25sb2FkU2VjdGlvbicsICdtbUNvcmVTZXR0aW5nc0Rvd25sb2FkU2VjdGlvbicpXG4uY29uc3RhbnQoJ21tQ29yZVNldHRpbmdzUmVwb3J0SW5CYWNrZ3JvdW5kJywgJ21tQ29yZVJlcG9ydEluQmFja2dyb3VuZCcpXG4uY29uc3RhbnQoJ21tQ29yZVNldHRpbmdzU3luY09ubHlPbldpZmknLCAnbW1Db3JlU3luY09ubHlPbldpZmknKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1tX3NldHRpbmdzJywge1xuICAgICAgICB1cmw6ICcvbW1fc2V0dGluZ3MnLFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvc2V0dGluZ3MvdGVtcGxhdGVzL2xpc3QuaHRtbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ3NpdGUubW1fc2V0dGluZ3MtYWJvdXQnLCB7XG4gICAgICAgIHVybDogJy9tbV9zZXR0aW5ncy1hYm91dCcsXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9zZXR0aW5ncy90ZW1wbGF0ZXMvYWJvdXQuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tU2V0dGluZ3NBYm91dEN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1tX3NldHRpbmdzLWdlbmVyYWwnLCB7XG4gICAgICAgIHVybDogJy9tbV9zZXR0aW5ncy1nZW5lcmFsJyxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL3NldHRpbmdzL3RlbXBsYXRlcy9nZW5lcmFsLmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbVNldHRpbmdzR2VuZXJhbEN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLnN0YXRlKCdzaXRlLm1tX3NldHRpbmdzLXNwYWNldXNhZ2UnLCB7XG4gICAgICAgIHVybDogJy9tbV9zZXR0aW5ncy1zcGFjZXVzYWdlJyxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL3NldHRpbmdzL3RlbXBsYXRlcy9zcGFjZS11c2FnZS5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1TZXR0aW5nc1NwYWNlVXNhZ2VDdHJsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tbV9zZXR0aW5ncy1zeW5jaHJvbml6YXRpb24nLCB7XG4gICAgICAgIHVybDogJy9tbV9zZXR0aW5ncy1zeW5jaHJvbml6YXRpb24nLFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2NvbXBvbmVudHMvc2V0dGluZ3MvdGVtcGxhdGVzL3N5bmNocm9uaXphdGlvbi5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1TZXR0aW5nc1N5bmNocm9uaXphdGlvbkN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuc2lkZW1lbnUnLCBbXSlcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZScsIHtcbiAgICAgICAgdXJsOiAnL3NpdGUnLFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy9zaWRlbWVudS90ZW1wbGF0ZXMvbWVudS5odG1sJyxcbiAgICAgICAgY29udHJvbGxlcjogJ21tU2lkZU1lbnVDdHJsJyxcbiAgICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgb25FbnRlcjogZnVuY3Rpb24oJGlvbmljSGlzdG9yeSwgJHN0YXRlLCAkbW1TaXRlLCAkdGltZW91dCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsb2dpbiBwYWdlIGZyb20gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAgICAgICAgICAkaW9uaWNIaXN0b3J5LmNsZWFySGlzdG9yeSgpO1xuXG4gICAgICAgICAgICAvLyBHbyB0byBsb2dpbiBpZiB1c2VyIGlzIG5vdCBsb2dnZWQgaW4uXG4gICAgICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdtbV9sb2dpbi5pbml0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLnJ1bihmdW5jdGlvbigkbW1FdmVudHMsIG1tQ29yZUV2ZW50TG9naW4sIG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsIG1tQ29yZUV2ZW50TG9nb3V0LCAkbW1TaWRlTWVudURlbGVnYXRlKSB7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9naW4sICRtbVNpZGVNZW51RGVsZWdhdGUudXBkYXRlTmF2SGFuZGxlcnMpO1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCAkbW1TaWRlTWVudURlbGVnYXRlLnVwZGF0ZU5hdkhhbmRsZXJzKTtcbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRMb2dvdXQsICRtbVNpZGVNZW51RGVsZWdhdGUuY2xlYXJTaXRlSGFuZGxlcnMpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUudGV4dHZpZXdlcicsIFtdKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1tX3RleHR2aWV3ZXInLCB7XG4gICAgICAgIHVybDogJy9tbV90ZXh0dmlld2VyJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB0aXRsZTogbnVsbCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL3RleHR2aWV3ZXIvdGVtcGxhdGVzL3RleHR2aWV3ZXIuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tVGV4dFZpZXdlckluZGV4Q3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS51c2VyJywgW10pXG5cbi52YWx1ZSgnbW1Vc2VyUHJvZmlsZVN0YXRlJywgJ3NpdGUubW1fdXNlci1wcm9maWxlJylcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgICAgICAuc3RhdGUoJ3NpdGUubW1fdXNlci1wcm9maWxlJywge1xuICAgICAgICAgICAgdXJsOiAnL21tX3VzZXItcHJvZmlsZScsXG4gICAgICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1Vc2VyUHJvZmlsZUN0cmwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2NvcmUvY29tcG9uZW50cy91c2VyL3RlbXBsYXRlcy9wcm9maWxlLmh0bWwnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkOiAwLFxuICAgICAgICAgICAgICAgIHVzZXJpZDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIC8vIFJlZ2lzdGVyIGNvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tVXNlcicsICckbW1Vc2VySGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG5cbn0pXG5cbi5ydW4oZnVuY3Rpb24oJG1tRXZlbnRzLCBtbUNvcmVFdmVudExvZ2luLCBtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCAkbW1Vc2VyRGVsZWdhdGUsICRtbVNpdGUsIG1tQ29yZUV2ZW50VXNlckRlbGV0ZWQsICRtbVVzZXIpIHtcbiAgICAkbW1FdmVudHMub24obW1Db3JlRXZlbnRMb2dpbiwgJG1tVXNlckRlbGVnYXRlLnVwZGF0ZVByb2ZpbGVIYW5kbGVycyk7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsICRtbVVzZXJEZWxlZ2F0ZS51cGRhdGVQcm9maWxlSGFuZGxlcnMpO1xuXG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50VXNlckRlbGV0ZWQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuc2l0ZWlkICYmIGRhdGEuc2l0ZWlkID09PSAkbW1TaXRlLmdldElkKCkgJiYgZGF0YS5wYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdXNlcmlkIGluIHBhcmFtcy5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBkYXRhLnBhcmFtcyxcbiAgICAgICAgICAgICAgICB1c2VyaWQgPSAwO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy51c2VyaWQpIHtcbiAgICAgICAgICAgICAgICB1c2VyaWQgPSBwYXJhbXMudXNlcmlkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMudXNlcmlkcykge1xuICAgICAgICAgICAgICAgIHVzZXJpZCA9IHBhcmFtcy51c2VyaWRzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuZmllbGQgPT09ICdpZCcgJiYgcGFyYW1zLnZhbHVlcyAmJiBwYXJhbXMudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVzZXJpZCA9IHBhcmFtcy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy51c2VybGlzdCAmJiBwYXJhbXMudXNlcmxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdXNlcmlkID0gcGFyYW1zLnVzZXJsaXN0WzBdLnVzZXJpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXNlcmlkID0gcGFyc2VJbnQodXNlcmlkKTtcbiAgICAgICAgICAgIGlmICh1c2VyaWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgJG1tVXNlci5kZWxldGVTdG9yZWRVc2VyKHVzZXJpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvbnRlbnRsaW5rcycpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBjaG9vc2UgYW4gYWNjb3VudCB0byBoYW5kbGUgY29udGVudCBsaW5rcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuY29udGVudGxpbmtzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1Db250ZW50TGlua3NDaG9vc2VTaXRlQ3RybFxuICovXG4uY29udHJvbGxlcignbW1Db250ZW50TGlua3NDaG9vc2VTaXRlQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1TaXRlc01hbmFnZXIsICRtbVV0aWwsICRpb25pY0hpc3RvcnksICRzdGF0ZSwgJHEsXG4gICAgICAgICAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSwgJG1tQ29udGVudExpbmtzSGVscGVyKSB7XG5cbiAgICAkc2NvcGUudXJsID0gJHN0YXRlUGFyYW1zLnVybCB8fMKgJyc7XG5cbiAgICB2YXIgYWN0aW9uO1xuXG4gICAgZnVuY3Rpb24gbGVhdmVWaWV3KCkge1xuICAgICAgICAkbW1TaXRlc01hbmFnZXIubG9nb3V0KCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlQW5pbWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlQmFjazogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc3RhdGUuZ28oJ21tX2xvZ2luLnNpdGVzJyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghJHNjb3BlLnVybCkge1xuICAgICAgICBsZWF2ZVZpZXcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlLmdldEFjdGlvbnNGb3IoJHNjb3BlLnVybCkudGhlbihmdW5jdGlvbihhY3Rpb25zKSB7XG4gICAgICAgIGFjdGlvbiA9ICRtbUNvbnRlbnRMaW5rc0hlbHBlci5nZXRGaXJzdFZhbGlkQWN0aW9uKGFjdGlvbnMpO1xuICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGVzKGFjdGlvbi5zaXRlcykudGhlbihmdW5jdGlvbihzaXRlcykge1xuICAgICAgICAgICAgJHNjb3BlLnNpdGVzID0gc2l0ZXM7XG4gICAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb250ZW50bGlua3MuZXJyb3Jub3NpdGVzJywgdHJ1ZSk7XG4gICAgICAgIGxlYXZlVmlldygpO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLnNpdGVDbGlja2VkID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIGFjdGlvbi5hY3Rpb24oc2l0ZUlkKTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZWF2ZVZpZXcoKTtcbiAgICB9O1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb250ZW50bGlua3MnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gaGFuZGxlIGxpbmtzIGZvdW5kIGluIGNvbnRlbnRzLiBBbGxvd3MgdG8gY2FwdHVyZSBsaW5rcyBpbiBjb250ZW50IGFuZCByZWRpcmVjdCB0byBjZXJ0YWluIHBhcnRzXG4gKiBvZiB0aGUgYXBwIGluc3RlYWQgb2Ygb3BlbmluZyB0aGVtIGluIGJyb3dzZXIuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvbnRlbnRsaW5rc1xuICogQG5nZG9jIHByb3ZpZGVyXG4gKiBAbmFtZSAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVxuICovXG4ucHJvdmlkZXIoJyRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpbmtIYW5kbGVycyA9IHt9LFxuICAgICAgICBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGxpbmsgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb250ZW50bGlua3NcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlciNyZWdpc3RlckxpbmtIYW5kbGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICAgICAgICAgICAgICAgICAgIEhhbmRsZXIncyBuYW1lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gaGFuZGxlciBNdXN0IGJlIHJlc29sdmVkIHRvIGFuIG9iamVjdCBkZWZpbmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucy4gT3IgdG8gYSBmdW5jdGlvblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmluZyBhbiBvYmplY3QgZGVmaW5pbmcgdGhlc2UgZnVuY3Rpb25zLiBTZWUge0BsaW5rICRtbVV0aWwjcmVzb2x2ZU9iamVjdH0uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gZ2V0QWN0aW9ucyhzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSAoUHJvbWlzZSkgUmV0dXJucyBsaXN0IG9mIGFjdGlvbnMuIEVhY2ggYWN0aW9uIG11c3QgaGF2ZTpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtZXNzYWdlOiBNZXNzYWdlIHJlbGF0ZWQgdG8gdGhlIGFjdGlvbiB0byBkby4gRS5nLiAnVmlldycuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gaWNvbjogSWNvbiByZWxhdGVkIHRvIHRoZSBhY3Rpb24gdG8gZG8uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gc2l0ZXM6IFNpdGVzIElEcyB0aGF0IHN1cHBvcnQgdGhlIGFjdGlvbi4gU3Vic2V0IG9mICdzaXRlSWRzJy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBhY3Rpb24oc2l0ZUlkKTogQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgbGluayBpcyBjbGlja2VkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldICAgICAgICAgICAgICBIYW5kbGVyJ3MgcHJpb3JpdHkuXG4gICAgICovXG4gICAgc2VsZi5yZWdpc3RlckxpbmtIYW5kbGVyID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlciwgcHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaW5rSGFuZGxlcnNbbmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXI6IEFkZG9uICdcIiArIGxpbmtIYW5kbGVyc1tuYW1lXS5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJyBhbHJlYWR5IHJlZ2lzdGVyZWQgYXMgbGluayBoYW5kbGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcjogUmVnaXN0ZXJlZCBoYW5kbGVyICdcIiArIG5hbWUgKyBcIicgYXMgbGluayBoYW5kbGVyLlwiKTtcbiAgICAgICAgbGlua0hhbmRsZXJzW25hbWVdID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICBpbnN0YW5jZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJpb3JpdHk6IHR5cGVvZiBwcmlvcml0eSA9PT0gJ3VuZGVmaW5lZCcgPyAxMDAgOiBwcmlvcml0eVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2VsZi4kZ2V0ID0gZnVuY3Rpb24oJG1tVXRpbCwgJGxvZywgJHEsICRtbVNpdGVzTWFuYWdlcikge1xuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Db250ZW50TGlua3NEZWxlZ2F0ZScpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgcG9zc2libGUgYWN0aW9ucyB0byBkbyBmb3IgYSBVUkwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb250ZW50bGlua3NcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNnZXRMaW5rSGFuZGxlcnNGb3JcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIGhhbmRsZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC4gT3B0aW9uYWwgYnV0IHJlY29tbWVuZGVkIHNpbmNlIHNvbWUgaGFuZGxlcnMgbWlnaHQgcmVxdWlyZVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBrbm93IHRoZSBjb3Vyc2VpZCBpZiBNb29kbGUgdmVyc2lvbiBpcyBwcmV2aW91cyB0byAzLjAuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgYWN0aW9ucy4gU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9uc0ZvciA9IGZ1bmN0aW9uKHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpc3Qgb2Ygc2l0ZXMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlSWRzRnJvbVVybCh1cmwsIHRydWUpLnRoZW4oZnVuY3Rpb24oc2l0ZUlkcykge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rQWN0aW9ucyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGxpbmtIYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIuaW5zdGFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmluc3RhbmNlID0gJG1tVXRpbC5yZXNvbHZlT2JqZWN0KGhhbmRsZXIuaGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkcS53aGVuKGhhbmRsZXIuaW5zdGFuY2UuZ2V0QWN0aW9ucyhzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSkudGhlbihmdW5jdGlvbihhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbnMgJiYgYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua0FjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogaGFuZGxlci5wcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IGFjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tVXRpbC5hbGxQcm9taXNlcyhwcm9taXNlcykuY2F0Y2goZnVuY3Rpb24oKSB7fSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU29ydCBsaW5rIGFjdGlvbnMgYnkgcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3J0QWN0aW9uc0J5UHJpb3JpdHkobGlua0FjdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvcnQgYWN0aW9ucyBieSBwcmlvcml0eS4gRWFjaCBvYmplY3QgaW4gdGhlIGFjdGlvbnMgcGFyYW0gbXVzdCBoYXZlIGEgcHJpb3JpdHkgYW5kIGEgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiBUaGUgcmV0dXJuZWQgYXJyYXkgb25seSBjb250YWlucyB0aGUgYWN0aW9ucyBvcmRlcmVkIGJ5IHByaW9yaXR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gYWN0aW9ucyBBY3Rpb25zIHRvIHNvcnQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgIFNvcnRlZCBhY3Rpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc29ydEFjdGlvbnNCeVByaW9yaXR5KGFjdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzb3J0ZWQgPSBbXTtcblxuICAgICAgICAgICAgLy8gU29ydCBieSBwcmlvcml0eS5cbiAgICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5ID4gYi5wcmlvcml0eTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGaWxsIHJlc3VsdCBhcnJheS5cbiAgICAgICAgICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgIHNvcnRlZCA9IHNvcnRlZC5jb25jYXQoZW50cnkuYWN0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb250ZW50bGlua3MnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gcHJvdmlkZSBzb21lIGhlbHBlciBmdW5jdGlvbmFsaXRpZXMgZm9yIHRoZSBjb250ZW50bGlua3MgY29tcG9uZW50LlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb250ZW50bGlua3NcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Db250ZW50TGlua3NIZWxwZXJcbiAqL1xuLmZhY3RvcnkoJyRtbUNvbnRlbnRMaW5rc0hlbHBlcicsIGZ1bmN0aW9uKCRsb2csICRpb25pY0hpc3RvcnksICRzdGF0ZSwgJG1tU2l0ZSwgJG1tQ29udGVudExpbmtzRGVsZWdhdGUsICRtbVV0aWwsICR0cmFuc2xhdGUsXG4gICAgICAgICAgICAkbW1Db3Vyc2VIZWxwZXIpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Db250ZW50TGlua3NIZWxwZXInKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIHNpdGVzIGJhc2VkIG9uIGEgaXNFbmFibGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvbnRlbnRsaW5rc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db250ZW50TGlua3NIZWxwZXIjZmlsdGVyU3VwcG9ydGVkU2l0ZXNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gc2l0ZUlkcyAgICAgU2l0ZSBJRHMgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBpc0VuYWJsZWRGbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHNpdGUuIE11c3QgcmV0dXJuIGEgcHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC4gSXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXMgYSBzaXRlSWQgcGFyYW0gYW5kIGFsbCB0aGUgcGFyYW1zIHNlbnQgdG8gdGhpcyBmdW5jdGlvbiBhZnRlciAnY2hlY2tBbGwnLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGNoZWNrQWxsICAgICBUcnVlIGlmIGl0IHNob3VsZCBjaGVjayBhbGwgdGhlIHNpdGVzLCBmYWxzZSBpZiBpdCBzaG91bGQgY2hlY2sgb25seSAxIGFuZCB0cmVhdCB0aGVtIGFsbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRpbmcgb24gdGhpcyByZXN1bHQuXG4gICAgICogQHBhcmFtICB7TWl4ZWR9ICAgICAgICAgICAgICAgIEFsbCB0aGUgcGFyYW1zIHNlbnQgYWZ0ZXIgY2hlY2tBbGwgd2lsbCBiZSBwYXNzZWQgdG8gaXNFbmFibGVkRm4uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgc2l0ZXMuXG4gICAgICovXG4gICAgc2VsZi5maWx0ZXJTdXBwb3J0ZWRTaXRlcyA9IGZ1bmN0aW9uKHNpdGVJZHMsIGlzRW5hYmxlZEZuLCBjaGVja0FsbCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgIHN1cHBvcnRlZCA9IFtdLFxuICAgICAgICAgICAgZXh0cmFQYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpOyAvLyBQYXJhbXMgcmVjZWl2ZWQgYWZ0ZXIgJ2NoZWNrQWxsJy5cblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goc2l0ZUlkcywgZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tBbGwgfHwgIXByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goaXNFbmFibGVkRm4uYXBwbHkoaXNFbmFibGVkRm4sIFtzaXRlSWRdLmNvbmNhdChleHRyYVBhcmFtcykpLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkLnB1c2goc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICRtbVV0aWwuYWxsUHJvbWlzZXMocHJvbWlzZXMpLmNhdGNoKGZ1bmN0aW9uKCkge30pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrQWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpdGVJZHM7IC8vIENoZWNraW5nIDEgd2FzIGVub3VnaCBhbmQgaXQgc3VjY2VlZGVkLCBhbGwgc2l0ZXMgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTsgLy8gQ2hlY2tpbmcgMSB3YXMgZW5vdWdoIGFuZCBpdCBmYWlsZWQsIG5vIHNpdGVzIHN1cHBvcnRlZC5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpcnN0IHZhbGlkIGFjdGlvbiBpbiBhIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb250ZW50bGlua3NcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ29udGVudExpbmtzSGVscGVyI2dldEZpcnN0VmFsaWRBY3Rpb25cbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gYWN0aW9ucyBMaXN0IG9mIGFjdGlvbnMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgRmlyc3QgdmFsaWQgYWN0aW9uLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyB2YWxpZCBhY3Rpb24gZm91bmQuXG4gICAgICovXG4gICAgc2VsZi5nZXRGaXJzdFZhbGlkQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9ucykge1xuICAgICAgICBpZiAoYWN0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24uc2l0ZXMgJiYgYWN0aW9uLnNpdGVzLmxlbmd0aCAmJiBhbmd1bGFyLmlzRnVuY3Rpb24oYWN0aW9uLmFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR29lcyB0byBhIGNlcnRhaW4gc3RhdGUgaW4gYSBjZXJ0YWluIHNpdGUuIElmIHRoZSBzaXRlIGlzIGN1cnJlbnQgc2l0ZSBpdCB3aWxsIHBlcmZvcm0gYSByZWd1bGFyIG5hdmlnYXRpb24sXG4gICAgICogb3RoZXJ3aXNlIGl0IHVzZXMgdGhlICdyZWRpcmVjdCcgc3RhdGUgdG8gY2hhbmdlIHRoZSBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvbnRlbnRsaW5rc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db250ZW50TGlua3NIZWxwZXIjZ29JblNpdGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0YXRlTmFtZSAgIE5hbWUgb2YgdGhlIHN0YXRlIHRvIGdvLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc3RhdGVQYXJhbXMgUGFyYW1zIHRvIHNlbmQgdG8gdGhlIHN0YXRlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgc3RhdGUgaXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdvSW5TaXRlID0gZnVuY3Rpb24oc3RhdGVOYW1lLCBzdGF0ZVBhcmFtcywgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIGlmIChzaXRlSWQgPT0gJG1tU2l0ZS5nZXRJZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJHN0YXRlLmdvKHN0YXRlTmFtZSwgc3RhdGVQYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS5nbygncmVkaXJlY3QnLCB7XG4gICAgICAgICAgICAgICAgc2l0ZWlkOiBzaXRlSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlTmFtZSxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHN0YXRlUGFyYW1zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHbyB0byB0aGUgdmlldyB0byBjaG9vc2UgYSBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvbnRlbnRsaW5rc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db250ZW50TGlua3NIZWxwZXIjZ29Ub0Nob29zZVNpdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byB0cmVhdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgc3RhdGUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBzZWxmLmdvVG9DaG9vc2VTaXRlID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtcbiAgICAgICAgICAgIGRpc2FibGVCYWNrOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJHN0YXRlLmdvKCdtbV9jb250ZW50bGlua3MuY2hvb3Nlc2l0ZScsIHt1cmw6IHVybH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYSBsaW5rLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvbnRlbnRsaW5rc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db250ZW50TGlua3NIZWxwZXIjaGFuZGxlTGlua1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdXJsIFVSTCB0byBoYW5kbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgYm9vbGVhbjogdHJ1ZSBpZiBVUkwgd2FzIHRyZWF0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmhhbmRsZUxpbmsgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxpbmsgc2hvdWxkIGJlIHRyZWF0ZWQgYnkgc29tZSBjb21wb25lbnQvYWRkb24uXG4gICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZS5nZXRBY3Rpb25zRm9yKHVybCkudGhlbihmdW5jdGlvbihhY3Rpb25zKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gc2VsZi5nZXRGaXJzdFZhbGlkQWN0aW9uKGFjdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24uc2l0ZXMubGVuZ3RoID09IDEgJiYgYWN0aW9uLnNpdGVzWzBdID09ICRtbVNpdGUuZ2V0SWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50IHNpdGUuXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5hY3Rpb24oYWN0aW9uLnNpdGVzWzBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgY3VycmVudCBzaXRlIG9yIG1vcmUgdGhhbiBvbmUgc2l0ZS4gQXNrIGZvciBjb25maXJtYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSgnbW0uY29udGVudGxpbmtzLmNvbmZpcm11cmxvdGhlcnNpdGUnKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24uc2l0ZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24uYWN0aW9uKGFjdGlvbi5zaXRlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ29Ub0Nob29zZVNpdGUodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyZWF0cyBhIFVSTCB0aGF0IGJlbG9uZ3MgdG8gYSBtb2R1bGUncyBpbmRleCBwYWdlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvbnRlbnRsaW5rc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db250ZW50TGlua3NIZWxwZXIjdHJlYXRNb2R1bGVJbmRleFVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpc0VuYWJsZWQgRnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIG1vZHVsZSBpcyBlbmFibGVkLiBAc2VlICRtbUNvbnRlbnRMaW5rc0hlbHBlciNmaWx0ZXJTdXBwb3J0ZWRTaXRlcyAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAqL1xuICAgIHNlbGYudHJlYXRNb2R1bGVJbmRleFVybCA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgaXNFbmFibGVkLCBjb3Vyc2VJZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0gJG1tVXRpbC5leHRyYWN0VXJsUGFyYW1zKHVybCk7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zLmlkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBQYXNzIGZhbHNlIGJlY2F1c2UgYWxsIHNpdGVzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNpdGV1cmwuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5maWx0ZXJTdXBwb3J0ZWRTaXRlcyhzaXRlSWRzLCBpc0VuYWJsZWQsIGZhbHNlLCBjb3Vyc2VJZCkudGhlbihmdW5jdGlvbihpZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhY3Rpb25zLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtbS5jb3JlLnZpZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1leWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZXM6IGlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tQ291cnNlSGVscGVyLm5hdmlnYXRlVG9Nb2R1bGUocGFyc2VJbnQocGFyYW1zLmlkLCAxMCksIHNpdGVJZCwgY291cnNlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlJylcblxuLyoqXG4gKiBNb2QgY29udGVudCBjb250cm9sbGVyLlxuICpcbiAqIEB0b2RvIE1ETC01MDExNMKgVGhlIGRlc2NyaXB0aW9uIG1pZ2h0IGJlIG1pc3NpbmcgYmVjYXVzZSB0aGlzIGRhdGEgaXMgYmFzZWQgb24gdGhlIGNvdXJzZVxuICogICAgICAgY29udGVudHMgd2hpY2ggZG9lcyBub3QgYWx3YXlzIGluY2x1ZGUgaXQuXG4gKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1Db3Vyc2VNb2RDb250ZW50Q3RybFxuICovXG4uY29udHJvbGxlcignbW1Db3Vyc2VNb2RDb250ZW50Q3RybCcsIGZ1bmN0aW9uKCRsb2csICRzdGF0ZVBhcmFtcywgJHNjb3BlKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tQ291cnNlTW9kQ29udGVudEN0cmwnKTtcbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fTtcbiAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBtb2R1bGUuZGVzY3JpcHRpb247XG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLnVybCA9IG1vZHVsZS51cmw7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2UnKVxuXG4vKipcbiAqIFNlY3Rpb24gdmlldyBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbUNvdXJzZVNlY3Rpb25DdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbUNvdXJzZVNlY3Rpb25DdHJsJywgZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGUsICRtbUNvdXJzZSwgJG1tVXRpbCwgJHNjb3BlLCAkc3RhdGVQYXJhbXMsICR0cmFuc2xhdGUsICRtbVNpdGUsXG4gICAgICAgICAgICAkbW1FdmVudHMsICRpb25pY1Njcm9sbERlbGVnYXRlLCAkbW1Db3Vyc2VzLCAkcSwgbW1Db3JlRXZlbnRDb21wbGV0aW9uTW9kdWxlVmlld2VkLCAkY29udHJvbGxlcikge1xuXG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgYXJlIGNvdXJzZSAxIChmcm9udCBwYWdlKSBhbmQgYWxsIHNlY3Rpb25zLlxuICAgIHZhciBjb3Vyc2VJZCA9ICRzdGF0ZVBhcmFtcy5jaWQgfHwgMSxcbiAgICAgICAgc2VjdGlvbklkID0gJHN0YXRlUGFyYW1zLnNlY3Rpb25pZCB8fCAtMSxcbiAgICAgICAgbW9kdWxlSWQgPSAkc3RhdGVQYXJhbXMubWlkO1xuXG4gICAgJHNjb3BlLnNpdGVob21lID0gKGNvdXJzZUlkID09PSAxKTsgLy8gQXJlIHdlIHZpc2l0aW5nIHRoZSBzaXRlIGhvbWU/XG4gICAgJHNjb3BlLnNlY3Rpb25zID0gW107IC8vIFJlc2V0IHNjb3BlLnNlY3Rpb25zLCBvdGhlcndpc2UgYW4gZXJyb3IgaXMgc2hvd24gaW4gY29uc29sZSB3aXRoIHRhYmxldCB2aWV3LlxuXG4gICAgaWYgKHNlY3Rpb25JZCA8IDApIHtcbiAgICAgICAgLy8gU3BlY2lhbCBzY2VuYXJpbywgd2Ugd2FudCBhbGwgc2VjdGlvbnMuXG4gICAgICAgIGlmICgkc2NvcGUuc2l0ZWhvbWUpIHtcbiAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICR0cmFuc2xhdGUuaW5zdGFudCgnbW1hLmZyb250cGFnZS5zaXRlaG9tZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3Vyc2UuYWxsc2VjdGlvbnMnKTtcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUuc3VtbWFyeSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZmV0Y2ggc2VjdGlvbihzKS5cbiAgICBmdW5jdGlvbiBsb2FkQ29udGVudChzZWN0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUNvdXJzZXMuZ2V0VXNlckNvdXJzZShjb3Vyc2VJZCwgdHJ1ZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBVc2VyIG5vdCBlbnJvbGxlZCBpbiB0aGUgY291cnNlIG9yIGFuIGVycm9yIG9jY3VycmVkLCBpZ25vcmUgdGhlIGVycm9yLlxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGNvdXJzZSkge1xuICAgICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgICBpZiAoY291cnNlICYmIGNvdXJzZS5lbmFibGVjb21wbGV0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKFtdKTsgLy8gQ29tcGxldGlvbiBub3QgZW5hYmxlZCwgcmV0dXJuIGVtcHR5IGFycmF5LlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJG1tQ291cnNlLmdldEFjdGl2aXRpZXNDb21wbGV0aW9uU3RhdHVzKGNvdXJzZUlkKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBJZiBmYWlsLCByZXR1cm4gZW1wdHkgYXJyYXkgKGFzIGlmIHRoZXJlIHdhcyBubyBjb21wbGV0aW9uKS5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihzdGF0dXNlcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9ubnVtYmVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlY3Rpb25JZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbm51bWJlciA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1Db3Vyc2UuZ2V0U2VjdGlvbnMoY291cnNlSWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25udW1iZXIgPSBzZWN0aW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1Db3Vyc2UuZ2V0U2VjdGlvbihjb3Vyc2VJZCwgc2VjdGlvbklkKS50aGVuKGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IHNlY3Rpb24ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zdW1tYXJ5ID0gc2VjdGlvbi5zdW1tYXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzZWN0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihzZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhlIHNpdGUgaG9tZSwgd2UgbmVlZCB0byByZXZlcnNlIHRoZSBvcmRlciB0byBkaXNwbGF5IGZpcnN0IHRoZSBzaXRlIGhvbWUgc2VjdGlvbiB0b3BpYy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5zaXRlaG9tZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0NvbnRlbnQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2VjdGlvbnMsIGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLnN1bW1hcnkgIT0gJycgfHwgc2VjdGlvbi5tb2R1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2VjdGlvbi5tb2R1bGVzLCBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUuX2NvbnRyb2xsZXIgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tQ291cnNlRGVsZWdhdGUuZ2V0Q29udGVudEhhbmRsZXJDb250cm9sbGVyRm9yKG1vZHVsZS5tb2RuYW1lLCBtb2R1bGUsIGNvdXJzZUlkLCBzZWN0aW9uLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhY3Rpdml0eSBoYXMgY29tcGxldGlvbnMgYW5kIGlmIGl0J3MgbWFya2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSBzdGF0dXNlc1ttb2R1bGUuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuaWQgPT0gbW9kdWxlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbW9kdWxlIHdlJ3JlIGxvb2tpbmcgZm9yLiBPcGVuIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSAkc2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY29udHJvbGxlcihtb2R1bGUuX2NvbnRyb2xsZXIsIHskc2NvcGU6IHNjb3BlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmFjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaGFzQ29udGVudCA9IGhhc0NvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGxvZyBpbiBNb29kbGUuXG4gICAgICAgICAgICAgICAgICAgICRtbVNpdGUud3JpdGUoJ2NvcmVfY291cnNlX3ZpZXdfY291cnNlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291cnNlaWQ6IGNvdXJzZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbm51bWJlcjogc2VjdGlvbm51bWJlclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY291cnNlLmNvdWxkbm90bG9hZHNlY3Rpb25jb250ZW50JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2FkQ29udGVudChzZWN0aW9uSWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5zZWN0aW9uTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgICRzY29wZS5kb1JlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tQ291cnNlLmludmFsaWRhdGVTZWN0aW9ucyhjb3Vyc2VJZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxvYWRDb250ZW50KHNlY3Rpb25JZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBSZWZyZXNoIGxpc3QgYWZ0ZXIgYSBjb21wbGV0aW9uIGNoYW5nZSBzaW5jZSB0aGVyZSBjb3VsZCBiZSBuZXcgYWN0aXZpdGllcyBvciBzby5cbiAgICBmdW5jdGlvbiByZWZyZXNoQWZ0ZXJDb21wbGV0aW9uQ2hhbmdlKCkge1xuICAgICAgICB2YXIgc2Nyb2xsVmlldyA9ICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnbW1TZWN0aW9uU2Nyb2xsJyk7XG4gICAgICAgIGlmIChzY3JvbGxWaWV3ICYmIHNjcm9sbFZpZXcuZ2V0U2Nyb2xsUG9zaXRpb24oKSkge1xuICAgICAgICAgICAgJHNjb3BlLmxvYWRpbmdQYWRkaW5nVG9wID0gc2Nyb2xsVmlldy5nZXRTY3JvbGxQb3NpdGlvbigpLnRvcDtcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUuc2VjdGlvbkxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAkc2NvcGUuc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbG9hZENvbnRlbnQoc2VjdGlvbklkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLnNlY3Rpb25Mb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgJHNjb3BlLmxvYWRpbmdQYWRkaW5nVG9wID0gMDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcGxldGlvbiBjaGFuZ2VkIGZvciBhdCBsZWFzdCBvbmUgbW9kdWxlLiBJbnZhbGlkYXRlIGRhdGEgYW5kIHJlLWxvYWQgaXQuXG4gICAgJHNjb3BlLmNvbXBsZXRpb25DaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbUNvdXJzZS5pbnZhbGlkYXRlU2VjdGlvbnMoY291cnNlSWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZWZyZXNoQWZ0ZXJDb21wbGV0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHZpZXdlZCBtb2R1bGVzLiBJZiBhbiBhdXRvbWF0aWMgY29tcGxldGlvbiBtb2R1bGUgaXMgdmlld2VkLCByZWZyZXNoIHRoZSB3aG9sZSBsaXN0LlxuICAgIHZhciBvYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudENvbXBsZXRpb25Nb2R1bGVWaWV3ZWQsIGZ1bmN0aW9uKGNpZCkge1xuICAgICAgICBpZiAoY2lkID09PSBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmVmcmVzaEFmdGVyQ29tcGxldGlvbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG9ic2VydmVyICYmIG9ic2VydmVyLm9mZikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZScpXG5cbi8qKlxuICogU2VjdGlvbnMgdmlldyBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbUNvdXJzZVNlY3Rpb25zQ3RybFxuICovXG4uY29udHJvbGxlcignbW1Db3Vyc2VTZWN0aW9uc0N0cmwnLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbVV0aWwsICRzY29wZSwgJHN0YXRlUGFyYW1zLCAkdHJhbnNsYXRlLCAkbW1Db3Vyc2VIZWxwZXIsICRtbUV2ZW50cyxcbiAgICAgICAgICAgICRtbVNpdGUsICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUsICRtbUNvdXJzZXMsICRxLCAkaW9uaWNIaXN0b3J5LCAkaW9uaWNQbGF0Zm9ybSwgbW1Db3JlQ291cnNlQWxsU2VjdGlvbnNJZCxcbiAgICAgICAgICAgIG1tQ29yZUV2ZW50U2VjdGlvblN0YXR1c0NoYW5nZWQsICRtbUNvbmZpZywgbW1Db3JlU2V0dGluZ3NEb3dubG9hZFNlY3Rpb24sICRzdGF0ZSwgJHRpbWVvdXQpIHtcbiAgICB2YXIgY291cnNlSWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIHNlY3Rpb25JZCA9ICRzdGF0ZVBhcmFtcy5zaWQsXG4gICAgICAgIG1vZHVsZUlkID0gJHN0YXRlUGFyYW1zLm1vZHVsZWlkLFxuICAgICAgICBkb3dubG9hZFNlY3Rpb25zRW5hYmxlZDtcblxuICAgICRzY29wZS5jb3Vyc2VJZCA9IGNvdXJzZUlkO1xuICAgICRzY29wZS5zZWN0aW9uVG9Mb2FkID0gMjsgLy8gTG9hZCBcIkdlbmVyYWxcIiBzZWN0aW9uIGJ5IGRlZmF1bHQuXG5cbiAgICBmdW5jdGlvbiBjaGVja0Rvd25sb2FkU2VjdGlvbnNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gJG1tQ29uZmlnLmdldChtbUNvcmVTZXR0aW5nc0Rvd25sb2FkU2VjdGlvbiwgdHJ1ZSkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICBkb3dubG9hZFNlY3Rpb25zRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gU2hvdWxkbid0IGhhcHBlbi5cbiAgICAgICAgICAgIGRvd25sb2FkU2VjdGlvbnNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRTZWN0aW9ucyhyZWZyZXNoKSB7XG4gICAgICAgIC8vIEdldCBmdWxsIGNvdXJzZSBkYXRhLiBJZiBub3QgcmVmcmVzaGluZyB3ZSdsbCB0cnkgdG8gZ2V0IGl0IGZyb20gY2FjaGUgdG8gc3BlZWQgdXAgdGhlIHJlc3BvbnNlLlxuICAgICAgICByZXR1cm4gJG1tQ291cnNlcy5nZXRVc2VyQ291cnNlKGNvdXJzZUlkKS50aGVuKGZ1bmN0aW9uKGNvdXJzZSkge1xuICAgICAgICAgICAgJHNjb3BlLmZ1bGxuYW1lID0gY291cnNlLmZ1bGxuYW1lO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWN0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiAkbW1Db3Vyc2UuZ2V0U2VjdGlvbnMoY291cnNlSWQpLnRoZW4oZnVuY3Rpb24oc2VjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBmYWtlIGZpcnN0IHNlY3Rpb24gKGFsbCBzZWN0aW9ucykuXG4gICAgICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUoJ21tLmNvdXJzZS5hbGxzZWN0aW9ucycpLnRoZW4oZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZGluZyBmYWtlIGZpcnN0IHNlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1tQ29yZUNvdXJzZUFsbFNlY3Rpb25zSWRcbiAgICAgICAgICAgICAgICAgICAgfV0uY29uY2F0KHNlY3Rpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2VjdGlvbnMgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkU2VjdGlvbnNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgc3RhdHVzIG9mIHRoZSBzZWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db3Vyc2VIZWxwZXIuY2FsY3VsYXRlU2VjdGlvbnNTdGF0dXMocmVzdWx0LCBjb3Vyc2VJZCwgdHJ1ZSwgcmVmcmVzaCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycyAoc2hvdWxkbid0IGhhcHBlbikuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGRvd25sb2FkcHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZXN0b3JlZCBhbnkgZG93bmxvYWQgd2UnbGwgcmVjYWxjdWxhdGUgdGhlIHN0YXR1cyBvbmNlIGFsbCBvZiB0aGVtIGhhdmUgZmluaXNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkcHJvbWlzZXMgJiYgZG93bmxvYWRwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5hbGxQcm9taXNlcyhkb3dubG9hZHByb21pc2VzKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY291cnNlLmVycm9yZG93bmxvYWRpbmdzZWN0aW9uJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJGRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIHRoZSBzdGF0dXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tQ291cnNlSGVscGVyLmNhbGN1bGF0ZVNlY3Rpb25zU3RhdHVzKCRzY29wZS5zZWN0aW9ucywgY291cnNlSWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvdXJzZS5jb3VsZG5vdGxvYWRzZWN0aW9ucycsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQcmVmZXRjaCBhIHNlY3Rpb24uIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGluZGljYXRlcyBpZiB0aGUgcHJlZmV0Y2ggd2FzIHN0YXJ0ZWQgbWFudWFsbHkgKHRydWUpXG4gICAgLy8gb3IgaXQgd2FzIGF1dG9tYXRpY2FsbHkgc3RhcnRlZCBiZWNhdXNlIGFsbCBtb2R1bGVzIGFyZSBiZWluZyBkb3dubG9hZGVkIChmYWxzZSkuXG4gICAgZnVuY3Rpb24gcHJlZmV0Y2goc2VjdGlvbiwgbWFudWFsKSB7XG4gICAgICAgICRtbUNvdXJzZUhlbHBlci5wcmVmZXRjaChzZWN0aW9uLCBjb3Vyc2VJZCwgJHNjb3BlLnNlY3Rpb25zKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHNob3cgZXJyb3IgbWVzc2FnZSBpZiBzY29wZSBpcyBkZXN0cm95ZWQgb3IgaXQncyBhbiBhdXRvbWF0aWMgZG93bmxvYWQgYnV0IHdlIGFyZW4ndCBpbiB0aGlzIHN0YXRlLlxuICAgICAgICAgICAgaWYgKCRzY29wZS4kJGRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSAkaW9uaWNIaXN0b3J5LmN1cnJlbnRTdGF0ZU5hbWUoKSxcbiAgICAgICAgICAgICAgICBpc0N1cnJlbnQgPSAoJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSAmJiBjdXJyZW50ID09ICdzaXRlLm1tX2NvdXJzZS5tbV9jb3Vyc2Utc2VjdGlvbicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCEkaW9uaWNQbGF0Zm9ybS5pc1RhYmxldCgpICYmIGN1cnJlbnQgPT0gJ3NpdGUubW1fY291cnNlJyk7XG4gICAgICAgICAgICBpZiAoIW1hbnVhbCAmJiAhaXNDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3Vyc2UuZXJyb3Jkb3dubG9hZGluZ3NlY3Rpb24nLCB0cnVlKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgdGhlIHN0YXR1cy5cbiAgICAgICAgICAgICAgICAkbW1Db3Vyc2VIZWxwZXIuY2FsY3VsYXRlU2VjdGlvbnNTdGF0dXMoJHNjb3BlLnNlY3Rpb25zLCBjb3Vyc2VJZCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhdXRvbG9hZCBhIHNlY3Rpb24gaWYgc2VjdGlvbklkIHBhcmFtIGlzIHNldC5cbiAgICBmdW5jdGlvbiBhdXRvbG9hZFNlY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGlmICgkaW9uaWNQbGF0Zm9ybS5pc1RhYmxldCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2VjdGlvbiB0byBsb2FkLlxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUuc2VjdGlvbnMsIGZ1bmN0aW9uKHNlY3Rpb24sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLmlkID09IHNlY3Rpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlY3Rpb25Ub0xvYWQgPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgbW9kdWxlSWQgdG8gcGFzcyBpdCB0byB0aGUgbmV3IHN0YXRlIHdoZW4gdGhlIHNlY3Rpb24gaXMgYXV0b2xvYWRlZC4gV2UgdW5zZXQgaXQgYWZ0ZXIgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgYXV0b2xvYWRpbmcgdGhlIG1vZHVsZSB3aGVuIHRoZSB1c2VyIG1hbnVhbGx5IGxvYWRzIGEgc2VjdGlvbi5cbiAgICAgICAgICAgICAgICAkc2NvcGUubW9kdWxlSWQgPSBtb2R1bGVJZDtcbiAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm1vZHVsZUlkID0gbnVsbDsgLy8gVW5zZXQgbW9kdWxlSWQgd2hlblxuICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tbV9jb3Vyc2Utc2VjdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbmlkOiBzZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIGNpZDogY291cnNlSWQsXG4gICAgICAgICAgICAgICAgICAgIG1pZDogbW9kdWxlSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICRzY29wZS5kb1JlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIHByb21pc2VzLnB1c2goJG1tQ291cnNlcy5pbnZhbGlkYXRlVXNlckNvdXJzZXMoKSk7XG4gICAgICAgIHByb21pc2VzLnB1c2goJG1tQ291cnNlLmludmFsaWRhdGVTZWN0aW9ucyhjb3Vyc2VJZCkpO1xuXG4gICAgICAgICRxLmFsbChwcm9taXNlcykuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxvYWRTZWN0aW9ucyh0cnVlKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5wcmVmZXRjaCA9IGZ1bmN0aW9uKGUsIHNlY3Rpb24pIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICRtbUNvdXJzZUhlbHBlci5jb25maXJtRG93bmxvYWRTaXplKGNvdXJzZUlkLCBzZWN0aW9uLCAkc2NvcGUuc2VjdGlvbnMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwcmVmZXRjaChzZWN0aW9uLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNoZWNrRG93bmxvYWRTZWN0aW9uc0VuYWJsZWQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkU2VjdGlvbnMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXV0b2xvYWRTZWN0aW9uKCk7XG4gICAgICAgICAgICAkc2NvcGUuc2VjdGlvbnNMb2FkZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiBmb3Igc2VjdGlvbiBzdGF0dXMgY2hhbmdlcy5cbiAgICB2YXIgc3RhdHVzT2JzZXJ2ZXIgPSAkbW1FdmVudHMub24obW1Db3JlRXZlbnRTZWN0aW9uU3RhdHVzQ2hhbmdlZCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoZG93bmxvYWRTZWN0aW9uc0VuYWJsZWQgJiYgJHNjb3BlLnNlY3Rpb25zICYmICRzY29wZS5zZWN0aW9ucy5sZW5ndGggJiYgZGF0YS5zaXRlaWQgPT09ICRtbVNpdGUuZ2V0SWQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAhJHNjb3BlLiQkZGVzdHJveWVkJiYgZGF0YS5zZWN0aW9uaWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBhZmZlY3RlZCBzZWN0aW9uIGlzIGJlaW5nIGRvd25sb2FkZWQuIElmIHNvLCB3ZSBkb24ndCB1cGRhdGUgc2VjdGlvbiBzdGF0dXNcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQnbGwgYWxyZWFkeSBiZSB1cGRhdGVkIHdoZW4gdGhlIGRvd25sb2FkIGZpbmlzaGVzLlxuICAgICAgICAgICAgaWYgKCRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUuaXNCZWluZ0Rvd25sb2FkZWQoJG1tQ291cnNlSGVscGVyLmdldFNlY3Rpb25Eb3dubG9hZElkKHtpZDogZGF0YS5zZWN0aW9uaWR9KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIHRoZSBzdGF0dXMuXG4gICAgICAgICAgICAkbW1Db3Vyc2VIZWxwZXIuY2FsY3VsYXRlU2VjdGlvbnNTdGF0dXMoJHNjb3BlLnNlY3Rpb25zLCBjb3Vyc2VJZCwgZmFsc2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlY3Rpb247XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5zZWN0aW9ucywgZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5pZCA9PT0gZGF0YS5zZWN0aW9uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvd25sb2FkaWQgPSAkbW1Db3Vyc2VIZWxwZXIuZ2V0U2VjdGlvbkRvd25sb2FkSWQoc2VjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLmlzRG93bmxvYWRpbmcgJiYgISRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUuaXNCZWluZ0Rvd25sb2FkZWQoZG93bmxvYWRpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCB0aGUgbW9kdWxlcyBhcmUgbm93IGRvd25sb2FkaW5nLCBzZXQgYSBkb3dubG9hZCBhbGwgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoKHNlY3Rpb24sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGF0dXNPYnNlcnZlciAmJiBzdGF0dXNPYnNlcnZlci5vZmYgJiYgc3RhdHVzT2JzZXJ2ZXIub2ZmKCk7XG4gICAgfSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2UnKVxuXG4vKipcbiAqIENvdXJzZSBNb2QgRGVzY3JpcHRpb24gZGlyZWN0aXZlLlxuICpcbiAqIFRvIHVzZSB0byBkaXNwbGF5IHRoZSBkZXNjcmlwdGlvbiBvZiBhIG1vZHVsZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbUNvdXJzZU1vZERlc2NyaXB0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyBtZWFudCB0byBkaXNwbGF5IGEgbW9kdWxlIGRlc2NyaXB0aW9uIGluIGEgc2ltaWxhciB3YXkgdGhyb3VnaG91dFxuICogYWxsIHRoZSBtb2R1bGVzLiBJdCBoYXMgaXRzIG93biBzY29wZSBhbmQgc28gd2lsbCB1c2UgdGhlIGF0dHJpYnV0ZSAnZGVzY3JpcHRpb24nIHRvXG4gKiBrbm93IHdoYXQgc2NvcGUgdmFyaWFibGUgdG8gbG9vayBmb3IgaW4gdGhlIHBhcmVudCBzY29wZS5cbiAqXG4gKiBJZiB0aGUgZGVzY3JpcHRpb24gaXMgYXN5bmNocm9ub3VzIHlvdSBzaG91bGQgc2V0IHRoZSBhdHRyaWJ1dGUgJ3dhdGNoJyB0byB0cnVlLlxuICogVGhpcyBhdHRyaWJ1dGUgaXMgZGlyZWN0bHkgc2hhcmVkIHdpdGggbW1Gb3JtYXRUZXh0IHdoaWNoIG5lZWRzIGl0LlxuICpcbiAqIFlvdSBjYW4gYWRkIGEgbm90ZSBhdCB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgZGVzY3JpcHRpb24gYnkgdXNpbmcgdGhlICdub3RlJyBhdHRyaWJ1dGUuXG4gKlxuICogTW9kdWxlIGRlc2NyaXB0aW9ucyBhcmUgc2hvcnRlbmVkIGJ5IGRlZmF1bHQsIGFsbG93aW5nIHRoZSB1c2VyIHRvIHNlZSB0aGUgZnVsbCBkZXNjcmlwdGlvbiBieSBjbGlja2luZyBpbiBpdC5cbiAqIElmIHlvdSB3YW50IHRoZSB3aG9sZSBkZXNjcmlwdGlvbiB0byBiZSBzaG93biB5b3UgY2FuIHVzZSB0aGUgJ3Nob3dmdWxsJyBhdHRyaWJ1dGUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiA8bW0tY291cnNlLW1vZC1kZXNjcmlwdGlvbiBkZXNjcmlwdGlvbj1cIm15RGVzY3JpcHRpb25cIj48L21tLWNvdXJzZS1tb2QtZGVzY3JpcHRpb24+XG4gKlxuICogPG1tLWNvdXJzZS1tb2QtZGVzY3JpcHRpb24gZGVzY3JpcHRpb249XCJteUFzeW5jRGVzY1wiIHdhdGNoPVwidHJ1ZVwiPjwvbW0tY291cnNlLW1vZC1kZXNjcmlwdGlvbj5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1Db3Vyc2VNb2REZXNjcmlwdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMud2F0Y2gpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmZpbmQoJ21tLWZvcm1hdC10ZXh0JykuYXR0cignd2F0Y2gnLCBhdHRycy53YXRjaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZSkgeyAvLyBMaW5rIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIHNjb3BlLnNob3dmdWxsID0gISFhdHRycy5zaG93ZnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJz0nLFxuICAgICAgICAgICAgbm90ZTogJz0nXG4gICAgICAgIH0sXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9jb21wb25lbnRzL2NvdXJzZS90ZW1wbGF0ZXMvbW9kX2Rlc2NyaXB0aW9uLmh0bWwnXG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZScpXG5cbi8qKlxuICogRGVmYXVsdCBjb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Db3Vyc2VDb250ZW50SGFuZGxlclxuICovXG4uZmFjdG9yeSgnJG1tQ291cnNlQ29udGVudEhhbmRsZXInLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbVV0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRDb250cm9sbGVyOiBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMobW9kdWxlLm1vZG5hbWUpO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1tX2NvdXJzZS1tb2Rjb250ZW50Jywge21vZHVsZTogbW9kdWxlfSk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZS51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJ1dHRvbnMgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1pb3MtYnJvd3NlcnMtb3V0bGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ21tLmNvcmUub3BlbmluYnJvd3NlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLm9wZW5JbkJyb3dzZXIobW9kdWxlLnVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlJylcblxuLmNvbnN0YW50KCdtbUNvcmVDb3Vyc2VNb2R1bGVzU3RvcmUnLCAnY291cnNlX21vZHVsZXMnKSAvLyBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4gUGxlYXNlIGRvIG5vdCB1c2UuXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tU2l0ZXNGYWN0b3J5UHJvdmlkZXIsIG1tQ29yZUNvdXJzZU1vZHVsZXNTdG9yZSkge1xuICAgIHZhciBzdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1tQ29yZUNvdXJzZU1vZHVsZXNTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCdcbiAgICAgICAgfVxuICAgIF07XG4gICAgJG1tU2l0ZXNGYWN0b3J5UHJvdmlkZXIucmVnaXN0ZXJTdG9yZXMoc3RvcmVzKTtcbn0pXG5cbi8qKlxuICogRmFjdG9yeSBjb250YWluaW5nIGNvdXJzZSByZWxhdGVkIG1ldGhvZHMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUNvdXJzZVxuICovXG4uZmFjdG9yeSgnJG1tQ291cnNlJywgZnVuY3Rpb24oJG1tU2l0ZSwgJHRyYW5zbGF0ZSwgJHEsICRsb2csICRtbUV2ZW50cywgJG1tU2l0ZXNNYW5hZ2VyLCBtbUNvcmVFdmVudENvbXBsZXRpb25Nb2R1bGVWaWV3ZWQpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1Db3Vyc2UnKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIG1vZHMgPSBbXCJhc3NpZ25cIiwgXCJhc3NpZ25tZW50XCIsIFwiYm9va1wiLCBcImNoYXRcIiwgXCJjaG9pY2VcIiwgXCJkYXRhXCIsIFwiZGF0YWJhc2VcIiwgXCJkYXRlXCIsIFwiZXh0ZXJuYWwtdG9vbFwiLFxuICAgICAgICAgICAgXCJmZWVkYmFja1wiLCBcImZpbGVcIiwgXCJmb2xkZXJcIiwgXCJmb3J1bVwiLCBcImdsb3NzYXJ5XCIsIFwiaW1zXCIsIFwiaW1zY3BcIiwgXCJsYWJlbFwiLCBcImxlc3NvblwiLCBcImx0aVwiLCBcInBhZ2VcIiwgXCJxdWl6XCIsXG4gICAgICAgICAgICBcInJlc291cmNlXCIsIFwic2Nvcm1cIiwgXCJzdXJ2ZXlcIiwgXCJ1cmxcIiwgXCJ3aWtpXCIsIFwid29ya3Nob3BcIlxuICAgICAgICBdLFxuICAgICAgICBtb2RzV2l0aENvbnRlbnQgPSBbJ2Jvb2snLCAnZm9sZGVyJywgJ2ltc2NwJywgJ3BhZ2UnLCAncmVzb3VyY2UnLCAndXJsJ107XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSAnY29udGVudHMnIHByb3BlcnR5IGlmIHRoZSBtb2R1bGUgbmVlZHMgaXQgYW5kIGl0IGRvZXNuJ3QgaGF2ZSBpdCBhbHJlYWR5LiBJbiBzb21lIHdlaXJkIGNhc2VzIHRoZSBzaXRlXG4gICAgICogZG9lc24ndCByZXR1cm4gdGhpcyBwcm9wZXJ0eSBhbmQgaXQncyBuZWVkZWQuIFNlZSBNT0JJTEUtMTM4MS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgTW9kdWxlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgTW9kdWxlIHdpdGggY29udGVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkQ29udGVudHNJZk5lZWRlZChtb2R1bGUpIHtcbiAgICAgICAgaWYgKG1vZHNXaXRoQ29udGVudC5pbmRleE9mKG1vZHVsZS5tb2RuYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICBtb2R1bGUuY29udGVudHMgPSBtb2R1bGUuY29udGVudHMgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgc2l0ZSBpcyBwcmVwYXJlZCB0byByZXR1cm4gYSBtb2R1bGUgd2l0aG91dCBoYXZpbmcgaXRzIGNvdXJzZSBJRC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlI2NhbkdldE1vZHVsZVdpdGhvdXRDb3Vyc2VJZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGNhbiByZXR1cm4gaXQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS53c0F2YWlsYWJsZSgnY29yZV9jb3Vyc2VfZ2V0X2NvdXJzZV9tb2R1bGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBzaXRlIGlzIHByZXBhcmVkIHRvIHJldHVybiBhIG1vZHVsZSBieSBpbnN0YW5jZSBJRC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlI2NhbkdldE1vZHVsZUJ5SW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBjYW4gcmV0dXJuIGl0LCByZWplY3RlZCBvciByZXNvbHZlZCB3aXRoIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmNhbkdldE1vZHVsZUJ5SW5zdGFuY2UgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLndzQXZhaWxhYmxlKCdjb3JlX2NvdXJzZV9nZXRfY291cnNlX21vZHVsZV9ieV9pbnN0YW5jZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgbW9kdWxlIGNvbXBsZXRpb24gY291bGQgaGF2ZSBjaGFuZ2VkLiBJZiBpdCBjb3VsZCBoYXZlLCB0cmlnZ2VyIGV2ZW50LiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCxcbiAgICAgKiBmb3IgZXhhbXBsZSwgYWZ0ZXIgY2FsbGluZyBhIFwibW9kdWxlX3ZpZXdcIiBXUyBzaW5jZSBpdCBjYW4gY2hhbmdlIHRoZSBtb2R1bGUgY29tcGxldGlvbi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlI2NoZWNrTW9kdWxlQ29tcGxldGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCAgIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcGxldGlvbiBDb21wbGV0aW9uIHN0YXR1cyBvZiB0aGUgbW9kdWxlLlxuICAgICAqL1xuICAgIHNlbGYuY2hlY2tNb2R1bGVDb21wbGV0aW9uID0gZnVuY3Rpb24oY291cnNlSWQsIGNvbXBsZXRpb24pIHtcbiAgICAgICAgaWYgKGNvbXBsZXRpb24gJiYgY29tcGxldGlvbi50cmFja2luZyA9PT0gMiAmJiBjb21wbGV0aW9uLnN0YXRlID09PSAwKSB7XG4gICAgICAgICAgICBzZWxmLmludmFsaWRhdGVTZWN0aW9ucyhjb3Vyc2VJZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbUNvcmVFdmVudENvbXBsZXRpb25Nb2R1bGVWaWV3ZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjb21wbGV0aW9uIHN0YXR1cyBvZiBhbGwgdGhlIGFjdGl2aXRpZXMgaW4gYSBjb3Vyc2UgZm9yIGEgY2VydGFpbiB1c2VyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjZ2V0QWN0aXZpdGllc0NvbXBsZXRpb25TdGF0dXNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt1c2VyaWRdIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGNvbXBsZXRpb24gc3RhdHVzZXM6IG9iamVjdCB3aGVyZSB0aGUga2V5IGlzIG1vZHVsZSBJRC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEFjdGl2aXRpZXNDb21wbGV0aW9uU3RhdHVzID0gZnVuY3Rpb24oY291cnNlaWQsIHVzZXJpZCkge1xuICAgICAgICB1c2VyaWQgPSB1c2VyaWQgfHwgJG1tU2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAkbG9nLmRlYnVnKCdHZXR0aW5nIGNvbXBsZXRpb24gc3RhdHVzIGZvciB1c2VyICcgKyB1c2VyaWQgKyAnIGluIGNvdXJzZSAnICsgY291cnNlaWQpO1xuXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY291cnNlaWQ6IGNvdXJzZWlkLFxuICAgICAgICAgICAgICAgIHVzZXJpZDogdXNlcmlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0QWN0aXZpdGllc0NvbXBsZXRpb25DYWNoZUtleShjb3Vyc2VpZCwgdXNlcmlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdjb3JlX2NvbXBsZXRpb25fZ2V0X2FjdGl2aXRpZXNfY29tcGxldGlvbl9zdGF0dXMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5zdGF0dXNlcykge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRTdGF0dXNlcyA9IHt9O1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLnN0YXR1c2VzLCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RhdHVzZXNbc3RhdHVzLmNtaWRdID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWRTdGF0dXNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGFjdGl2aXRpZXMgY29tcGxldGlvbiBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcmlkICAgVXNlciBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBY3Rpdml0aWVzQ29tcGxldGlvbkNhY2hlS2V5KGNvdXJzZWlkLCB1c2VyaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbUNvdXJzZTphY3Rpdml0aWVzY29tcGxldGlvbjonICsgY291cnNlaWQgKyAnOicgKyB1c2VyaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIG1vZHVsZSBiYXNpYyBpbmZvIGJ5IG1vZHVsZSBJRC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlI2dldE1vZHVsZUJhc2ljSW5mb1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gbW9kdWxlSWQgTW9kdWxlIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbW9kdWxlJ3MgaW5mby5cbiAgICAgKi9cbiAgICBzZWxmLmdldE1vZHVsZUJhc2ljSW5mbyA9IGZ1bmN0aW9uKG1vZHVsZUlkLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNtaWQ6IG1vZHVsZUlkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0TW9kdWxlQ2FjaGVLZXkobW9kdWxlSWQpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHNpdGUucmVhZCgnY29yZV9jb3Vyc2VfZ2V0X2NvdXJzZV9tb2R1bGUnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuY20gJiYgKCFyZXNwb25zZS53YXJuaW5ncyB8fMKgIXJlc3BvbnNlLndhcm5pbmdzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmNtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBtb2R1bGUgYmFzaWMgaW5mbyBieSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlI2dldE1vZHVsZUJhc2ljSW5mb0J5SW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgICAgICAgIEluc3RhbmNlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGUgICAgTmFtZSBvZiB0aGUgbW9kdWxlLiBFLmcuICdnbG9zc2FyeScuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBtb2R1bGUncyBpbmZvLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0TW9kdWxlQmFzaWNJbmZvQnlJbnN0YW5jZSA9IGZ1bmN0aW9uKGlkLCBtb2R1bGUsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGlkLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldE1vZHVsZUJ5SW5zdGFuY2VDYWNoZUtleShpZCwgbW9kdWxlKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBzaXRlLnJlYWQoJ2NvcmVfY291cnNlX2dldF9jb3Vyc2VfbW9kdWxlX2J5X2luc3RhbmNlJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmNtICYmICghcmVzcG9uc2Uud2FybmluZ3MgfHzCoCFyZXNwb25zZS53YXJuaW5ncy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5jbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBtb2R1bGUgZnJvbSBNb29kbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZSNnZXRNb2R1bGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9kdWxlSWQgICAgVGhlIG1vZHVsZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSAgVGhlIGNvdXJzZSBJRC4gUmVjb21tZW5kZWQgdG8gc3BlZWQgdXAgdGhlIHByb2Nlc3MgYW5kIG1pbmltaXplIGRhdGEgdXNhZ2UuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWN0aW9uSWRdIFRoZSBzZWN0aW9uIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5nZXRNb2R1bGUgPSBmdW5jdGlvbihtb2R1bGVJZCwgY291cnNlSWQsIHNlY3Rpb25JZCkge1xuXG4gICAgICAgIGlmICghbW9kdWxlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgIGlmICghY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIE5vIGNvdXJzZUlkIHBhc3NlZCwgdHJ5IHRvIHJldHJpZXZlIGl0LlxuICAgICAgICAgICAgcHJvbWlzZSA9IHNlbGYuZ2V0TW9kdWxlQmFzaWNJbmZvKG1vZHVsZUlkKS50aGVuKGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUuY291cnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihjb3Vyc2VJZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGNvdXJzZUlkLCB3ZSBjYW4gdXNlIGNvcmVfY291cnNlX2dldF9jb250ZW50cyBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0dldHRpbmcgbW9kdWxlICcgKyBtb2R1bGVJZCArICcgaW4gY291cnNlICcgKyBjb3Vyc2VJZCk7XG5cbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlSWQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY21pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbW9kdWxlSWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRNb2R1bGVDYWNoZUtleShtb2R1bGVJZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzZWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMub3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NlY3Rpb25pZCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzZWN0aW9uSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnY29yZV9jb3Vyc2VfZ2V0X2NvbnRlbnRzJywgcGFyYW1zLCBwcmVTZXRzKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBnZXR0aW5nIHRoZSBtb2R1bGUuIFRyeSB0byBnZXQgYWxsIGNvbnRlbnRzICh3aXRob3V0IGZpbHRlcmluZykuXG4gICAgICAgICAgICAgICAgcGFyYW1zLm9wdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBwcmVTZXRzLmNhY2hlS2V5ID0gZ2V0U2VjdGlvbnNDYWNoZUtleShjb3Vyc2VJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnY29yZV9jb3Vyc2VfZ2V0X2NvbnRlbnRzJywgcGFyYW1zLCBwcmVTZXRzKTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oc2VjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VjdGlvbi5tb2R1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgPSBzZWN0aW9uLm1vZHVsZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlLmlkID09IG1vZHVsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmNvdXJzZSA9IGNvdXJzZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRDb250ZW50c0lmTmVlZGVkKG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBtb2R1bGUgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgICAgIEluc3RhbmNlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGUgTmFtZSBvZiB0aGUgbW9kdWxlLiBFLmcuICdnbG9zc2FyeScuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TW9kdWxlQnlJbnN0YW5jZUNhY2hlS2V5KGlkLCBtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuICdtbUNvdXJzZTptb2R1bGVCeUluc3RhbmNlOicgKyBtb2R1bGUgKyAnOicgKyBpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBtb2R1bGUgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9kdWxlaWQgTW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TW9kdWxlQ2FjaGVLZXkobW9kdWxlaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbUNvdXJzZTptb2R1bGU6JyArIG1vZHVsZWlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNvdXJjZSB0byBhIG1vZHVsZSBpY29uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjZ2V0TW9kdWxlSWNvblNyY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGVOYW1lIFRoZSBtb2R1bGUgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBJTUcgc3JjLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0TW9kdWxlSWNvblNyYyA9IGZ1bmN0aW9uKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgaWYgKG1vZHMuaW5kZXhPZihtb2R1bGVOYW1lKSA8IDApIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWUgPSBcImV4dGVybmFsLXRvb2xcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcImltZy9tb2QvXCIgKyBtb2R1bGVOYW1lICsgXCIuc3ZnXCI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2VjdGlvbiBJRCBhIG1vZHVsZSBiZWxvbmdzIHRvLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjZ2V0TW9kdWxlU2VjdGlvbklkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vZHVsZUlkICAgVGhlIG1vZHVsZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBUaGUgY291cnNlIElELiBSZXF1aXJlZCBpZiBNb29kbGUgc2l0ZSBpcyBwcmlvciB0byAzLjAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuZ2V0TW9kdWxlU2VjdGlvbklkID0gZnVuY3Rpb24obW9kdWxlSWQsIGNvdXJzZUlkLCBzaXRlSWQpIHtcblxuICAgICAgICBpZiAoIW1vZHVsZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgdG8gZ2V0IHRoZSBzZWN0aW9uIHVzaW5nIGdldE1vZHVsZUJhc2ljSW5mby5cbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0TW9kdWxlQmFzaWNJbmZvKG1vZHVsZUlkLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlLnNlY3Rpb247XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFjb3Vyc2VJZCkge1xuICAgICAgICAgICAgICAgIC8vIEl0IGZhaWxlZCBhbmQgd2UgZG9uJ3QgaGF2ZSBjb3Vyc2VJZCwgcmVqZWN0LlxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IGFsbCB0aGUgc2VjdGlvbnMgaW4gdGhlIGNvdXJzZSBhbmQgaXRlcmF0ZSBvdmVyIHRoZW0gdG8gZmluZCBpdC5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFNlY3Rpb25zKGNvdXJzZUlkLCB7fSwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24ubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5pZCA9PSBtb2R1bGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWN0aW9uLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBOb3QgZm91bmQuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzcGVjaWZpYyBzZWN0aW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjZ2V0U2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWN0aW9uaWQgVGhlIHNlY3Rpb24gSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHJlamVjdCBjb250YWlucyB0aGUgZXJyb3IgbWVzc2FnZSwgZWxzZSBjb250YWlucyB0aGUgc2VjdGlvbi5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNlY3Rpb24gPSBmdW5jdGlvbihjb3Vyc2VpZCwgc2VjdGlvbmlkKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgaWYgKHNlY3Rpb25pZCA8IDApIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgnSW52YWxpZCBzZWN0aW9uIElEJyk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuZ2V0U2VjdGlvbnMoY291cnNlaWQpLnRoZW4oZnVuY3Rpb24oc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbnNbaV0uaWQgPT0gc2VjdGlvbmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2VjdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdVbmtvd24gc2VjdGlvbicpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY291cnNlIHNlY3Rpb25zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjZ2V0U2VjdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgIFRoZSBjb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcmVTZXRzXSBPcHRpb25hbC4gUHJlc2V0cyB0byB1c2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHJlamVjdCBjb250YWlucyB0aGUgZXJyb3IgbWVzc2FnZSwgZWxzZSBjb250YWlucyB0aGUgc2VjdGlvbnMuXG4gICAgICovXG4gICAgc2VsZi5nZXRTZWN0aW9ucyA9IGZ1bmN0aW9uKGNvdXJzZWlkLCBwcmVTZXRzLCBzaXRlSWQpIHtcbiAgICAgICAgcHJlU2V0cyA9IHByZVNldHMgfHwge307XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHByZVNldHMuY2FjaGVLZXkgPSBnZXRTZWN0aW9uc0NhY2hlS2V5KGNvdXJzZWlkKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLnJlYWQoJ2NvcmVfY291cnNlX2dldF9jb250ZW50cycsIHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlaWQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogW11cbiAgICAgICAgICAgIH0sIHByZVNldHMpLnRoZW4oZnVuY3Rpb24oc2VjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2VjdGlvbnMsIGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNlY3Rpb24ubW9kdWxlcywgZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDb250ZW50c0lmTmVlZGVkKG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWN0aW9ucztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3Igc2VjdGlvbiBXUyBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2VjdGlvbnNDYWNoZUtleShjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gJ21tQ291cnNlOnNlY3Rpb25zOicgKyBjb3Vyc2VpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBtb2R1bGUgV1MgY2FsbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlI2ludmFsaWRhdGVNb2R1bGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9kdWxlaWQgTW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlTW9kdWxlID0gZnVuY3Rpb24obW9kdWxlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0TW9kdWxlQ2FjaGVLZXkobW9kdWxlaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgbW9kdWxlIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZSNpbnZhbGlkYXRlTW9kdWxlQnlJbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAgICAgSW5zdGFuY2UgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZSBOYW1lIG9mIHRoZSBtb2R1bGUuIEUuZy4gJ2dsb3NzYXJ5Jy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVNb2R1bGVCeUluc3RhbmNlID0gZnVuY3Rpb24oaWQsIG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRNb2R1bGVCeUluc3RhbmNlQ2FjaGVLZXkoaWQsIG1vZHVsZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBzZWN0aW9ucyBXUyBjYWxsLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2UjaW52YWxpZGF0ZVNlY3Rpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkICBDb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbdXNlcmlkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCB1c2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZVNlY3Rpb25zID0gZnVuY3Rpb24oY291cnNlaWQsIHVzZXJpZCkge1xuICAgICAgICB1c2VyaWQgPSB1c2VyaWQgfHwgJG1tU2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICB2YXIgcDEgPSAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldFNlY3Rpb25zQ2FjaGVLZXkoY291cnNlaWQpKSxcbiAgICAgICAgICAgIHAyID0gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRBY3Rpdml0aWVzQ29tcGxldGlvbkNhY2hlS2V5KGNvdXJzZWlkLCB1c2VyaWQpKTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChbcDEsIHAyXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZSBhIG1vZHVsZSBuYW1lIHRvIGN1cnJlbnQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZSN0cmFuc2xhdGVNb2R1bGVOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZU5hbWUgVGhlIG1vZHVsZSBuYW1lLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgdHJhbnNsYXRlZCBuYW1lLlxuICAgICAqL1xuICAgIHNlbGYudHJhbnNsYXRlTW9kdWxlTmFtZSA9IGZ1bmN0aW9uKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgaWYgKG1vZHMuaW5kZXhPZihtb2R1bGVOYW1lKSA8IDApIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWUgPSBcImV4dGVybmFsLXRvb2xcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYW5na2V5ID0gJ21tLmNvcmUubW9kXycrbW9kdWxlTmFtZTtcbiAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUobGFuZ2tleSkudGhlbihmdW5jdGlvbih0cmFuc2xhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlZCAhPT0gbGFuZ2tleSA/IHRyYW5zbGF0ZWQgOiBtb2R1bGVOYW1lO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZScpXG5cbi8qKlxuICogQ291cnNlcyBuYXYgaGFuZGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQ291cnNlQ291cnNlc05hdkhhbmRsZXJcbiAqL1xuLmZhY3RvcnkoJyRtbUNvdXJzZUNvdXJzZXNOYXZIYW5kbGVyJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIHRoaXMgY291cnNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgICBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2Nlc3NEYXRhIFR5cGUgb2YgYWNjZXNzIHRvIHRoZSBjb3Vyc2U6IGRlZmF1bHQsIGd1ZXN0LCAuLi5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgVHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIGlzRW5hYmxlZEZvckNvdXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgQ291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgQ29udHJvbGxlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldENvbnRyb2xsZXI6IGZ1bmN0aW9uKGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICdpb24tYnJpZWZjYXNlJztcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW0uY291cnNlLmNvbnRlbnRzJztcblxuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlLCBjb3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1tX2NvdXJzZScsIHtjb3Vyc2VpZDogY291cnNlLmlkfSk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2UnKVxuXG4vKipcbiAqIERlbGVnYXRlIHRvIHJlZ2lzdGVyIGNvbnRlbnQgaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUNvdXJzZURlbGVnYXRlXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBUbyByZWdpc3RlciBhIGNvbnRlbnQgaGFuZGxlcjpcbiAqXG4gKiAuY29uZmlnKCRtbUNvdXJzZURlbGVnYXRlLCBmdW5jdGlvbigpIHtcbiAqICAgICAkbW1Db3Vyc2VEZWxlZ2F0ZS5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFZb3VyQWRkb24nLCAnbW9kdWxlTmFtZScsICdoYW5kbGVyTmFtZScpO1xuICogICAgICRtbUNvdXJzZURlbGVnYXRlLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZFBhZ2UnLCAncGFnZScsICckbW1hTW9kUGFnZUNvdXJzZUNvbnRlbnRIYW5kbGVyJyk7XG4gKiB9KVxuICpcbiAqIFRoZSBjb250ZW50IGhhbmRsZXIgbXVzdCBwcm92aWRlIHR3byBtZXRob2RzLlxuICpcbiAqIDEvIGlzRW5hYmxlZCgpIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uY2UgaW4gYSB3aGlsZSB0byBjaGVjayBpZiB0aGUgcGx1Z2luIHdvcmtzIG9uIHRoZSBjdXJyZW50IHNpdGUuXG4gKiAyLyBnZXRDb250cm9sbGVyKG1vZHVsZSwgY291cnNlaWQpIHdoaWNoIHNob3VsZCByZXR1cm4gYSBjb250cm9sbGVyIG9iamVjdFxuICpcbiAqIFRoZSBjb250cm9sbGVyIGhhcyBpdHMgb3duIHNjb3BlIGluaGVyaXRpbmcgdGhlIHBhcmVudCBvbmUuIFRob3VnaCB5b3Ugc2hvdWxkIG5vdCB1c2UgdGhlXG4gKiBwYXJlbnQgc2NvcGUuIFRvIGZpbmQgb3V0IG1vcmUgd2hhdCBzY29wZSB2YXJpYWJsZXMgYXJlIGV4cGVjdGVkIGxvb2sgYXQgdGhlIHRlbXBsYXRlXG4gKiBjb3JlL2NvbXBvbmVudHMvY291cnNlL3RlbXBsYXRlcy9zZWN0aW9uLmh0bWwgYW5kIGF0IGV4aXN0aW5nIGNvbnRlbnQgaGFuZGxlcnMuXG4gKi9cbi5wcm92aWRlcignJG1tQ291cnNlRGVsZWdhdGUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGVudEhhbmRsZXJzID0ge30sXG4gICAgICAgIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY29udGVudCBoYW5kbGVyLiBJZiBtb2R1bGUgaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IHNpdGUsIGhhbmRsZXIgc2hvdWxkIHJldHVybiB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZURlbGVnYXRlI3JlZ2lzdGVyQ29udGVudEhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkb24gVGhlIGFkZG9uJ3MgbmFtZSAobW1hTGFiZWwsIG1tYUZvcnVtLCAuLi4pXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXMgVGhlIG1vZHVsZSB0aGlzIGhhbmRsZXIgaGFuZGxlcywgZS5nLiBmb3J1bSwgbGFiZWwuIFRoaXMgdmFsdWUgd2lsbCBiZSBjb21wYXJlZCB3aXRoXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHZhbHVlIGNvbnRhaW5lZCBpbiBtb2R1bGUubW9kbmFtZSBmcm9tIHRoZSBXZWJzZXJ2aWNlIGNvcmVfY291cnNlX2dldF9jb250ZW50cy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IGhhbmRsZXIgTXVzdCBiZSByZXNvbHZlZCB0byBhbiBvYmplY3QgZGVmaW5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMuIE9yIHRvIGEgZnVuY3Rpb25cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmluZyBhbiBvYmplY3QgZGVmaW5pbmcgdGhlc2UgZnVuY3Rpb25zLiBTZWUge0BsaW5rICRtbVV0aWwjcmVzb2x2ZU9iamVjdH0uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gaXNFbmFibGVkIChCb29sZWFuKSBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIG9uIGEgc2l0ZSBsZXZlbC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBnZXRDb250cm9sbGVyKG1vZHVsZSwgY291cnNlaWQpIChGdW5jdGlvbikgUmV0dXJucyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGFjdCBhcyBjb250cm9sbGVyLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBjb3JlL2NvbXBvbmVudHMvY291cnNlL3RlbXBsYXRlcy9zZWN0aW9uLmh0bWxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlIGxpc3Qgb2Ygc2NvcGUgdmFyaWFibGVzIGV4cGVjdGVkLlxuICAgICAqL1xuICAgIHNlbGYucmVnaXN0ZXJDb250ZW50SGFuZGxlciA9IGZ1bmN0aW9uKGFkZG9uLCBoYW5kbGVzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudEhhbmRsZXJzW2hhbmRsZXNdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyOiBBZGRvbiAnXCIgKyBjb250ZW50SGFuZGxlcnNbaGFuZGxlc10uYWRkb24gKyBcIicgYWxyZWFkeSByZWdpc3RlcmVkIGFzIGhhbmRsZXIgZm9yICdcIiArIGhhbmRsZXMgKyBcIidcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCIkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyOiBSZWdpc3RlcmVkIGFkZG9uICdcIiArIGFkZG9uICsgXCInIGFzIGNvdXJzZSBjb250ZW50IGhhbmRsZXIuXCIpO1xuICAgICAgICBjb250ZW50SGFuZGxlcnNbaGFuZGxlc10gPSB7XG4gICAgICAgICAgICBhZGRvbjogYWRkb24sXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2VsZi4kZ2V0ID0gZnVuY3Rpb24oJHEsICRsb2csICRtbVNpdGUsICRtbVV0aWwsICRtbUNvdXJzZUNvbnRlbnRIYW5kbGVyKSB7XG4gICAgICAgIHZhciBlbmFibGVkSGFuZGxlcnMgPSB7fSxcbiAgICAgICAgICAgIHNlbGYgPSB7fTtcblxuICAgICAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tQ291cnNlRGVsZWdhdGUnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyIGEgY29udGVudCBoYW5kbGVyIHByb3ZpZGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgZmlyc3QgZ2V0IHRoZSBkZWZhdWx0IGRhdGEsIHRoZW4gY2FsbCB0aGUgaGFuZGxlciBpZiBhbnkgYW5kIG92ZXJyaWRlXG4gICAgICAgICAqIHRoZSBkZWZhdWx0IGRhdGEgd2l0aCB0aGUgbmV3IGRhdGEgZnJvbSB0aGUgaGFuZGxlci4gVGhhdCBtZWFucyB0aGF0IGEgaGFuZGxlclxuICAgICAgICAgKiBzaG91bGQgYWx3YXlzIG92ZXJyaWRlIGFueSBleGlzdGluZyBhdHRyaWJ1dGUgaWYgdGhleSB3YW50IHRvIGNoYW5nZSB0aGUgZGVmYXVsdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VEZWxlZ2F0ZSNnZXRDb250ZW50SGFuZGxlckNvbnRyb2xsZXJGb3JcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXMgICBUaGUgbW9kdWxlIHRvIHdvcmsgb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSAgICBUaGUgbW9kdWxlIGRhdGFcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkICBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VjdGlvbmlkIFRoZSBzZWN0aW9uIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRlbnRIYW5kbGVyQ29udHJvbGxlckZvciA9IGZ1bmN0aW9uKGhhbmRsZXMsIG1vZHVsZSwgY291cnNlaWQsIHNlY3Rpb25pZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkSGFuZGxlcnNbaGFuZGxlc10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWRIYW5kbGVyc1toYW5kbGVzXS5nZXRDb250cm9sbGVyKG1vZHVsZSwgY291cnNlaWQsIHNlY3Rpb25pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJG1tQ291cnNlQ29udGVudEhhbmRsZXIuZ2V0Q29udHJvbGxlcihtb2R1bGUsIGNvdXJzZWlkLCBzZWN0aW9uaWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGVuYWJsZWQgaGFuZGxlcnMgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VEZWxlZ2F0ZSN1cGRhdGVDb250ZW50SGFuZGxlclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlcyBUaGUgbW9kdWxlIHRoaXMgaGFuZGxlciBoYW5kbGVzLCBlLmcuIGZvcnVtLCBsYWJlbC4gVGhpcyB2YWx1ZSB3aWxsIGJlIGNvbXBhcmVkIHdpdGhcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJJbmZvIFRoZSBoYW5kbGVyIGRldGFpbHMuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gZW5hYmxlZCwgcmVqZWN0ZWQgd2hlbiBub3QuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYudXBkYXRlQ29udGVudEhhbmRsZXIgPSBmdW5jdGlvbihoYW5kbGVzLCBoYW5kbGVySW5mbykge1xuICAgICAgICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlckluZm8uaW5zdGFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlckluZm8uaW5zdGFuY2UgPSAkbW1VdGlsLnJlc29sdmVPYmplY3QoaGFuZGxlckluZm8uaGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKGhhbmRsZXJJbmZvLmluc3RhbmNlLmlzRW5hYmxlZCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBjb250ZW50IGlzIGVuYWJsZWQuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkSGFuZGxlcnNbaGFuZGxlc10gPSBoYW5kbGVySW5mby5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVuYWJsZWRIYW5kbGVyc1toYW5kbGVzXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlRGVsZWdhdGUjdXBkYXRlQ29udGVudEhhbmRsZXJzXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gZG9uZS5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi51cGRhdGVDb250ZW50SGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGVuYWJsZWRIYW5kbGVycyA9IHt9O1xuXG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdVcGRhdGluZyBjb250ZW50IGhhbmRsZXJzIGZvciBjdXJyZW50IHNpdGUuJyk7XG5cbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBhbGwgdGhlIGNvbnRlbnQgaGFuZGxlcnMuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGVudEhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVySW5mbywgaGFuZGxlcykge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi51cGRhdGVDb250ZW50SGFuZGxlcihoYW5kbGVzLCBoYW5kbGVySW5mbykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXZlciByZWplY3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZScpXG5cbi8qKlxuICogSGVscGVyIHRvIGdhdGhlciBzb21lIGNvbW1vbiBjb3Vyc2UgZnVuY3Rpb25zLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Db3Vyc2VIZWxwZXJcbiAqL1xuLmZhY3RvcnkoJyRtbUNvdXJzZUhlbHBlcicsIGZ1bmN0aW9uKCRxLCAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLCAkbW1GaWxlcG9vbCwgJG1tVXRpbCwgJG1tQ291cnNlLCAkbW1TaXRlLCAkc3RhdGUsXG4gICAgICAgICAgICBtbUNvcmVOb3REb3dubG9hZGVkLCBtbUNvcmVPdXRkYXRlZCwgbW1Db3JlRG93bmxvYWRpbmcsIG1tQ29yZUNvdXJzZUFsbFNlY3Rpb25zSWQpIHtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHN0YXR1cyBvZiBhIHNlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZUhlbHBlciNjYWxjdWxhdGVTZWN0aW9uU3RhdHVzXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gc2VjdGlvbiAgICAgICAgICBTZWN0aW9uIHRvIGNhbGN1bGF0ZSBpdHMgc3RhdHVzLiBDYW4ndCBiZSBcIkFsbCBzZWN0aW9uc1wiLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlaWQgICAgICAgICAgQ291cnNlIElEIHRoZSBzZWN0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXN0b3JlRG93bmxvYWRzICBUcnVlIGlmIGl0IHNob3VsZCByZXN0b3JlIGRvd25sb2Fkcy4gSXQgd2lsbCB0cnkgdG8gcmVzdG9yZSB0aGlzIHNlY3Rpb24gZG93bmxvYWRzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVmcmVzaCAgICAgICAgICAgVHJ1ZSBpZiBpdCBzaG91bGRuJ3QgdXNlIG1vZHVsZSBzdGF0dXMgY2FjaGUgKHNsb3dlcikuXG4gICAgICogQHBhcmFtIHtQcm9taXNlW119IFtkd25wcm9taXNlc10gICBJZiBzZWN0aW9uIGRvd25sb2FkIGlzIHJlc3RvcmVkLCBhIHByb21pc2Ugd2lsbCBiZSBhZGRlZCB0byB0aGlzIGFycmF5LiBSZXF1aXJlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcmVzdG9yZURvd25sb2Fkcz10cnVlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBzdGF0ZSBpcyBjYWxjdWxhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuY2FsY3VsYXRlU2VjdGlvblN0YXR1cyA9IGZ1bmN0aW9uKHNlY3Rpb24sIGNvdXJzZWlkLCByZXN0b3JlRG93bmxvYWRzLCByZWZyZXNoLCBkd25wcm9taXNlcykge1xuXG4gICAgICAgIGlmIChzZWN0aW9uLmlkICE9PSBtbUNvcmVDb3Vyc2VBbGxTZWN0aW9uc0lkKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHN0YXR1cyBvZiB0aGlzIHNlY3Rpb24uXG4gICAgICAgICAgICByZXR1cm4gJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5nZXRNb2R1bGVzU3RhdHVzKHNlY3Rpb24uaWQsIHNlY3Rpb24ubW9kdWxlcywgY291cnNlaWQsIHJlZnJlc2gsIHJlc3RvcmVEb3dubG9hZHMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBiZWluZyBkb3dubG9hZGVkLiBXZSBjYW4ndCB0cnVzdCBzdGF0dXMgMTAwJSBiZWNhdXNlIGRvd25sb2FkZWQgYm9va3MgYXJlIGFsd2F5cyBvdXRkYXRlZC5cbiAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRpZCA9IHNlbGYuZ2V0U2VjdGlvbkRvd25sb2FkSWQoc2VjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUuaXNCZWluZ0Rvd25sb2FkZWQoZG93bmxvYWRpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9IG1tQ29yZURvd25sb2FkaW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGlzIHNlY3Rpb24gZGF0YS5cbiAgICAgICAgICAgICAgICBzZWN0aW9uLnNob3dEb3dubG9hZCA9IHJlc3VsdC5zdGF0dXMgPT09IG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5zaG93UmVmcmVzaCA9IHJlc3VsdC5zdGF0dXMgPT09IG1tQ29yZU91dGRhdGVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09IG1tQ29yZURvd25sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24uaXNEb3dubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLnRvdGFsID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyZXN0b3JlRG93bmxvYWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBkb3dubG9hZCBkYXRhLlxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi50b3RhbCA9IHJlc3VsdFttbUNvcmVPdXRkYXRlZF0ubGVuZ3RoICsgcmVzdWx0W21tQ29yZU5vdERvd25sb2FkZWRdLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbbW1Db3JlRG93bmxvYWRpbmddLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5pc0Rvd25sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG9yIHJlLXN0YXJ0IHRoZSBwcmVmZXRjaC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBzZWxmLnN0YXJ0T3JSZXN0b3JlUHJlZmV0Y2goc2VjdGlvbiwgcmVzdWx0LCBjb3Vyc2VpZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLWNhbGN1bGF0ZSB0aGUgc3RhdHVzIG9mIHRoaXMgc2VjdGlvbiBvbmNlIGZpbmlzaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsY3VsYXRlU2VjdGlvblN0YXR1cyhzZWN0aW9uLCBjb3Vyc2VpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHducHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR3bnByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHN0YXR1cyBvZiBhIGxpc3Qgb2Ygc2VjdGlvbnMsIHNldHRpbmcgYXR0cmlidXRlcyB0byBkZXRlcm1pbmUgdGhlIGljb25zL2RhdGEgdG8gYmUgc2hvd24uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZUhlbHBlciNjYWxjdWxhdGVTZWN0aW9uc1N0YXR1c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHNlY3Rpb25zICAgICAgICAgU2VjdGlvbnMgdG8gY2FsY3VsYXRlIHRoZWlyIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZWlkICAgICAgICAgIENvdXJzZSBJRCB0aGUgc2VjdGlvbnMgYmVsb25nIHRvLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzdG9yZURvd25sb2FkcyAgVHJ1ZSBpZiBpdCBzaG91bGQgcmVzdG9yZSBkb3dubG9hZHMuIEl0IHdpbGwgdHJ5IHRvIHJlc3RvcmUgc2VjdGlvbiBkb3dubG9hZHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZnJlc2ggICAgICAgICAgIFRydWUgaWYgaXQgc2hvdWxkbid0IHVzZSBtb2R1bGUgc3RhdHVzIGNhY2hlIChzbG93ZXIpLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBzdGF0ZXMgYXJlIGNhbGN1bGF0ZWQuIFJldHVybnMgYW4gYXJyYXkgb2YgZG93bmxvYWQgcHJvbWlzZXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIHJlc3RvcmVkIGRvd25sb2FkcyAob25seSBpZiByZXN0b3JlRG93bmxvYWRzPXRydWUpLlxuICAgICAqL1xuICAgIHNlbGYuY2FsY3VsYXRlU2VjdGlvbnNTdGF0dXMgPSBmdW5jdGlvbihzZWN0aW9ucywgY291cnNlaWQsIHJlc3RvcmVEb3dubG9hZHMsIHJlZnJlc2gpIHtcblxuICAgICAgICB2YXIgYWxsc2VjdGlvbnNzZWN0aW9uLFxuICAgICAgICAgICAgYWxsc2VjdGlvbnNzdGF0dXMsXG4gICAgICAgICAgICBkb3dubG9hZHByb21pc2VzID0gW10sXG4gICAgICAgICAgICBzdGF0dXNwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzZWN0aW9ucywgZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24uaWQgPT09IG1tQ29yZUNvdXJzZUFsbFNlY3Rpb25zSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBcIkFsbCBzZWN0aW9uc1wiIHNlY3Rpb24gc3RhdHVzIGlzIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIHN0YXR1cyBvZiB0aGUgcmVzdCBvZiBzZWN0aW9ucy5cbiAgICAgICAgICAgICAgICBhbGxzZWN0aW9uc3NlY3Rpb24gPSBzZWN0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNwcm9taXNlcy5wdXNoKHNlbGYuY2FsY3VsYXRlU2VjdGlvblN0YXR1cyhzZWN0aW9uLCBjb3Vyc2VpZCwgcmVzdG9yZURvd25sb2FkcywgcmVmcmVzaCwgZG93bmxvYWRwcm9taXNlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBcIkFsbCBzZWN0aW9uc1wiIHN0YXR1cy5cbiAgICAgICAgICAgICAgICAgICAgYWxsc2VjdGlvbnNzdGF0dXMgPSAkbW1GaWxlcG9vbC5kZXRlcm1pbmVQYWNrYWdlc1N0YXR1cyhhbGxzZWN0aW9uc3N0YXR1cywgcmVzdWx0LnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gJHEuYWxsKHN0YXR1c3Byb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGFsbHNlY3Rpb25zc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFNldCBcIkFsbCBzZWN0aW9uc1wiIGRhdGEuXG4gICAgICAgICAgICAgICAgYWxsc2VjdGlvbnNzZWN0aW9uLnNob3dEb3dubG9hZCA9IGFsbHNlY3Rpb25zc3RhdHVzID09PSBtbUNvcmVOb3REb3dubG9hZGVkO1xuICAgICAgICAgICAgICAgIGFsbHNlY3Rpb25zc2VjdGlvbi5zaG93UmVmcmVzaCA9IGFsbHNlY3Rpb25zc3RhdHVzID09PSBtbUNvcmVPdXRkYXRlZDtcbiAgICAgICAgICAgICAgICBhbGxzZWN0aW9uc3NlY3Rpb24uaXNEb3dubG9hZGluZyA9IGFsbHNlY3Rpb25zc3RhdHVzID09PSBtbUNvcmVEb3dubG9hZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb3dubG9hZHByb21pc2VzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzaXplIG9mIHRoZSBkb3dubG9hZCBhbmQgc2hvdyBhIGNvbmZpcm0gbW9kYWwgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VIZWxwZXIjY29uZmlybURvd25sb2FkU2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCAgIENvdXJzZSBJRCB0aGUgc2VjdGlvbiBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWN0aW9uICAgIFNlY3Rpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gc2VjdGlvbnMgTGlzdCBvZiBzZWN0aW9ucy4gVXNlZCB3aGVuIGRvd25sb2FkaW5nIGFsbCB0aGUgc2VjdGlvbnMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCBpZiB0aGUgdXNlciBjb25maXJtcyBvciB0aGVyZSdzIG5vIG5lZWQgdG8gY29uZmlybS5cbiAgICAgKi9cbiAgICBzZWxmLmNvbmZpcm1Eb3dubG9hZFNpemUgPSBmdW5jdGlvbihjb3Vyc2VpZCwgc2VjdGlvbiwgc2VjdGlvbnMpIHtcbiAgICAgICAgdmFyIHNpemVQcm9taXNlO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGUgZG93bmxvYWQuXG4gICAgICAgIGlmIChzZWN0aW9uLmlkICE9IG1tQ29yZUNvdXJzZUFsbFNlY3Rpb25zSWQpIHtcbiAgICAgICAgICAgIHNpemVQcm9taXNlID0gJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5nZXREb3dubG9hZFNpemUoc2VjdGlvbi5tb2R1bGVzLCBjb3Vyc2VpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBzaXplID0gMDtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzZWN0aW9ucywgZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIGlmIChzLmlkICE9IG1tQ29yZUNvdXJzZUFsbFNlY3Rpb25zSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLmdldERvd25sb2FkU2l6ZShzLm1vZHVsZXMsIGNvdXJzZWlkKS50aGVuKGZ1bmN0aW9uKHNlY3Rpb25zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gc2l6ZSArIHNlY3Rpb25zaXplO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzaXplUHJvbWlzZSA9ICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNpemVQcm9taXNlLnRoZW4oZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAgICAgLy8gU2hvdyBjb25maXJtIG1vZGFsIGlmIG5lZWRlZC5cbiAgICAgICAgICAgIHJldHVybiAkbW1VdGlsLmNvbmZpcm1Eb3dubG9hZFNpemUoc2l6ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvdXJzZSBJRCBmcm9tIGEgbW9kdWxlLCBzaG93aW5nIGFuIGVycm9yIG1lc3NhZ2UgaWYgaXQgY2FuJ3QgYmUgcmV0cmlldmVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VIZWxwZXIjZ2V0TW9kdWxlQ291cnNlSWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgICAgICAgIEluc3RhbmNlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGUgICAgTmFtZSBvZiB0aGUgbW9kdWxlLiBFLmcuICdnbG9zc2FyeScuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBtb2R1bGUncyBjb3Vyc2UgSUQuXG4gICAgICovXG4gICAgc2VsZi5nZXRNb2R1bGVDb3Vyc2VJZEJ5SW5zdGFuY2UgPSBmdW5jdGlvbihpZCwgbW9kdWxlLCBzaXRlSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUNvdXJzZS5nZXRNb2R1bGVCYXNpY0luZm9CeUluc3RhbmNlKGlkLCBtb2R1bGUsIHNpdGVJZCkudGhlbihmdW5jdGlvbihjbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNtLmNvdXJzZTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3Vyc2UuZXJyb3JnZXRtb2R1bGUnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG93bmxvYWQgSUQgb2YgYSBzZWN0aW9uLiBJdCdzIHVzZWQgdG8gaW50ZXJhY3Qgd2l0aCAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VIZWxwZXIjZ2V0U2VjdGlvbkRvd25sb2FkSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VjdGlvbiBTZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIFNlY3Rpb24gZG93bmxvYWQgSUQuXG4gICAgICovXG4gICAgc2VsZi5nZXRTZWN0aW9uRG93bmxvYWRJZCA9IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICdTZWN0aW9uLScrc2VjdGlvbi5pZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjb3Vyc2VJZCBvZiB0aGUgbW9kdWxlIGFuZCBuYXZpZ2F0ZXMgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZUhlbHBlciNuYXZpZ2F0ZVRvTW9kdWxlXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBtb2R1bGVJZCAgICBNb2R1bGUncyBJRC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdICAgIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdICBDb3Vyc2UgSUQuIElmIG5vdCBkZWZpbmVkIHdlJ2xsIHRyeSB0byByZXRyaWV2ZSBpdCBmcm9tIHRoZSBzaXRlLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW3NlY3Rpb25JZF0gU2VjdGlvbiB0aGUgbW9kdWxlIGJlbG9uZ3MgdG8uIElmIG5vdCBkZWZpbmVkIHdlJ2xsIHRyeSB0byByZXRyaWV2ZSBpdCBmcm9tIHRoZSBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHNlbGYubmF2aWdhdGVUb01vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZUlkLCBzaXRlSWQsIGNvdXJzZUlkLCBzZWN0aW9uSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCksXG4gICAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2UuY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoY291cnNlSWQgJiYgc2VjdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZXRyaWV2ZSBtb3JlIGRhdGEuXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvdXJzZUlkICYmICFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBlbm91Z2ggZGF0YSBhbmQgd2UgY2FuJ3QgcmV0cmlldmUgaXQuXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghY291cnNlSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvdXJzZUlkIGJ1dCBXUyBpcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlQmFzaWNJbmZvKG1vZHVsZUlkLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdXJzZUlkID0gbW9kdWxlLmNvdXJzZTtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbklkID0gbW9kdWxlLnNlY3Rpb247XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgc2VjdGlvbklkIGJ1dCB3ZSBoYXZlIGNvdXJzZUlkLlxuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlU2VjdGlvbklkKG1vZHVsZUlkLCBjb3Vyc2VJZCwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25JZCA9IGlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkc3RhdGUuZ28oJ3JlZGlyZWN0Jywge1xuICAgICAgICAgICAgICAgICAgICBzaXRlaWQ6IHNpdGVJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdzaXRlLm1tX2NvdXJzZScsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291cnNlaWQ6IGNvdXJzZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlaWQ6IG1vZHVsZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lkOiBzZWN0aW9uSWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY291cnNlLmVycm9yZ2V0bW9kdWxlJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCBvciByZXN0b3JlIHRoZSBwcmVmZXRjaCBvZiBvbmUgc2VjdGlvbiBvciBhbGwgdGhlIHNlY3Rpb25zLlxuICAgICAqIElmIHRoZSBzZWN0aW9uIGlzIFwiQWxsIHNlY3Rpb25zXCIgaXQgd2lsbCBwcmVmZXRjaCBhbGwgdGhlIHNlY3Rpb25zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VIZWxwZXIjcHJlZmV0Y2hcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNlY3Rpb24gICAgU2VjdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZWlkICAgQ291cnNlIElEIHRoZSBzZWN0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IHNlY3Rpb25zIExpc3Qgb2Ygc2VjdGlvbnMuIFVzZWQgd2hlbiBkb3dubG9hZGluZyBhbGwgdGhlIHNlY3Rpb25zLlxuICAgICAqIEByZXR1cm4ge3Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHByZWZldGNoIGlzIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIHNlbGYucHJlZmV0Y2ggPSBmdW5jdGlvbihzZWN0aW9uLCBjb3Vyc2VpZCwgc2VjdGlvbnMpIHtcblxuICAgICAgICBpZiAoc2VjdGlvbi5pZCAhPSBtbUNvcmVDb3Vyc2VBbGxTZWN0aW9uc0lkKSB7XG4gICAgICAgICAgICAvLyBEb3dubG9hZCBvbmx5IHRoaXMgc2VjdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByZWZldGNoU2VjdGlvbihzZWN0aW9uLCBjb3Vyc2VpZCwgdHJ1ZSwgc2VjdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRG93bmxvYWQgYWxsIHRoZSBzZWN0aW9ucyBleGNlcHQgXCJBbGwgc2VjdGlvbnNcIi5cbiAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYSBmYWlsdXJlLCB3ZSB3YW50IHRoYXQgQUxMIHByb21pc2VzIGhhdmUgZmluaXNoZWQgYmVmb3JlIHJlamVjdGluZyB0aGUgcHJvbWlzZS5cbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICBzZWN0aW9uLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNlY3Rpb25zLCBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMuaWQgIT0gbW1Db3JlQ291cnNlQWxsU2VjdGlvbnNJZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYucHJlZmV0Y2hTZWN0aW9uKHMsIGNvdXJzZWlkLCBmYWxzZSwgc2VjdGlvbnMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgb25seSB0aGUgc2VjdGlvbiB0aGF0IGZpbmlzaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsY3VsYXRlU2VjdGlvblN0YXR1cyhzLCBjb3Vyc2VpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRtbVV0aWwuYWxsUHJvbWlzZXMocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIG9yIHJlc3RvcmUgdGhlIHByZWZldGNoIG9mIGEgY2VydGFpbiBzZWN0aW9uIGlmIGl0IG5lZWRzIHRvIGJlIHByZWZldGNoZWQuXG4gICAgICogSWYgdGhlIHNlY3Rpb24gaXMgXCJBbGwgc2VjdGlvbnNcIiBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZUhlbHBlciNwcmVmZXRjaFNlY3Rpb25cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNlY3Rpb24gICAgICAgICBTZWN0aW9uIHRvIHByZWZldGNoLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlaWQgICAgICAgIENvdXJzZSBJRCB0aGUgc2VjdGlvbiBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHNpbmdsZURvd25sb2FkIFRydWUgaWYgdXNlciBpcyBvbmx5IGRvd25sb2FkaW5nIHRoaXMgc2VjdGlvbiwgZmFsc2UgaWYgdXNlciBpcyBkb3dubG9hZGluZyBhbGwgc2VjdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gW3NlY3Rpb25zXSAgICAgTGlzdCBvZiBzZWN0aW9ucy4gVXNlZCBvbmx5IGlmIHNpbmdsZURvd25sb2FkIGlzIHRydWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBzZWN0aW9uIGlzIHByZWZldGNoZWQuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaFNlY3Rpb24gPSBmdW5jdGlvbihzZWN0aW9uLCBjb3Vyc2VpZCwgc2luZ2xlRG93bmxvYWQsIHNlY3Rpb25zKSB7XG5cbiAgICAgICAgaWYgKHNlY3Rpb24uaWQgPT0gbW1Db3JlQ291cnNlQWxsU2VjdGlvbnNJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlY3Rpb24uaXNEb3dubG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNlY3Rpb24gbmVlZHMgdG8gYmUgZG93bmxvYWRlZCBhbmQgY2FsY3VsYXRlIGFtb3VudCBvZiBtb2R1bGVzIHRoYXQgbmVlZCB0byBiZSBkb3dubG9hZGVkLlxuICAgICAgICByZXR1cm4gJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5nZXRNb2R1bGVzU3RhdHVzKHNlY3Rpb24uaWQsIHNlY3Rpb24ubW9kdWxlcywgY291cnNlaWQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gbW1Db3JlTm90RG93bmxvYWRlZCB8fCByZXN1bHQuc3RhdHVzID09PSBtbUNvcmVPdXRkYXRlZCB8fMKgcmVzdWx0LnN0YXR1cyA9PT0gbW1Db3JlRG93bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYuc3RhcnRPclJlc3RvcmVQcmVmZXRjaChzZWN0aW9uLCByZXN1bHQsIGNvdXJzZWlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlRG93bmxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtY2FsY3VsYXRlIHN0YXR1cyB0byBkZXRlcm1pbmUgdGhlIHJpZ2h0IHN0YXR1cyBmb3IgdGhlIFwiQWxsIHNlY3Rpb25zXCIgc2VjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxjdWxhdGVTZWN0aW9uc1N0YXR1cyhzZWN0aW9ucywgY291cnNlaWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLlxuICAgICAgICAgICAgc2VjdGlvbi5pc0Rvd25sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBvciByZXN0b3JlIHRoZSBwcmVmZXRjaCBvZiBhIHNlY3Rpb24uXG4gICAgICogSWYgdGhlIHNlY3Rpb24gaXMgXCJBbGwgc2VjdGlvbnNcIiBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZUhlbHBlciNzdGFydE9yUmVzdG9yZVByZWZldGNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlY3Rpb24gU2VjdGlvbiB0byBkb3dubG9hZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdHVzICBSZXN1bHQgb2YgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSNnZXRNb2R1bGVzU3RhdHVzIGZvciB0aGlzIHNlY3Rpb24uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBzZWN0aW9uIGhhcyBiZWVuIHByZWZldGNoZWQuXG4gICAgICovXG4gICAgc2VsZi5zdGFydE9yUmVzdG9yZVByZWZldGNoID0gZnVuY3Rpb24oc2VjdGlvbiwgc3RhdHVzLCBjb3Vyc2VpZCkge1xuXG4gICAgICAgIGlmIChzZWN0aW9uLmlkID09IG1tQ29yZUNvdXJzZUFsbFNlY3Rpb25zSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBvbmx5IGRvd25sb2FkIG1vZHVsZXMgd2l0aCBzdGF0dXMgbm90ZG93bmxvYWRlZCwgZG93bmxvYWRpbmcgb3Igb3V0ZGF0ZWQuXG4gICAgICAgIHZhciBtb2R1bGVzID0gc3RhdHVzW21tQ29yZU91dGRhdGVkXS5jb25jYXQoc3RhdHVzW21tQ29yZU5vdERvd25sb2FkZWRdKS5jb25jYXQoc3RhdHVzW21tQ29yZURvd25sb2FkaW5nXSksXG4gICAgICAgICAgICBkb3dubG9hZGlkID0gc2VsZi5nZXRTZWN0aW9uRG93bmxvYWRJZChzZWN0aW9uKSxcbiAgICAgICAgICAgIG1vZHVsZWlkcztcblxuICAgICAgICBtb2R1bGVpZHMgPSBtb2R1bGVzLm1hcChmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5pZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2V0IGRvd25sb2FkIGRhdGEuXG4gICAgICAgIHNlY3Rpb24uY291bnQgPSAwO1xuICAgICAgICBzZWN0aW9uLnRvdGFsID0gbW9kdWxlcy5sZW5ndGg7XG4gICAgICAgIHNlY3Rpb24uaXNEb3dubG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgLy8gV2UgcHJlZmV0Y2ggYWxsIHRoZSBtb2R1bGVzIHRvIHByZXZlbnQgaW5jb2VoZXJlbmNlcyBpbiB0aGUgZG93bmxvYWQgY291bnRcbiAgICAgICAgLy8gYW5kIGFsc28gdG8gZG93bmxvYWQgc3RhbGUgZGF0YSB0aGF0IG1pZ2h0IG5vdCBiZSBtYXJrZWQgYXMgb3V0ZGF0ZWQuXG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLnByZWZldGNoQWxsKGRvd25sb2FkaWQsIG1vZHVsZXMsIGNvdXJzZWlkKS50aGVuKGZ1bmN0aW9uKCkge30sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBzbyBlcnJvcnMgYXJlIGhhbmRsZWQgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9LCBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgLy8gUHJvZ3Jlc3MuIENoZWNrIHRoYXQgdGhlIG1vZHVsZSBkb3dubG9hZGVkIGlzIG9uZSBvZiB0aGUgZXhwZWN0ZWQgb25lcy5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IG1vZHVsZWlkcy5pbmRleE9mKGlkKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBvbmUgb2YgdGhlIG1vZHVsZXMgd2Ugd2VyZSBleHBlY3RpbmcgdG8gZG93bmxvYWQuXG4gICAgICAgICAgICAgICAgbW9kdWxlaWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5jb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZScpXG5cbi8qKlxuICogRGVsZWdhdGUgdG8gcmVnaXN0ZXIgcHJlZmV0Y2ggaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogVG8gcmVnaXN0ZXIgYSBwcmVmZXRjaCBoYW5kbGVyOlxuICpcbiAqIC5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gKiAgICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJlZmV0Y2hIYW5kbGVyKCdtbWFZb3VyQWRkb24nLCAnbW9kdWxlTmFtZScsICdoYW5kbGVyTmFtZScpO1xuICogfSlcbiAqXG4gKiBUbyBzZWUgdGhlIG1ldGhvZHMgdGhhdCBtdXN0IHByb3ZpZGUgdGhlIHByZWZldGNoIGhhbmRsZXIgc2VlIHtAbGluayAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIjcmVnaXN0ZXJQcmVmZXRjaEhhbmRsZXJ9LlxuICovXG4ucHJvdmlkZXIoJyRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJlZmV0Y2hIYW5kbGVycyA9IHt9LFxuICAgICAgICBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHByZWZldGNoIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyI3JlZ2lzdGVyUHJlZmV0Y2hIYW5kbGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFkZG9uIFRoZSBhZGRvbidzIG5hbWUgKG1tYUxhYmVsLCBtbWFGb3J1bSwgLi4uKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYW5kbGVzIFRoZSBtb2R1bGUgdGhpcyBoYW5kbGVyIGhhbmRsZXMsIGUuZy4gZm9ydW0sIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gaGFuZGxlciBNdXN0IGJlIHJlc29sdmVkIHRvIGFuIG9iamVjdCBkZWZpbmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucy4gT3IgdG8gYSBmdW5jdGlvblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuaW5nIGFuIG9iamVjdCBkZWZpbmluZyB0aGVzZSBwcm9wZXJ0aWVzLiBTZWUge0BsaW5rICRtbVV0aWwjcmVzb2x2ZU9iamVjdH0uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gY29tcG9uZW50IChTdHJpbmcpIEhhbmRsZXIncyBjb21wb25lbnQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gZ2V0RG93bmxvYWRTaXplKG1vZHVsZSwgY291cnNlaWQpIChOdW1iZXJ8UHJvbWlzZSkgR2V0IHRoZSBkb3dubG9hZCBzaXplIG9mIGEgbW9kdWxlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGlzRW5hYmxlZCgpIChCb29sZWFufFByb21pc2UpIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgb24gYSBzaXRlIGxldmVsLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZWZldGNoKG1vZHVsZSwgY291cnNlaWQpIChQcm9taXNlKSBQcmVmZXRjaGVzIGEgbW9kdWxlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIChPcHRpb25hbCkgZ2V0RmlsZXMobW9kdWxlLCBjb3Vyc2VpZCkgKE9iamVjdFtdfFByb21pc2UpIEdldCBsaXN0IG9mIGZpbGVzLiBJZiBub3QgZGVmaW5lZCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZSdsbCBhc3N1bWUgdGhleSdyZSBpbiBtb2R1bGUuY29udGVudHMuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gKE9wdGlvbmFsKSBkZXRlcm1pbmVTdGF0dXMoc3RhdHVzKSAoU3RyaW5nKSBSZXR1cm5zIHN0YXR1cyB0byBzaG93IGJhc2VkIG9uIGN1cnJlbnQuIEUuZy4gZm9yXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2tzIHdlJ2xsIHNob3cgXCJvdXRkYXRlZFwiIGV2ZW4gaWYgc3RhdGUgaXMgXCJkb3dubG9hZGVkXCIuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gKE9wdGlvbmFsKSBnZXRSZXZpc2lvbihtb2R1bGUsIGNvdXJzZWlkKSAoU3RyaW5nfE51bWJlcnxQcm9taXNlKSBSZXR1cm5zIHRoZSBtb2R1bGUgcmV2aXNpb24uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBkZWZpbmVkIHdlJ2xsIGNhbGN1bGF0ZSBpdCB1c2luZyBtb2R1bGUgZmlsZXMuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gKE9wdGlvbmFsKSBnZXRUaW1lbW9kaWZpZWQobW9kdWxlLCBjb3Vyc2VpZCkgKE51bWJlcnxQcm9taXNlKSBSZXR1cm5zIHRoZSBtb2R1bGUgdGltZW1vZGlmaWVkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgZGVmaW5lZCB3ZSdsbCBjYWxjdWxhdGUgaXQgdXNpbmcgbW9kdWxlIGZpbGVzLlxuICAgICAqL1xuICAgIHNlbGYucmVnaXN0ZXJQcmVmZXRjaEhhbmRsZXIgPSBmdW5jdGlvbihhZGRvbiwgaGFuZGxlcywgaGFuZGxlcikge1xuICAgICAgICBpZiAodHlwZW9mIHByZWZldGNoSGFuZGxlcnNbaGFuZGxlc10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGVQcm92aWRlcjogQWRkb24gJ1wiICsgcHJlZmV0Y2hIYW5kbGVyc1toYW5kbGVzXS5hZGRvbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInIGFscmVhZHkgcmVnaXN0ZXJlZCBhcyBoYW5kbGVyIGZvciAnXCIgKyBoYW5kbGVzICsgXCInXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyOiBSZWdpc3RlcmVkIGFkZG9uICdcIiArIGFkZG9uICsgXCInIGFzIHByZWZldGNoIGhhbmRsZXIuXCIpO1xuICAgICAgICBwcmVmZXRjaEhhbmRsZXJzW2hhbmRsZXNdID0ge1xuICAgICAgICAgICAgYWRkb246IGFkZG9uLFxuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICAgIGluc3RhbmNlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHNlbGYuJGdldCA9IGZ1bmN0aW9uKCRxLCAkbG9nLCAkbW1TaXRlLCAkbW1VdGlsLCAkbW1GaWxlcG9vbCwgJG1tRXZlbnRzLCBtbUNvcmVEb3dubG9hZGVkLCBtbUNvcmVEb3dubG9hZGluZyxcbiAgICAgICAgICAgICAgICBtbUNvcmVOb3REb3dubG9hZGVkLCBtbUNvcmVPdXRkYXRlZCwgbW1Db3JlTm90RG93bmxvYWRhYmxlLCBtbUNvcmVFdmVudFNlY3Rpb25TdGF0dXNDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBlbmFibGVkSGFuZGxlcnMgPSB7fSxcbiAgICAgICAgICAgIHNlbGYgPSB7fSxcbiAgICAgICAgICAgIGRlZmVycmVkcyA9IHt9LFxuICAgICAgICAgICAgc3RhdHVzQ2FjaGUgPSB7fTsgLy8gVG8gc3BlZWQgdXAgdGhlIGdldE1vZHVsZXNTdGF0dXMgZnVuY3Rpb24uXG5cbiAgICAgICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgdGhlIHN0YXR1cyBjYWNoZSAobWVtb3J5IG9iamVjdCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUjY2xlYXJTdGF0dXNDYWNoZVxuICAgICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5jbGVhclN0YXR1c0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdGF0dXNDYWNoZSA9IHt9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGEgbW9kdWxlIHN0YXR1cyBiYXNlZCBvbiBjdXJyZW50IHN0YXR1cywgcmVzdG9yaW5nIGRvd25sb2FkcyBpZiBuZWVkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUjZGV0ZXJtaW5lTW9kdWxlU3RhdHVzXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gbW9kdWxlICAgICAgICAgICBNb2R1bGUuXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RhdHVzICAgICAgICAgICBDdXJyZW50IHN0YXR1cy5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSByZXN0b3JlRG93bmxvYWRzIFRydWUgaWYgaXQgc2hvdWxkIHJlc3RvcmUgZG93bmxvYWRzIGlmIG5lZWRlZC5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgICAgIE1vZHVsZSBzdGF0dXMuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmRldGVybWluZU1vZHVsZVN0YXR1cyA9IGZ1bmN0aW9uKG1vZHVsZSwgc3RhdHVzLCByZXN0b3JlRG93bmxvYWRzKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGVuYWJsZWRIYW5kbGVyc1ttb2R1bGUubW9kbmFtZV07XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSBtbUNvcmVEb3dubG9hZGluZyAmJiByZXN0b3JlRG93bmxvYWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBkb3dubG9hZCBpcyBiZWluZyBoYW5kbGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoISRtbUZpbGVwb29sLmdldFBhY2thZ2VEb3dubG9hZFByb21pc2UoJG1tU2l0ZS5nZXRJZCgpLCBoYW5kbGVyLmNvbXBvbmVudCwgbW9kdWxlLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGhhbmRsZWQsIHRoZSBhcHAgd2FzIHByb2JhYmx5IHJlc3RhcnRlZCBvciBzb21ldGhpbmcgd2VpcmQgaGFwcGVuZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS1zdGFydCBkb3dubG9hZCAoZmlsZXMgYWxyZWFkeSBvbiBxdWV1ZSBvciBhbHJlYWR5IGRvd25sb2FkZWQgd2lsbCBiZSBza2lwcGVkKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIucHJlZmV0Y2gobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlci5kZXRlcm1pbmVTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGhhbmRsZXIgaW1wbGVtZW50cyBhIGRldGVybWluZVN0YXR1cyBmdW5jdGlvbi4gQXBwbHkgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmRldGVybWluZVN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBtb2R1bGVzIGRvd25sb2FkIHNpemUuIE9ubHkgdHJlYXQgdGhlIG1vZHVsZXMgd2l0aCBzdGF0dXMgbm90IGRvd25sb2FkZWQgb3Igb3V0ZGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUjZ2V0RG93bmxvYWRTaXplXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdFtdfSBtb2R1bGVzIExpc3Qgb2YgbW9kdWxlcy5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VpZCAgQ291cnNlIElEIHRoZSBtb2R1bGVzIGJlbG9uZyB0by5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBkb3dubG9hZCBzaXplLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXREb3dubG9hZFNpemUgPSBmdW5jdGlvbihtb2R1bGVzLCBjb3Vyc2VpZCkge1xuICAgICAgICAgICAgdmFyIHNpemUgPSAwLFxuICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGVzLCBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG51bGwgY29udGVudHMuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmNvbnRlbnRzID0gbW9kdWxlLmNvbnRlbnRzIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1vZHVsZSBoYXMgYSBwcmVmZXRjaCBoYW5kbGVyLlxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZW5hYmxlZEhhbmRsZXJzW21vZHVsZS5tb2RuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmlsZSB3aWxsIGJlIGRvd25sb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5nZXRNb2R1bGVTdGF0dXMobW9kdWxlLCBjb3Vyc2VpZCkudGhlbihmdW5jdGlvbihtb2RzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RzdGF0dXMgPT09IG1tQ29yZU5vdERvd25sb2FkZWQgfHwgbW9kc3RhdHVzID09PSBtbUNvcmVPdXRkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKGhhbmRsZXIuZ2V0RG93bmxvYWRTaXplKG1vZHVsZSwgY291cnNlaWQpKS50aGVuKGZ1bmN0aW9uKG1vZHVsZXNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzaXplIG9mIHRoZSBkb3dubG9hZGFibGUgZmlsZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSBzaXplICsgbW9kdWxlc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbW9kdWxlIHN0YXR1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSNnZXRNb2R1bGVTdGF0dXNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSAgICAgICAgIE1vZHVsZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkICAgICAgIENvdXJzZSBJRCB0aGUgbW9kdWxlIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmV2aXNpb25dICAgICBNb2R1bGUncyByZXZpc2lvbi4gSWYgbm90IGRlZmluZWQsIGl0IHdpbGwgYmUgY2FsY3VsYXRlZCB1c2luZyBtb2R1bGUgZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lbW9kaWZpZWRdIE1vZHVsZSdzIHRpbWVtb2RpZmllZC4gSWYgbm90IGRlZmluZWQsIGl0IHdpbGwgYmUgY2FsY3VsYXRlZCB1c2luZyBtb2R1bGUgZGF0YS5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgc3RhdHVzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRNb2R1bGVTdGF0dXMgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGVuYWJsZWRIYW5kbGVyc1ttb2R1bGUubW9kbmFtZV0sXG4gICAgICAgICAgICAgICAgc2l0ZWlkID0gJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICAgICAgbW9kdWxlLmNvbnRlbnRzID0gbW9kdWxlLmNvbnRlbnRzIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoYW5kbGVyIGRvZXNuJ3QgZGVmaW5lIGEgZnVuY3Rpb24gdG8gZ2V0IHRoZSBmaWxlcywgdXNlIG1vZHVsZS5jb250ZW50cy5cbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGhhbmRsZXIuZ2V0RmlsZXMgPyAkcS53aGVuKGhhbmRsZXIuZ2V0RmlsZXMobW9kdWxlLCBjb3Vyc2VpZCkpIDogJHEud2hlbihtb2R1bGUuY29udGVudHMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihmaWxlcykge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHsgLy8gTm8gZmlsZXMsIHRyZWF0IGlzIGFzIGRvd25sb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbihtbUNvcmVEb3dubG9hZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCByZXZpc2lvbiBhbmQgdGltZW1vZGlmaWVkIGlmIHRoZXkgYXJlbid0IGRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGhhbmRsZXIgZG9lc24ndCBkZWZpbmUgYSBmdW5jdGlvbiB0byBnZXQgdGhlbSwgZ2V0IHRoZW0gZnJvbSBmaWxlIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV2aXNpb24gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmdldFJldmlzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkcS53aGVuKGhhbmRsZXIuZ2V0UmV2aXNpb24obW9kdWxlLCBjb3Vyc2VpZCkpLnRoZW4oZnVuY3Rpb24ocmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmlzaW9uID0gcmV2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2aXNpb24gPSAkbW1GaWxlcG9vbC5nZXRSZXZpc2lvbkZyb21GaWxlTGlzdChmaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRpbWVtb2RpZmllZCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuZ2V0VGltZW1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkcS53aGVuKGhhbmRsZXIuZ2V0VGltZW1vZGlmaWVkKG1vZHVsZSwgY291cnNlaWQpKS50aGVuKGZ1bmN0aW9uKHRpbWVtb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gdGltZW1vZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChmaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm93IGdldCB0aGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmdldFBhY2thZ2VTdGF0dXMoc2l0ZWlkLCBoYW5kbGVyLmNvbXBvbmVudCwgbW9kdWxlLmlkLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5kZXRlcm1pbmVNb2R1bGVTdGF0dXMobW9kdWxlLCBzdGF0dXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgbGlzdCBvZiBtb2R1bGVzLCBhbG9uZyB3aXRoIHRoZSBsaXN0cyBvZiBtb2R1bGVzIGZvciBlYWNoIHN0YXR1cy5cbiAgICAgICAgICogQHNlZSB7QGxpbmsgJG1tRmlsZXBvb2wjZGV0ZXJtaW5lUGFja2FnZXNTdGF0dXN9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUjZ2V0TW9kdWxlc1N0YXR1c1xuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNlY3Rpb25pZCAgICAgICAgIElEIG9mIHRoZSBzZWN0aW9uIHRoZSBtb2R1bGVzIGJlbG9uZyB0by5cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0W119IG1vZHVsZXMgICAgICAgICBMaXN0IG9mIG1vZHVsZXMgdG8gcHJlZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlaWQgICAgICAgICAgQ291cnNlIElEIHRoZSBtb2R1bGVzIGJlbG9uZyB0by5cbiAgICAgICAgICogQHBhcmFtICB7Qm9vbGVhbn0gcmVmcmVzaCAgICAgICAgICBUcnVlIGlmIGl0IHNob3VsZCBhbHdheXMgY2hlY2sgdGhlIERCIChzbG93ZXIpLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlc3RvcmVEb3dubG9hZHMgIFRydWUgaWYgaXQgc2hvdWxkIHJlc3RvcmUgZG93bmxvYWRzLiBJdCdzIG9ubHkgdXNlZCBpZiByZWZyZXNoPWZhbHNlLFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHJlZnJlc2g9dHJ1ZSB0aGVuIGl0IGFsd2F5cyB0cmllcyB0byByZXN0b3JlIGRvd25sb2Fkcy5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBzdGF0dXMgKFN0cmluZykgU3RhdHVzIG9mIHRoZSBtb2R1bGUuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHRvdGFsIChOdW1iZXIpIE51bWJlciBvZiBtb2R1bGVzLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtbUNvcmVOb3REb3dubG9hZGVkIChPYmplY3RbXSkgTW9kdWxlcyB3aXRoIHN0YXRlIG1tQ29yZU5vdERvd25sb2FkZWQuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1tQ29yZURvd25sb2FkZWQgKE9iamVjdFtdKSBNb2R1bGVzIHdpdGggc3RhdGUgbW1Db3JlRG93bmxvYWRlZC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbW1Db3JlRG93bmxvYWRpbmcgKE9iamVjdFtdKSBNb2R1bGVzIHdpdGggc3RhdGUgbW1Db3JlRG93bmxvYWRpbmcuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1tQ29yZU91dGRhdGVkIChPYmplY3RbXSkgTW9kdWxlcyB3aXRoIHN0YXRlIG1tQ29yZU91dGRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRNb2R1bGVzU3RhdHVzID0gZnVuY3Rpb24oc2VjdGlvbmlkLCBtb2R1bGVzLCBjb3Vyc2VpZCwgcmVmcmVzaCwgcmVzdG9yZURvd25sb2Fkcykge1xuXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBtbUNvcmVOb3REb3dubG9hZGFibGUsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgICAgICAgIC8vIEluaXQgcmVzdWx0LlxuICAgICAgICAgICAgcmVzdWx0W21tQ29yZU5vdERvd25sb2FkZWRdID0gW107XG4gICAgICAgICAgICByZXN1bHRbbW1Db3JlRG93bmxvYWRlZF0gPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdFttbUNvcmVEb3dubG9hZGluZ10gPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdFttbUNvcmVPdXRkYXRlZF0gPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdC50b3RhbCA9IDA7XG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGVzLCBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbW9kdWxlIGhhcyBhIHByZWZldGNoIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBlbmFibGVkSGFuZGxlcnNbbW9kdWxlLm1vZG5hbWVdLFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlO1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbnVsbCBjb250ZW50cy5cbiAgICAgICAgICAgICAgICBtb2R1bGUuY29udGVudHMgPSBtb2R1bGUuY29udGVudHMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFja2FnZUlkID0gJG1tRmlsZXBvb2wuZ2V0UGFja2FnZUlkKGhhbmRsZXIuY29tcG9uZW50LCBtb2R1bGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZnJlc2ggJiYgc3RhdHVzQ2FjaGVbcGFja2FnZUlkXSAmJiBzdGF0dXNDYWNoZVtwYWNrYWdlSWRdLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oc2VsZi5kZXRlcm1pbmVNb2R1bGVTdGF0dXMobW9kdWxlLCBzdGF0dXNDYWNoZVtwYWNrYWdlSWRdLnN0YXR1cywgcmVzdG9yZURvd25sb2FkcykpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHNlbGYuZ2V0TW9kdWxlU3RhdHVzKG1vZHVsZSwgY291cnNlaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlLnRoZW4oZnVuY3Rpb24obW9kc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ2FjaGVbcGFja2FnZUlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IG1vZHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uaWQ6IHNlY3Rpb25pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICRtbUZpbGVwb29sLmRldGVybWluZVBhY2thZ2VzU3RhdHVzKHN0YXR1cywgbW9kc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFttb2RzdGF0dXNdLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC50b3RhbCsrO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHByZWZldGNoIGhhbmRsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUjZ2V0UHJlZmV0Y2hIYW5kbGVyRm9yXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYW5kbGVzIFRoZSBtb2R1bGUgdG8gd29yayBvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgUHJlZmV0Y2ggaGFuZGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0UHJlZmV0Y2hIYW5kbGVyRm9yID0gZnVuY3Rpb24oaGFuZGxlcykge1xuICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWRIYW5kbGVyc1toYW5kbGVzXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYSBsaXN0IG9mIG1vZHVsZXMgaXMgYmVpbmcgZG93bmxvYWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSNpc0JlaW5nRG93bmxvYWRlZFxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlkIEFuIElEIHRvIGlkZW50aWZ5IHRoZSBkb3dubG9hZC5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICBUcnVlIGlmIGl0J3MgYmVpbmcgZG93bmxvYWRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0JlaW5nRG93bmxvYWRlZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWRzWyRtbVNpdGUuZ2V0SWQoKV0gJiYgZGVmZXJyZWRzWyRtbVNpdGUuZ2V0SWQoKV1baWRdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmVmZXRjaGVzIGEgbGlzdCBvZiBtb2R1bGVzIHVzaW5nIHRoZWlyIHByZWZldGNoIGhhbmRsZXJzLlxuICAgICAgICAgKiBJZiBhIHByZWZldGNoIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHNpdGUgYW5kIGlkLCByZXR1cm5zIHRoZSBjdXJyZW50IHByb21pc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUjZ2V0UHJlZmV0Y2hIYW5kbGVyRm9yXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZWlkICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gaWQgICAgICAgIEFuIElEIHRvIGlkZW50aWZ5IHRoZSBkb3dubG9hZC4gSXQgY2FuIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIGRvd25sb2FkIHByb21pc2UuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdFtdfSBtb2R1bGVzIExpc3Qgb2YgbW9kdWxlcyB0byBwcmVmZXRjaC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VpZCAgQ291cnNlIElEIHRoZSBtb2R1bGVzIGJlbG9uZyB0by5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBtb2R1bGVzIGhhdmUgYmVlbiBwcmVmZXRjaGVkLiBOb3RpZnkgaXMgY2FsbGVkIGV2ZXJ5dGltZVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIG1vZHVsZSBpcyBwcmVmZXRjaGVkLCBwYXNzaW5nIHRoZSBtb2R1bGUgaWQgYXMgcGFyYW0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnByZWZldGNoQWxsID0gZnVuY3Rpb24oaWQsIG1vZHVsZXMsIGNvdXJzZWlkKSB7XG5cbiAgICAgICAgICAgIHZhciBzaXRlaWQgPSAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgICAgIGlmIChkZWZlcnJlZHNbc2l0ZWlkXSAmJiBkZWZlcnJlZHNbc2l0ZWlkXVtpZF0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSdzIGEgcHJlZmV0Y2ggb25nb2luZywgcmV0dXJuIHRoZSBjdXJyZW50IHByb21pc2UuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkc1tzaXRlaWRdW2lkXS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBkZWZlcnJlZC5cbiAgICAgICAgICAgIGlmICghZGVmZXJyZWRzW3NpdGVpZF0pIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZHNbc2l0ZWlkXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWRzW3NpdGVpZF1baWRdID0gZGVmZXJyZWQ7XG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGVzLCBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG51bGwgY29udGVudHMuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmNvbnRlbnRzID0gbW9kdWxlLmNvbnRlbnRzIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1vZHVsZSBoYXMgYSBwcmVmZXRjaCBoYW5kbGVyLlxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZW5hYmxlZEhhbmRsZXJzW21vZHVsZS5tb2RuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIucHJlZmV0Y2gobW9kdWxlLCBjb3Vyc2VpZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShtb2R1bGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGVmZXJyZWRzW3NpdGVpZF1baWRdOyAvLyBSZW1vdmUgZnJvbSBhcnJheSBiZWZvcmUgcmVzb2x2aW5nLlxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWZlcnJlZHNbc2l0ZWlkXVtpZF07IC8vIFJlbW92ZSBmcm9tIGFycmF5IGJlZm9yZSByZWplY3RpbmcuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgZW5hYmxlZCBoYW5kbGVycyBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSN1cGRhdGVQcmVmZXRjaEhhbmRsZXJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXMgVGhlIG1vZHVsZSB0aGlzIGhhbmRsZXIgaGFuZGxlcywgZS5nLiBmb3J1bSwgbGFiZWwuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVySW5mbyBUaGUgaGFuZGxlciBkZXRhaWxzLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGVuYWJsZWQsIHJlamVjdGVkIHdoZW4gbm90LlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnVwZGF0ZVByZWZldGNoSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXMsIGhhbmRsZXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVySW5mby5pbnN0YW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVySW5mby5pbnN0YW5jZSA9ICRtbVV0aWwucmVzb2x2ZU9iamVjdChoYW5kbGVySW5mby5oYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oaGFuZGxlckluZm8uaW5zdGFuY2UuaXNFbmFibGVkKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVja3MgaWYgdGhlIHByZWZldGNoIGlzIGVuYWJsZWQuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkSGFuZGxlcnNbaGFuZGxlc10gPSBoYW5kbGVySW5mby5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVuYWJsZWRIYW5kbGVyc1toYW5kbGVzXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlI3VwZGF0ZVByZWZldGNoSGFuZGxlcnNcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBkb25lLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnVwZGF0ZVByZWZldGNoSGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdVcGRhdGluZyBwcmVmZXRjaCBoYW5kbGVycyBmb3IgY3VycmVudCBzaXRlLicpO1xuXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgYWxsIHRoZSBwcmVmZXRjaCBoYW5kbGVycy5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChwcmVmZXRjaEhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVySW5mbywgaGFuZGxlcykge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi51cGRhdGVQcmVmZXRjaEhhbmRsZXIoaGFuZGxlcywgaGFuZGxlckluZm8pKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gTmV2ZXIgcmVqZWN0LlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgc3RhdHVzIG9mIGEgbW9kdWxlIGluIHRoZSBcImNhY2hlXCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUjdXBkYXRlU3RhdHVzQ2FjaGVcbiAgICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQ2FjaGUgPSBmdW5jdGlvbihjb21wb25lbnQsIGNvbXBvbmVudElkLCBzdGF0dXMpIHtcbiAgICAgICAgICAgIHZhciBub3RpZnkgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYWNrYWdlaWQgPSAkbW1GaWxlcG9vbC5nZXRQYWNrYWdlSWQoY29tcG9uZW50LCBjb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChzdGF0dXNDYWNoZVtwYWNrYWdlaWRdKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN0YXR1cyBoYXMgY2hhbmdlZCwgbm90aWZ5IHRoYXQgdGhlIHNlY3Rpb24gaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgbm90aWZ5ID0gc3RhdHVzQ2FjaGVbcGFja2FnZWlkXS5zdGF0dXMgIT09IHN0YXR1cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ2FjaGVbcGFja2FnZWlkXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdHVzQ2FjaGVbcGFja2FnZWlkXS5zdGF0dXMgPSBzdGF0dXM7XG5cbiAgICAgICAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbUNvcmVFdmVudFNlY3Rpb25TdGF0dXNDaGFuZ2VkLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25pZDogc3RhdHVzQ2FjaGVbcGFja2FnZWlkXS5zZWN0aW9uaWQsXG4gICAgICAgICAgICAgICAgICAgIHNpdGVpZDogJG1tU2l0ZS5nZXRJZCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIHNlbGY7XG59KVxuXG4ucnVuKGZ1bmN0aW9uKCRtbUV2ZW50cywgbW1Db3JlRXZlbnRMb2dpbiwgbW1Db3JlRXZlbnRTaXRlVXBkYXRlZCwgbW1Db3JlRXZlbnRMb2dvdXQsICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUsICRtbVNpdGUsXG4gICAgICAgICAgICBtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkKSB7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9naW4sICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUudXBkYXRlUHJlZmV0Y2hIYW5kbGVycyk7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUudXBkYXRlUHJlZmV0Y2hIYW5kbGVycyk7XG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9nb3V0LCAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLmNsZWFyU3RhdHVzQ2FjaGUpO1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnNpdGVpZCA9PT0gJG1tU2l0ZS5nZXRJZCgpKSB7XG4gICAgICAgICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLnVwZGF0ZVN0YXR1c0NhY2hlKGRhdGEuY29tcG9uZW50LCBkYXRhLmNvbXBvbmVudElkLCBkYXRhLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZXMnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIHRoZSBjb3Vyc2VzIGxpc3QuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbUNvdXJzZXNMaXN0Q3RybFxuICovXG4uY29udHJvbGxlcignbW1Db3Vyc2VzTGlzdEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRtbUNvdXJzZXMsICRtbUNvdXJzZXNEZWxlZ2F0ZSwgJG1tVXRpbCwgJG1tRXZlbnRzLCAkbW1TaXRlLFxuICAgICAgICAgICAgbW1Db3Vyc2VzRXZlbnRNeUNvdXJzZXNVcGRhdGVkKSB7XG5cbiAgICAkc2NvcGUuc2VhcmNoRW5hYmxlZCA9ICRtbUNvdXJzZXMuaXNTZWFyY2hDb3Vyc2VzQXZhaWxhYmxlKCk7XG4gICAgJHNjb3BlLmFyZU5hdkhhbmRsZXJzTG9hZGVkRm9yID0gJG1tQ291cnNlc0RlbGVnYXRlLmFyZU5hdkhhbmRsZXJzTG9hZGVkRm9yO1xuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZmV0Y2ggY291cnNlcy5cbiAgICBmdW5jdGlvbiBmZXRjaENvdXJzZXMocmVmcmVzaCkge1xuICAgICAgICByZXR1cm4gJG1tQ291cnNlcy5nZXRVc2VyQ291cnNlcygpLnRoZW4oZnVuY3Rpb24oY291cnNlcykge1xuICAgICAgICAgICAgJHNjb3BlLmNvdXJzZXMgPSBjb3Vyc2VzO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvdXJzZXMsIGZ1bmN0aW9uKGNvdXJzZSkge1xuICAgICAgICAgICAgICAgIGNvdXJzZS5faGFuZGxlcnMgPSAkbW1Db3Vyc2VzRGVsZWdhdGUuZ2V0TmF2SGFuZGxlcnNGb3IoY291cnNlLmlkLCByZWZyZXNoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHNjb3BlLmZpbHRlclRleHQgPSAnJzsgLy8gRmlsdGVyIHZhbHVlIE1VU1QgYmUgc2V0IGFmdGVyIGNvdXJzZXMgYXJlIHNob3duLlxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciAhPSAndW5kZWZpbmVkJyAmJiBlcnJvciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY291cnNlcy5lcnJvcmxvYWRjb3Vyc2VzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaENvdXJzZXMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuY291cnNlc0xvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUucmVmcmVzaENvdXJzZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tQ291cnNlcy5pbnZhbGlkYXRlVXNlckNvdXJzZXMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZmV0Y2hDb3Vyc2VzKHRydWUpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJG1tRXZlbnRzLm9uKG1tQ291cnNlc0V2ZW50TXlDb3Vyc2VzVXBkYXRlZCwgZnVuY3Rpb24oc2l0ZWlkKSB7XG4gICAgICAgIGlmIChzaXRlaWQgPT0gJG1tU2l0ZS5nZXRJZCgpKSB7XG4gICAgICAgICAgICBmZXRjaENvdXJzZXMoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlcycpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgc2VhcmNoIGNvdXJzZXMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbUNvdXJzZXNTZWFyY2hDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbUNvdXJzZXNTZWFyY2hDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkbW1Db3Vyc2VzLCAkcSwgJG1tVXRpbCkge1xuXG4gICAgdmFyIHBhZ2UgPSAwLFxuICAgIFx0Y3VycmVudFNlYXJjaCA9ICcnO1xuXG4gICAgJHNjb3BlLnNlYXJjaFRleHQgPSAnJztcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNlYXJjaCBjb3Vyc2VzLlxuICAgIGZ1bmN0aW9uIHNlYXJjaENvdXJzZXMocmVmcmVzaCkge1xuICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgcGFnZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tQ291cnNlcy5zZWFyY2goY3VycmVudFNlYXJjaCwgcGFnZSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHBhZ2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuY291cnNlcyA9IHJlc3BvbnNlLmNvdXJzZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5jb3Vyc2VzID0gJHNjb3BlLmNvdXJzZXMuY29uY2F0KHJlc3BvbnNlLmNvdXJzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLnRvdGFsID0gcmVzcG9uc2UudG90YWw7XG5cbiAgICAgICAgICAgIHBhZ2UrKztcbiAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9ICRzY29wZS5jb3Vyc2VzLmxlbmd0aCA8ICRzY29wZS50b3RhbDtcblxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAkc2NvcGUuY2FuTG9hZE1vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLnNlYXJjaGNvdXJzZXMuZXJyb3JzZWFyY2hpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgJHNjb3BlLnNlYXJjaCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgY3VycmVudFNlYXJjaCA9IHRleHQ7XG4gICAgICAgICRzY29wZS5jb3Vyc2VzID0gdW5kZWZpbmVkO1xuXG4gICAgXHR2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tLmNvcmUuc2VhcmNoaW5nJywgdHJ1ZSk7XG4gICAgXHRzZWFyY2hDb3Vyc2VzKHRydWUpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgXHR9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLmxvYWRNb3JlUmVzdWx0cyA9IGZ1bmN0aW9uKCkge1xuICAgIFx0c2VhcmNoQ291cnNlcygpO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2VzJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGhhbmRsZSB2aWV3IGEgY291cnNlIHRoYXQgd2FzIHNlYXJjaGVkLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1Db3Vyc2VzVmlld1Jlc3VsdEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tQ291cnNlc1ZpZXdSZXN1bHRDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbUNvdXJzZXMsICRtbUNvdXJzZXNEZWxlZ2F0ZSwgJG1tVXRpbCwgJHRyYW5zbGF0ZSwgJHEsXG4gICAgICAgICAgICAkaW9uaWNNb2RhbCwgJG1tRXZlbnRzLCAkbW1TaXRlLCBtbUNvdXJzZXNTZWFyY2hDb21wb25lbnQsIG1tQ291cnNlc0Vucm9sSW52YWxpZEtleSwgbW1Db3Vyc2VzRXZlbnRNeUNvdXJzZXNVcGRhdGVkKSB7XG5cbiAgICB2YXIgY291cnNlID0gJHN0YXRlUGFyYW1zLmNvdXJzZSB8fCB7fSxcbiAgICAgICAgc2VsZkVucm9sV1NBdmFpbGFibGUgPSAkbW1Db3Vyc2VzLmlzU2VsZkVucm9sbWVudEVuYWJsZWQoKSxcbiAgICAgICAgZ3Vlc3RXU0F2YWlsYWJsZSA9ICRtbUNvdXJzZXMuaXNHdWVzdFdTQXZhaWxhYmxlKCksXG4gICAgICAgIGlzR3Vlc3RFbmFibGVkID0gZmFsc2UsXG4gICAgICAgIGd1ZXN0SW5zdGFuY2VJZCxcbiAgICAgICAgaGFuZGxlcnNTaG91bGRCZVNob3duID0gdHJ1ZSxcbiAgICAgICAgZW5yb2xsbWVudE1ldGhvZHM7XG5cbiAgICAkc2NvcGUuY291cnNlID0gY291cnNlO1xuICAgICRzY29wZS50aXRsZSA9IGNvdXJzZS5mdWxsbmFtZTtcbiAgICAkc2NvcGUuY29tcG9uZW50ID0gbW1Db3Vyc2VzU2VhcmNoQ29tcG9uZW50O1xuICAgICRzY29wZS5zZWxmRW5yb2xJbnN0YW5jZXMgPSBbXTtcbiAgICAkc2NvcGUuZW5yb2xkYXRhID0ge1xuICAgICAgICBwYXNzd29yZDogJydcbiAgICB9O1xuXG4gICAgLy8gRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGhhbmRsZXJzIGFyZSBiZWluZyBsb2FkZWQuXG4gICAgJHNjb3BlLmxvYWRpbmdIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlcnNTaG91bGRCZVNob3duICYmICEkbW1Db3Vyc2VzRGVsZWdhdGUuYXJlTmF2SGFuZGxlcnNMb2FkZWRGb3IoY291cnNlLmlkKTtcbiAgICB9O1xuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IGNvdXJzZS4gV2UgdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIGEgdXNlciBjYW4gc2VlIHRoZSBjb3Vyc2Ugb3Igbm90LlxuICAgIGZ1bmN0aW9uIGdldENvdXJzZShyZWZyZXNoKSB7XG4gICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICBpZiAoc2VsZkVucm9sV1NBdmFpbGFibGUgfHwgZ3Vlc3RXU0F2YWlsYWJsZSkge1xuICAgICAgICAgICAgLy8gR2V0IGNvdXJzZSBlbnJvbG1lbnQgbWV0aG9kcy5cbiAgICAgICAgICAgICRzY29wZS5zZWxmRW5yb2xJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIHByb21pc2UgPSAkbW1Db3Vyc2VzLmdldENvdXJzZUVucm9sbWVudE1ldGhvZHMoY291cnNlLmlkKS50aGVuKGZ1bmN0aW9uKG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBlbnJvbGxtZW50TWV0aG9kcyA9IG1ldGhvZHM7XG5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW5yb2xsbWVudE1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZkVucm9sV1NBdmFpbGFibGUgJiYgbWV0aG9kLnR5cGUgPT09ICdzZWxmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGZFbnJvbEluc3RhbmNlcy5wdXNoKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3Vlc3RXU0F2YWlsYWJsZSAmJiBtZXRob2QudHlwZSA9PT0gJ2d1ZXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNHdWVzdEVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKCk7IC8vIE5vIG5lZWQgdG8gZ2V0IGVucm9sbWVudCBtZXRob2RzLlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgZW5yb2xsZWQgaW4gdGhlIGNvdXJzZS5cbiAgICAgICAgICAgIHJldHVybiAkbW1Db3Vyc2VzLmdldFVzZXJDb3Vyc2UoY291cnNlLmlkKS50aGVuKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaXNFbnJvbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBpcyBub3QgZW5yb2xsZWQgaW4gdGhlIGNvdXJzZS4gVXNlIGdldENvdXJzZXMgdG8gc2VlIGlmIGl0J3MgYW4gYWRtaW4vbWFuYWdlciBhbmQgY2FuIHNlZSB0aGUgY291cnNlLlxuICAgICAgICAgICAgICAgICRzY29wZS5pc0Vucm9sbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZXMuZ2V0Q291cnNlKGNvdXJzZS5pZCk7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzIHJldHJpZXZpbmcgdGhlIGNvdXJzZSwgd2UgY2FuIGFzc3VtZSB0aGUgdXNlciBoYXMgcGVybWlzc2lvbnMgdG8gdmlldyBpdC5cbiAgICAgICAgICAgICAgICBjb3Vyc2UuZnVsbG5hbWUgPSBjLmZ1bGxuYW1lIHx8IGNvdXJzZS5mdWxsbmFtZTtcbiAgICAgICAgICAgICAgICBjb3Vyc2Uuc3VtbWFyeSA9IGMuc3VtbWFyeSB8fCBjb3Vyc2Uuc3VtbWFyeTtcbiAgICAgICAgICAgICAgICBjb3Vyc2UuX2hhbmRsZXJzID0gJG1tQ291cnNlc0RlbGVnYXRlLmdldE5hdkhhbmRsZXJzRm9yKGNvdXJzZS5pZCwgcmVmcmVzaCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBpcyBub3QgYW4gYWRtaW4vbWFuYWdlci4gQ2hlY2sgaWYgd2UgY2FuIHByb3ZpZGUgZ3Vlc3QgYWNjZXNzIHRvIHRoZSBjb3Vyc2UuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbkFjY2Vzc0FzR3Vlc3QoKS50aGVuKGZ1bmN0aW9uKHBhc3N3b3JkUmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXNzd29yZFJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3Vyc2UuX2hhbmRsZXJzID0gJG1tQ291cnNlc0RlbGVnYXRlLmdldE5hdkhhbmRsZXJzRm9yR3Vlc3QoY291cnNlLmlkLCByZWZyZXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdXJzZS5faGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzU2hvdWxkQmVTaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdXJzZS5faGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNTaG91bGRCZVNob3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIHVzZXIgY2FuIGFjY2VzcyBhcyBndWVzdC5cbiAgICBmdW5jdGlvbiBjYW5BY2Nlc3NBc0d1ZXN0KCkge1xuICAgICAgICBpZiAoIWlzR3Vlc3RFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2VhcmNoIGluc3RhbmNlIElEIG9mIGd1ZXN0IGVucm9sbWVudCBtZXRob2QuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbnJvbGxtZW50TWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kLnR5cGUgPT0gJ2d1ZXN0Jykge1xuICAgICAgICAgICAgICAgIGd1ZXN0SW5zdGFuY2VJZCA9IG1ldGhvZC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGd1ZXN0SW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZXMuZ2V0Q291cnNlR3Vlc3RFbnJvbG1lbnRJbmZvKGd1ZXN0SW5zdGFuY2VJZCkudGhlbihmdW5jdGlvbihpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmZvLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYWN0aXZlLCByZWplY3QuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm8ucGFzc3dvcmRyZXF1aXJlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoRGF0YSgpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1Db3Vyc2VzLmludmFsaWRhdGVVc2VyQ291cnNlcygpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1Db3Vyc2VzLmludmFsaWRhdGVDb3Vyc2UoY291cnNlLmlkKSk7XG4gICAgICAgIHByb21pc2VzLnB1c2goJG1tQ291cnNlcy5pbnZhbGlkYXRlQ291cnNlRW5yb2xtZW50TWV0aG9kcyhjb3Vyc2UuaWQpKTtcbiAgICAgICAgaWYgKGd1ZXN0SW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1Db3Vyc2VzLmludmFsaWRhdGVDb3Vyc2VHdWVzdEVucm9sbWVudEluZm8oZ3Vlc3RJbnN0YW5jZUlkKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvdXJzZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0Q291cnNlKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmNvdXJzZUxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuZG9SZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZnJlc2hEYXRhKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoc2VsZkVucm9sV1NBdmFpbGFibGUgJiYgY291cnNlLmVucm9sbG1lbnRtZXRob2RzLmluZGV4T2YoJ3NlbGYnKSA+IC0xKSB7XG4gICAgICAgIC8vIFNldHVwIHBhc3N3b3JkIG1vZGFsIGZvciBzZWxmLWVucm9sbWVudC5cbiAgICAgICAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCdjb3JlL2NvbXBvbmVudHMvY291cnNlcy90ZW1wbGF0ZXMvcGFzc3dvcmQtbW9kYWwuaHRtbCcsIHtcbiAgICAgICAgICAgIHNjb3BlOiAkc2NvcGUsXG4gICAgICAgICAgICBhbmltYXRpb246ICdzbGlkZS1pbi11cCdcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihtb2RhbCkge1xuICAgICAgICAgICAgJHNjb3BlLm1vZGFsID0gbW9kYWw7XG5cbiAgICAgICAgICAgICRzY29wZS5jbG9zZU1vZGFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmVucm9sZGF0YS5wYXNzd29yZCA9ICcnO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSAkc2NvcGUuY3VycmVudEVucm9sSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgbW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2VsZi1lbnJvbCBhIHVzZXIgaW4gYSBjb3Vyc2UuXG4gICAgICAgICRzY29wZS5lbnJvbCA9IGZ1bmN0aW9uKGluc3RhbmNlSWQsIHBhc3N3b3JkKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICAgICAgaWYgKCRzY29wZS5tb2RhbC5pc1Nob3duKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzaG93IGNvbmZpcm0gaWYgcGFzc3dvcmQgaXMgc2hvd24sIHdlIGFscmVhZHkgc2hvd2VkIGl0IGJlZm9yZS5cbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJG1tVXRpbC5zaG93Q29uZmlybSgkdHJhbnNsYXRlKCdtbS5jb3Vyc2VzLmNvbmZpcm1zZWxmZW5yb2wnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tLmNvcmUubG9hZGluZycsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgJG1tQ291cnNlcy5zZWxmRW5yb2woY291cnNlLmlkLCBwYXNzd29yZCwgaW5zdGFuY2VJZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2UgbW9kYWwgYW5kIHJlZnJlc2ggZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlTW9kYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmlzRW5yb2xsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZWZyZXNoRGF0YSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNeSBjb3Vyc2VzIGhhdmUgYmVlbiB1cGRhdGVkLCB0cmlnZ2VyIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1Db3Vyc2VzRXZlbnRNeUNvdXJzZXNVcGRhdGVkLCAkbW1TaXRlLmdldElkKCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBtbUNvdXJzZXNFbnJvbEludmFsaWRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIHBhc3N3b3JkLiBJZiBwYXNzd29yZCB3YXMgYWxyZWFkeSBzaG93biwgc2hvdyBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGUubW9kYWwuaXNTaG93bigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmN1cnJlbnRFbnJvbEluc3RhbmNlID0gaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm1vZGFsLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY291cnNlcy5lcnJvcnNlbGZlbnJvbCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlcycpXG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgc2l0ZSBjb3Vyc2VzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQ291cnNlc1xuICovXG4uZmFjdG9yeSgnJG1tQ291cnNlcycsIGZ1bmN0aW9uKCRxLCAkbW1TaXRlLCAkbG9nLCAkbW1TaXRlc01hbmFnZXIsIG1tQ291cnNlc1NlYXJjaFBlclBhZ2UsIG1tQ291cnNlc0Vucm9sSW52YWxpZEtleSkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUNvdXJzZXMnKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGN1cnJlbnRDb3Vyc2VzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBERVBSRUNBVEVEOiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgICAqIENsZWFyIGN1cnJlbnQgY291cnNlcyBhcnJheS4gUmVzZXJ2ZWQgZm9yIGNvcmUgdXNlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5jbGVhckN1cnJlbnRDb3Vyc2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGN1cnJlbnRDb3Vyc2VzID0ge307XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjb3Vyc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzI2dldENvdXJzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAgICAgICBJRCBvZiB0aGUgY291cnNlIHRvIGdldC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVpZF0gU2l0ZSB0byBnZXQgdGhlIGNvdXJzZXMgZnJvbS4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgY291cnNlcyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Q291cnNlID0gZnVuY3Rpb24oaWQsIHNpdGVpZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRDb3Vyc2VzKFtpZF0sIHNpdGVpZCkudGhlbihmdW5jdGlvbihjb3Vyc2VzKSB7XG4gICAgICAgICAgICBpZiAoY291cnNlcyAmJiBjb3Vyc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZW5yb2xtZW50IG1ldGhvZHMgZnJvbSBhIGNvdXJzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjZ2V0Q291cnNlRW5yb2xtZW50TWV0aG9kc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBJRCBvZiB0aGUgY291cnNlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIG1ldGhvZHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldENvdXJzZUVucm9sbWVudE1ldGhvZHMgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkOiBpZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldENvdXJzZUVucm9sbWVudE1ldGhvZHNDYWNoZUtleShpZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnY29yZV9lbnJvbF9nZXRfY291cnNlX2Vucm9sbWVudF9tZXRob2RzJywgcGFyYW1zLCBwcmVTZXRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZ2V0IGNvdXJzZSBlbnJvbG1lbnQgbWV0aG9kcyBXUyBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBDb3Vyc2UgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q291cnNlRW5yb2xtZW50TWV0aG9kc0NhY2hlS2V5KGlkKSB7XG4gICAgICAgIHJldHVybiAnbW1Db3Vyc2VzOmVucm9sbWVudG1ldGhvZHM6JyArIGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbmZvIGZyb20gYSBjb3Vyc2UgZ3Vlc3QgZW5yb2xtZW50IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjZ2V0Q291cnNlR3Vlc3RFbnJvbG1lbnRJbmZvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlSWQgR3Vlc3QgaW5zdGFuY2UgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBpbmZvIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldENvdXJzZUd1ZXN0RW5yb2xtZW50SW5mbyA9IGZ1bmN0aW9uKGluc3RhbmNlSWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZWlkOiBpbnN0YW5jZUlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0Q291cnNlR3Vlc3RFbnJvbG1lbnRJbmZvQ2FjaGVLZXkoaW5zdGFuY2VJZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnZW5yb2xfZ3Vlc3RfZ2V0X2luc3RhbmNlX2luZm8nLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5pbnN0YW5jZWluZm87XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBnZXQgY291cnNlIGVucm9sbWVudCBtZXRob2RzIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VJZCBHdWVzdCBpbnN0YW5jZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q291cnNlR3Vlc3RFbnJvbG1lbnRJbmZvQ2FjaGVLZXkoaW5zdGFuY2VJZCkge1xuICAgICAgICByZXR1cm4gJ21tQ291cnNlczpndWVzdGluZm86JyArIGluc3RhbmNlSWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvdXJzZXMuXG4gICAgICogV2FybmluZzogaWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIHBlcm1pc3Npb25zIHRvIHZpZXcgc29tZSBvZiB0aGUgY291cnNlcyBwYXNzZWQgdGhlIFdTIGNhbGwgd2lsbCBmYWlsLlxuICAgICAqIFRoZSB1c2VyIG11c3QgYmUgYWJsZSB0byB2aWV3IEFMTCB0aGUgY291cnNlcyBwYXNzZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzI2dldENvdXJzZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBpZHMgICAgTGlzdCBvZiBJRHMgb2YgdGhlIGNvdXJzZXMgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZWlkXSBTaXRlIHRvIGdldCB0aGUgY291cnNlcyBmcm9tLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBjb3Vyc2VzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRDb3Vyc2VzID0gZnVuY3Rpb24oaWRzLCBzaXRlaWQpIHtcbiAgICAgICAgc2l0ZWlkID0gc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICBpZiAoIWFuZ3VsYXIuaXNBcnJheShpZHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHM6IGlkc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0Q291cnNlc0NhY2hlS2V5KGlkcylcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5yZWFkKCdjb3JlX2NvdXJzZV9nZXRfY291cnNlcycsIGRhdGEsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24oY291cnNlcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY291cnNlcyAhPSAnb2JqZWN0JyAmJiAhYW5ndWxhci5pc0FycmF5KGNvdXJzZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGdldCBjb3Vyc2VzIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJbXX0gaWRzIENvdXJzZXMgSURzLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENvdXJzZXNDYWNoZUtleShpZHMpIHtcbiAgICAgICAgcmV0dXJuICdtbUNvdXJzZXM6Y291cnNlOicgKyBKU09OLnN0cmluZ2lmeShpZHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFBsZWFzZSB1c2UgJG1tQ291cnNlcyNnZXRVc2VyQ291cnNlLlxuICAgICAqIEdldCBhIGNvdXJzZSBzdG9yZWQgaW4gbWVtb3J5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNnZXRTdG9yZWRDb3Vyc2VcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIElEIG9mIHRoZSBjb3Vyc2UgdG8gZ2V0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgQ291cnNlLlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41XG4gICAgICovXG4gICAgc2VsZi5nZXRTdG9yZWRDb3Vyc2UgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAkbG9nLndhcm4oJ1RoZSBmdW5jdGlvbiBcXCdnZXRTdG9yZWRDb3Vyc2VcXCcgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcXCdnZXRVc2VyQ291cnNlXFwnIGluc3RlYWQnKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb3Vyc2VzW2lkXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgY291cnNlIHRoZSB1c2VyIGlzIGVucm9sbGVkIGluLiBUaGlzIGZ1bmN0aW9uIHJlbGllcyBvbiAkbW1Db3Vyc2VzI2dldFVzZXJDb3Vyc2VzLlxuICAgICAqIHByZWZlckNhY2hlPXRydWUgd2lsbCB0cnkgdG8gc3BlZWQgdXAgdGhlIHJlc3BvbnNlLCBidXQgdGhlIGRhdGEgcmV0dXJuZWQgbWlnaHQgbm90IGJlIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzI2dldFVzZXJDb3Vyc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgICAgICAgICAgICAgICAgICAgSUQgb2YgdGhlIGNvdXJzZSB0byBnZXQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJlZmVyQ2FjaGU9ZmFsc2VdIFRydWUgaWYgc2hvdWxkbid0IGNhbGwgV1MgaWYgZGF0YSBpcyBjYWNoZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVpZF0gICAgICAgICAgICAgU2l0ZSB0byBnZXQgdGhlIGNvdXJzZXMgZnJvbS4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgY291cnNlLlxuICAgICAqIEBzaW5jZSAyLjVcbiAgICAgKi9cbiAgICBzZWxmLmdldFVzZXJDb3Vyc2UgPSBmdW5jdGlvbihpZCwgcHJlZmVyQ2FjaGUsIHNpdGVpZCkge1xuICAgICAgICBzaXRlaWQgPSBzaXRlaWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJlZmVyQ2FjaGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHByZWZlckNhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi5nZXRVc2VyQ291cnNlcyhwcmVmZXJDYWNoZSwgc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKGNvdXJzZXMpIHtcbiAgICAgICAgICAgIHZhciBjb3Vyc2U7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY291cnNlcywgZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgIGlmIChjLmlkID09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdXJzZSA9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY291cnNlID8gY291cnNlIDogJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBjb3Vyc2VzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNnZXRVc2VyQ291cnNlc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZWZlckNhY2hlPWZhbHNlXSBUcnVlIGlmIHNob3VsZG4ndCBjYWxsIFdTIGlmIGRhdGEgaXMgY2FjaGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlaWRdICAgICAgICAgICAgU2l0ZSB0byBnZXQgdGhlIGNvdXJzZXMgZnJvbS4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBjb3Vyc2VzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRVc2VyQ291cnNlcyA9IGZ1bmN0aW9uKHByZWZlckNhY2hlLCBzaXRlaWQpIHtcbiAgICAgICAgc2l0ZWlkID0gc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmZXJDYWNoZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcHJlZmVyQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlaWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuXG4gICAgICAgICAgICB2YXIgdXNlcmlkID0gc2l0ZS5nZXRVc2VySWQoKSxcbiAgICAgICAgICAgICAgICBwcmVzZXRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0VXNlckNvdXJzZXNDYWNoZUtleSgpLFxuICAgICAgICAgICAgICAgICAgICBvbWl0RXhwaXJlczogcHJlZmVyQ2FjaGVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRhdGEgPSB7dXNlcmlkOiB1c2VyaWR9O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzaXRlLnJlYWQoJ2NvcmVfZW5yb2xfZ2V0X3VzZXJzX2NvdXJzZXMnLCBkYXRhLCBwcmVzZXRzKS50aGVuKGZ1bmN0aW9uKGNvdXJzZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2l0ZWlkID09PSAkbW1TaXRlLmdldElkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdG9yZSBjb3Vyc2VzIGlmIHdlJ3JlIGdldHRpbmcgY3VycmVudCBzaXRlIGNvdXJzZXMuIFRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICBzdG9yZUNvdXJzZXNJbk1lbW9yeShjb3Vyc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGdldCB1c2VyIGNvdXJzZXMgV1MgY2FsbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFVzZXJDb3Vyc2VzQ2FjaGVLZXkoKSB7XG4gICAgICAgIHJldHVybiAnbW1Db3Vyc2VzOnVzZXJjb3Vyc2VzJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBnZXQgY291cnNlIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzI2ludmFsaWRhdGVDb3Vyc2VcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDb3Vyc2UgPSBmdW5jdGlvbihpZCwgc2l0ZWlkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmludmFsaWRhdGVDb3Vyc2VzKFtpZF0sIHNpdGVpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIGdldCBjb3Vyc2UgZW5yb2xtZW50IG1ldGhvZHMgV1MgY2FsbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjaW52YWxpZGF0ZVVzZXJDb3Vyc2VzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUNvdXJzZUVucm9sbWVudE1ldGhvZHMgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRDb3Vyc2VFbnJvbG1lbnRNZXRob2RzQ2FjaGVLZXkoaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgZ2V0IGNvdXJzZSBndWVzdCBlbnJvbG1lbnQgaW5mbyBXUyBjYWxsLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNpbnZhbGlkYXRlVXNlckNvdXJzZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VJZCBHdWVzdCBpbnN0YW5jZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQ291cnNlR3Vlc3RFbnJvbG1lbnRJbmZvID0gZnVuY3Rpb24oaW5zdGFuY2VJZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRDb3Vyc2VHdWVzdEVucm9sbWVudEluZm9DYWNoZUtleShpbnN0YW5jZUlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIGdldCBjb3Vyc2VzIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzI2ludmFsaWRhdGVDb3Vyc2VzXG4gICAgICogQHBhcmFtICB7TnVtYmVyW119IGlkcyAgIENvdXJzZXMgSURzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZWlkXSBTaXRlIElEIHRvIGludmFsaWRhdGUuIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQ291cnNlcyA9IGZ1bmN0aW9uKGlkcywgc2l0ZWlkKSB7XG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlaWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0Q291cnNlc0NhY2hlS2V5KGlkcykpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgZ2V0IHVzZXIgY291cnNlcyBXUyBjYWxsLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNpbnZhbGlkYXRlVXNlckNvdXJzZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVpZF0gU2l0ZSBJRCB0byBpbnZhbGlkYXRlLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZVVzZXJDb3Vyc2VzID0gZnVuY3Rpb24oc2l0ZWlkKSB7XG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlaWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0VXNlckNvdXJzZXNDYWNoZUtleSgpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIFdTIHRvIHJldHJpZXZlIGd1ZXN0IGVucm9sbWVudCBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjaXNHdWVzdFdTQXZhaWxhYmxlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBndWVzdCBXUyBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzR3Vlc3RXU0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53c0F2YWlsYWJsZSgnZW5yb2xfZ3Vlc3RfZ2V0X2luc3RhbmNlX2luZm8nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgc2VhcmNoIGNvdXJzZXMgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjaXNTZWFyY2hDb3Vyc2VzQXZhaWxhYmxlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzU2VhcmNoQ291cnNlc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53c0F2YWlsYWJsZSgnY29yZV9jb3Vyc2Vfc2VhcmNoX2NvdXJzZXMnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgc2VsZiBlbnJvbG1lbnQgaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tQ291cnNlcyNpc1NlbGZFbnJvbG1lbnRFbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBzZWxmIGVucm9sbWVudCBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzU2VsZkVucm9sbWVudEVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3NBdmFpbGFibGUoJ2Vucm9sX3NlbGZfZW5yb2xfdXNlcicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggY291cnNlcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjc2VhcmNoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgICAgICBUZXh0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhZ2VdICAgIFBhZ2UgdG8gZ2V0LiBEZWZhdWx0cyB0byAwLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGVycGFnZV0gTnVtYmVyIG9mIGNvdXJzZXMgcGVyIHBhZ2UuIERlZmF1bHRzIHRvIG1tQ291cnNlc1NlYXJjaFBlclBhZ2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGNvdXJzZXMgYW5kIHRoZSB0b3RhbCBvZiBtYXRjaGVzLlxuICAgICAqL1xuICAgIHNlbGYuc2VhcmNoID0gZnVuY3Rpb24odGV4dCwgcGFnZSwgcGVycGFnZSkge1xuICAgICAgICBwYWdlID0gcGFnZSB8fCAwO1xuICAgICAgICBwZXJwYWdlID0gcGVycGFnZSB8fCBtbUNvdXJzZXNTZWFyY2hQZXJQYWdlO1xuXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY3JpdGVyaWFuYW1lOiAnc2VhcmNoJyxcbiAgICAgICAgICAgICAgICBjcml0ZXJpYXZhbHVlOiB0ZXh0LFxuICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2UsXG4gICAgICAgICAgICAgICAgcGVycGFnZTogcGVycGFnZVxuICAgICAgICAgICAgfSwgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBnZXRGcm9tQ2FjaGU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ2NvcmVfY291cnNlX3NlYXJjaF9jb3Vyc2VzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0b3RhbDogcmVzcG9uc2UudG90YWwsIGNvdXJzZXM6IHJlc3BvbnNlLmNvdXJzZXN9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2VsZiBlbnJvbCBjdXJyZW50IHVzZXIgaW4gYSBjZXJ0YWluIGNvdXJzZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXMjc2VsZkVucm9sXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvdXJzZWlkICAgICBDb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXNzd29yZF0gICBQYXNzd29yZCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbnN0YW5jZUlkXSBFbnJvbCBpbnN0YW5jZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgaWYgdGhlIHVzZXIgaXMgZW5yb2xsZWQuIElmIHRoZSBwYXNzd29yZCBpcyBpbnZhbGlkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCBhbiBvYmplY3Qgd2l0aCBjb2RlID0gbW1Db3Vyc2VzRW5yb2xJbnZhbGlkS2V5LlxuICAgICAqL1xuICAgIHNlbGYuc2VsZkVucm9sID0gZnVuY3Rpb24oY291cnNlaWQsIHBhc3N3b3JkLCBpbnN0YW5jZUlkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBhc3N3b3JkID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgY291cnNlaWQ6IGNvdXJzZWlkLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICBwYXJhbXMuaW5zdGFuY2VpZCA9IGluc3RhbmNlSWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnZW5yb2xfc2VsZl9lbnJvbF91c2VyJywgcGFyYW1zKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uud2FybmluZ3MgJiYgcmVzcG9uc2Uud2FybmluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzcG9uc2Uud2FybmluZ3MsIGZ1bmN0aW9uKHdhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YXJuaW5nLndhcm5pbmdjb2RlID09ICcyJyB8fMKgd2FybmluZy53YXJuaW5nY29kZSA9PSAnNCcpIHsgLy8gSW52YWxpZCBwYXNzd29yZCB3YXJuaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gd2FybmluZy5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCh7Y29kZTogbW1Db3Vyc2VzRW5yb2xJbnZhbGlkS2V5LCBtZXNzYWdlOiBtZXNzYWdlfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBERVBSRUNBVEVEOiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgICAqIFN0b3JlcyBhIGxpc3Qgb2YgY291cnNlcyBpbiBtZW1vcnkgc28gdGhleSBjYW4gYmUgcmV0cmlldmVkIGxhdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IGNvdXJzZXMgQ291cnNlcyB0byBzdG9yZVxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yZUNvdXJzZXNJbk1lbW9yeShjb3Vyc2VzKSB7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb3Vyc2VzLCBmdW5jdGlvbihjb3Vyc2UpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDb3Vyc2VzW2NvdXJzZS5pZF0gPSBhbmd1bGFyLmNvcHkoY291cnNlKTsgLy8gU3RvcmUgYSBjb3B5IHRvIHByZXZlbnQgdW53YW50ZWQgbW9kaWZpY2F0aW9ucy5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5jb3Vyc2VzJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGludGVyYWN0IHdpdGggY291cnNlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUNvdXJzZXNEZWxlZ2F0ZVxuICovXG4ucHJvdmlkZXIoJyRtbUNvdXJzZXNEZWxlZ2F0ZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYXZIYW5kbGVycyA9IHt9LFxuICAgICAgICBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIG5hdmlnYXRpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXNEZWxlZ2F0ZSNyZWdpc3Rlck5hdkhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkb24gVGhlIGFkZG9uJ3MgbmFtZSAobW1hTGFiZWwsIG1tYUZvcnVtLCAuLi4pXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEZ1bmN0aW9ufSBoYW5kbGVyIE11c3QgYmUgcmVzb2x2ZWQgdG8gYW4gb2JqZWN0IGRlZmluaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zLiBPciB0byBhIGZ1bmN0aW9uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5pbmcgYW4gb2JqZWN0IGRlZmluaW5nIHRoZXNlIGZ1bmN0aW9ucy4gU2VlIHtAbGluayAkbW1VdGlsI3Jlc29sdmVPYmplY3R9LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGlzRW5hYmxlZCAoQm9vbGVhbnxQcm9taXNlKSBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIG9uIGEgc2l0ZSBsZXZlbC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiB1c2luZyBhIHByb21pc2UsIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGlzRW5hYmxlZEZvckNvdXJzZShjb3Vyc2VpZCwgYWNjZXNzRGF0YSkgKEJvb2xlYW58UHJvbWlzZSkgV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZCBvbiBhIGNvdXJzZSBsZXZlbC4gV2hlbiB1c2luZyBhIHByb21pc2UsIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGdldENvbnRyb2xsZXIoY291cnNlaWQpIChPYmplY3QpIFJldHVybnMgdGhlIG9iamVjdCB0aGF0IHdpbGwgYWN0IGFzIGNvbnRyb2xsZXIuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGNvcmUvY29tcG9uZW50cy9jb3Vyc2VzL3RlbXBsYXRlcy9saXN0Lmh0bWxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlIGxpc3Qgb2Ygc2NvcGUgdmFyaWFibGVzIGV4cGVjdGVkLlxuICAgICAqL1xuICAgIHNlbGYucmVnaXN0ZXJOYXZIYW5kbGVyID0gZnVuY3Rpb24oYWRkb24sIGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmF2SGFuZGxlcnNbYWRkb25dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIkbW1Db3Vyc2VzRGVsZWdhdGVQcm92aWRlcjogQWRkb24gJ1wiICsgbmF2SGFuZGxlcnNbYWRkb25dLmFkZG9uICsgXCInIGFscmVhZHkgcmVnaXN0ZXJlZCBhcyBuYXZpZ2F0aW9uIGhhbmRsZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCIkbW1Db3Vyc2VzRGVsZWdhdGVQcm92aWRlcjogUmVnaXN0ZXJlZCBhZGRvbiAnXCIgKyBhZGRvbiArIFwiJyBhcyBuYXZpZ2F0aW9uIGhhbmRsZXIuXCIpO1xuICAgICAgICBuYXZIYW5kbGVyc1thZGRvbl0gPSB7XG4gICAgICAgICAgICBhZGRvbjogYWRkb24sXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2VsZi4kZ2V0ID0gZnVuY3Rpb24oJG1tVXRpbCwgJHEsICRsb2csICRtbVNpdGUsIG1tQ291cnNlc0FjY2Vzc01ldGhvZHMpIHtcbiAgICAgICAgdmFyIGVuYWJsZWROYXZIYW5kbGVycyA9IHt9LFxuICAgICAgICAgICAgY291cnNlc0hhbmRsZXJzID0ge30sXG4gICAgICAgICAgICBzZWxmID0ge30sXG4gICAgICAgICAgICBsb2FkZWQgPSB7fTtcblxuICAgICAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tQ291cnNlc0RlbGVnYXRlJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGFkZG9ucyBhcmUgbG9hZGVkIGZvciBhIGNlcnRhaW4gY291cnNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbUNvdXJzZXNEZWxlZ2F0ZSNhcmVOYXZIYW5kbGVyc0xvYWRlZEZvclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBhZGRvbnMgYXJlIGxvYWRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5hcmVOYXZIYW5kbGVyc0xvYWRlZEZvciA9IGZ1bmN0aW9uKGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVkW2NvdXJzZUlkXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgYWxsIGNvdXJzZXMgaGFuZGxlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlc0RlbGVnYXRlI2NsZWFyQ291cnNlc0hhbmRsZXJzXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuY2xlYXJDb3Vyc2VzSGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvdXJzZXNIYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgbG9hZGVkID0ge307XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaGFuZGxlciBmb3IgYSBjb3Vyc2UgdXNpbmcgYSBjZXJ0YWluIGFjY2VzcyB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgICAgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSByZWZyZXNoICAgIFRydWUgaWYgaXQgc2hvdWxkIHJlZnJlc2ggdGhlIGxpc3QuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gYWNjZXNzRGF0YSBBY2Nlc3MgdHlwZSBhbmQgZGF0YS4gRGVmYXVsdCwgZ3Vlc3QsIC4uLlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nICdwcmlvcml0eScgYW5kICdjb250cm9sbGVyJy5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldE5hdkhhbmRsZXJzRm9yQWNjZXNzKGNvdXJzZUlkLCByZWZyZXNoLCBhY2Nlc3NEYXRhKSB7XG4gICAgICAgICAgICBpZiAocmVmcmVzaCB8fMKgIWNvdXJzZXNIYW5kbGVyc1tjb3Vyc2VJZF0gfHwgY291cnNlc0hhbmRsZXJzW2NvdXJzZUlkXS5hY2Nlc3MudHlwZSAhPSBhY2Nlc3NEYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VzSGFuZGxlcnNbY291cnNlSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3M6IGFjY2Vzc0RhdGEsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVOYXZIYW5kbGVyc0ZvckNvdXJzZShjb3Vyc2VJZCwgYWNjZXNzRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY291cnNlc0hhbmRsZXJzW2NvdXJzZUlkXS5oYW5kbGVycztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGhhbmRsZXJzIGZvciBhIGNvdXJzZSB3aGVyZSB0aGUgdXNlciBpcyBlbnJvbGxlZCBpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzRGVsZWdhdGUjZ2V0TmF2SGFuZGxlcnNGb3JcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIFRoZSBjb3Vyc2UgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVmcmVzaCBUcnVlIGlmIGl0IHNob3VsZCByZWZyZXNoIHRoZSBsaXN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nICdwcmlvcml0eScgYW5kICdjb250cm9sbGVyJy5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0TmF2SGFuZGxlcnNGb3IgPSBmdW5jdGlvbihjb3Vyc2VJZCwgcmVmcmVzaCkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBhY2Nlc3MuXG4gICAgICAgICAgICB2YXIgYWNjZXNzRGF0YSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBtbUNvdXJzZXNBY2Nlc3NNZXRob2RzLmRlZmF1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZ2V0TmF2SGFuZGxlcnNGb3JBY2Nlc3MoY291cnNlSWQsIHJlZnJlc2gsIGFjY2Vzc0RhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGhhbmRsZXJzIGZvciBhIGNvdXJzZSBhcyBndWVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLmNvdXJzZXNcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1Db3Vyc2VzRGVsZWdhdGUjZ2V0TmF2SGFuZGxlcnNGb3JHdWVzdFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSByZWZyZXNoIFRydWUgaWYgaXQgc2hvdWxkIHJlZnJlc2ggdGhlIGxpc3QuXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBBcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgJ3ByaW9yaXR5JyBhbmQgJ2NvbnRyb2xsZXInLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXROYXZIYW5kbGVyc0Zvckd1ZXN0ID0gZnVuY3Rpb24oY291cnNlSWQsIHJlZnJlc2gpIHtcbiAgICAgICAgICAgIC8vIEd1ZXN0IGFjY2Vzcy5cbiAgICAgICAgICAgIHZhciBhY2Nlc3NEYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG1tQ291cnNlc0FjY2Vzc01ldGhvZHMuZ3Vlc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZ2V0TmF2SGFuZGxlcnNGb3JBY2Nlc3MoY291cnNlSWQsIHJlZnJlc2gsIGFjY2Vzc0RhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGhhbmRsZXIgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlc0RlbGVnYXRlI3VwZGF0ZU5hdkhhbmRsZXJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGFkZG9uIFRoZSBhZGRvbi5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJJbmZvIFRoZSBoYW5kbGVyIGRldGFpbHMuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gZW5hYmxlZCwgcmVqZWN0ZWQgd2hlbiBub3QuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYudXBkYXRlTmF2SGFuZGxlciA9IGZ1bmN0aW9uKGFkZG9uLCBoYW5kbGVySW5mbykge1xuICAgICAgICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlckluZm8uaW5zdGFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlckluZm8uaW5zdGFuY2UgPSAkbW1VdGlsLnJlc29sdmVPYmplY3QoaGFuZGxlckluZm8uaGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKGhhbmRsZXJJbmZvLmluc3RhbmNlLmlzRW5hYmxlZCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBjb250ZW50IGlzIGVuYWJsZWQuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkTmF2SGFuZGxlcnNbYWRkb25dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGhhbmRsZXJJbmZvLmluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IGhhbmRsZXJJbmZvLnByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbmFibGVkTmF2SGFuZGxlcnNbYWRkb25dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgaGFuZGxlcnMgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlc0RlbGVnYXRlI3VwZGF0ZU5hdkhhbmRsZXJzXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gZG9uZS5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi51cGRhdGVOYXZIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1VwZGF0aW5nIG5hdmlnYXRpb24gaGFuZGxlcnMgZm9yIGN1cnJlbnQgc2l0ZS4nKTtcblxuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIGFsbCB0aGUgY29udGVudCBoYW5kbGVycy5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChuYXZIYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlckluZm8sIGFkZG9uKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLnVwZGF0ZU5hdkhhbmRsZXIoYWRkb24sIGhhbmRsZXJJbmZvKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE5ldmVyIHJlamVjdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGhhbmRsZXJzIGZvciBhbGwgY291cnNlcy5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY291cnNlc0hhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZU5hdkhhbmRsZXJzRm9yQ291cnNlKHBhcnNlSW50KGNvdXJzZUlkKSwgaGFuZGxlci5hY2Nlc3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgaGFuZGxlcnMgZm9yIGEgY2VydGFpbiBjb3Vyc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tQ291cnNlc0RlbGVnYXRlI3VwZGF0ZU5hdkhhbmRsZXJzRm9yQ291cnNlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCAgICBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGFjY2Vzc0RhdGEgQWNjZXNzIHR5cGUgYW5kIGRhdGEuIERlZmF1bHQsIGd1ZXN0LCAuLi5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFJlc29sdmVkIHdoZW4gdXBkYXRlZC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi51cGRhdGVOYXZIYW5kbGVyc0ZvckNvdXJzZSA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBhY2Nlc3NEYXRhKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBlbmFibGVkRm9yQ291cnNlID0gW107XG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbmFibGVkTmF2SGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSAkcS53aGVuKGhhbmRsZXIuaW5zdGFuY2UuaXNFbmFibGVkRm9yQ291cnNlKGNvdXJzZUlkLCBhY2Nlc3NEYXRhKSkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkRm9yQ291cnNlLnB1c2goaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkbyBoZXJlLCBpdCBpcyBub3QgZW5hYmxlZCBmb3IgdGhpcyB1c2VyLlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE5ldmVyIGZhaWxzLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvdXJzZXNIYW5kbGVycyBhcnJheSB3aXRoIHRoZSBuZXcgZW5hYmxlZCBhZGRvbnMuXG4gICAgICAgICAgICAgICAgJG1tVXRpbC5lbXB0eUFycmF5KGNvdXJzZXNIYW5kbGVyc1tjb3Vyc2VJZF0uaGFuZGxlcnMpO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbmFibGVkRm9yQ291cnNlLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdXJzZXNIYW5kbGVyc1tjb3Vyc2VJZF0uaGFuZGxlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBoYW5kbGVyLmluc3RhbmNlLmdldENvbnRyb2xsZXIoY291cnNlSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IGhhbmRsZXIucHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9hZGVkW2NvdXJzZUlkXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLmNvdXJzZXMnKVxuXG4vKipcbiAqIENvdXJzZXMgaGFuZGxlcnMgZmFjdG9yeS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuY291cnNlc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbUNvdXJzZXNIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tQ291cnNlc0hhbmRsZXJzJywgZnVuY3Rpb24oJG1tU2l0ZSwgJHN0YXRlLCAkbW1Db3Vyc2VzLCAkcSwgJG1tVXRpbCwgJHRyYW5zbGF0ZSwgJHRpbWVvdXQsICRtbUNvbnRlbnRMaW5rc0hlbHBlcixcbiAgICAgICAgICAgIG1tQ291cnNlc0Vucm9sSW52YWxpZEtleSkge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5jb3Vyc2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUNvdXJzZXNIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdGlvbiB0byBwZXJmb3JtIHdoZW4gYW4gZW5yb2wgbGluayBpcyBjbGlja2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmwgICAgICBUcmVhdGVkIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGFjdGlvbkVucm9sKGNvdXJzZUlkLCB1cmwpIHtcbiAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGVucm9sbGVkIGluIHRoZSBjb3Vyc2UuXG4gICAgICAgICAgICAkbW1Db3Vyc2VzLmdldFVzZXJDb3Vyc2UoY291cnNlSWQpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgaXMgbm90IGVucm9sbGVkIGluIHRoZSBjb3Vyc2UuIENoZWNrIGlmIGNhbiBzZWxmIGVucm9sLlxuICAgICAgICAgICAgICAgIHJldHVybiBjYW5TZWxmRW5yb2woY291cnNlSWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGZFbnJvbChjb3Vyc2VJZCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yLiBTaG93IGVycm9yIG1lc3NhZ2UgYW5kIGFsbG93IHRoZSB1c2VyIHRvIG9wZW4gdGhlIGxpbmsgaW4gYnJvd3Nlci5cbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY291cnNlcy5ub3RlbnJvbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9ICR0cmFuc2xhdGUoJ21tLmNvcmUudHdvcGFyYWdyYXBocycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cDE6IGVycm9yLCBwMjogJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLmNvbmZpcm1vcGVuaW5icm93c2VyJyl9KTtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93Q29uZmlybShib2R5KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5vcGVuSW5Ccm93c2VyKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW1fY291cnNlJywge2NvdXJzZWlkOiBwYXJzZUludChjb3Vyc2VJZCl9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGEgdXNlciBjYW4gYmUgXCJhdXRvbWF0aWNhbGx5XCIgc2VsZiBlbnJvbGxlZCBpbiBhIGNvdXJzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCBpZiB1c2VyIGlzIGNhbiBiZSBlbnJvbGxlZCBpbiBhIGNvdXJzZSwgcmVqZWN0ZWQgb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY2FuU2VsZkVucm9sKGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzZWxmIGVucm9sbWVudCBpcyBlbmFibGVkLlxuICAgICAgICAgICAgaWYgKCEkbW1Db3Vyc2VzLmlzU2VsZkVucm9sbWVudEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgY291cnNlIGhhcyBzZWxmIGVucm9sbWVudCBlbmFibGVkLlxuICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZXMuZ2V0Q291cnNlRW5yb2xtZW50TWV0aG9kcyhjb3Vyc2VJZCkudGhlbihmdW5jdGlvbihtZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU2VsZkVucm9sRW5hYmxlZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXMgPSAwO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZC50eXBlID09ICdzZWxmJyAmJiBtZXRob2Quc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlbGZFbnJvbEVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghaXNTZWxmRW5yb2xFbmFibGVkIHx8IGluc3RhbmNlcyAhPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGYgZW5yb2wgbm90IGVuYWJsZWQgb3IgbW9yZSB0aGFuIG9uZSBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyeSB0byBzZWxmIGVucm9sIGEgdXNlciBpbiBhIGNvdXJzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGFzc3dvcmQgUGFzc3dvcmQuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZXIgZXNvbHZlZCB3aGVuIHRoZSB1c2VyIGlzIGVucm9sbGVkLCByZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzZWxmRW5yb2woY291cnNlSWQsIHBhc3N3b3JkKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiAkbW1Db3Vyc2VzLnNlbGZFbnJvbChjb3Vyc2VJZCwgcGFzc3dvcmQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2VzcyBzZWxmIGVucm9sbGluZyB0aGUgdXNlciwgaW52YWxpZGF0ZSB0aGUgY291cnNlcyBsaXN0LlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db3Vyc2VzLmludmFsaWRhdGVVc2VyQ291cnNlcygpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzLlxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgaWYgd2UgZ2V0IHRoZSBjb3Vyc2UgbGlzdCByaWdodCBhZnRlciBzZWxmIGVucm9sbGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3b24ndCByZXRyaWV2ZSB0aGUgbmV3IGNvdXJzZS4gTGV0J3MgZGVsYXkgaXQgYSBiaXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGltZW91dChmdW5jdGlvbigpIHt9LCA0MDAwKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09IG1tQ291cnNlc0Vucm9sSW52YWxpZEtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIHBhc3N3b3JkLiBBbGxvdyB0aGUgdXNlciB0byBpbnB1dCBwYXNzd29yZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3Vyc2VzLnNlbGZlbnJvbG1lbnQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSAnICcsIC8vIEVtcHR5IG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlciA9ICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY291cnNlcy5wYXNzd29yZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGF0dGVtcHRlZCBhIHBhc3N3b3JkLiBTaG93IGFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbVV0aWwuc2hvd1Byb21wdChib2R5LCB0aXRsZSwgcGxhY2Vob2xkZXIpLnRoZW4oZnVuY3Rpb24ocGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmRW5yb2woY291cnNlSWQsIHBhc3N3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgTGlzdCBvZiBhY3Rpb25zLiBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgY291cnNlIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignZW5yb2wvaW5kZXgucGhwJykgPiAtMcKgfHzCoHVybC5pbmRleE9mKCdjb3Vyc2UvZW5yb2wucGhwJykgPiAtMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLmluZGV4T2YoJ2NvdXJzZS92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gJG1tVXRpbC5leHRyYWN0VXJsUGFyYW1zKHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuaWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ21tLmNvcmUudmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWV5ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXRlczogc2l0ZUlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l0ZUlkID09ICRtbVNpdGUuZ2V0SWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25FbnJvbChwYXJzZUludChwYXJhbXMuaWQsIDEwKSwgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db250ZW50TGlua3NIZWxwZXIuZ29JblNpdGUoJ3NpdGUubW1fY291cnNlJywge2NvdXJzZWlkOiBwYXJzZUludChwYXJhbXMuaWQsIDEwKX0sIHNpdGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUubG9naW4nKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIGlucHV0IG9mIHVzZXIgY3JlZGVudGlhbHMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmxvZ2luXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1Mb2dpbkNyZWRlbnRpYWxzQ3RybFxuICovXG4uY29udHJvbGxlcignbW1Mb2dpbkNyZWRlbnRpYWxzQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlLCAkc3RhdGVQYXJhbXMsICRtbVNpdGVzTWFuYWdlciwgJG1tVXRpbCwgJGlvbmljSGlzdG9yeSwgJG1tQXBwLFxuICAgICAgICAgICAgJHEsICRtbUxvZ2luSGVscGVyLCAkdHJhbnNsYXRlKSB7XG5cbiAgICAkc2NvcGUuc2l0ZXVybCA9ICRzdGF0ZVBhcmFtcy5zaXRldXJsO1xuICAgICRzY29wZS5jcmVkZW50aWFscyA9IHt9O1xuXG4gICAgdmFyIHNpdGVDaGVja2VkID0gZmFsc2U7XG5cbiAgICAvLyBGdW5jdGlvbiB0byBjaGVjayBpZiBhIHNpdGUgdXNlcyBsb2NhbF9tb2JpbGUsIHJlcXVpcmVzIFNTTyBsb2dpbiwgZXRjLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIHVzZWQgb25seSBpZiBhIGZpeGVkIFVSTCBpcyBzZXQsIG90aGVyd2lzZSB0aGlzIGNoZWNrIGlzIGFscmVhZHkgcGVyZm9ybWVkIGluIG1tTG9naW5TaXRlQ3RybC5cbiAgICBmdW5jdGlvbiBjaGVja1NpdGUoc2l0ZXVybCkge1xuICAgICAgICB2YXIgY2hlY2ttb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygpO1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmNoZWNrU2l0ZShzaXRldXJsKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuXG4gICAgICAgICAgICBzaXRlQ2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAkc2NvcGUuc2l0ZXVybCA9IHJlc3VsdC5zaXRldXJsO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC53YXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChyZXN1bHQud2FybmluZywgdHJ1ZSwgNDAwMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkbW1Mb2dpbkhlbHBlci5pc1NTT0xvZ2luTmVlZGVkKHJlc3VsdC5jb2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNTTy4gVXNlciBuZWVkcyB0byBhdXRoZW50aWNhdGUgaW4gYSBicm93c2VyLlxuICAgICAgICAgICAgICAgICRzY29wZS5pc0Jyb3dzZXJTU08gPSB0cnVlO1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSgnbW0ubG9naW4ubG9naW5pbnNpdGVyZXF1aXJlZCcpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkbW1Mb2dpbkhlbHBlci5vcGVuQnJvd3NlckZvclNTT0xvZ2luKHJlc3VsdC5zaXRldXJsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmlzQnJvd3NlclNTTyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNoZWNrbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoJG1tTG9naW5IZWxwZXIuaXNGaXhlZFVybFNldCgpKSB7XG4gICAgICAgIC8vIEZpeGVkIFVSTCwgd2UgbmVlZCB0byBjaGVjayBpZiBpdCB1c2VzIGJyb3dzZXIgU1NPIGxvZ2luLlxuICAgICAgICBjaGVja1NpdGUoJHNjb3BlLnNpdGV1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpdGVDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAkc2NvcGUubG9naW4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAkbW1BcHAuY2xvc2VLZXlib2FyZCgpO1xuXG4gICAgICAgIC8vIEdldCBpbnB1dCBkYXRhLlxuICAgICAgICB2YXIgc2l0ZXVybCA9ICRzY29wZS5zaXRldXJsLFxuICAgICAgICAgICAgdXNlcm5hbWUgPSAkc2NvcGUuY3JlZGVudGlhbHMudXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZCA9ICRzY29wZS5jcmVkZW50aWFscy5wYXNzd29yZDtcblxuICAgICAgICBpZiAoIXNpdGVDaGVja2VkKSB7XG4gICAgICAgICAgICAvLyBTaXRlIHdhc24ndCBjaGVja2VkIChpdCBmYWlsZWQpLCBsZXQncyBjaGVjayBhZ2Fpbi5cbiAgICAgICAgICAgIHJldHVybiBjaGVja1NpdGUoc2l0ZXVybCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoISRzY29wZS5pc0Jyb3dzZXJTU08pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2l0ZSBkb2Vzbid0IHVzZSBicm93c2VyIFNTTywgdGhyb3cgYXBwJ3MgbG9naW4gYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkc2NvcGUubG9naW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgkc2NvcGUuaXNCcm93c2VyU1NPKSB7XG4gICAgICAgICAgICAvLyBBIHByZXZpb3VzIGNoZWNrIGRldGVybWluZWQgdGhhdCBicm93c2VyIFNTTyBpcyBuZWVkZWQuIExldCdzIGNoZWNrIGFnYWluLCBtYXliZSBzaXRlIHdhcyB1cGRhdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrU2l0ZShzaXRldXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXNlcm5hbWUpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmxvZ2luLnVzZXJuYW1lcmVxdWlyZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhc3N3b3JkKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5sb2dpbi5wYXNzd29yZHJlcXVpcmVkJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoKTtcblxuICAgICAgICAvLyBTdGFydCB0aGUgYXV0aGVudGljYXRpb24gcHJvY2Vzcy5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRVc2VyVG9rZW4oc2l0ZXVybCwgdXNlcm5hbWUsIHBhc3N3b3JkKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIubmV3U2l0ZShkYXRhLnNpdGV1cmwsIGRhdGEudG9rZW4pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlICRzY29wZS5jcmVkZW50aWFsczsgLy8gRGVsZXRlIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBmcm9tIHRoZSBzY29wZS5cbiAgICAgICAgICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7ZGlzYWJsZUJhY2s6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW1fY291cnNlcycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUubG9naW4nKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIHNwbGFzaCBzY3JlZW4gYW5kIGluaXRpYWxpemUgdGhlIGFwcCAocmVzdG9yZSBzZXNzaW9uLCBkZXRlcm1pbmUgZmlyc3Qgc3RhdGUsIGV0Yy4pLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5sb2dpblxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tTG9naW5Jbml0Q3RybFxuICovXG4uY29udHJvbGxlcignbW1Mb2dpbkluaXRDdHJsJywgZnVuY3Rpb24oJGxvZywgJGlvbmljSGlzdG9yeSwgJHN0YXRlLCAkbW1TaXRlc01hbmFnZXIsICRtbVNpdGUsICRtbUFwcCwgJG1tTG9naW5IZWxwZXIpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbUxvZ2luSW5pdEN0cmwnKTtcblxuICAgICRtbUFwcC5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gRGlzYWJsZSBhbmltYXRpb24gYW5kIGJhY2sgYnV0dG9uIGZvciB0aGUgbmV4dCB0cmFuc2l0aW9uLlxuICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7XG4gICAgICAgICAgICBkaXNhYmxlQW5pbWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVCYWNrOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1tX2NvdXJzZXMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5oYXNTaXRlcygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS5nbygnbW1fbG9naW4uc2l0ZXMnKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Mb2dpbkhlbHBlci5nb1RvQWRkU2l0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUubG9naW4nKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIGlucHV0IG9mIHVzZXIgY3JlZGVudGlhbHMuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLmxvZ2luXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1Mb2dpblJlY29ubmVjdEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tTG9naW5SZWNvbm5lY3RDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsICRzdGF0ZVBhcmFtcywgJG1tU2l0ZXNNYW5hZ2VyLCAkbW1BcHAsICRtbVV0aWwsICRpb25pY0hpc3RvcnkpIHtcblxuICAgIHZhciBpbmZvc2l0ZXVybCA9ICRzdGF0ZVBhcmFtcy5pbmZvc2l0ZXVybDsgLy8gU2l0ZXVybCBpbiBzaXRlIGluZm8uIEl0IG1pZ2h0IGJlIGRpZmZlcmVudCB0aGFuIHNpdGV1cmwgKGh0dHAvaHR0cHMpLlxuICAgICRzY29wZS5zaXRldXJsID0gJHN0YXRlUGFyYW1zLnNpdGV1cmw7XG4gICAgJHNjb3BlLmNyZWRlbnRpYWxzID0ge1xuICAgICAgICB1c2VybmFtZTogJHN0YXRlUGFyYW1zLnVzZXJuYW1lLFxuICAgICAgICBwYXNzd29yZDogJydcbiAgICB9O1xuXG4gICAgJHNjb3BlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1TaXRlc01hbmFnZXIubG9nb3V0KCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlQW5pbWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlQmFjazogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc3RhdGUuZ28oJ21tX2xvZ2luLnNpdGVzJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUubG9naW4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAkbW1BcHAuY2xvc2VLZXlib2FyZCgpO1xuXG4gICAgICAgIC8vIEdldCBpbnB1dCBkYXRhLlxuICAgICAgICB2YXIgc2l0ZXVybCA9ICRzY29wZS5zaXRldXJsLFxuICAgICAgICAgICAgdXNlcm5hbWUgPSAkc2NvcGUuY3JlZGVudGlhbHMudXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZCA9ICRzY29wZS5jcmVkZW50aWFscy5wYXNzd29yZDtcblxuICAgICAgICBpZiAoIXBhc3N3b3JkKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5sb2dpbi5wYXNzd29yZHJlcXVpcmVkJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoKTtcblxuICAgICAgICAvLyBTdGFydCB0aGUgYXV0aGVudGljYXRpb24gcHJvY2Vzcy5cbiAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmdldFVzZXJUb2tlbihzaXRldXJsLCB1c2VybmFtZSwgcGFzc3dvcmQpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLnVwZGF0ZVNpdGVUb2tlbihpbmZvc2l0ZXVybCwgdXNlcm5hbWUsIGRhdGEudG9rZW4pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHNpdGUgaW5mbyB0b28gYmVjYXVzZSBmdW5jdGlvbnMgbWlnaHQgaGF2ZSBjaGFuZ2VkIChlLmcuIHVuaXNudGFsbCBsb2NhbF9tb2JpbGUpLlxuICAgICAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci51cGRhdGVTaXRlSW5mb0J5VXJsKGluZm9zaXRldXJsLCB1c2VybmFtZSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlICRzY29wZS5jcmVkZW50aWFsczsgLy8gRGVsZXRlIHBhc3N3b3JkIGZyb20gdGhlIHNjb3BlLlxuICAgICAgICAgICAgICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7ZGlzYWJsZUJhY2s6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1tX2NvdXJzZXMnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gU2l0ZSBkZWxldGVkPyBHbyBiYWNrIHRvIGxvZ2luIHBhZ2UuXG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0ubG9naW4uZXJyb3J1cGRhdGVzaXRlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5sb2dpbicpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgdGhlIGlucHV0IG9mIGEgc2l0ZSBVUkwgYW5kIGl0cyB2YWxpZGF0aW9uLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5sb2dpblxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tTG9naW5TaXRlQ3RybFxuICovXG4uY29udHJvbGxlcignbW1Mb2dpblNpdGVDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsICRtbVNpdGVzTWFuYWdlciwgJG1tVXRpbCwgJHRyYW5zbGF0ZSwgJGlvbmljSGlzdG9yeSwgJG1tQXBwLFxuICAgICAgICAkaW9uaWNNb2RhbCwgJG1tTG9naW5IZWxwZXIpIHtcblxuICAgICRzY29wZS5zaXRldXJsID0gJyc7XG4gICAgJHNjb3BlLmlzSW52YWxpZFVybCA9IHRydWU7XG5cbiAgICAkc2NvcGUudmFsaWRhdGUgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICRzY29wZS5pc0ludmFsaWRVcmwgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRtbVNpdGVzTWFuYWdlci5nZXREZW1vU2l0ZURhdGEodXJsKSkge1xuICAgICAgICAgICAgLy8gSXMgZGVtbyBzaXRlLlxuICAgICAgICAgICAgJHNjb3BlLmlzSW52YWxpZFVybCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZm9ybWF0VVJMIGFkZHMgdGhlIHByb3RvY29sIGlmIGlzIG1pc3NpbmcuXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkdXJsID0gJG1tVXRpbC5mb3JtYXRVUkwodXJsKTtcbiAgICAgICAgICAgICRzY29wZS5pc0ludmFsaWRVcmwgPSBmb3JtYXR0ZWR1cmwuaW5kZXhPZignOi8vbG9jYWxob3N0JykgPT0gLTEgJiYgISRtbVV0aWwuaXNWYWxpZFVSTChmb3JtYXR0ZWR1cmwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICRzY29wZS5jb25uZWN0ID0gZnVuY3Rpb24odXJsKSB7XG5cbiAgICAgICAgJG1tQXBwLmNsb3NlS2V5Ym9hcmQoKTtcblxuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0ubG9naW4uc2l0ZXVybHJlcXVpcmVkJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoKSxcbiAgICAgICAgICAgIHNpdGVkYXRhID0gJG1tU2l0ZXNNYW5hZ2VyLmdldERlbW9TaXRlRGF0YSh1cmwpO1xuXG4gICAgICAgIGlmIChzaXRlZGF0YSkge1xuICAgICAgICAgICAgLy8gSXQncyBhIGRlbW8gc2l0ZS5cbiAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5nZXRVc2VyVG9rZW4oc2l0ZWRhdGEudXJsLCBzaXRlZGF0YS51c2VybmFtZSwgc2l0ZWRhdGEucGFzc3dvcmQpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5uZXdTaXRlKGRhdGEuc2l0ZXVybCwgZGF0YS50b2tlbikudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe2Rpc2FibGVCYWNrOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tbV9jb3Vyc2VzJyk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm90IGEgZGVtbyBzaXRlLlxuICAgICAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLmNoZWNrU2l0ZSh1cmwpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lndhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChyZXN1bHQud2FybmluZywgdHJ1ZSwgNDAwMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCRtbUxvZ2luSGVscGVyLmlzU1NPTG9naW5OZWVkZWQocmVzdWx0LmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNTTy4gVXNlciBuZWVkcyB0byBhdXRoZW50aWNhdGUgaW4gYSBicm93c2VyLlxuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dDb25maXJtKCR0cmFuc2xhdGUoJ21tLmxvZ2luLmxvZ2luaW5zaXRlcmVxdWlyZWQnKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbUxvZ2luSGVscGVyLm9wZW5Ccm93c2VyRm9yU1NPTG9naW4ocmVzdWx0LnNpdGV1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ21tX2xvZ2luLmNyZWRlbnRpYWxzJywge3NpdGV1cmw6IHJlc3VsdC5zaXRldXJsfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBHZXQgZG9jcyBVUkwgZm9yIGhlbHAgbW9kYWwuXG4gICAgJG1tVXRpbC5nZXREb2NzVXJsKCkudGhlbihmdW5jdGlvbihkb2NzdXJsKSB7XG4gICAgICAgICRzY29wZS5kb2NzdXJsID0gZG9jc3VybDtcbiAgICB9KTtcblxuICAgIC8vIFNldHVwIGhlbHAgbW9kYWwuXG4gICAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCdjb3JlL2NvbXBvbmVudHMvbG9naW4vdGVtcGxhdGVzL2hlbHAtbW9kYWwuaHRtbCcsIHtcbiAgICAgICAgc2NvcGU6ICRzY29wZSxcbiAgICAgICAgYW5pbWF0aW9uOiAnc2xpZGUtaW4tdXAnXG4gICAgfSkudGhlbihmdW5jdGlvbihoZWxwTW9kYWwpIHtcbiAgICAgICAgJHNjb3BlLnNob3dIZWxwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoZWxwTW9kYWwuc2hvdygpO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuY2xvc2VIZWxwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoZWxwTW9kYWwuaGlkZSgpO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaGVscE1vZGFsLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUubG9naW4nKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIHRoZSBsaXN0IG9mIHNpdGVzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5sb2dpblxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tTG9naW5TaXRlc0N0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tTG9naW5TaXRlc0N0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCAkbG9nLCAkdHJhbnNsYXRlLCAkbW1VdGlsLCAkaW9uaWNIaXN0b3J5LCAkbW1UZXh0LFxuICAgICAgICAgICAgJG1tTG9naW5IZWxwZXIpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbUxvZ2luU2l0ZXNDdHJsJyk7XG5cbiAgICAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZXMoKS50aGVuKGZ1bmN0aW9uKHNpdGVzKSB7XG4gICAgICAgICRzY29wZS5zaXRlcyA9IHNpdGVzO1xuICAgICAgICAkc2NvcGUuZGF0YSA9IHtcbiAgICAgICAgICAgIGhhc1NpdGVzOiBzaXRlcy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgc2hvd0RlbGV0ZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgICRzY29wZS50b2dnbGVEZWxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmRhdGEuc2hvd0RlbGV0ZSA9ICEkc2NvcGUuZGF0YS5zaG93RGVsZXRlO1xuICAgIH07XG5cbiAgICAkc2NvcGUub25JdGVtRGVsZXRlID0gZnVuY3Rpb24oZSwgaW5kZXgpIHtcbiAgICAgICAgLy8gUHJldmVudCBsb2dpbigpIGZyb20gYmVpbmcgdHJpZ2dlcmVkLiBObyBpZGVhIHdoeSBJIGNhbm5vdCByZXBsaWNhdGUgdGhpc1xuICAgICAgICAvLyBwcm9ibGVtIG9uIGh0dHA6Ly9jb2RlcGVuLmlvL2lvbmljL3Blbi9Kc0hqZi5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB2YXIgc2l0ZSA9ICRzY29wZS5zaXRlc1tpbmRleF0sXG4gICAgICAgICAgICBzaXRlbmFtZSA9IHNpdGUuc2l0ZW5hbWU7XG5cbiAgICAgICAgJG1tVGV4dC5mb3JtYXRUZXh0KHNpdGVuYW1lKS50aGVuKGZ1bmN0aW9uKHNpdGVuYW1lKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dDb25maXJtKCR0cmFuc2xhdGUoJ21tLmxvZ2luLmNvbmZpcm1kZWxldGVzaXRlJywge3NpdGVuYW1lOiBzaXRlbmFtZX0pKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5kZWxldGVTaXRlKHNpdGUuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zaXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAkbW1TaXRlc01hbmFnZXIuaGFzTm9TaXRlcygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBzaXRlcyBsZWZ0LCBnbyB0byBhZGQgYSBuZXcgc2l0ZSBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtkaXNhYmxlQmFjazogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tTG9naW5IZWxwZXIuZ29Ub0FkZFNpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0RlbGV0ZSBzaXRlIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5sb2dpbi5lcnJvcmRlbGV0ZXNpdGUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLmxvZ2luID0gZnVuY3Rpb24oc2l0ZWlkKSB7XG4gICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygpO1xuXG4gICAgICAgICRtbVNpdGVzTWFuYWdlci5sb2FkU2l0ZShzaXRlaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7ZGlzYWJsZUJhY2s6IHRydWV9KTtcbiAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tbV9jb3Vyc2VzJyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciBsb2FkaW5nIHNpdGUgJytzaXRlaWQpO1xuICAgICAgICAgICAgZXJyb3IgPSBlcnJvciB8fCAnRXJyb3IgbG9hZGluZyBzaXRlLic7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5hZGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tTG9naW5IZWxwZXIuZ29Ub0FkZFNpdGUoKTtcbiAgICB9O1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5sb2dpbicpXG5cbi5jb25zdGFudCgnbW1Mb2dpblNTT0NvZGUnLCAyKSAvLyBUaGlzIGNvZGUgaXMgcmV0dXJuZWQgYnkgbG9jYWxfbW9iaWxlIE1vb2RsZSBwbHVnaW4gaWYgU1NPIGluIGJyb3dzZXIgaXMgcmVxdWlyZWQuXG4uY29uc3RhbnQoJ21tTG9naW5MYXVuY2hTaXRlVVJMJywgJ21tTG9naW5MYXVuY2hTaXRlVVJMJylcbi5jb25zdGFudCgnbW1Mb2dpbkxhdW5jaFBhc3Nwb3J0JywgJ21tTG9naW5MYXVuY2hQYXNzcG9ydCcpXG5cbi8qKlxuICogU2VydmljZSB0byBwcm92aWRlIHNvbWUgaGVscGVyIGZ1bmN0aW9uYWxpdGllcyBmb3IgdGhlIGxvZ2luIGNvbXBvbmVudC5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUubG9naW5cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1Mb2dpbkhlbHBlclxuICovXG4uZmFjdG9yeSgnJG1tTG9naW5IZWxwZXInLCBmdW5jdGlvbigkcSwgJGxvZywgJG1tQ29uZmlnLCBtbUxvZ2luU1NPQ29kZSwgbW1Mb2dpbkxhdW5jaFNpdGVVUkwsIG1tTG9naW5MYXVuY2hQYXNzcG9ydCxcbiAgICAgICAgICAgIG1kNSwgJG1tU2l0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCAkbW1MYW5nLCAkbW1VdGlsLCAkc3RhdGUsIG1tQ29yZUNvbmZpZ0NvbnN0YW50cykge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbUxvZ2luSGVscGVyJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogR28gdG8gdGhlIHZpZXcgdG8gYWRkIGEgbmV3IHNpdGUuXG4gICAgICogSWYgYSBmaXhlZCBVUkwgaXMgY29uZmlndXJlZCwgZ28gdG8gY3JlZGVudGlhbHMgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5sb2dpblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Mb2dpbkhlbHBlciNnb1RvQWRkU2l0ZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgc3RhdGUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBzZWxmLmdvVG9BZGRTaXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChtbUNvcmVDb25maWdDb25zdGFudHMuc2l0ZXVybCkge1xuICAgICAgICAgICAgLy8gRml4ZWQgVVJMIGlzIHNldCwgZ28gdG8gY3JlZGVudGlhbHMgcGFnZS5cbiAgICAgICAgICAgIHJldHVybiAkc3RhdGUuZ28oJ21tX2xvZ2luLmNyZWRlbnRpYWxzJywge3NpdGV1cmw6IG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5zaXRldXJsfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHN0YXRlLmdvKCdtbV9sb2dpbi5zaXRlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGFwcCBpcyBjb25maWd1cmVkIHRvIHVzZSBhIGZpeGVkIFVSTC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5sb2dpblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Mb2dpbkhlbHBlciNpc0ZpeGVkVXJsU2V0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBzZXQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzRml4ZWRVcmxTZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtbUNvcmVDb25maWdDb25zdGFudHMuc2l0ZXVybCAhPSAndW5kZWZpbmVkJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgU1NPIGxvZ2luIGlzIG5lZWRlZCBiYXNlZCBvbiBjb2RlIHJldHVybmVkIGJ5IHRoZSBXUy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS5sb2dpblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Mb2dpbkhlbHBlciNpc1NTT0xvZ2luTmVlZGVkXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgY29kZSBDb2RlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgVHJ1ZSBpZiBTU08gbG9naW4gaXMgbmVlZGVkLCBmYWxzZSBvdGh3ZXJpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1NTT0xvZ2luTmVlZGVkID0gZnVuY3Rpb24oY29kZSkge1xuICAgICAgICByZXR1cm4gY29kZSA9PSBtbUxvZ2luU1NPQ29kZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3BlbiBhIGJyb3dzZXIgdG8gcGVyZm9ybSBTU08gbG9naW4uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUubG9naW5cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tTG9naW5IZWxwZXIjb3BlbkJyb3dzZXJGb3JTU09Mb2dpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRldXJsIFVSTCBvZiB0aGUgc2l0ZSB3aGVyZSB0aGUgU1NPIGxvZ2luIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgICAqL1xuICAgIHNlbGYub3BlbkJyb3dzZXJGb3JTU09Mb2dpbiA9IGZ1bmN0aW9uKHNpdGV1cmwpIHtcbiAgICAgICAgdmFyIHBhc3Nwb3J0ID0gTWF0aC5yYW5kb20oKSAqIDEwMDA7XG4gICAgICAgIHZhciBsb2dpbnVybCA9IHNpdGV1cmwgKyBcIi9sb2NhbC9tb2JpbGUvbGF1bmNoLnBocD9zZXJ2aWNlPVwiICsgbW1Db3JlQ29uZmlnQ29uc3RhbnRzLndzZXh0c2VydmljZTtcbiAgICAgICAgbG9naW51cmwgKz0gXCImcGFzc3BvcnQ9XCIgKyBwYXNzcG9ydDtcblxuICAgICAgICAvLyBTdG9yZSB0aGUgc2l0ZXVybCBhbmQgcGFzc3BvcnQgaW4gJG1tQ29uZmlnIGZvciBwZXJzaXN0ZW5jZS4gV2UgYXJlIFwiY29uZmlndXJpbmdcIlxuICAgICAgICAvLyB0aGUgYXBwIHRvIHdhaXQgZm9yIGFuIFNTTy4gJG1tQ29uZmlnIHNob3VsZG4ndCBiZSB1c2VkIGFzIGEgdGVtcG9yYXJ5IHN0b3JhZ2UuXG4gICAgICAgICRtbUNvbmZpZy5zZXQobW1Mb2dpbkxhdW5jaFNpdGVVUkwsIHNpdGV1cmwpO1xuICAgICAgICAkbW1Db25maWcuc2V0KG1tTG9naW5MYXVuY2hQYXNzcG9ydCwgcGFzc3BvcnQpO1xuXG4gICAgICAgICRtbVV0aWwub3BlbkluQnJvd3Nlcihsb2dpbnVybCk7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IuYXBwKSB7XG4gICAgICAgICAgICBuYXZpZ2F0b3IuYXBwLmV4aXRBcHAoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW50IGhlbHBlciB0byB2YWxpZGF0ZSBhIGJyb3dzZXIgU1NPIGxvZ2luLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmxvZ2luXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvZ2luSGVscGVyI3ZhbGlkYXRlQnJvd3NlclNTT0xvZ2luXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgcmVjZWl2ZWQsIHRvIGJlIHZhbGlkYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgIFRoZSBzdWNjZXNzIGNvbnRhaW5zIHRoZSBzaWduYXR1cmUgYW5kIHRva2VuLiBUaGUgcmVqZWN0IGNvbnRhaW5zIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIHNlbGYudmFsaWRhdGVCcm93c2VyU1NPTG9naW4gPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgLy8gU3BsaXQgc2lnbmF0dXJlOjo6dG9rZW5cbiAgICAgICAgdmFyIHBhcmFtcyA9IHVybC5zcGxpdChcIjo6OlwiKTtcblxuICAgICAgICByZXR1cm4gJG1tQ29uZmlnLmdldChtbUxvZ2luTGF1bmNoU2l0ZVVSTCkudGhlbihmdW5jdGlvbihsYXVuY2hTaXRlVVJMKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tQ29uZmlnLmdldChtbUxvZ2luTGF1bmNoUGFzc3BvcnQpLnRoZW4oZnVuY3Rpb24ocGFzc3BvcnQpIHtcblxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRlbXBvcmFyeSB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgJG1tQ29uZmlnLmRlbGV0ZShtbUxvZ2luTGF1bmNoU2l0ZVVSTCk7XG4gICAgICAgICAgICAgICAgJG1tQ29uZmlnLmRlbGV0ZShtbUxvZ2luTGF1bmNoUGFzc3BvcnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNpZ25hdHVyZS5cbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGJvdGggaHR0cCBhbmQgaHR0cHMuXG4gICAgICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IG1kNS5jcmVhdGVIYXNoKGxhdW5jaFNpdGVVUkwgKyBwYXNzcG9ydCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSAhPSBwYXJhbXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhdW5jaFNpdGVVUkwuaW5kZXhPZihcImh0dHBzOi8vXCIpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXVuY2hTaXRlVVJMID0gbGF1bmNoU2l0ZVVSTC5yZXBsYWNlKFwiaHR0cHM6Ly9cIiwgXCJodHRwOi8vXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF1bmNoU2l0ZVVSTCA9IGxhdW5jaFNpdGVVUkwucmVwbGFjZShcImh0dHA6Ly9cIiwgXCJodHRwczovL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBtZDUuY3JlYXRlSGFzaChsYXVuY2hTaXRlVVJMICsgcGFzc3BvcnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmUgPT0gcGFyYW1zWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1NpZ25hdHVyZSB2YWxpZGF0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2l0ZXVybDogbGF1bmNoU2l0ZVVSTCwgdG9rZW46IHBhcmFtc1sxXSB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0luYWxpZCBzaWduYXR1cmUgaW4gdGhlIFVSTCByZXF1ZXN0IHlvdXJzOiAnICsgcGFyYW1zWzBdICsgJyBtaW5lOiAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHNpZ25hdHVyZSArICcgZm9yIHBhc3Nwb3J0ICcgKyBwYXNzcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0uY29yZS51bmV4cGVjdGVkZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVudCBoZWxwZXIgdG8gaGFuZGxlIGF1dGhlbnRpY2F0aW9uIGluIHRoZSBhcHAgdXNpbmcgYSB0b2tlbiByZWNlaXZlZCBieSBTU08gbG9naW4uIElmIGl0J3MgYSBuZXcgYWNjb3VudCxcbiAgICAgKiB0aGUgc2l0ZSBpcyBzdG9yZWQgYW5kIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWQuIElmIHRoZSBhY2NvdW50IGFscmVhZHkgZXhpc3RzLCB1cGRhdGUgaXRzIHRva2VuLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLmxvZ2luXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbUxvZ2luSGVscGVyI2hhbmRsZVNTT0xvZ2luQXV0aGVudGljYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZXVybCBTaXRlJ3MgVVJMLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiAgIFVzZXIncyB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHVzZXIgaXMgYXV0aGVudGljYXRlZCB3aXRoIHRoZSB0b2tlbi4gUmVqZWN0IHJldHVybnMgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBzZWxmLmhhbmRsZVNTT0xvZ2luQXV0aGVudGljYXRpb24gPSBmdW5jdGlvbihzaXRldXJsLCB0b2tlbikge1xuICAgICAgICBpZiAoJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIC8vIFVzZXIgbG9nZ2VkIGluLCBoZSBpcyByZWNvbm5lY3RpbmcuXG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSB1c2VybmFtZS5cbiAgICAgICAgICAgIHZhciBpbmZvID0gJG1tU2l0ZS5nZXRJbmZvKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGluZm8pICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YoaW5mby51c2VybmFtZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgJG1tU2l0ZXNNYW5hZ2VyLnVwZGF0ZVNpdGVUb2tlbihpbmZvLnNpdGV1cmwsIGluZm8udXNlcm5hbWUsIHRva2VuKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkbW1TaXRlc01hbmFnZXIudXBkYXRlU2l0ZUluZm9CeVVybChpbmZvLnNpdGV1cmwsIGluZm8udXNlcm5hbWUpLmZpbmFsbHkoZGVmZXJyZWQucmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIHVwZGF0aW5nIHRva2VuLCByZXR1cm4gcHJvcGVyIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsICdtbS5sb2dpbi5lcnJvcnVwZGF0ZXNpdGUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgJ21tLmxvZ2luLmVycm9ydXBkYXRlc2l0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLm5ld1NpdGUoc2l0ZXVybCwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuc2V0dGluZ3MnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIHRoZSBhcHAgJ0Fib3V0JyBzZWN0aW9uIGluIHNldHRpbmdzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5zZXR0aW5nc1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tU2V0dGluZ3NBYm91dEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tU2V0dGluZ3NBYm91dEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICR0cmFuc2xhdGUsICR3aW5kb3csICRtbUFwcCwgJGlvbmljUGxhdGZvcm0sICRtbUxhbmcsICRtbUZTLFxuICAgICAgICAgICAgJG1tTG9jYWxOb3RpZmljYXRpb25zLCBtbUNvcmVDb25maWdDb25zdGFudHMpIHtcblxuICAgICRzY29wZS52ZXJzaW9ubmFtZSA9IG1tQ29yZUNvbmZpZ0NvbnN0YW50cy52ZXJzaW9ubmFtZTtcbiAgICAkdHJhbnNsYXRlKCdtbS5zZXR0aW5ncy5hcHBuYW1lJywge3ZlcnNpb246ICRzY29wZS52ZXJzaW9ubmFtZX0pLnRoZW4oZnVuY3Rpb24oYXBwTmFtZSkge1xuICAgICAgICAkc2NvcGUuYXBwbmFtZSA9IGFwcE5hbWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUudmVyc2lvbmNvZGUgPSBtbUNvcmVDb25maWdDb25zdGFudHMudmVyc2lvbmNvZGU7XG5cbiAgICAkc2NvcGUubmF2aWdhdG9yID0gJHdpbmRvdy5uYXZpZ2F0b3I7XG4gICAgaWYgKCR3aW5kb3cubG9jYXRpb24gJiYgJHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICAgIHZhciB1cmwgPSAkd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgICRzY29wZS5sb2NhdGlvbmhyZWYgPSB1cmwuc3Vic3RyKDAsIHVybC5pbmRleE9mKCcjL3NpdGUvJykpO1xuICAgIH1cblxuICAgICRzY29wZS5hcHByZWFkeSA9ICRtbUFwcC5pc1JlYWR5KCkgPyAnbW0uY29yZS55ZXMnIDogJ21tLmNvcmUubm8nO1xuICAgICRzY29wZS5kZXZpY2V0eXBlID0gJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSA/ICdtbS5jb3JlLnRhYmxldCcgOiAnbW0uY29yZS5waG9uZSc7XG5cbiAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgJHNjb3BlLmRldmljZW9zID0gJ21tLmNvcmUuYW5kcm9pZCc7XG4gICAgfSBlbHNlIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICAgICRzY29wZS5kZXZpY2VvcyA9ICdtbS5jb3JlLmlvcyc7XG4gICAgfSBlbHNlIGlmIChpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICRzY29wZS5kZXZpY2VvcyA9ICdtbS5jb3JlLndpbmRvd3NwaG9uZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9cXCgoW15cXCldKilcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGV2aWNlb3MgPSBtYXRjaGVzWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLmRldmljZW9zID0gJ21tLmNvcmUudW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkbW1MYW5nLmdldEN1cnJlbnRMYW5ndWFnZSgpLnRoZW4oZnVuY3Rpb24obGFuZykge1xuICAgICAgICAkc2NvcGUuY3VycmVudGxhbmd1YWdlID0gbGFuZztcbiAgICB9KTtcblxuICAgICRzY29wZS5uZXR3b3Jrc3RhdHVzID0gJG1tQXBwLmlzT25saW5lKCkgPyAnbW0uY29yZS5vbmxpbmUnIDogJ21tLmNvcmUub2ZmbGluZSc7XG4gICAgJHNjb3BlLndpZmljb25uZWN0aW9uID0gJG1tQXBwLmlzTmV0d29ya0FjY2Vzc0xpbWl0ZWQoKSA/ICdtbS5jb3JlLm5vJyA6ICdtbS5jb3JlLnllcyc7XG4gICAgJHNjb3BlLmRldmljZXdlYndvcmtlcnMgPSAhIXdpbmRvdy5Xb3JrZXIgJiYgISF3aW5kb3cuVVJMID8gJ21tLmNvcmUueWVzJyA6ICdtbS5jb3JlLm5vJztcbiAgICAkc2NvcGUuZGV2aWNlID0gaW9uaWMuUGxhdGZvcm0uZGV2aWNlKCk7XG5cbiAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAkbW1GUy5nZXRCYXNlUGF0aCgpLnRoZW4oZnVuY3Rpb24oYmFzZXBhdGgpIHtcbiAgICAgICAgICAgICRzY29wZS5maWxlc3lzdGVtcm9vdCA9IGJhc2VwYXRoO1xuICAgICAgICAgICAgJHNjb3BlLmZzY2xpY2thYmxlID0gJG1tRlMudXNlc0hUTUxBUEkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgJHNjb3BlLnN0b3JhZ2V0eXBlID0gJG1tQXBwLmdldERCKCkuZ2V0VHlwZSgpO1xuICAgICRzY29wZS5sb2NhbG5vdGlmYXZhaWxhYmxlID0gJG1tTG9jYWxOb3RpZmljYXRpb25zLmlzQXZhaWxhYmxlKCkgPyAnbW0uY29yZS55ZXMnIDogJ21tLmNvcmUubm8nO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuc2V0dGluZ3MnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIHRoZSBhcHAgJ0dlbmVyYWwnIHNlY3Rpb24gaW4gc2V0dGluZ3MuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLnNldHRpbmdzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1TZXR0aW5nc0dlbmVyYWxDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbVNldHRpbmdzR2VuZXJhbEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRtbUxhbmcsICRpb25pY0hpc3RvcnksICRtbUV2ZW50cywgJG1tQ29uZmlnLCBtbUNvcmVFdmVudExhbmd1YWdlQ2hhbmdlZCxcbiAgICAgICAgICAgIG1tQ29yZVNldHRpbmdzUmVwb3J0SW5CYWNrZ3JvdW5kLCBtbUNvcmVDb25maWdDb25zdGFudHMsIG1tQ29yZVNldHRpbmdzRG93bmxvYWRTZWN0aW9uKSB7XG5cbiAgICAkc2NvcGUubGFuZ3MgPSBtbUNvcmVDb25maWdDb25zdGFudHMubGFuZ3VhZ2VzO1xuXG4gICAgJG1tTGFuZy5nZXRDdXJyZW50TGFuZ3VhZ2UoKS50aGVuKGZ1bmN0aW9uKGN1cnJlbnRMYW5ndWFnZSkge1xuICAgICAgICAkc2NvcGUuc2VsZWN0ZWRMYW5ndWFnZSA9IGN1cnJlbnRMYW5ndWFnZTtcbiAgICB9KTtcblxuICAgICRzY29wZS5sYW5ndWFnZUNoYW5nZWQgPSBmdW5jdGlvbihuZXdMYW5nKSB7XG4gICAgICAgICRtbUxhbmcuY2hhbmdlQ3VycmVudExhbmd1YWdlKG5ld0xhbmcpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBjYWNoZWQgdmlld3MuXG4gICAgICAgICAgICAkaW9uaWNIaXN0b3J5LmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tQ29yZUV2ZW50TGFuZ3VhZ2VDaGFuZ2VkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRtbUNvbmZpZy5nZXQobW1Db3JlU2V0dGluZ3NEb3dubG9hZFNlY3Rpb24sIHRydWUpLnRoZW4oZnVuY3Rpb24oZG93bmxvYWRTZWN0aW9uRW5hYmxlZCkge1xuICAgICAgICAkc2NvcGUuZG93bmxvYWRTZWN0aW9uID0gZG93bmxvYWRTZWN0aW9uRW5hYmxlZDtcbiAgICB9KTtcblxuICAgICRzY29wZS5kb3dubG9hZFNlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24oZG93bmxvYWRTZWN0aW9uKSB7XG4gICAgICAgICRtbUNvbmZpZy5zZXQobW1Db3JlU2V0dGluZ3NEb3dubG9hZFNlY3Rpb24sIGRvd25sb2FkU2VjdGlvbik7XG4gICAgfTtcblxuICAgIGlmIChsb2NhbFN0b3JhZ2UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0gJiYgbG9jYWxTdG9yYWdlLnNldEl0ZW0pIHtcbiAgICAgICAgJHNjb3BlLnNob3dSZXBvcnQgPSB0cnVlO1xuICAgICAgICAkc2NvcGUucmVwb3J0SW5CYWNrZ3JvdW5kID0gcGFyc2VJbnQobG9jYWxTdG9yYWdlLmdldEl0ZW0obW1Db3JlU2V0dGluZ3NSZXBvcnRJbkJhY2tncm91bmQpLCAxMCkgPT09IDE7XG5cbiAgICAgICAgJHNjb3BlLnJlcG9ydENoYW5nZWQgPSBmdW5jdGlvbihpbkJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG1tQ29yZVNldHRpbmdzUmVwb3J0SW5CYWNrZ3JvdW5kLCBpbkJhY2tncm91bmQgPyAnMScgOiAnMCcpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgICRzY29wZS5zaG93UmVwb3J0ID0gZmFsc2U7XG4gICAgfVxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuc2V0dGluZ3MnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIHRoZSBhcHAgJ1NwYWNlIFVzYWdlJyBzZWN0aW9uIGluIHNldHRpbmdzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5zZXR0aW5nc1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tU2V0dGluZ3NTcGFjZVVzYWdlQ3RybFxuICogQHRvZG8gV2hlbiBcIm1vY2sgc2l0ZVwiIGlzIGltcGxlbWVudGVkIHdlIHNob3VsZCBoYXZlIGZ1bmN0aW9ucyB0byBjYWxjdWxhdGUgdGhlIHNpdGUgdXNhZ2UgYW5kIGRlbGV0ZSBpdHMgZmlsZXMuXG4gKi9cbi5jb250cm9sbGVyKCdtbVNldHRpbmdzU3BhY2VVc2FnZUN0cmwnLCBmdW5jdGlvbigkbG9nLCAkc2NvcGUsICRtbVNpdGVzTWFuYWdlciwgJG1tRlMsICRxLCAkbW1VdGlsLCAkdHJhbnNsYXRlLFxuICAgICAgICAgICAgJG1tVGV4dCwgJG1tRmlsZXBvb2wpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1TZXR0aW5nc1NwYWNlVXNhZ2VDdHJsJyk7XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBjYWxjdWxhdGUgZWFjaCBzaXRlJ3MgdXNhZ2UsIGFuZCB0aGUgdG90YWwgdXNhZ2UuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU2l6ZVVzYWdlKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGVzKCkudGhlbihmdW5jdGlvbihzaXRlcykge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAkc2NvcGUuc2l0ZXMgPSBzaXRlcztcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNpdGVzLCBmdW5jdGlvbihzaXRlRW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVFbnRyeS5pZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXRlLmdldFNwYWNlVXNhZ2UoKS50aGVuKGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVFbnRyeS5zcGFjZXVzYWdlID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRvdGFsIHVzYWdlLlxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVRvdGFsVXNhZ2UoKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUuc2l0ZXMsIGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIGlmIChzaXRlLnNwYWNldXNhZ2UpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBwYXJzZUludChzaXRlLnNwYWNldXNhZ2UsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS50b3RhbHVzYWdlID0gdG90YWw7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGZyZWUgc3BhY2UgaW4gdGhlIGRldmljZS5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVGcmVlU3BhY2UoKSB7XG4gICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tRlMuY2FsY3VsYXRlRnJlZVNwYWNlKCkudGhlbihmdW5jdGlvbihmcmVlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZnJlZXNwYWNlID0gZnJlZXNwYWNlO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmZyZWVzcGFjZSA9IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5mcmVlc3BhY2UgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChjYWxjdWxhdGVTaXplVXNhZ2UoKS50aGVuKGNhbGN1bGF0ZVRvdGFsVXNhZ2UpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCgkcS53aGVuKGNhbGN1bGF0ZUZyZWVTcGFjZSgpKSk7XG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBmZXRjaERhdGEoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuc2l6ZUxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBQdWxsIHRvIHJlZnJlc2guXG4gICAgJHNjb3BlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmV0Y2hEYXRhKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byB1cGRhdGUgc2l0ZSBzaXplLCBhbG9uZyB3aXRoIHRvdGFsIHVzYWdlIGFuZCBmcmVlIHNwYWNlLlxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNpdGVVc2FnZShzaXRlLCBuZXdVc2FnZSkge1xuICAgICAgICB2YXIgb2xkVXNhZ2UgPSBzaXRlLnNwYWNldXNhZ2U7XG4gICAgICAgIHNpdGUuc3BhY2V1c2FnZSA9IG5ld1VzYWdlO1xuICAgICAgICAkc2NvcGUudG90YWx1c2FnZSAtPSBvbGRVc2FnZSAtIG5ld1VzYWdlO1xuICAgICAgICAkc2NvcGUuZnJlZXNwYWNlICs9IG9sZFVzYWdlIC0gbmV3VXNhZ2U7XG4gICAgfVxuXG4gICAgJHNjb3BlLmRlbGV0ZVNpdGVGaWxlcyA9IGZ1bmN0aW9uKHNpdGVEYXRhKSB7XG4gICAgICAgIGlmIChzaXRlRGF0YSkge1xuICAgICAgICAgICAgdmFyIHNpdGVpZCA9IHNpdGVEYXRhLmlkLFxuICAgICAgICAgICAgICAgIHNpdGVuYW1lID0gc2l0ZURhdGEuc2l0ZW5hbWU7XG5cbiAgICAgICAgICAgICRtbVRleHQuZm9ybWF0VGV4dChzaXRlbmFtZSkudGhlbihmdW5jdGlvbihzaXRlbmFtZSkge1xuICAgICAgICAgICAgICAgICR0cmFuc2xhdGUoJ21tLnNldHRpbmdzLmRlbGV0ZXNpdGVmaWxlc3RpdGxlJykudGhlbihmdW5jdGlvbih0aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tVXRpbC5zaG93Q29uZmlybSgkdHJhbnNsYXRlKCdtbS5zZXR0aW5ncy5kZWxldGVzaXRlZmlsZXMnLCB7c2l0ZW5hbWU6IHNpdGVuYW1lfSksIHRpdGxlKTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZWlkKTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpdGUuZGVsZXRlRm9sZGVyKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbUZpbGVwb29sLmNsZWFyQWxsUGFja2FnZXNTdGF0dXMoc2l0ZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbUZpbGVwb29sLmNsZWFyRmlsZXBvb2woc2l0ZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNpdGVVc2FnZShzaXRlRGF0YSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gRmlsZUVycm9yLk5PVF9GT1VORF9FUlIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZm91bmQsIHNldCBzaXplIDAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tRmlsZXBvb2wuY2xlYXJBbGxQYWNrYWdlc1N0YXR1cyhzaXRlaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNpdGVVc2FnZShzaXRlRGF0YSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yLCByZWNhbGN1bGF0ZSB0aGUgc2l0ZSB1c2FnZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5zZXR0aW5ncy5lcnJvcmRlbGV0ZXNpdGVmaWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpdGUuZ2V0U3BhY2VVc2FnZSgpLnRoZW4oZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTaXRlVXNhZ2Uoc2l0ZURhdGEsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLnNldHRpbmdzJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGhhbmRsZSB0aGUgYXBwICdTeW5jaHJvbml6YXRpb24nIHNlY3Rpb24gaW4gc2V0dGluZ3MuXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlLnNldHRpbmdzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1TZXR0aW5nc1N5bmNocm9uaXphdGlvbkN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tU2V0dGluZ3NTeW5jaHJvbml6YXRpb25DdHJsJywgZnVuY3Rpb24oJGxvZywgJHNjb3BlLCAkbW1TaXRlc01hbmFnZXIsICRtbVV0aWwsICRtbUZpbGVwb29sLCAkbW1FdmVudHMsXG4gICAgICAgICAgICAkbW1MYW5nLCAkbW1Db25maWcsIG1tQ29yZUV2ZW50U2Vzc2lvbkV4cGlyZWQsIG1tQ29yZVNldHRpbmdzU3luY09ubHlPbldpZmkpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1TZXR0aW5nc1N5bmNocm9uaXphdGlvbkN0cmwnKTtcblxuICAgICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlcygpLnRoZW4oZnVuY3Rpb24oc2l0ZXMpIHtcbiAgICAgICAgJHNjb3BlLnNpdGVzID0gc2l0ZXM7XG4gICAgfSk7XG5cbiAgICAkbW1Db25maWcuZ2V0KG1tQ29yZVNldHRpbmdzU3luY09ubHlPbldpZmksIHRydWUpLnRoZW4oZnVuY3Rpb24oc3luY09ubHlPbldpZmkpIHtcbiAgICAgICAgJHNjb3BlLnN5bmNPbmx5T25XaWZpID0gc3luY09ubHlPbldpZmk7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuc3luY1dpZmlDaGFuZ2VkID0gZnVuY3Rpb24oc3luY09ubHlPbldpZmkpIHtcbiAgICAgICAgJG1tQ29uZmlnLnNldChtbUNvcmVTZXR0aW5nc1N5bmNPbmx5T25XaWZpLCBzeW5jT25seU9uV2lmaSk7XG4gICAgfTtcblxuICAgICRzY29wZS5zeW5jaHJvbml6ZSA9IGZ1bmN0aW9uKHNpdGVEYXRhKSB7XG4gICAgICAgIGlmIChzaXRlRGF0YSkge1xuICAgICAgICAgICAgdmFyIHNpdGVpZCA9IHNpdGVEYXRhLmlkLFxuICAgICAgICAgICAgICAgIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbS5zZXR0aW5ncy5zeW5jaHJvbml6aW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAkbW1GaWxlcG9vbC5pbnZhbGlkYXRlQWxsRmlsZXMoc2l0ZWlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXRlLmludmFsaWRhdGVXc0NhY2hlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGxvY2FsX21vYmlsZSB3YXMgaW5zdGFsbGVkIHRvIE1vb2RsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXRlLmNoZWNrSWZMb2NhbE1vYmlsZUluc3RhbGxlZEFuZE5vdFVzZWQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvY2FsIG1vYmlsZSB3YXMgYWRkZWQuIFRocm93IGludmFsaWQgc2Vzc2lvbiB0byBmb3JjZSByZWNvbm5lY3QgYW5kIGNyZWF0ZSBhIG5ldyB0b2tlbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbUNvcmVFdmVudFNlc3Npb25FeHBpcmVkLCBzaXRlaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdCgnbW0uY29yZS5sb3N0Y29ubmVjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHNpdGUgaW5mby5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLnVwZGF0ZVNpdGVJbmZvKHNpdGVpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVEYXRhLmZ1bGxuYW1lID0gc2l0ZS5nZXRJbmZvKCkuZnVsbG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXRlRGF0YS5zaXRlbmFtZSA9IHNpdGUuZ2V0SW5mbygpLnNpdGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93TW9kYWwoJ21tLmNvcmUuc3VjY2VzcycsICdtbS5zZXR0aW5ncy5zeW5jc2l0ZXN1Y2Nlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLnNldHRpbmdzLmVycm9yc3luY3NpdGUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLnNpZGVtZW51JylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGhhbmRsZSB0aGUgc2lkZSBtZW51LlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS5zaWRlbWVudVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tU2lkZU1lbnVDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbVNpZGVNZW51Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlLCAkbW1TaWRlTWVudURlbGVnYXRlLCAkbW1TaXRlc01hbmFnZXIsICRtbVNpdGUsICRtbUV2ZW50cyxcbiAgICAgICAgICAgICR0aW1lb3V0LCBtbUNvcmVFdmVudExhbmd1YWdlQ2hhbmdlZCwgbW1Db3JlRXZlbnRTaXRlVXBkYXRlZCkge1xuXG4gICAgJHNjb3BlLmhhbmRsZXJzID0gJG1tU2lkZU1lbnVEZWxlZ2F0ZS5nZXROYXZIYW5kbGVycygpO1xuICAgICRzY29wZS5hcmVOYXZIYW5kbGVyc0xvYWRlZCA9ICRtbVNpZGVNZW51RGVsZWdhdGUuYXJlTmF2SGFuZGxlcnNMb2FkZWQ7XG4gICAgJHNjb3BlLnNpdGVpbmZvID0gJG1tU2l0ZS5nZXRJbmZvKCk7XG5cbiAgICAkc2NvcGUubG9nb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbVNpdGVzTWFuYWdlci5sb2dvdXQoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHN0YXRlLmdvKCdtbV9sb2dpbi5zaXRlcycpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJG1tU2l0ZS5nZXREb2NzVXJsKCkudGhlbihmdW5jdGlvbihkb2NzdXJsKSB7XG4gICAgICAgICRzY29wZS5kb2NzdXJsID0gZG9jc3VybDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNpdGVJbmZvKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSAkdGltZW91dCB0byBmb3JjZSBhICRkaWdlc3QgYW5kIG1ha2UgJHdhdGNoIG5vdGljZSB0aGUgdmFyaWFibGUgY2hhbmdlLlxuICAgICAgICAkc2NvcGUuc2l0ZWluZm8gPSB1bmRlZmluZWQ7XG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLnNpdGVpbmZvID0gJG1tU2l0ZS5nZXRJbmZvKCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBkb2NzIFVSTCwgbWF5YmUgdGhlIE1vb2RsZSByZWxlYXNlIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgJG1tU2l0ZS5nZXREb2NzVXJsKCkudGhlbihmdW5jdGlvbihkb2NzdXJsKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRvY3N1cmwgPSBkb2NzdXJsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBsYW5nT2JzZXJ2ZXIgPSAkbW1FdmVudHMub24obW1Db3JlRXZlbnRMYW5ndWFnZUNoYW5nZWQsIHVwZGF0ZVNpdGVJbmZvKTtcbiAgICB2YXIgdXBkYXRlU2l0ZU9ic2VydmVyID0gJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50U2l0ZVVwZGF0ZWQsIGZ1bmN0aW9uKHNpdGVpZCkge1xuICAgICAgICBpZiAoJG1tU2l0ZS5nZXRJZCgpID09PSBzaXRlaWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNpdGVJbmZvKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChsYW5nT2JzZXJ2ZXIgJiYgbGFuZ09ic2VydmVyLm9mZikge1xuICAgICAgICAgICAgbGFuZ09ic2VydmVyLm9mZigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVTaXRlT2JzZXJ2ZXIgJiYgdXBkYXRlU2l0ZU9ic2VydmVyLm9mZikge1xuICAgICAgICAgICAgdXBkYXRlU2l0ZU9ic2VydmVyLm9mZigpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uY29yZS5zaWRlbWVudScpXG5cbi8qKlxuICogU2VydmljZSB0byBpbnRlcmFjdCB3aXRoIHBsdWdpbnMgdG8gYmUgc2hvd24gaW4gdGhlIHNpZGUgbWVudS4gUHJvdmlkZXMgZnVuY3Rpb25zIHRvIHJlZ2lzdGVyIGEgcGx1Z2luXG4gKiBhbmQgbm90aWZ5IGFuIHVwZGF0ZSBpbiB0aGUgZGF0YS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUuc2lkZW1lbnVcbiAqIEBuZ2RvYyBwcm92aWRlclxuICogQG5hbWUgJG1tU2lkZU1lbnVEZWxlZ2F0ZVxuICovXG4ucHJvdmlkZXIoJyRtbVNpZGVNZW51RGVsZWdhdGUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmF2SGFuZGxlcnMgPSB7fSxcbiAgICAgICAgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBuYXZpZ2F0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUuc2lkZW1lbnVcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tU2lkZU1lbnVEZWxlZ2F0ZVByb3ZpZGVyI3JlZ2lzdGVyTmF2SGFuZGxlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRvbiBUaGUgYWRkb24ncyBuYW1lIChtbWFGaWxlcywgbW1hTWVzc2FnZXMsIC4uLilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IGhhbmRsZXIgTXVzdCBiZSByZXNvbHZlZCB0byBhbiBvYmplY3QgZGVmaW5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMuIE9yIHRvIGEgZnVuY3Rpb25cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmluZyBhbiBvYmplY3QgZGVmaW5pbmcgdGhlc2UgZnVuY3Rpb25zLiBTZWUge0BsaW5rICRtbVV0aWwjcmVzb2x2ZU9iamVjdH0uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gaXNFbmFibGVkIChCb29sZWFufFByb21pc2UpIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgb24gYSBzaXRlIGxldmVsLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHVzaW5nIGEgcHJvbWlzZSwgaXQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gZ2V0Q29udHJvbGxlciAoT2JqZWN0KSBSZXR1cm5zIHRoZSBvYmplY3QgdGhhdCB3aWxsIGFjdCBhcyBjb250cm9sbGVyLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBjb3JlL2NvbXBvbmVudHMvc2lkZW1lbnUvdGVtcGxhdGVzL21lbnUuaHRtbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgbGlzdCBvZiBzY29wZSB2YXJpYWJsZXMgZXhwZWN0ZWQuXG4gICAgICovXG4gICAgc2VsZi5yZWdpc3Rlck5hdkhhbmRsZXIgPSBmdW5jdGlvbihhZGRvbiwgaGFuZGxlciwgcHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYXZIYW5kbGVyc1thZGRvbl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlcjogQWRkb24gJ1wiICsgbmF2SGFuZGxlcnNbYWRkb25dLmFkZG9uICsgXCInIGFscmVhZHkgcmVnaXN0ZXJlZCBhcyBuYXZpZ2F0aW9uIGhhbmRsZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCIkbW1TaWRlTWVudURlbGVnYXRlUHJvdmlkZXI6IFJlZ2lzdGVyZWQgYWRkb24gJ1wiICsgYWRkb24gKyBcIicgYXMgbmF2aWdhdGlvbiBoYW5kbGVyLlwiKTtcbiAgICAgICAgbmF2SGFuZGxlcnNbYWRkb25dID0ge1xuICAgICAgICAgICAgYWRkb246IGFkZG9uLFxuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICAgIGluc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHNlbGYuJGdldCA9IGZ1bmN0aW9uKCRtbVV0aWwsICRxLCAkbG9nLCAkbW1TaXRlKSB7XG4gICAgICAgIHZhciBlbmFibGVkTmF2SGFuZGxlcnMgPSB7fSxcbiAgICAgICAgICAgIGN1cnJlbnRTaXRlSGFuZGxlcnMgPSBbXSwgLy8gSGFuZGxlcnMgdG8gcmV0dXJuLlxuICAgICAgICAgICAgc2VsZiA9IHt9LFxuICAgICAgICAgICAgbG9hZGVkID0gZmFsc2U7IC8vIElmIHNpdGUgaGFuZGxlcnMgaGF2ZSBiZWVuIGxvYWRlZC5cblxuICAgICAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tU2lkZU1lbnVEZWxlZ2F0ZScpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBhZGRvbnMgYXJlIGxvYWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLnNpZGVtZW51XG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tU2lkZU1lbnVEZWxlZ2F0ZSNhcmVOYXZIYW5kbGVyc0xvYWRlZFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGFkZG9ucyBhcmUgbG9hZGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmFyZU5hdkhhbmRsZXJzTG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBjdXJyZW50IHNpdGUgbmF2IGhhbmRsZXJzLiBSZXNlcnZlZCBmb3IgY29yZSB1c2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5zaWRlbWVudVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVNpZGVNZW51RGVsZWdhdGUjY2xlYXJTaXRlSGFuZGxlcnNcbiAgICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuY2xlYXJTaXRlSGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgJG1tVXRpbC5lbXB0eUFycmF5KGN1cnJlbnRTaXRlSGFuZGxlcnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmUuc2lkZW1lbnVcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1TaWRlTWVudURlbGVnYXRlI2dldE5hdkhhbmRsZXJzXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nICdwcmlvcml0eScgYW5kICdjb250cm9sbGVyJy5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0TmF2SGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2l0ZUhhbmRsZXJzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGhhbmRsZXIgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS5zaWRlbWVudVxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVNpZGVNZW51RGVsZWdhdGUjdXBkYXRlTmF2SGFuZGxlclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkb24gVGhlIGFkZG9uLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlckluZm8gVGhlIGhhbmRsZXIgZGV0YWlscy5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBlbmFibGVkLCByZWplY3RlZCB3aGVuIG5vdC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi51cGRhdGVOYXZIYW5kbGVyID0gZnVuY3Rpb24oYWRkb24sIGhhbmRsZXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVySW5mby5pbnN0YW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVySW5mby5pbnN0YW5jZSA9ICRtbVV0aWwucmVzb2x2ZU9iamVjdChoYW5kbGVySW5mby5oYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oaGFuZGxlckluZm8uaW5zdGFuY2UuaXNFbmFibGVkKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGNvbnRlbnQgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWROYXZIYW5kbGVyc1thZGRvbl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaGFuZGxlckluZm8uaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogaGFuZGxlckluZm8ucHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVuYWJsZWROYXZIYW5kbGVyc1thZGRvbl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBoYW5kbGVycyBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5jb3JlLnNpZGVtZW51XG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tU2lkZU1lbnVEZWxlZ2F0ZSN1cGRhdGVOYXZIYW5kbGVyc1xuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGRvbmUuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYudXBkYXRlTmF2SGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdVcGRhdGluZyBuYXZpZ2F0aW9uIGhhbmRsZXJzIGZvciBjdXJyZW50IHNpdGUuJyk7XG5cbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBhbGwgdGhlIGNvbnRlbnQgaGFuZGxlcnMuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobmF2SGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXJJbmZvLCBhZGRvbikge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi51cGRhdGVOYXZIYW5kbGVyKGFkZG9uLCBoYW5kbGVySW5mbykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXZlciByZWplY3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgJG1tVXRpbC5lbXB0eUFycmF5KGN1cnJlbnRTaXRlSGFuZGxlcnMpO1xuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVuYWJsZWROYXZIYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l0ZUhhbmRsZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogaGFuZGxlci5pbnN0YW5jZS5nZXRDb250cm9sbGVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogaGFuZGxlci5wcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLnRleHR2aWV3ZXInKVxuXG4vKipcbiAqIFRleHQgdmlld2VyICBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS50ZXh0dmlld2VyXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1UZXh0Vmlld2VySW5kZXhDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbVRleHRWaWV3ZXJJbmRleEN0cmwnLCBmdW5jdGlvbigkc3RhdGVQYXJhbXMsICRzY29wZSkge1xuICAgICRzY29wZS50aXRsZSA9ICRzdGF0ZVBhcmFtcy50aXRsZTtcbiAgICAkc2NvcGUuY29udGVudCA9ICRzdGF0ZVBhcmFtcy5jb250ZW50O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUudXNlcicpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgYSB1c2VyIHByb2ZpbGUgcGFnZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYVBhcnRpY2lwYW50c1Byb2ZpbGVDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbVVzZXJQcm9maWxlQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1VdGlsLCAkbW1Vc2VyLCAkbW1Vc2VyRGVsZWdhdGUsICRtbVNpdGUsICRxLCAkdHJhbnNsYXRlKSB7XG5cbiAgICB2YXIgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIHVzZXJpZCAgID0gJHN0YXRlUGFyYW1zLnVzZXJpZDtcblxuICAgICRzY29wZS5pc0FuZHJvaWQgPSBpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKTtcbiAgICAkc2NvcGUucGx1Z2lucyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gZmV0Y2hVc2VyRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuICRtbVVzZXIuZ2V0UHJvZmlsZSh1c2VyaWQsIGNvdXJzZWlkKS50aGVuKGZ1bmN0aW9uKHVzZXIpIHtcblxuICAgICAgICAgICAgdXNlci5hZGRyZXNzID0gJG1tVXNlci5mb3JtYXRBZGRyZXNzKHVzZXIuYWRkcmVzcywgdXNlci5jaXR5LCB1c2VyLmNvdW50cnkpO1xuICAgICAgICAgICAgaWYgKHVzZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHVzZXIuZW5jb2RlZEFkZHJlc3MgPSBlbmNvZGVVUklDb21wb25lbnQodXNlci5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJG1tVXNlci5mb3JtYXRSb2xlTGlzdCh1c2VyLnJvbGVzKS50aGVuKGZ1bmN0aW9uKHJvbGVzKSB7XG4gICAgICAgICAgICAgICAgdXNlci5yb2xlcyA9IHJvbGVzO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICRzY29wZS51c2VyID0gdXNlcjtcbiAgICAgICAgICAgICRzY29wZS50aXRsZSA9IHVzZXIuZnVsbG5hbWU7XG4gICAgICAgICAgICAkc2NvcGUuaGFzQ29udGFjdCA9IHVzZXIuZW1haWwgfHwgdXNlci5waG9uZTEgfHwgdXNlci5waG9uZTIgfHwgdXNlci5jaXR5IHx8IHVzZXIuY291bnRyeSB8fCB1c2VyLmFkZHJlc3M7XG4gICAgICAgICAgICAkc2NvcGUuaGFzRGV0YWlscyA9IHVzZXIudXJsIHx8IHVzZXIucm9sZXMgfHwgdXNlci5pbnRlcmVzdHM7XG5cbiAgICAgICAgICAgICRzY29wZS5pc0xvYWRpbmdIYW5kbGVycyA9IHRydWU7XG4gICAgICAgICAgICAkbW1Vc2VyRGVsZWdhdGUuZ2V0UHJvZmlsZUhhbmRsZXJzRm9yKHVzZXIsIGNvdXJzZWlkKS50aGVuKGZ1bmN0aW9uKGhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnByb2ZpbGVIYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaXNMb2FkaW5nSGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAkc2NvcGUudXNlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZldGNoVXNlckRhdGEoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBBZGQgbG9nIGluIE1vb2RsZS5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ2NvcmVfdXNlcl92aWV3X3VzZXJfcHJvZmlsZScsIHtcbiAgICAgICAgICAgIHVzZXJpZDogdXNlcmlkLFxuICAgICAgICAgICAgY291cnNlaWQ6IGNvdXJzZWlkXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAkc2NvcGUuaXNEZWxldGVkID0gZXJyb3IgPT09ICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS51c2VyZGVsZXRlZCcpO1xuICAgICAgICB9KTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUudXNlckxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUucmVmcmVzaFVzZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tVXNlci5pbnZhbGlkYXRlVXNlckNhY2hlKHVzZXJpZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZldGNoVXNlckRhdGEoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBnbyB0byB1c2VyIHByb2ZpbGUgb24gY2xpY2suXG4gKlxuICogQG1vZHVsZSBtbS5jb3JlXG4gKiBAbmdkb2MgcHJvdmlkZXJcbiAqIEBuYW1lIG1tVXNlckxpbmtcbiAqL1xuLmRpcmVjdGl2ZSgnbW1Vc2VyTGluaycsIGZ1bmN0aW9uKCRzdGF0ZSwgbW1Vc2VyUHJvZmlsZVN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICBlbGVtZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAkc3RhdGUuZ28obW1Vc2VyUHJvZmlsZVN0YXRlLCB7Y291cnNlaWQ6IGF0dHJzLmNvdXJzZWlkLCB1c2VyaWQ6IGF0dHJzLnVzZXJpZH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUudXNlcicpXG5cbi8qKlxuICogU2VydmljZSB0byBpbnRlcmFjdCB3aXRoIHBsdWdpbnMgdG8gYmUgc2hvd24gaW4gdXNlciBwcm9maWxlLiBQcm92aWRlcyBmdW5jdGlvbnMgdG8gcmVnaXN0ZXIgYSBwbHVnaW5cbiAqIGFuZCBub3RpZnkgYW4gdXBkYXRlIGluIHRoZSBkYXRhLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gKiBAbmdkb2MgcHJvdmlkZXJcbiAqIEBuYW1lICRtbVVzZXJEZWxlZ2F0ZVxuICovXG4ucHJvdmlkZXIoJyRtbVVzZXJEZWxlZ2F0ZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9maWxlSGFuZGxlcnMgPSB7fSxcbiAgICAgICAgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBwcm9maWxlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Vc2VyRGVsZWdhdGVQcm92aWRlciNyZWdpc3RlclByb2ZpbGVIYW5kbGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCBUaGUgYWRkb24ncyBuYW1lLCBvciBhZGRvbiBhbmQgc3ViIGNvbnRleHQgKG1tYU1lc3NhZ2VzLCBtbWFNZXNzYWdlOmJsb2NrQ29udGFjdCwgLi4uKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gaGFuZGxlciBNdXN0IGJlIHJlc29sdmVkIHRvIGFuIG9iamVjdCBkZWZpbmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucy4gT3IgdG8gYSBmdW5jdGlvblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5pbmcgYW4gb2JqZWN0IGRlZmluaW5nIHRoZXNlIGZ1bmN0aW9ucy4gU2VlIHtAbGluayAkbW1VdGlsI3Jlc29sdmVPYmplY3R9LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGlzRW5hYmxlZCAoQm9vbGVhbnxQcm9taXNlKSBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIG9uIGEgc2l0ZSBsZXZlbC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiB1c2luZyBhIHByb21pc2UsIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGlzRW5hYmxlZEZvclVzZXIgKEJvb2xlYW58UHJvbWlzZSkgV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSB1c2VyLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiB1c2luZyBhIHByb21pc2UsIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGdldENvbnRyb2xsZXIodXNlcmlkKSAoRnVuY3Rpb24pIFJldHVybnMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBhY3QgYXMgY29udHJvbGxlci5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgY29yZS9jb21wb25lbnRzL3VzZXIvdGVtcGxhdGVzL3Byb2ZpbGUuaHRtbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgbGlzdCBvZiBzY29wZSB2YXJpYWJsZXMgZXhwZWN0ZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgc3RyaW5nIGNhbiBlaXRoZXIgYmUgJ2ZhY3RvcnlOYW1lJyBvciAnZmFjdG9yeU5hbWUuZnVuY3Rpb25Ub0NhbGwnLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHk9MTAwXSBQbHVnaW4gcHJpb3JpdHkuXG4gICAgICovXG4gICAgc2VsZi5yZWdpc3RlclByb2ZpbGVIYW5kbGVyID0gZnVuY3Rpb24oY29tcG9uZW50LCBoYW5kbGVyLCBwcmlvcml0eSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb2ZpbGVIYW5kbGVyc1tjb21wb25lbnRdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIkbW1Vc2VyRGVsZWdhdGVQcm92aWRlcjogSGFuZGxlciAnXCIgKyBwcm9maWxlSGFuZGxlcnNbY29tcG9uZW50XS5jb21wb25lbnQgKyBcIicgYWxyZWFkeSByZWdpc3RlcmVkIGFzIHByb2ZpbGUgaGFuZGxlclwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIiRtbVVzZXJEZWxlZ2F0ZVByb3ZpZGVyOiBSZWdpc3RlcmVkIGNvbXBvbmVudCAnXCIgKyBjb21wb25lbnQgKyBcIicgYXMgcHJvZmlsZSBoYW5kbGVyLlwiKTtcbiAgICAgICAgcHJvZmlsZUhhbmRsZXJzW2NvbXBvbmVudF0gPSB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICBpbnN0YW5jZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJpb3JpdHk6IHR5cGVvZiBwcmlvcml0eSA9PT0gJ3VuZGVmaW5lZCcgPyAxMDAgOiBwcmlvcml0eVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2VsZi4kZ2V0ID0gZnVuY3Rpb24oJHEsICRsb2csICRtbVNpdGUsICRtbVV0aWwpIHtcbiAgICAgICAgdmFyIGVuYWJsZWRQcm9maWxlSGFuZGxlcnMgPSB7fSxcbiAgICAgICAgICAgIHNlbGYgPSB7fTtcblxuICAgICAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tVXNlckRlbGVnYXRlJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcHJvZmlsZSBoYW5kbGVycyBmb3IgYSB1c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVVzZXJEZWxlZ2F0ZSNnZXRQcm9maWxlSGFuZGxlcnNGb3JcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXIgVGhlIHVzZXIgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgJ3ByaW9yaXR5JyBhbmQgJ2NvbnRyb2xsZXInLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRQcm9maWxlSGFuZGxlcnNGb3IgPSBmdW5jdGlvbih1c2VyLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gW10sXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVuYWJsZWRQcm9maWxlSGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSAkcS53aGVuKGhhbmRsZXIuaW5zdGFuY2UuaXNFbmFibGVkRm9yVXNlcih1c2VyLCBjb3Vyc2VJZCkpLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogaGFuZGxlci5pbnN0YW5jZS5nZXRDb250cm9sbGVyKHVzZXIsIGNvdXJzZUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogaGFuZGxlci5wcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkbyBoZXJlLCBpdCBpcyBub3QgZW5hYmxlZCBmb3IgdGhpcyB1c2VyLlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcnM7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXZlciBmYWlscy5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBlbmFibGVkIHByb2ZpbGUgaGFuZGxlcnMgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tVXNlckRlbGVnYXRlI3VwZGF0ZVByb2ZpbGVIYW5kbGVyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlckluZm8gVGhlIGhhbmRsZXIgZGV0YWlscy5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBlbmFibGVkLCByZWplY3RlZCB3aGVuIG5vdC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi51cGRhdGVQcm9maWxlSGFuZGxlciA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgaGFuZGxlckluZm8pIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXJJbmZvLmluc3RhbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJJbmZvLmluc3RhbmNlID0gJG1tVXRpbC5yZXNvbHZlT2JqZWN0KGhhbmRsZXJJbmZvLmhhbmRsZXIsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihoYW5kbGVySW5mby5pbnN0YW5jZS5pc0VuYWJsZWQoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrcyBpZiB0aGUgY29udGVudCBpcyBlbmFibGVkLlxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZFByb2ZpbGVIYW5kbGVyc1tjb21wb25lbnRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGhhbmRsZXJJbmZvLmluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IGhhbmRsZXJJbmZvLnByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbmFibGVkUHJvZmlsZUhhbmRsZXJzW2NvbXBvbmVudF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBwcm9maWxlIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbVVzZXJEZWxlZ2F0ZSN1cGRhdGVQcm9maWxlSGFuZGxlcnNcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBkb25lLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnVwZGF0ZVByb2ZpbGVIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1VwZGF0aW5nIHByb2ZpbGUgaGFuZGxlcnMgZm9yIGN1cnJlbnQgc2l0ZS4nKTtcblxuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIGFsbCB0aGUgcHJvZmlsZSBoYW5kbGVycy5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChwcm9maWxlSGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXJJbmZvLCBjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYudXBkYXRlUHJvZmlsZUhhbmRsZXIoY29tcG9uZW50LCBoYW5kbGVySW5mbykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXZlciByZWplY3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcblxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLnVzZXInKVxuXG4vKipcbiAqIFVzZXIgaGFuZGxlcnMgZmFjdG9yeS5cbiAqXG4gKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbVVzZXJIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tVXNlckhhbmRsZXJzJywgZnVuY3Rpb24oJG1tVXRpbCwgJG1tQ29udGVudExpbmtzSGVscGVyKSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLnVzZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVXNlckhhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgTGlzdCBvZiBhY3Rpb25zLiBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgdXNlciBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJ2dyYWRlL3JlcG9ydC91c2VyJykgPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKHVybC5pbmRleE9mKCcvdXNlci92aWV3LnBocCcpID4gLTEgfHzCoHVybC5pbmRleE9mKCcvdXNlci9wcm9maWxlLnBocCcpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9ICRtbVV0aWwuZXh0cmFjdFVybFBhcmFtcyh1cmwpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zLmlkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhY3Rpb25zLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtbS5jb3JlLnZpZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1leWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZXM6IHNpdGVJZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291cnNlaWQ6IHBhcmFtcy5jb3Vyc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJpZDogcGFyc2VJbnQocGFyYW1zLmlkLCAxMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUNvbnRlbnRMaW5rc0hlbHBlci5nb0luU2l0ZSgnc2l0ZS5tbV91c2VyLXByb2ZpbGUnLCBzdGF0ZVBhcmFtcywgc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5jb3JlLnVzZXInKVxuXG4uY29uc3RhbnQoJ21tQ29yZVVzZXJzU3RvcmUnLCAndXNlcnMnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbVNpdGVzRmFjdG9yeVByb3ZpZGVyLCBtbUNvcmVVc2Vyc1N0b3JlKSB7XG4gICAgdmFyIHN0b3JlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogbW1Db3JlVXNlcnNTdG9yZSxcbiAgICAgICAgICAgIGtleVBhdGg6ICdpZCdcbiAgICAgICAgfVxuICAgIF07XG4gICAgJG1tU2l0ZXNGYWN0b3J5UHJvdmlkZXIucmVnaXN0ZXJTdG9yZXMoc3RvcmVzKTtcbn0pXG5cbi8qKlxuICogU2VydmljZSB0byBwcm92aWRlIHVzZXIgZnVuY3Rpb25hbGl0aWVzLlxuICpcbiAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tVXNlclxuICovXG4uZmFjdG9yeSgnJG1tVXNlcicsIGZ1bmN0aW9uKCRsb2csICRxLCAkbW1TaXRlLCAkbW1VdGlsLCAkdHJhbnNsYXRlLCBtbUNvcmVVc2Vyc1N0b3JlKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tVXNlcicpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIHVzZXIgYmFzaWMgaW5mb3JtYXRpb24gaW4gbG9jYWwgREIgdG8gYmUgcmV0cmlldmVkIGlmIHRoZSBXUyBjYWxsIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBVc2VyIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgUHJvbWlzZSByZXNvbHZlIHdoZW4gdGhlIHVzZXIgaXMgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmRlbGV0ZVN0b3JlZFVzZXIgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICAvLyBOb3QgbG9nZ2VkIGluLCB3ZSBjYW4ndCBnZXQgdGhlIHNpdGUgREIuIFVzZXIgbG9nZ2VkIG91dCBvciBzZXNzaW9uIGV4cGlyZWQgd2hpbGUgYW4gb3BlcmF0aW9uIHdhcyBvbmdvaW5nLlxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5pbnZhbGlkYXRlVXNlckNhY2hlKGlkKTsgLy8gSW52YWxpZGF0ZSBXUyBjYWxscy5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUuZ2V0RGIoKS5yZW1vdmUobW1Db3JlVXNlcnNTdG9yZSwgcGFyc2VJbnQoaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIHVzZXIgYWRkcmVzcywgY29uY2F0ZW5hdGluZyBhZGRyZXNzLCBjaXR5IGFuZCBjb3VudHJ5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLnVzZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVXNlciNmb3JtYXRBZGRyZXNzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBhZGRyZXNzIEFkZHJlc3MuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBjaXR5ICAgIENpdHkuLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gY291bnRyeSBDb3VudHJ5LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBGb3JtYXR0ZWQgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBzZWxmLmZvcm1hdEFkZHJlc3MgPSBmdW5jdGlvbihhZGRyZXNzLCBjaXR5LCBjb3VudHJ5KSB7XG4gICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICBhZGRyZXNzICs9IGNpdHkgPyAnLCAnICsgY2l0eSA6ICcnO1xuICAgICAgICAgICAgYWRkcmVzcyArPSBjb3VudHJ5ID8gJywgJyArIGNvdW50cnkgOiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIHVzZXIgcm9sZSBsaXN0LCB0cmFuc2xhdGluZyBhbmQgY29uY2F0ZW5hdGluZyB0aGVtLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLnVzZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVXNlciNmb3JtYXRSb2xlTGlzdFxuICAgICAqIEBwYXJhbSAge0FycmF5fSByb2xlcyBMaXN0IG9mIHVzZXIgcm9sZXMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZm9ybWF0dGVkIHJvbGVzIChzdHJpbmcpLlxuICAgICAqL1xuICAgIHNlbGYuZm9ybWF0Um9sZUxpc3QgPSBmdW5jdGlvbihyb2xlcykge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIGlmIChyb2xlcyAmJiByb2xlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAkdHJhbnNsYXRlKCdtbS5jb3JlLmVsZW1lbnRzZXBhcmF0b3InKS50aGVuKGZ1bmN0aW9uKHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHZhciByb2xla2V5cyA9IHJvbGVzLm1hcChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ21tLnVzZXIuJytlbC5zaG9ydG5hbWU7IC8vIFNldCB0aGUgc3RyaW5nIGtleSB0byBiZSB0cmFuc2xhdGVkLlxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJHRyYW5zbGF0ZShyb2xla2V5cykudGhlbihmdW5jdGlvbihyb2xlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvbGVzID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJvbGVLZXkgaW4gcm9sZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9sZU5hbWUgPSByb2xlTmFtZXNbcm9sZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm9sZU5hbWUuaW5kZXhPZignbW0udXNlci4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm9sZSBuYW1lIGNvdWxkbid0IGJlIHRyYW5zbGF0ZWQsIGxlYXZlIGl0IGxpa2UgaXQgd2FzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGVOYW1lID0gcm9sZU5hbWUucmVwbGFjZSgnbW0udXNlci4nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlcyArPSAocm9sZXMgIT0gJycgPyBzZXBhcmF0b3I6ICcnKSArIHJvbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocm9sZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgcHJvZmlsZS4gVGhlIHR5cGUgb2YgcHJvZmlsZSByZXRyaWV2ZWQgZGVwZW5kcyBvbiB0aGUgcGFyYW1zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLnVzZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVXNlciNnZXRQcm9maWxlXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VyaWQgICAgICBVc2VyJ3MgSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlaWRdICBDb3Vyc2UgSUQgdG8gZ2V0IGNvdXJzZSBwcm9maWxlLCB1bmRlZmluZWQgb3IgMCB0byBnZXQgc2l0ZSBwcm9maWxlLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGZvcmNlTG9jYWwgVHJ1ZSB0byByZXRyaWV2ZSB0aGUgdXNlciBkYXRhIGZyb20gbG9jYWwgREIsIGZhbHNlIHRvIHJldHJpZXZlIGl0IGZyb20gV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHVzZXIgZGF0YS5cbiAgICAgKi9cbiAgICBzZWxmLmdldFByb2ZpbGUgPSBmdW5jdGlvbih1c2VyaWQsIGNvdXJzZWlkLCBmb3JjZUxvY2FsKSB7XG5cbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICBpZiAoZm9yY2VMb2NhbCkge1xuICAgICAgICAgICAgc2VsZi5nZXRVc2VyRnJvbUxvY2FsKHVzZXJpZCkudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdldFVzZXJGcm9tV1ModXNlcmlkLCBjb3Vyc2VpZCkudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmdldFVzZXJGcm9tV1ModXNlcmlkLCBjb3Vyc2VpZCkudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdldFVzZXJGcm9tTG9jYWwodXNlcmlkKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyB1c2VyIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VyaWQgVXNlciBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VXNlckNhY2hlS2V5KHVzZXJpZCkge1xuICAgICAgICByZXR1cm4gJ21tVXNlcjpkYXRhOicrdXNlcmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGJhc2ljIGluZm9ybWF0aW9uIGZyb20gbG9jYWwgREIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Vc2VyI2dldFVzZXJGcm9tTG9jYWxcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFVzZXIgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICBQcm9taXNlIHJlc29sdmUgd2hlbiB0aGUgdXNlciBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRVc2VyRnJvbUxvY2FsID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKCEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgLy8gTm90IGxvZ2dlZCBpbiwgd2UgY2FuJ3QgZ2V0IHRoZSBzaXRlIERCLiBVc2VyIGxvZ2dlZCBvdXQgb3Igc2Vzc2lvbiBleHBpcmVkIHdoaWxlIGFuIG9wZXJhdGlvbiB3YXMgb25nb2luZy5cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5nZXREYigpLmdldChtbUNvcmVVc2Vyc1N0b3JlLCBwYXJzZUludChpZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBwcm9maWxlIGZyb20gV1MuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmNvcmUudXNlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1Vc2VyI2dldFVzZXJGcm9tV1NcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkICAgICAgICAgVXNlciBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VpZF0gQ291cnNlIElEIHRvIGdldCBjb3Vyc2UgcHJvZmlsZSwgdW5kZWZpbmVkIG9yIDAgdG8gZ2V0IHNpdGUgcHJvZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlIHdoZW4gdGhlIHVzZXIgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0VXNlckZyb21XUyA9IGZ1bmN0aW9uKHVzZXJpZCwgY291cnNlaWQpIHtcbiAgICAgICAgdmFyIHdzTmFtZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwcmVTZXRzID17XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldFVzZXJDYWNoZUtleSh1c2VyaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIERldGVybWluZSBXUyBhbmQgZGF0YSB0byB1c2UuXG4gICAgICAgIGlmIChjb3Vyc2VpZCA+IDEpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0dldCBwYXJ0aWNpcGFudCB3aXRoIElEICcgKyB1c2VyaWQgKyAnIGluIGNvdXJzZSAnK2NvdXJzZWlkKTtcbiAgICAgICAgICAgIHdzTmFtZSA9ICdjb3JlX3VzZXJfZ2V0X2NvdXJzZV91c2VyX3Byb2ZpbGVzJztcbiAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgXCJ1c2VybGlzdFswXVt1c2VyaWRdXCI6IHVzZXJpZCxcbiAgICAgICAgICAgICAgICBcInVzZXJsaXN0WzBdW2NvdXJzZWlkXVwiOiBjb3Vyc2VpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0dldCB1c2VyIHdpdGggSUQgJyArIHVzZXJpZCk7XG4gICAgICAgICAgICBpZiAoJG1tU2l0ZS53c0F2YWlsYWJsZSgnY29yZV91c2VyX2dldF91c2Vyc19ieV9maWVsZCcpKSB7XG4gICAgICAgICAgICAgICAgd3NOYW1lID0gJ2NvcmVfdXNlcl9nZXRfdXNlcnNfYnlfZmllbGQnO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICdmaWVsZCc6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgICd2YWx1ZXNbMF0nOiB1c2VyaWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3c05hbWUgPSAnY29yZV91c2VyX2dldF91c2Vyc19ieV9pZCc7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ3VzZXJpZHNbMF0nOiB1c2VyaWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCh3c05hbWUsIGRhdGEsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24odXNlcnMpIHtcbiAgICAgICAgICAgIGlmICh1c2Vycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVzZXIgPSB1c2Vycy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHVzZXIuY291bnRyeSkge1xuICAgICAgICAgICAgICAgIHVzZXIuY291bnRyeSA9ICRtbVV0aWwuZ2V0Q291bnRyeU5hbWUodXNlci5jb3VudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc3RvcmVVc2VyKHVzZXIuaWQsIHVzZXIuZnVsbG5hbWUsIHVzZXIucHJvZmlsZWltYWdldXJsKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgdXNlciBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uY29yZS51c2VyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVVzZXIjaW52YWxpZGF0ZVVzZXJDYWNoZVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcmlkIFVzZXIgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZVVzZXJDYWNoZSA9IGZ1bmN0aW9uKHVzZXJpZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRVc2VyQ2FjaGVLZXkodXNlcmlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIHVzZXIgYmFzaWMgaW5mb3JtYXRpb24gaW4gbG9jYWwgREIgdG8gYmUgcmV0cmlldmVkIGlmIHRoZSBXUyBjYWxsIGZhaWxzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5jb3JlLnVzZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tVXNlciNzdG9yZVVzZXJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkICAgICAgIFVzZXIgSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBmdWxsbmFtZSBVc2VyIGZ1bGwgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGF2YXRhciAgIFVzZXIgYXZhdGFyIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZSB3aGVuIHRoZSB1c2VyIGlzIHN0b3JlZC5cbiAgICAgKi9cbiAgICBzZWxmLnN0b3JlVXNlciA9IGZ1bmN0aW9uKGlkLCBmdWxsbmFtZSwgYXZhdGFyKSB7XG4gICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIC8vIE5vdCBsb2dnZWQgaW4sIHdlIGNhbid0IGdldCB0aGUgc2l0ZSBEQi4gVXNlciBsb2dnZWQgb3V0IG9yIHNlc3Npb24gZXhwaXJlZCB3aGlsZSBhbiBvcGVyYXRpb24gd2FzIG9uZ29pbmcuXG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5nZXREYigpLmluc2VydChtbUNvcmVVc2Vyc1N0b3JlLCB7XG4gICAgICAgICAgICBpZDogcGFyc2VJbnQoaWQpLFxuICAgICAgICAgICAgZnVsbG5hbWU6IGZ1bGxuYW1lLFxuICAgICAgICAgICAgcHJvZmlsZWltYWdldXJsOiBhdmF0YXJcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIHVzZXJzIGJhc2ljIGluZm9ybWF0aW9uIGluIGxvY2FsIERCLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IHVzZXJzIFVzZXJzIHRvIHN0b3JlLiBGaWVsZHMgc3RvcmVkOiBpZCwgZnVsbG5hbWUsIHByb2ZpbGVpbWFnZXVybC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlIHdoZW4gdGhlIHVzZXIgaXMgc3RvcmVkLlxuICAgICAqL1xuICAgIHNlbGYuc3RvcmVVc2VycyA9IGZ1bmN0aW9uKHVzZXJzKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgdmFyIHVzZXJpZCA9IHVzZXIuaWQgfHwgdXNlci51c2VyaWQsXG4gICAgICAgICAgICAgICAgaW1nID0gdXNlci5wcm9maWxlaW1hZ2V1cmwgfHwgdXNlci5wcm9maWxlaW1ndXJsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1c2VyaWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYuc3RvcmVVc2VyKHVzZXJpZCwgdXNlci5mdWxsbmFtZSwgaW1nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuY2FsZW5kYXInLCBbXSlcblxuLmNvbnN0YW50KCdtbWFDYWxlbmRhckRheXNJbnRlcnZhbCcsIDMwKVxuLmNvbnN0YW50KCdtbWFDYWxlbmRhckRlZmF1bHROb3RpZlRpbWUnLCA2MClcbi5jb25zdGFudCgnbW1hQ2FsZW5kYXJDb21wb25lbnQnLCAnbW1hQ2FsZW5kYXJFdmVudHMnKVxuLmNvbnN0YW50KCdtbWFDYWxlbmRhclByaW9yaXR5JywgNDAwKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkbW1TaWRlTWVudURlbGVnYXRlUHJvdmlkZXIsIG1tYUNhbGVuZGFyUHJpb3JpdHkpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG4gICAgICAgIC5zdGF0ZSgnc2l0ZS5jYWxlbmRhcicsIHtcbiAgICAgICAgICAgIHVybDogJy9jYWxlbmRhcicsXG4gICAgICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hQ2FsZW5kYXJMaXN0Q3RybCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL2NhbGVuZGFyL3RlbXBsYXRlcy9saXN0Lmh0bWwnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGV2ZW50aWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY2xlYXI6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLnN0YXRlKCdzaXRlLmNhbGVuZGFyLWV2ZW50Jywge1xuICAgICAgICAgICAgdXJsOiAnL2NhbGVuZGFyLWV2ZW50LzppZCcsIC8vIFdlIG5lZWQgdG8gYWRkIElEIHRvIHRoZSBVUkwgdG8gbWFrZSBuZy1ocmVmIHdvcmsuXG4gICAgICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hQ2FsZW5kYXJFdmVudEN0cmwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9jYWxlbmRhci90ZW1wbGF0ZXMvZXZlbnQuaHRtbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgc2lkZSBtZW51IGFkZG9uLlxuICAgIC8vIEZZSTogQ29tbWVudCB0aGlzIG91dCB0byBkaXNhYmxlIGZyb20gc2lkZSBtZW51XG4gICAgJG1tU2lkZU1lbnVEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTmF2SGFuZGxlcignbW1hQ2FsZW5kYXInLCAnJG1tYUNhbGVuZGFySGFuZGxlcnMuc2lkZU1lbnVOYXYnLCBtbWFDYWxlbmRhclByaW9yaXR5KTtcblxufSlcblxuLnJ1bihmdW5jdGlvbigkbW1hQ2FsZW5kYXIsICRtbUxvY2FsTm90aWZpY2F0aW9ucywgJHN0YXRlLCAkaW9uaWNQbGF0Zm9ybSwgJG1tQXBwLCBtbWFDYWxlbmRhckNvbXBvbmVudCkge1xuXG4gICAgLy8gTGlzdGVuIGZvciBub3RpZmljYXRpb24gY2xpY2tzLlxuICAgICRtbUxvY2FsTm90aWZpY2F0aW9ucy5yZWdpc3RlckNsaWNrKG1tYUNhbGVuZGFyQ29tcG9uZW50LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmV2ZW50aWQpIHtcbiAgICAgICAgICAgICRtbUFwcC5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdyZWRpcmVjdCcsIHtzaXRlaWQ6IGRhdGEuc2l0ZWlkLCBzdGF0ZTogJ3NpdGUuY2FsZW5kYXInLCBwYXJhbXM6IHtldmVudGlkOiBkYXRhLmV2ZW50aWR9fSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJGlvbmljUGxhdGZvcm0ucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFDYWxlbmRhci5zY2hlZHVsZUFsbFNpdGVzRXZlbnRzTm90aWZpY2F0aW9ucygpO1xuICAgIH0pO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uJywgW10pXG5cbi5jb25zdGFudCgnbW1hQ291cnNlQ29tcGxldGlvblByaW9yaXR5JywgMjAwKVxuLmNvbnN0YW50KCdtbWFDb3Vyc2VDb21wbGV0aW9uVmlld0NvbXBsZXRpb25Qcmlvcml0eScsIDIwMClcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJG1tVXNlckRlbGVnYXRlUHJvdmlkZXIsICRtbUNvdXJzZXNEZWxlZ2F0ZVByb3ZpZGVyLCBtbWFDb3Vyc2VDb21wbGV0aW9uUHJpb3JpdHksXG4gICAgICAgICAgICBtbWFDb3Vyc2VDb21wbGV0aW9uVmlld0NvbXBsZXRpb25Qcmlvcml0eSkge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5jb3Vyc2UtY29tcGxldGlvbicsIHtcbiAgICAgICAgdXJsOiAnL2NvdXJzZS1jb21wbGV0aW9uJyxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL2NvdXJzZWNvbXBsZXRpb24vdGVtcGxhdGVzL3JlcG9ydC5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hQ291cnNlQ29tcGxldGlvblJlcG9ydEN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgY291cnNlOiBudWxsLFxuICAgICAgICAgICAgdXNlcmlkOiBudWxsXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlZ2lzdGVyIHBsdWdpbiBvbiB1c2VyIHByb2ZpbGUuXG4gICAgJG1tVXNlckRlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcm9maWxlSGFuZGxlcignbW1hQ291cnNlQ29tcGxldGlvbjp2aWV3Q29tcGxldGlvbicsXG4gICAgICAgICAgICAnJG1tYUNvdXJzZUNvbXBsZXRpb25IYW5kbGVycy52aWV3Q29tcGxldGlvbicsIG1tYUNvdXJzZUNvbXBsZXRpb25WaWV3Q29tcGxldGlvblByaW9yaXR5KTtcblxuICAgIC8vIFJlZ2lzdGVyIGNvdXJzZXMgaGFuZGxlci5cbiAgICAkbW1Db3Vyc2VzRGVsZWdhdGVQcm92aWRlci5yZWdpc3Rlck5hdkhhbmRsZXIoJ21tYUNvdXJzZUNvbXBsZXRpb24nLFxuICAgICAgICAgICAgJyRtbWFDb3Vyc2VDb21wbGV0aW9uSGFuZGxlcnMuY291cnNlc05hdicsIG1tYUNvdXJzZUNvbXBsZXRpb25Qcmlvcml0eSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmZpbGVzJywgWydtbS5jb3JlJ10pXG5cbi5jb25zdGFudCgnbW1hRmlsZXNVcGxvYWRTdGF0ZU5hbWUnLCAnc2l0ZS5maWxlcy11cGxvYWQnKVxuLmNvbnN0YW50KCdtbWFGaWxlc1NoYXJlZEZpbGVzU3RvcmUnLCAnc2hhcmVkX2ZpbGVzJylcbi5jb25zdGFudCgnbW1hRmlsZXNNeUNvbXBvbmVudCcsICdtbWFGaWxlc015Jylcbi5jb25zdGFudCgnbW1hRmlsZXNTaXRlQ29tcG9uZW50JywgJ21tYUZpbGVzU2l0ZScpXG4uY29uc3RhbnQoJ21tYUZpbGVzUHJpb3JpdHknLCAyMDApXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlciwgbW1hRmlsZXNVcGxvYWRTdGF0ZU5hbWUsIG1tYUZpbGVzUHJpb3JpdHkpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG4gICAgICAgIC5zdGF0ZSgnc2l0ZS5maWxlcycsIHtcbiAgICAgICAgICAgIHVybDogJy9maWxlcycsXG4gICAgICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hRmlsZXNJbmRleENvbnRyb2xsZXInLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9maWxlcy90ZW1wbGF0ZXMvaW5kZXguaHRtbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLnN0YXRlKCdzaXRlLmZpbGVzLWxpc3QnLCB7XG4gICAgICAgICAgICB1cmw6ICcvbGlzdCcsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBwYXRoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByb290OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hRmlsZXNMaXN0Q29udHJvbGxlcicsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL2ZpbGVzL3RlbXBsYXRlcy9saXN0Lmh0bWwnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC5zdGF0ZShtbWFGaWxlc1VwbG9hZFN0YXRlTmFtZSwge1xuICAgICAgICAgICAgdXJsOiAnL3VwbG9hZCcsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBwYXRoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByb290OiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFGaWxlc1VwbG9hZEN0cmwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9maWxlcy90ZW1wbGF0ZXMvdXBsb2FkLmh0bWwnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC5zdGF0ZSgnc2l0ZS5maWxlcy1jaG9vc2Utc2l0ZScsIHtcbiAgICAgICAgICAgIHVybDogJy9jaG9vc2Utc2l0ZScsXG4gICAgICAgICAgICBwYXJhbXM6wqB7XG4gICAgICAgICAgICAgICAgZmlsZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFGaWxlc0Nob29zZVNpdGVDdHJsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvZmlsZXMvdGVtcGxhdGVzL2Nob29zZXNpdGUuaHRtbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgc2lkZSBtZW51IGFkZG9uLlxuICAgICRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlci5yZWdpc3Rlck5hdkhhbmRsZXIoJ21tYUZpbGVzJywgJyRtbWFGaWxlc0hhbmRsZXJzLnNpZGVNZW51TmF2JywgbW1hRmlsZXNQcmlvcml0eSk7XG5cbn0pXG5cbi5ydW4oZnVuY3Rpb24oJG1tYUZpbGVzLCAkc3RhdGUsICRtbVNpdGVzTWFuYWdlciwgJG1tVXRpbCwgJG1tYUZpbGVzSGVscGVyLCAkaW9uaWNQbGF0Zm9ybSwgJG1tQXBwKSB7XG5cbiAgICAvLyBTZWFyY2ggZm9yIG5ldyBmaWxlcyBzaGFyZWQgd2l0aCB0aGUgdXBsb2FkICh0byB1cGxvYWQpLlxuICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICAgIC8vIEluIGlPUyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNoZWNrIGlmIHRoZXJlIGFyZSBuZXcgZmlsZXMgaW4gdGhlIGFwcCBJbmJveCBmb2xkZXIuXG4gICAgICAgIGZ1bmN0aW9uIHNlYXJjaFRvVXBsb2FkKCkge1xuICAgICAgICAgICAgJG1tQXBwLnJlYWR5KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbW1hRmlsZXMuY2hlY2tJT1NOZXdGaWxlcygpLnRoZW4oZnVuY3Rpb24oZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlcygpLnRoZW4oZnVuY3Rpb24oc2l0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXRlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5maWxlcy5lcnJvcnJlY2VpdmVmaWxlbm9zaXRlcycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaXRlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFGaWxlc0hlbHBlci5zaG93Q29uZmlybUFuZFVwbG9hZEluU2l0ZShmaWxlRW50cnksIHNpdGVzWzBdLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLmZpbGVzLWNob29zZS1zaXRlJywge2ZpbGU6IGZpbGVFbnRyeX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY2hlY2sgaXQgYXQgYXBwIHN0YXJ0IGFuZCB3aGVuIHRoZSBhcHAgaXMgcmVzdW1lZC5cbiAgICAgICAgJGlvbmljUGxhdGZvcm0ub24oJ3Jlc3VtZScsIHNlYXJjaFRvVXBsb2FkKTtcbiAgICAgICAgc2VhcmNoVG9VcGxvYWQoKTtcbiAgICB9XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuZnJvbnRwYWdlJywgW10pXG5cbi5jb25zdGFudCgnbW1hRnJvbnRwYWdlUHJpb3JpdHknLCAxMDAwKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbVNpZGVNZW51RGVsZWdhdGVQcm92aWRlciwgbW1hRnJvbnRwYWdlUHJpb3JpdHkpIHtcbiAgICAvLyBSZWdpc3RlciBzaWRlIG1lbnUgYWRkb24uXG4gICAgLy8kbW1TaWRlTWVudURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJOYXZIYW5kbGVyKCdtbWFGcm9udHBhZ2UnLCAnJG1tYUZyb250UGFnZUhhbmRsZXJzLnNpZGVNZW51TmF2JywgbW1hRnJvbnRwYWdlUHJpb3JpdHkpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5ncmFkZXMnLCBbXSlcblxuLmNvbnN0YW50KCdtbWFHcmFkZXNQcmlvcml0eScsIDQwMClcbi5jb25zdGFudCgnbW1hR3JhZGVzVmlld0dyYWRlc1ByaW9yaXR5JywgNDAwKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkbW1Vc2VyRGVsZWdhdGVQcm92aWRlciwgJG1tQ291cnNlc0RlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIsXG4gICAgICAgICAgICBtbWFHcmFkZXNQcmlvcml0eSwgbW1hR3JhZGVzVmlld0dyYWRlc1ByaW9yaXR5KSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLmdyYWRlcycsIHtcbiAgICAgICAgdXJsOiAnL2dyYWRlcycsXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9ncmFkZXMvdGVtcGxhdGVzL3RhYmxlLmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFHcmFkZXNUYWJsZUN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgY291cnNlOiBudWxsLFxuICAgICAgICAgICAgdXNlcmlkOiBudWxsXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gUmVnaXN0ZXIgcGx1Z2luIG9uIHVzZXIgcHJvZmlsZS5cbiAgICAkbW1Vc2VyRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlclByb2ZpbGVIYW5kbGVyKCdtbWFHcmFkZXM6dmlld0dyYWRlcycsICckbW1hR3JhZGVzSGFuZGxlcnMudmlld0dyYWRlcycsIG1tYUdyYWRlc1ZpZXdHcmFkZXNQcmlvcml0eSk7XG5cbiAgICAvLyBSZWdpc3RlciBjb3Vyc2VzIGNvbnRlbnQgcGx1Z2luLlxuICAgICRtbUNvdXJzZXNEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTmF2SGFuZGxlcignbW1hR3JhZGVzJywgJyRtbWFHcmFkZXNIYW5kbGVycy5jb3Vyc2VzTmF2JywgbW1hR3JhZGVzUHJpb3JpdHkpO1xuXG4gICAgLy8gUmVnaXN0ZXIgY29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hR3JhZGVzJywgJyRtbWFHcmFkZXNIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubWVzc2FnZXMnLCBbJ21tLmNvcmUnXSlcblxuLmNvbnN0YW50KCdtbWFNZXNzYWdlc0Rpc2N1c3Npb25Mb2FkZWRFdmVudCcsICdtbWFfbWVzc2FnZXNfZGlzY3Vzc2lvbl9sb2FkZWQnKVxuLmNvbnN0YW50KCdtbWFNZXNzYWdlc0Rpc2N1c3Npb25MZWZ0RXZlbnQnLCAnbW1hX21lc3NhZ2VzX2Rpc2N1c3Npb25fbGVmdCcpXG4uY29uc3RhbnQoJ21tYU1lc3NhZ2VzUG9sbEludGVydmFsJywgNTAwMClcbi5jb25zdGFudCgnbW1hTWVzc2FnZXNQcmlvcml0eScsIDYwMClcbi5jb25zdGFudCgnbW1hTWVzc2FnZXNTZW5kTWVzc2FnZVByaW9yaXR5JywgMTAwMClcbi5jb25zdGFudCgnbW1hTWVzc2FnZXNBZGRDb250YWN0UHJpb3JpdHknLCA4MDApXG4uY29uc3RhbnQoJ21tYU1lc3NhZ2VzQmxvY2tDb250YWN0UHJpb3JpdHknLCA2MDApXG4uY29uc3RhbnQoJ21tYU1lc3NhZ2VzTmV3TWVzc2FnZUV2ZW50JywgJ21tYS1tZXNzYWdlc19uZXdfbWVzc2FnZScpXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICRtbVVzZXJEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1TaWRlTWVudURlbGVnYXRlUHJvdmlkZXIsIG1tYU1lc3NhZ2VzU2VuZE1lc3NhZ2VQcmlvcml0eSxcbiAgICAgICAgICAgIG1tYU1lc3NhZ2VzQWRkQ29udGFjdFByaW9yaXR5LCBtbWFNZXNzYWdlc0Jsb2NrQ29udGFjdFByaW9yaXR5LCBtbWFNZXNzYWdlc1ByaW9yaXR5LCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1lc3NhZ2VzJywge1xuICAgICAgICB1cmw6ICcvbWVzc2FnZXMnLFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbWVzc2FnZXMvdGVtcGxhdGVzL2luZGV4Lmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNZXNzYWdlc0luZGV4Q3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ3NpdGUubWVzc2FnZXMtZGlzY3Vzc2lvbicsIHtcbiAgICAgICAgdXJsOiAnL21lc3NhZ2VzLWRpc2N1c3Npb24nLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHVzZXJJZDogbnVsbCxcbiAgICAgICAgICAgIHVzZXJGdWxsbmFtZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbWVzc2FnZXMvdGVtcGxhdGVzL2Rpc2N1c3Npb24uaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU1lc3NhZ2VzRGlzY3Vzc2lvbkN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlZ2lzdGVyIHNpZGUgbWVudSBhZGRvbi5cbiAgICAkbW1TaWRlTWVudURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJOYXZIYW5kbGVyKCdtbWFNZXNzYWdlcycsICckbW1hTWVzc2FnZXNIYW5kbGVycy5zaWRlTWVudU5hdicsIG1tYU1lc3NhZ2VzUHJpb3JpdHkpO1xuXG4gICAgLy8gUmVnaXN0ZXIgdXNlciBwcm9maWxlIGFkZG9ucy5cbiAgICAkbW1Vc2VyRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlclByb2ZpbGVIYW5kbGVyKCdtbWFNZXNzYWdlczpzZW5kTWVzc2FnZScsICckbW1hTWVzc2FnZXNIYW5kbGVycy5zZW5kTWVzc2FnZScsIG1tYU1lc3NhZ2VzU2VuZE1lc3NhZ2VQcmlvcml0eSk7XG4gICAgJG1tVXNlckRlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcm9maWxlSGFuZGxlcignbW1hTWVzc2FnZXM6YWRkQ29udGFjdCcsICckbW1hTWVzc2FnZXNIYW5kbGVycy5hZGRDb250YWN0JywgbW1hTWVzc2FnZXNBZGRDb250YWN0UHJpb3JpdHkpO1xuICAgICRtbVVzZXJEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJvZmlsZUhhbmRsZXIoJ21tYU1lc3NhZ2VzOmJsb2NrQ29udGFjdCcsICckbW1hTWVzc2FnZXNIYW5kbGVycy5ibG9ja0NvbnRhY3QnLCBtbWFNZXNzYWdlc0Jsb2NrQ29udGFjdFByaW9yaXR5KTtcblxuICAgIC8vIFJlZ2lzdGVyIGNvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1lc3NhZ2VzJywgJyRtbWFNZXNzYWdlc0hhbmRsZXJzLmxpbmtzSGFuZGxlcicpO1xufSlcblxuLnJ1bihmdW5jdGlvbigkbW1hTWVzc2FnZXMsICRtbUV2ZW50cywgJHN0YXRlLCAkbW1BZGRvbk1hbmFnZXIsICRtbVV0aWwsIG1tQ29yZUV2ZW50TG9naW4pIHtcblxuICAgIC8vIEludmFsaWRhdGUgbWVzc2FnaW5nIGVuYWJsZWQgV1MgY2FsbHMuXG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9naW4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTWVzc2FnZXMuaW52YWxpZGF0ZUVuYWJsZWRDYWNoZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgcHVzaCBub3RpZmljYXRpb24gY2xpY2tzLlxuICAgIHZhciAkbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlID0gJG1tQWRkb25NYW5hZ2VyLmdldCgnJG1tUHVzaE5vdGlmaWNhdGlvbnNEZWxlZ2F0ZScpO1xuICAgIGlmICgkbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlKSB7XG4gICAgICAgICRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUucmVnaXN0ZXJIYW5kbGVyKCdtbWFNZXNzYWdlcycsIGZ1bmN0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgaWYgKCRtbVV0aWwuaXNGYWxzZU9yWmVybyhub3RpZmljYXRpb24ubm90aWYpKSB7XG4gICAgICAgICAgICAgICAgJG1tYU1lc3NhZ2VzLmlzTWVzc2FnaW5nRW5hYmxlZEZvclNpdGUobm90aWZpY2F0aW9uLnNpdGUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbWFNZXNzYWdlcy5pbnZhbGlkYXRlRGlzY3Vzc2lvbnNDYWNoZSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3JlZGlyZWN0Jywge3NpdGVpZDogbm90aWZpY2F0aW9uLnNpdGUsIHN0YXRlOiAnc2l0ZS5tZXNzYWdlcyd9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfYXNzaWduJywgWydtbS5jb3JlJ10pXG5cbi5jb25zdGFudCgnbW1hTW9kQXNzaWduQ29tcG9uZW50JywgJ21tYU1vZEFzc2lnbicpXG4uY29uc3RhbnQoJ21tYU1vZEFzc2lnblN1Ym1pc3Npb25Db21wb25lbnQnLCAnbW1hTW9kQXNzaWduU3VibWlzc2lvbicpXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX2Fzc2lnbicsIHtcbiAgICAgICAgdXJsOiAnL21vZF9hc3NpZ24nLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogbnVsbCxcbiAgICAgICAgICAgIGNvdXJzZWlkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kQXNzaWduSW5kZXhDdHJsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfYXNzaWduL3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfYXNzaWduLXN1Ym1pc3Npb24nLCB7XG4gICAgICAgIHVybDogJy9tb2RfYXNzaWduLXN1Ym1pc3Npb24nLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHN1Ym1pc3Npb246IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RBc3NpZ25TdWJtaXNzaW9uQ3RybCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2Fzc2lnbi90ZW1wbGF0ZXMvc3VibWlzc2lvbi5odG1sJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuICAgICRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJDb250ZW50SGFuZGxlcignbW1hTW9kQXNzaWduJywgJ2Fzc2lnbicsICckbW1hTW9kQXNzaWduSGFuZGxlcnMuY291cnNlQ29udGVudCcpO1xuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hTW9kQXNzaWduJywgJyRtbWFNb2RBc3NpZ25IYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2Jvb2snLCBbJ21tLmNvcmUnXSlcblxuLmNvbnN0YW50KCdtbWFNb2RCb29rQ29tcG9uZW50JywgJ21tYU1vZEJvb2snKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9ib29rJywge1xuICAgICAgdXJsOiAnL21vZF9ib29rJyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgIGNvdXJzZWlkOiBudWxsXG4gICAgICB9LFxuICAgICAgdmlld3M6IHtcbiAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZEJvb2tJbmRleEN0cmwnLFxuICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9ib29rL3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RCb29rJywgJ2Jvb2snLCAnJG1tYU1vZEJvb2tIYW5kbGVycy5jb3Vyc2VDb250ZW50SGFuZGxlcicpO1xuICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlclByZWZldGNoSGFuZGxlcignbW1hTW9kQm9vaycsICdib29rJywgJyRtbWFNb2RCb29rUHJlZmV0Y2hIYW5kbGVyJyk7XG5cbiAgICAvLyBSZWdpc3RlciBjb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFNb2RCb29rJywgJyRtbWFNb2RCb29rSGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9jaGF0JywgW10pXG5cbi5jb25zdGFudCgnbW1hQ2hhdFBvbGxJbnRlcnZhbCcsIDQwMDApXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX2NoYXQnLCB7XG4gICAgICAgIHVybDogJy9tb2RfY2hhdCcsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICAgICAgY291cnNlaWQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RDaGF0SW5kZXhDdHJsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfY2hhdC90ZW1wbGF0ZXMvaW5kZXguaHRtbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX2NoYXQtY2hhdCcsIHtcbiAgICAgICAgdXJsOiAnL21vZF9jaGF0LWNoYXQnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGNoYXRpZDogbnVsbCxcbiAgICAgICAgICAgIGNvdXJzZWlkOiBudWxsLFxuICAgICAgICAgICAgdGl0bGU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RDaGF0Q2hhdEN0cmwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9jaGF0L3RlbXBsYXRlcy9jaGF0Lmh0bWwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RDaGF0JywgJ2NoYXQnLCAnJG1tYU1vZENoYXRIYW5kbGVycy5jb3Vyc2VDb250ZW50Jyk7XG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFNb2RDaGF0JywgJyRtbWFNb2RDaGF0SGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KTsiLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfY2hvaWNlJywgW10pXG5cbi5jb25zdGFudCgnbW1hTW9kQ2hvaWNlUmVzdWx0c05vdCcsIDApXG4uY29uc3RhbnQoJ21tYU1vZENob2ljZVJlc3VsdHNBZnRlckFuc3dlcicsIDEpXG4uY29uc3RhbnQoJ21tYU1vZENob2ljZVJlc3VsdHNBZnRlckNsb3NlJywgMilcbi5jb25zdGFudCgnbW1hTW9kQ2hvaWNlUmVzdWx0c0Fsd2F5cycsIDMpXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX2Nob2ljZScsIHtcbiAgICAgICAgdXJsOiAnL21vZF9jaG9pY2UnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogbnVsbCxcbiAgICAgICAgICAgIGNvdXJzZWlkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kQ2hvaWNlSW5kZXhDdHJsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfY2hvaWNlL3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuICAgICRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJDb250ZW50SGFuZGxlcignbW1hTW9kQ2hvaWNlJywgJ2Nob2ljZScsICckbW1hTW9kQ2hvaWNlSGFuZGxlcnMuY291cnNlQ29udGVudCcpO1xuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hTW9kQ2hvaWNlJywgJyRtbWFNb2RDaG9pY2VIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2ZvbGRlcicsIFsnbW0uY29yZSddKVxuXG4uY29uc3RhbnQoJ21tYU1vZEZvbGRlckNvbXBvbmVudCcsICdtbWFNb2RGb2xkZXInKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9mb2xkZXInLCB7XG4gICAgICB1cmw6ICcvbW9kX2ZvbGRlcicsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICBjb3Vyc2VpZDogbnVsbCxcbiAgICAgICAgc2VjdGlvbmlkOiBudWxsLFxuICAgICAgICBwYXRoOiBudWxsIC8vIEZvciBzdWJmb2xkZXJzLiBVc2UgdGhlIHBhdGggaW5zdGVhZCBvZiBhIGJvb2xlYW4gc28gQW5ndWxhciBkZXRlY3RzIHRoZW0gYXMgZGlmZmVyZW50IHN0YXRlcy5cbiAgICAgIH0sXG4gICAgICB2aWV3czoge1xuICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kRm9sZGVySW5kZXhDdHJsJyxcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfZm9sZGVyL3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RGb2xkZXInLCAnZm9sZGVyJywgJyRtbWFNb2RGb2xkZXJIYW5kbGVycy5jb3Vyc2VDb250ZW50Jyk7XG4gICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJlZmV0Y2hIYW5kbGVyKCdtbWFNb2RGb2xkZXInLCAnZm9sZGVyJywgJyRtbWFNb2RGb2xkZXJQcmVmZXRjaEhhbmRsZXInKTtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZEZvbGRlcicsICckbW1hTW9kRm9sZGVySGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9mb3J1bScsIFtdKVxuXG4uY29uc3RhbnQoJ21tYU1vZEZvcnVtRGlzY1BlclBhZ2UnLCAxMCkgLy8gTWF4IG9mIGRpc2N1c3Npb25zIHBlciBwYWdlLlxuLmNvbnN0YW50KCdtbWFNb2RGb3J1bUNvbXBvbmVudCcsICdtbWFNb2RGb3J1bScpXG4uY29uc3RhbnQoJ21tYU1vZEZvcnVtTmV3RGlzY3Vzc2lvbkV2ZW50JywgJ21tYS1tb2RfZm9ydW1fbmV3X2Rpc2N1c3Npb24nKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9mb3J1bScsIHtcbiAgICAgICAgdXJsOiAnL21vZF9mb3J1bScsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICAgICAgY291cnNlaWQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICdzaXRlJzoge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RGb3J1bURpc2N1c3Npb25zQ3RybCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2ZvcnVtL3RlbXBsYXRlcy9kaXNjdXNzaW9ucy5odG1sJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfZm9ydW0tZGlzY3Vzc2lvbicsIHtcbiAgICAgICAgdXJsOiAnL21vZF9mb3J1bS1kaXNjdXNzaW9uJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBkaXNjdXNzaW9uaWQ6IG51bGwsXG4gICAgICAgICAgICBjaWQ6IG51bGwgLy8gTm90IG5hbWluZyBpdCBjb3Vyc2VpZCBiZWNhdXNlIGl0IGNvbGxpZGVzIHdpdGggJ3NpdGUubW9kX2ZvcnVtJyBwYXJhbSBpbiBzcGxpdC12aWV3LlxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZEZvcnVtRGlzY3Vzc2lvbkN0cmwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9mb3J1bS90ZW1wbGF0ZXMvZGlzY3Vzc2lvbi5odG1sJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfZm9ydW0tbmV3ZGlzY3Vzc2lvbicsIHtcbiAgICAgICAgdXJsOiAnL21vZF9mb3J1bS1uZXdkaXNjdXNzaW9uJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBjaWQ6IG51bGwsIC8vIE5vdCBuYW1pbmcgaXQgY291cnNlaWQgYmVjYXVzZSBpdCBjb2xsaWRlcyB3aXRoICdzaXRlLm1vZF9mb3J1bScgcGFyYW0gaW4gc3BsaXQtdmlldy5cbiAgICAgICAgICAgIGZvcnVtaWQ6IG51bGwsXG4gICAgICAgICAgICBjbWlkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kRm9ydW1OZXdEaXNjdXNzaW9uQ3RybCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2ZvcnVtL3RlbXBsYXRlcy9uZXdkaXNjdXNzaW9uLmh0bWwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RGb3J1bScsICdmb3J1bScsICckbW1hTW9kRm9ydW1IYW5kbGVycy5jb3Vyc2VDb250ZW50Jyk7XG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFNb2RGb3J1bScsICckbW1hTW9kRm9ydW1IYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2dsb3NzYXJ5JywgWydtbS5jb3JlJ10pXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX2dsb3NzYXJ5Jywge1xuICAgICAgdXJsOiAnL21vZF9nbG9zc2FyeScsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICBjb3Vyc2VpZDogbnVsbFxuICAgICAgfSxcbiAgICAgIHZpZXdzOiB7XG4gICAgICAgICdzaXRlJzoge1xuICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RHbG9zc2FyeUluZGV4Q3RybCcsXG4gICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2dsb3NzYXJ5L3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfZ2xvc3NhcnktZW50cnknLCB7XG4gICAgICB1cmw6ICcvbW9kX2dsb3NzYXJ5LWVudHJ5JyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjaWQ6IG51bGwsIC8vIE5vdCBuYW1pbmcgaXQgY291cnNlaWQgYmVjYXVzZSBpdCBjb2xsaWRlcyB3aXRoICdzaXRlLm1vZF9nbG9zc2FyeScgcGFyYW0gaW4gc3BsaXQtdmlldy5cbiAgICAgICAgZW50cnk6IG51bGxcbiAgICAgIH0sXG4gICAgICB2aWV3czoge1xuICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kR2xvc3NhcnlFbnRyeUN0cmwnLFxuICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYWRkb25zL21vZF9nbG9zc2FyeS90ZW1wbGF0ZXMvZW50cnkuaHRtbCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZEdsb3NzYXJ5JywgJ2dsb3NzYXJ5JywgJyRtbWFNb2RHbG9zc2FyeUhhbmRsZXJzLmNvdXJzZUNvbnRlbnQnKTtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZEdsb3NzYXJ5JywgJyRtbWFNb2RHbG9zc2FyeUhhbmRsZXJzLmxpbmtzSGFuZGxlcicpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfaW1zY3AnLCBbJ21tLmNvcmUnXSlcblxuLmNvbnN0YW50KCdtbWFNb2RJbXNjcENvbXBvbmVudCcsICdtbWFNb2RJbXNjcCcpXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX2ltc2NwJywge1xuICAgICAgdXJsOiAnL21vZF9pbXNjcCcsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICBjb3Vyc2VpZDogbnVsbFxuICAgICAgfSxcbiAgICAgIHZpZXdzOiB7XG4gICAgICAgICdzaXRlJzoge1xuICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RJbXNjcEluZGV4Q3RybCcsXG4gICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2ltc2NwL3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RJbXNjcCcsICdpbXNjcCcsICckbW1hTW9kSW1zY3BIYW5kbGVycy5jb3Vyc2VDb250ZW50Jyk7XG4gICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyUHJlZmV0Y2hIYW5kbGVyKCdtbWFNb2RJbXNjcCcsICdpbXNjcCcsICckbW1hTW9kSW1zY3BQcmVmZXRjaEhhbmRsZXInKTtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZEltc2NwJywgJyRtbWFNb2RJbXNjcEhhbmRsZXJzLmxpbmtzSGFuZGxlcicpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfbGFiZWwnLCBbJ21tLmNvcmUnXSlcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcbiAgICAuc3RhdGUoJ3NpdGUubW9kX2xhYmVsJywge1xuICAgICAgICB1cmw6ICcvbW9kX2xhYmVsJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2xhYmVsL3RlbXBsYXRlcy9pbmRleC5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kTGFiZWxJbmRleEN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyKSB7XG4gICAgJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckNvbnRlbnRIYW5kbGVyKCdtbWFNb2RMYWJlbCcsICdsYWJlbCcsICckbW1hTW9kTGFiZWxIYW5kbGVycy5jb3Vyc2VDb250ZW50Jyk7XG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFNb2RMYWJlbCcsICckbW1hTW9kTGFiZWxIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2x0aScsIFtdKVxuXG4uY29uc3RhbnQoJ21tYU1vZEx0aUNvbXBvbmVudCcsICdtbWFNb2RMdGknKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9sdGknLCB7XG4gICAgICAgIHVybDogJy9tb2RfbHRpJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgICAgICBjb3Vyc2VpZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZEx0aUluZGV4Q3RybCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX2x0aS90ZW1wbGF0ZXMvaW5kZXguaHRtbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZEx0aScsICdsdGknLCAnJG1tYU1vZEx0aUhhbmRsZXJzLmNvdXJzZUNvbnRlbnQnKTtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZEx0aScsICckbW1hTW9kTHRpSGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9wYWdlJywgWydtbS5jb3JlJ10pXG5cbi5jb25zdGFudCgnbW1hTW9kUGFnZUNvbXBvbmVudCcsICdtbWFNb2RQYWdlJylcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfcGFnZScsIHtcbiAgICAgIHVybDogJy9tb2RfcGFnZScsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICBjb3Vyc2VpZDogbnVsbFxuICAgICAgfSxcbiAgICAgIHZpZXdzOiB7XG4gICAgICAgICdzaXRlJzoge1xuICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RQYWdlSW5kZXhDdHJsJyxcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfcGFnZS90ZW1wbGF0ZXMvaW5kZXguaHRtbCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIsICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuICAgICRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJDb250ZW50SGFuZGxlcignbW1hTW9kUGFnZScsICdwYWdlJywgJyRtbWFNb2RQYWdlSGFuZGxlcnMuY291cnNlQ29udGVudCcpO1xuICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlclByZWZldGNoSGFuZGxlcignbW1hTW9kUGFnZScsICdwYWdlJywgJyRtbWFNb2RQYWdlUHJlZmV0Y2hIYW5kbGVyJyk7XG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFNb2RQYWdlJywgJyRtbWFNb2RQYWdlSGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9yZXNvdXJjZScsIFsnbW0uY29yZSddKVxuXG4uY29uc3RhbnQoJ21tYU1vZFJlc291cmNlQ29tcG9uZW50JywgJ21tYU1vZFJlc291cmNlJylcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfcmVzb3VyY2UnLCB7XG4gICAgICB1cmw6ICcvbW9kX3Jlc291cmNlJyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgIGNvdXJzZWlkOiBudWxsXG4gICAgICB9LFxuICAgICAgdmlld3M6IHtcbiAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZFJlc291cmNlSW5kZXhDdHJsJyxcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfcmVzb3VyY2UvdGVtcGxhdGVzL2luZGV4Lmh0bWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxufSlcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZFJlc291cmNlJywgJ3Jlc291cmNlJywgJyRtbWFNb2RSZXNvdXJjZUhhbmRsZXJzLmNvdXJzZUNvbnRlbnQnKTtcbiAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJQcmVmZXRjaEhhbmRsZXIoJ21tYU1vZFJlc291cmNlJywgJ3Jlc291cmNlJywgJyRtbWFNb2RSZXNvdXJjZVByZWZldGNoSGFuZGxlcicpO1xuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hTW9kUmVzb3VyY2UnLCAnJG1tYU1vZFJlc291cmNlSGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9zY29ybScsIFsnbW0uY29yZSddKVxuXG4uY29uc3RhbnQoJ21tYU1vZFNjb3JtQ29tcG9uZW50JywgJ21tYU1vZFNjb3JtJylcbi5jb25zdGFudCgnbW1hTW9kU2Nvcm1FdmVudExhdW5jaE5leHRTY28nLCAnbW1hX21vZF9zY29ybV9sYXVuY2hfbmV4dF9zY28nKVxuLmNvbnN0YW50KCdtbWFNb2RTY29ybUV2ZW50TGF1bmNoUHJldlNjbycsICdtbWFfbW9kX3Njb3JtX2xhdW5jaF9wcmV2X3NjbycpXG4uY29uc3RhbnQoJ21tYU1vZFNjb3JtRXZlbnRVcGRhdGVUb2MnLCAnbW1hX21vZF9zY29ybV91cGRhdGVfdG9jJylcbi5jb25zdGFudCgnbW1hTW9kU2Nvcm1FdmVudEdvT2ZmbGluZScsICdtbWFfbW9kX3Njb3JtX2dvX29mZmxpbmUnKVxuLmNvbnN0YW50KCdtbWFNb2RTY29ybUV2ZW50QXV0b21TeW5jZWQnLCAnbW1hX21vZF9zY29ybV9hdXRvbV9zeW5jZWQnKVxuLmNvbnN0YW50KCdtbWFNb2RTY29ybVN5bmNUaW1lJywgMjAwMDAwKSAvLyBJbiBtaWxsaXNlY29uZHMuXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubW9kX3Njb3JtJywge1xuICAgICAgdXJsOiAnL21vZF9zY29ybScsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICBjb3Vyc2VpZDogbnVsbFxuICAgICAgfSxcbiAgICAgIHZpZXdzOiB7XG4gICAgICAgICdzaXRlJzoge1xuICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFNb2RTY29ybUluZGV4Q3RybCcsXG4gICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX3Njb3JtL3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2Rfc2Nvcm0tcGxheWVyJywge1xuICAgICAgdXJsOiAnL21vZF9zY29ybS1wbGF5ZXInLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHNjb3JtOiBudWxsLFxuICAgICAgICBtb2RlOiBudWxsLFxuICAgICAgICBuZXdBdHRlbXB0OiBmYWxzZSxcbiAgICAgICAgb3JnYW5pemF0aW9uSWQ6IG51bGwsXG4gICAgICAgIHNjb0lkOiBudWxsXG4gICAgICB9LFxuICAgICAgdmlld3M6IHtcbiAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZFNjb3JtUGxheWVyQ3RybCcsXG4gICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX3Njb3JtL3RlbXBsYXRlcy9wbGF5ZXIuaHRtbCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIsICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuICAgICRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJDb250ZW50SGFuZGxlcignbW1hTW9kU2Nvcm0nLCAnc2Nvcm0nLCAnJG1tYU1vZFNjb3JtSGFuZGxlcnMuY291cnNlQ29udGVudCcpO1xuICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlclByZWZldGNoSGFuZGxlcignbW1hTW9kU2Nvcm0nLCAnc2Nvcm0nLCAnJG1tYU1vZFNjb3JtUHJlZmV0Y2hIYW5kbGVyJyk7XG4gICAgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlckxpbmtIYW5kbGVyKCdtbWFNb2RTY29ybScsICckbW1hTW9kU2Nvcm1IYW5kbGVycy5saW5rc0hhbmRsZXInKTtcbn0pXG5cbi5ydW4oZnVuY3Rpb24oJHRpbWVvdXQsICRtbWFNb2RTY29ybVN5bmMsICRtbUFwcCwgJG1tRXZlbnRzLCAkbW1TaXRlLCBtbUNvcmVFdmVudExvZ2luKSB7XG4gICAgdmFyIGxhc3RFeGVjdXRpb24gPSAwLFxuICAgICAgICBleGVjdXRpbmcgPSBmYWxzZSxcbiAgICAgICAgYWxsU2l0ZXNDYWxsZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHN5bmNTY29ybXMoYWxsU2l0ZXMpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIGlmICghYWxsU2l0ZXMgJiYgISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IGNvbnNlY3V0aXZlIGFuZCBzaW11bHRhbmVvdXMgZXhlY3V0aW9ucy4gQSBzeW5jIHByb2Nlc3Mgc2hvdWxkbid0IHRha2UgbW9yZSB0aGFuIGEgZmV3IG1pbnV0ZXMsXG4gICAgICAgIC8vIHNvIGlmIGl0J3MgYmVlbiBtb3JlIHRoYW4gNSBtaW51dGVzIHNpbmNlIHRoZSBsYXN0IGV4ZWN1dGlvbiB3ZSdsbCBpZ25vcmUgdGhlIGV4ZWN1dGluZyB2YWx1ZS5cbiAgICAgICAgaWYgKG5vdyAtIDUwMDAgPiBsYXN0RXhlY3V0aW9uICYmICghZXhlY3V0aW5nIHx8IG5vdyAtIDMwMDAwMCA+IGxhc3RFeGVjdXRpb24pKSB7XG4gICAgICAgICAgICBsYXN0RXhlY3V0aW9uID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBleGVjdXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHsgLy8gTWlub3IgZGVsYXkganVzdCB0byBtYWtlIHN1cmUgbmV0d29yayBpcyBmdWxseSBlc3RhYmxpc2hlZC5cbiAgICAgICAgICAgICAgICAkbW1hTW9kU2Nvcm1TeW5jLnN5bmNBbGxTY29ybXMoYWxsU2l0ZXMgPyB1bmRlZmluZWQgOiAkbW1TaXRlLmdldElkKCkpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkbW1BcHAucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN5bmNTY29ybXMoZmFsc2UpO1xuICAgICAgICB9LCBmYWxzZSk7IC8vIENvcmRvdmEgZXZlbnQuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN5bmNTY29ybXMoZmFsc2UpO1xuICAgICAgICB9LCBmYWxzZSk7IC8vIEhUTUw1IGV2ZW50LlxuXG4gICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIC8vIEFwcCB3YXMgc3RhcnRlZCB3aXRob3V0IGFueSBzaXRlIGxvZ2dlZCBpbi4gVHJ5IHRvIHN5bmMgYWxsIHNpdGVzLlxuICAgICAgICAgICAgYWxsU2l0ZXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAgICAgc3luY1Njb3Jtcyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9naW4sIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWxsU2l0ZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFhbGxTaXRlc0NhbGxlZCkge1xuICAgICAgICAgICAgLy8gQXBwIHN0YXJ0ZWQgd2l0aCBhIHNpdGUgbG9nZ2VkIGluLiBUcnkgdG8gc3luYyBhbGwgc2l0ZXMuXG4gICAgICAgICAgICBhbGxTaXRlc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBhbGxTaXRlcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgIHN5bmNTY29ybXMoYWxsU2l0ZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3N1cnZleScsIFtdKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAkc3RhdGVQcm92aWRlclxuXG4gICAgLnN0YXRlKCdzaXRlLm1vZF9zdXJ2ZXknLCB7XG4gICAgICAgIHVybDogJy9tb2Rfc3VydmV5JyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgICAgICBjb3Vyc2VpZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgJ3NpdGUnOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU1vZFN1cnZleUluZGV4Q3RybCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbW9kX3N1cnZleS90ZW1wbGF0ZXMvaW5kZXguaHRtbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIsICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIpIHtcbiAgICAkbW1Db3Vyc2VEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29udGVudEhhbmRsZXIoJ21tYU1vZFN1cnZleScsICdzdXJ2ZXknLCAnJG1tYU1vZFN1cnZleUhhbmRsZXJzLmNvdXJzZUNvbnRlbnQnKTtcbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZFN1cnZleScsICckbW1hTW9kU3VydmV5SGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF91cmwnLCBbJ21tLmNvcmUnXSlcblxuLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcikge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5tb2RfdXJsJywge1xuICAgICAgdXJsOiAnL21vZF91cmwnLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1vZHVsZTogbnVsbCxcbiAgICAgICAgY291cnNlaWQ6IG51bGxcbiAgICAgIH0sXG4gICAgICB2aWV3czoge1xuICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTW9kVXJsSW5kZXhDdHJsJyxcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfdXJsL3RlbXBsYXRlcy9pbmRleC5odG1sJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJG1tQ291cnNlRGVsZWdhdGVQcm92aWRlciwgJG1tQ29udGVudExpbmtzRGVsZWdhdGVQcm92aWRlcikge1xuICAgICRtbUNvdXJzZURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJDb250ZW50SGFuZGxlcignbW1hTW9kVXJsJywgJ3VybCcsICckbW1hTW9kVXJsSGFuZGxlcnMuY291cnNlQ29udGVudEhhbmRsZXInKTtcblxuICAgIC8vIFJlZ2lzdGVyIGNvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTGlua0hhbmRsZXIoJ21tYU1vZFVybCcsICckbW1hTW9kVXJsSGFuZGxlcnMubGlua3NIYW5kbGVyJyk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm5vdGVzJywgW10pXG5cbi5jb25zdGFudCgnbW1hTm90ZXNQcmlvcml0eScsIDIwMClcbi5jb25zdGFudCgnbW1hTm90ZXNBZGROb3RlUHJpb3JpdHknLCAyMDApXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICRtbVVzZXJEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db3Vyc2VzRGVsZWdhdGVQcm92aWRlciwgbW1hTm90ZXNQcmlvcml0eSwgbW1hTm90ZXNBZGROb3RlUHJpb3JpdHkpIHtcblxuICAgICRzdGF0ZVByb3ZpZGVyXG5cbiAgICAuc3RhdGUoJ3NpdGUubm90ZXMtdHlwZXMnLCB7XG4gICAgICAgIHVybDogJy9ub3Rlcy10eXBlcycsXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9ub3Rlcy90ZW1wbGF0ZXMvdHlwZXMuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYU5vdGVzVHlwZXNDdHJsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGNvdXJzZTogbnVsbFxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC5zdGF0ZSgnc2l0ZS5ub3Rlcy1saXN0Jywge1xuICAgICAgICB1cmw6ICcvbm90ZXMtbGlzdCcsXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9ub3Rlcy90ZW1wbGF0ZXMvbGlzdC5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnbW1hTm90ZXNMaXN0Q3RybCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBjb3Vyc2VpZDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgcGx1Z2luIG9uIHVzZXIgcHJvZmlsZS5cbiAgICAkbW1Vc2VyRGVsZWdhdGVQcm92aWRlci5yZWdpc3RlclByb2ZpbGVIYW5kbGVyKCdtbWFOb3RlczphZGROb3RlJywgJyRtbWFOb3Rlc0hhbmRsZXJzLmFkZE5vdGUnLCBtbWFOb3Rlc0FkZE5vdGVQcmlvcml0eSk7XG5cbiAgICAvLyBSZWdpc3RlciBjb3Vyc2VzIGhhbmRsZXIuXG4gICAgJG1tQ291cnNlc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJOYXZIYW5kbGVyKCdtbWFOb3RlcycsICckbW1hTm90ZXNIYW5kbGVycy5jb3Vyc2VzTmF2JywgbW1hTm90ZXNQcmlvcml0eSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm5vdGlmaWNhdGlvbnMnLCBbXSlcblxuLmNvbnN0YW50KCdtbWFOb3RpZmljYXRpb25zTGlzdExpbWl0JywgMjApIC8vIE1heCBvZiBub3RpZmljYXRpb25zIHRvIHJldHJpZXZlIGluIGVhY2ggV1MgY2FsbC5cbi5jb25zdGFudCgnbW1hTm90aWZpY2F0aW9uc1ByaW9yaXR5JywgODAwKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkbW1TaWRlTWVudURlbGVnYXRlUHJvdmlkZXIsIG1tYU5vdGlmaWNhdGlvbnNQcmlvcml0eSkge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcblxuICAgIC5zdGF0ZSgnc2l0ZS5ub3RpZmljYXRpb25zJywge1xuICAgICAgICB1cmw6ICcvbm90aWZpY2F0aW9ucycsXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9ub3RpZmljYXRpb25zL3RlbXBsYXRlcy9saXN0Lmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdtbWFOb3RpZmljYXRpb25zTGlzdEN0cmwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlZ2lzdGVyIHNpZGUgbWVudSBhZGRvbi5cbiAgICAkbW1TaWRlTWVudURlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJOYXZIYW5kbGVyKCdtbWFOb3RpZmljYXRpb25zJywgJyRtbWFOb3RpZmljYXRpb25zSGFuZGxlcnMuc2lkZU1lbnVOYXYnLCBtbWFOb3RpZmljYXRpb25zUHJpb3JpdHkpO1xufSlcblxuLnJ1bihmdW5jdGlvbigkbG9nLCAkbW1hTm90aWZpY2F0aW9ucywgJG1tVXRpbCwgJHN0YXRlLCAkbW1BZGRvbk1hbmFnZXIpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1hTm90aWZpY2F0aW9ucycpO1xuXG4gICAgLy8gUmVnaXN0ZXIgcHVzaCBub3RpZmljYXRpb24gY2xpY2tzLlxuICAgIHZhciAkbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlID0gJG1tQWRkb25NYW5hZ2VyLmdldCgnJG1tUHVzaE5vdGlmaWNhdGlvbnNEZWxlZ2F0ZScpO1xuICAgIGlmICgkbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlKSB7XG4gICAgICAgICRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUucmVnaXN0ZXJIYW5kbGVyKCdtbWFOb3RpZmljYXRpb25zJywgZnVuY3Rpb24obm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAoJG1tVXRpbC5pc1RydWVPck9uZShub3RpZmljYXRpb24ubm90aWYpKSB7XG4gICAgICAgICAgICAgICAgJG1tYU5vdGlmaWNhdGlvbnMuaXNQbHVnaW5FbmFibGVkRm9yU2l0ZShub3RpZmljYXRpb24uc2l0ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tYU5vdGlmaWNhdGlvbnMuaW52YWxpZGF0ZU5vdGlmaWNhdGlvbnNMaXN0KCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygncmVkaXJlY3QnLCB7c2l0ZWlkOiBub3RpZmljYXRpb24uc2l0ZSwgc3RhdGU6ICdzaXRlLm5vdGlmaWNhdGlvbnMnfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLnBhcnRpY2lwYW50cycsIFtdKVxuXG4uY29uc3RhbnQoJ21tYVBhcnRpY2lwYW50c0xpc3RMaW1pdCcsIDUwKSAvLyBNYXggb2YgcGFydGljaXBhbnRzIHRvIHJldHJpZXZlIGluIGVhY2ggV1MgY2FsbC5cbi5jb25zdGFudCgnbW1hUGFydGljaXBhbnRzUHJpb3JpdHknLCA2MDApXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICRtbUNvdXJzZXNEZWxlZ2F0ZVByb3ZpZGVyLCAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZVByb3ZpZGVyLCBtbWFQYXJ0aWNpcGFudHNQcmlvcml0eSkge1xuXG4gICAgJHN0YXRlUHJvdmlkZXJcbiAgICAgICAgLnN0YXRlKCdzaXRlLnBhcnRpY2lwYW50cycsIHtcbiAgICAgICAgICAgIHVybDogJy9wYXJ0aWNpcGFudHMnLFxuICAgICAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgICAgICAnc2l0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ21tYVBhcnRpY2lwYW50c0xpc3RDdHJsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvcGFydGljaXBhbnRzL3RlbXBsYXRlcy9saXN0Lmh0bWwnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGNvdXJzZTogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICRtbUNvdXJzZXNEZWxlZ2F0ZVByb3ZpZGVyLnJlZ2lzdGVyTmF2SGFuZGxlcignbW1hUGFydGljaXBhbnRzJywgJyRtbWFQYXJ0aWNpcGFudHNIYW5kbGVycy5jb3Vyc2VzTmF2SGFuZGxlcicsXG4gICAgICAgICAgICAgICAgbW1hUGFydGljaXBhbnRzUHJpb3JpdHkpO1xuXG4gICAgLy8gUmVnaXN0ZXIgY29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlUHJvdmlkZXIucmVnaXN0ZXJMaW5rSGFuZGxlcignbW1hUGFydGljaXBhbnRzJywgJyRtbWFQYXJ0aWNpcGFudHNIYW5kbGVycy5saW5rc0hhbmRsZXInKTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9ucycsIFtdKVxuXG4uY29uc3RhbnQoJ21tYVB1c2hOb3RpZmljYXRpb25zQ29tcG9uZW50JywgJ21tYVB1c2hOb3RpZmljYXRpb25zJylcblxuLnJ1bihmdW5jdGlvbigkbW1hUHVzaE5vdGlmaWNhdGlvbnMsICRpb25pY1BsYXRmb3JtLCAkcm9vdFNjb3BlLCAkbW1FdmVudHMsICRtbUxvY2FsTm90aWZpY2F0aW9ucywgbW1Db3JlRXZlbnRMb2dpbixcbiAgICAgICAgICAgIG1tYVB1c2hOb3RpZmljYXRpb25zQ29tcG9uZW50LCBtbUNvcmVFdmVudFNpdGVEZWxldGVkKSB7XG5cbiAgICAvLyBSZWdpc3RlciBkZXZpY2Ugb24gR0NNIG9yIEFQTlMgc2VydmVyLlxuICAgICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hUHVzaE5vdGlmaWNhdGlvbnMucmVnaXN0ZXJEZXZpY2UoKTtcbiAgICB9KTtcblxuICAgIC8vIE5vdGlmaWNhdGlvbiByZWNlaXZlZC5cbiAgICAkcm9vdFNjb3BlLiRvbignJGNvcmRvdmFQdXNoOm5vdGlmaWNhdGlvblJlY2VpdmVkJywgZnVuY3Rpb24oZSwgbm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgICAgICAgJG1tYVB1c2hOb3RpZmljYXRpb25zLm9uR0NNUmVjZWl2ZWQobm90aWZpY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICAgICAgICAkbW1hUHVzaE5vdGlmaWNhdGlvbnMub25NZXNzYWdlUmVjZWl2ZWQobm90aWZpY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgZGV2aWNlIG9uIE1vb2RsZSBzaXRlIHdoZW4gbG9naW4uXG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9naW4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hUHVzaE5vdGlmaWNhdGlvbnMucmVnaXN0ZXJEZXZpY2VPbk1vb2RsZSgpO1xuICAgIH0pO1xuXG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50U2l0ZURlbGV0ZWQsIGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgJG1tYVB1c2hOb3RpZmljYXRpb25zLnVucmVnaXN0ZXJEZXZpY2VPbk1vb2RsZShzaXRlKTtcbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiBmb3IgbG9jYWwgbm90aWZpY2F0aW9uIGNsaWNrcyAoZ2VuZXJhdGVkIGJ5IHRoZSBhcHApLlxuICAgICRtbUxvY2FsTm90aWZpY2F0aW9ucy5yZWdpc3RlckNsaWNrKG1tYVB1c2hOb3RpZmljYXRpb25zQ29tcG9uZW50LCAkbW1hUHVzaE5vdGlmaWNhdGlvbnMubm90aWZpY2F0aW9uQ2xpY2tlZCk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLnJlbW90ZXN0eWxlcycsIFtdKVxuXG4uY29uc3RhbnQoJ21tYVJlbW90ZVN0eWxlc0NvbXBvbmVudCcsICdtbWFSZW1vdGVTdHlsZXMnKVxuXG4ucnVuKGZ1bmN0aW9uKCRtbUV2ZW50cywgbW1Db3JlRXZlbnRMb2dpbiwgbW1Db3JlRXZlbnRMb2dvdXQsIG1tQ29yZUV2ZW50U2l0ZUFkZGVkLCBtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCAkbW1hUmVtb3RlU3R5bGVzLFxuICAgICAgICAgICAgJG1tU2l0ZSkge1xuXG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50U2l0ZUFkZGVkLCAkbW1hUmVtb3RlU3R5bGVzLmxvYWQpO1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFNpdGVVcGRhdGVkLCBmdW5jdGlvbihzaXRlaWQpIHtcbiAgICAgICAgLy8gTG9hZCBvbmx5IGlmIGN1cnJlbnQgc2l0ZSB3YXMgdXBkYXRlZC5cbiAgICAgICAgaWYgKHNpdGVpZCA9PT0gJG1tU2l0ZS5nZXRJZCgpKSB7XG4gICAgICAgICAgICAkbW1hUmVtb3RlU3R5bGVzLmxvYWQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudExvZ2luLCAkbW1hUmVtb3RlU3R5bGVzLmxvYWQpO1xuXG4gICAgLy8gUmVtb3ZlIGFkZGVkIHN0eWxlcyBvbiBsb2dvdXQuXG4gICAgJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50TG9nb3V0LCAkbW1hUmVtb3RlU3R5bGVzLmNsZWFyKTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuY2FsZW5kYXInKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIGFuIGV2ZW50LlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLmNhbGVuZGFyXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hQ2FsZW5kYXJFdmVudEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYUNhbGVuZGFyRXZlbnRDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkbG9nLCAkc3RhdGVQYXJhbXMsICRtbWFDYWxlbmRhciwgJG1tVXRpbCwgJG1tQ291cnNlLCAkbW1Db3Vyc2VzLFxuICAgICAgICAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbWFDYWxlbmRhckV2ZW50Q3RybCcpO1xuXG4gICAgdmFyIGV2ZW50aWQgPSBwYXJzZUludCgkc3RhdGVQYXJhbXMuaWQpO1xuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdGhhdCBmZXRjaGVzIHRoZSBldmVudCBhbmQgdXBkYXRlcyB0aGUgc2NvcGUuXG4gICAgZnVuY3Rpb24gZmV0Y2hFdmVudChyZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiAkbW1hQ2FsZW5kYXIuZ2V0RXZlbnQoZXZlbnRpZCwgcmVmcmVzaCkudGhlbihmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAkbW1hQ2FsZW5kYXIuZm9ybWF0RXZlbnREYXRhKGUpO1xuICAgICAgICAgICAgJHNjb3BlLmV2ZW50ID0gZTtcbiAgICAgICAgICAgICRzY29wZS50aXRsZSA9IGUubmFtZTtcblxuICAgICAgICAgICAgaWYgKGUubW9kdWxlaWNvbikge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgYSBtb2R1bGUgZXZlbnQsIHRyYW5zbGF0ZSB0aGUgbW9kdWxlIG5hbWUgdG8gdGhlIGN1cnJlbnQgbGFuZ3VhZ2UuXG4gICAgICAgICAgICAgICAgJG1tQ291cnNlLnRyYW5zbGF0ZU1vZHVsZU5hbWUoZS5tb2R1bGVuYW1lKS50aGVuKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignbW0uY29yZS5tb2QnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubW9kdWxlbmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGUuY291cnNlaWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIGNvdXJzZSBldmVudCwgcmV0cmlldmUgdGhlIGNvdXJzZSBuYW1lLlxuICAgICAgICAgICAgICAgICRtbUNvdXJzZXMuZ2V0VXNlckNvdXJzZShlLmNvdXJzZWlkLCB0cnVlKS50aGVuKGZ1bmN0aW9uKGNvdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY291cnNlbmFtZSA9IGNvdXJzZS5mdWxsbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5jYWxlbmRhci5lcnJvcmxvYWRldmVudCcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBHZXQgZXZlbnQuXG4gICAgZmV0Y2hFdmVudCgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5ldmVudExvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBQdWxsIHRvIHJlZnJlc2guXG4gICAgJHNjb3BlLnJlZnJlc2hFdmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmZXRjaEV2ZW50KHRydWUpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLm5vdGlmaWNhdGlvbnNFbmFibGVkID0gJG1tTG9jYWxOb3RpZmljYXRpb25zLmlzQXZhaWxhYmxlKCk7XG4gICAgaWYgKCRzY29wZS5ub3RpZmljYXRpb25zRW5hYmxlZCkge1xuXG4gICAgICAgICRtbWFDYWxlbmRhci5nZXRFdmVudE5vdGlmaWNhdGlvblRpbWUoZXZlbnRpZCkudGhlbihmdW5jdGlvbihub3RpZmljYXRpb250aW1lKSB7XG4gICAgICAgICAgICAkc2NvcGUubm90aWZpY2F0aW9uID0geyAvLyBVc2UgYW4gb2JqZWN0LCBvdGhlcndpc2UgY2hhbmdlcyBhcmUgbm90IHJlZmxlY3RlZC5cbiAgICAgICAgICAgICAgICB0aW1lOiBTdHJpbmcobm90aWZpY2F0aW9udGltZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzY29wZS51cGRhdGVOb3RpZmljYXRpb25UaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHBhcnNlSW50KCRzY29wZS5ub3RpZmljYXRpb24udGltZSk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHRpbWUpICYmICRzY29wZS5ldmVudCAmJiAkc2NvcGUuZXZlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAkbW1hQ2FsZW5kYXIudXBkYXRlTm90aWZpY2F0aW9uVGltZSgkc2NvcGUuZXZlbnQsIHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuY2FsZW5kYXInKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIGNhbGVuZGFyIGV2ZW50cy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYUNhbGVuZGFyTGlzdEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYUNhbGVuZGFyTGlzdEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJGxvZywgJHN0YXRlLCAkbW1hQ2FsZW5kYXIsICRtbVV0aWwsICRpb25pY0hpc3RvcnksXG4gICAgICAgIG1tYUNhbGVuZGFyRGF5c0ludGVydmFsKSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1hQ2FsZW5kYXJMaXN0Q3RybCcpO1xuXG4gICAgdmFyIGRheXNMb2FkZWQsXG4gICAgICAgIGVtcHR5RXZlbnRzVGltZXM7IC8vIFZhcmlhYmxlIHRvIGlkZW50aWZ5IGNvbnNlY3V0aXZlIGNhbGxzIHJldHVybmluZyAwIGV2ZW50cy5cblxuICAgIGlmICgkc3RhdGVQYXJhbXMuZXZlbnRpZCkge1xuICAgICAgICAvLyBXZSBhcnJpdmVkIGhlcmUgdmlhIG5vdGlmaWNhdGlvbiBjbGljaywgbGV0J3MgY2xlYXIgaGlzdG9yeSBhbmQgcmVkaXJlY3QgdG8gZXZlbnQgZGV0YWlscy5cbiAgICAgICAgJGlvbmljSGlzdG9yeS5jbGVhckhpc3RvcnkoKTtcbiAgICAgICAgJHN0YXRlLmdvKCdzaXRlLmNhbGVuZGFyLWV2ZW50Jywge2lkOiAkc3RhdGVQYXJhbXMuZXZlbnRpZH0pO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgdmFyaWFibGVzLlxuICAgIGZ1bmN0aW9uIGluaXRWYXJzKCkge1xuICAgICAgICBkYXlzTG9hZGVkID0gMDtcbiAgICAgICAgZW1wdHlFdmVudHNUaW1lcyA9IDA7XG4gICAgICAgICRzY29wZS5ldmVudHMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0aGF0IGZldGNoZXMgdGhlIGV2ZW50cyBhbmQgdXBkYXRlcyB0aGUgc2NvcGUuXG4gICAgZnVuY3Rpb24gZmV0Y2hFdmVudHMocmVmcmVzaCkge1xuICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgaW5pdFZhcnMoKTtcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUuY2FuTG9hZE1vcmUgPSBmYWxzZTsgLy8gU2V0IGl0IHRvIGZhbHNlIHRvIHByZXZlbnQgY29uc2VjdXRpdmUgY2FsbHMuXG5cbiAgICAgICAgcmV0dXJuICRtbWFDYWxlbmRhci5nZXRFdmVudHMoZGF5c0xvYWRlZCwgbW1hQ2FsZW5kYXJEYXlzSW50ZXJ2YWwsIHJlZnJlc2gpLnRoZW4oZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgICAgICAgICBkYXlzTG9hZGVkICs9IG1tYUNhbGVuZGFyRGF5c0ludGVydmFsO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVtcHR5RXZlbnRzVGltZXMrKztcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHlFdmVudHNUaW1lcyA+IDUpIHsgLy8gU3RvcCBleGVjdXRpb24gaWYgd2UgcmV0cmlldmUgZW1wdHkgbGlzdCA2IGNvbnNlY3V0aXZlIHRpbWVzLlxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2FuTG9hZE1vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmV2ZW50c0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gZXZlbnRzIHJldHVybmVkLCBsb2FkIG5leHQgZXZlbnRzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hFdmVudHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChldmVudHMsICRtbWFDYWxlbmRhci5mb3JtYXRFdmVudERhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5ldmVudHMgPSBldmVudHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmV2ZW50cyA9ICRzY29wZS5ldmVudHMuY29uY2F0KGV2ZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRzY29wZS5jb3VudCA9ICRzY29wZS5ldmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICRzY29wZS5ldmVudHNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBub3RpZmljYXRpb25zIGZvciB0aGUgZXZlbnRzIHJldHJpZXZlZCAobWlnaHQgaGF2ZSBuZXcgZXZlbnRzKS5cbiAgICAgICAgICAgICAgICAkbW1hQ2FsZW5kYXIuc2NoZWR1bGVFdmVudHNOb3RpZmljYXRpb25zKGV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLmNhbGVuZGFyLmVycm9ybG9hZGV2ZW50cycsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLmV2ZW50c0xvYWRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGluaXRWYXJzKCk7XG4gICAgJHNjb3BlLmNvdW50ID0gMDtcblxuICAgIC8vIEdldCBmaXJzdCBldmVudHMuXG4gICAgZmV0Y2hFdmVudHMoKTtcblxuICAgIC8vIExvYWQgbW9yZSBldmVudHMuXG4gICAgJHNjb3BlLmxvYWRNb3JlRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZldGNoRXZlbnRzKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwuaW5maW5pdGVTY3JvbGxDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gUHVsbCB0byByZWZyZXNoLlxuICAgICRzY29wZS5yZWZyZXNoRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFDYWxlbmRhci5pbnZhbGlkYXRlRXZlbnRzTGlzdCgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmZXRjaEV2ZW50cyh0cnVlKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuY2FsZW5kYXInKVxuXG4uY29uc3RhbnQoJ21tYUNhbGVuZGFyRXZlbnRzU3RvcmUnLCAnY2FsZW5kYXJfZXZlbnRzJylcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1TaXRlc0ZhY3RvcnlQcm92aWRlciwgbW1hQ2FsZW5kYXJFdmVudHNTdG9yZSkge1xuICAgIHZhciBzdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1tYUNhbGVuZGFyRXZlbnRzU3RvcmUsXG4gICAgICAgICAgICBrZXlQYXRoOiAnaWQnLFxuICAgICAgICAgICAgaW5kZXhlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ25vdGlmaWNhdGlvbnRpbWUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgXTtcbiAgICAkbW1TaXRlc0ZhY3RvcnlQcm92aWRlci5yZWdpc3RlclN0b3JlcyhzdG9yZXMpO1xufSlcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGhhbmRsZSBjYWxlbmRhciBldmVudHMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hQ2FsZW5kYXJcbiAqL1xuLmZhY3RvcnkoJyRtbWFDYWxlbmRhcicsIGZ1bmN0aW9uKCRsb2csICRxLCAkbW1TaXRlLCAkbW1VdGlsLCAkbW1Db3Vyc2VzLCAkbW1Hcm91cHMsICRtbUNvdXJzZSwgJG1tTG9jYWxOb3RpZmljYXRpb25zLFxuICAgICAgICAkbW1TaXRlc01hbmFnZXIsIG1tQ29yZVNlY29uZHNEYXksIG1tYUNhbGVuZGFyRGF5c0ludGVydmFsLCBtbWFDYWxlbmRhckV2ZW50c1N0b3JlLCBtbWFDYWxlbmRhckRlZmF1bHROb3RpZlRpbWUsXG4gICAgICAgIG1tYUNhbGVuZGFyQ29tcG9uZW50KSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYUNhbGVuZGFyJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBjYWxlbmRhckltZ1BhdGggPSAnYWRkb25zL2NhbGVuZGFyL2ltZy8nLFxuICAgICAgICBldmVudGljb25zID0ge1xuICAgICAgICAgICAgJ2NvdXJzZSc6IGNhbGVuZGFySW1nUGF0aCArICdjb3Vyc2VldmVudC5zdmcnLFxuICAgICAgICAgICAgJ2dyb3VwJzogY2FsZW5kYXJJbWdQYXRoICsgJ2dyb3VwZXZlbnQuc3ZnJyxcbiAgICAgICAgICAgICdzaXRlJzogY2FsZW5kYXJJbWdQYXRoICsgJ3NpdGVldmVudC5zdmcnLFxuICAgICAgICAgICAgJ3VzZXInOiBjYWxlbmRhckltZ1BhdGggKyAndXNlcmV2ZW50LnN2ZydcbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGV2ZW50cyBsaXN0IFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRheXNUb1N0YXJ0ICBOdW1iZXIgb2YgZGF5cyBmcm9tIG5vdyB0byBzdGFydCBnZXR0aW5nIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF5c0ludGVydmFsIE51bWJlciBvZiBkYXlzIGJldHdlZW4gdGltZXN0YXJ0IGFuZCB0aW1lZW5kLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEV2ZW50c0xpc3RDYWNoZUtleShkYXlzVG9TdGFydCwgZGF5c0ludGVydmFsKSB7XG4gICAgICAgIHJldHVybiAnbW1hQ2FsZW5kYXI6ZXZlbnRzOicgKyBkYXlzVG9TdGFydCArICc6JyArIGRheXNJbnRlcnZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBhIHNpbmdsZSBldmVudCBXUyBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIEV2ZW50IElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEV2ZW50Q2FjaGVLZXkoaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFDYWxlbmRhcjpldmVudHM6JyArIGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29tbW9uIHBhcnQgb2YgdGhlIGNhY2hlIGtleXMgZm9yIGV2ZW50cyBXUyBjYWxscy4gSW52YWxpZGF0ZSB0aGUgd2hvbGUgbGlzdCBhbHNvIGludmFsaWRhdGVzIGFsbCB0aGVcbiAgICAgKiBzaW5nbGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRzQ29tbW9uQ2FjaGVLZXkoKSB7XG4gICAgICAgIHJldHVybiAnbW1hQ2FsZW5kYXI6ZXZlbnRzOic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcmUgZXZlbnRzIGluIGxvY2FsIERCLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZXZlbnRzICBFdmVudHMgdG8gc3RvcmUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZWlkXSBJRCBvZiB0aGUgc2l0ZSB0aGUgZXZlbnQgYmVsb25ncyB0by4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGV2ZW50cyBhcmUgc3RvcmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3JlRXZlbnRzSW5Mb2NhbERCKGV2ZW50cywgc2l0ZWlkKSB7XG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBkYiA9IHNpdGUuZ2V0RGIoKTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGV2ZW50IG5vdGlmaWNhdGlvbiB0aW1lIHRvIHByZXZlbnQgb3ZlcnJpZGluZyBpdCBpbiBEQi5cbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYuZ2V0RXZlbnROb3RpZmljYXRpb25UaW1lKGV2ZW50LmlkLCBzaXRlaWQpLnRoZW4oZnVuY3Rpb24odGltZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5ub3RpZmljYXRpb250aW1lID0gdGltZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLmluc2VydChtbWFDYWxlbmRhckV2ZW50c1N0b3JlLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZm9ybWF0IHNvbWUgZXZlbnQgZGF0YSB0byBiZSByZW5kZXJlZC4gQWRkcyBwcm9wZXJ0aWVzICdzdGFydCcsICdlbmQnLCAnaWNvbidcbiAgICAgKiBhbmQgKGlmIGl0J3MgYSBtb2R1bGUgZXZlbnQpICdtb2R1bGVpY29uJy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNhbGVuZGFyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDYWxlbmRhciNmb3JtYXRFdmVudERhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBFdmVudCB0byBmb3JtYXQuXG4gICAgICovXG4gICAgc2VsZi5mb3JtYXRFdmVudERhdGEgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBpY29uID0gc2VsZi5nZXRFdmVudEljb24oZS5ldmVudHR5cGUpO1xuICAgICAgICBpZiAoaWNvbiA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgYSBtb2R1bGUgZXZlbnQuXG4gICAgICAgICAgICBpY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoZS5tb2R1bGVuYW1lKTtcbiAgICAgICAgICAgIGUubW9kdWxlaWNvbiA9IGljb247XG4gICAgICAgIH1cbiAgICAgICAgZS5pY29uID0gaWNvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgY2FsZW5kYXIgZXZlbnQgZnJvbSBzZXJ2ZXIgb3IgY2FjaGUuIElmIHRoZSBzZXJ2ZXIgcmVxdWVzdCBmYWlscyBhbmQgZGF0YSBpcyBub3QgY2FjaGVkLFxuICAgICAqIHRyeSB0byBnZXQgaXQgZnJvbSBsb2NhbCBEQi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNhbGVuZGFyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDYWxlbmRhciNnZXRFdmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgaWQgICAgICAgIEV2ZW50IElELlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlZnJlc2hdIFRydWUgd2hlbiB3ZSBzaG91bGQgdXBkYXRlIHRoZSBldmVudCBkYXRhLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZXZlbnQgZGF0YSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRFdmVudCA9IGZ1bmN0aW9uKGlkLCByZWZyZXNoKSB7XG4gICAgICAgIHZhciBwcmVzZXRzID0ge30sXG4gICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgIFwib3B0aW9uc1t1c2VyZXZlbnRzXVwiOiAwLFxuICAgICAgICAgICAgICAgIFwib3B0aW9uc1tzaXRlZXZlbnRzXVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZXZlbnRzW2V2ZW50aWRzXVswXVwiOiBpZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICBwcmVzZXRzLmNhY2hlS2V5ID0gZ2V0RXZlbnRDYWNoZUtleShpZCk7XG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICBwcmVzZXRzLmdldEZyb21DYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ2NvcmVfY2FsZW5kYXJfZ2V0X2NhbGVuZGFyX2V2ZW50cycsIGRhdGEsIHByZXNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBlID0gcmVzcG9uc2UuZXZlbnRzWzBdO1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RXZlbnRGcm9tTG9jYWxEYihpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RXZlbnRGcm9tTG9jYWxEYihpZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBjYWxlbmRhciBldmVudCBmcm9tIGxvY2FsIERiLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFyI2dldEV2ZW50RnJvbUxvY2FsRGJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIGlkIEV2ZW50IElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBldmVudCBkYXRhIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEV2ZW50RnJvbUxvY2FsRGIgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICAvLyBOb3QgbG9nZ2VkIGluLCB3ZSBjYW4ndCBnZXQgdGhlIHNpdGUgREIuIFVzZXIgbG9nZ2VkIG91dCBvciBzZXNzaW9uIGV4cGlyZWQgd2hpbGUgYW4gb3BlcmF0aW9uIHdhcyBvbmdvaW5nLlxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmdldERiKCkuZ2V0KG1tYUNhbGVuZGFyRXZlbnRzU3RvcmUsIGlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGV2ZW50IGljb24gbmFtZSBiYXNlZCBvbiBldmVudCB0eXBlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFyI2dldEV2ZW50SWNvblxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICBFdmVudCBpY29uIG5hbWUuIElmIHR5cGUgbm90IHZhbGlkLCByZXR1cm4gZW1wdHkgc3RyaW5nLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RXZlbnRJY29uID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gZXZlbnRpY29uc1t0eXBlXSB8fCAnJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGV2ZW50IG5vdGlmaWNhdGlvbiB0aW1lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFyI2dldEV2ZW50Tm90aWZpY2F0aW9uVGltZVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICAgICAgRXZlbnQgSUQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZWlkXSBJRCBvZiB0aGUgc2l0ZSB0aGUgZXZlbnQgYmVsb25ncyB0by4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICBFdmVudCBpY29uIG5hbWUuIElmIHR5cGUgbm90IHZhbGlkLCByZXR1cm4gZW1wdHkgc3RyaW5nLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RXZlbnROb3RpZmljYXRpb25UaW1lID0gZnVuY3Rpb24oaWQsIHNpdGVpZCkge1xuICAgICAgICBzaXRlaWQgPSBzaXRlaWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlaWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdmFyIGRiID0gc2l0ZS5nZXREYigpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0KG1tYUNhbGVuZGFyRXZlbnRzU3RvcmUsIGlkKS50aGVuKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUubm90aWZpY2F0aW9udGltZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5ub3RpZmljYXRpb250aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbW1hQ2FsZW5kYXJEZWZhdWx0Tm90aWZUaW1lO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1tYUNhbGVuZGFyRGVmYXVsdE5vdGlmVGltZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhbGVuZGFyIGV2ZW50cyBpbiBhIGNlcnRhaW4gcGVyaW9kLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFyI2dldEV2ZW50c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF5c1RvU3RhcnQ9MF0gICBOdW1iZXIgb2YgZGF5cyBmcm9tIG5vdyB0byBzdGFydCBnZXR0aW5nIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RheXNJbnRlcnZhbD0zMF0gTnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aW1lc3RhcnQgYW5kIHRpbWVlbmQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVmcmVzaF0gICAgICAgIFRydWUgd2hlbiB3ZSBzaG91bGQgbm90IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlaWRdICAgICAgICAgIFNpdGUgdG8gZ2V0IHRoZSBldmVudHMgZnJvbS4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgcGFydGljaXBhbnRzIGFyZSByZXRyaWV2ZWQuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogR2V0IHRoZSBldmVudHMgaW4gYSBjZXJ0YWluIHBlcmlvZC4gVGhlIHBlcmlvZCBpcyBjYWxjdWxhdGVkIGxpa2UgdGhpczpcbiAgICAgKiAgICAgc3RhcnQgdGltZTogbm93ICsgZGF5c1RvU3RhcnRcbiAgICAgKiAgICAgZW5kIHRpbWU6IHN0YXJ0IHRpbWUgKyBkYXlzSW50ZXJ2YWxcbiAgICAgKiBFLmcuIHVzaW5nICRtbWFDYWxlbmRhci5nZXRFdmVudHMoMzAsIDMwKSBpcyBnb2luZyB0byBnZXQgdGhlIGV2ZW50cyBzdGFydGluZyBhZnRlciAzMCBkYXlzIGZyb20gbm93XG4gICAgICogYW5kIGVuZGluZyBiZWZvcmUgNjAgZGF5cyBmcm9tIG5vdy5cbiAgICAgKi9cbiAgICBzZWxmLmdldEV2ZW50cyA9IGZ1bmN0aW9uKGRheXNUb1N0YXJ0LCBkYXlzSW50ZXJ2YWwsIHJlZnJlc2gsIHNpdGVpZCkge1xuICAgICAgICBkYXlzVG9TdGFydCA9IGRheXNUb1N0YXJ0IHx8IDA7XG4gICAgICAgIGRheXNJbnRlcnZhbCA9IGRheXNJbnRlcnZhbCB8fCBtbWFDYWxlbmRhckRheXNJbnRlcnZhbDtcbiAgICAgICAgc2l0ZWlkID0gc2l0ZWlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICAgdmFyIG5vdyA9ICRtbVV0aWwudGltZXN0YW1wKCksXG4gICAgICAgICAgICBzdGFydCA9IG5vdyArIChtbUNvcmVTZWNvbmRzRGF5ICogZGF5c1RvU3RhcnQpLFxuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyAobW1Db3JlU2Vjb25kc0RheSAqIGRheXNJbnRlcnZhbCk7XG5cbiAgICAgICAgLy8gVGhlIGNvcmVfY2FsZW5kYXJfZ2V0X2NhbGVuZGFyX2V2ZW50cyBuZWVkcyBhbGwgdGhlIGN1cnJlbnQgdXNlciBjb3Vyc2VzIGFuZCBncm91cHMuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgXCJvcHRpb25zW3VzZXJldmVudHNdXCI6IDEsXG4gICAgICAgICAgICBcIm9wdGlvbnNbc2l0ZWV2ZW50c11cIjogMSxcbiAgICAgICAgICAgIFwib3B0aW9uc1t0aW1lc3RhcnRdXCI6IHN0YXJ0LFxuICAgICAgICAgICAgXCJvcHRpb25zW3RpbWVlbmRdXCI6IGVuZFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2VzLmdldFVzZXJDb3Vyc2VzKGZhbHNlLCBzaXRlaWQpLnRoZW4oZnVuY3Rpb24oY291cnNlcykge1xuICAgICAgICAgICAgY291cnNlcy5wdXNoKHtpZDogMX0pOyAvLyBBZGQgZnJvbnQgcGFnZS5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb3Vyc2VzLCBmdW5jdGlvbihjb3Vyc2UsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgZGF0YVtcImV2ZW50c1tjb3Vyc2VpZHNdW1wiICsgaW5kZXggKyBcIl1cIl0gPSBjb3Vyc2UuaWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRtbUdyb3Vwcy5nZXRVc2VyR3JvdXBzKGNvdXJzZXMsIHJlZnJlc2gsIHNpdGVpZCkudGhlbihmdW5jdGlvbihncm91cHMpIHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZ3JvdXBzLCBmdW5jdGlvbihncm91cCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtcImV2ZW50c1tncm91cGlkc11bXCIgKyBpbmRleCArIFwiXVwiXSA9IGdyb3VwLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZXRyaWV2ZSBjYWNoZWQgZGF0YSB1c2luZyBjYWNoZSBrZXkgYmVjYXVzZSB3ZSBoYXZlIHRpbWVzdGFtcCBpbiB0aGUgcGFyYW1zLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRFdmVudHNMaXN0Q2FjaGVLZXkoZGF5c1RvU3RhcnQsIGRheXNJbnRlcnZhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDYWNoZVVzaW5nQ2FjaGVLZXk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpdGUucmVhZCgnY29yZV9jYWxlbmRhcl9nZXRfY2FsZW5kYXJfZXZlbnRzJywgZGF0YSwgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVFdmVudHNJbkxvY2FsREIocmVzcG9uc2UuZXZlbnRzLCBzaXRlaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgZXZlbnRzIGxpc3QgYW5kIGFsbCB0aGUgc2luZ2xlIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNhbGVuZGFyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDYWxlbmRhciNpbnZhbGlkYXRlRXZlbnRzTGlzdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbGlzdCBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVFdmVudHNMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwMSA9ICRtbUNvdXJzZXMuaW52YWxpZGF0ZVVzZXJDb3Vyc2VzKCksXG4gICAgICAgICAgICBwMiA9ICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXlTdGFydGluZ1dpdGgoZ2V0RXZlbnRzQ29tbW9uQ2FjaGVLZXkoKSk7XG4gICAgICAgIHJldHVybiAkcS5hbGwoW3AxLCBwMl0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYWxlbmRhciBldmVudHMgV1MgaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFyI2lzQXZhaWxhYmxlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBjYWxlbmRhciBldmVudHMgV1MgaXMgYXZhaWxhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53c0F2YWlsYWJsZSgnY29yZV9jYWxlbmRhcl9nZXRfY2FsZW5kYXJfZXZlbnRzJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBldmVudHMgZm9yIGFsbCB0aGUgc2l0ZXMgYW5kIHNjaGVkdWxlcyB0aGVpciBub3RpZmljYXRpb25zLlxuICAgICAqIElmIGFuIGV2ZW50IG5vdGlmaWNhdGlvbiB0aW1lIGlzIDAsIGNhbmNlbCBpdHMgc2NoZWR1bGVkIG5vdGlmaWNhdGlvbiAoaWYgYW55KS5cbiAgICAgKiBJZiBsb2NhbCBub3RpZmljYXRpb24gcGx1Z2luIGlzIG5vdCBlbmFibGVkLCByZXNvbHZlIHRoZSBwcm9taXNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFyI3NjaGVkdWxlQWxsU2l0ZXNFdmVudHNOb3RpZmljYXRpb25zXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IGV2ZW50cyBFdmVudHMgdG8gc2NoZWR1bGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIHRoZSBub3RpZmljYXRpb25zIGhhdmUgYmVlbiBzY2hlZHVsZWQuXG4gICAgICovXG4gICAgc2VsZi5zY2hlZHVsZUFsbFNpdGVzRXZlbnRzTm90aWZpY2F0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICgkbW1Mb2NhbE5vdGlmaWNhdGlvbnMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlc0lkcygpLnRoZW4oZnVuY3Rpb24oc2l0ZWlkcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNpdGVpZHMsIGZ1bmN0aW9uKHNpdGVpZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgZmlyc3QgZXZlbnRzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYuZ2V0RXZlbnRzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmYWxzZSwgc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKGV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2NoZWR1bGVFdmVudHNOb3RpZmljYXRpb25zKGV2ZW50cywgc2l0ZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiBldmVudCBub3RpZmljYXRpb24uIElmIHRpbWUgaXMgMCwgY2FuY2VsIHNjaGVkdWxlZCBub3RpZmljYXRpb24gaWYgYW55LlxuICAgICAqIElmIGxvY2FsIG5vdGlmaWNhdGlvbiBwbHVnaW4gaXMgbm90IGVuYWJsZWQsIHJlc29sdmUgdGhlIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ2FsZW5kYXIjc2NoZWR1bGVFdmVudE5vdGlmaWNhdGlvblxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnQgICAgRXZlbnQgdG8gc2NoZWR1bGUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB0aW1lICAgICBOb3RpZmljYXRpb24gc2V0dGluZyB0aW1lIChpbiBtaW51dGVzKS4gRS5nLiAxMCBtZWFucyBcIm5vdGlmaWNhdGUgMTAgbWludXRlcyBiZWZvcmUgc3RhcnRcIi5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlaWRdIFNpdGUgSUQgdGhlIGV2ZW50IGJlbG9uZ3MgdG8uIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbm90aWZpY2F0aW9uIGlzIHNjaGVkdWxlZC5cbiAgICAgKi9cbiAgICBzZWxmLnNjaGVkdWxlRXZlbnROb3RpZmljYXRpb24gPSBmdW5jdGlvbihldmVudCwgdGltZSwgc2l0ZWlkKSB7XG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgaWYgKCRtbUxvY2FsTm90aWZpY2F0aW9ucy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICBpZiAodGltZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Mb2NhbE5vdGlmaWNhdGlvbnMuY2FuY2VsKGV2ZW50LmlkLCBtbWFDYWxlbmRhckNvbXBvbmVudCwgc2l0ZWlkKTsgLy8gQ2FuY2VsIGlmIGl0IHdhcyBzY2hlZHVsZWQuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lZW5kID0gKGV2ZW50LnRpbWVzdGFydCArIGV2ZW50LnRpbWVkdXJhdGlvbikgKiAxMDAwO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lZW5kIDw9IG5ldyBEYXRlKCkuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBldmVudCBoYXMgZmluaXNoZWQgYWxyZWFkeSwgZG9uJ3Qgc2NoZWR1bGUgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGVUcmlnZ2VyZWQgPSBuZXcgRGF0ZSgoZXZlbnQudGltZXN0YXJ0IC0gKHRpbWUgKiA2MCkpICogMTAwMCksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKGV2ZW50LnRpbWVzdGFydCAqIDEwMDApLFxuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZXZlbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogZXZlbnQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHN0YXJ0RGF0ZS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXQ6IGRhdGVUcmlnZ2VyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzbWFsbEljb246ICdyZXM6Ly9pY29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudGlkOiBldmVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXRlaWQ6IHNpdGVpZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUxvY2FsTm90aWZpY2F0aW9ucy5zY2hlZHVsZShub3RpZmljYXRpb24sIG1tYUNhbGVuZGFyQ29tcG9uZW50LCBzaXRlaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgdGhlIG5vdGlmaWNhdGlvbnMgZm9yIGEgbGlzdCBvZiBldmVudHMuXG4gICAgICogSWYgYW4gZXZlbnQgbm90aWZpY2F0aW9uIHRpbWUgaXMgMCwgY2FuY2VsIGl0cyBzY2hlZHVsZWQgbm90aWZpY2F0aW9uIChpZiBhbnkpLlxuICAgICAqIElmIGxvY2FsIG5vdGlmaWNhdGlvbiBwbHVnaW4gaXMgbm90IGVuYWJsZWQsIHJlc29sdmUgdGhlIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ2FsZW5kYXIjc2NoZWR1bGVFdmVudHNOb3RpZmljYXRpb25zXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IGV2ZW50cyBFdmVudHMgdG8gc2NoZWR1bGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZWlkXSBJRCBvZiB0aGUgc2l0ZSB0aGUgZXZlbnRzIGJlbG9uZyB0by4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIHRoZSBub3RpZmljYXRpb25zIGhhdmUgYmVlbiBzY2hlZHVsZWQuXG4gICAgICovXG4gICAgc2VsZi5zY2hlZHVsZUV2ZW50c05vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbihldmVudHMsIHNpdGVpZCkge1xuICAgICAgICBzaXRlaWQgPSBzaXRlaWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBpZiAoJG1tTG9jYWxOb3RpZmljYXRpb25zLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYuZ2V0RXZlbnROb3RpZmljYXRpb25UaW1lKGUuaWQsIHNpdGVpZCkudGhlbihmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNjaGVkdWxlRXZlbnROb3RpZmljYXRpb24oZSwgdGltZSwgc2l0ZWlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbiBldmVudCBub3RpZmljYXRpb24gdGltZSBhbmQgc2NoZWR1bGUgYSBuZXcgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNhbGVuZGFyI3VwZGF0ZU5vdGlmaWNhdGlvblRpbWVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50IEV2ZW50IHRvIHVwZGF0ZSBpdHMgbm90aWZpY2F0aW9uIHRpbWUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB0aW1lICBOZXcgbm90aWZpY2F0aW9uIHNldHRpbmcgdGltZSAoaW4gbWludXRlcykuIEUuZy4gMTAgbWVhbnMgXCJub3RpZmljYXRlIDEwIG1pbnV0ZXMgYmVmb3JlIHN0YXJ0XCIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIG5vdGlmaWNhdGlvbiBpcyB1cGRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYudXBkYXRlTm90aWZpY2F0aW9uVGltZSA9IGZ1bmN0aW9uKGV2ZW50LCB0aW1lKSB7XG4gICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIC8vIE5vdCBsb2dnZWQgaW4sIHdlIGNhbid0IGdldCB0aGUgc2l0ZSBEQi4gVXNlciBsb2dnZWQgb3V0IG9yIHNlc3Npb24gZXhwaXJlZCB3aGlsZSBhbiBvcGVyYXRpb24gd2FzIG9uZ29pbmcuXG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGIgPSAkbW1TaXRlLmdldERiKCk7XG5cbiAgICAgICAgZXZlbnQubm90aWZpY2F0aW9udGltZSA9IHRpbWU7XG5cbiAgICAgICAgcmV0dXJuIGRiLmluc2VydChtbWFDYWxlbmRhckV2ZW50c1N0b3JlLCBldmVudCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNjaGVkdWxlRXZlbnROb3RpZmljYXRpb24oZXZlbnQsIHRpbWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmNhbGVuZGFyJylcblxuLyoqXG4gKiBDYWxlbmRhciBoYW5kbGVycyBmYWN0b3J5LlxuICpcbiAqIFRoaXMgZmFjdG9yeSBob2xkcyB0aGUgZGlmZmVyZW50IGhhbmRsZXJzIHVzZWQgZm9yIGRlbGVnYXRlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5jYWxlbmRhclxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFDYWxlbmRhckhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hQ2FsZW5kYXJIYW5kbGVycycsIGZ1bmN0aW9uKCRsb2csICRtbWFDYWxlbmRhcikge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hQ2FsZW5kYXJIYW5kbGVycycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFNpZGUgbWVudSBuYXYgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNhbGVuZGFyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDYWxlbmRhckhhbmRsZXJzI3NpZGVNZW51TmF2XG4gICAgICovXG4gICAgc2VsZi5zaWRlTWVudU5hdiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYUNhbGVuZGFyLmlzQXZhaWxhYmxlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBDb250cm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2lkZSBtZW51IG5hdiBoYW5kbGVyIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY2FsZW5kYXJcbiAgICAgICAgICAgICAqIEBuZ2RvYyBjb250cm9sbGVyXG4gICAgICAgICAgICAgKiBAbmFtZSAkbW1hQ2FsZW5kYXJIYW5kbGVycyNzaWRlTWVudU5hdjpjb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICdpb24tY2FsZW5kYXInO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEuY2FsZW5kYXIuY2FsZW5kYXJldmVudHMnO1xuICAgICAgICAgICAgICAgICRzY29wZS5zdGF0ZSA9ICdzaXRlLmNhbGVuZGFyJztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGhhbmRsZSBjb3Vyc2UgY29tcGxldGlvbiByZXBvcnQuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYUNvdXJzZUNvbXBsZXRpb25SZXBvcnRDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFDb3Vyc2VDb21wbGV0aW9uUmVwb3J0Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1VdGlsLCAkbW1hQ291cnNlQ29tcGxldGlvbiwgJG1tU2l0ZSxcbiAgICAgICAgICAgICRpb25pY1BsYXRmb3JtKSB7XG5cbiAgICB2YXIgY291cnNlID0gJHN0YXRlUGFyYW1zLmNvdXJzZSxcbiAgICAgICAgdXNlcmlkID0gJHN0YXRlUGFyYW1zLnVzZXJpZCB8fCAkbW1TaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgJHNjb3BlLmlzVGFibGV0ID0gJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKTtcblxuICAgIGZ1bmN0aW9uIGZldGNoQ29tcGxldGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbWFDb3Vyc2VDb21wbGV0aW9uLmdldENvbXBsZXRpb24oY291cnNlLmlkLCB1c2VyaWQpLnRoZW4oZnVuY3Rpb24oY29tcGxldGlvbikge1xuXG4gICAgICAgICAgICBjb21wbGV0aW9uLnN0YXR1c1RleHQgPSAkbW1hQ291cnNlQ29tcGxldGlvbi5nZXRDb21wbGV0ZWRTdGF0dXNUZXh0KGNvbXBsZXRpb24pO1xuXG4gICAgICAgICAgICAkc2NvcGUuY29tcGxldGlvbiA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICAkc2NvcGUuc2hvd1NlbGZDb21wbGV0ZSA9ICRtbWFDb3Vyc2VDb21wbGV0aW9uLmlzU2VsZkNvbXBsZXRpb25BdmFpbGFibGUoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFDb3Vyc2VDb21wbGV0aW9uLmNhbk1hcmtTZWxmQ29tcGxldGVkKHVzZXJpZCwgY29tcGxldGlvbik7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLmNvdXJzZWNvbXBsZXRpb24uY291bGRub3Rsb2FkcmVwb3J0JywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZldGNoQ29tcGxldGlvbigpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5jb21wbGV0aW9uTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIENvbnZlbmllbnZlIGZ1bmN0aW9uIHRvIHJlZnJlc2ggY29tcGxldGlvbiBkYXRhLlxuICAgIGZ1bmN0aW9uIHJlZnJlc2hDb21wbGV0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tYUNvdXJzZUNvbXBsZXRpb24uaW52YWxpZGF0ZUNvdXJzZUNvbXBsZXRpb24oY291cnNlLmlkLCB1c2VyaWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hDb21wbGV0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICRzY29wZS5yZWZyZXNoQ29tcGxldGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWZyZXNoQ29tcGxldGlvbigpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLmNvbXBsZXRlQ291cnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW0uY29yZS5zZW5kaW5nJywgdHJ1ZSk7XG4gICAgICAgICRtbWFDb3Vyc2VDb21wbGV0aW9uLm1hcmtDb3Vyc2VBc1NlbGZDb21wbGV0ZWQoY291cnNlLmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZnJlc2hDb21wbGV0aW9uKCk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb24nKVxuXG4vKipcbiAqIENvdXJzZSBjb21wbGV0aW9uIGZhY3RvcnkuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uXG4gKi9cbi5mYWN0b3J5KCckbW1hQ291cnNlQ29tcGxldGlvbicsIGZ1bmN0aW9uKCRtbVNpdGUsICRsb2csICRxLCAkbW1Db3Vyc2VzKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFDb3Vyc2VDb21wbGV0aW9uJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdXNlciBjYW4gbWFyayBhIGNvdXJzZSBhcyBzZWxmIGNvbXBsZXRlZC5cbiAgICAgKiBJdCBjYW4gaWYgaXQncyBjb25maWd1cmVkIGluIHRoZSBjb3Vyc2UgYW5kIGl0IGhhc24ndCBiZWVuIGNvbXBsZXRlZCB5ZXQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uI2Nhbk1hcmtTZWxmQ29tcGxldGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJpZCAgICAgVXNlciBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcGxldGlvbiBDb3Vyc2UgY29tcGxldGlvbi5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlIGlmIHVzZXIgY2FuIG1hcmsgY291cnNlIGFzIHNlbGYgY29tcGxldGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5jYW5NYXJrU2VsZkNvbXBsZXRlZCA9IGZ1bmN0aW9uKHVzZXJpZCwgY29tcGxldGlvbikge1xuICAgICAgICB2YXIgc2VsZkNvbXBsZXRpb25BY3RpdmUgPSBmYWxzZSxcbiAgICAgICAgICAgIGFscmVhZHlNYXJrZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoJG1tU2l0ZS5nZXRVc2VySWQoKSAhPSB1c2VyaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb21wbGV0aW9uLmNvbXBsZXRpb25zLCBmdW5jdGlvbihjcml0ZXJpYSkge1xuICAgICAgICAgICAgaWYgKGNyaXRlcmlhLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWxmIGNvbXBsZXRpb24gY3JpdGVyaWEgZm91bmQuXG4gICAgICAgICAgICAgICAgc2VsZkNvbXBsZXRpb25BY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFscmVhZHlNYXJrZWQgPSBjcml0ZXJpYS5jb21wbGV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGZDb21wbGV0aW9uQWN0aXZlICYmICFhbHJlYWR5TWFya2VkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29tcGxldGVkIHN0YXR1cyB0ZXh0LiBUaGUgbGFuZ3VhZ2UgY29kZSByZXR1cm5lZCBpcyBtZWFudCB0byBiZSB0cmFuc2xhdGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ291cnNlQ29tcGxldGlvbiNnZXRDb21wbGV0ZWRTdGF0dXNUZXh0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBsZXRpb24gQ291cnNlIGNvbXBsZXRpb24uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgTGFuZ3VhZ2UgY29kZSBvZiB0aGUgdGV4dCB0byBzaG93LlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Q29tcGxldGVkU3RhdHVzVGV4dCA9IGZ1bmN0aW9uKGNvbXBsZXRpb24pIHtcbiAgICAgICAgaWYgKGNvbXBsZXRpb24uY29tcGxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21tYS5jb3Vyc2Vjb21wbGV0aW9uLmNvbXBsZXRlZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBMZXQncyBjYWxjdWxhdGUgc3RhdHVzLlxuICAgICAgICAgICAgdmFyIGhhc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb21wbGV0aW9uLmNvbXBsZXRpb25zLCBmdW5jdGlvbihjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIGlmIChjcml0ZXJpYS50aW1lY29tcGxldGVkIHx8IGNyaXRlcmlhLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21tYS5jb3Vyc2Vjb21wbGV0aW9uLmlucHJvZ3Jlc3MnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21tYS5jb3Vyc2Vjb21wbGV0aW9uLm5vdHlldHN0YXJ0ZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjb3Vyc2UgY29tcGxldGlvbiBzdGF0dXMgZm9yIGEgY2VydGFpbiBjb3Vyc2UgYW5kIHVzZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uI2dldENvbXBsZXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcmlkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aGVuIHRoZSBjb21wbGV0aW9uIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldENvbXBsZXRpb24gPSBmdW5jdGlvbihjb3Vyc2VpZCwgdXNlcmlkKSB7XG4gICAgICAgIHVzZXJpZCA9IHVzZXJpZCB8fCAkbW1TaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICRsb2cuZGVidWcoJ0dldCBjb21wbGV0aW9uIGZvciBjb3Vyc2UgJyArIGNvdXJzZWlkICsgJyBhbmQgdXNlciAnICsgdXNlcmlkKTtcblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VpZCA6IGNvdXJzZWlkLFxuICAgICAgICAgICAgICAgIHVzZXJpZDogdXNlcmlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0Q29tcGxldGlvbkNhY2hlS2V5KGNvdXJzZWlkLCB1c2VyaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ2NvcmVfY29tcGxldGlvbl9nZXRfY291cnNlX2NvbXBsZXRpb25fc3RhdHVzJywgZGF0YSwgcHJlU2V0cykudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5jb21wbGV0aW9uc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuY29tcGxldGlvbnN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGdldCBjb21wbGV0aW9uIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdXNlcmlkICAgVXNlciBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENvbXBsZXRpb25DYWNoZUtleShjb3Vyc2VpZCwgdXNlcmlkKSB7XG4gICAgICAgIHJldHVybiAnbW1hQ291cnNlQ29tcGxldGlvbjp2aWV3OicgKyBjb3Vyc2VpZCArICc6JyArIHVzZXJpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyB2aWV3IGNvdXJzZSBjb21wbGV0aW9uIFdTIGNhbGwuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uI2ludmFsaWRhdGVDb3Vyc2VDb21wbGV0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJpZF0gVXNlciBJRC4gSWYgbm90IGRlZmluZWQsIHVzZSBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBsaXN0IGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUNvdXJzZUNvbXBsZXRpb24gPSBmdW5jdGlvbihjb3Vyc2VpZCwgdXNlcmlkKSB7XG4gICAgICAgIHVzZXJpZCA9IHVzZXJpZCB8fCAkbW1TaXRlLmdldFVzZXJJZCgpO1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRDb21wbGV0aW9uQ2FjaGVLZXkoY291cnNlaWQsIHVzZXJpZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2aWV3IGNvdXJzZSBjb21wbGV0aW9uIHBsdWdpbiBpcyBlbmFibGVkIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHF1aXRlIG9mdGVuIGFuZCB0aHVzIHNob3VsZCBvbmx5IHBlcmZvcm0gYSBxdWlja1xuICAgICAqIGNoZWNrLCB3ZSBzaG91bGQgbm90IGJlIGNhbGxpbmcgV1MgZnJvbSBoZXJlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ291cnNlQ29tcGxldGlvbiNpc1BsdWdpblZpZXdFbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBwbHVnaW4gZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5WaWV3RW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoISRtbVNpdGUud3NBdmFpbGFibGUoJ2NvcmVfY29tcGxldGlvbl9nZXRfY291cnNlX2NvbXBsZXRpb25fc3RhdHVzJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2aWV3IGNvdXJzZSBjb21wbGV0aW9uIHBsdWdpbiBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gY291cnNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ291cnNlQ29tcGxldGlvbiNpc1BsdWdpblZpZXdFbmFibGVkRm9yQ291cnNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5WaWV3RW5hYmxlZEZvckNvdXJzZSA9IGZ1bmN0aW9uKGNvdXJzZUlkKSB7XG4gICAgICAgIGlmICghY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2VzLmdldFVzZXJDb3Vyc2UoY291cnNlSWQsIHRydWUpLnRoZW4oZnVuY3Rpb24oY291cnNlKSB7XG4gICAgICAgICAgICBpZiAoY291cnNlICYmIHR5cGVvZiBjb3Vyc2UuZW5hYmxlY29tcGxldGlvbiAhPSAndW5kZWZpbmVkJyAmJiAhY291cnNlLmVuYWJsZWNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHNlbGYgY29tcGxldGlvbiBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ291cnNlQ29tcGxldGlvbiNpc1NlbGZDb21wbGV0aW9uQXZhaWxhYmxlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBzZWxmIGNvbXBsZXRpb24gaXMgYXZhaWxhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1NlbGZDb21wbGV0aW9uQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX2NvbXBsZXRpb25fbWFya19jb3Vyc2Vfc2VsZl9jb21wbGV0ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFyayBhIGNvdXJzZSBhcyBzZWxmIGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb25cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUNvdXJzZUNvbXBsZXRpb24jbWFya0NvdXJzZUFzU2VsZkNvbXBsZXRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFJlc29sdmVkIG9uIHN1Y2Nlc3MuXG4gICAgICovXG4gICAgc2VsZi5tYXJrQ291cnNlQXNTZWxmQ29tcGxldGVkID0gZnVuY3Rpb24oY291cnNlaWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNvdXJzZWlkOiBjb3Vyc2VpZFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdjb3JlX2NvbXBsZXRpb25fbWFya19jb3Vyc2Vfc2VsZl9jb21wbGV0ZWQnLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb24nKVxuXG4vKipcbiAqIENvdXJzZSBjb21wbGV0aW9uIGhhbmRsZXJzIGZhY3RvcnkuXG4gKlxuICogVGhpcyBmYWN0b3J5IGhvbGRzIHRoZSBkaWZmZXJlbnQgaGFuZGxlcnMgdXNlZCBmb3IgZGVsZWdhdGVzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb25cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hQ291cnNlQ29tcGxldGlvbkhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hQ291cnNlQ29tcGxldGlvbkhhbmRsZXJzJywgZnVuY3Rpb24oJG1tYUNvdXJzZUNvbXBsZXRpb24sICRzdGF0ZSwgbW1Db3Vyc2VzQWNjZXNzTWV0aG9kcykge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFZpZXcgdXNlciBjb21wbGV0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5jb3Vyc2Vjb21wbGV0aW9uXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uSGFuZGxlcnMjdmlld0NvbXBsZXRpb25cbiAgICAgKi9cbiAgICBzZWxmLnZpZXdDb21wbGV0aW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hQ291cnNlQ29tcGxldGlvbi5pc1BsdWdpblZpZXdFbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgdGhpcyB1c2VyIGluIHRoaXMgY29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXIgICAgIFVzZXIgdG8gY2hlY2suXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWRGb3JVc2VyID0gZnVuY3Rpb24odXNlciwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hQ291cnNlQ29tcGxldGlvbi5pc1BsdWdpblZpZXdFbmFibGVkRm9yQ291cnNlKGNvdXJzZUlkKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlciAgICAgQ291cnNlIElELlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgQ291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgQ29udHJvbGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKHVzZXIsIGNvdXJzZUlkKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmlldyBjb3Vyc2UgY29tcGxldGlvbiBoYW5kbGVyIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFDb3Vyc2VDb21wbGV0aW9uSGFuZGxlcnMjdmlld0NvbXBsZXRpb246Y29udHJvbGxlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBCdXR0b24gdGl0bGUuXG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5jb3Vyc2Vjb21wbGV0aW9uLnZpZXdjb3Vyc2VyZXBvcnQnO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUuY291cnNlLWNvbXBsZXRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3Vyc2U6IHtpZDogY291cnNlSWR9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIG5hdiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuY291cnNlY29tcGxldGlvblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hQ291cnNlQ29tcGxldGlvbkhhbmRsZXJzI2NvdXJzZXNOYXZcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZXNOYXYgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFDb3Vyc2VDb21wbGV0aW9uLmlzUGx1Z2luVmlld0VuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkIGZvciB0aGlzIGNvdXJzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkICAgQ291cnNlIElELlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjZXNzRGF0YSBUeXBlIG9mIGFjY2VzcyB0byB0aGUgY291cnNlOiBkZWZhdWx0LCBndWVzdCwgLi4uXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZEZvckNvdXJzZSA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBhY2Nlc3NEYXRhKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXNzRGF0YSAmJiBhY2Nlc3NEYXRhLnR5cGUgPT0gbW1Db3Vyc2VzQWNjZXNzTWV0aG9kcy5ndWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm90IGVuYWJsZWQgZm9yIGd1ZXN0cy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkbW1hQ291cnNlQ29tcGxldGlvbi5pc1BsdWdpblZpZXdFbmFibGVkRm9yQ291cnNlKGNvdXJzZUlkKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgQ291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgQ29udHJvbGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKGNvdXJzZUlkKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ291cnNlcyBuYXYgaGFuZGxlciBjb250cm9sbGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmNvdXJzZWNvbXBsZXRpb25cbiAgICAgICAgICAgICAqIEBuZ2RvYyBjb250cm9sbGVyXG4gICAgICAgICAgICAgKiBAbmFtZSAkbW1hQ291cnNlQ29tcGxldGlvbkhhbmRsZXJzI2NvdXJzZXNOYXY6Y29udHJvbGxlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICdpb24tYW5kcm9pZC1jaGVja2JveC1vdXRsaW5lJztcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLmNvdXJzZWNvbXBsZXRpb24uY291cnNlY29tcGxldGlvbic7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKCRldmVudCwgY291cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5jb3Vyc2UtY29tcGxldGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdXJzZTogY291cnNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuZmlsZXMnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gdXBsb2FkIGFueSBraW5kIG9mIGZpbGUgb24gaU9TLiBMZXRzIHRoZSB1c2VyIGNob29zZSB0aGUgc2l0ZSBoZSB3YW50cyB0byB1cGxvYWQgdGhlIGZpbGUgdG8uXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFGaWxlc0Nob29zZVNpdGVDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFGaWxlc0Nob29zZVNpdGVDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsICRzdGF0ZVBhcmFtcywgJG1tU2l0ZXNNYW5hZ2VyLCAkbW1hRmlsZXNIZWxwZXIsICRpb25pY0hpc3RvcnkpIHtcblxuICAgIHZhciBmaWxlRW50cnkgPSAkc3RhdGVQYXJhbXMuZmlsZSB8fMKge307XG4gICAgJHNjb3BlLmZpbGVuYW1lID0gZmlsZUVudHJ5Lm5hbWU7XG5cbiAgICAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZXMoKS50aGVuKGZ1bmN0aW9uKHNpdGVzKSB7XG4gICAgICAgICRzY29wZS5zaXRlcyA9IHNpdGVzO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLnVwbG9hZEluU2l0ZSA9IGZ1bmN0aW9uKHNpdGVpZCkge1xuICAgICAgICAkbW1hRmlsZXNIZWxwZXIuc2hvd0NvbmZpcm1BbmRVcGxvYWRJblNpdGUoZmlsZUVudHJ5LCBzaXRlaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUJhY2s6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1tX2NvdXJzZXMnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuZmlsZXMnKVxuXG4uY29udHJvbGxlcignbW1hRmlsZXNJbmRleENvbnRyb2xsZXInLCBmdW5jdGlvbigkc2NvcGUsICRtbWFGaWxlcywgJG1tU2l0ZSwgJG1tVXRpbCwgJG1tQXBwLCAkc3RhdGUpIHtcblxuICAgICRzY29wZS5jYW5BY2Nlc3NGaWxlcyA9ICRtbWFGaWxlcy5jYW5BY2Nlc3NGaWxlcztcbiAgICAkc2NvcGUuc2hvd1ByaXZhdGVGaWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tYUZpbGVzLmNhbkFjY2Vzc0ZpbGVzKCkgJiYgJG1tU2l0ZS5jYW5BY2Nlc3NNeUZpbGVzKCk7XG4gICAgfTtcbiAgICAkc2NvcGUuc2hvd1VwbG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBTaG93IHVwbG9hZCBpbiB0aGlzIHBhZ2UgaWYgdXNlciBjYW4gdXBsb2FkIGJ1dCBoZSBjYW4ndCBzZWUgdGhlIE15IEZpbGVzIG9wdGlvbi5cbiAgICAgICAgcmV0dXJuICEkbW1hRmlsZXMuY2FuQWNjZXNzRmlsZXMoKSAmJiAkbW1TaXRlLmNhbkFjY2Vzc015RmlsZXMoKSAmJiAkbW1TaXRlLmNhblVwbG9hZEZpbGVzKCk7XG4gICAgfTtcbiAgICAkc2NvcGUuY2FuRG93bmxvYWQgPSAkbW1TaXRlLmNhbkRvd25sb2FkRmlsZXM7XG5cbiAgICAkc2NvcGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5maWxlcy5lcnJvcm11c3RiZW9ubGluZXRvdXBsb2FkJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUuZmlsZXMtdXBsb2FkJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmZpbGVzJylcblxuLmNvbnRyb2xsZXIoJ21tYUZpbGVzTGlzdENvbnRyb2xsZXInLCBmdW5jdGlvbigkcSwgJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbWFGaWxlcywgJG1tU2l0ZSwgJHRyYW5zbGF0ZSwgJG1tVXRpbCxcbiAgICAgICAgJGlvbmljSGlzdG9yeSwgbW1hRmlsZXNVcGxvYWRTdGF0ZU5hbWUsICRzdGF0ZSwgJG1tQXBwLCBtbWFGaWxlc015Q29tcG9uZW50LCBtbWFGaWxlc1NpdGVDb21wb25lbnQpIHtcblxuICAgIHZhciBwYXRoID0gJHN0YXRlUGFyYW1zLnBhdGgsXG4gICAgICAgIHJvb3QgPSAkc3RhdGVQYXJhbXMucm9vdCxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHByb21pc2U7XG5cbiAgICAvLyBXZSdyZSBsb2FkaW5nIHRoZSBmaWxlcy5cbiAgICAkc2NvcGUuY291bnQgPSAtMTtcbiAgICAkc2NvcGUuY29tcG9uZW50ID0gcm9vdCA9PT0gJ215JyA/IG1tYUZpbGVzTXlDb21wb25lbnQgOiBtbWFGaWxlc1NpdGVDb21wb25lbnQ7XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0aGF0IGZldGNoZXMgdGhlIGZpbGVzIGFuZCB1cGRhdGVzIHRoZSBzY29wZS5cbiAgICBmdW5jdGlvbiBmZXRjaEZpbGVzKHJvb3QsIHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAvLyBUaGUgcGF0aCBpcyB1bmtub3duLCB0aGUgdXNlciBtdXN0IGJlIHJlcXVlc3RpbmcgYSByb290LlxuICAgICAgICAgICAgaWYgKHJvb3QgPT09ICdzaXRlJykge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1hRmlsZXMuZ2V0U2l0ZUZpbGVzKCk7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSAkdHJhbnNsYXRlKCdtbWEuZmlsZXMuc2l0ZWZpbGVzJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09ICdteScpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJG1tYUZpbGVzLmdldE15RmlsZXMoKTtcbiAgICAgICAgICAgICAgICB0aXRsZSA9ICR0cmFuc2xhdGUoJ21tYS5maWxlcy5teXByaXZhdGVmaWxlcycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBVcG9uIGVycm9yIHdlIGNyZWF0ZSBhIGZha2UgcHJvbWlzZSB0aGF0IGlzIHJlamVjdGVkLlxuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICAgICAgICBxLnJlc29sdmUoJycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcS5wcm9taXNlO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTZXJ2ZSB0aGUgZmlsZXMgdGhlIHVzZXIgcmVxdWVzdGVkLlxuICAgICAgICAgICAgcGF0aGRhdGEgPSBKU09OLnBhcnNlKHBhdGgpO1xuICAgICAgICAgICAgcHJvbWlzZSA9ICRtbWFGaWxlcy5nZXRGaWxlcyhwYXRoZGF0YSk7XG5cbiAgICAgICAgICAgIC8vIFB1dCB0aGUgdGl0bGUgaW4gYSBwcm9taXNlIHRvIGFjdCBsaWtlIHRyYW5zbGF0ZSBkb2VzLlxuICAgICAgICAgICAgdGl0bGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHEgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICAgIHEucmVzb2x2ZSgkc3RhdGVQYXJhbXMudGl0bGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnByb21pc2U7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChbcHJvbWlzZSwgdGl0bGVdKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IGRhdGFbMF0sXG4gICAgICAgICAgICAgICAgdGl0bGUgPSBkYXRhWzFdO1xuXG4gICAgICAgICAgICAkc2NvcGUuZmlsZXMgPSBmaWxlcy5lbnRyaWVzO1xuICAgICAgICAgICAgJHNjb3BlLmNvdW50ID0gZmlsZXMuY291bnQ7XG4gICAgICAgICAgICAkc2NvcGUudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEuZmlsZXMuY291bGRub3Rsb2FkZmlsZXMnLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmV0Y2hGaWxlcyhyb290LCBwYXRoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuZmlsZXNMb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLnJlZnJlc2hGaWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hRmlsZXMuaW52YWxpZGF0ZURpcmVjdG9yeShyb290LCBwYXRoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZmV0Y2hGaWxlcyhyb290LCBwYXRoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBsaXN0IGlmIHdlIGNvbWUgZnJvbSB1cGxvYWQgcGFnZSAod2UgZG9uJ3Qga25vdyBpZiB1c2VyIHVwb2FkZWQgYSBmaWxlIG9yIG5vdCkuXG4gICAgLy8gTGlzdCBpcyBpbnZhbGlkYXRlZCBpbiB1cGxvYWQgc3RhdGUgYWZ0ZXIgdXBsb2FkaW5nIGEgZmlsZS5cbiAgICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmVudGVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZm9yd2FyZFZpZXcgPSAkaW9uaWNIaXN0b3J5LmZvcndhcmRWaWV3KCk7XG4gICAgICAgIGlmIChmb3J3YXJkVmlldyAmJiBmb3J3YXJkVmlldy5zdGF0ZU5hbWUgPT09IG1tYUZpbGVzVXBsb2FkU3RhdGVOYW1lKSB7XG4gICAgICAgICAgICAkc2NvcGUuZmlsZXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZldGNoRmlsZXMocm9vdCwgcGF0aCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZmlsZXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRzY29wZS5zaG93VXBsb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAocm9vdCA9PT0gJ215JyAmJiAhcGF0aCAmJiAkbW1TaXRlLmNhblVwbG9hZEZpbGVzKCkpO1xuICAgIH07XG5cbiAgICAvLyBXaGVuIHdlIGFyZSBpbiB0aGUgcm9vdCBvZiB0aGUgcHJpdmF0ZSBmaWxlcyB3ZSBjYW4gYWRkIG1vcmUgZmlsZXMuXG4gICAgJHNjb3BlLmFkZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoISRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEuZmlsZXMuZXJyb3JtdXN0YmVvbmxpbmV0b3VwbG9hZCcsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLmZpbGVzLXVwbG9hZCcsIHtyb290OiByb290LCBwYXRoOiBwYXRofSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5maWxlcycpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byB1cGxvYWQgYW55IGtpbmQgb2YgZmlsZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYUZpbGVzVXBsb2FkQ3RybFxuICovXG4uY29udHJvbGxlcignbW1hRmlsZXNVcGxvYWRDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbVV0aWwsICRtbWFGaWxlc0hlbHBlciwgJGlvbmljSGlzdG9yeSwgJG1tYUZpbGVzLCAkbW1BcHApIHtcblxuICAgIHZhciB1cGxvYWRNZXRob2RzID0ge1xuICAgICAgICAgICAgYWxidW06ICRtbWFGaWxlc0hlbHBlci51cGxvYWRJbWFnZUZyb21BbGJ1bSxcbiAgICAgICAgICAgIGNhbWVyYTogJG1tYUZpbGVzSGVscGVyLnVwbG9hZEltYWdlRnJvbUNhbWVyYSxcbiAgICAgICAgICAgIGF1ZGlvOiAkbW1hRmlsZXNIZWxwZXIudXBsb2FkQXVkaW8sXG4gICAgICAgICAgICB2aWRlbzogJG1tYUZpbGVzSGVscGVyLnVwbG9hZFZpZGVvXG4gICAgICAgIH0sXG4gICAgICAgIHBhdGggPSAkc3RhdGVQYXJhbXMucGF0aCxcbiAgICAgICAgcm9vdCA9ICRzdGF0ZVBhcmFtcy5yb290O1xuXG4gICAgJHNjb3BlLmlzQW5kcm9pZCA9IGlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpO1xuXG4gICAgLy8gRnVuY3Rpb24gY2FsbGVkIHdoZW4gYSBmaWxlIGlzIHVwbG9hZGVkLlxuICAgIGZ1bmN0aW9uIHN1Y2Nlc3NVcGxvYWRpbmcoKSB7XG4gICAgICAgICRtbWFGaWxlcy5pbnZhbGlkYXRlRGlyZWN0b3J5KHJvb3QsIHBhdGgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dNb2RhbCgnbW0uY29yZS5zdWNjZXNzJywgJ21tYS5maWxlcy5maWxldXBsb2FkZWQnKTtcbiAgICAgICAgICAgICRpb25pY0hpc3RvcnkuZ29CYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgZmlsZSB1cGxvYWQgZmFpbHMuXG4gICAgZnVuY3Rpb24gZXJyb3JVcGxvYWRpbmcoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICRzY29wZS51cGxvYWQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5maWxlcy5lcnJvcm11c3RiZW9ubGluZXRvdXBsb2FkJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHVwbG9hZE1ldGhvZHNbdHlwZV0pICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHVwbG9hZE1ldGhvZHNbdHlwZV0oKS50aGVuKHN1Y2Nlc3NVcGxvYWRpbmcsIGVycm9yVXBsb2FkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkc2NvcGUudXBsb2FkRmlsZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBldnQuc3JjRWxlbWVudDtcbiAgICAgICAgdmFyIGZpbGUgPSBpbnB1dC5maWxlc1swXTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSAnJzsgLy8gVW5zZXQgaW5wdXQuXG4gICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAkbW1hRmlsZXNIZWxwZXIuY29uZmlybVVwbG9hZEZpbGUoZmlsZS5zaXplKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGRhdGEgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQsIGJ1dCBub3QgaXRzIFVSTCAobmVlZGVkKS4gQ3JlYXRlIGEgY29weSBvZiB0aGUgZmlsZSB0byB1cGxvYWQgaXQuXG4gICAgICAgICAgICAgICAgJG1tYUZpbGVzSGVscGVyLmNvcHlBbmRVcGxvYWRGaWxlKGZpbGUpLnRoZW4oc3VjY2Vzc1VwbG9hZGluZywgZXJyb3JVcGxvYWRpbmcpO1xuICAgICAgICAgICAgfSwgZXJyb3JVcGxvYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5maWxlcycpXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIGRldGVjdCBjaGFuZWdzIG9uIGZpbGUgaW5wdXRzIChuZy1DaGFuZ2UgZG9lc24ndCB3b3JrIGluIHRoYXQgdHlwZSBvZiBpbnB1dCkuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tYUZpbGVzT25DaGFuZ2VcbiAqL1xuLmRpcmVjdGl2ZSgnbW1hRmlsZXNPbkNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgdmFyIG9uQ2hhbmdlSGFuZGxlciA9IHNjb3BlLiRldmFsKGF0dHJzLm1tYUZpbGVzT25DaGFuZ2UpO1xuICAgICAgZWxlbWVudC5iaW5kKCdjaGFuZ2UnLCBvbkNoYW5nZUhhbmRsZXIpO1xuICAgIH1cbiAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuZmlsZXMnKVxuXG4uY29uZmlnKGZ1bmN0aW9uKCRtbUFwcFByb3ZpZGVyLCBtbWFGaWxlc1NoYXJlZEZpbGVzU3RvcmUpIHtcbiAgICB2YXIgc3RvcmVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBtbWFGaWxlc1NoYXJlZEZpbGVzU3RvcmUsXG4gICAgICAgICAgICBrZXlQYXRoOiAnaWQnXG4gICAgICAgIH1cbiAgICBdO1xuICAgICRtbUFwcFByb3ZpZGVyLnJlZ2lzdGVyU3RvcmVzKHN0b3Jlcyk7XG59KVxuXG4uZmFjdG9yeSgnJG1tYUZpbGVzJywgZnVuY3Rpb24oJG1tU2l0ZSwgJG1tRlMsICRxLCAkdGltZW91dCwgJGxvZywgJG1tU2l0ZXNNYW5hZ2VyLCAkbW1BcHAsIG1kNSxcbiAgICAgICAgICAgIG1tYUZpbGVzU2hhcmVkRmlsZXNTdG9yZSkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFGaWxlcycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgZGVmYXVsdFBhcmFtcyA9IHtcbiAgICAgICAgICAgIFwiY29udGV4dGlkXCI6IDAsXG4gICAgICAgICAgICBcImNvbXBvbmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJmaWxlYXJlYVwiOiBcIlwiLFxuICAgICAgICAgICAgXCJpdGVtaWRcIjogMCxcbiAgICAgICAgICAgIFwiZmlsZXBhdGhcIjogXCJcIixcbiAgICAgICAgICAgIFwiZmlsZW5hbWVcIjogXCJcIlxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY29yZV9maWxlc19nZXRfZmlsZXMgV1MgY2FsbCBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXMjY2FuQWNjZXNzRmlsZXNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIFdTIGlzIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuY2FuQWNjZXNzRmlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3NBdmFpbGFibGUoJ2NvcmVfZmlsZXNfZ2V0X2ZpbGVzJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGVyZSBpcyBhIG5ldyBmaWxlIHJlY2VpdmVkIGluIGlPUy4gSWYgbW9yZSB0aGFuIG9uZSBmaWxlIGlzIGZvdW5kLCB0cmVhdCBvbmx5IHRoZSBmaXJzdCBvbmUuXG4gICAgICogVGhlIGZpbGUgcmV0dXJuZWQgaXMgbWFya2VkIGFzIFwidHJlYXRlZFwiIGFuZCB3aWxsIGJlIGRlbGV0ZWQgaW4gdGhlIG5leHQgZXhlY3V0aW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI2NoZWNrSU9TTmV3RmlsZXNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdpdGggYSBuZXcgZmlsZSB0byBiZSB0cmVhdGVkLiBJZiBubyBuZXcgZmlsZXMgZm91bmQsIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAgICovXG4gICAgc2VsZi5jaGVja0lPU05ld0ZpbGVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICAkbG9nLmRlYnVnKCdTZWFyY2ggZm9yIG5ldyBmaWxlcyBvbiBpT1MnKTtcbiAgICAgICAgJG1tRlMuZ2V0RGlyZWN0b3J5Q29udGVudHMoJ0luYm94JykudGhlbihmdW5jdGlvbihlbnRyaWVzKSB7XG5cbiAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlRGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUlkID0gbWQ1LmNyZWF0ZUhhc2goZW50cnkubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZmlsZSB3YXMgYWxyZWFkeSB0cmVhdGVkLlxuICAgICAgICAgICAgICAgICAgICAkbW1BcHAuZ2V0REIoKS5nZXQobW1hRmlsZXNTaGFyZWRGaWxlc1N0b3JlLCBmaWxlSWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIGFscmVhZHkgdHJlYXRlZC4gRGVsZXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRGVsZXRlIGFscmVhZHkgdHJlYXRlZCBmaWxlOiAnICsgZW50cnkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlRGVmZXJyZWQucmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZW1vdmUoZnVuY3Rpb24oKcKge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0ZpbGUgZGVsZXRlZDogJyArIGVudHJ5Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUFwcC5nZXREQigpLnJlbW92ZShtbWFGaWxlc1NoYXJlZEZpbGVzU3RvcmUsIGZpbGVJZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnXCJUcmVhdGVkXCIgbWFyayByZW1vdmVkIGZyb20gZmlsZTogJyArIGVudHJ5Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdFcnJvciBkZWxldGluZyBcInRyZWF0ZWRcIiBtYXJrIGZyb20gZmlsZTogJyArIGVudHJ5Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRXJyb3IgZGVsZXRpbmcgZmlsZSBpbiBJbmJveDogJyArIGVudHJ5Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIG5vdCB0cmVhdGVkIGJlZm9yZSwgc2VuZCBpdCB0byByZXNvbHZlIHNvIGl0J3MgYSBjYW5kaWRhdGUgdG8gYmUgbm90aWZpZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdGb3VuZCBuZXcgZmlsZSAnICsgZW50cnkubmFtZSArICcgc2hhcmVkIHdpdGggdGhlIGFwcC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVEZWZlcnJlZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChmaWxlRGVmZXJyZWQucHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlVG9SZXR1cm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlSWQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzcG9uc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHJlc3BvbnNlc1tpXSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgbmV3IGVudHJ5IHRvIHRyZWF0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVUb1JldHVybiA9IHJlc3BvbnNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZVRvUmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlSWQgPSBtZDUuY3JlYXRlSGFzaChmaWxlVG9SZXR1cm4ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIGl0IGFzIFwidHJlYXRlZFwiLlxuICAgICAgICAgICAgICAgICAgICAgICAgJG1tQXBwLmdldERCKCkuaW5zZXJ0KG1tYUZpbGVzU2hhcmVkRmlsZXNTdG9yZSwge2lkOiBmaWxlSWR9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0ZpbGUgbWFya2VkIGFzIFwidHJlYXRlZFwiOiAnICsgZmlsZVRvUmV0dXJuLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZmlsZVRvUmV0dXJuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0Vycm9yIG1hcmtpbmcgZmlsZSBhcyBcInRyZWF0ZWRcIjogJyArIGZpbGVUb1JldHVybi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBmaWxlcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlcyNnZXRGaWxlc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gcGFyYW1zIEEgbGlzdCBvZiBwYXJhbWV0ZXJzIGFjY2VwdGVkIGJ5IHRoZSBXZWIgc2VydmljZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgaW4gdGhlIGtleSAnZW50cmllcycsIGFuZCAnY291bnQnLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIEFkZGl0aW9uYWwgcHJvcGVydGllcyBpcyBhZGRlZCB0byB0aGUgZW50cmllcywgc3VjaCBhczpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgLSBpbWdwYXRoOiBUaGUgcGF0aCB0byB0aGUgaWNvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgLSBsaW5rOiBUaGUgSlNPTiBzdHJpbmcgb2YgcGFyYW1zIHRvIGdldCB0byB0aGUgZmlsZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgLSBsaW5rSWQ6IEEgaGFzaCBvZiB0aGUgZmlsZSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblxuICAgICAgICBvcHRpb25zLmNhY2hlS2V5ID0gZ2V0RmlsZXNMaXN0Q2FjaGVLZXkocGFyYW1zKTtcblxuICAgICAgICAkbW1TaXRlLnJlYWQoJ2NvcmVfZmlsZXNfZ2V0X2ZpbGVzJywgcGFyYW1zLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZW50cmllczogW10sXG4gICAgICAgICAgICAgICAgY291bnQ6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmZpbGVzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzdWx0LmZpbGVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgIGVudHJ5LmxpbmsgPSB7fTtcbiAgICAgICAgICAgICAgICBlbnRyeS5saW5rLmNvbnRleHRpZCA9IChlbnRyeS5jb250ZXh0aWQpID8gZW50cnkuY29udGV4dGlkIDogXCJcIjtcbiAgICAgICAgICAgICAgICBlbnRyeS5saW5rLmNvbXBvbmVudCA9IChlbnRyeS5jb21wb25lbnQpID8gZW50cnkuY29tcG9uZW50IDogXCJcIjtcbiAgICAgICAgICAgICAgICBlbnRyeS5saW5rLmZpbGVhcmVhID0gKGVudHJ5LmZpbGVhcmVhKSA/IGVudHJ5LmZpbGVhcmVhIDogXCJcIjtcbiAgICAgICAgICAgICAgICBlbnRyeS5saW5rLml0ZW1pZCA9IChlbnRyeS5pdGVtaWQpID8gZW50cnkuaXRlbWlkIDogMDtcbiAgICAgICAgICAgICAgICBlbnRyeS5saW5rLmZpbGVwYXRoID0gKGVudHJ5LmZpbGVwYXRoKSA/IGVudHJ5LmZpbGVwYXRoIDogXCJcIjtcbiAgICAgICAgICAgICAgICBlbnRyeS5saW5rLmZpbGVuYW1lID0gKGVudHJ5LmZpbGVuYW1lKSA/IGVudHJ5LmZpbGVuYW1lIDogXCJcIjtcblxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5jb21wb25lbnQgJiYgZW50cnkuaXNkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHVudXNlZCBlbGVtZW50cyB0aGF0IG1heSBicmVhayB0aGUgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgZW50cnkubGluay5maWxlbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmltZ3BhdGggPSAkbW1GUy5nZXRGb2xkZXJJY29uKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuaW1ncGF0aCA9ICRtbUZTLmdldEZpbGVJY29uKGVudHJ5LmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbnRyeS5saW5rID0gSlNPTi5zdHJpbmdpZnkoZW50cnkubGluayk7XG4gICAgICAgICAgICAgICAgZW50cnkubGlua0lkID0gbWQ1LmNyZWF0ZUhhc2goZW50cnkubGluayk7XG4gICAgICAgICAgICAgICAgLy8gZW50cnkubG9jYWxwYXRoID0gXCJcIjtcblxuICAgICAgICAgICAgICAgIC8vIGlmICghZW50cnkuaXNkaXIgJiYgZW50cnkudXJsKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIFRPRE8gQ2hlY2sgJG1tU2l0ZS5cbiAgICAgICAgICAgICAgICAvLyAgICAgdmFyIHVuaXF1ZUlkID0gJG1tU2l0ZS5pZCArIFwiLVwiICsgbWQ1LmNyZWF0ZUhhc2goZW50cnkudXJsKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgdmFyIHBhdGggPSBNTS5kYi5nZXQoXCJmaWxlc1wiLCB1bmlxdWVJZCk7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBlbnRyeS5sb2NhbHBhdGggPSBwYXRoLmdldChcImxvY2FscGF0aFwiKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIGRhdGEuY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICBkYXRhLmVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGZpbGUgbGlzdCBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gcGFyYW1zIFBhcmFtcyBvZiB0aGUgZGlyZWN0b3J5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RmlsZXNMaXN0Q2FjaGVLZXkocGFyYW1zKSB7XG4gICAgICAgIHZhciByb290ID0gcGFyYW1zLmNvbXBvbmVudCA9PT0gJycgPyAnc2l0ZScgOiAnbXknO1xuICAgICAgICByZXR1cm4gJ21tYUZpbGVzOmxpc3Q6JyArIHJvb3QgKyAnOicgKyBwYXJhbXMuY29udGV4dGlkICsgJzonICsgcGFyYW1zLmZpbGVwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJpdmF0ZSBmaWxlcyBvZiB0aGUgY3VycmVudCB1c2VyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI2dldE15RmlsZXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFNlZSAkbW1hRmlsZXMjZ2V0RmlsZXNcbiAgICAgKi9cbiAgICBzZWxmLmdldE15RmlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGdldE15RmlsZXNSb290UGFyYW1zKCk7XG4gICAgICAgIHJldHVybiBzZWxmLmdldEZpbGVzKHBhcmFtcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29tbW9uIHBhcnQgb2YgdGhlIGNhY2hlIGtleXMgZm9yIHByaXZhdGUgZmlsZXMgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNeUZpbGVzTGlzdENvbW1vbkNhY2hlS2V5KCkge1xuICAgICAgICByZXR1cm4gJ21tYUZpbGVzOmxpc3Q6bXknO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBwYXJhbXMgdG8gZ2V0IHJvb3QgcHJpdmF0ZSBmaWxlcyBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFBhcmFtcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNeUZpbGVzUm9vdFBhcmFtcygpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGFuZ3VsYXIuY29weShkZWZhdWx0UGFyYW1zLCB7fSk7XG4gICAgICAgIHBhcmFtcy5jb21wb25lbnQgPSBcInVzZXJcIjtcbiAgICAgICAgcGFyYW1zLmZpbGVhcmVhID0gXCJwcml2YXRlXCI7XG4gICAgICAgIHBhcmFtcy5jb250ZXh0aWQgPSAtMTtcbiAgICAgICAgcGFyYW1zLmNvbnRleHRsZXZlbCA9IFwidXNlclwiO1xuICAgICAgICBwYXJhbXMuaW5zdGFuY2VpZCA9ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaXRlIGZpbGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI2dldFNpdGVGaWxlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gU2VlICRtbWFGaWxlcyNnZXRGaWxlc1xuICAgICAqL1xuICAgIHNlbGYuZ2V0U2l0ZUZpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBhbmd1bGFyLmNvcHkoZGVmYXVsdFBhcmFtcywge30pO1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRGaWxlcyhwYXJhbXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbW1vbiBwYXJ0IG9mIHRoZSBjYWNoZSBrZXlzIGZvciBzaXRlIGZpbGVzIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2l0ZUZpbGVzTGlzdENvbW1vbkNhY2hlS2V5KCkge1xuICAgICAgICByZXR1cm4gJ21tYUZpbGVzOmxpc3Q6c2l0ZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgbGlzdCBvZiBmaWxlcyBpbiBhIGNlcnRhaW4gZGlyZWN0b3J5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI2ludmFsaWRhdGVEaXJlY3RvcnlcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHJvb3QgICAgIFJvb3Qgb2YgdGhlIGRpcmVjdG9yeSAoJ215JyBmb3IgcHJpdmF0ZSBmaWxlcywgJ3NpdGUnIGZvciBzaXRlIGZpbGVzKS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggICAgIFBhdGggdG8gdGhlIGRpcmVjdG9yeS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlaWRdIElkIG9mIHRoZSBzaXRlIHRvIGludmFsaWRhdGUuIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBsaXN0IGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZURpcmVjdG9yeSA9IGZ1bmN0aW9uKHJvb3QsIHBhdGgsIHNpdGVpZCkge1xuICAgICAgICBzaXRlaWQgPSBzaXRlaWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICBpZiAocm9vdCA9PT0gJ3NpdGUnKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gYW5ndWxhci5jb3B5KGRlZmF1bHRQYXJhbXMsIHt9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gJ215Jykge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGdldE15RmlsZXNSb290UGFyYW1zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBKU09OLnBhcnNlKHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICBzaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldEZpbGVzTGlzdENhY2hlS2V5KHBhcmFtcykpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgbGlzdCBvZiBwcml2YXRlIGZpbGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI2ludmFsaWRhdGVNeUZpbGVzXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBsaXN0IGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZU15RmlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXlTdGFydGluZ1dpdGgoZ2V0TXlGaWxlc0xpc3RDb21tb25DYWNoZUtleSgpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgbGlzdCBvZiBzaXRlIGZpbGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI2ludmFsaWRhdGVTaXRlRmlsZXNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGxpc3QgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlU2l0ZUZpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5U3RhcnRpbmdXaXRoKGdldFNpdGVGaWxlc0xpc3RDb21tb25DYWNoZUtleSgpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaXMgZW5hYmxlZC4gUGx1Z2luIGlzIGVuYWJsZWQgaWY6XG4gICAgICogICAgIC0gU2l0ZSBzdXBwb3J0cyBjb3JlX2ZpbGVzX2dldF9maWxlc1xuICAgICAqICAgICBvclxuICAgICAqICAgICAtIFVzZXIgaGFzIGNhcGFiaWxpdHkgbW9vZGxlL3VzZXI6bWFuYWdlb3duZmlsZXMgYW5kIFdTIGFsbG93cyB1cGxvYWRpbmcgZmlsZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXMjaXNQbHVnaW5FbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FuQWNjZXNzRmlsZXMgPSBzZWxmLmNhbkFjY2Vzc0ZpbGVzKCksXG4gICAgICAgICAgICBjYW5BY2Nlc3NNeUZpbGVzID0gJG1tU2l0ZS5jYW5BY2Nlc3NNeUZpbGVzKCksXG4gICAgICAgICAgICBjYW5VcGxvYWRGaWxlcyA9ICRtbVNpdGUuY2FuVXBsb2FkRmlsZXMoKTtcblxuICAgICAgICByZXR1cm4gY2FuQWNjZXNzRmlsZXMgfHwgKGNhblVwbG9hZEZpbGVzICYmIGNhbkFjY2Vzc015RmlsZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBmaWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI3VwbG9hZEZpbGVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHVyaSAgICAgIEZpbGUgVVJJLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgT3B0aW9ucyBmb3IgdGhlIHVwbG9hZC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlbGV0ZUFmdGVyVXBsb2FkIFdoZXRoZXIgb3Igbm90IHRvIGRlbGV0ZSB0aGUgb3JpZ2luYWwgYWZ0ZXIgdXBsb2FkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBmaWxlS2V5XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGZpbGVOYW1lXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IG1pbWVUeXBlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZWlkXSBJZCBvZiB0aGUgc2l0ZSB0byB1cGxvYWQgdGhlIGZpbGUgdG8uIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi51cGxvYWRGaWxlID0gZnVuY3Rpb24odXJpLCBvcHRpb25zLCBzaXRlaWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgdmFyIGRlbGV0ZUFmdGVyVXBsb2FkID0gb3B0aW9ucy5kZWxldGVBZnRlclVwbG9hZCxcbiAgICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKSxcbiAgICAgICAgICAgIGZ0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBmaWxlS2V5OiBvcHRpb25zLmZpbGVLZXksXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IG9wdGlvbnMuZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IG9wdGlvbnMubWltZVR5cGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlRmlsZSgpIHtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBzZXQgdGltZW91dCwgb3RoZXJ3aXNlIGluIE5vZGUtV2Via2l0IHRoZSB1cGxvYWQgdGhyZXcgYW4gZXJyb3Igc29tZXRpbWVzLlxuICAgICAgICAgICAgICAgICRtbUZTLnJlbW92ZUV4dGVybmFsRmlsZSh1cmkpO1xuICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICBzaXRlLnVwbG9hZEZpbGUodXJpLCBmdE9wdGlvbnMpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUFmdGVyVXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZGVsZXRlQWZ0ZXJVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVGaWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBsb2FkIGltYWdlLlxuICAgICAqIEB0b2RvIEhhbmRsZSBOb2RlIFdlYmtpdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlcyN1cGxvYWRJbWFnZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gIHVyaSAgICAgICAgIEZpbGUgVVJJLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzRnJvbUFsYnVtIFRydWUgaWYgdGhlIGltYWdlIHdhcyB0YWtlbiBmcm9tIGFsYnVtLCBmYWxzZSBpZiBpdCdzIGEgbmV3IGltYWdlIHRha2VuIHdpdGggY2FtZXJhLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi51cGxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVyaSwgaXNGcm9tQWxidW0pIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnVXBsb2FkaW5nIGFuIGltYWdlJyk7XG4gICAgICAgIHZhciBkID0gbmV3IERhdGUoKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mKHVyaSkgPT09ICd1bmRlZmluZWQnIHx8IHVyaSA9PT0gJycpe1xuICAgICAgICAgICAgLy8gSW4gTm9kZS1XZWJraXQsIGlmIHlvdSBzdWNjZXNzZnVsbHkgdXBsb2FkIGEgcGljdHVyZSBhbmQgdGhlbiB5b3Ugb3BlbiB0aGUgZmlsZSBwaWNrZXIgYWdhaW5cbiAgICAgICAgICAgIC8vIGFuZCBjYW5jZWwsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYW4gZW1wdHkgdXJpLiBMZXQncyBmaWx0ZXIgaXQuXG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdSZWNlaXZlZCBpbnZhbGlkIFVSSSBpbiAkbW1hRmlsZXMudXBsb2FkSW1hZ2UoKScpO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5kZWxldGVBZnRlclVwbG9hZCA9ICFpc0Zyb21BbGJ1bTtcbiAgICAgICAgb3B0aW9ucy5maWxlS2V5ID0gXCJmaWxlXCI7XG4gICAgICAgIG9wdGlvbnMuZmlsZU5hbWUgPSBcImltYWdlX1wiICsgZC5nZXRUaW1lKCkgKyBcIi5qcGdcIjtcbiAgICAgICAgb3B0aW9ucy5taW1lVHlwZSA9IFwiaW1hZ2UvanBlZ1wiO1xuXG4gICAgICAgIHJldHVybiBzZWxmLnVwbG9hZEZpbGUodXJpLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBsb2FkIG1lZGlhLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzI3VwbG9hZE1lZGlhXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG1lZGlhRmlsZXMgQXJyYXkgb2YgZmlsZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBwcm9taXNlcy5cbiAgICAgKi9cbiAgICBzZWxmLnVwbG9hZE1lZGlhID0gZnVuY3Rpb24obWVkaWFGaWxlcykge1xuICAgICAgICAkbG9nLmRlYnVnKCdVcGxvYWRpbmcgbWVkaWEnKTtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtZWRpYUZpbGVzLCBmdW5jdGlvbihtZWRpYUZpbGUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5maWxlS2V5ID0gbnVsbDtcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsZU5hbWUgPSBtZWRpYUZpbGUubmFtZTtcbiAgICAgICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgb3B0aW9ucy5kZWxldGVBZnRlclVwbG9hZCA9IHRydWU7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYudXBsb2FkRmlsZShtZWRpYUZpbGUuZnVsbFBhdGgsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBsb2FkIGEgZmlsZSBvZiBhbnkgdHlwZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlcyN1cGxvYWRHZW5lcmljRmlsZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdXJpICAgICAgRmlsZSBVUkkuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lICAgICBGaWxlIG5hbWUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlICAgICBGaWxlIHR5cGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZWlkXSBJZCBvZiB0aGUgc2l0ZSB0byB1cGxvYWQgdGhlIGZpbGUgdG8uIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGZpbGUgaXMgdXBsb2FkZWQuXG4gICAgICovXG4gICAgc2VsZi51cGxvYWRHZW5lcmljRmlsZSA9IGZ1bmN0aW9uKHVyaSwgbmFtZSwgdHlwZSwgc2l0ZWlkKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIG9wdGlvbnMuZmlsZUtleSA9IG51bGw7XG4gICAgICAgIG9wdGlvbnMuZmlsZU5hbWUgPSBuYW1lO1xuICAgICAgICBvcHRpb25zLm1pbWVUeXBlID0gdHlwZTtcbiAgICAgICAgLy8gRG9uJ3QgZGVsZXRlIHRoZSBmaWxlIG9uIGlPUywgaXQncyBnb2luZyB0byBiZSBkZWxldGVkIG9uICRtbWFGaWxlcyNjaGVja0lPU05ld0ZpbGVzLlxuICAgICAgICBvcHRpb25zLmRlbGV0ZUFmdGVyVXBsb2FkID0gIWlvbmljLlBsYXRmb3JtLmlzSU9TKCk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYudXBsb2FkRmlsZSh1cmksIG9wdGlvbnMsIHNpdGVpZCk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5maWxlcycpXG5cbi8qKlxuICogRmlsZXMgaGFuZGxlcnMgZmFjdG9yeS5cbiAqXG4gKiBUaGlzIGZhY3RvcnkgaG9sZHMgdGhlIGRpZmZlcmVudCBoYW5kbGVycyB1c2VkIGZvciBkZWxlZ2F0ZXMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hRmlsZXNIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYUZpbGVzSGFuZGxlcnMnLCBmdW5jdGlvbigkbG9nLCAkbW1hRmlsZXMpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYUZpbGVzSGFuZGxlcnMnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBTaWRlIG1lbnUgbmF2IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXNIYW5kbGVycyNzaWRlTWVudU5hdlxuICAgICAqL1xuICAgIHNlbGYuc2lkZU1lbnVOYXYgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFGaWxlcy5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbnRyb2xsZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTaWRlIG1lbnUgbmF2IGhhbmRsZXIgY29udHJvbGxlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFGaWxlc0hhbmRsZXJzI3NpZGVNZW51TmF2OmNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJ2lvbi1mb2xkZXInO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEuZmlsZXMubXlmaWxlcyc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnN0YXRlID0gJ3NpdGUuZmlsZXMnO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLmZpbGVzJylcblxuLmNvbnN0YW50KCdtbWFGaWxlc0ZpbGVTaXplV2FybmluZycsIDUyNDI4ODApXG5cbi5mYWN0b3J5KCckbW1hRmlsZXNIZWxwZXInLCBmdW5jdGlvbigkcSwgJG1tVXRpbCwgJG1tQXBwLCAkbG9nLCAkdHJhbnNsYXRlLCAkd2luZG93LFxuICAgICAgICAkbW1hRmlsZXMsICRjb3Jkb3ZhQ2FtZXJhLCAkY29yZG92YUNhcHR1cmUsICRtbUxhbmcsICRtbUZTLCAkbW1UZXh0LCBtbWFGaWxlc0ZpbGVTaXplV2FybmluZykge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFGaWxlc0hlbHBlcicpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbnQgaGVscGVyIGZvciB0aGUgdXNlciB0byB1cGxvYWQgYW4gaW1hZ2UgZnJvbSBhbiBhbGJ1bS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlc0hlbHBlciN1cGxvYWRJbWFnZUZyb21BbGJ1bVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSByZWplY3QgY29udGFpbnMgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIHRoZXJlIGlzIG5vIGVycm9yIG1lc3NhZ2VcbiAgICAgKiAgICAgICAgICAgICAgICAgICB0aGVuIHdlIGNhbiBjb25zaWRlciB0aGF0IHRoaXMgaXMgYSBzaWxlbnQgZmFpbC5cbiAgICAgKi9cbiAgICBzZWxmLnVwbG9hZEltYWdlRnJvbUFsYnVtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ1RyeWluZyB0byBnZXQgYSBpbWFnZSBmcm9tIGFsYnVtcycpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIHZhciB3aWR0aCAgPSAgJHdpbmRvdy5pbm5lcldpZHRoICAtIDIwMDtcbiAgICAgICAgdmFyIGhlaWdodCA9ICAkd2luZG93LmlubmVySGVpZ2h0IC0gMjAwO1xuXG4gICAgICAgIC8vIGlQYWQgcG9wT3Zlciwgc2VlIGh0dHBzOi8vdHJhY2tlci5tb29kbGUub3JnL2Jyb3dzZS9NT0JJTEUtMjA4XG4gICAgICAgIHZhciBwb3BvdmVyID0gbmV3IENhbWVyYVBvcG92ZXJPcHRpb25zKDEwLCAxMCwgd2lkdGgsIGhlaWdodCwgQ2FtZXJhLlBvcG92ZXJBcnJvd0RpcmVjdGlvbi5BUlJPV19BTlkpO1xuICAgICAgICAkY29yZG92YUNhbWVyYS5nZXRQaWN0dXJlKHtcbiAgICAgICAgICAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgICAgZGVzdGluYXRpb25UeXBlOiBuYXZpZ2F0b3IuY2FtZXJhLkRlc3RpbmF0aW9uVHlwZS5GSUxFX1VSSSxcbiAgICAgICAgICAgIHNvdXJjZVR5cGU6IG5hdmlnYXRvci5jYW1lcmEuUGljdHVyZVNvdXJjZVR5cGUuUEhPVE9MSUJSQVJZLFxuICAgICAgICAgICAgcG9wb3Zlck9wdGlvbnMgOiBwb3BvdmVyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tYS5maWxlcy51cGxvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICRtbWFGaWxlcy51cGxvYWRJbWFnZShpbWcsIHRydWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW1hLmZpbGVzLmVycm9yd2hpbGV1cGxvYWRpbmcnKTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHRyZWF0SW1hZ2VFcnJvcihlcnJvciwgZGVmZXJyZWQsICdtbWEuZmlsZXMuZXJyb3JnZXR0aW5naW1hZ2VhbGJ1bScpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVudCBoZWxwZXIgZm9yIHRoZSB1c2VyIHRvIHRha2UgYW4gaW1hZ2Ugd2l0aCB0aGUgY2FtZXJhIGFuZCB1cGxvYWQgaXQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXNIZWxwZXIjdXBsb2FkSW1hZ2VGcm9tQ2FtZXJhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHJlamVjdCBjb250YWlucyB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgdGhlcmUgaXMgbm8gZXJyb3IgbWVzc2FnZVxuICAgICAqICAgICAgICAgICAgICAgICAgIHRoZW4gd2UgY2FuIGNvbnNpZGVyIHRoYXQgdGhpcyBpcyBhIHNpbGVudCBmYWlsLlxuICAgICAqL1xuICAgIHNlbGYudXBsb2FkSW1hZ2VGcm9tQ2FtZXJhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ1RyeWluZyB0byBjYXB0dXJlIGFuIGltYWdlIHdpdGggY2FtZXJhJyk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgJGNvcmRvdmFDYW1lcmEuZ2V0UGljdHVyZSh7XG4gICAgICAgICAgICBxdWFsaXR5OiA1MCxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uVHlwZTogbmF2aWdhdG9yLmNhbWVyYS5EZXN0aW5hdGlvblR5cGUuRklMRV9VUklcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW1hLmZpbGVzLnVwbG9hZGluZycsIHRydWUpO1xuICAgICAgICAgICAgJG1tYUZpbGVzLnVwbG9hZEltYWdlKGltZywgZmFsc2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW1hLmZpbGVzLmVycm9yd2hpbGV1cGxvYWRpbmcnKTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHRyZWF0SW1hZ2VFcnJvcihlcnJvciwgZGVmZXJyZWQsICdtbWEuZmlsZXMuZXJyb3JjYXB0dXJpbmdpbWFnZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVudCBoZWxwZXIgZm9yIHRoZSB1c2VyIHRvIHJlY29yZCBhbmQgdXBsb2FkIGFuIGF1ZGlvLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzSGVscGVyI3VwbG9hZEF1ZGlvXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHJlamVjdCBjb250YWlucyB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgdGhlcmUgaXMgbm8gZXJyb3IgbWVzc2FnZVxuICAgICAqICAgICAgICAgICAgICAgICAgIHRoZW4gd2UgY2FuIGNvbnNpZGVyIHRoYXQgdGhpcyBpcyBhIHNpbGVudCBmYWlsLlxuICAgICAqL1xuICAgIHNlbGYudXBsb2FkQXVkaW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnVHJ5aW5nIHRvIHJlY29yZCBhbiBhdWRpbyBmaWxlJyk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgJGNvcmRvdmFDYXB0dXJlLmNhcHR1cmVBdWRpbyh7bGltaXQ6IDF9KS50aGVuKGZ1bmN0aW9uKG1lZGlhcykge1xuICAgICAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbWEuZmlsZXMudXBsb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAkcS5hbGwoJG1tYUZpbGVzLnVwbG9hZE1lZGlhKG1lZGlhcykpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW1hLmZpbGVzLmVycm9yd2hpbGV1cGxvYWRpbmcnKTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHRyZWF0Q2FwdHVyZUVycm9yKGVycm9yLCBkZWZlcnJlZCwgJ21tYS5maWxlcy5lcnJvcmNhcHR1cmluZ2F1ZGlvJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW50IGhlbHBlciBmb3IgdGhlIHVzZXIgdG8gcmVjb3JkIGFuZCB1cGxvYWQgYSB2aWRlby5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlc0hlbHBlciN1cGxvYWRWaWRlb1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSByZWplY3QgY29udGFpbnMgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIHRoZXJlIGlzIG5vIGVycm9yIG1lc3NhZ2VcbiAgICAgKiAgICAgICAgICAgICAgICAgICB0aGVuIHdlIGNhbiBjb25zaWRlciB0aGF0IHRoaXMgaXMgYSBzaWxlbnQgZmFpbC5cbiAgICAgKi9cbiAgICBzZWxmLnVwbG9hZFZpZGVvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRsb2cuZGVidWcoJ1RyeWluZyB0byByZWNvcmQgYSB2aWRlbyBmaWxlJyk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgJGNvcmRvdmFDYXB0dXJlLmNhcHR1cmVWaWRlbyh7bGltaXQ6IDF9KS50aGVuKGZ1bmN0aW9uKG1lZGlhcykge1xuICAgICAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbWEuZmlsZXMudXBsb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAkcS5hbGwoJG1tYUZpbGVzLnVwbG9hZE1lZGlhKG1lZGlhcykpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW1hLmZpbGVzLmVycm9yd2hpbGV1cGxvYWRpbmcnKTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHRyZWF0Q2FwdHVyZUVycm9yKGVycm9yLCBkZWZlcnJlZCwgJ21tYS5maWxlcy5lcnJvcmNhcHR1cmluZ3ZpZGVvJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93IGEgY29uZmlybWF0aW9uIG1vZGFsIHRvIHRoZSB1c2VyIGlmIGhlIGlzIHVzaW5nIGEgbGltaXRlZCBjb25uZWN0aW9uIG9yIHRoZSBmaWxlIHNpemUgaXMgaGlnaGVyIHRoYW4gNU1CLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZmlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZpbGVzSGVscGVyI2NvbmZpcm1VcGxvYWRGaWxlXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzaXplIEZpbGUncyBzaXplLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHVzZXIgY29uZmlybXMgb3IgaWYgdGhlcmUncyBubyBuZWVkIHRvIHNob3cgYSBtb2RhbC5cbiAgICAgKi9cbiAgICBzZWxmLmNvbmZpcm1VcGxvYWRGaWxlID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICBpZiAoISRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3QoJ21tYS5maWxlcy5lcnJvcm11c3RiZW9ubGluZXRvdXBsb2FkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJG1tQXBwLmlzTmV0d29ya0FjY2Vzc0xpbWl0ZWQoKSB8fCBzaXplID49IG1tYUZpbGVzRmlsZVNpemVXYXJuaW5nKSB7XG4gICAgICAgICAgICAgdmFyIHNpemUgPSAkbW1UZXh0LmJ5dGVzVG9TaXplKHNpemUsIDIpO1xuICAgICAgICAgICAgcmV0dXJuICRtbVV0aWwuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSgnbW1hLmZpbGVzLmNvbmZpcm11cGxvYWRmaWxlJywge3NpemU6IHNpemV9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdGVtcG9yYXJ5IGNvcHkgb2YgYSBmaWxlIGFuZCB1cGxvYWQgaXQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5maWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRmlsZXNIZWxwZXIjY29weUFuZFVwbG9hZEZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZSBGaWxlIHRvIGNvcHkgYW5kIHVwbG9hZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGZpbGUgaXMgdXBsb2FkZWQuXG4gICAgICovXG4gICAgc2VsZi5jb3B5QW5kVXBsb2FkRmlsZSA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tYS5maWxlcy5yZWFkaW5nZmlsZScsIHRydWUpO1xuXG4gICAgICAgIC8vIFdlIGhhdmUgdGhlIGRhdGEgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQsIGJ1dCBub3QgaXRzIFVSTCAobmVlZGVkKS4gQ3JlYXRlIGEgY29weSBvZiB0aGUgZmlsZSB0byB1cGxvYWQgaXQuXG4gICAgICAgICRtbUZTLnJlYWRGaWxlRGF0YShmaWxlLCAkbW1GUy5GT1JNQVRBUlJBWUJVRkZFUikudGhlbihmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgICAgIHZhciBmaWxlcGF0aCA9ICRtbUZTLmdldFRtcEZvbGRlcigpICsgJy8nICsgZmlsZS5uYW1lO1xuXG4gICAgICAgICAgICAkbW1GUy53cml0ZUZpbGUoZmlsZXBhdGgsIGRhdGEpLnRoZW4oZnVuY3Rpb24oZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgIHNlbGYudXBsb2FkR2VuZXJpY0ZpbGUoZmlsZUVudHJ5LnRvVVJMKCksIGZpbGUubmFtZSwgZmlsZS50eXBlKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIHdyaXRpbmcgZmlsZSB0byB1cGxvYWQ6ICcrSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW1hLmZpbGVzLmVycm9ycmVhZGluZ2ZpbGUnKTtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgcmVhZGluZyBmaWxlIHRvIHVwbG9hZDogJytKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgJ21tYS5maWxlcy5lcnJvcnJlYWRpbmdmaWxlJyk7XG4gICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBvZiBhbnkgdHlwZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlc0hlbHBlciN1cGxvYWRHZW5lcmljRmlsZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdXJpICAgICAgRmlsZSBVUkkuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lICAgICBGaWxlIG5hbWUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlICAgICBGaWxlIHR5cGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZWlkXSBJZCBvZiB0aGUgc2l0ZSB0byB1cGxvYWQgdGhlIGZpbGUgdG8uIElmIG5vdCBkZWZpbmVkLCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBmaWxlIGlzIHVwbG9hZGVkLlxuICAgICAqL1xuICAgIHNlbGYudXBsb2FkR2VuZXJpY0ZpbGUgPSBmdW5jdGlvbih1cmksIG5hbWUsIHR5cGUsIHNpdGVpZCkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0RGVmZXJyZWQoZGVmZXJyZWQsICdtbWEuZmlsZXMuZXJyb3JtdXN0YmVvbmxpbmV0b3VwbG9hZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tYS5maWxlcy51cGxvYWRpbmcnLCB0cnVlKTtcblxuICAgICAgICAkbW1hRmlsZXMudXBsb2FkR2VuZXJpY0ZpbGUodXJpLCBuYW1lLCB0eXBlLCBzaXRlaWQpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIHVwbG9hZGluZyBmaWxlOiAnK0pTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCAnbW1hLmZpbGVzLmVycm9yd2hpbGV1cGxvYWRpbmcnKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHVwbG9hZCBhIGZpbGUgb24gYSBjZXJ0YWluIHNpdGUsIHNob3dpbmcgYSBjb25maXJtIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZpbGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFGaWxlc0hlbHBlciNzaG93Q29uZmlybUFuZFVwbG9hZEluU2l0ZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZUVudHJ5IEZpbGVFbnRyeSBvZiB0aGUgZmlsZSB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZWlkXSAgSWQgb2YgdGhlIHNpdGUgdG8gdXBsb2FkIHRoZSBmaWxlIHRvLiBJZiBub3QgZGVmaW5lZCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGZpbGUgaXMgdXBsb2FkZWQuXG4gICAgICovXG4gICAgc2VsZi5zaG93Q29uZmlybUFuZFVwbG9hZEluU2l0ZSA9IGZ1bmN0aW9uKGZpbGVFbnRyeSwgc2l0ZWlkKSB7XG4gICAgICAgIHJldHVybiAkbW1GUy5nZXRGaWxlT2JqZWN0RnJvbUZpbGVFbnRyeShmaWxlRW50cnkpLnRoZW4oZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29uZmlybVVwbG9hZEZpbGUoZmlsZS5zaXplKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnVwbG9hZEdlbmVyaWNGaWxlKGZpbGVFbnRyeS50b1VSTCgpLCBmaWxlLm5hbWUsIGZpbGUudHlwZSwgc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIG15IGZpbGVzIHJvb3QgZGlyIHNvIHRoZSBsaXN0IGlzIHJlZnJlc2hlZCB3aGVuIHRoZSB1c2VyIGdvZXMgaW4uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hRmlsZXMuaW52YWxpZGF0ZURpcmVjdG9yeSgnbXknLCB1bmRlZmluZWQsIHNpdGVpZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd01vZGFsKCdtbS5jb3JlLnN1Y2Nlc3MnLCAnbW1hLmZpbGVzLmZpbGV1cGxvYWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEuZmlsZXMuZXJyb3JyZWFkaW5nZmlsZScsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmVhdCBhIGNhcHR1cmUgaW1hZ2Ugb3IgYnJvd3NlIGFsYnVtIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBlcnJvciAgICAgICAgICBFcnJvciByZXR1cm5lZCBieSB0aGUgQ29yZG92YSBwbHVnaW4uXG4gICAgICogQHBhcmFtICB7UHJvbWlzZX0gZGVmZXJyZWQgICAgICBQcm9taXNlIHRvIHJlamVjdC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRlZmF1bHRNZXNzYWdlIEtleSBvZiB0aGUgZGVmYXVsdCBtZXNzYWdlIHRvIHNob3cuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJlYXRJbWFnZUVycm9yKGVycm9yLCBkZWZlcnJlZCwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICAgICAgLy8gQ2FuY2VsbGVkLCBvciBlcnJvci4gSWYgY2FuY2VsbGVkLCBlcnJvciBpcyBhIHN0cmluZyB3aXRoIFwiU2VsZWN0aW9uIGNhbmNlbGxlZC5cIiBvciBcIkNhbWVyYSBjYW5jZWxsZWQuXCIuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihlcnJvcikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImVycm9yXCIpID4gLTEgfHwgZXJyb3IudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwidW5hYmxlXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3IgZ2V0dGluZyBpbWFnZTogJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdDYW5jZWxsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1MYW5nLnRyYW5zbGF0ZUFuZFJlamVjdERlZmVycmVkKGRlZmVycmVkLCBkZWZhdWx0TWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyZWF0IGEgY2FwdHVyZSBhdWRpby92aWRlbyBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge01peGVkfSBlcnJvciAgICAgICAgICAgRXJyb3IgcmV0dXJuZWQgYnkgdGhlIENvcmRvdmEgcGx1Z2luLiBDYW4gYmUgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge1Byb21pc2V9IGRlZmVycmVkICAgICAgUHJvbWlzZSB0byByZWplY3QuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBkZWZhdWx0TWVzc2FnZSBLZXkgb2YgdGhlIGRlZmF1bHQgbWVzc2FnZSB0byBzaG93LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyZWF0Q2FwdHVyZUVycm9yKGVycm9yLCBkZWZlcnJlZCwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICAgICAgLy8gQ2FuY2VsbGVkLCBvciBlcnJvci4gSWYgY2FuY2VsbGVkLCBlcnJvciBpcyBhbiBvYmplY3Qgd2l0aCBjb2RlID0gMy5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGVycm9yKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciB3aGlsZSByZWNvcmRpbmcgYXVkaW8vdmlkZW86ICcgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZGV4T2YoJ05vIEFjdGl2aXR5IGZvdW5kJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2VyIGRvZXNuJ3QgaGF2ZSBhbiBhcHAgdG8gZG8gdGhpcy5cbiAgICAgICAgICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgJ21tYS5maWxlcy5lcnJvcm5vYXBwJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgZGVmYXVsdE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT0gMykge1xuICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciwgbm90IGNhbmNlbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3Igd2hpbGUgcmVjb3JkaW5nIGF1ZGlvL3ZpZGVvOiAnICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgJG1tTGFuZy50cmFuc2xhdGVBbmRSZWplY3REZWZlcnJlZChkZWZlcnJlZCwgZGVmYXVsdE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0NhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5mcm9udHBhZ2UnKVxuXG4vKipcbiAqIEZyb250cGFnZSBmYWN0b3J5LlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLmZyb250cGFnZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFGcm9udHBhZ2VcbiAqL1xuLmZhY3RvcnkoJyRtbWFGcm9udHBhZ2UnLCBmdW5jdGlvbigkbW1TaXRlLCAkbG9nLCAkcSwgJG1tQ291cnNlKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFGcm9udHBhZ2UnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaXMgZW5hYmxlZCBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBxdWl0ZSBvZnRlbiBhbmQgdGh1cyBzaG91bGQgb25seSBwZXJmb3JtIGEgcXVpY2tcbiAgICAgKiBjaGVjaywgd2Ugc2hvdWxkIG5vdCBiZSBjYWxsaW5nIFdTIGZyb20gaGVyZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZyb250cGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRnJvbnRwYWdlI2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZnJvbnRwYWdlIGlzIGF2YWlsYWJsZSBmb3IgdGhlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY291bGQgY2FsbCBhIFdTIHNvIGRvIG5vdCBhYnVzZSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZyb250cGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hRnJvbnRwYWdlI2lzRnJvbnRwYWdlQXZhaWxhYmxlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBlbmFibGVkLCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pc0Zyb250cGFnZUF2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIE9uIG9sZGVyIHZlcnNpb24gd2UgY2Fubm90IGNoZWNrIG90aGVyIHRoYW4gY2FsbGluZyBhIFdTLiBJZiB0aGUgcmVxdWVzdFxuICAgICAgICAvLyBmYWlscyB0aGVyZSBpcyBhIHZlcnkgaGlnaCBjaGFuY2UgdGhhdCBmcm9udHBhZ2UgaXMgbm90IGF2YWlsYWJsZS5cbiAgICAgICAgJGxvZy5kZWJ1ZygnVXNpbmcgV1MgY2FsbCB0byBjaGVjayBpZiBmcm9udHBhZ2UgaXMgYXZhaWxhYmxlLicpO1xuICAgICAgICByZXR1cm4gJG1tQ291cnNlLmdldFNlY3Rpb25zKDEsIHtlbWVyZ2VuY3lDYWNoZTogZmFsc2V9KS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghYW5ndWxhci5pc0FycmF5KGRhdGEpIHx8IGRhdGEubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuZnJvbnRwYWdlJylcblxuLyoqXG4gKiBGcm9udCBwYWdlIGhhbmRsZXJzIGZhY3RvcnkuXG4gKlxuICogVGhpcyBmYWN0b3J5IGhvbGRzIHRoZSBkaWZmZXJlbnQgaGFuZGxlcnMgdXNlZCBmb3IgZGVsZWdhdGVzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLmZyb250cGFnZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFGcm9udFBhZ2VIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYUZyb250UGFnZUhhbmRsZXJzJywgZnVuY3Rpb24oJGxvZywgJG1tYUZyb250cGFnZSkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hRnJvbnRQYWdlSGFuZGxlcnMnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBTaWRlIG1lbnUgbmF2IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5mcm9udHBhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUZyb250UGFnZUhhbmRsZXJzI3NpZGVNZW51TmF2XG4gICAgICovXG4gICAgc2VsZi5zaWRlTWVudU5hdiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZXxCb29sZWFufSBJZiBoYW5kbGVyIGlzIGVuYWJsZWQgcmV0dXJucyBhIHJlc29sdmVkIHByb21pc2UuIElmIGl0J3Mgbm90IGl0IGNhbiByZXR1cm4gYVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdGVkIHByb21pc2Ugb3IgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCRtbWFGcm9udHBhZ2UuaXNQbHVnaW5FbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tYUZyb250cGFnZS5pc0Zyb250cGFnZUF2YWlsYWJsZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29udHJvbGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNpZGUgbWVudSBuYXYgaGFuZGxlciBjb250cm9sbGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmZyb250cGFnZVxuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFGcm9udFBhZ2VIYW5kbGVycyNzaWRlTWVudU5hdjpjb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICdpb24taG9tZSc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5mcm9udHBhZ2Uuc2l0ZWhvbWUnO1xuICAgICAgICAgICAgICAgICRzY29wZS5zdGF0ZSA9ICdzaXRlLm1tX2NvdXJzZS1zZWN0aW9uJztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5ncmFkZXMnKVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gaGFuZGxlIGNvdXJzZSBncmFkZXMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuZ3JhZGVzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hR3JhZGVzVGFibGVDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFHcmFkZXNUYWJsZUN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tVXRpbCwgJG1tYUdyYWRlcywgJG1tU2l0ZSkge1xuXG4gICAgdmFyIGNvdXJzZSA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2UgfHwge30sXG4gICAgICAgIGNvdXJzZWlkID0gY291cnNlLmlkLFxuICAgICAgICB1c2VyaWQgPSAkc3RhdGVQYXJhbXMudXNlcmlkIHx8ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICBmdW5jdGlvbiBmZXRjaEdyYWRlcyhyZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiAkbW1hR3JhZGVzLmdldEdyYWRlc1RhYmxlKGNvdXJzZWlkLCB1c2VyaWQsIHJlZnJlc2gpLnRoZW4oZnVuY3Rpb24odGFibGUpIHtcbiAgICAgICAgICAgICRzY29wZS5ncmFkZXNUYWJsZSA9IHRhYmxlO1xuICAgICAgICB9LCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgJHNjb3BlLmVycm9ybWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaEdyYWRlcygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEFkZCBsb2cgaW4gTW9vZGxlLlxuICAgICAgICAkbW1TaXRlLndyaXRlKCdncmFkZXJlcG9ydF91c2VyX3ZpZXdfZ3JhZGVfcmVwb3J0Jywge1xuICAgICAgICAgICAgY291cnNlaWQ6IGNvdXJzZWlkLFxuICAgICAgICAgICAgdXNlcmlkOiB1c2VyaWRcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmdyYWRlc0xvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUucmVmcmVzaEdyYWRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmZXRjaEdyYWRlcyh0cnVlKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMuZ3JhZGVzJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGhhbmRsZSBncmFkZXMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMuZ3JhZGVzXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYUdyYWRlc1xuICovXG4uZmFjdG9yeSgnJG1tYUdyYWRlcycsIGZ1bmN0aW9uKCRxLCAkbG9nLCAkbW1TaXRlLCAkbW1UZXh0LCAkaW9uaWNQbGF0Zm9ybSwgJHRyYW5zbGF0ZSwgJG1tQ291cnNlLCAkbW1Db3Vyc2VzLCAkbW1TaXRlc01hbmFnZXIpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hR3JhZGVzJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyB0aGUgcmVzcG9uc2Ugb2YgZ3JhZGVyZXBvcnRfdXNlcl9nZXRfZ3JhZGVzX3RhYmxlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgdGFibGUgICAgICBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgYSB0YWJsZSB3aXRoIGRhdGEuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gc2hvd1NpbXBsZSBUcnVlIGlmIHNpbXBsZSB0YWJsZSBzaG91bGQgYmUgc2hvd24sIGZhbHNlIGZvciBmdWxsIHRhYmxlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgRm9ybWF0dGVkIEhUTUwgdGFibGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0R3JhZGVzVGFibGUodGFibGUsIHNob3dTaW1wbGUpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZCA9IHtcbiAgICAgICAgICAgIGNvbHVtbnM6IFtdLFxuICAgICAgICAgICAgcm93czogW11cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRhYmxlIHx8ICF0YWJsZS50YWJsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2x1bW5zLCBieSBvcmRlci5cbiAgICAgICAgdmFyIGNvbHVtbnMgPSBbIFwiaXRlbW5hbWVcIiwgXCJ3ZWlnaHRcIiwgXCJncmFkZVwiLCBcInJhbmdlXCIsIFwicGVyY2VudGFnZVwiLCBcImxldHRlcmdyYWRlXCIsIFwicmFua1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdmVyYWdlXCIsIFwiZmVlZGJhY2tcIiwgXCJjb250cmlidXRpb250b2NvdXJzZXRvdGFsXCJdO1xuICAgICAgICB2YXIgcmV0dXJuZWRDb2x1bW5zID0gW107XG5cbiAgICAgICAgdmFyIHRhYmxlZGF0YSA9IFtdO1xuICAgICAgICB2YXIgbWF4RGVwdGggPSAwO1xuICAgICAgICAvLyBDaGVjayBjb2x1bW5zIHJldHVybmVkIChtYXliZSBzb21lIG9mIHRoZSBhYm92ZSkuXG4gICAgICAgIGlmICh0YWJsZS50YWJsZXMgJiYgdGFibGUudGFibGVzWzBdICYmIHRhYmxlLnRhYmxlc1swXVsndGFibGVkYXRhJ10pIHtcbiAgICAgICAgICAgIHRhYmxlZGF0YSA9IHRhYmxlLnRhYmxlc1swXVsndGFibGVkYXRhJ107XG4gICAgICAgICAgICBtYXhEZXB0aCA9IHRhYmxlLnRhYmxlc1swXVsnbWF4ZGVwdGgnXTtcbiAgICAgICAgICAgIGZvciAodmFyIGVsIGluIHRhYmxlZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB0eXBpY2FsIHJvdy5cbiAgICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNBcnJheSh0YWJsZWRhdGFbZWxdKSAmJiB0eXBlb2YodGFibGVkYXRhW2VsXVtcImxlYWRlclwiXSkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sIGluIHRhYmxlZGF0YVtlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkQ29sdW1ucy5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVybmVkQ29sdW1ucy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIFJlZHVjZSB0aGUgcmV0dXJuZWQgY29sdW1ucyBmb3IgcGhvbmUgdmVyc2lvbi5cbiAgICAgICAgICAgIGlmIChzaG93U2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuZWRDb2x1bW5zID0gW1wiaXRlbW5hbWVcIiwgXCJncmFkZVwiXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgZWwgaW4gY29sdW1ucykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xOYW1lID0gY29sdW1uc1tlbF07XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkQ29sdW1ucy5pbmRleE9mKGNvbE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gY29sTmFtZSA9PSBcIml0ZW1uYW1lXCIgPyBtYXhEZXB0aCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkLmNvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5hbWUsIHJvd3NwYW4sIHRjbGFzcywgY29sc3BhbiwgY29udGVudCwgY2VsbHR5cGUsIGlkLCBoZWFkZXJzLGosIGltZywgY29sc3BhblZhbDtcblxuICAgICAgICAgICAgdmFyIGxlbiA9IHRhYmxlZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YodGFibGVkYXRhW2ldWydsZWFkZXInXSkgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByb3dzcGFuID0gdGFibGVkYXRhW2ldWydsZWFkZXInXVsncm93c3BhbiddO1xuICAgICAgICAgICAgICAgICAgICB0Y2xhc3MgPSB0YWJsZWRhdGFbaV1bJ2xlYWRlciddWydjbGFzcyddO1xuICAgICAgICAgICAgICAgICAgICByb3cgKz0gJzx0ZCBjbGFzcz1cIicgKyB0Y2xhc3MgKyAnXCIgcm93c3Bhbj1cIicgKyByb3dzcGFuICsgJ1wiPjwvdGQ+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChlbCBpbiByZXR1cm5lZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHJldHVybmVkQ29sdW1uc1tlbF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZih0YWJsZWRhdGFbaV1bbmFtZV0pICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRjbGFzcyA9ICh0eXBlb2YodGFibGVkYXRhW2ldW25hbWVdWydjbGFzcyddKSAhPSBcInVuZGVmaW5lZFwiKT8gdGFibGVkYXRhW2ldW25hbWVdWydjbGFzcyddIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzcGFuID0gKHR5cGVvZih0YWJsZWRhdGFbaV1bbmFtZV1bJ2NvbHNwYW4nXSkgIT0gXCJ1bmRlZmluZWRcIik/IFwiY29sc3Bhbj0nXCIrdGFibGVkYXRhW2ldW25hbWVdWydjb2xzcGFuJ10rXCInXCIgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSAodHlwZW9mKHRhYmxlZGF0YVtpXVtuYW1lXVsnY29udGVudCddKSAhPSBcInVuZGVmaW5lZFwiKT8gdGFibGVkYXRhW2ldW25hbWVdWydjb250ZW50J10gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHR5cGUgPSAodHlwZW9mKHRhYmxlZGF0YVtpXVtuYW1lXVsnY2VsbHR5cGUnXSkgIT0gXCJ1bmRlZmluZWRcIik/IHRhYmxlZGF0YVtpXVtuYW1lXVsnY2VsbHR5cGUnXSA6ICd0ZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9ICh0eXBlb2YodGFibGVkYXRhW2ldW25hbWVdWydpZCddKSAhPSBcInVuZGVmaW5lZFwiKT8gXCJpZD0nXCIgKyB0YWJsZWRhdGFbaV1bbmFtZV1bJ2lkJ10gK1wiJ1wiIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0gKHR5cGVvZih0YWJsZWRhdGFbaV1bbmFtZV1bJ2hlYWRlcnMnXSkgIT0gXCJ1bmRlZmluZWRcIik/IFwiaGVhZGVycz0nXCIgKyB0YWJsZWRhdGFbaV1bbmFtZV1bJ2hlYWRlcnMnXSArIFwiJ1wiIDogJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY29udGVudCkgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZyA9IGdldEltZ0hUTUwoY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvPFxcL3NwYW4+L2dpLCBcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gJG1tVGV4dC5jbGVhblRhZ3MoY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShcIlxcblwiLCBcIjxiciAvPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gaW1nICsgXCIgXCIgKyBjb250ZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ICs9IFwiPFwiICsgY2VsbHR5cGUgKyBcIiBcIiArIGlkICsgXCIgXCIgKyBoZWFkZXJzICsgXCIgXCIgKyBcImNsYXNzPSdcIisgdGNsYXNzICtcIicgXCIgKyBjb2xzcGFuICtcIj5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgKz0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgKz0gXCI8L1wiICsgY2VsbHR5cGUgKyBcIj5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQucm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEhUTUwgY29kZSB0byByZW5kZXIgdGhlIGNvbnRlbnRzIGltZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dCBIVE1MIHdoZXJlIHRoZSBpbWFnZSB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICBIVE1MIGNvZGUgdG8gcmVuZGVyIHRoZSBpbWFnZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbWdIVE1MKHRleHQpIHtcbiAgICAgICAgdmFyIGltZyA9ICcnO1xuXG4gICAgICAgIGlmICh0ZXh0LmluZGV4T2YoXCIvYWdnX21lYW5cIikgPiAtMSkge1xuICAgICAgICAgICAgaW1nID0gJzxpbWcgc3JjPVwiYWRkb25zL2dyYWRlcy9pbWcvYWdnX21lYW4ucG5nXCIgd2lkdGg9XCIxNlwiPic7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dC5pbmRleE9mKFwiL2FnZ19zdW1cIikgPiAtMSkge1xuICAgICAgICAgICAgaW1nID0gJzxpbWcgc3JjPVwiYWRkb25zL2dyYWRlcy9pbWcvYWdnX3N1bS5wbmdcIiB3aWR0aD1cIjE2XCI+JztcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0LmluZGV4T2YoXCIvb3V0Y29tZXNcIikgPiAtMSkge1xuICAgICAgICAgICAgaW1nID0gJzxpbWcgc3JjPVwiYWRkb25zL2dyYWRlcy9pbWcvb3V0Y29tZXMucG5nXCIgd2lkdGg9XCIxNlwiPic7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dC5pbmRleE9mKFwiaS9mb2xkZXJcIikgPiAtMSkge1xuICAgICAgICAgICAgaW1nID0gJzxpbWcgc3JjPVwiYWRkb25zL2dyYWRlcy9pbWcvZm9sZGVyLnBuZ1wiIHdpZHRoPVwiMTZcIj4nO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQuaW5kZXhPZihcIi9tYW51YWxfaXRlbVwiKSA+IC0xKSB7XG4gICAgICAgICAgICBpbWcgPSAnPGltZyBzcmM9XCJhZGRvbnMvZ3JhZGVzL2ltZy9tYW51YWxfaXRlbS5wbmdcIiB3aWR0aD1cIjE2XCI+JztcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0LmluZGV4T2YoXCIvbW9kL1wiKSA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgbW9kdWxlID0gdGV4dC5tYXRjaCgvbW9kXFwvKFteXFwvXSopXFwvLyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZVsxXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZVNyYyA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKG1vZHVsZVsxXSk7XG4gICAgICAgICAgICAgICAgaW1nID0gJzxpbWcgc3JjPVwiJyArIG1vZHVsZVNyYyArICdcIiB3aWR0aD1cIjE2XCI+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1nKSB7XG4gICAgICAgICAgICBpbWcgPSAnPHNwYW4gY2xhc3M9XCJhcHAtaWNvXCI+JyArIGltZyArICc8L3NwYW4+JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIG5hbWVzIG9mIHRoZSBncmFkZXMgdGFibGUgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdGFibGUgR3JhZGVzIHRhYmxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aXRoIHRoZSB0cmFuc2xhdGVkIHRhYmxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZUdyYWRlc1RhYmxlKHRhYmxlKSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gYW5ndWxhci5jb3B5KHRhYmxlLmNvbHVtbnMpLFxuICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICR0cmFuc2xhdGUoJ21tYS5ncmFkZXMuJytjb2x1bW4ubmFtZSkudGhlbihmdW5jdGlvbih0cmFuc2xhdGVkKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLm5hbWUgPSB0cmFuc2xhdGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zLFxuICAgICAgICAgICAgICAgIHJvd3M6IHRhYmxlLnJvd3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ncmFkZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUdyYWRlcyNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICBUcnVlIGlmIHBsdWdpbiBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLndzQXZhaWxhYmxlKCdncmFkZXJlcG9ydF91c2VyX2dldF9ncmFkZXNfdGFibGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGdyYWRlIGFkZG9uIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBjb3Vyc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ncmFkZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUdyYWRlcyNpc1BsdWdpbkVuYWJsZWRGb3JDb3Vyc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWRGb3JDb3Vyc2UgPSBmdW5jdGlvbihjb3Vyc2VJZCwgc2l0ZUlkKSB7XG4gICAgICAgIGlmICghY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1Db3Vyc2VzLmdldFVzZXJDb3Vyc2UoY291cnNlSWQsIHRydWUsIHNpdGVJZCkudGhlbihmdW5jdGlvbihjb3Vyc2UpIHtcbiAgICAgICAgICAgIGlmIChjb3Vyc2UgJiYgdHlwZW9mIGNvdXJzZS5zaG93Z3JhZGVzICE9ICd1bmRlZmluZWQnICYmICFjb3Vyc2Uuc2hvd2dyYWRlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBncmFkZXMgZm9yIGEgY2VydGFpbiBjb3Vyc2UuXG4gICAgICogRm9yIG5vdyB3ZSBvbmx5IHN1cHBvcnQgZ3JhZGVyZXBvcnRfdXNlcl9nZXRfZ3JhZGVzX3RhYmxlLiBJdCByZXR1cm5zIHRoZSBjb21wbGV0ZSBncmFkZXMgdGFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ncmFkZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUdyYWRlcyNnZXRHcmFkZXNUYWJsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBJRCBvZiB0aGUgY291cnNlIHRvIGdldCB0aGUgZ3JhZGVzIGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJpZCAgIElEIG9mIHRoZSB1c2VyIHRvIGdldCB0aGUgZ3JhZGVzIGZyb20uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZWZyZXNoIFRydWUgd2hlbiB3ZSBzaG91bGQgbm90IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZ3JhZGVzIHRhYmxlIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEdyYWRlc1RhYmxlID0gZnVuY3Rpb24oY291cnNlaWQsIHVzZXJpZCwgcmVmcmVzaCkge1xuXG4gICAgICAgICRsb2cuZGVidWcoJ0dldCBncmFkZXMgZm9yIGNvdXJzZSAnICsgY291cnNlaWQgKyAnIGFuZCB1c2VyICcgKyB1c2VyaWQpO1xuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkIDogY291cnNlaWQsXG4gICAgICAgICAgICAgICAgdXNlcmlkICAgOiB1c2VyaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVzZXRzID0ge307XG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICBwcmVzZXRzLmdldEZyb21DYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnZ3JhZGVyZXBvcnRfdXNlcl9nZXRfZ3JhZGVzX3RhYmxlJywgZGF0YSwgcHJlc2V0cykudGhlbihmdW5jdGlvbih0YWJsZSkge1xuICAgICAgICAgICAgdGFibGUgPSBmb3JtYXRHcmFkZXNUYWJsZSh0YWJsZSwgISRpb25pY1BsYXRmb3JtLmlzVGFibGV0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZUdyYWRlc1RhYmxlKHRhYmxlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5ncmFkZXMnKVxuXG4vKipcbiAqIEdyYWRlcyBoYW5kbGVycyBmYWN0b3J5LlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLmdyYWRlc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFHcmFkZXNIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYUdyYWRlc0hhbmRsZXJzJywgZnVuY3Rpb24oJG1tYUdyYWRlcywgJHN0YXRlLCAkbW1VdGlsLCAkbW1Db250ZW50TGlua3NIZWxwZXIsIG1tQ291cnNlc0FjY2Vzc01ldGhvZHMpIHtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgbmF2IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ncmFkZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYUdyYWRlc0hhbmRsZXJzI2NvdXJzZXNOYXZcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZXNOYXYgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hR3JhZGVzLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIHRoaXMgY291cnNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgICBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2Nlc3NEYXRhIFR5cGUgb2YgYWNjZXNzIHRvIHRoZSBjb3Vyc2U6IGRlZmF1bHQsIGd1ZXN0LCAuLi5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWRGb3JDb3Vyc2UgPSBmdW5jdGlvbihjb3Vyc2VJZCwgYWNjZXNzRGF0YSkge1xuICAgICAgICAgICAgaWYgKGFjY2Vzc0RhdGEgJiYgYWNjZXNzRGF0YS50eXBlID09IG1tQ291cnNlc0FjY2Vzc01ldGhvZHMuZ3Vlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vdCBlbmFibGVkIGZvciBndWVzdHMuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJG1tYUdyYWRlcy5pc1BsdWdpbkVuYWJsZWRGb3JDb3Vyc2UoY291cnNlSWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBDb250cm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ291cnNlcyBuYXYgaGFuZGxlciBjb250cm9sbGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmdyYWRlc1xuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFHcmFkZXNIYW5kbGVycyNjb3Vyc2VzTmF2OmNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAnaW9uLXN0YXRzLWJhcnMnO1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEuZ3JhZGVzLmdyYWRlcyc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKCRldmVudCwgY291cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5ncmFkZXMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3Vyc2U6IGNvdXJzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmlldyBncmFkZXMgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLmdyYWRlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hR3JhZGVzSGFuZGxlcnMjdmlld0dyYWRlc1xuICAgICAqL1xuICAgIHNlbGYudmlld0dyYWRlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFHcmFkZXMuaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgdGhpcyB1c2VyIGluIHRoaXMgY29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXIgICAgIFVzZXIgdG8gY2hlY2suXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZEZvclVzZXIgPSBmdW5jdGlvbih1c2VyLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFHcmFkZXMuaXNQbHVnaW5FbmFibGVkRm9yQ291cnNlKGNvdXJzZUlkKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkIGZvciB0aGlzIHVzZXIgaW4gdGhpcyBjb250ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlciAgICAgVXNlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIENvbnRyb2xsZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbih1c2VyLCBjb3Vyc2VJZCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZpZXcgZ3JhZGVzIGhhbmRsZXIgY29udHJvbGxlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ncmFkZXNcbiAgICAgICAgICAgICAqIEBuZ2RvYyBjb250cm9sbGVyXG4gICAgICAgICAgICAgKiBAbmFtZSAkbW1hR3JhZGVzSGFuZGxlcnMjdmlld0dyYWRlczpjb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLmdyYWRlcy52aWV3Z3JhZGVzJztcblxuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLmdyYWRlcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJpZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdXJzZToge2lkOiBjb3Vyc2VJZH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMuZ3JhZGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFHcmFkZXNIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlIGFuZCBjb3Vyc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRW5hYmxlZChzaXRlSWQsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYUdyYWRlcy5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYUdyYWRlcy5pc1BsdWdpbkVuYWJsZWRGb3JDb3Vyc2UoY291cnNlSWQsIHNpdGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhIGdyYWRlIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignL2dyYWRlL3JlcG9ydC91c2VyL2luZGV4LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gJG1tVXRpbC5leHRyYWN0VXJsUGFyYW1zKHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuaWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdXJzZUlkID0gcGFyc2VJbnQocGFyYW1zLmlkLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgZmFsc2UgYmVjYXVzZSBhbGwgc2l0ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2l0ZXVybC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci5maWx0ZXJTdXBwb3J0ZWRTaXRlcyhzaXRlSWRzLCBpc0VuYWJsZWQsIGZhbHNlLCBjb3Vyc2VJZCkudGhlbihmdW5jdGlvbihpZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtbS5jb3JlLnZpZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWV5ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVzOiBpZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291cnNlOiB7aWQ6IGNvdXJzZUlkfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyaWQ6IHBhcnNlSW50KHBhcmFtcy51c2VyaWQsIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUNvbnRlbnRMaW5rc0hlbHBlci5nb0luU2l0ZSgnc2l0ZS5ncmFkZXMnLCBzdGF0ZVBhcmFtcywgc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tZXNzYWdlcycpXG5cbi8qKlxuICogQ29udGFjdHMgY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1lc3NhZ2VzQ29udGFjdHNDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNZXNzYWdlc0NvbnRhY3RzQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJG1tYU1lc3NhZ2VzLCAkbW1TaXRlLCAkbW1VdGlsLCAkbW1BcHAsIG1tVXNlclByb2ZpbGVTdGF0ZSkge1xuXG4gICAgdmFyIGN1cnJlbnRVc2VySWQgPSAkbW1TaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgJHNjb3BlLmxvYWRlZCA9IGZhbHNlO1xuICAgICRzY29wZS5jb250YWN0VHlwZXMgPSBbJ29ubGluZScsICdvZmZsaW5lJywgJ2Jsb2NrZWQnLCAnc3RyYW5nZXJzJywgJ3NlYXJjaCddO1xuICAgICRzY29wZS5zZWFyY2hUeXBlID0gJ3NlYXJjaCc7XG4gICAgJHNjb3BlLmhhc0NvbnRhY3RzID0gZmFsc2U7XG4gICAgJHNjb3BlLmNhblNlYXJjaCA9ICRtbWFNZXNzYWdlcy5pc1NlYXJjaEVuYWJsZWQ7XG4gICAgJHNjb3BlLmZvcm1EYXRhID0ge1xuICAgICAgICBzZWFyY2hTdHJpbmc6ICcnXG4gICAgfTtcbiAgICAkc2NvcGUudXNlclN0YXRlTmFtZSA9IG1tVXNlclByb2ZpbGVTdGF0ZTtcblxuICAgICRzY29wZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNZXNzYWdlcy5pbnZhbGlkYXRlQWxsQ29udGFjdHNDYWNoZShjdXJyZW50VXNlcklkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoQ29udGFjdHModHJ1ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZm9ybURhdGEuc2VhcmNoU3RyaW5nID0gJyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUuc2VhcmNoID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgaWYgKHF1ZXJ5Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2aWV3IHNob3VsZCBoYW5kbGUgdGhpcyBjYXNlLCBidXQgYWRkaW5nIHRoaXMgY2hlY2sgaGVyZSB0byBkb2N1bWVudCB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB1c2VycyB0byBxdWVyeSBvbiBsZXNzIHRoYW4gMyBjaGFyYWN0ZXJzIGFzIHRoZXkgY291bGQgcmV0cmlldmVcbiAgICAgICAgICAgIC8vIHRvbyBtYW55IHVzZXJzIVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJG1tQXBwLmNsb3NlS2V5Ym9hcmQoKTtcblxuICAgICAgICAkc2NvcGUubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMuc2VhcmNoQ29udGFjdHMocXVlcnkpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAkc2NvcGUuaGFzQ29udGFjdHMgPSByZXN1bHQubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICRzY29wZS5jb250YWN0cyA9IHtcbiAgICAgICAgICAgICAgICBzZWFyY2g6IHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tZXNzYWdlcy5lcnJvcndoaWxlcmV0cmlldmluZ2NvbnRhY3RzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5jbGVhclNlYXJjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGZldGNoQ29udGFjdHMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmZXRjaENvbnRhY3RzKCkge1xuICAgICAgICByZXR1cm4gJG1tYU1lc3NhZ2VzLmdldEFsbENvbnRhY3RzKCkudGhlbihmdW5jdGlvbihjb250YWN0cykge1xuICAgICAgICAgICAgJHNjb3BlLmNvbnRhY3RzID0gY29udGFjdHM7XG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250YWN0cywgZnVuY3Rpb24oY29udGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250YWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmhhc0NvbnRhY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tZXNzYWdlcy5lcnJvcndoaWxlcmV0cmlldmluZ2NvbnRhY3RzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaENvbnRhY3RzKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG59KTtcblxuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubWVzc2FnZXMnKVxuXG4vKipcbiAqIERpc2N1c3Npb24gY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1lc3NhZ2VzRGlzY3Vzc2lvbkN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1lc3NhZ2VzRGlzY3Vzc2lvbkN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tQXBwLCAkbW1hTWVzc2FnZXMsICRtbVNpdGUsICR0aW1lb3V0LCAkbW1FdmVudHMsICR3aW5kb3csXG4gICAgICAgICRpb25pY1Njcm9sbERlbGVnYXRlLCBtbVVzZXJQcm9maWxlU3RhdGUsICRtbVV0aWwsIG1tYU1lc3NhZ2VzUG9sbEludGVydmFsLCAkaW50ZXJ2YWwsICRsb2csICRpb25pY0hpc3RvcnksICRpb25pY1BsYXRmb3JtLFxuICAgICAgICBtbUNvcmVFdmVudEtleWJvYXJkU2hvdywgbW1Db3JlRXZlbnRLZXlib2FyZEhpZGUsIG1tYU1lc3NhZ2VzRGlzY3Vzc2lvbkxvYWRlZEV2ZW50LCBtbWFNZXNzYWdlc0Rpc2N1c3Npb25MZWZ0RXZlbnQsXG4gICAgICAgICRtbVVzZXIpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbWFNZXNzYWdlc0Rpc2N1c3Npb25DdHJsJyk7XG5cbiAgICB2YXIgdXNlcklkID0gJHN0YXRlUGFyYW1zLnVzZXJJZCxcbiAgICAgICAgdXNlckZ1bGxuYW1lID0gJHN0YXRlUGFyYW1zLnVzZXJGdWxsbmFtZSxcbiAgICAgICAgbWVzc2FnZXNCZWluZ1NlbnQgPSAwLFxuICAgICAgICBwb2xsaW5nLFxuICAgICAgICBiYWNrVmlldyA9ICRpb25pY0hpc3RvcnkuYmFja1ZpZXcoKSxcbiAgICAgICAgbGFzdE1lc3NhZ2UsXG4gICAgICAgIHNjcm9sbFZpZXcgPSAkaW9uaWNTY3JvbGxEZWxlZ2F0ZS4kZ2V0QnlIYW5kbGUoJ21tYU1lc3NhZ2VzU2Nyb2xsJyk7XG5cbiAgICAkc2NvcGUubG9hZGVkID0gZmFsc2U7XG4gICAgJHNjb3BlLm1lc3NhZ2VzID0gW107XG4gICAgJHNjb3BlLnVzZXJJZCA9IHVzZXJJZDtcbiAgICAkc2NvcGUuY3VycmVudFVzZXJJZCA9ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG4gICAgJHNjb3BlLnByb2ZpbGVMaW5rID0gdHJ1ZTtcblxuICAgIGlmICh1c2VyRnVsbG5hbWUpIHtcbiAgICAgICAgJHNjb3BlLnRpdGxlID0gdXNlckZ1bGxuYW1lO1xuICAgIH0gZWxzZSBpZiAodXNlcklkKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgdGhlIGZ1bGxuYW1lLCB0cnkgdG8gZ2V0IGl0LlxuICAgICAgICAkbW1Vc2VyLmdldFByb2ZpbGUodXNlcklkKS50aGVuKGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgICAgIGlmICghJHNjb3BlLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gdXNlci5mdWxsbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGlzYWJsZSB0aGUgcHJvZmlsZSBidXR0b24gaWYgd2UncmUgY29taW5nIGZyb20gYSBwcm9maWxlLiBJdCBpcyBzYWZlciB0byBwcmV2ZW50IGZvcmJpZCB0aGUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGZ1bGwgcHJvZmlsZSAod2UgZG8gbm90IGtub3cgdGhlIGNvdXJzZSBJRCB0aGV5IGNhbWUgZnJvbSkgYXMgc29tZSB1c2VycyBjYW5ub3QgdmlldyB0aGUgZnVsbFxuICAgIC8vIHByb2ZpbGUgb2Ygb3RoZXIgdXNlcnMuXG4gICAgaWYgKGJhY2tWaWV3ICYmIGJhY2tWaWV3LnN0YXRlTmFtZSA9PT0gbW1Vc2VyUHJvZmlsZVN0YXRlKSB7XG4gICAgICAgICRzY29wZS5wcm9maWxlTGluayA9IGZhbHNlO1xuICAgIH1cblxuICAgICRzY29wZS5pc0FwcE9mZmxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEkbW1BcHAuaXNPbmxpbmUoKTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLnNob3dEYXRlID0gZnVuY3Rpb24obWVzc2FnZSwgcHJldk1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFwcmV2TWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBkYXkgaGFzIGNoYW5nZWQuXG4gICAgICAgIHJldHVybiAhbW9tZW50KG1lc3NhZ2UudGltZWNyZWF0ZWQgKiAxMDAwKS5pc1NhbWUocHJldk1lc3NhZ2UudGltZWNyZWF0ZWQgKiAxMDAwLCAnZGF5Jyk7XG4gICAgfTtcblxuICAgICRzY29wZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgIC8vIFNpbGVudCBlcnJvciwgdGhlIHZpZXcgc2hvdWxkIHByZXZlbnQgdGhpcy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICghdGV4dC50cmltKCkpIHtcbiAgICAgICAgICAgIC8vIFNpbGVudCBlcnJvci5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyg/OlxcclxcbnxcXHJ8XFxuKS9nLCAnPGJyIC8+Jyk7XG4gICAgICAgIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBzZW5kaW5nOiB0cnVlLFxuICAgICAgICAgICAgdXNlcmlkZnJvbTogJHNjb3BlLmN1cnJlbnRVc2VySWQsXG4gICAgICAgICAgICBzbWFsbG1lc3NhZ2U6IHRleHQsXG4gICAgICAgICAgICB0aW1lY3JlYXRlZDogKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwKVxuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblxuICAgICAgICBtZXNzYWdlc0JlaW5nU2VudCsrO1xuICAgICAgICAkbW1hTWVzc2FnZXMuc2VuZE1lc3NhZ2UodXNlcklkLCB0ZXh0KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBub3RpZnlOZXdNZXNzYWdlKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgY2xvc2UgdGhlIGtleWJvYXJkIGlmIGFuIGVycm9yIGhhcHBlbnMsIHdlIHdhbnQgdGhlIHVzZXIgdG8gYmUgYWJsZSB0byBzZW5kIG11bHRpcGxlXG4gICAgICAgICAgICAvLyBtZXNzYWdlcyB3aXRob3V0dGhlIGtleWJvYXJkIGJlaW5nIGNsb3NlZC5cbiAgICAgICAgICAgICRtbUFwcC5jbG9zZUtleWJvYXJkKCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tZXNzYWdlcy5tZXNzYWdlbm90c2VudCcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLm1lc3NhZ2VzLnNwbGljZSgkc2NvcGUubWVzc2FnZXMuaW5kZXhPZihtZXNzYWdlKSwgMSk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtZXNzYWdlc0JlaW5nU2VudC0tO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRmV0Y2ggdGhlIG1lc3NhZ2VzIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAkbW1hTWVzc2FnZXMuZ2V0RGlzY3Vzc2lvbih1c2VySWQpLnRoZW4oZnVuY3Rpb24obWVzc2FnZXMpIHtcbiAgICAgICAgJHNjb3BlLm1lc3NhZ2VzID0gJG1tYU1lc3NhZ2VzLnNvcnRNZXNzYWdlcyhtZXNzYWdlcyk7XG4gICAgICAgIGlmICghdXNlckZ1bGxuYW1lICYmIG1lc3NhZ2VzICYmIG1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgZGlkIG5vdCByZWNlaXZlIHRoZSBmdWxsbmFtZSB2aWEgYXJndW1lbnQuIEFsc28gaXQgaXMgcG9zc2libGUgdGhhdFxuICAgICAgICAgICAgLy8gd2UgY2Fubm90IHJlc29sdmUgdGhlIG5hbWUgd2hlbiBubyBtZXNzYWdlcyB3ZXJlIHlldCBleGNoYW5nZWQuXG4gICAgICAgICAgICBpZiAobWVzc2FnZXNbMF0udXNlcmlkdG8gIT0gJHNjb3BlLmN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtZXNzYWdlc1swXS51c2VydG9mdWxsbmFtZSB8fCAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbWVzc2FnZXNbMF0udXNlcmZyb21mdWxsbmFtZSB8fCAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub3RpZnlOZXdNZXNzYWdlKCk7XG4gICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1lc3NhZ2VzLmVycm9yd2hpbGVyZXRyaWV2aW5nbWVzc2FnZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLnNjcm9sbEFmdGVyUmVuZGVyID0gZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgaWYgKHNjb3BlLiRsYXN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBOZWVkIGEgdGltZW91dCB0byBsZWF2ZSB0aW1lIHRvIHRoZSB2aWV3IHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmlldy5zY3JvbGxCb3R0b20oKTtcbiAgICAgICAgICAgICAgICBzZXRTY3JvbGxXaXRoS2V5Ym9hcmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNldCBhIHBvbGxpbmcgdG8gZ2V0IG5ldyBtZXNzYWdlcyBldmVyeSBjZXJ0YWluIHRpbWUuXG4gICAgZnVuY3Rpb24gc2V0UG9sbGluZygpIHtcbiAgICAgICAgaWYgKHBvbGxpbmcpIHtcbiAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSB0aGUgcG9sbGluZyBpbiBwbGFjZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHBvbGxpbmcuXG4gICAgICAgIHBvbGxpbmcgPSAkaW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdQb2xsaW5nIG5ldyBtZXNzYWdlcyBmb3IgZGlzY3Vzc2lvbiB3aXRoIHVzZXIgJyArIHVzZXJJZCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZXNCZWluZ1NlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHBvbGwgd2hpbGUgYSBtZXNzYWdlIGlzIGJlaW5nIHNlbnQgb3Igd2UgY291bGQgY29uZnVzZSB0aGUgdXNlclxuICAgICAgICAgICAgICAgIC8vIGFzIGhpcyBtZXNzYWdlIHdvdWxkIGRpc2FwcGVhciBmcm9tIHRoZSBsaXN0LCBhbmQgaGUnZCBoYXZlIHRvIHdhaXQgZm9yIHRoZVxuICAgICAgICAgICAgICAgIC8vIGludGVydmFsIHRvIGNoZWNrIGZvciBuZXcgbWVzc2FnZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPYnZpb3VzbHkgd2UgY2Fubm90IGNoZWNrIGZvciBuZXcgbWVzc2FnZXMgd2hlbiB0aGUgYXBwIGlzIG9mZmxpbmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHRoZSBjYWNoZSBiZWZvcmUgZmV0Y2hpbmcuXG4gICAgICAgICAgICAkbW1hTWVzc2FnZXMuaW52YWxpZGF0ZURpc2N1c3Npb25DYWNoZSh1c2VySWQpO1xuICAgICAgICAgICAgJG1tYU1lc3NhZ2VzLmdldERpc2N1c3Npb24odXNlcklkKS50aGVuKGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzQmVpbmdTZW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcG9sbGluZyBpZiBkdWUgdG8gYSByYWNlIGNvbmRpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkc2NvcGUubWVzc2FnZXMgPSAkbW1hTWVzc2FnZXMuc29ydE1lc3NhZ2VzKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBub3RpZnlOZXdNZXNzYWdlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbW1hTWVzc2FnZXNQb2xsSW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIC8vIFVuc2V0IHBvbGxpbmcuXG4gICAgZnVuY3Rpb24gdW5zZXRQb2xsaW5nKCkge1xuICAgICAgICBpZiAocG9sbGluZykge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ2FuY2VsbGluZyBwb2xsaW5nIGZvciBjb252ZXJzYXRpb24gd2l0aCB1c2VyICcgKyB1c2VySWQpO1xuICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbChwb2xsaW5nKTtcbiAgICAgICAgICAgIHBvbGxpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSkge1xuICAgICAgICAvLyBMaXN0ZW4gZm9yIGV2ZW50cyB0byBzZXQvdW5zZXQgdGhlIHBvbGxpbmcgaW4gdGFibGV0LiBXZSB1c2UgYW5ndWxhciBldmVudHMgYmVjYXVzZSB3ZSBjYW5ub3QgdXNlIGlvbmljIGV2ZW50c1xuICAgICAgICAvLyAod2UgdXNlIHVpLXZpZXcpLiBUaGUgYmVoYXZpb3IgaXMgdGhlIHNhbWUsIHNpbmNlIHNjb3BlIGlzIGRlc3Ryb3llZCBvbiB0YWJsZXQgdmlldyB3aGVuIG5hdmlnYXRpbmcgdG8gc3Vidmlld3MuXG4gICAgICAgICRzY29wZS4kb24oJyR2aWV3Q29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZXRQb2xsaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB1bnNldFBvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTGlzdGVuIGZvciBldmVudHMgdG8gc2V0L3Vuc2V0IHRoZSBwb2xsaW5nIGluIHBob25lcy4gV2UgY2FuIHVzZSBpb25pYyBldmVudHMuXG4gICAgICAgICRzY29wZS4kb24oJyRpb25pY1ZpZXcuZW50ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldFBvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kb24oJyRpb25pY1ZpZXcubGVhdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB1bnNldFBvbGxpbmcoKTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvLyBOb3RpZnkgdGhlIGxhc3QgbWVzc2FnZSBmb3VuZCBzbyBkaXNjdXNzaW9ucyBsaXN0IGNvbnRyb2xsZXIgY2FuIHRlbGwgaWYgbGFzdCBtZXNzYWdlIHNob3VsZCBiZSB1cGRhdGVkLlxuICAgIGZ1bmN0aW9uIG5vdGlmeU5ld01lc3NhZ2UoKSB7XG4gICAgICAgIHZhciBsYXN0ID0gJHNjb3BlLm1lc3NhZ2VzWyRzY29wZS5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5zbWFsbG1lc3NhZ2UgIT09IGxhc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICBsYXN0TWVzc2FnZSA9IGxhc3Quc21hbGxtZXNzYWdlO1xuICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIoJG1tYU1lc3NhZ2VzLmdldERpc2N1c3Npb25FdmVudE5hbWUodXNlcklkKSwge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxhc3RNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHRpbWVjcmVhdGVkOiBsYXN0LnRpbWVjcmVhdGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNjcm9sbCB3aGVuIGtleWJvYXJkIGlzIGhpZGUvc2hvd24gdG8ga2VlcCB0aGUgdXNlciBzY3JvbGwuIFRoaXMgaXMgb25seSBuZWVkZWQgZm9yIEFuZHJvaWQuXG4gICAgZnVuY3Rpb24gc2V0U2Nyb2xsV2l0aEtleWJvYXJkKCkge1xuICAgICAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkgeyAvLyBVc2UgYSAkdGltZW91dCB0byB3YWl0IGZvciBzY3JvbGwgdG8gY29ycmVjdGx5IG1lYXN1cmUgaGVpZ2h0LlxuICAgICAgICAgICAgICAgIHZhciBvYnNTaG93LFxuICAgICAgICAgICAgICAgICAgICBvYnNIaWRlLFxuICAgICAgICAgICAgICAgICAgICBrZXlib2FyZEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5pdGlhbFNjcm9sbCA9IHNjcm9sbFZpZXcuZ2V0U2Nyb2xsVmlldygpLl9fY29udGVudEhlaWdodCAtIHNjcm9sbFZpZXcuZ2V0U2Nyb2xsVmlldygpLl9fY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsSGVpZ2h0ID0gJHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgICAgICAgICAgIG9ic1Nob3cgPSAkbW1FdmVudHMub24obW1Db3JlRXZlbnRLZXlib2FyZFNob3csIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gY2FsY3VsYXRlIGtleWJvYXJkIGhlaWdodCBvdXJzZWx2ZXMgc2luY2UgZS5rZXlib2FyZEhlaWdodCBpcyBub3QgcmVsaWFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0RGlmZmVyZW5jZSA9IGluaXRpYWxIZWlnaHQgLSAkd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0tleWJvYXJkSGVpZ2h0ID0gaGVpZ2h0RGlmZmVyZW5jZSA+IDUwID8gaGVpZ2h0RGlmZmVyZW5jZSA6IGUua2V5Ym9hcmRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3S2V5Ym9hcmRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlib2FyZEhlaWdodCA9IG5ld0tleWJvYXJkSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsQnkoMCwgbmV3S2V5Ym9hcmRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG9ic0hpZGUgPSAkbW1FdmVudHMub24obW1Db3JlRXZlbnRLZXlib2FyZEhpZGUsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxWaWV3IHx8wqAhc2Nyb2xsVmlldy5nZXRTY3JvbGxQb3NpdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIENhbid0IGdldCBzY3JvbGwgcG9zaXRpb24sIHN0b3AuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVmlldy5nZXRTY3JvbGxQb3NpdGlvbigpLnRvcCA+PSBtYXhJbml0aWFsU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxCeSgwLDApIHdvdWxkIGF1dG9tYXRpY2FsbHkgcmVzZXQgYXQgbWF4SW5pdGlhbFNjcm9sbC4gV2UgbmVlZCB0byBhcHBseSB0aGUgZGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGVyZSB0byBzY3JvbGwgdG8gdGhlIHJpZ2h0IHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVmlldy5zY3JvbGxCeSgwLCBzY3JvbGxWaWV3LmdldFNjcm9sbFBvc2l0aW9uKCkudG9wIC0ga2V5Ym9hcmRIZWlnaHQgLSBtYXhJbml0aWFsU2Nyb2xsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsQnkoMCwgLSBrZXlib2FyZEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic1Nob3cgJiYgb2JzU2hvdy5vZmYgJiYgb2JzU2hvdy5vZmYoKTtcbiAgICAgICAgICAgICAgICAgICAgb2JzSGlkZSAmJiBvYnNIaWRlLm9mZiAmJiBvYnNIaWRlLm9mZigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSkge1xuICAgICAgICAkbW1FdmVudHMudHJpZ2dlcihtbWFNZXNzYWdlc0Rpc2N1c3Npb25Mb2FkZWRFdmVudCwgdXNlcklkKTtcbiAgICB9XG4gICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCRpb25pY1BsYXRmb3JtLmlzVGFibGV0KCkpIHtcbiAgICAgICAgICAgICRtbUV2ZW50cy50cmlnZ2VyKG1tYU1lc3NhZ2VzRGlzY3Vzc2lvbkxlZnRFdmVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxufSk7XG5cbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1lc3NhZ2VzJylcblxuLyoqXG4gKiBEaXNjdXNzaW9ucyBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTWVzc2FnZXNEaXNjdXNzaW9uc0N0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1lc3NhZ2VzRGlzY3Vzc2lvbnNDdHJsJywgZnVuY3Rpb24oJHEsICRzdGF0ZSwgJHNjb3BlLCAkbW1VdGlsLCAkbW1hTWVzc2FnZXMsICRyb290U2NvcGUsICRtbUV2ZW50cyxcbiAgICAgICAgICAgIG1tQ29yZVNwbGl0Vmlld0xvYWQpIHtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gW107XG5cbiAgICAkc2NvcGUubG9hZGVkID0gZmFsc2U7XG5cbiAgICAvLyBTZXQgb2JzZXJ2ZXJzIHRvIHdhdGNoIGZvciBuZXcgbWVzc2FnZXMgb24gZGlzY3Vzc2lvbnMuIElmIGEgdXNlciBzZWVzIGEgbmV3IG1lc3NhZ2UgaW4gYSBkaXNjdXNzaW9uLCB3ZSdsbCB1cGRhdGVcbiAgICAvLyB0aGUgZGlzY3Vzc2lvbidzIGxhc3QgbWVzc2FnZSBpbiBkaXNjdXNzaW9ucyBsaXN0LlxuICAgIGZ1bmN0aW9uIHNldE9ic2VydmVycyhkaXNjdXNzaW9ucykge1xuICAgICAgICBjbGVhck9ic2VydmVycygpO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkaXNjdXNzaW9ucywgZnVuY3Rpb24oZGlzY3Vzc2lvbikge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2goJG1tRXZlbnRzLm9uKCRtbWFNZXNzYWdlcy5nZXREaXNjdXNzaW9uRXZlbnROYW1lKGRpc2N1c3Npb24ubWVzc2FnZS51c2VyKSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEudGltZWNyZWF0ZWQgPiBkaXNjdXNzaW9uLm1lc3NhZ2UudGltZWNyZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzY3Vzc2lvbi5tZXNzYWdlLm1lc3NhZ2UgPSBkYXRhLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGRpc2N1c3Npb24ubWVzc2FnZS50aW1lY3JlYXRlZCA9IGRhdGEudGltZWNyZWF0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBvYnNlcnZlcnMuXG4gICAgZnVuY3Rpb24gY2xlYXJPYnNlcnZlcnMoKSB7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChvYnNlcnZlcnMsIGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXIgJiYgb2JzZXJ2ZXIub2ZmKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZldGNoRGlzY3Vzc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMuZ2V0RGlzY3Vzc2lvbnMoKS50aGVuKGZ1bmN0aW9uKGRpc2N1c3Npb25zKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIGFuIGFycmF5IGZvciBzb3J0aW5nLlxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZGlzY3Vzc2lvbnMsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuZGlzY3Vzc2lvbnMgPSBhcnJheTtcbiAgICAgICAgICAgIHNldE9ic2VydmVycyhhcnJheSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubWVzc2FnZXMuZXJyb3J3aGlsZXJldHJpZXZpbmdkaXNjdXNzaW9ucycsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkc2NvcGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTWVzc2FnZXMuaW52YWxpZGF0ZURpc2N1c3Npb25zQ2FjaGUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoRGlzY3Vzc2lvbnMoKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmZXRjaERpc2N1c3Npb25zKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIC8vIFRlbGwgbW0tc3BsaXQtdmlldyB0aGF0IGl0IGNhbiBsb2FkIHRoZSBmaXJzdCBsaW5rIG5vdyBpbiB0YWJsZXRzLiBXZSBuZWVkIHRvIGRvIGl0XG4gICAgICAgIC8vIGxpa2UgdGhpcyBiZWNhdXNlIHRoZSBkaXJlY3RpdmUgZG9lc24ndCBoYXZlIGFjY2VzcyB0byAkc2NvcGUubG9hZGVkIHZhcmlhYmxlIChiZWNhdXNlIG9mIHRhYnMpLlxuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QobW1Db3JlU3BsaXRWaWV3TG9hZCk7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhck9ic2VydmVycygpO1xuICAgIH0pO1xufSk7XG5cbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1lc3NhZ2VzJylcblxuLyoqXG4gKiBNZXNzYWdlcyBpbmRleCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTWVzc2FnZXNJbmRleEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1lc3NhZ2VzSW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkbW1FdmVudHMsICRpb25pY1BsYXRmb3JtLCAkaW9uaWNUYWJzRGVsZWdhdGUsXG4gICAgICAgICAgICBtbWFNZXNzYWdlc0Rpc2N1c3Npb25Mb2FkZWRFdmVudCwgbW1hTWVzc2FnZXNEaXNjdXNzaW9uTGVmdEV2ZW50KSB7XG4gICAgLy8gTGlzdGVuIGZvciBkaXNjdXNzaW9uIGxvYWRlZCBldmVudCB0byBzaG93IHVzZXIgcHJvZmlsZSBsaW5rIGluIHRhYmxldCB2aWV3LlxuICAgIHZhciBvYnNMb2FkZWQgPSAkbW1FdmVudHMub24obW1hTWVzc2FnZXNEaXNjdXNzaW9uTG9hZGVkRXZlbnQsIGZ1bmN0aW9uKHVzZXJJZCkge1xuICAgICAgICAkc2NvcGUucHJvZmlsZUxpbmsgPSAkaW9uaWNQbGF0Zm9ybS5pc1RhYmxldCgpICYmICRpb25pY1RhYnNEZWxlZ2F0ZS5zZWxlY3RlZEluZGV4KCkgPT0gMDtcbiAgICAgICAgJHNjb3BlLnVzZXJJZCA9IHVzZXJJZDtcbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiBmb3IgZGlzY3Vzc2lvbiBsb2FkZWQgZXZlbnQgdG8gc2hvdyB1c2VyIHByb2ZpbGUgbGluayBpbiB0YWJsZXQgdmlldy5cbiAgICB2YXIgb2JzTGVmdCA9ICRtbUV2ZW50cy5vbihtbWFNZXNzYWdlc0Rpc2N1c3Npb25MZWZ0RXZlbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUucHJvZmlsZUxpbmsgPSBmYWxzZTtcbiAgICB9KTtcblxuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvYnNMb2FkZWQgJiYgb2JzTG9hZGVkLm9mZikge1xuICAgICAgICAgICAgb2JzTG9hZGVkLm9mZigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNMZWZ0ICYmIG9ic0xlZnQub2ZmKSB7XG4gICAgICAgICAgICBvYnNMZWZ0Lm9mZigpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubWVzc2FnZXMnKVxuXG4vKipcbiAqIEZpbHRlciB0byBmb3JtYXQgYSBtZXNzYWdlLlxuICpcbiAqIEBtb2R1bGUgbW1hLm1lc3NhZ2VzXG4gKiBAbmdkb2MgZmlsdGVyXG4gKiBAbmFtZSBtbWFNZXNzYWdlc0Zvcm1hdFxuICovXG4uZmlsdGVyKCdtbWFNZXNzYWdlc0Zvcm1hdCcsIGZ1bmN0aW9uKCRtbVRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8tezQsfS9pZywgJycpO1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLzxiciBcXC8+PGJyIFxcLz4vaWcsIFwiPGJyIC8+XCIpO1xuICAgIHRleHQgPSAkbW1UZXh0LnJlcGxhY2VOZXdMaW5lcyh0ZXh0LCAnPGJyIC8+Jyk7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1lc3NhZ2VzJylcblxuLyoqXG4gKiBNZXNzYWdlcyBoYW5kbGVycyBmYWN0b3J5LlxuICpcbiAqIFRoaXMgZmFjdG9yeSBob2xkcyB0aGUgZGlmZmVyZW50IGhhbmRsZXJzIHVzZWQgZm9yIGRlbGVnYXRlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNZXNzYWdlc0hhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTWVzc2FnZXNIYW5kbGVycycsIGZ1bmN0aW9uKCRsb2csICRtbWFNZXNzYWdlcywgJG1tU2l0ZSwgJHN0YXRlLCAkbW1VdGlsLCAkbW1Db250ZW50TGlua3NIZWxwZXIpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU1lc3NhZ2VzSGFuZGxlcnMnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29udGFjdCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzSGFuZGxlcnMjYWRkQ29udGFjdFxuICAgICAqL1xuICAgIHNlbGYuYWRkQ29udGFjdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMuaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5pc0VuYWJsZWRGb3JVc2VyID0gZnVuY3Rpb24odXNlciwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VyLmlkICE9ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBjb250YWN0IGhhbmRsZXIgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzSGFuZGxlcnMjYmxvY2tDb250YWN0OmNvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKHVzZXIsIGNvdXJzZWlkKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUsICRyb290U2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRpdGxlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1lc3NhZ2VzLmlzQ29udGFjdCh1c2VyLmlkKS50aGVuKGZ1bmN0aW9uKGlzQ29udGFjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29udGFjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEubWVzc2FnZXMucmVtb3ZlY29udGFjdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEubWVzc2FnZXMuYWRkY29udGFjdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBmYWlscyBmb3Igc29tZSByZWFzb24sIGxldCdzIGp1c3QgaGlkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICcnO1xuICAgICAgICAgICAgICAgICRzY29wZS5zcGlubmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zcGlubmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgJG1tYU1lc3NhZ2VzLmlzQ29udGFjdCh1c2VyLmlkKS50aGVuKGZ1bmN0aW9uKGlzQ29udGFjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29udGFjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMucmVtb3ZlQ29udGFjdCh1c2VyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNZXNzYWdlcy5hZGRDb250YWN0KHVzZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ21tYU1lc3NhZ2VzSGFuZGxlcnM6YWRkVXBkYXRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGl0bGUoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLiRvbignbW1hTWVzc2FnZXNIYW5kbGVyczpibG9ja1VwZGF0ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGl0bGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZVRpdGxlKCk7XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQmxvY2sgY29udGFjdCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzSGFuZGxlcnMjYmxvY2tDb250YWN0XG4gICAgICovXG4gICAgc2VsZi5ibG9ja0NvbnRhY3QgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1lc3NhZ2VzLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuaXNFbmFibGVkRm9yVXNlciA9IGZ1bmN0aW9uKHVzZXIsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlci5pZCAhPSAkbW1TaXRlLmdldFVzZXJJZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKHVzZXIsIGNvdXJzZWlkKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmxvY2sgY29udGFjdCBoYW5kbGVyIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgICAgICAgICAqIEBuZ2RvYyBjb250cm9sbGVyXG4gICAgICAgICAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXNIYW5kbGVycyNibG9ja0NvbnRhY3Q6Y29udHJvbGxlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlLCAkcm9vdFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVUaXRsZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNZXNzYWdlcy5pc0Jsb2NrZWQodXNlci5pZCkudGhlbihmdW5jdGlvbihpc0Jsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLm1lc3NhZ2VzLnVuYmxvY2tjb250YWN0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5tZXNzYWdlcy5ibG9ja2NvbnRhY3QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZmFpbHMgZm9yIHNvbWUgcmVhc29uLCBsZXQncyBqdXN0IGhpZGUgdGhlIGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICRtbWFNZXNzYWdlcy5pc0Jsb2NrZWQodXNlci5pZCkudGhlbihmdW5jdGlvbihpc0Jsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1lc3NhZ2VzLnVuYmxvY2tDb250YWN0KHVzZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1lc3NhZ2VzLmJsb2NrQ29udGFjdCh1c2VyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdtbWFNZXNzYWdlc0hhbmRsZXJzOmJsb2NrVXBkYXRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGl0bGUoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLiRvbignbW1hTWVzc2FnZXNIYW5kbGVyczphZGRVcGRhdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRpdGxlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVUaXRsZSgpO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbmQgbWVzc2FnZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzSGFuZGxlcnMjYmxvY2tDb250YWN0XG4gICAgICovXG4gICAgc2VsZi5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMuaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5pc0VuYWJsZWRGb3JVc2VyID0gZnVuY3Rpb24odXNlciwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VyLmlkICE9ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24odXNlciwgY291cnNlaWQpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZW5kIG1lc3NhZ2UgaGFuZGxlciBjb250cm9sbGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICAgICAgICAgKiBAbmdkb2MgY29udHJvbGxlclxuICAgICAgICAgICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzSGFuZGxlcnMjc2VuZE1lc3NhZ2U6Y29udHJvbGxlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5tZXNzYWdlcy5zZW5kbWVzc2FnZSc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubWVzc2FnZXMtZGlzY3Vzc2lvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJGdWxsbmFtZTogdXNlci5mdWxsbmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaWRlIG1lbnUgbmF2IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXNIYW5kbGVycyNzaWRlTWVudU5hdlxuICAgICAqL1xuICAgIHNlbGYuc2lkZU1lbnVOYXYgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNZXNzYWdlcy5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbnRyb2xsZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTaWRlIG1lbnUgbmF2IGhhbmRsZXIgY29udHJvbGxlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFNZXNzYWdlc0hhbmRsZXJzI3NpZGVNZW51TmF2OmNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJ2lvbi1jaGF0Ym94JztcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLm1lc3NhZ2VzLm1lc3NhZ2VzJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3RhdGUgPSAnc2l0ZS5tZXNzYWdlcyc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXNIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCBTaXRlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkRm9yU2l0ZShzaXRlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTWVzc2FnZXMuaXNQbHVnaW5FbmFibGVkKHNpdGVJZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhIG1lc3NhZ2VzIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignL21lc3NhZ2UvaW5kZXgucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgZmFsc2UgYmVjYXVzZSBhbGwgc2l0ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2l0ZXVybC5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLmZpbHRlclN1cHBvcnRlZFNpdGVzKHNpdGVJZHMsIGlzRW5hYmxlZEZvclNpdGUsIGZhbHNlKS50aGVuKGZ1bmN0aW9uKGlkcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhY3Rpb25zLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9ICRtbVV0aWwuZXh0cmFjdFVybFBhcmFtcyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ21tLmNvcmUudmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1leWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVzOiBpZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUGFyYW1zO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zLnVzZXIxICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXJhbXMudXNlcjIgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHVzZXIgaXMgaW4gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkbW1TaXRlLmdldFVzZXJJZCgpID09IHBhcmFtcy51c2VyMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTmFtZSA9ICdzaXRlLm1lc3NhZ2VzLWRpc2N1c3Npb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUGFyYW1zID0ge3VzZXJJZDogcGFyc2VJbnQocGFyYW1zLnVzZXIyLCAxMCl9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkbW1TaXRlLmdldFVzZXJJZCgpID09IHBhcmFtcy51c2VyMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTmFtZSA9ICdzaXRlLm1lc3NhZ2VzLWRpc2N1c3Npb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUGFyYW1zID0ge3VzZXJJZDogcGFyc2VJbnQocGFyYW1zLnVzZXIxLCAxMCl9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIZSBpc24ndCwgb3BlbiBpbiBicm93c2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwub3BlbkluQnJvd3Nlcih1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLmlkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU5hbWUgPSAnc2l0ZS5tZXNzYWdlcy1kaXNjdXNzaW9uJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUGFyYW1zID0ge3VzZXJJZDogcGFyc2VJbnQocGFyYW1zLmlkLCAxMCl9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvIHRvIG1lc3NhZ2luZyBpbmRleCBwYWdlLiBXZSB1c2UgcmVkaXJlY3Qgc3RhdGUgdG8gdmlldyB0aGUgc2lkZSBtZW51LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdyZWRpcmVjdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXRlaWQ6IHNpdGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3NpdGUubWVzc2FnZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tQ29udGVudExpbmtzSGVscGVyLmdvSW5TaXRlKHN0YXRlTmFtZSwgc3RhdGVQYXJhbXMsIHNpdGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubWVzc2FnZXMnKVxuXG4vKipcbiAqIE1lc3NhZ2VzIGZhY3RvcnkuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTWVzc2FnZXNcbiAqL1xuLmZhY3RvcnkoJyRtbWFNZXNzYWdlcycsIGZ1bmN0aW9uKCRtbVNpdGUsICRtbVNpdGVzTWFuYWdlciwgJGxvZywgJHEsICRtbVVzZXIsIG1tYU1lc3NhZ2VzTmV3TWVzc2FnZUV2ZW50KSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFNZXNzYWdlcycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbnRhY3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjYWRkQ29udGFjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0byBVc2VyIElEIG9mIHRoZSBwZXJzb24gdG8gYWRkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5hZGRDb250YWN0ID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdjb3JlX21lc3NhZ2VfY3JlYXRlX2NvbnRhY3RzJywge1xuICAgICAgICAgICAgdXNlcmlkczogWyB1c2VySWQgXVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW52YWxpZGF0ZUFsbENvbnRhY3RzQ2FjaGUoJG1tU2l0ZS5nZXRVc2VySWQoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBCbG9jayBhIGNvbnRhY3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjYmxvY2tDb250YWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvIFVzZXIgSUQgb2YgdGhlIHBlcnNvbiB0byBibG9jay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuYmxvY2tDb250YWN0ID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdjb3JlX21lc3NhZ2VfYmxvY2tfY29udGFjdHMnLCB7XG4gICAgICAgICAgICB1c2VyaWRzOiBbIHVzZXJJZCBdXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbnZhbGlkYXRlQWxsQ29udGFjdHNDYWNoZSgkbW1TaXRlLmdldFVzZXJJZCgpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIGNvbnRhY3RzIG9mIHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjZ2V0QWxsQ29udGFjdHNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIHRoZSBXUyBkYXRhLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QWxsQ29udGFjdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Q29udGFjdHMoKS50aGVuKGZ1bmN0aW9uKGNvbnRhY3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRCbG9ja2VkQ29udGFjdHMoKS50aGVuKGZ1bmN0aW9uKGJsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICBjb250YWN0cy5ibG9ja2VkID0gYmxvY2tlZC51c2VycztcbiAgICAgICAgICAgICAgICBzdG9yZVVzZXJzRnJvbUFsbENvbnRhY3RzKGNvbnRhY3RzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFjdHM7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgV1MgZm9yIGJsb2NrZWQgY29udGFjdHMgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSB5ZXQsIGJ1dCB3ZSBzdGlsbCB3YW50IHRoZSBjb250YWN0cy5cbiAgICAgICAgICAgICAgICBjb250YWN0cy5ibG9ja2VkID0gW107XG4gICAgICAgICAgICAgICAgc3RvcmVVc2Vyc0Zyb21BbGxDb250YWN0cyhjb250YWN0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3RzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBibG9ja2VkIGNvbnRhY3RzIG9mIHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjZ2V0QmxvY2tlZENvbnRhY3RzXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCB0aGUgV1MgZGF0YS5cbiAgICAgKi9cbiAgICBzZWxmLmdldEJsb2NrZWRDb250YWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJpZDogJG1tU2l0ZS5nZXRVc2VySWQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IHNlbGYuX2dldENhY2hlS2V5Rm9yQmxvY2tlZENvbnRhY3RzKCRtbVNpdGUuZ2V0VXNlcklkKCkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmZXJyZWQ7XG5cbiAgICAgICAgaWYgKCEkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX21lc3NhZ2VfZ2V0X2Jsb2NrZWRfdXNlcnMnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIFdTIGlzIG5vdCBhdmFpbGFibGUsIHdlIG1vY2sgYW4gZW1wdHkgcmVzcG9uc2UuXG4gICAgICAgICAgICBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHt1c2VyczogW10sIHdhcm5pbmdzOiBbXX0pO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdjb3JlX21lc3NhZ2VfZ2V0X2Jsb2NrZWRfdXNlcnMnLCBwYXJhbXMsIHByZXNldHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNhY2hlIGtleSBmb3IgY29udGFjdHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjX2dldENhY2hlS2V5Rm9yQ29udGFjdHNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2dldENhY2hlS2V5Rm9yQ29udGFjdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTm90ZTogdGhlIGNvbnRhY3RzIFdTIGRvZXMgbm90IHRha2UgYXJndW1lbnRzLCBzbyB3ZSBkbyBub3QgbmVlZCBhbnkgaGVyZS5cbiAgICAgICAgcmV0dXJuICdtbWFNZXNzYWdlczpjb250YWN0cyc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2FjaGUga2V5IGZvciBibG9ja2VkIGNvbnRhY3RzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI19nZXRDYWNoZUtleUZvckJsb2NrZWRDb250YWN0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1c2VySWQgVGhlIHVzZXIgd2hvJ3MgY29udGFjdHMgd2UncmUgbG9va2luZyBmb3IuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRDYWNoZUtleUZvckJsb2NrZWRDb250YWN0cyA9IGZ1bmN0aW9uKHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1lc3NhZ2VzOmJsb2NrZWRDb250YWN0czonICsgdXNlcklkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNhY2hlIGtleSBmb3IgYSBkaXNjdXNzaW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI19nZXRDYWNoZUtleUZvckRpc2N1c3Npb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdXNlcklkIFRoZSBvdGhlciBwZXJzb24gd2l0aCB3aG9tIHRoZSBjdXJyZW50IHVzZXIgaXMgaGF2aW5nIHRoZSBkaXNjdXNzaW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0Q2FjaGVLZXlGb3JEaXNjdXNzaW9uID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTWVzc2FnZXM6ZGlzY3Vzc2lvbjonICsgdXNlcklkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNhY2hlIGtleSBmb3IgdGhlIGxpc3Qgb2YgZGlzY3Vzc2lvbnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjX2dldENhY2hlS2V5Rm9yRGlzY3Vzc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2dldENhY2hlS2V5Rm9yRGlzY3Vzc2lvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNZXNzYWdlczpkaXNjdXNzaW9ucyc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2FjaGUga2V5IGZvciB0aGUgbWVzc2FnaW5nIGVuYWJsZWQgY2FsbC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNfZ2V0Q2FjaGVLZXlGb3JFbmFibGVkXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRDYWNoZUtleUZvckVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNZXNzYWdlczplbmFibGVkJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb250YWN0cyBvZiB0aGUgY3VycmVudCB1c2VyLlxuICAgICAqXG4gICAgICogVGhpcyBleGNsdWRlcyB0aGUgYmxvY2tlZCB1c2Vycy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNnZXRDb250YWN0c1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggdGhlIFdTIGRhdGEuXG4gICAgICovXG4gICAgc2VsZi5nZXRDb250YWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJlc2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogc2VsZi5fZ2V0Q2FjaGVLZXlGb3JDb250YWN0cygpXG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdjb3JlX21lc3NhZ2VfZ2V0X2NvbnRhY3RzJywgdW5kZWZpbmVkLCBwcmVzZXRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBldmVudHMgb2YgYSBkaXNjdXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VyaWQgVXNlciBJRCBvZiB0aGUgZGlzY3Vzc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICBOYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBzZWxmLmdldERpc2N1c3Npb25FdmVudE5hbWUgPSBmdW5jdGlvbih1c2VyaWQpIHtcbiAgICAgICAgcmV0dXJuIG1tYU1lc3NhZ2VzTmV3TWVzc2FnZUV2ZW50ICsgJ18nICsgJG1tU2l0ZS5nZXRVc2VySWQoKSArICdfJyArIHVzZXJpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgdXNlcidzIGRpc2N1c3Npb24gd2l0aCBhbm90aGVyIHVzZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjZ2V0RGlzY3Vzc2lvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1c2VySWQgVGhlIElEIG9mIHRoZSBvdGhlciB1c2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5nZXREaXNjdXNzaW9uID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHZhciBtZXNzYWdlcyxcbiAgICAgICAgICAgIHByZXNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IHNlbGYuX2dldENhY2hlS2V5Rm9yRGlzY3Vzc2lvbih1c2VySWQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJpZHRvOiAkbW1TaXRlLmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgICAgIHVzZXJpZGZyb206IHVzZXJJZCxcbiAgICAgICAgICAgICAgICBsaW1pdGZyb206IDAsXG4gICAgICAgICAgICAgICAgbGltaXRudW06IDUwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmLl9nZXRSZWNlbnRNZXNzYWdlcyhwYXJhbXMsIHByZXNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBwYXJhbXMudXNlcmlkdG8gPSB1c2VySWQ7XG4gICAgICAgICAgICBwYXJhbXMudXNlcmlkZnJvbSA9ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRSZWNlbnRNZXNzYWdlcyhwYXJhbXMsIHByZXNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZXMuY29uY2F0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkaXNjdXNzaW9ucyBvZiB0aGUgY3VycmVudCB1c2VyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2dldERpc2N1c3Npb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSB1c2VyIElEIG9mIHRoZSBvdGhlciB1c2VyLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RGlzY3Vzc2lvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpc2N1c3Npb25zID0ge30sXG4gICAgICAgICAgICBwcmVzZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBzZWxmLl9nZXRDYWNoZUtleUZvckRpc2N1c3Npb25zKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICAgIHJldHVybiBzZWxmLl9nZXRSZWNlbnRNZXNzYWdlcyh7XG4gICAgICAgICAgICB1c2VyaWR0bzogJG1tU2l0ZS5nZXRVc2VySWQoKSxcbiAgICAgICAgICAgIHVzZXJpZGZyb206IDAsXG4gICAgICAgICAgICBsaW1pdGZyb206IDAsXG4gICAgICAgICAgICBsaW1pdG51bTogNTBcbiAgICAgICAgfSwgcHJlc2V0cykudGhlbihmdW5jdGlvbihtZXNzYWdlcykge1xuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBkaXNjdXNzaW9ucyBieSBmaWx0ZXJpbmcgc2FtZSBzZW5kZXJzLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1lc3NhZ2VzLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXNjdXNzaW9uc1ttZXNzYWdlLnVzZXJpZGZyb21dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uc1ttZXNzYWdlLnVzZXJpZGZyb21dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVsbG5hbWU6IG1lc3NhZ2UudXNlcmZyb21mdWxsbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVpbWFnZXVybDogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS50aW1lcmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzY3Vzc2lvbnNbbWVzc2FnZS51c2VyaWRmcm9tXS51bnJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgbW9zdCByZWNlbnQgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRpc2N1c3Npb25zW21lc3NhZ2UudXNlcmlkZnJvbV0ubWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2N1c3Npb25zW21lc3NhZ2UudXNlcmlkZnJvbV0ubWVzc2FnZS50aW1lY3JlYXRlZCA8IG1lc3NhZ2UudGltZWNyZWF0ZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uc1ttZXNzYWdlLnVzZXJpZGZyb21dLm1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyOiBtZXNzYWdlLnVzZXJpZGZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLnNtYWxsbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVjcmVhdGVkOiBtZXNzYWdlLnRpbWVjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE5vdyBnZXQgdGhlIGxhc3QgbWVzc2FnZXMgc2VudCBmcm9tIHdoaWNoIHdlIG1pZ2h0IG5vdCBoYXZlIHJlY2VpdmVkIGEgcmVwbHkgeWV0LlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldFJlY2VudE1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICB1c2VyaWRmcm9tOiAkbW1TaXRlLmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgICAgIHVzZXJpZHRvOiAwLFxuICAgICAgICAgICAgICAgIGxpbWl0ZnJvbTogMCxcbiAgICAgICAgICAgICAgICBsaW1pdG51bTogNTBcbiAgICAgICAgICAgIH0sIHByZXNldHMpLnRoZW4oZnVuY3Rpb24obWVzc2FnZXMpIHtcblxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGRpc2N1c3Npb25zIGJ5IGZpbHRlcmluZyBzYW1lIHNlbmRlcnMuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1lc3NhZ2VzLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGlzY3Vzc2lvbnNbbWVzc2FnZS51c2VyaWR0b10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uc1ttZXNzYWdlLnVzZXJpZHRvXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsbmFtZTogbWVzc2FnZS51c2VydG9mdWxsbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlaW1hZ2V1cmw6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS50aW1lcmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2N1c3Npb25zW21lc3NhZ2UudXNlcmlkdG9dLnVucmVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBtb3N0IHJlY2VudCBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRpc2N1c3Npb25zW21lc3NhZ2UudXNlcmlkdG9dLm1lc3NhZ2UgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY3Vzc2lvbnNbbWVzc2FnZS51c2VyaWR0b10ubWVzc2FnZS50aW1lY3JlYXRlZCA8IG1lc3NhZ2UudGltZWNyZWF0ZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzY3Vzc2lvbnNbbWVzc2FnZS51c2VyaWR0b10ubWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyOiBtZXNzYWdlLnVzZXJpZHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2Uuc21hbGxtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVjcmVhdGVkOiBtZXNzYWdlLnRpbWVjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3cgZ2V0IHRoZSBjb250YWN0c1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldENvbnRhY3RzKCkudGhlbihmdW5jdGlvbihjb250YWN0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZXMgPSBbJ29ubGluZScsICdvZmZsaW5lJywgJ3N0cmFuZ2VycyddO1xuXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh0eXBlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3RzW3R5cGVdICYmIGNvbnRhY3RzW3R5cGVdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGFjdHNbdHlwZV0sIGZ1bmN0aW9uKGNvbnRhY3QpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRpc2N1c3Npb25zW2NvbnRhY3QuaWRdID09PSAndW5kZWZpbmVkJyAmJiBjb250YWN0LnVucmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBhIGNvbnRhY3Qgd2l0aCB1bnJlYWQgbWVzc2FnZXMuIENvbnRhY3RzIHdpdGhvdXQgdW5yZWFkIG1lc3NhZ2VzIGFyZSBub3QgdXNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2N1c3Npb25zW2NvbnRhY3QuaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxuYW1lOiBjb250YWN0LmZ1bGxuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVpbWFnZXVybDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IGNvbnRhY3QuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiLi4uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVjcmVhdGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRpc2N1c3Npb25zW2NvbnRhY3QuaWRdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbnRhY3QgaXMgdXNlZCBpbiBhIGRpc2N1c3Npb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC5wcm9maWxlaW1hZ2V1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNjdXNzaW9uc1tjb250YWN0LmlkXS5wcm9maWxlaW1hZ2V1cmwgPSBjb250YWN0LnByb2ZpbGVpbWFnZXVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGFjdC51bnJlYWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY3Vzc2lvbnNbY29udGFjdC5pZF0udW5yZWFkID0gY29udGFjdC51bnJlYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RGlzY3Vzc2lvbnNVc2VySW1nKGRpc2N1c3Npb25zKS50aGVuKGZ1bmN0aW9uKGRpc2N1c3Npb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVVzZXJzRnJvbURpc2N1c3Npb25zKGRpc2N1c3Npb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXNjdXNzaW9ucztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGltYWdlcyBmb3IgYWxsIHRoZSBkaXNjdXNzaW9ucyB0aGF0IGRvbid0IGhhdmUgb25lIGFscmVhZHkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjZ2V0RGlzY3Vzc2lvbnNVc2VySW1nXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGlzY3Vzc2lvbnMgTGlzdCBvZiBkaXNjdXNzaW9ucy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBQcm9taXNlIGFsd2F5cyByZXNvbHZlZC4gUmVzb2x2ZSBwYXJhbSBpcyB0aGUgZm9ybWF0dGVkIGRpc2N1c3Npb25zLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RGlzY3Vzc2lvbnNVc2VySW1nID0gZnVuY3Rpb24oZGlzY3Vzc2lvbnMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRpc2N1c3Npb25zLCBmdW5jdGlvbihkaXNjdXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAoIWRpc2N1c3Npb24ucHJvZmlsZWltYWdldXJsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0aGUgdXNlciBpbWFnZS4gVHJ5IHRvIHJldHJpZXZlIGl0LlxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gJG1tVXNlci5nZXRQcm9maWxlKGRpc2N1c3Npb24ubWVzc2FnZS51c2VyLCAxLCB0cnVlKS50aGVuKGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzY3Vzc2lvbi5wcm9maWxlaW1hZ2V1cmwgPSB1c2VyLnByb2ZpbGVpbWFnZXVybDtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3IgZ2V0dGluZyBwcm9maWxlLCByZXNvbHZlIHByb21pc2Ugd2l0aG91dCBhZGRpbmcgYW55IGV4dHJhIGRhdGEuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzY3Vzc2lvbnM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWVzc2FnZXMgYWNjb3JkaW5nIHRvIHRoZSBwYXJhbXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjX2dldE1lc3NhZ2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIFdTLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzZXRzIFNldCBvZiBwcmVzZXRzIGZvciB0aGUgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0TWVzc2FnZXMgPSBmdW5jdGlvbihwYXJhbXMsIHByZXNldHMpIHtcbiAgICAgICAgcGFyYW1zID0gYW5ndWxhci5leHRlbmQocGFyYW1zLCB7XG4gICAgICAgICAgICB0eXBlOiAnY29udmVyc2F0aW9ucycsXG4gICAgICAgICAgICBuZXdlc3RmaXJzdDogMSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnY29yZV9tZXNzYWdlX2dldF9tZXNzYWdlcycsIHBhcmFtcywgcHJlc2V0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbW9zdCByZWNlbnQgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjX2dldFJlY2VudE1lc3NhZ2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIFdTLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzZXRzIFNldCBvZiBwcmVzZXRzIGZvciB0aGUgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0UmVjZW50TWVzc2FnZXMgPSBmdW5jdGlvbihwYXJhbXMsIHByZXNldHMpIHtcbiAgICAgICAgcGFyYW1zID0gYW5ndWxhci5leHRlbmQocGFyYW1zLCB7XG4gICAgICAgICAgICByZWFkOiAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmLl9nZXRNZXNzYWdlcyhwYXJhbXMsIHByZXNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IHJlc3BvbnNlLm1lc3NhZ2VzO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA+PSBwYXJhbXMubGltaXRudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZmV0Y2ggbW9yZSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAgICBwYXJhbXMubGltaXRudW0gPSBwYXJhbXMubGltaXRudW0gLSBtZXNzYWdlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnJlYWQgPSAxO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldE1lc3NhZ2VzKHBhcmFtcywgcHJlc2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzID0gbWVzc2FnZXMuY29uY2F0KHJlc3BvbnNlLm1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGFsbCBjb250YWN0cyBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNpbnZhbGlkYXRlQWxsQ29udGFjdHNDYWNoZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1c2VySWQgVGhlIHVzZXIgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVBbGxDb250YWN0c0NhY2hlID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmludmFsaWRhdGVDb250YWN0c0NhY2hlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmludmFsaWRhdGVCbG9ja2VkQ29udGFjdHNDYWNoZSh1c2VySWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBibG9ja2VkIGNvbnRhY3RzIGNhY2hlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2ludmFsaWRhdGVCbG9ja2VkQ29udGFjdHNDYWNoZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1c2VySWQgVGhlIHVzZXIgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVCbG9ja2VkQ29udGFjdHNDYWNoZSA9IGZ1bmN0aW9uKHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShzZWxmLl9nZXRDYWNoZUtleUZvckJsb2NrZWRDb250YWN0cyh1c2VySWQpKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGNvbnRhY3RzIGNhY2hlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2ludmFsaWRhdGVDb250YWN0c0NhY2hlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDb250YWN0c0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KHNlbGYuX2dldENhY2hlS2V5Rm9yQ29udGFjdHMoKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgZGlzY3Vzc2lvbiBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNpbnZhbGlkYXRlRGlzY3Vzc2lvbkNhY2hlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJJZCBUaGUgdXNlciBJRCB3aXRoIHdob20gdGhlIGN1cnJlbnQgdXNlciBpcyBoYXZpbmcgdGhlIGRpc2N1c3Npb24uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVEaXNjdXNzaW9uQ2FjaGUgPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoc2VsZi5fZ2V0Q2FjaGVLZXlGb3JEaXNjdXNzaW9uKHVzZXJJZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGRpc2N1c3Npb25zIGNhY2hlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHtAbGluayAkbW1hTWVzc2FnZXMjZ2V0RGlzY3Vzc2lvbnN9IHVzZXMgdGhlIGNvbnRhY3RzLCBzbyB3ZSBuZWVkIHRvIGludmFsaWRhdGUgY29udGFjdHMgdG9vLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2ludmFsaWRhdGVEaXNjdXNzaW9uc0NhY2hlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVEaXNjdXNzaW9uc0NhY2hlID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KHNlbGYuX2dldENhY2hlS2V5Rm9yRGlzY3Vzc2lvbnMoKSkudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW52YWxpZGF0ZUNvbnRhY3RzQ2FjaGUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgbWVzc2FnaW5nIGVuYWJsZWQgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjaW52YWxpZGF0ZUVuYWJsZWRDYWNoZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlRW5hYmxlZENhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KHNlbGYuX2dldENhY2hlS2V5Rm9yRW5hYmxlZCgpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBhIHVzZXIgaXMgYmxvY2tlZCBieSB0aGUgY3VycmVudCB1c2VyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2lzQmxvY2tlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1c2VySWQgVGhlIHVzZXIgSUQgdG8gY2hlY2sgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIGJvb2xlYW4sIHJlamVjdGVkIHdoZW4gd2UgZG8gbm90IGtub3cuXG4gICAgICovXG4gICAgc2VsZi5pc0Jsb2NrZWQgPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0QmxvY2tlZENvbnRhY3RzKCkudGhlbihmdW5jdGlvbihibG9ja2VkQ29udGFjdHMpIHtcbiAgICAgICAgICAgIHZhciBibG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWJsb2NrZWRDb250YWN0cy51c2VycyB8fCBibG9ja2VkQ29udGFjdHMudXNlcnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGJsb2NrZWRDb250YWN0cy51c2VycywgZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgICAgIGlmICh1c2VySWQgPT0gdXNlci5pZCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBibG9ja2VkO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBhIHVzZXIgaXMgYSBjb250YWN0IG9mIHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjaXNDb250YWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJJZCBUaGUgdXNlciBJRCB0byBjaGVjayBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggYm9vbGVhbiwgcmVqZWN0ZWQgd2hlbiB3ZSBkbyBub3Qga25vdy5cbiAgICAgKi9cbiAgICBzZWxmLmlzQ29udGFjdCA9IGZ1bmN0aW9uKHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRDb250YWN0cygpLnRoZW4oZnVuY3Rpb24oY29udGFjdHMpIHtcbiAgICAgICAgICAgIHZhciBpc0NvbnRhY3QgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlcyA9IFsnb25saW5lJywgJ29mZmxpbmUnXTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhY3RzW3R5cGVdICYmIGNvbnRhY3RzW3R5cGVdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbnRhY3RzW3R5cGVdLCBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcklkID09IHVzZXIuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbnRhY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzQ29udGFjdDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgbWVzc2FnaW5nIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvdWxkIGNhbGwgYSBXUyBzbyBkbyBub3QgYWJ1c2UgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjX2lzTWVzc2FnaW5nRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gZW5hYmxlZCwgb3RoZXJ3aXNlIHJlamVjdGVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9pc01lc3NhZ2luZ0VuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciBlbmFibGVkID0gc2l0ZS5jYW5Vc2VBZHZhbmNlZEZlYXR1cmUoJ21lc3NhZ2luZycsICd1bmtub3duJyk7XG5cbiAgICAgICAgICAgIGlmIChlbmFibGVkID09PSAndW5rbm93bicpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBvbGRlciB2ZXJzaW9uIHdlIGNhbm5vdCBjaGVjayBvdGhlciB0aGFuIGNhbGxpbmcgYSBXUy4gSWYgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAvLyBmYWlscyB0aGVyZSBpcyBhIHZlcnkgaGlnaCBjaGFuY2UgdGhhdCBtZXNzYWdpbmcgaXMgZGlzYWJsZWQuXG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVXNpbmcgV1MgY2FsbCB0byBjaGVjayBpZiBtZXNzYWdpbmcgaXMgZW5hYmxlZC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l0ZS5yZWFkKCdjb3JlX21lc3NhZ2Vfc2VhcmNoX2NvbnRhY3RzJywge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2h0ZXh0OiAnQ2hlY2tpbmdJZk1lc3NhZ2luZ0lzRW5hYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgIG9ubHlteWNvdXJzZXM6IDBcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGVtZXJnZW5jeUNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IHNlbGYuX2dldENhY2hlS2V5Rm9yRW5hYmxlZCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgbWVzc2FnaW5nIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAqXG4gICAgICogVGhpcyBjb3VsZCBjYWxsIGEgV1Mgc28gZG8gbm90IGFidXNlIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubWVzc2FnZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1lc3NhZ2VzI2lzTWVzc2FnaW5nRW5hYmxlZEZvclNpdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZWlkIFNpdGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBSZXNvbHZlZCB3aGVuIGVuYWJsZWQsIG90aGVyd2lzZSByZWplY3RlZC5cbiAgICAgKi9cbiAgICBzZWxmLmlzTWVzc2FnaW5nRW5hYmxlZEZvclNpdGUgPSBmdW5jdGlvbihzaXRlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICBpZiAoIXNpdGUuY2FuVXNlQWR2YW5jZWRGZWF0dXJlKCdtZXNzYWdpbmcnKSB8fCAhc2l0ZS53c0F2YWlsYWJsZSgnY29yZV9tZXNzYWdlX2dldF9tZXNzYWdlcycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbiBvbGRlciB2ZXJzaW9uIHdlIGNhbm5vdCBjaGVjayBvdGhlciB0aGFuIGNhbGxpbmcgYSBXUy4gSWYgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIC8vIGZhaWxzIHRoZXJlIGlzIGEgdmVyeSBoaWdoIGNoYW5jZSB0aGF0IG1lc3NhZ2luZyBpcyBkaXNhYmxlZC5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1VzaW5nIFdTIGNhbGwgdG8gY2hlY2sgaWYgbWVzc2FnaW5nIGlzIGVuYWJsZWQuJyk7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5yZWFkKCdjb3JlX21lc3NhZ2Vfc2VhcmNoX2NvbnRhY3RzJywge1xuICAgICAgICAgICAgICAgIHNlYXJjaHRleHQ6ICdDaGVja2luZ0lmTWVzc2FnaW5nSXNFbmFibGVkJyxcbiAgICAgICAgICAgICAgICBvbmx5bXljb3Vyc2VzOiAwXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZW1lcmdlbmN5Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBzZWxmLl9nZXRDYWNoZUtleUZvckVuYWJsZWQoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaXMgZW5hYmxlZCBpbiBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgKlxuICAgICAqIERvIG5vdCBhYnVzZSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLCByZWplY3RlZCBvciByZXNvbHZlZCB3aXRoIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgaWYgKCFzaXRlLmNhblVzZUFkdmFuY2VkRmVhdHVyZSgnbWVzc2FnaW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzaXRlLndzQXZhaWxhYmxlKCdjb3JlX21lc3NhZ2VfZ2V0X21lc3NhZ2VzJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9pc01lc3NhZ2luZ0VuYWJsZWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3Qgd2UgY2FuIHNlYXJjaCBjb250YWN0cy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNpc1NlYXJjaEVuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNlbGYuaXNTZWFyY2hFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX21lc3NhZ2Vfc2VhcmNoX2NvbnRhY3RzJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNvbnRhY3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjcmVtb3ZlQ29udGFjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0byBVc2VyIElEIG9mIHRoZSBwZXJzb24gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5yZW1vdmVDb250YWN0ID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdjb3JlX21lc3NhZ2VfZGVsZXRlX2NvbnRhY3RzJywge1xuICAgICAgICAgICAgdXNlcmlkczogWyB1c2VySWQgXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICByZXNwb25zZUV4cGVjdGVkOiBmYWxzZVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW52YWxpZGF0ZUNvbnRhY3RzQ2FjaGUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgY29udGFjdHMuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0IHRoaXMgb25seSByZXR1cm5zIHRoZSBmaXJzdCAxMDAgY29udGFjdHMsIGJ1dCBub3RlIHRoYXQgdGhlIFdTIGNhbiByZXR1cm4gdGhvdXNhbmRzXG4gICAgICogb2YgcmVzdWx0cyB3aGljaCB3b3VsZCB0YWtlIGEgd2hpbGUgdG8gcHJvY2Vzcy4gVGhlIGxpbWl0IGhlcmUgaXMganVzdCBhIGNvbnZlbmllbmNlIHRvXG4gICAgICogcHJldmVudCB2aWV3ZWQgdG8gY3Jhc2ggYmVjYXVzZSB0b28gbWFueSBET00gZWxlbWVudHMgYXJlIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjc2VhcmNoQ29udGFjdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0PTEwMF0gVGhlIG51bWJlciBvZiByZXN1bHRzIHRvIHJldHVybiwgMCBmb3Igbm9uZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuc2VhcmNoQ29udGFjdHMgPSBmdW5jdGlvbihxdWVyeSwgbGltaXQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgc2VhcmNodGV4dDogcXVlcnksXG4gICAgICAgICAgICAgICAgb25seW15Y291cnNlczogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgbGltaXQgPSB0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnID8gMTAwIDogbGltaXQ7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ2NvcmVfbWVzc2FnZV9zZWFyY2hfY29udGFjdHMnLCBkYXRhKS50aGVuKGZ1bmN0aW9uKGNvbnRhY3RzKSB7XG4gICAgICAgICAgICBpZiAobGltaXQgJiYgY29udGFjdHMubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBjb250YWN0cyA9IGNvbnRhY3RzLnNwbGljZSgwLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkbW1Vc2VyLnN0b3JlVXNlcnMoY29udGFjdHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3RzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2VuZCBhIG1lc3NhZ2UgdG8gc29tZW9uZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNzZW5kTWVzc2FnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0byBVc2VyIElEIHRvIHNlbmQgdGhlIG1lc3NhZ2UgdG8uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKHRvLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdjb3JlX21lc3NhZ2Vfc2VuZF9pbnN0YW50X21lc3NhZ2VzJywge1xuICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRvdXNlcmlkOiB0byxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dGZvcm1hdDogMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlWzBdICYmIHJlc3BvbnNlWzBdLm1zZ2lkID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciwgYW5kIGl0IHNob3VsZCBiZSB0cmFuc2xhdGVkIGFscmVhZHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChyZXNwb25zZVswXS5lcnJvcm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW52YWxpZGF0ZURpc2N1c3Npb25DYWNoZSh0byk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHNvcnQgbWVzc2FnZXMgYnkgdGltZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1lc3NhZ2VzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNZXNzYWdlcyNzb3J0TWVzc2FnZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBtZXNzYWdlcyBBcnJheSBvZiBtZXNzYWdlcyBjb250YWluaW5nIHRoZSBrZXkgJ3RpbWVjcmVhdGVkJy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gTWVzc2FnZXMgc29ydGVkIHdpdGggbW9zdCByZWNlbnQgbGFzdC5cbiAgICAgKi9cbiAgICBzZWxmLnNvcnRNZXNzYWdlcyA9IGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBhID0gcGFyc2VJbnQoYS50aW1lY3JlYXRlZCwgMTApO1xuICAgICAgICAgICAgYiA9IHBhcnNlSW50KGIudGltZWNyZWF0ZWQsIDEwKTtcbiAgICAgICAgICAgIHJldHVybiBhID49IGIgPyAxIDogLTE7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSB1c2VyIGRhdGEgZnJvbSBjb250YWN0cyBpbiBsb2NhbCBEQi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbnRhY3RUeXBlcyBMaXN0IG9mIGNvbnRhY3RzIGdyb3VwZWQgaW4gdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmVVc2Vyc0Zyb21BbGxDb250YWN0cyhjb250YWN0VHlwZXMpIHtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbnRhY3RUeXBlcywgZnVuY3Rpb24oY29udGFjdHMpIHtcbiAgICAgICAgICAgICRtbVVzZXIuc3RvcmVVc2Vycyhjb250YWN0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlIHVzZXIgZGF0YSBmcm9tIGRpc2N1c3Npb25zIGluIGxvY2FsIERCLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGlzY3Vzc2lvbnMgTGlzdCBvZiBkaXNjdXNzaW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yZVVzZXJzRnJvbURpc2N1c3Npb25zKGRpc2N1c3Npb25zKSB7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkaXNjdXNzaW9ucywgZnVuY3Rpb24oZGlzY3Vzc2lvbiwgdXNlcmlkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJpZCAhPSAndW5kZWZpbmVkJyAmJiAhaXNOYU4ocGFyc2VJbnQodXNlcmlkKSkpIHtcbiAgICAgICAgICAgICAgICAkbW1Vc2VyLnN0b3JlVXNlcih1c2VyaWQsIGRpc2N1c3Npb24uZnVsbG5hbWUsIGRpc2N1c3Npb24ucHJvZmlsZWltYWdldXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5ibG9jayBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTWVzc2FnZXMjdW5ibG9ja0NvbnRhY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG8gVXNlciBJRCBvZiB0aGUgcGVyc29uIHRvIHVuYmxvY2suXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLnVuYmxvY2tDb250YWN0ID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdjb3JlX21lc3NhZ2VfdW5ibG9ja19jb250YWN0cycsIHtcbiAgICAgICAgICAgIHVzZXJpZHM6IFsgdXNlcklkIF1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmludmFsaWRhdGVBbGxDb250YWN0c0NhY2hlKCRtbVNpdGUuZ2V0VXNlcklkKCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9hc3NpZ24nKVxuXG4vKipcbiAqIEFzc2lnbiBpbmRleCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9hc3NpZ25cbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RBc3NpZ25JbmRleEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZEFzc2lnbkluZGV4Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1hTW9kQXNzaWduLCAkbW1VdGlsLCAkdHJhbnNsYXRlLFxuICAgICAgICBtbWFNb2RBc3NpZ25Db21wb25lbnQsIG1tYU1vZEFzc2lnblN1Ym1pc3Npb25Db21wb25lbnQpIHtcbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQ7XG5cbiAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBtb2R1bGUuZGVzY3JpcHRpb247XG4gICAgJHNjb3BlLmFzc2lnbmNvbXBvbmVudCA9IG1tYU1vZEFzc2lnbkNvbXBvbmVudDtcbiAgICAkc2NvcGUuc3VibWlzc2lvbmNvbXBvbmVudCA9IG1tYU1vZEFzc2lnblN1Ym1pc3Npb25Db21wb25lbnQ7XG4gICAgJHNjb3BlLmFzc2lnbnVybCA9IG1vZHVsZS51cmw7XG4gICAgJHNjb3BlLmNvdXJzZWlkID0gY291cnNlaWQ7XG5cbiAgICBmdW5jdGlvbiBmZXRjaEFzc2lnbm1lbnQocmVmcmVzaCkge1xuICAgICAgICAvLyBHZXQgYXNzaWdubWVudCBkYXRhLlxuICAgICAgICByZXR1cm4gJG1tYU1vZEFzc2lnbi5nZXRBc3NpZ25tZW50KGNvdXJzZWlkLCBtb2R1bGUuaWQsIHJlZnJlc2gpLnRoZW4oZnVuY3Rpb24oYXNzaWduKSB7XG4gICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBhc3NpZ24ubmFtZSB8fCAkc2NvcGUudGl0bGU7XG4gICAgICAgICAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBhc3NpZ24uaW50cm8gfHzCoCRzY29wZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICRzY29wZS5hc3NpZ24gPSBhc3NpZ247XG5cbiAgICAgICAgICAgIC8vIEdldCBhc3NpZ25tZW50IHN1Ym1pc3Npb25zLlxuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RBc3NpZ24uZ2V0U3VibWlzc2lvbnMoYXNzaWduLmlkLCByZWZyZXNoKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuY2Fudmlld3N1Ym1pc3Npb25zID0gZGF0YS5jYW52aWV3c3VibWlzc2lvbnM7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5jYW52aWV3c3VibWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBzaG93IHRoZSB1c2VyIGRhdGEgb24gZWFjaCBzdWJtaXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZEFzc2lnbi5nZXRTdWJtaXNzaW9uc1VzZXJEYXRhKGRhdGEuc3VibWlzc2lvbnMsIGNvdXJzZWlkKS50aGVuKGZ1bmN0aW9uKHN1Ym1pc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc3VibWlzc2lvbnMsIGZ1bmN0aW9uKHN1Ym1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uLnRleHQgPSAkbW1hTW9kQXNzaWduLmdldFN1Ym1pc3Npb25UZXh0KHN1Ym1pc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb24uYXR0YWNobWVudHMgPSAkbW1hTW9kQXNzaWduLmdldFN1Ym1pc3Npb25BdHRhY2htZW50cyhzdWJtaXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnN1Ym1pc3Npb25zID0gc3VibWlzc2lvbnM7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkdHJhbnNsYXRlKCdtbS5jb3JlLmVycm9yJykudGhlbihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvciArICc6IGdldF9hc3NpZ25tZW50X3N1Ym1pc3Npb25zJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICR0cmFuc2xhdGUoJ21tLmNvcmUuZXJyb3InKS50aGVuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IgKyAnOiBnZXRfYXNzaWdubWVudCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmZXRjaEFzc2lnbm1lbnQoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuYXNzaWdubWVudExvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUucmVmcmVzaEFzc2lnbm1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmV0Y2hBc3NpZ25tZW50KHRydWUpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfYXNzaWduJylcblxuLyoqXG4gKiBBc3NpZ24gc3VibWlzc2lvbiBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9hc3NpZ25cbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RBc3NpZ25TdWJtaXNzaW9uQ3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kQXNzaWduU3VibWlzc2lvbkN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgbW1hTW9kQXNzaWduU3VibWlzc2lvbkNvbXBvbmVudCkge1xuICAgIHZhciBzdWJtaXNzaW9uID0gJHN0YXRlUGFyYW1zLnN1Ym1pc3Npb24gfHwge307XG5cbiAgICAkc2NvcGUudGl0bGUgPSBzdWJtaXNzaW9uLnVzZXJmdWxsbmFtZTtcbiAgICAkc2NvcGUuc3VibWlzc2lvbiA9IHN1Ym1pc3Npb247XG4gICAgJHNjb3BlLmNvbXBvbmVudCA9IG1tYU1vZEFzc2lnblN1Ym1pc3Npb25Db21wb25lbnQ7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9hc3NpZ24nKVxuXG4vKipcbiAqIEFzc2lnbm1lbnRzIHNlcnZpY2UuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lICRtbWFNb2RBc3NpZ25cbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RBc3NpZ24nLCBmdW5jdGlvbigkbW1TaXRlLCAkcSwgJG1tVXNlciwgJG1tU2l0ZXNNYW5hZ2VyKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBhc3NpZ25tZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQXNzaWduI2dldEFzc2lnbm1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgICBDb3Vyc2UgSUQgdGhlIGFzc2lnbm1lbnQgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY21pZCAgICAgICBBc3NpZ25tZW50IG1vZHVsZSBJRC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWZyZXNoXSBUcnVlIHdoZW4gd2Ugc2hvdWxkIG5vdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIGNhY2hlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgYXNzaWdubWVudC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEFzc2lnbm1lbnQgPSBmdW5jdGlvbihjb3Vyc2VpZCwgY21pZCwgcmVmcmVzaCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIFwiY291cnNlaWRzXCI6IFtjb3Vyc2VpZF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge307XG5cbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgIHByZVNldHMuZ2V0RnJvbUNhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfYXNzaWduX2dldF9hc3NpZ25tZW50cycsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmNvdXJzZXMgJiYgcmVzcG9uc2UuY291cnNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXNzaWdubWVudHMgPSByZXNwb25zZS5jb3Vyc2VzWzBdLmFzc2lnbm1lbnRzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXNzaWdubWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2lnbm1lbnRzW2ldLmNtaWQgPT0gY21pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzc2lnbm1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGF0dGFjaG1lbnRzIG9mIGEgc3VibWlzc2lvbi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9hc3NpZ25cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEFzc2lnbiNnZXRTdWJtaXNzaW9uQXR0YWNobWVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3VibWlzc2lvbiBTdWJtaXNzaW9uLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgIFN1Ym1pc3Npb24gYXR0YWNobWVudHMuXG4gICAgICovXG4gICAgc2VsZi5nZXRTdWJtaXNzaW9uQXR0YWNobWVudHMgPSBmdW5jdGlvbihzdWJtaXNzaW9uKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IFtdO1xuICAgICAgICBpZiAoc3VibWlzc2lvbi5wbHVnaW5zKSB7XG4gICAgICAgICAgICBzdWJtaXNzaW9uLnBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnR5cGUgPT09ICdmaWxlJyAmJiBwbHVnaW4uZmlsZWFyZWFzICYmIHBsdWdpbi5maWxlYXJlYXNbMF0gJiYgcGx1Z2luLmZpbGVhcmVhc1swXS5maWxlcykge1xuICAgICAgICAgICAgICAgICAgICBmaWxlcyA9IHBsdWdpbi5maWxlYXJlYXNbMF0uZmlsZXM7XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChmaWxlcywgZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSA9IGZpbGUuZmlsZXBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRleHQgb2YgYSBzdWJtaXNzaW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQXNzaWduI2dldFN1Ym1pc3Npb25UZXh0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN1Ym1pc3Npb24gU3VibWlzc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBTdWJtaXNzaW9uIHRleHQuXG4gICAgICovXG4gICAgc2VsZi5nZXRTdWJtaXNzaW9uVGV4dCA9IGZ1bmN0aW9uKHN1Ym1pc3Npb24pIHtcbiAgICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgICAgaWYgKHN1Ym1pc3Npb24ucGx1Z2lucykge1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHN1Ym1pc3Npb24ucGx1Z2lucywgZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi50eXBlID09PSAnb25saW5ldGV4dCcgJiYgcGx1Z2luLmVkaXRvcmZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gcGx1Z2luLmVkaXRvcmZpZWxkc1swXS50ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubGluZSB0ZXh0IGNvbnRhaW5zICdAQFBMVUdJTkZJTEVAQCcgZm9yIGVhY2ggZW1iZWRkZWQgZmlsZS4gUmVwbGFjZSB0aG9zZSB3aXRoIHRoZSByaWdodCBVUkwuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uZmlsZWFyZWFzICYmIHBsdWdpbi5maWxlYXJlYXNbMF0gJiYgcGx1Z2luLmZpbGVhcmVhc1swXS5maWxlcyAmJiBwbHVnaW4uZmlsZWFyZWFzWzBdLmZpbGVzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZVVSTCA9ICBwbHVnaW4uZmlsZWFyZWFzWzBdLmZpbGVzWzBdLmZpbGV1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlVVJMID0gZmlsZVVSTC5zdWJzdHIoMCwgZmlsZVVSTC5sYXN0SW5kZXhPZignLycpKS5yZXBsYWNlKCdwbHVnaW5maWxlLnBocC8nLCAncGx1Z2luZmlsZS5waHA/ZmlsZT0vJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9AQFBMVUdJTkZJTEVAQC9nLCBmaWxlVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gYXNzaWdubWVudCBzdWJtaXNzaW9ucy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9hc3NpZ25cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEFzc2lnbiNnZXRTdWJtaXNzaW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgaWQgICAgICAgIEFzc2lnbm1lbnQgaWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVmcmVzaF0gVHJ1ZSB3aGVuIHdlIHNob3VsZCBub3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGg6XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGNhbnZpZXdzdWJtaXNzaW9uczogVHJ1ZSBpZiB1c2VyIGNhbiB2aWV3IHN1Ym1pc3Npb25zLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHN1Ym1pc3Npb25zOiBBcnJheSBvZiBzdWJtaXNzaW9ucy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFN1Ym1pc3Npb25zID0gZnVuY3Rpb24oaWQsIHJlZnJlc2gpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBcImFzc2lnbm1lbnRpZHNcIjogW2lkXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7fTtcblxuICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgcHJlU2V0cy5nZXRGcm9tQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9hc3NpZ25fZ2V0X3N1Ym1pc3Npb25zJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gdmlldyBzdWJtaXNzaW9ucywgd2l0aCBlbm91Z2ggcGVybWlzc2lvbnMuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uud2FybmluZ3MubGVuZ3RoID4gMCAmJiByZXNwb25zZS53YXJuaW5nc1swXS53YXJuaW5nY29kZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtjYW52aWV3c3VibWlzc2lvbnM6IGZhbHNlfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmFzc2lnbm1lbnRzICYmIHJlc3BvbnNlLmFzc2lnbm1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2Fudmlld3N1Ym1pc3Npb25zOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VibWlzc2lvbnM6IHJlc3BvbnNlLmFzc2lnbm1lbnRzWzBdLnN1Ym1pc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGRhdGEgZm9yIHN1Ym1pc3Npb25zIHNpbmNlIHRoZXkgb25seSBoYXZlIHVzZXJpZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9hc3NpZ25cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEFzc2lnbiNnZXRTdWJtaXNzaW9uc1VzZXJEYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gc3VibWlzc2lvbnMgU3VibWlzc2lvbnMgdG8gZ2V0IHRoZSBkYXRhIGZvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBjb3Vyc2VpZCAgICBJRCBvZiB0aGUgY291cnNlIHRoZSBzdWJtaXNzaW9ucyBiZWxvbmcgdG8uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgUHJvbWlzZSBhbHdheXMgcmVzb2x2ZWQuIFJlc29sdmUgcGFyYW0gaXMgdGhlIGZvcm1hdHRlZCBzdWJtaXNzaW9ucy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFN1Ym1pc3Npb25zVXNlckRhdGEgPSBmdW5jdGlvbihzdWJtaXNzaW9ucywgY291cnNlaWQpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHN1Ym1pc3Npb25zLCBmdW5jdGlvbihzdWJtaXNzaW9uKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICRtbVVzZXIuZ2V0UHJvZmlsZShzdWJtaXNzaW9uLnVzZXJpZCwgY291cnNlaWQsIHRydWUpLnRoZW4oZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgICAgIHN1Ym1pc3Npb24udXNlcmZ1bGxuYW1lID0gdXNlci5mdWxsbmFtZTtcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uLnVzZXJwcm9maWxlaW1hZ2V1cmwgPSB1c2VyLnByb2ZpbGVpbWFnZXVybDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIGdldHRpbmcgcHJvZmlsZSwgcmVzb2x2ZSBwcm9taXNlIHdpdGhvdXQgYWRkaW5nIGFueSBleHRyYSBkYXRhLlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJtaXNzaW9ucztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFzc2lnbm1lbnRzIHBsdWdpbiBpcyBlbmFibGVkIGluIGEgY2VydGFpbiBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Fzc2lnblxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQXNzaWduI2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIHBsdWdpbiBpcyBlbmFibGVkLCByZWplY3RlZCBvciByZXNvbHZlZCB3aXRoIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUud3NBdmFpbGFibGUoJ21vZF9hc3NpZ25fZ2V0X2Fzc2lnbm1lbnRzJykgJiYgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2Fzc2lnbl9nZXRfc3VibWlzc2lvbnMnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfYXNzaWduJylcblxuLyoqXG4gKiBNb2QgYXNzaWduIGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9hc3NpZ25cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kQXNzaWduSGFuZGxlcnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RBc3NpZ25IYW5kbGVycycsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tYU1vZEFzc2lnbiwgJHN0YXRlLCAkcSwgJG1tQ29udGVudExpbmtzSGVscGVyKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvdXJzZSBjb250ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYXNzaWduXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RBc3NpZ25IYW5kbGVycyNjb3Vyc2VDb250ZW50XG4gICAgICovXG4gICAgc2VsZi5jb3Vyc2VDb250ZW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RBc3NpZ24uaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKCdhc3NpZ24nKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW9kX2Fzc2lnbicsIHttb2R1bGU6IG1vZHVsZSwgY291cnNlaWQ6IGNvdXJzZWlkfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9hc3NpZ25cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEFzc2lnbkhhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICBTaXRlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoc2l0ZUlkLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RBc3NpZ24uaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhY3Rpb25zIHRvIHBlcmZvcm0gd2l0aCB0aGUgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhbiBhc3NpZ24gVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL2Fzc2lnbi92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9ib29rJylcblxuLyoqXG4gKiBCb29rIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RCb29rSW5kZXhDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RCb29rSW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbVV0aWwsICRtbWFNb2RCb29rLCAkbG9nLCBtbWFNb2RCb29rQ29tcG9uZW50LFxuICAgICAgICAgICAgJGlvbmljUG9wb3ZlciwgJG1tQXBwLCAkcSwgJG1tQ291cnNlLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbWFNb2RCb29rSW5kZXhDdHJsJyk7XG5cbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIGN1cnJlbnRDaGFwdGVyO1xuXG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbW9kdWxlLmRlc2NyaXB0aW9uO1xuICAgICRzY29wZS5jb21wb25lbnQgPSBtbWFNb2RCb29rQ29tcG9uZW50O1xuICAgICRzY29wZS5jb21wb25lbnRJZCA9IG1vZHVsZS5pZDtcbiAgICAkc2NvcGUuZXh0ZXJuYWxVcmwgPSBtb2R1bGUudXJsO1xuICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcblxuICAgIHZhciBjaGFwdGVycyA9ICRtbWFNb2RCb29rLmdldFRvY0xpc3QobW9kdWxlLmNvbnRlbnRzKTtcbiAgICBjdXJyZW50Q2hhcHRlciA9ICRtbWFNb2RCb29rLmdldEZpcnN0Q2hhcHRlcihjaGFwdGVycyk7XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBsb2FkIGEgYm9vayBjaGFwdGVyLlxuICAgIGZ1bmN0aW9uIGxvYWRDaGFwdGVyKGNoYXB0ZXJJZCkge1xuICAgICAgICBjdXJyZW50Q2hhcHRlciA9IGNoYXB0ZXJJZDtcbiAgICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUuc2Nyb2xsVG9wKCk7XG4gICAgICAgIHJldHVybiAkbW1hTW9kQm9vay5nZXRDaGFwdGVyQ29udGVudChtb2R1bGUuY29udGVudHMsIGNoYXB0ZXJJZCwgbW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICRzY29wZS5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgICRzY29wZS5wcmV2aW91c0NoYXB0ZXIgPSAkbW1hTW9kQm9vay5nZXRQcmV2aW91c0NoYXB0ZXIoY2hhcHRlcnMsIGNoYXB0ZXJJZCk7XG4gICAgICAgICAgICAkc2NvcGUubmV4dENoYXB0ZXIgPSAkbW1hTW9kQm9vay5nZXROZXh0Q2hhcHRlcihjaGFwdGVycywgY2hhcHRlcklkKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2Jvb2suZXJyb3JjaGFwdGVyJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICRpb25pY1Njcm9sbERlbGVnYXRlLnJlc2l6ZSgpOyAvLyBDYWxsIHJlc2l6ZSB0byByZWNhbGN1bGF0ZSBzY3JvbGwgYXJlYS5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZG93bmxvYWQgYm9vayBjb250ZW50cyBhbmQgbG9hZCB0aGUgY3VycmVudCBjaGFwdGVyLlxuICAgIGZ1bmN0aW9uIGZldGNoQ29udGVudChjaGFwdGVySWQpIHtcbiAgICAgICAgdmFyIGRvd25sb2FkRmFpbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAkbW1hTW9kQm9vay5kb3dubG9hZEFsbENvbnRlbnQobW9kdWxlKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgZG93bmxvYWQgYXMgZmFpbGVkIGJ1dCBnbyBvbiBzaW5jZSB0aGUgbWFpbiBmaWxlcyBjb3VsZCBoYXZlIGJlZW4gZG93bmxvYWRlZC5cbiAgICAgICAgICAgIGRvd25sb2FkRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFNob3cgY2hhcHRlci5cbiAgICAgICAgICAgIHJldHVybiBsb2FkQ2hhcHRlcihjaGFwdGVySWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkRmFpbGVkICYmICRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIGxvYWQgdGhlIG1haW4gZmlsZSBidXQgdGhlIGRvd25sb2FkIGZhaWxlZC4gU2hvdyBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3JlLmVycm9yZG93bmxvYWRpbmdzb21lZmlsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgJHNjb3BlLmRvUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTW9kQm9vay5pbnZhbGlkYXRlQ29udGVudChtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hDb250ZW50KGN1cnJlbnRDaGFwdGVyKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBGdW5jdGlvbiB0byBsb2FkIGEgY2hhcHRlci5cbiAgICAkc2NvcGUubG9hZENoYXB0ZXIgPSBmdW5jdGlvbihjaGFwdGVySWQpIHtcbiAgICAgICAgJHNjb3BlLnBvcG92ZXIuaGlkZSgpO1xuICAgICAgICAkc2NvcGUubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGxvYWRDaGFwdGVyKGNoYXB0ZXJJZCk7XG4gICAgfTtcblxuICAgIC8vIE1lbnUgcG9wb3Zlci5cbiAgICAkc2NvcGUudG9jID0gY2hhcHRlcnM7XG4gICAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ2FkZG9ucy9tb2RfYm9vay90ZW1wbGF0ZXMvdG9jLmh0bWwnLCB7XG4gICAgICAgIHNjb3BlOiAkc2NvcGUsXG4gICAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgICAgICRzY29wZS5wb3BvdmVyID0gcG9wb3ZlcjtcbiAgICB9KTtcblxuXG4gICAgZmV0Y2hDb250ZW50KGN1cnJlbnRDaGFwdGVyKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTW9kQm9vay5sb2dWaWV3KG1vZHVsZS5pbnN0YW5jZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbUNvdXJzZS5jaGVja01vZHVsZUNvbXBsZXRpb24oY291cnNlaWQsIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9ib29rJylcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gbmF2aWdhdGUgdG8gcHJldmlvdXMvbmV4dCBjaGFwdGVyIGluIGEgYm9vay5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1hTW9kQm9va0Fycm93c1xuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGRpcmVjdGl2ZSB3aWxsIHNob3cgdHdvIGFycm93cyBhdCB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIHNjcmVlbiB0byBuYXZpZ2F0ZSB0byBwcmV2aW91cy9uZXh0IGJvb2sgY2hhcHRlciB3aGVuXG4gKiBjbGlja2VkLiBJZiBubyBwcmV2aW91cy9uZXh0IGNoYXB0ZXIgaXMgZGVmaW5lZCwgdGhhdCBhcnJvdyB3b24ndCBiZSBzaG93bi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gICBwcmV2aW91cyBJRCBvZiB0aGUgcHJldmlvdXMgY2hhcHRlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIG5leHQgICAgIElEIG9mIHRoZSBuZXh0IGNoYXB0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gICBGdW5jdGlvbiB0byBjYWxsIHdoZW4gYW4gYXJyb3cgaXMgY2xpY2tlZC4gV2lsbCByZWNlaXZlIGFzIGEgcGFyYW0gdGhlIGNoYXB0ZXJJZCB0byBsb2FkLlxuICovXG4uZGlyZWN0aXZlKCdtbWFNb2RCb29rQXJyb3dzJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgIHByZXZpb3VzOiAnPT8nLFxuICAgICAgICAgICAgbmV4dDogJz0/JyxcbiAgICAgICAgICAgIGFjdGlvbjogJz0/J1xuICAgICAgICB9LFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfYm9vay90ZW1wbGF0ZXMvYXJyb3dzLmh0bWwnXG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2Jvb2snKVxuXG4vKipcbiAqIEJvb2sgZmFjdG9yeS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RCb29rXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kQm9vaycsIGZ1bmN0aW9uKCRtbUZpbGVwb29sLCAkbW1TaXRlLCAkbW1GUywgJGh0dHAsICRsb2csICRxLCAkbW1TaXRlc01hbmFnZXIsIG1tYU1vZEJvb2tDb21wb25lbnQpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU1vZEJvb2snKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbGwgdGhlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9vayNkb3dubG9hZEFsbENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBjb250ZW50IGlzIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYuZG93bmxvYWRBbGxDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMobW9kdWxlKSxcbiAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgIHRpbWVtb2QgPSAkbW1GaWxlcG9vbC5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKTtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmRvd25sb2FkUGFja2FnZSgkbW1TaXRlLmdldElkKCksIGZpbGVzLCBtbWFNb2RCb29rQ29tcG9uZW50LCBtb2R1bGUuaWQsIHJldmlzaW9uLCB0aW1lbW9kKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGV2ZW50IG5hbWVzIG9mIGZpbGVzIGJlaW5nIGRvd25sb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9vayNnZXREb3dubG9hZGluZ0ZpbGVzRXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkaW5nRmlsZXNFdmVudE5hbWVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgZXZlbnROYW1lcyA9IFtdLFxuICAgICAgICAgICAgc2l0ZWlkID0gJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBjb250ZW50LmZpbGV1cmw7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GaWxlcG9vbC5pc0ZpbGVEb3dubG9hZGluZ0J5VXJsKHNpdGVpZCwgdXJsKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXRGaWxlRXZlbnROYW1lQnlVcmwoc2l0ZWlkLCB1cmwpLnRoZW4oZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZXMucHVzaChldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGZhaWxzLlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlIGV2ZW50IG5hbWVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2sjZ2V0RmlsZUV2ZW50TmFtZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhcnJheSBvZiAkbW1FdmVudCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVFdmVudE5hbWVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gY29udGVudC5maWxldXJsO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzRmlsZURvd25sb2FkYWJsZShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tRmlsZXBvb2wuZ2V0RmlsZUV2ZW50TmFtZUJ5VXJsKCRtbVNpdGUuZ2V0SWQoKSwgdXJsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE5hbWVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBjYW4gYmUgZG93bmxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2dldERvd25sb2FkYWJsZUZpbGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gICAgIExpc3Qgb2YgZmlsZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBbXTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYm9vayB0b2MgYXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9vayNnZXRUb2NcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gY29udGVudHMgVGhlIG1vZHVsZSBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgVGhlIHRvYy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5nZXRUb2MgPSBmdW5jdGlvbihjb250ZW50cykge1xuICAgICAgICBpZiAoIWNvbnRlbnRzIHx8wqAhY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudHNbMF0uY29udGVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYm9vayB0b2MgYXMgYW4gYXJyYXkgb2YgY2hhcHRlcnMgKG5vIG5lc3RlZCkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9vayNnZXRUb2NMaXN0XG4gICAgICogQHBhcmFtICB7YXJyYXl9IGNvbnRlbnRzIFRoZSBtb2R1bGUgY29udGVudHMuXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIFRoZSB0b2MgYXMgYSBsaXN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLmdldFRvY0xpc3QgPSBmdW5jdGlvbihjb250ZW50cykge1xuICAgICAgICB2YXIgY2hhcHRlcnMgPSBbXTtcbiAgICAgICAgdmFyIHRvYyA9IHNlbGYuZ2V0VG9jKGNvbnRlbnRzKTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHRvYywgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHZhciBjaGFwdGVySWQgPSBlbC5ocmVmLnJlcGxhY2UoJy9pbmRleC5odG1sJywgJycpO1xuICAgICAgICAgICAgY2hhcHRlcnMucHVzaCh7aWQ6IGNoYXB0ZXJJZCwgdGl0bGU6IGVsLnRpdGxlLCBsZXZlbDogZWwubGV2ZWx9KTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbC5zdWJpdGVtcywgZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgICAgICAgICAgY2hhcHRlcklkID0gc2VsLmhyZWYucmVwbGFjZSgnL2luZGV4Lmh0bWwnLCAnJyk7XG4gICAgICAgICAgICAgICAgY2hhcHRlcnMucHVzaCh7aWQ6IGNoYXB0ZXJJZCwgdGl0bGU6IHNlbC50aXRsZSwgbGV2ZWw6IHNlbC5sZXZlbH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hhcHRlcnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgY2hhcHRlciBvZiBhIGJvb2suXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9vayNnZXRGaXJzdENoYXB0ZXJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gY2hhcHRlcnMgIFRoZSBjaGFwdGVycyBsaXN0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgVGhlIGNoYXB0ZXIgaWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuZ2V0Rmlyc3RDaGFwdGVyID0gZnVuY3Rpb24oY2hhcHRlcnMpIHtcbiAgICAgICAgaWYgKCFjaGFwdGVycyB8fCAhY2hhcHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYXB0ZXJzWzBdLmlkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByZXZpb3VzIGNoYXB0ZXIgdG8gdGhlIGdpdmVuIG9uZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2dldFByZXZpb3VzQ2hhcHRlclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBjaGFwdGVycyAgICAgVGhlIGNoYXB0ZXJzIGxpc3QuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBjaGFwdGVySWQgICBUaGUgY3VycmVudCBjaGFwdGVyLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgVGhlIHByZXZpb3VzIGNoYXB0ZXIgaWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuZ2V0UHJldmlvdXNDaGFwdGVyID0gZnVuY3Rpb24oY2hhcHRlcnMsIGNoYXB0ZXJJZCkge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGFwdGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoYXB0ZXJzW2ldLmlkID09IGNoYXB0ZXJJZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBjaGFwdGVyc1tpXS5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IGNoYXB0ZXIgdG8gdGhlIGdpdmVuIG9uZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2dldE5leHRDaGFwdGVyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IGNoYXB0ZXJzICAgICBUaGUgY2hhcHRlcnMgbGlzdC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNoYXB0ZXJJZCAgIFRoZSBjdXJyZW50IGNoYXB0ZXIuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICBUaGUgbmV4dCBjaGFwdGVyIGlkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLmdldE5leHRDaGFwdGVyID0gZnVuY3Rpb24oY2hhcHRlcnMsIGNoYXB0ZXJJZCkge1xuICAgICAgICB2YXIgbmV4dCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoYXB0ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2hhcHRlcnNbaV0uaWQgPT0gY2hhcHRlcklkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFwdGVyc1tpICsgMV0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNoYXB0ZXJzW2kgKyAxXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgY2hhcHRlciBjb250ZW50cyBmcm9tIHRoZSBib29rLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2sjZ2V0Q2hhcHRlckNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGVudHMgICAgIFRoZSBtb2R1bGUgY29udGVudHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoYXB0ZXJJZCAgICBDaGFwdGVyIHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbW9kdWxlSWQgICAgVGhlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuZ2V0Q2hhcHRlckNvbnRlbnQgPSBmdW5jdGlvbihjb250ZW50cywgY2hhcHRlcklkLCBtb2R1bGVJZCkge1xuICAgICAgICB2YXIgaW5kZXhVcmwsXG4gICAgICAgICAgICBwYXRocyA9IHt9LFxuICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICAvLyBFeHRyYWN0IHRoZSBpbmZvcm1hdGlvbiBhYm91dCBwYXRocyBmcm9tIHRoZSBtb2R1bGUgY29udGVudHMuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250ZW50cywgZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gY29udGVudC5maWxldXJsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleFVybCAmJiBjb250ZW50LmZpbGVuYW1lID09ICdpbmRleC5odG1sJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBjaGFwdGVyLCB3ZSBkb24ndCBoYXZlIGEgY2hhcHRlciBpZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQuZmlsZXBhdGggPT0gXCIvXCIgKyBjaGFwdGVySWQgKyBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhVcmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBjb250ZW50LmZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICBwYXRoc1trZXldID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvbWlzZSBoYW5kbGluZyB3aGVuIHdlIGFyZSBpbiBhIGJyb3dzZXIuXG4gICAgICAgIHByb21pc2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQ7XG4gICAgICAgICAgICBpZiAoIWluZGV4VXJsKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZXZlciB0aGF0IGhhcHBlbnMuXG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ291bGQgbm90IGxvY2F0ZSB0aGUgaW5kZXggY2hhcHRlcicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIHN5c3RlbSBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmRvd25sb2FkVXJsKCRtbVNpdGUuZ2V0SWQoKSwgaW5kZXhVcmwsIGZhbHNlLCBtbWFNb2RCb29rQ29tcG9uZW50LCBtb2R1bGVJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJldHVybiB0aGUgbGl2ZSBVUkwuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoJG1tU2l0ZS5maXhQbHVnaW5maWxlVVJMKGluZGV4VXJsKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBVUkwgY29udGVudC5cbiAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQodXJsKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5kYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHRoYXQgd2UgaGF2ZSB0aGUgY29udGVudCwgd2UgdXBkYXRlIHRoZSBTUkMgdG8gcG9pbnQgYmFjayB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZXh0ZXJuYWwgcmVzb3VyY2UuIFRoYXQgd2lsbCBiZSBjYXVnaHQgYnkgbW0tZm9ybWF0LXRleHQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBodG1sID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2PicpO1xuICAgICAgICAgICAgICAgICAgICBodG1sLmh0bWwocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChodG1sLmZpbmQoJ2ltZycpLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmMgPSBwYXRoc1tkZWNvZGVVUklDb21wb25lbnQoaW1nLmdldEF0dHJpYnV0ZSgnc3JjJykpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ3NyYycsIHNyYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGUgc2FtZSBmb3IgbGlua3MuXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChodG1sLmZpbmQoJ2EnKSwgZnVuY3Rpb24oYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IHBhdGhzW2RlY29kZVVSSUNvbXBvbmVudChhbmNob3IuZ2V0QXR0cmlidXRlKCdocmVmJykpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaHJlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHRtbC5odG1sKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIHRoZSBwcmVmZXRjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9vayNpbnZhbGlkYXRlQ29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGVJZCBUaGUgbW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQ29udGVudCA9IGZ1bmN0aW9uKG1vZHVsZUlkKSB7XG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5pbnZhbGlkYXRlRmlsZXNCeUNvbXBvbmVudCgkbW1TaXRlLmdldElkKCksIG1tYU1vZEJvb2tDb21wb25lbnQsIG1vZHVsZUlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBmaWxlIGlzIGRvd25sb2FkYWJsZS4gVGhlIGZpbGUgcGFyYW0gbXVzdCBoYXZlIGEgJ3R5cGUnIGF0dHJpYnV0ZSBsaWtlIGluIGNvcmVfY291cnNlX2dldF9jb250ZW50cyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2lzRmlsZURvd25sb2FkYWJsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlIEZpbGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgVHJ1ZSBpZiBkb3dubG9hZGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzRmlsZURvd25sb2FkYWJsZSA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGUudHlwZSA9PT0gJ2ZpbGUnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2sjaXNQbHVnaW5FbmFibGVkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IHNpdGUuZ2V0SW5mbygpLnZlcnNpb247XG4gICAgICAgICAgICAvLyBSZXF1aXJlIE1vb2RsZSAyLjkuXG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbiAmJiAocGFyc2VJbnQodmVyc2lvbikgPj0gMjAxNTA1MTEwMCkgJiYgc2l0ZS5jYW5Eb3dubG9hZEZpbGVzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgYSBib29rIGFzIGJlaW5nIHZpZXdlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rI2xvZ1ZpZXdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgTW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ1ZpZXcgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYm9va2lkOiBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfYm9va192aWV3X2Jvb2snLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlZmV0Y2ggdGhlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQm9vayNwcmVmZXRjaENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBjb250ZW50IGlzIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYucHJlZmV0Y2hDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMobW9kdWxlKSxcbiAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgIHRpbWVtb2QgPSAkbW1GaWxlcG9vbC5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKTtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLnByZWZldGNoUGFja2FnZSgkbW1TaXRlLmdldElkKCksIGZpbGVzLCBtbWFNb2RCb29rQ29tcG9uZW50LCBtb2R1bGUuaWQsIHJldmlzaW9uLCB0aW1lbW9kKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9ib29rJylcblxuLyoqXG4gKiBNb2QgYm9vayBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RCb29rSGFuZGxlcnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RCb29rSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbWFNb2RCb29rLCAkbW1FdmVudHMsICRzdGF0ZSwgJG1tU2l0ZSwgJG1tVXRpbCwgJG1tRmlsZXBvb2wsXG4gICAgICAgICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLCBtbUNvcmVEb3dubG9hZGluZywgbW1Db3JlTm90RG93bmxvYWRlZCwgbW1Db3JlT3V0ZGF0ZWQsIG1tQ29yZURvd25sb2FkZWQsXG4gICAgICAgICAgICBtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLCBtbWFNb2RCb29rQ29tcG9uZW50LCAkbW1Db250ZW50TGlua3NIZWxwZXIsICRxKSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rSGFuZGxlcnMjY291cnNlQ29udGVudEhhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RCb29rLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBpbmZvLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25sb2FkQnRuLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoQnRuLFxuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbiA9ICRtbUZpbGVwb29sLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuXG4gICAgICAgICAgICAgICAgZG93bmxvYWRCdG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1pb3MtY2xvdWQtZG93bmxvYWQtb3V0bGluZScsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnbW0uY29yZS5kb3dubG9hZCcsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RCb29rLnByZWZldGNoQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tYW5kcm9pZC1yZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLnJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZEJvb2suaW52YWxpZGF0ZUNvbnRlbnQobW9kdWxlLmlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RCb29rLnByZWZldGNoQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJGRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ2Jvb2snKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYnV0dG9ucyA9IFtkb3dubG9hZEJ0biwgcmVmcmVzaEJ0bl07XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2RfYm9vaycsIHttb2R1bGU6IG1vZHVsZSwgY291cnNlaWQ6IGNvdXJzZWlkfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3cgYnV0dG9ucyBhY2NvcmRpbmcgdG8gbW9kdWxlIHN0YXR1cy5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG93U3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IHN0YXR1cyA9PT0gbW1Db3JlRG93bmxvYWRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEJ0bi5oaWRkZW4gPSBzdGF0dXMgIT09IG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgc2hvdyByZWZyZXNoIGJ1dHRvbiBpZiBhIGJvb2sgaXMgZG93bmxvYWRlZCBiZWNhdXNlIHJldmlzaW9uIGFuZCB0aW1lbW9kaWZpZWQgYXJlbid0IHJlbGlhYmxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEJ0bi5oaWRkZW4gPSBzdGF0dXMgIT09IG1tQ29yZU91dGRhdGVkICYmwqBzdGF0dXMgIT09IG1tQ29yZURvd25sb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhpcyBtb2R1bGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNpdGVpZCA9PT0gJG1tU2l0ZS5nZXRJZCgpICYmIGRhdGEuY29tcG9uZW50SWQgPT09IG1vZHVsZS5pZCAmJiBkYXRhLmNvbXBvbmVudCA9PT0gbW1hTW9kQm9va0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1N0YXR1cyhkYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IHN0YXR1cyB0byBkZWNpZGUgd2hpY2ggaWNvbiBzaG91bGQgYmUgc2hvd24uXG4gICAgICAgICAgICAgICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5nZXRNb2R1bGVTdGF0dXMobW9kdWxlLCBjb3Vyc2VpZCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCkudGhlbihzaG93U3RhdHVzKTtcblxuICAgICAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c09ic2VydmVyICYmIHN0YXR1c09ic2VydmVyLm9mZiAmJiBzdGF0dXNPYnNlcnZlci5vZmYoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rSGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRW5hYmxlZChzaXRlSWQsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEJvb2suaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhY3Rpb25zIHRvIHBlcmZvcm0gd2l0aCB0aGUgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhIGJvb2sgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL2Jvb2svdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfYm9vaycpXG5cbi8qKlxuICogTW9kIGJvb2sgcHJlZmV0Y2ggaGFuZGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfYm9va1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RCb29rUHJlZmV0Y2hIYW5kbGVyXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kQm9va1ByZWZldGNoSGFuZGxlcicsIGZ1bmN0aW9uKCRtbWFNb2RCb29rLCBtbUNvcmVEb3dubG9hZGVkLCBtbUNvcmVPdXRkYXRlZCwgbW1hTW9kQm9va0NvbXBvbmVudCkge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIHNlbGYuY29tcG9uZW50ID0gbW1hTW9kQm9va0NvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgc3RhdHVzIG9mIGEgbW9kdWxlIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXR1cyBkZXRlY3RlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rUHJlZmV0Y2hIYW5kbGVyI2RldGVybWluZVN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0dXMgQ3VycmVudCBzdGF0dXMuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBTdGF0dXMgdG8gc2hvdy5cbiAgICAgKi9cbiAgICBzZWxmLmRldGVybWluZVN0YXR1cyA9IGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICBpZiAoc3RhdHVzID09PSBtbUNvcmVEb3dubG9hZGVkKSB7XG4gICAgICAgICAgICAvLyBCb29rcyBhcmUgYWx3YXlzIHRyZWF0ZWQgYXMgb3V0ZGF0ZWQgc2luY2UgcmV2aXNpb24gYW5kIHRpbWVtb2RpZmllZCBhcmVuJ3QgcmVsaWFibGUuXG4gICAgICAgICAgICByZXR1cm4gbW1Db3JlT3V0ZGF0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG93bmxvYWQgc2l6ZSBvZiBhIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rUHJlZmV0Y2hIYW5kbGVyI2dldERvd25sb2FkU2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgTW9kdWxlIHRvIGdldCB0aGUgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIFNpemUuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZFNpemUgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoJG1tYU1vZEJvb2suaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpICYmIGNvbnRlbnQuZmlsZXNpemUpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gc2l6ZSArIGNvbnRlbnQuZmlsZXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9ib29rXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RCb29rUHJlZmV0Y2hIYW5kbGVyI2lzRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RCb29rLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCB0aGUgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Jvb2tcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEJvb2tQcmVmZXRjaEhhbmRsZXIjcHJlZmV0Y2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBmaWxlcyBoYXZlIGJlZW4gZG93bmxvYWRlZC4gRGF0YSByZXR1cm5lZCBpcyBub3QgcmVsaWFibGUuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaCA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZEJvb2sucHJlZmV0Y2hDb250ZW50KG1vZHVsZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfY2hhdCcpXG5cbi8qKlxuICogQ2hhdCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaGF0XG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kQ2hhdENoYXRDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RDaGF0Q2hhdEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tQXBwLCAkbW1hTW9kQ2hhdCwgJGxvZywgJGlvbmljTW9kYWwsICRtbVV0aWwsICRpb25pY0hpc3RvcnksXG4gICAgICAgICAgICAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSwgJHRpbWVvdXQsICRtbVNpdGUsICRpbnRlcnZhbCwgbW1hQ2hhdFBvbGxJbnRlcnZhbCkge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tYU1vZENoYXRDaGF0Q3RybCcpO1xuXG4gICAgdmFyIGNoYXRJZCA9ICRzdGF0ZVBhcmFtcy5jaGF0aWQsXG4gICAgICAgIGNvdXJzZUlkID0gJHN0YXRlUGFyYW1zLmNvdXJzZWlkLFxuICAgICAgICB0aXRsZSA9ICRzdGF0ZVBhcmFtcy50aXRsZSxcbiAgICAgICAgcG9sbGluZztcblxuICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAkc2NvcGUudGl0bGUgPSB0aXRsZTtcbiAgICAkc2NvcGUuY3VycmVudFVzZXJJZCA9ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG4gICAgJHNjb3BlLmN1cnJlbnRVc2VyQmVlcCA9ICdiZWVwICcgKyAkc2NvcGUuY3VycmVudFVzZXJJZDtcbiAgICAkc2NvcGUubWVzc2FnZXMgPSBbXTtcbiAgICAkc2NvcGUuY2hhdFVzZXJzID0gW107XG5cbiAgICAvLyBXZSB1c2UgYW4gb2JqZWN0IGJlY2F1c2UgaXQgd29ya3MgYmV0dGVyIHdpdGggZm9ybXMuXG4gICAgJHNjb3BlLm5ld01lc3NhZ2UgPSB7XG4gICAgICAgIHRleHQ6ICcnXG4gICAgfTtcbiAgICBjaGF0TGFzdFRpbWUgPSAwO1xuXG4gICAgLy8gQ2hhdCB1c2VycyBtb2RhbC5cbiAgICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ2FkZG9ucy9tb2RfY2hhdC90ZW1wbGF0ZXMvdXNlcnMuaHRtbCcsIHtcbiAgICAgICAgc2NvcGU6ICRzY29wZSxcbiAgICAgICAgYW5pbWF0aW9uOiAnc2xpZGUtaW4tdXAnXG4gICAgfSkudGhlbihmdW5jdGlvbihtKSB7XG4gICAgICAgICRzY29wZS5tb2RhbCA9IG07XG4gICAgfSk7XG5cbiAgICAvLyBDbG9zZSB0aGUgY2hhdCB1c2VycyBtb2RhbC5cbiAgICAkc2NvcGUuY2xvc2VNb2RhbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICRzY29wZS5tb2RhbC5oaWRlKCk7XG4gICAgfTtcblxuICAgIC8vIERpc3BsYXkgdGhlIGNoYXQgdXNlcnMgbW9kYWwuXG4gICAgJHNjb3BlLnNob3dDaGF0VXNlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLnVzZXJzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICRzY29wZS5tb2RhbC5zaG93KCk7XG4gICAgICAgICRtbWFNb2RDaGF0LmdldENoYXRVc2Vycygkc2NvcGUuY2hhdHNpZCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAkc2NvcGUuY2hhdFVzZXJzID0gZGF0YS51c2VycztcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHNob3dFcnJvcihlcnJvciwgJ21tYS5tb2RfY2hhdC5lcnJvcndoaWxlZ2V0dGluZ2NoYXR1c2VycycpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLnVzZXJzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBUbyBcInVzZXJcIjpcbiAgICAkc2NvcGUudGFsa1RvID0gZnVuY3Rpb24odXNlcikge1xuICAgICAgICAkc2NvcGUubmV3TWVzc2FnZS50ZXh0ID0gXCJUbyBcIiArIHVzZXIgKyBcIjogXCI7XG4gICAgICAgICRzY29wZS5tb2RhbC5oaWRlKCk7XG4gICAgfTtcblxuICAgIC8vIEJlZXAgYSB1c2VyLlxuICAgICRzY29wZS5iZWVwVG8gPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICAgICAgJHNjb3BlLnNlbmRNZXNzYWdlKCcnLCB1c2VySWQpO1xuICAgICAgICAkc2NvcGUubW9kYWwuaGlkZSgpO1xuICAgIH07XG5cbiAgICAvLyBDaGVjayBpcyB0aGUgYXBwIGlzIG9mZmxpbmUuXG4gICAgJHNjb3BlLmlzQXBwT2ZmbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISRtbUFwcC5pc09ubGluZSgpO1xuICAgIH07XG5cbiAgICAvLyBTaG93IGVycm9yIG1vZGFsLlxuICAgIGZ1bmN0aW9uIHNob3dFcnJvcihlcnJvciwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChkZWZhdWx0TWVzc2FnZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgZGF0ZSBzaG91bGQgYmUgZGlzcGxheWVkIGJldHdlZW4gbWVzc2FnZXMgKHdoZW4gdGhlIGRheSBjaGFuZ2VzIGF0IG1pZG5pZ2h0IGZvciBleGFtcGxlKS5cbiAgICAkc2NvcGUuc2hvd0RhdGUgPSBmdW5jdGlvbihtZXNzYWdlLCBwcmV2TWVzc2FnZSkge1xuICAgICAgICBpZiAoIXByZXZNZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGRheSBoYXMgY2hhbmdlZC5cbiAgICAgICAgcmV0dXJuICFtb21lbnQobWVzc2FnZS50aW1lc3RhbXAgKiAxMDAwKS5pc1NhbWUocHJldk1lc3NhZ2UudGltZXN0YW1wICogMTAwMCwgJ2RheScpO1xuICAgIH07XG5cbiAgICAvLyBTZW5kIGEgbWVzc2FnZSB0byB0aGUgY2hhdC5cbiAgICAkc2NvcGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbih0ZXh0LCBiZWVwKSB7XG4gICAgICAgIGJlZXAgPSBiZWVwIHx8ICcnO1xuXG4gICAgICAgIGlmICghJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgIC8vIFNpbGVudCBlcnJvciwgdGhlIHZpZXcgc2hvdWxkIHByZXZlbnQgdGhpcy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChiZWVwID09PSAnJyAmJiAhdGV4dC50cmltKCkpIHtcbiAgICAgICAgICAgIC8vIFNpbGVudCBlcnJvci5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oPzpcXHJcXG58XFxyfFxcbikvZywgJzxiciAvPicpO1xuXG4gICAgICAgICRtbWFNb2RDaGF0LnNlbmRNZXNzYWdlKCRzY29wZS5jaGF0c2lkLCB0ZXh0LCBiZWVwKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGJlZXAgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm5ld01lc3NhZ2UudGV4dCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgLy8gT25seSBjbG9zZSB0aGUga2V5Ym9hcmQgaWYgYW4gZXJyb3IgaGFwcGVucywgd2Ugd2FudCB0aGUgdXNlciB0byBiZSBhYmxlIHRvIHNlbmQgbXVsdGlwbGVcbiAgICAgICAgICAgIC8vIG1lc3NhZ2VzIHdpdGhvdXR0aGUga2V5Ym9hcmQgYmVpbmcgY2xvc2VkLlxuICAgICAgICAgICAgJG1tQXBwLmNsb3NlS2V5Ym9hcmQoKTtcblxuICAgICAgICAgICAgc2hvd0Vycm9yKGVycm9yLCAnbW1hLm1vZF9jaGF0LmVycm9yd2hpbGVzZW5kaW5nbWVzc2FnZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gTG9naW4gdGhlIHVzZXIuXG4gICAgJG1tYU1vZENoYXQubG9naW5Vc2VyKGNoYXRJZCkudGhlbihmdW5jdGlvbihjaGF0c2lkKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kQ2hhdC5nZXRMYXRlc3RNZXNzYWdlcyhjaGF0c2lkLCAwKS50aGVuKGZ1bmN0aW9uKG1lc3NhZ2VzSW5mbykge1xuICAgICAgICAgICAgJHNjb3BlLmNoYXRzaWQgPSBjaGF0c2lkO1xuICAgICAgICAgICAgY2hhdExhc3RUaW1lID0gbWVzc2FnZXNJbmZvLmNoYXRuZXdsYXN0dGltZTtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kQ2hhdC5nZXRNZXNzYWdlc1VzZXJEYXRhKG1lc3NhZ2VzSW5mby5tZXNzYWdlcywgY291cnNlSWQpLnRoZW4oZnVuY3Rpb24obWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubWVzc2FnZXMgPSAkc2NvcGUubWVzc2FnZXMuY29uY2F0KG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICBzaG93RXJyb3IobWVzc2FnZSwgJ21tYS5tb2RfY2hhdC5lcnJvcndoaWxlcmV0cmlldmluZ21lc3NhZ2VzJyk7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIHNob3dFcnJvcihlcnJvciwgJ21tYS5tb2RfY2hhdC5lcnJvcndoaWxlY29ubmVjdGluZycpO1xuICAgICAgICAkaW9uaWNIaXN0b3J5LmdvQmFjaygpO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gU2Nyb2xsIHRvIHRoZSBib3R0b20uXG4gICAgJHNjb3BlLnNjcm9sbEFmdGVyUmVuZGVyID0gZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgaWYgKHNjb3BlLiRsYXN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBOZWVkIGEgdGltZW91dCB0byBsZWF2ZSB0aW1lIHRvIHRoZSB2aWV3IHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFZpZXcgPSAkaW9uaWNTY3JvbGxEZWxlZ2F0ZS4kZ2V0QnlIYW5kbGUoJ21tYUNoYXRTY3JvbGwnKTtcbiAgICAgICAgICAgICAgICBzY3JvbGxWaWV3LnNjcm9sbEJvdHRvbSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gU2V0IHVwIHRoZSBwb2xsaW5nIG9uIGEgdmlldyBlbnRlciwgdGhpcyBhbGxvd3MgZm9yIHRoZSB1c2VyIHRvIGdvIGJhY2sgYW5kIHJlc3VtZSB0aGUgcG9sbGluZy5cbiAgICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmVudGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFN0cmFuZ2UgY2FzZSwgd2UgYWxyZWFkeSBoYXZlIHRoZSBwb2xsaW5nIGluIHBsYWNlLlxuICAgICAgICBpZiAocG9sbGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgcG9sbGluZy5cbiAgICAgICAgcG9sbGluZyA9ICRpbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1BvbGxpbmcgZm9yIG1lc3NhZ2VzJyk7XG4gICAgICAgICAgICBpZiAoISRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gT2J2aW91c2x5IHdlIGNhbm5vdCBjaGVjayBmb3IgbmV3IG1lc3NhZ2VzIHdoZW4gdGhlIGFwcCBpcyBvZmZsaW5lLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJG1tYU1vZENoYXQuZ2V0TGF0ZXN0TWVzc2FnZXMoJHNjb3BlLmNoYXRzaWQsIGNoYXRMYXN0VGltZSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgY2hhdExhc3RUaW1lID0gZGF0YS5jaGF0bmV3bGFzdHRpbWU7XG4gICAgICAgICAgICAgICAgJG1tYU1vZENoYXQuZ2V0TWVzc2FnZXNVc2VyRGF0YShkYXRhLm1lc3NhZ2VzLCBjb3Vyc2VJZCkudGhlbihmdW5jdGlvbihtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUubWVzc2FnZXMgPSAkc2NvcGUubWVzc2FnZXMuY29uY2F0KG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbChwb2xsaW5nKTtcbiAgICAgICAgICAgICAgICBzaG93RXJyb3IoZXJyb3IsICdtbWEubW9kX2NoYXQuZXJyb3J3aGlsZXJldHJpZXZpbmdtZXNzYWdlcycpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgbW1hQ2hhdFBvbGxJbnRlcnZhbCk7XG4gICAgfSk7XG5cbiAgICAvLyBSZW1vdmluZyB0aGUgcG9sbGluZyBhcyB3ZSBsZWF2ZSB0aGUgcGFnZS5cbiAgICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmxlYXZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAocG9sbGluZykge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ2FuY2VsbGluZyBwb2xsaW5nIGZvciBjb252ZXJzYXRpb24nKTtcbiAgICAgICAgICAgICRpbnRlcnZhbC5jYW5jZWwocG9sbGluZyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfY2hhdCcpXG5cbi8qKlxuICogQ2hhdCBpbmRleCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaGF0XG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kQ2hhdEluZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kQ2hhdEluZGV4Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1hTW9kQ2hhdCwgJG1tVXRpbCwgJHEsICRtbUNvdXJzZSkge1xuICAgIHZhciBtb2R1bGUgPSAkc3RhdGVQYXJhbXMubW9kdWxlIHx8IHt9LFxuICAgICAgICBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZCxcbiAgICAgICAgY2hhdDtcblxuICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAkc2NvcGUubW9kdWxldXJsID0gbW9kdWxlLnVybDtcbiAgICAkc2NvcGUuY291cnNlaWQgPSBjb3Vyc2VpZDtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBjaGF0IGRhdGEuXG4gICAgZnVuY3Rpb24gZmV0Y2hDaGF0RGF0YShyZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kQ2hhdC5nZXRDaGF0KGNvdXJzZWlkLCBtb2R1bGUuaWQsIHJlZnJlc2gpLnRoZW4oZnVuY3Rpb24oY2hhdGRhdGEpIHtcbiAgICAgICAgICAgIGNoYXQgPSBjaGF0ZGF0YTtcbiAgICAgICAgICAgICRzY29wZS50aXRsZSA9IGNoYXQubmFtZSB8fCAkc2NvcGUudGl0bGU7XG4gICAgICAgICAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBjaGF0LmludHJvIHx8wqAkc2NvcGUuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAkc2NvcGUuY2hhdElkID0gY2hhdC5pZDtcbiAgICAgICAgICAgICRzY29wZS5jaGF0U2NoZWR1bGVkID0gJyc7XG5cbiAgICAgICAgICAgIHZhciBub3cgPSAkbW1VdGlsLnRpbWVzdGFtcCgpO1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBjaGF0LmNoYXR0aW1lIC0gbm93O1xuXG4gICAgICAgICAgICBpZiAoY2hhdC5jaGF0dGltZSAmJiBjaGF0LnNjaGVkdWxlID4gMCAmJiBzcGFuID4gMCkge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuZm9ybWF0VGltZShzcGFuKS50aGVuKGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNoYXRTY2hlZHVsZWQgPSB0aW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIXJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgY2hhdCBmYWlsZWQsIHJldHJ5IHdpdGhvdXQgdXNpbmcgY2FjaGUgc2luY2UgaXQgbWlnaHQgYmUgYSBuZXcgYWN0aXZpdHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoQ2hhdERhdGEodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2NoYXQuZXJyb3J3aGlsZWdldHRpbmdjaGF0ZGF0YScsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmZXRjaENoYXREYXRhKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYU1vZENoYXQubG9nVmlldyhjaGF0LmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuY2hhdExvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBQdWxsIHRvIHJlZnJlc2guXG4gICAgJHNjb3BlLnJlZnJlc2hDaGF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZldGNoQ2hhdERhdGEodHJ1ZSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59KTsiLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfY2hhdCcpXG5cbi8qKlxuICogQ2hhdCBzZXJ2aWNlLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaGF0XG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZENoYXRcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RDaGF0JywgZnVuY3Rpb24oJHEsICRtbVNpdGUsICRtbVVzZXIsICRtbVNpdGVzTWFuYWdlcikge1xuICAgIHZhciBzZWxmID0ge307XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGlzIGVuYWJsZWQgaW4gYSBjZXJ0YWluIHNpdGUuIFBsdWdpbiBpcyBlbmFibGVkIGlmIHRoZSBjaGF0IFdTIGFyZSBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hhdFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hhdCNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2NoYXRfZ2V0X2NoYXRzX2J5X2NvdXJzZXMnKSAmJlxuICAgICAgICAgICAgICAgICAgICBzaXRlLndzQXZhaWxhYmxlKCdtb2RfY2hhdF9sb2dpbl91c2VyJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2NoYXRfZ2V0X2NoYXRfdXNlcnMnKSAmJlxuICAgICAgICAgICAgICAgICAgICBzaXRlLndzQXZhaWxhYmxlKCdtb2RfY2hhdF9zZW5kX2NoYXRfbWVzc2FnZScpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9jaGF0X2dldF9jaGF0X2xhdGVzdF9tZXNzYWdlcycpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgY2hhdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaGF0XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaGF0I2dldENoYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbWlkICAgICBDb3Vyc2UgbW9kdWxlIElELlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlZnJlc2hdIFRydWUgd2hlbiB3ZSBzaG91bGQgbm90IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY2hhdCBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRDaGF0ID0gZnVuY3Rpb24oY291cnNlaWQsIGNtaWQsIHJlZnJlc2gpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNvdXJzZWlkczogW2NvdXJzZWlkXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7fTtcblxuICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgcHJlU2V0cy5nZXRGcm9tQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9jaGF0X2dldF9jaGF0c19ieV9jb3Vyc2VzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuY2hhdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENoYXQ7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc3BvbnNlLmNoYXRzLCBmdW5jdGlvbihjaGF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGF0LmNvdXJzZW1vZHVsZSA9PSBjbWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhdCA9IGNoYXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDaGF0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGNoYXQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hhdFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hhdCNsb2dpblVzZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhdElkICAgQ2hhdCBpbnN0YW5jZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBpcyBleGVjdXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ2luVXNlciA9IGZ1bmN0aW9uKGNoYXRJZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgY2hhdGlkOiBjaGF0SWRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2NoYXRfbG9naW5fdXNlcicsIHBhcmFtcykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmNoYXRzaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuY2hhdHNpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCBhIGNoYXQgYXMgYmVpbmcgdmlld2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2NoYXRcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENoYXQjbG9nVmlld1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBNb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgY2FsbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHNlbGYubG9nVmlldyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjaGF0aWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9jaGF0X3ZpZXdfY2hhdCcsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byBhIGNoYXQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hhdFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hhdCNzZW5kTWVzc2FnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGF0c2lkICBDaGF0IHNlc3Npb25kIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlICBNZXNzYWdlIHRleHQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJlZXAgICAgIEJlZXAgdXNlciBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBpcyBleGVjdXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24oY2hhdHNpZCwgbWVzc2FnZSwgYmVlcCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgY2hhdHNpZDogY2hhdHNpZCxcbiAgICAgICAgICAgIG1lc3NhZ2V0ZXh0OiBtZXNzYWdlLFxuICAgICAgICAgICAgYmVlcGlkOiBiZWVwXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9jaGF0X3NlbmRfY2hhdF9tZXNzYWdlJywgcGFyYW1zKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubWVzc2FnZWlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1lc3NhZ2VpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGF0ZXN0IG1lc3NhZ2VzIGZyb20gYSBjaGF0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2NoYXRcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENoYXQjZ2V0TGF0ZXN0TWVzc2FnZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhdHNpZCAgQ2hhdCBzZXNzaW9uZCBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGFzdHRpbWUgTGFzdCB0aW1lIHdoZW4gbWVzc2FnZXMgd2VyZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgaXMgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRMYXRlc3RNZXNzYWdlcyA9IGZ1bmN0aW9uKGNoYXRzaWQsIGxhc3R0aW1lKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBjaGF0c2lkOiBjaGF0c2lkLFxuICAgICAgICAgICAgY2hhdGxhc3R0aW1lOiBsYXN0dGltZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgIGdldEZyb21DYWNoZTogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfY2hhdF9nZXRfY2hhdF9sYXRlc3RfbWVzc2FnZXMnLCBwYXJhbXMsIHByZVNldHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBkYXRhIGZvciBtZXNzYWdlcyBzaW5jZSB0aGV5IG9ubHkgaGF2ZSB1c2VyaWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tZXNzYWdlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hhdCNnZXRNZXNzYWdlc1VzZXJEYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gbWVzc2FnZXMgICAgTWVzc2FnZXMgdG8gZ2V0IHRoZSBkYXRhIGZvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBjb3Vyc2VpZCAgICBJRCBvZiB0aGUgY291cnNlIHRoZSBtZXNzYWdlcyBiZWxvbmcgdG8uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgUHJvbWlzZSBhbHdheXMgcmVzb2x2ZWQuIFJlc29sdmUgcGFyYW0gaXMgdGhlIGZvcm1hdHRlZCBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldE1lc3NhZ2VzVXNlckRhdGEgPSBmdW5jdGlvbihtZXNzYWdlcywgY291cnNlaWQpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1lc3NhZ2VzLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICRtbVVzZXIuZ2V0UHJvZmlsZShtZXNzYWdlLnVzZXJpZCwgY291cnNlaWQsIHRydWUpLnRoZW4oZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcmZ1bGxuYW1lID0gdXNlci5mdWxsbmFtZTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJwcm9maWxlaW1hZ2V1cmwgPSB1c2VyLnByb2ZpbGVpbWFnZXVybDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIGdldHRpbmcgcHJvZmlsZS4gU2V0IGRlZmF1bHQgZGF0YS5cbiAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJmdWxsbmFtZSA9IG1lc3NhZ2UudXNlcmlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYWN0aXZlcyB1c2VycyBvZiBhIGN1cnJlbnQgY2hhdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaGF0XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaGF0I2dldENoYXRVc2Vyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGF0c2lkICBDaGF0IHNlc3Npb25kIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGlzIGV4ZWN1dGVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Q2hhdFVzZXJzID0gZnVuY3Rpb24oY2hhdHNpZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgY2hhdHNpZDogY2hhdHNpZFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgIGdldEZyb21DYWNoZTogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfY2hhdF9nZXRfY2hhdF91c2VycycsIHBhcmFtcywgcHJlU2V0cyk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7IiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2NoYXQnKVxuXG4vKipcbiAqIE1vZCBjaGF0IGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaGF0XG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZENoYXRIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZENoYXRIYW5kbGVycycsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tYU1vZENoYXQsICRzdGF0ZSwgJG1tQ29udGVudExpbmtzSGVscGVyLCAkcSkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2NoYXRcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENoYXRIYW5kbGVycyNjb3Vyc2VDb250ZW50XG4gICAgICovXG4gICAgc2VsZi5jb3Vyc2VDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RDaGF0LmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBpbmZvLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYygnY2hhdCcpO1xuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2RfY2hhdCcsIHttb2R1bGU6IG1vZHVsZSwgY291cnNlaWQ6IGNvdXJzZWlkfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaGF0XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaGF0SGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRW5hYmxlZChzaXRlSWQsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZENoYXQuaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhY3Rpb25zIHRvIHBlcmZvcm0gd2l0aCB0aGUgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhIGNoYXQgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL2NoYXQvdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7IiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2Nob2ljZScpXG5cbi8qKlxuICogQ2hvaWNlIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZENob2ljZUluZGV4Q3RybFxuICogQHRvZG8gRGVsZXRlIGFuc3dlciBpZiB1c2VyIGNhbiB1cGRhdGUgdGhlIGFuc3dlciwgc2hvdyBzZWxlY3RlZCBpZiBjaG9pY2UgaXMgY2xvc2VkIChXUyByZXR1cm5zIGVtcHR5IG9wdGlvbnMpLlxuICovXG4uY29udHJvbGxlcignbW1hTW9kQ2hvaWNlSW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkdGltZW91dCwgJHN0YXRlUGFyYW1zLCAkbW1hTW9kQ2hvaWNlLCAkbW1VdGlsLCAkcSwgJG1tQ291cnNlLCAkdHJhbnNsYXRlKSB7XG4gICAgdmFyIG1vZHVsZSA9ICRzdGF0ZVBhcmFtcy5tb2R1bGUgfHwge30sXG4gICAgICAgIGNvdXJzZWlkID0gJHN0YXRlUGFyYW1zLmNvdXJzZWlkLFxuICAgICAgICBjaG9pY2UsXG4gICAgICAgIGhhc0Fuc3dlcmVkID0gZmFsc2U7XG5cbiAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBtb2R1bGUuZGVzY3JpcHRpb247XG4gICAgJHNjb3BlLm1vZHVsZXVybCA9IG1vZHVsZS51cmw7XG4gICAgJHNjb3BlLmNvdXJzZWlkID0gY291cnNlaWQ7XG5cbiAgICAkc2NvcGUuZDNfb3B0aW9ucyA9IHtcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkaXNjcmV0ZUJhckNoYXJ0JyxcbiAgICAgICAgICAgIHg6IGZ1bmN0aW9uKGQpeyByZXR1cm4gZC5sYWJlbDsgfSxcbiAgICAgICAgICAgIHk6IGZ1bmN0aW9uKGQpeyByZXR1cm4gZC52YWx1ZTsgfSxcbiAgICAgICAgICAgIHNob3dWYWx1ZXM6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDogZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQzLmZvcm1hdCgnJykoZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgICB4QXhpczoge30sXG4gICAgICAgICAgICB5QXhpczoge1xuICAgICAgICAgICAgICAgIHRpY2tGb3JtYXQ6IGZ1bmN0aW9uKGQpeyByZXR1cm4gZDMuZm9ybWF0KCcsZicpKGQpIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBodHRwczovL252ZDMtY29tbXVuaXR5LmdpdGh1Yi5pby9udmQzL2V4YW1wbGVzL2RvY3VtZW50YXRpb24uaHRtbCN0b29sdGlwXG4gICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgY29udGVudEdlbmVyYXRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkMy5mb3JtYXQoJy4xJScpKG9iai5kYXRhLnBlcmNlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20va3Jpc3BvL2FuZ3VsYXItbnZkMy9pc3N1ZXMvMzZcbiAgICAgICAgICAgIGRpc2NyZXRlYmFyOiB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2g6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyRW5kOiBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbChcIi50aWNrIHRleHRcIikuY2FsbCh3cmFwLF9jaGFydC54QXhpcy5yYW5nZUJhbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihjaGFydCl7XG4gICAgICAgICAgICAgICAgX2NoYXJ0ID0gY2hhcnQ7IC8vZ2xvYmFsIHZhclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJlLXdyYXAgeC1heGlzIGxhYmVscyBhZnRlciAoc3dpcGUgZG93bikgcmVmcmVzaFxuICAgICRzY29wZS5kM19ldmVudHMgPSB7XG4gICAgICAgICdzY3JvbGwucmVmcmVzaENvbXBsZXRlJzogZnVuY3Rpb24oZSwgc2NvcGUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBtaXJreSBkZXB0aHMgb2YgQW5ndWxhciByZXF1aXJlIHdyYXBwaW5nIHRoaXMgZXZlbnQgaGFuZGxlciBpbiAkdGltZW91dCgpXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHRleHQgd3JhcHBpbmcgdG8gcGVyc2lzdCBpbiB0aGUgRE9NLlxuICAgICAgICAgICAgLy8gZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2tyaXNwby9hbmd1bGFyLW52ZDMvaXNzdWVzLzM2XG4gICAgICAgICAgICAvLyBiYWNrZ3JvdW5kOiBodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9lcnJvci8kcm9vdFNjb3BlL2lucHJvZ1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7ZDMuc2VsZWN0QWxsKFwiLnRpY2sgdGV4dFwiKS5jYWxsKHdyYXAsX2NoYXJ0LnhBeGlzLnJhbmdlQmFuZCgpKTt9LCAwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBodHRwOi8vYmwub2Nrcy5vcmcvbWJvc3RvY2svNzU1NTMyMVxuICAgIGZ1bmN0aW9uIHdyYXAodGV4dCwgd2lkdGgpIHtcbiAgICAgIHRleHQuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRleHQgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICB3b3JkcyA9IHRleHQudGV4dCgpLnNwbGl0KC9cXHMrLykucmV2ZXJzZSgpLFxuICAgICAgICAgICAgd29yZCxcbiAgICAgICAgICAgIGxpbmUgPSBbXSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSAwLFxuICAgICAgICAgICAgbGluZUhlaWdodCA9IDEuMSwgLy8gZW1zXG4gICAgICAgICAgICB5ID0gdGV4dC5hdHRyKFwieVwiKSxcbiAgICAgICAgICAgIGR5ID0gcGFyc2VGbG9hdCh0ZXh0LmF0dHIoXCJkeVwiKSksXG4gICAgICAgICAgICB0c3BhbiA9IHRleHQudGV4dChudWxsKS5hcHBlbmQoXCJ0c3BhblwiKS5hdHRyKFwieFwiLCAwKS5hdHRyKFwieVwiLCB5KS5hdHRyKFwiZHlcIiwgZHkgKyBcImVtXCIpO1xuICAgICAgICB3aGlsZSAod29yZCA9IHdvcmRzLnBvcCgpKSB7XG4gICAgICAgICAgbGluZS5wdXNoKHdvcmQpO1xuICAgICAgICAgIHRzcGFuLnRleHQobGluZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgaWYgKHRzcGFuLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSA+IHdpZHRoKSB7XG4gICAgICAgICAgICBsaW5lLnBvcCgpO1xuICAgICAgICAgICAgdHNwYW4udGV4dChsaW5lLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgIGxpbmUgPSBbd29yZF07XG4gICAgICAgICAgICB0c3BhbiA9IHRleHQuYXBwZW5kKFwidHNwYW5cIikuYXR0cihcInhcIiwgMCkuYXR0cihcInlcIiwgeSkuYXR0cihcImR5XCIsICsrbGluZU51bWJlciAqIGxpbmVIZWlnaHQgKyBkeSArIFwiZW1cIikudGV4dCh3b3JkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBjaG9pY2UgZGF0YS5cbiAgICBmdW5jdGlvbiBmZXRjaENob2ljZURhdGEocmVmcmVzaCkge1xuICAgICAgICAkc2NvcGUubm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHJldHVybiAkbW1hTW9kQ2hvaWNlLmdldENob2ljZShjb3Vyc2VpZCwgbW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKGNob2ljZWRhdGEpIHtcbiAgICAgICAgICAgIGNob2ljZSA9IGNob2ljZWRhdGE7XG4gICAgICAgICAgICBjaG9pY2UudGltZW9wZW4gPSBwYXJzZUludChjaG9pY2UudGltZW9wZW4pICogMTAwMDtcbiAgICAgICAgICAgIGNob2ljZS5vcGVuVGltZVJlYWRhYmxlID0gbW9tZW50KGNob2ljZS50aW1lb3BlbikuZm9ybWF0KCdMTEwnKTtcbiAgICAgICAgICAgIGNob2ljZS50aW1lY2xvc2UgPSBwYXJzZUludChjaG9pY2UudGltZWNsb3NlKSAqIDEwMDA7XG4gICAgICAgICAgICBjaG9pY2UuY2xvc2VUaW1lUmVhZGFibGUgPSBtb21lbnQoY2hvaWNlLnRpbWVjbG9zZSkuZm9ybWF0KCdMTEwnKTtcblxuICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gY2hvaWNlLm5hbWUgfHwgJHNjb3BlLnRpdGxlO1xuICAgICAgICAgICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gY2hvaWNlLmludHJvIHx8wqAkc2NvcGUuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAkc2NvcGUuY2hvaWNlID0gY2hvaWNlO1xuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIGZldGNoT3B0aW9ucyB0byBmaW5pc2ggYmVmb3JlIGNhbGxpbmcgZmV0Y2hSZXN1bHRzIGJlY2F1c2UgaXQgbmVlZHMgaGFzQW5zd2VyZWQgdmFyaWFibGUuXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hPcHRpb25zKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hSZXN1bHRzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKCFyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZSBjYWxsIGZhaWxlZCwgcmV0cnkgd2l0aG91dCB1c2luZyBjYWNoZSBzaW5jZSBpdCBtaWdodCBiZSBhIG5ldyBhY3Rpdml0eS5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmcmVzaEFsbERhdGEoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2Nob2ljZS5lcnJvcmdldGNob2ljZScsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgY2hvaWNlIG9wdGlvbnMuXG4gICAgZnVuY3Rpb24gZmV0Y2hPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZENob2ljZS5nZXRPcHRpb25zKGNob2ljZS5pZCkudGhlbihmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgaXNPcGVuID0gaXNDaG9pY2VPcGVuKCk7XG4gICAgICAgICAgICBoYXNBbnN3ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgJHNjb3BlLnNlbGVjdGVkT3B0aW9uID0ge2lkOiAtMX07IC8vIFNpbmdsZSBjaG9pY2UgbW9kZWwuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gob3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Fuc3dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaG9pY2UuYWxsb3dtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdGVkT3B0aW9uLmlkID0gb3B0aW9uLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuY2FuRWRpdCA9IGlzT3BlbiAmJiAoY2hvaWNlLmFsbG93dXBkYXRlIHx8wqAhaGFzQW5zd2VyZWQpO1xuICAgICAgICAgICAgJHNjb3BlLmNhbkRlbGV0ZSA9ICRtbWFNb2RDaG9pY2UuaXNEZWxldGVSZXNwb25zZXNFbmFibGVkKCkgJiYgaXNPcGVuICYmIGNob2ljZS5hbGxvd3VwZGF0ZSAmJiBoYXNBbnN3ZXJlZDtcbiAgICAgICAgICAgICRzY29wZS5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IGNob2ljZSByZXN1bHRzLlxuICAgIGZ1bmN0aW9uIGZldGNoUmVzdWx0cygpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RDaG9pY2UuZ2V0UmVzdWx0cyhjaG9pY2UuaWQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIGhhc1ZvdGVzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZGF0YSAgICAgPSBbXTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXN1bHRzLCBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm51bWJlcm9mdXNlciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVm90ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucGVyY2VudGFnZWFtb3VudCA9IHBhcnNlRmxvYXQocmVzdWx0LnBlcmNlbnRhZ2VhbW91bnQpLnRvRml4ZWQoMSk7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgJ2xhYmVsJzogcmVzdWx0LnRleHQsXG4gICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHJlc3VsdC5udW1iZXJvZnVzZXIsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50JzogcmVzdWx0LnBlcmNlbnRhZ2VhbW91bnQgLyAxMDAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5jYW5TZWVSZXN1bHRzID0gaGFzVm90ZXMgfHwgJG1tYU1vZENob2ljZS5jYW5TdHVkZW50U2VlUmVzdWx0cyhjaG9pY2UsIGhhc0Fuc3dlcmVkKTtcbiAgICAgICAgICAgICRzY29wZS5yZXN1bHRzID0gcmVzdWx0cztcbiAgICAgICAgICAgICRzY29wZS5kYXRhID0gW3tcbiAgICAgICAgICAgICAgICAvL2tleTogXCJTb21lIGtleSB0byB0aGUgZGF0YT9cIixcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGNob2ljZSBpcyBvcGVuLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBjaG9pY2UgaXMgb3BlbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQ2hvaWNlT3BlbigpIHtcbiAgICAgICAgcmV0dXJuIChjaG9pY2UudGltZW9wZW4gPT09IDAgfHwgY2hvaWNlLnRpbWVvcGVuIDw9ICRzY29wZS5ub3cpICYmXG4gICAgICAgICAgICAgICAgKGNob2ljZS50aW1lY2xvc2UgPT09IDAgfHzCoGNob2ljZS50aW1lY2xvc2UgPiAkc2NvcGUubm93KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byByZWZyZXNoIGFsbCB0aGUgZGF0YS5cbiAgICBmdW5jdGlvbiByZWZyZXNoQWxsRGF0YSgpIHtcbiAgICAgICAgdmFyIHAxID0gJG1tYU1vZENob2ljZS5pbnZhbGlkYXRlQ2hvaWNlRGF0YShjb3Vyc2VpZCksXG4gICAgICAgICAgICBwMiA9IGNob2ljZSA/ICRtbWFNb2RDaG9pY2UuaW52YWxpZGF0ZU9wdGlvbnMoY2hvaWNlLmlkKSA6ICRxLndoZW4oKSxcbiAgICAgICAgICAgIHAzID0gY2hvaWNlID8gJG1tYU1vZENob2ljZS5pbnZhbGlkYXRlUmVzdWx0cyhjaG9pY2UuaWQpIDogJHEud2hlbigpO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwoW3AxLCBwMiwgcDNdKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoQ2hvaWNlRGF0YSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmV0Y2hDaG9pY2VEYXRhKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYU1vZENob2ljZS5sb2dWaWV3KGNob2ljZS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbUNvdXJzZS5jaGVja01vZHVsZUNvbXBsZXRpb24oY291cnNlaWQsIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmNob2ljZUxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBTYXZlIG9wdGlvbnMgc2VsZWN0ZWQuXG4gICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gT25seSBzaG93IGNvbmZpcm0gaWYgY2hvaWNlIGRvZXNuJ3QgYWxsb3cgdXBkYXRlLlxuICAgICAgICB2YXIgcHJvbWlzZSA9IGNob2ljZS5hbGxvd3VwZGF0ZSA/ICRxLndoZW4oKSA6ICRtbVV0aWwuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSgnbW0uY29yZS5hcmV5b3VzdXJlJykpO1xuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VzID0gW107XG4gICAgICAgICAgICBpZiAoY2hvaWNlLmFsbG93bXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLm9wdGlvbnMsIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlcy5wdXNoKG9wdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VzLnB1c2goJHNjb3BlLnNlbGVjdGVkT3B0aW9uLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbS5jb3JlLnNlbmRpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICRtbWFNb2RDaG9pY2Uuc3VibWl0UmVzcG9uc2UoY2hvaWNlLmlkLCByZXNwb25zZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2VzcyEgTGV0J3MgcmVmcmVzaCB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmcmVzaEFsbERhdGEoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfY2hvaWNlLmNhbm5vdHN1Ym1pdCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBEZWxldGUgb3B0aW9ucyBzZWxlY3RlZC5cbiAgICAkc2NvcGUuZGVsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbVV0aWwuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSgnbW0uY29yZS5hcmV5b3VzdXJlJykpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tLmNvcmUuc2VuZGluZycsIHRydWUpO1xuICAgICAgICAgICAgJG1tYU1vZENob2ljZS5kZWxldGVSZXNwb25zZXMoY2hvaWNlLmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MhIExldCdzIHJlZnJlc2ggdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZnJlc2hBbGxEYXRhKCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2Nob2ljZS5jYW5ub3RzdWJtaXQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gUHVsbCB0byByZWZyZXNoLlxuICAgICRzY29wZS5yZWZyZXNoQ2hvaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZnJlc2hBbGxEYXRhKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9jaG9pY2UnKVxuXG4vKipcbiAqIENob2ljZSBzZXJ2aWNlLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaG9pY2VcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kQ2hvaWNlXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kQ2hvaWNlJywgZnVuY3Rpb24oJHEsICRtbVNpdGUsICRtbVNpdGVzTWFuYWdlciwgbW1hTW9kQ2hvaWNlUmVzdWx0c0FmdGVyQW5zd2VyLCBtbWFNb2RDaG9pY2VSZXN1bHRzQWZ0ZXJDbG9zZSxcbiAgICAgICAgICAgIG1tYU1vZENob2ljZVJlc3VsdHNBbHdheXMpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgcmVzdWx0cyBjYW4gYmUgc2VlbiBieSBhIHN0dWRlbnQuIFRoZSBzdHVkZW50IGNhbiBzZWUgdGhlIHJlc3VsdHMgaWY6XG4gICAgICogICAgIC0gdGhleSdyZSBhbHdheXMgcHVibGlzaGVkLCBPUlxuICAgICAqICAgICAtIHRoZXkncmUgcHVibGlzaGVkIGFmdGVyIHRoZSBjaG9pY2UgaXMgY2xvc2VkIGFuZCBpdCdzIGNsb3NlZCwgT1JcbiAgICAgKiAgICAgLSB0aGV5J3JlIHB1Ymxpc2hlZCBhZnRlciBhbnN3ZXJpbmcgYW5kIHRoZSB1c2VyIGhhcyBhbnN3ZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgY2hvaWNlICAgICAgQ2hvaWNlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFzQW5zd2VyZWQgVHJ1ZSBpZiB1c2VyIGhhcyBhbnN3ZXJlZCB0aGUgY2hvaWNlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHNlbGYuY2FuU3R1ZGVudFNlZVJlc3VsdHMgPSBmdW5jdGlvbihjaG9pY2UsIGhhc0Fuc3dlcmVkKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuICBjaG9pY2Uuc2hvd3Jlc3VsdHMgPT09IG1tYU1vZENob2ljZVJlc3VsdHNBbHdheXMgfHxcbiAgICAgICAgICAgICAgICBjaG9pY2Uuc2hvd3Jlc3VsdHMgPT09IG1tYU1vZENob2ljZVJlc3VsdHNBZnRlckNsb3NlICYmIGNob2ljZS50aW1lY2xvc2UgIT09IDAgJiYgY2hvaWNlLnRpbWVjbG9zZSA8PSBub3cgfHxcbiAgICAgICAgICAgICAgICBjaG9pY2Uuc2hvd3Jlc3VsdHMgPT09IG1tYU1vZENob2ljZVJlc3VsdHNBZnRlckFuc3dlciAmJiBoYXNBbnN3ZXJlZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHJlc3BvbnNlcyBmcm9tIGEgY2hvaWNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hvaWNlI2RlbGV0ZVJlc3BvbnNlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaG9pY2VpZCAgICAgIENob2ljZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbcmVzcG9uc2VzXSBJRHMgb2YgdGhlIGFuc3dlcnMuIElmIG5vdCBkZWZpbmVkLCBkZWxldGUgYWxsIHRoZSBhbnN3ZXJzIG9mIHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBvcHRpb25zIGFyZSBkZWxldGVkLlxuICAgICAqL1xuICAgIHNlbGYuZGVsZXRlUmVzcG9uc2VzID0gZnVuY3Rpb24oY2hvaWNlaWQsIHJlc3BvbnNlcykge1xuICAgICAgICByZXNwb25zZXMgPSByZXNwb25zZXMgfHwgW107XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBjaG9pY2VpZDogY2hvaWNlaWQsXG4gICAgICAgICAgICByZXNwb25zZXM6IHJlc3BvbnNlc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2Nob2ljZV9kZWxldGVfY2hvaWNlX3Jlc3BvbnNlcycsIHBhcmFtcykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fCByZXNwb25zZS5zdGF0dXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgY2hvaWNlIGRhdGEgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q2hvaWNlRGF0YUNhY2hlS2V5KGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kQ2hvaWNlOmNob2ljZTonICsgY291cnNlaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgY2hvaWNlIG9wdGlvbnMgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hvaWNlaWQgQ2hvaWNlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDaG9pY2VPcHRpb25zQ2FjaGVLZXkoY2hvaWNlaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RDaG9pY2U6b3B0aW9uczonICsgY2hvaWNlaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgY2hvaWNlIHJlc3VsdHMgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hvaWNlaWQgQ2hvaWNlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDaG9pY2VSZXN1bHRzQ2FjaGVLZXkoY2hvaWNlaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RDaG9pY2U6cmVzdWx0czonICsgY2hvaWNlaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBjdXJyZW50IHNpdGUgc3VwcG9ydHMgZGVsZXRpbmcgY2hvaWNlIHJlc3BvbnNlcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaG9pY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENob2ljZSNpc0RlbGV0ZVJlc3BvbnNlc0VuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHN1cHBvcnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNEZWxldGVSZXNwb25zZXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdtb2RfY2hvaWNlX2RlbGV0ZV9jaG9pY2VfcmVzcG9uc2VzJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGlzIGVuYWJsZWQgaW4gYSBjZXJ0YWluIHNpdGUuIFBsdWdpbiBpcyBlbmFibGVkIGlmIHRoZSBjaG9pY2UgV1MgYXJlIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaG9pY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENob2ljZSNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2Nob2ljZV9nZXRfY2hvaWNlX29wdGlvbnMnKSAmJlxuICAgICAgICAgICAgICAgICAgICBzaXRlLndzQXZhaWxhYmxlKCdtb2RfY2hvaWNlX2dldF9jaG9pY2VfcmVzdWx0cycpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9jaG9pY2VfZ2V0X2Nob2ljZXNfYnlfY291cnNlcycpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9jaG9pY2Vfc3VibWl0X2Nob2ljZV9yZXNwb25zZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgY2hvaWNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hvaWNlI2dldENob2ljZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNtaWQgICAgIENvdXJzZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgY2hvaWNlIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldENob2ljZSA9IGZ1bmN0aW9uKGNvdXJzZWlkLCBjbWlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY291cnNlaWRzOiBbY291cnNlaWRdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0Q2hvaWNlRGF0YUNhY2hlS2V5KGNvdXJzZWlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfY2hvaWNlX2dldF9jaG9pY2VzX2J5X2NvdXJzZXMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5jaG9pY2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaG9pY2U7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc3BvbnNlLmNob2ljZXMsIGZ1bmN0aW9uKGNob2ljZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hvaWNlLmNvdXJzZW1vZHVsZSA9PSBjbWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hvaWNlID0gY2hvaWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaG9pY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDaG9pY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgY2hvaWNlIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hvaWNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaG9pY2UjZ2V0T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaG9pY2VpZCBDaG9pY2UgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBjaG9pY2Ugb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZWxmLmdldE9wdGlvbnMgPSBmdW5jdGlvbihjaG9pY2VpZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNob2ljZWlkOiBjaG9pY2VpZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldENob2ljZU9wdGlvbnNDYWNoZUtleShjaG9pY2VpZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX2Nob2ljZV9nZXRfY2hvaWNlX29wdGlvbnMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBjaG9pY2UgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaG9pY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENob2ljZSNnZXRSZXN1bHRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNob2ljZWlkIENob2ljZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGNob2ljZSByZXN1bHRzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UmVzdWx0cyA9IGZ1bmN0aW9uKGNob2ljZWlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY2hvaWNlaWQ6IGNob2ljZWlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0Q2hvaWNlUmVzdWx0c0NhY2hlS2V5KGNob2ljZWlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfY2hvaWNlX2dldF9jaG9pY2VfcmVzdWx0cycsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uub3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIGNob2ljZSBkYXRhLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hvaWNlI2ludmFsaWRhdGVDaG9pY2VEYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUNob2ljZURhdGEgPSBmdW5jdGlvbihjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRDaG9pY2VEYXRhQ2FjaGVLZXkoY291cnNlaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaG9pY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENob2ljZSNpbnZhbGlkYXRlT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaG9pY2VpZCBDaG9pY2UgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24oY2hvaWNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0Q2hvaWNlT3B0aW9uc0NhY2hlS2V5KGNob2ljZWlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hvaWNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaG9pY2UjaW52YWxpZGF0ZVJlc3VsdHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hvaWNlaWQgQ2hvaWNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlUmVzdWx0cyA9IGZ1bmN0aW9uKGNob2ljZWlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldENob2ljZVJlc3VsdHNDYWNoZUtleShjaG9pY2VpZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgdGhlIGNob2ljZSBhcyBiZWluZyB2aWV3ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hvaWNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaG9pY2UjbG9nVmlld1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBDaG9pY2UgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgY2FsbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHNlbGYubG9nVmlldyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjaG9pY2VpZDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2Nob2ljZV92aWV3X2Nob2ljZScsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgcmVzcG9uc2UgdG8gYSBjaG9pY2UgdG8gTW9vZGxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kQ2hvaWNlI3N1Ym1pdFJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNob2ljZWlkICAgIENob2ljZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSByZXNwb25zZXMgSURzIG9mIHNlbGVjdGVkIG9wdGlvbnMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiByZXN1bHRzIGFyZSBzdWNjZXNzZnVsbHkgc3VibWl0dGVkLlxuICAgICAqL1xuICAgIHNlbGYuc3VibWl0UmVzcG9uc2UgPSBmdW5jdGlvbihjaG9pY2VpZCwgcmVzcG9uc2VzKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBjaG9pY2VpZDogY2hvaWNlaWQsXG4gICAgICAgICAgICByZXNwb25zZXM6IHJlc3BvbnNlc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2Nob2ljZV9zdWJtaXRfY2hvaWNlX3Jlc3BvbnNlJywgcGFyYW1zKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9jaG9pY2UnKVxuXG4vKipcbiAqIE1vZCBjaG9pY2UgaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2Nob2ljZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RDaG9pY2VIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZENob2ljZUhhbmRsZXJzJywgZnVuY3Rpb24oJG1tQ291cnNlLCAkbW1hTW9kQ2hvaWNlLCAkc3RhdGUsICRtbUNvbnRlbnRMaW5rc0hlbHBlciwgJHEpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9jaG9pY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZENob2ljZUhhbmRsZXJzI2NvdXJzZUNvbnRlbnRcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kQ2hvaWNlLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBpbmZvLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYygnY2hvaWNlJyk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1vZF9jaG9pY2UnLCB7bW9kdWxlOiBtb2R1bGUsIGNvdXJzZWlkOiBjb3Vyc2VpZH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfY2hvaWNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RDaG9pY2VIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kQ2hvaWNlLmlzUGx1Z2luRW5hYmxlZChzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb3Vyc2VJZCB8fCAkbW1Db3Vyc2UuY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkKHNpdGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSBjaG9pY2UgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL2Nob2ljZS92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9mb2xkZXInKVxuXG4vKipcbiAqIEZvbGRlciBpbmRleCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb2xkZXJcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RGb2xkZXJJbmRleEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZEZvbGRlckluZGV4Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1hTW9kRm9sZGVyLCAkbW1Db3Vyc2UsICRtbVV0aWwsICRxKSB7XG4gICAgdmFyIG1vZHVsZSA9ICRzdGF0ZVBhcmFtcy5tb2R1bGUgfHwge30sXG4gICAgICAgIGNvdXJzZWlkID0gJHN0YXRlUGFyYW1zLmNvdXJzZWlkLFxuICAgICAgICBzZWN0aW9uaWQgPSAkc3RhdGVQYXJhbXMuc2VjdGlvbmlkLFxuICAgICAgICBwYXRoID0gJHN0YXRlUGFyYW1zLnBhdGg7XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzZXQgc2NvcGUgZGF0YSB1c2luZyBtb2R1bGUuXG4gICAgZnVuY3Rpb24gc2hvd01vZHVsZURhdGEobW9kdWxlKSB7XG4gICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBtb2R1bGUuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAvLyBTdWJmb2xkZXIuXG4gICAgICAgICAgICAkc2NvcGUuY29udGVudHMgPSBtb2R1bGUuY29udGVudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUuY29udGVudHMgPSAkbW1hTW9kRm9sZGVyLmZvcm1hdENvbnRlbnRzKG1vZHVsZS5jb250ZW50cyk7XG4gICAgICAgICAgICAkc2NvcGUubW9kdWxldXJsID0gbW9kdWxlLnVybDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGZldGNoIGZvbGRlciBkYXRhIGZyb20gTW9vZGxlLlxuICAgIGZ1bmN0aW9uIGZldGNoRm9sZGVyKCkge1xuICAgICAgICByZXR1cm4gJG1tQ291cnNlLmdldE1vZHVsZShtb2R1bGUuaWQsIGNvdXJzZWlkLCBzZWN0aW9uaWQpLnRoZW4oZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICBzaG93TW9kdWxlRGF0YShtb2R1bGUpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfZm9sZGVyLmVycm9yd2hpbGVnZXR0aW5nZm9sZGVyJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghJHNjb3BlLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gRXJyb3IgZ2V0dGluZyBkYXRhIGZyb20gc2VydmVyLiBVc2UgbW9kdWxlIHBhcmFtLlxuICAgICAgICAgICAgICAgIHNob3dNb2R1bGVEYXRhKG1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXRoKSB7XG4gICAgICAgIC8vIFN1YmZvbGRlci4gVXNlIG1vZHVsZSBwYXJhbS5cbiAgICAgICAgc2hvd01vZHVsZURhdGEobW9kdWxlKTtcbiAgICAgICAgJHNjb3BlLmZvbGRlckxvYWRlZCA9IHRydWU7XG4gICAgICAgICRzY29wZS5jYW5SZWxvYWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaEZvbGRlcigpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1hTW9kRm9sZGVyLmxvZ1ZpZXcobW9kdWxlLmluc3RhbmNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRtbUNvdXJzZS5jaGVja01vZHVsZUNvbXBsZXRpb24oY291cnNlaWQsIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmZvbGRlckxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAkc2NvcGUuY2FuUmVsb2FkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgJHNjb3BlLnJlZnJlc2hGb2xkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tQ291cnNlLmludmFsaWRhdGVNb2R1bGUobW9kdWxlLmlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZmV0Y2hGb2xkZXIoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2ZvbGRlcicpXG5cbi8qKlxuICogRm9sZGVyIHNlcnZpY2UuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RGb2xkZXJcbiAqIEB0b2RvIEFkZGluZyBhIG5ldyBmaWxlIGluIGEgZm9sZGVyIHVwZGF0ZXMgdGhlIHJldmlzaW9uIG9mIGFsbCB0aGUgZmlsZXMsIHNvIHRoZXkncmUgYWxsIHNob3duIGFzIG91dGRhdGVkLlxuICogICAgICAgVG8gaWdub3JlIHJldmlzaW9uIGluIGZvbGRlcnMgd2UnbGwgaGF2ZSB0byBtb2RpZnkgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSwgbW0tZmlsZSBhbmQgJG1tRmlsZXBvb2wuXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kRm9sZGVyJywgZnVuY3Rpb24oJG1tU2l0ZSwgJG1tQ291cnNlLCAkcSwgJG1tRmlsZXBvb2wsIG1tYU1vZEZvbGRlckNvbXBvbmVudCkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbGwgdGhlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb2xkZXIjZG93bmxvYWRBbGxDb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgY29udGVudCBpcyBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLmRvd25sb2FkQWxsQ29udGVudCA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBzZWxmLmdldERvd25sb2FkYWJsZUZpbGVzKG1vZHVsZSksXG4gICAgICAgICAgICByZXZpc2lvbiA9ICRtbUZpbGVwb29sLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyksXG4gICAgICAgICAgICB0aW1lbW9kID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyk7XG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5kb3dubG9hZFBhY2thZ2UoJG1tU2l0ZS5nZXRJZCgpLCBmaWxlcywgbW1hTW9kRm9sZGVyQ29tcG9uZW50LCBtb2R1bGUuaWQsIHJldmlzaW9uLCB0aW1lbW9kKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGZvbGRlciBjb250ZW50cywgY3JlYXRpbmcgZGlyZWN0b3J5IHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb2xkZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvbGRlciNmb3JtYXRDb250ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbnRlbnRzIEZvbGRlciBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gICAgICAgICBGb3JtYXR0ZWQgY29udGVudHMuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRm9ybWF0IGZvbGRlciBjb250ZW50cywgY3JlYXRpbmcgZGlyZWN0b3J5IHN0cnVjdHVyZS5cbiAgICAgKiBGb2xkZXJzIGZvdW5kIGluIGZpbGVwYXRocyBhcmUgYWRkZWQgdG8gdGhlIGFycmF5LiBFYWNoIGZvbGRlciBoYXMgdGhlIHByb3BlcnRpZXM6IG5hbWUsIGZpbGVpY29uLFxuICAgICAqIHR5cGUgKGZvbGRlciksIGZpbGVwYXRoIGFuZCBjb250ZW50cyAoYXJyYXkgd2l0aCBmaWxlcyBhbmQgc3ViZm9sZGVycykuXG4gICAgICovXG4gICAgc2VsZi5mb3JtYXRDb250ZW50cyA9IGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IFtdLFxuICAgICAgICAgICAgZm9sZGVycyA9IFtdLFxuICAgICAgICAgICAgZm9sZGVyaWNvbiA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKCdmb2xkZXInKTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGVudHMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuZmlsZXBhdGggIT09ICcvJykge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgYSBmaWxlIGluIGEgc3ViZm9sZGVyLiBMZXRzIHRyZWF0IHRoZSBwYXRoIHRvIGFkZCB0aGUgc3ViZm9sZGVycyB0byB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdG9yaWVzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGlzdCA9IGZvbGRlcnMsIC8vIFN0YXJ0IGF0IHJvb3QgbGV2ZWwuXG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBlbnRyeS5maWxlcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgc3VicGF0aCA9ICcnO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZpcnN0IGFuZCBsYXN0IHNsYXNoIGlmIG5lZWRlZC5cbiAgICAgICAgICAgICAgICBpZiAocGF0aC5zdWJzdHIoMCwgMSkgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXRoLnN1YnN0cihwYXRoLmxlbmd0aCAtIDEpID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpcmVjdG9yaWVzID0gcGF0aC5zcGxpdCgnLycpO1xuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRpcmVjdG9yaWVzLCBmdW5jdGlvbihkaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VicGF0aCA9IHN1YnBhdGggKyAnLycgKyBkaXJlY3Rvcnk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBpZiB0aGUgZGlyZWN0b3J5IGlzIGFscmVhZHkgc3RvcmVkIGluIGZvbGRlcnMgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExpc3RbaV0ubmFtZSA9PT0gZGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpc3QgPSBjdXJyZW50TGlzdFtpXS5jb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlyZWN0b3J5IG5vdCBmb3VuZC4gQWRkIGl0IHRvIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0ZvbGRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZWljb246IGZvbGRlcmljb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVwYXRoOiBzdWJwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb2xkZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpc3QucHVzaChuZXdGb2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpc3QgPSBuZXdGb2xkZXIuY29udGVudHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRMaXN0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvbGRlcnMuY29uY2F0KGZpbGVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBjYW4gYmUgZG93bmxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb2xkZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvbGRlciNnZXREb3dubG9hZGFibGVGaWxlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7T2JqZWN0W119ICAgICBMaXN0IG9mIGZpbGVzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gW107XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZHVsZS5jb250ZW50cywgZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgZmlsZXMucHVzaChjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGZpbGUgaXMgZG93bmxvYWRhYmxlLiBUaGUgZmlsZSBwYXJhbSBtdXN0IGhhdmUgYSAndHlwZScgYXR0cmlidXRlIGxpa2UgaW4gY29yZV9jb3Vyc2VfZ2V0X2NvbnRlbnRzIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9sZGVyI2lzRmlsZURvd25sb2FkYWJsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlIEZpbGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgVHJ1ZSBpZiBkb3dubG9hZGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzRmlsZURvd25sb2FkYWJsZSA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGUudHlwZSA9PT0gJ2ZpbGUnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgYSBmb2xkZXIgYXMgYmVpbmcgdmlld2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9sZGVyI2xvZ1ZpZXdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgTW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ1ZpZXcgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZm9sZGVyaWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9mb2xkZXJfdmlld19mb2xkZXInLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlZmV0Y2ggdGhlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb2xkZXIjcHJlZmV0Y2hDb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgY29udGVudCBpcyBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoQ29udGVudCA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBzZWxmLmdldERvd25sb2FkYWJsZUZpbGVzKG1vZHVsZSksXG4gICAgICAgICAgICByZXZpc2lvbiA9ICRtbUZpbGVwb29sLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyksXG4gICAgICAgICAgICB0aW1lbW9kID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyk7XG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5wcmVmZXRjaFBhY2thZ2UoJG1tU2l0ZS5nZXRJZCgpLCBmaWxlcywgbW1hTW9kRm9sZGVyQ29tcG9uZW50LCBtb2R1bGUuaWQsIHJldmlzaW9uLCB0aW1lbW9kKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9mb2xkZXInKVxuXG4vKipcbiAqIE1vZCBGb2xkZXIgaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RGb2xkZXJIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZEZvbGRlckhhbmRsZXJzJywgZnVuY3Rpb24oJG1tQ291cnNlLCAkbW1hTW9kRm9sZGVyLCAkbW1FdmVudHMsICRzdGF0ZSwgJG1tU2l0ZSwgJG1tVXRpbCwgJG1tRmlsZXBvb2wsXG4gICAgICAgICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLCBtbUNvcmVEb3dubG9hZGluZywgbW1Db3JlTm90RG93bmxvYWRlZCwgbW1Db3JlT3V0ZGF0ZWQsIG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsXG4gICAgICAgICAgICBtbWFNb2RGb2xkZXJDb21wb25lbnQsICRtbUNvbnRlbnRMaW5rc0hlbHBlciwgJHEpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb2xkZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvbGRlckhhbmRsZXJzI2NvdXJzZUNvbnRlbnRcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRtbWFNb2RGb2xkZXJDb3Vyc2VDb250ZW50SGFuZGxlciNpc0VuYWJsZWRcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9sZGVyXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tYU1vZEZvbGRlckNvdXJzZUNvbnRlbnRIYW5kbGVyI2dldENvbnRyb2xsZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSAgICBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCAgQ291cnNlIElELlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VjdGlvbmlkIFNlY3Rpb24gSUQuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCwgc2VjdGlvbmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25sb2FkQnRuLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoQnRuLFxuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbiA9ICRtbUZpbGVwb29sLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJlZmV0Y2ggZm9sZGVyIGNvbnRlbnRzLlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByZWZldGNoRm9sZGVyKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAkbW1hTW9kRm9sZGVyLnByZWZldGNoQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRkZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3JlLmVycm9yZG93bmxvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG93bmxvYWRCdG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1pb3MtY2xvdWQtZG93bmxvYWQtb3V0bGluZScsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnbW0uY29yZS5kb3dubG9hZCcsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogcHJlZmV0Y2hGb2xkZXJcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWFuZHJvaWQtcmVmcmVzaCcsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnbW0uY29yZS5yZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBwcmVmZXRjaEZvbGRlclxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKCdmb2xkZXInKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYnV0dG9ucyA9IFtkb3dubG9hZEJ0biwgcmVmcmVzaEJ0bl07XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2RfZm9sZGVyJywge21vZHVsZTogbW9kdWxlLCBjb3Vyc2VpZDogY291cnNlaWQsIHNlY3Rpb25pZDogc2VjdGlvbmlkfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3cgYnV0dG9ucyBhY2NvcmRpbmcgdG8gbW9kdWxlIHN0YXR1cy5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG93U3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3Bpbm5lciA9IHN0YXR1cyA9PT0gbW1Db3JlRG93bmxvYWRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEJ0bi5oaWRkZW4gPSBzdGF0dXMgIT09IG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoQnRuLmhpZGRlbiA9IHN0YXR1cyAhPT0gbW1Db3JlT3V0ZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhpcyBtb2R1bGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNpdGVpZCA9PT0gJG1tU2l0ZS5nZXRJZCgpICYmIGRhdGEuY29tcG9uZW50SWQgPT09IG1vZHVsZS5pZCAmJiBkYXRhLmNvbXBvbmVudCA9PT0gbW1hTW9kRm9sZGVyQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93U3RhdHVzKGRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgc3RhdHVzIHRvIGRlY2lkZSB3aGljaCBpY29uIHNob3VsZCBiZSBzaG93bi5cbiAgICAgICAgICAgICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLmdldE1vZHVsZVN0YXR1cyhtb2R1bGUsIGNvdXJzZWlkLCByZXZpc2lvbiwgdGltZW1vZGlmaWVkKS50aGVuKHNob3dTdGF0dXMpO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzT2JzZXJ2ZXIgJiYgc3RhdHVzT2JzZXJ2ZXIub2ZmICYmIHN0YXR1c09ic2VydmVyLm9mZigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9sZGVySGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRW5hYmxlZChzaXRlSWQsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICBpZiAoY291cnNlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkbW1Db3Vyc2UuY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkKHNpdGVJZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgZm9sZGVyIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignL21vZC9mb2xkZXIvdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZm9sZGVyJylcblxuLyoqXG4gKiBNb2QgZm9sZGVyIHByZWZldGNoIGhhbmRsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RGb2xkZXJQcmVmZXRjaEhhbmRsZXJcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RGb2xkZXJQcmVmZXRjaEhhbmRsZXInLCBmdW5jdGlvbigkbW1hTW9kRm9sZGVyLCAkbW1TaXRlLCBtbWFNb2RGb2xkZXJDb21wb25lbnQpIHtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICBzZWxmLmNvbXBvbmVudCA9IG1tYU1vZEZvbGRlckNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG93bmxvYWQgc2l6ZSBvZiBhIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb2xkZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvbGRlclByZWZldGNoSGFuZGxlciNnZXREb3dubG9hZFNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIE1vZHVsZSB0byBnZXQgdGhlIHNpemUuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICBTaXplLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RG93bmxvYWRTaXplID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBzaXplID0gMDtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZHVsZS5jb250ZW50cywgZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgaWYgKCRtbWFNb2RGb2xkZXIuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpICYmIGNvbnRlbnQuZmlsZXNpemUpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gc2l6ZSArIGNvbnRlbnQuZmlsZXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb2xkZXJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvbGRlclByZWZldGNoSGFuZGxlciNpc0VuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCB0aGUgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvbGRlclxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9sZGVyUHJlZmV0Y2hIYW5kbGVyI3ByZWZldGNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgZmlsZXMgaGF2ZSBiZWVuIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYucHJlZmV0Y2ggPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RGb2xkZXIucHJlZmV0Y2hDb250ZW50KG1vZHVsZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZm9ydW0nKVxuXG4vKipcbiAqIEZvcnVtIGRpc2N1c3Npb24gY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RGb3J1bURpc2N1c3Npb25DdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RGb3J1bURpc2N1c3Npb25DdHJsJywgZnVuY3Rpb24oJHEsICRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1hTW9kRm9ydW0sICRtbVNpdGUsICRtbVV0aWwsICR0cmFuc2xhdGUsXG4gICAgICAgICAgICAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSwgbW1hTW9kRm9ydW1Db21wb25lbnQpIHtcblxuICAgIHZhciBkaXNjdXNzaW9uaWQgPSAkc3RhdGVQYXJhbXMuZGlzY3Vzc2lvbmlkLFxuICAgICAgICBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jaWQsXG4gICAgICAgIHNjcm9sbFZpZXc7XG5cbiAgICAkc2NvcGUuY29tcG9uZW50ID0gbW1hTW9kRm9ydW1Db21wb25lbnQ7XG4gICAgJHNjb3BlLmNvdXJzZWlkID0gY291cnNlaWQ7XG4gICAgJHNjb3BlLm5ld3Bvc3QgPSB7XG4gICAgICAgIHJlcGx5aW5ndG86IHVuZGVmaW5lZCxcbiAgICAgICAgc3ViamVjdDogJycsXG4gICAgICAgIG1lc3NhZ2U6ICcnXG4gICAgfTtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBmb3J1bSBkaXNjdXNzaW9ucy5cbiAgICBmdW5jdGlvbiBmZXRjaFBvc3RzKCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZEZvcnVtLmdldERpc2N1c3Npb25Qb3N0cyhkaXNjdXNzaW9uaWQpLnRoZW4oZnVuY3Rpb24ocG9zdHMpIHtcbiAgICAgICAgICAgICRzY29wZS5kaXNjdXNzaW9uID0gJG1tYU1vZEZvcnVtLmV4dHJhY3RTdGFydGluZ1Bvc3QocG9zdHMpO1xuICAgICAgICAgICAgJHNjb3BlLnBvc3RzID0gcG9zdHM7XG5cbiAgICAgICAgICAgIC8vIFNldCBkZWZhdWx0IHJlcGx5IHN1YmplY3QuXG4gICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZSgnbW1hLm1vZF9mb3J1bS5yZScpLnRoZW4oZnVuY3Rpb24oc3RyUmVwbHlQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZGVmYXVsdFN1YmplY3QgPSBzdHJSZXBseVByZWZpeCArICcgJyArICRzY29wZS5kaXNjdXNzaW9uLnN1YmplY3Q7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm5ld3Bvc3Quc3ViamVjdCA9ICRzY29wZS5kZWZhdWx0U3ViamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZWZyZXNoIHBvc3RzLlxuICAgIGZ1bmN0aW9uIHJlZnJlc2hQb3N0cygpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RGb3J1bS5pbnZhbGlkYXRlRGlzY3Vzc2lvblBvc3RzKGRpc2N1c3Npb25pZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFBvc3RzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZldGNoUG9zdHMoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBBZGQgbG9nIGluIE1vb2RsZS5cbiAgICAgICAgJG1tU2l0ZS53cml0ZSgnbW9kX2ZvcnVtX3ZpZXdfZm9ydW1fZGlzY3Vzc2lvbicsIHtcbiAgICAgICAgICAgIGRpc2N1c3Npb25pZDogZGlzY3Vzc2lvbmlkXG4gICAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5kaXNjdXNzaW9uTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIFB1bGwgdG8gcmVmcmVzaC5cbiAgICAkc2NvcGUucmVmcmVzaFBvc3RzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZnJlc2hQb3N0cygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gTmV3IHBvc3QgYWRkZWQuXG4gICAgJHNjb3BlLm5ld1Bvc3RBZGRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNjcm9sbFZpZXcpIHtcbiAgICAgICAgICAgIHNjcm9sbFZpZXcgPSAkaW9uaWNTY3JvbGxEZWxlZ2F0ZS4kZ2V0QnlIYW5kbGUoJ21tYU1vZEZvcnVtUG9zdHNTY3JvbGwnKTtcbiAgICAgICAgfVxuICAgICAgICBzY3JvbGxWaWV3ICYmIHNjcm9sbFZpZXcuc2Nyb2xsVG9wICYmIHNjcm9sbFZpZXcuc2Nyb2xsVG9wKCk7XG5cbiAgICAgICAgJHNjb3BlLm5ld3Bvc3QucmVwbHlpbmd0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgJHNjb3BlLm5ld3Bvc3Quc3ViamVjdCA9ICRzY29wZS5kZWZhdWx0U3ViamVjdDtcbiAgICAgICAgJHNjb3BlLm5ld3Bvc3QubWVzc2FnZSA9ICcnO1xuXG4gICAgICAgICRzY29wZS5kaXNjdXNzaW9uTG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHJlZnJlc2hQb3N0cygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGlzY3Vzc2lvbkxvYWRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9mb3J1bScpXG5cbi8qKlxuICogRm9ydW0gZGlzY3Vzc2lvbiBsaXN0IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kRm9ydW1EaXNjdXNzaW9uc0N0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZEZvcnVtRGlzY3Vzc2lvbnNDdHJsJywgZnVuY3Rpb24oJHEsICRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1hTW9kRm9ydW0sICRtbUNvdXJzZSwgJG1tVXRpbCwgJG1tR3JvdXBzLFxuICAgICAgICAgICAgJG1tRXZlbnRzLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSwgJGlvbmljUGxhdGZvcm0sIG1tVXNlclByb2ZpbGVTdGF0ZSwgbW1hTW9kRm9ydW1OZXdEaXNjdXNzaW9uRXZlbnQpIHtcbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIGZvcnVtLFxuICAgICAgICBwYWdlID0gMCxcbiAgICAgICAgc2Nyb2xsVmlldyA9ICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnbW1hTW9kRm9ydW1EaXNjdXNzaW9uc1Njcm9sbCcpLFxuICAgICAgICBzaG91bGRTY3JvbGxUb3AgPSBmYWxzZSxcbiAgICAgICAgdXNlc0dyb3VwcyA9IGZhbHNlO1xuXG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbW9kdWxlLmRlc2NyaXB0aW9uO1xuICAgICRzY29wZS5tb2R1bGV1cmwgPSBtb2R1bGUudXJsO1xuICAgICRzY29wZS5jb3Vyc2VpZCA9IGNvdXJzZWlkO1xuICAgICRzY29wZS51c2VyU3RhdGVOYW1lID0gbW1Vc2VyUHJvZmlsZVN0YXRlO1xuICAgICRzY29wZS5pc0NyZWF0ZUVuYWJsZWQgPSAkbW1hTW9kRm9ydW0uaXNDcmVhdGVEaXNjdXNzaW9uRW5hYmxlZCgpO1xuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IGZvcnVtIGRhdGEgYW5kIGRpc2N1c3Npb25zLlxuICAgIGZ1bmN0aW9uIGZldGNoRm9ydW1EYXRhQW5kRGlzY3Vzc2lvbnMocmVmcmVzaCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZEZvcnVtLmdldEZvcnVtKGNvdXJzZWlkLCBtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24oZm9ydW1kYXRhKSB7XG4gICAgICAgICAgICBmb3J1bSA9IGZvcnVtZGF0YTtcblxuICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gZm9ydW0ubmFtZSB8fCAkc2NvcGUudGl0bGU7XG4gICAgICAgICAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBmb3J1bS5pbnRybyB8fMKgJHNjb3BlLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgJHNjb3BlLmZvcnVtID0gZm9ydW07XG5cbiAgICAgICAgICAgIHJldHVybiAkbW1Hcm91cHMuZ2V0QWN0aXZpdHlHcm91cE1vZGUoZm9ydW0uY21pZCkudGhlbihmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgICAgICAgICAgdXNlc0dyb3VwcyA9IG1vZGUgPT09ICRtbUdyb3Vwcy5TRVBBUkFURUdST1VQUyB8fCBtb2RlID09PSAkbW1Hcm91cHMuVklTSUJMRUdST1VQUztcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRGlzY3Vzc2lvbnMocmVmcmVzaCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKCFyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGZvcnVtIGZhaWxlZCwgcmV0cnkgd2l0aG91dCB1c2luZyBjYWNoZSBzaW5jZSBpdCBtaWdodCBiZSBhIG5ldyBhY3Rpdml0eS5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmcmVzaERhdGEoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2ZvcnVtLmVycm9yZ2V0Zm9ydW0nLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IGZhbHNlOyAvLyBTZXQgdG8gZmFsc2UgdG8gcHJldmVudCBpbmZpbml0ZSBjYWxscyB3aXRoIGluZmluaXRlLWxvYWRpbmcuXG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBmb3J1bSBkaXNjdXNzaW9ucy5cbiAgICBmdW5jdGlvbiBmZXRjaERpc2N1c3Npb25zKHJlZnJlc2gpIHtcbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgIHBhZ2UgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbWFNb2RGb3J1bS5nZXREaXNjdXNzaW9ucyhmb3J1bS5pZCwgcGFnZSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSB1c2VzR3JvdXBzID9cbiAgICAgICAgICAgICAgICAgICAgJG1tYU1vZEZvcnVtLmZvcm1hdERpc2N1c3Npb25zR3JvdXBzKGZvcnVtLmNtaWQsIHJlc3BvbnNlLmRpc2N1c3Npb25zKSA6ICRxLndoZW4ocmVzcG9uc2UuZGlzY3Vzc2lvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihkaXNjdXNzaW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChwYWdlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRpc2N1c3Npb25zID0gZGlzY3Vzc2lvbnM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRpc2N1c3Npb25zID0gJHNjb3BlLmRpc2N1c3Npb25zLmNvbmNhdChkaXNjdXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmNvdW50ID0gJHNjb3BlLmRpc2N1c3Npb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAkc2NvcGUuY2FuTG9hZE1vcmUgPSByZXNwb25zZS5jYW5Mb2FkTW9yZTtcbiAgICAgICAgICAgICAgICBwYWdlKys7XG5cbiAgICAgICAgICAgICAgICBwcmVGZXRjaERpc2N1c3Npb25zUG9zdHMoZGlzY3Vzc2lvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICAkc2NvcGUuY2FuTG9hZE1vcmUgPSBmYWxzZTsgLy8gU2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgaW5maW5pdGUgY2FsbHMgd2l0aCBpbmZpbml0ZS1sb2FkaW5nLlxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBwcmVmZXRjaCB0aGUgcG9zdHMgb2YgZWFjaCBkaXNjdXNzaW9uLCBzbyB0aGV5J3JlIGF2YWlsYWJsZSBpbiBvZmZsaW5lIG1vZGUuXG4gICAgZnVuY3Rpb24gcHJlRmV0Y2hEaXNjdXNzaW9uc1Bvc3RzKGRpc2N1c3Npb25zKSB7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkaXNjdXNzaW9ucywgZnVuY3Rpb24oZGlzY3Vzc2lvbikge1xuICAgICAgICAgICAgdmFyIGRpc2N1c3Npb25pZCA9IGRpc2N1c3Npb24uZGlzY3Vzc2lvbjtcbiAgICAgICAgICAgICRtbWFNb2RGb3J1bS5nZXREaXNjdXNzaW9uUG9zdHMoZGlzY3Vzc2lvbmlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVmcmVzaCBmb3J1bSBkYXRhIGFuZCBkaXNjdXNzaW9ucyBsaXN0LlxuICAgIGZ1bmN0aW9uIHJlZnJlc2hEYXRhKCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kRm9ydW0uaW52YWxpZGF0ZUZvcnVtRGF0YShjb3Vyc2VpZCkpO1xuICAgICAgICBpZiAoZm9ydW0pIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZEZvcnVtLmludmFsaWRhdGVEaXNjdXNzaW9uc0xpc3QoZm9ydW0uaWQpKTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tR3JvdXBzLmludmFsaWRhdGVBY3Rpdml0eUdyb3VwTW9kZShmb3J1bS5jbWlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaEZvcnVtRGF0YUFuZERpc2N1c3Npb25zKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmZXRjaEZvcnVtRGF0YUFuZERpc2N1c3Npb25zKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYU1vZEZvcnVtLmxvZ1ZpZXcoZm9ydW0uaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5kaXNjdXNzaW9uc0xvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBMb2FkIG1vcmUgZGlzY3Vzc2lvbnMuXG4gICAgJHNjb3BlLmxvYWRNb3JlRGlzY3Vzc2lvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmV0Y2hEaXNjdXNzaW9ucygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLmluZmluaXRlU2Nyb2xsQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFB1bGwgdG8gcmVmcmVzaC5cbiAgICAkc2NvcGUucmVmcmVzaERpc2N1c3Npb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZnJlc2hEYXRhKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGRpc2N1c3Npb25zIGFkZGVkLiBXaGVuIGEgZGlzY3Vzc2lvbiBpcyBhZGRlZCwgd2UgcmVsb2FkIHRoZSBkYXRhLlxuICAgIHZhciBvYnNOZXdEaXNjID0gJG1tRXZlbnRzLm9uKG1tYU1vZEZvcnVtTmV3RGlzY3Vzc2lvbkV2ZW50LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICgoZm9ydW0gJiYgZm9ydW0uaWQgPT09IGRhdGEuZm9ydW1pZCkgfHwgZGF0YS5jbWlkID09PSBtb2R1bGUuaWQpIHtcbiAgICAgICAgICAgIGlmICgkaW9uaWNQbGF0Zm9ybS5pc1RhYmxldCgpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmlldy5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3Qgc2Nyb2xsIHRvcCBpbm1lZGlhdGVseSBiZWNhdXNlIHRoZSBzY3JvbGwgaXMgbm90IHNlZW4uXG4gICAgICAgICAgICAgICAgc2hvdWxkU2Nyb2xsVG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5kaXNjdXNzaW9uc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVmcmVzaERhdGEoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5kaXNjdXNzaW9uc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2Nyb2xsIHRvcCBpZiBuZWVkZWQuXG4gICAgJHNjb3BlLiRvbignJGlvbmljVmlldy5lbnRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICBzaG91bGRTY3JvbGxUb3AgPSBmYWxzZTtcbiAgICAgICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsVG9wKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKG9ic05ld0Rpc2MgJiYgb2JzTmV3RGlzYy5vZmYpIHtcbiAgICAgICAgICAgIG9ic05ld0Rpc2Mub2ZmKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2ZvcnVtJylcblxuLyoqXG4gKiBBZGQgbmV3IGRpc2N1c3Npb24gY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RGb3J1bU5ld0Rpc2N1c3Npb25DdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RGb3J1bU5ld0Rpc2N1c3Npb25DdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbUdyb3VwcywgJHEsICRtbWFNb2RGb3J1bSwgJG1tRXZlbnRzLCAkaW9uaWNQbGF0Zm9ybSxcbiAgICAgICAgICAgICRtbVV0aWwsICRpb25pY0hpc3RvcnksICR0cmFuc2xhdGUsIG1tYU1vZEZvcnVtTmV3RGlzY3Vzc2lvbkV2ZW50KSB7XG5cbiAgICB2YXIgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY2lkLFxuICAgICAgICBmb3J1bWlkID0gJHN0YXRlUGFyYW1zLmZvcnVtaWQsXG4gICAgICAgIGNtaWQgPSAkc3RhdGVQYXJhbXMuY21pZDtcblxuICAgICRzY29wZS5uZXdkaXNjdXNzaW9uID0ge1xuICAgICAgICBzdWJqZWN0OiAnJyxcbiAgICAgICAgbWVzc2FnZTogJycsXG4gICAgICAgIHN1YnNjcmliZTogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBGZXRjaCBpZiBmb3J1bSB1c2VzIGdyb3VwcyBhbmQgdGhlIGdyb3VwcyBpdCB1c2VzLlxuICAgIGZ1bmN0aW9uIGZldGNoR3JvdXBzKHJlZnJlc2gpIHtcbiAgICAgICAgcmV0dXJuICRtbUdyb3Vwcy5nZXRBY3Rpdml0eUdyb3VwTW9kZShjbWlkKS50aGVuKGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAkbW1Hcm91cHMuU0VQQVJBVEVHUk9VUFMgfHwgbW9kZSA9PT0gJG1tR3JvdXBzLlZJU0lCTEVHUk9VUFMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tR3JvdXBzLmdldEFjdGl2aXR5QWxsb3dlZEdyb3VwcyhjbWlkKS50aGVuKGZ1bmN0aW9uKGZvcnVtZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJG1tR3JvdXBzLlZJU0lCTEVHUk9VUFMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgd2hpY2ggb2YgdGhlIHJldHVybmVkIGdyb3VwcyB0aGUgdXNlciBjYW4gcG9zdCB0by5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB2YWxpZGF0ZVZpc2libGVHcm91cHMoZm9ydW1ncm91cHMsIHJlZnJlc2gpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV1MgYWxyZWFkeSBmaWx0ZXJzIGdyb3Vwcywgbm8gbmVlZCB0byBkbyBpdCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihmb3J1bWdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGZvcnVtZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ydW1ncm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5ncm91cHMgPSBmb3J1bWdyb3VwcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubmV3ZGlzY3Vzc2lvbi5ncm91cGlkID0gZm9ydW1ncm91cHNbMF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNob3dHcm91cHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zaG93Rm9ybSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbW9kZSA9PT0gJG1tR3JvdXBzLlNFUEFSQVRFR1JPVVBTID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtbWEubW9kX2ZvcnVtLmNhbm5vdGFkZGRpc2N1c3Npb25hbGwnIDogJ21tYS5tb2RfZm9ydW0uY2Fubm90YWRkZGlzY3Vzc2lvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgkdHJhbnNsYXRlLmluc3RhbnQobWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNob3dHcm91cHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2hvd0Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfZm9ydW0uZXJyb3JnZXRncm91cHMnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5zaG93Rm9ybSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB3aGljaCBvZiB0aGUgZ3JvdXBzIHJldHVybmVkIGJ5IGdldEFjdGl2aXR5QWxsb3dlZEdyb3VwcyBpbiB2aXNpYmxlIGdyb3VwcyBzaG91bGQgYmUgc2hvd24gdG8gcG9zdCB0by5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVZpc2libGVHcm91cHMoZm9ydW1ncm91cHMsIHJlZnJlc2gpIHtcbiAgICAgICAgaWYgKCRtbWFNb2RGb3J1bS5pc0NhbkFkZERpc2N1c3Npb25BdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBjYW5BZGREaXNjdXNzaW9uIGZ1bmN0aW9uIHRvIGZpbHRlciB0aGUgZ3JvdXBzLlxuICAgICAgICAgICAgLy8gV2UgZmlyc3QgY2hlY2sgaWYgdGhlIHVzZXIgY2FuIHBvc3QgdG8gYWxsIHRoZSBncm91cHMuXG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEZvcnVtLmNhbkFkZERpc2N1c3Npb25Ub0FsbChmb3J1bWlkKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbCBmYWlsZWQsIGxldCdzIGFzc3VtZSBoZSBjYW4ndC5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGNhbkFkZCkge1xuICAgICAgICAgICAgICAgIGlmIChjYW5BZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgY2FuIHBvc3QgdG8gYWxsIGdyb3VwcywgcmV0dXJuIHRoZW0gYWxsLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ydW1ncm91cHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgY2FuJ3QgcG9zdCB0byBhbGwgZ3JvdXBzLCBsZXQncyBjaGVjayB3aGljaCBncm91cHMgaGUgY2FuIHBvc3QgdG8uXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZm9ydW1ncm91cHMsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RGb3J1bS5jYW5BZGREaXNjdXNzaW9uKGZvcnVtaWQsIGdyb3VwLmlkKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbCBmYWlsZWQsIGxldCdzIHJldHVybiB0cnVlIHNvIHRoZSBncm91cCBpcyBzaG93bi4gSWYgdGhlIHVzZXIgY2FuJ3QgcG9zdCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGFuIGVycm9yIHdpbGwgYmUgc2hvd24gd2hlbiBoZSB0cmllcyB0byBhZGQgdGhlIGRpc2N1c3Npb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGNhbkFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5BZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChncm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGNoZWNrIGl0IHVzaW5nIFdTLiBXZSdsbCBnZXQgdGhlIGdyb3VwcyB0aGUgdXNlciBiZWxvbmdzIHRvIGFuZCB1c2UgdGhlbSB0b1xuICAgICAgICAgICAgLy8gZmlsdGVyIHRoZSBncm91cHMgdG8gcG9zdC5cbiAgICAgICAgICAgIHJldHVybiAkbW1Hcm91cHMuZ2V0VXNlckdyb3Vwc0luQ291cnNlKGNvdXJzZWlkLCByZWZyZXNoKS50aGVuKGZ1bmN0aW9uKHVzZXJncm91cHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlcmdyb3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlciBkb2Vzbid0IGJlbG9uZyB0byBhbnkgZ3JvdXAsIHByb2JhYmx5IGEgdGVhY2hlci4gTGV0J3MgcmV0dXJuIGFsbCBncm91cHMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIGNhbid0IHBvc3QgdG8gc29tZSBvZiB0aGVtIGl0IHdpbGwgYmUgZmlsdGVyZWQgYnkgYWRkIGRpc2N1c3Npb24gV1MuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3J1bWdyb3VwcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckdyb3Vwcyhmb3J1bWdyb3VwcywgdXNlcmdyb3Vwcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbHRlciBmb3J1bWdyb3VwcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgdGhhdCBhcmUgaW5zaWRlIHVzZXJncm91cHMuXG4gICAgZnVuY3Rpb24gZmlsdGVyR3JvdXBzKGZvcnVtZ3JvdXBzLCB1c2VyZ3JvdXBzKSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IFtdLFxuICAgICAgICAgICAgdXNlcmdyb3Vwc2lkcyA9IHVzZXJncm91cHMubWFwKGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZy5pZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChmb3J1bWdyb3VwcywgZnVuY3Rpb24oZmcpIHtcbiAgICAgICAgICAgIGlmICh1c2VyZ3JvdXBzaWRzLmluZGV4T2YoZmcuaWQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKGZnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgIH1cblxuICAgIGZldGNoR3JvdXBzKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmdyb3Vwc0xvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBQdWxsIHRvIHJlZnJlc2guXG4gICAgJHNjb3BlLnJlZnJlc2hHcm91cHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAxID0gJG1tR3JvdXBzLmludmFsaWRhdGVBY3Rpdml0eUdyb3VwTW9kZShjbWlkKSxcbiAgICAgICAgICAgIHAyID0gJG1tR3JvdXBzLmludmFsaWRhdGVBY3Rpdml0eUFsbG93ZWRHcm91cHMoY21pZCksXG4gICAgICAgICAgICBwMyA9ICRtbWFNb2RGb3J1bS5pbnZhbGlkYXRlQ2FuQWRkRGlzY3Vzc2lvbihmb3J1bWlkKTtcblxuICAgICAgICAkcS5hbGwoW3AxLCBwMl0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmZXRjaEdyb3Vwcyh0cnVlKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBhIG5ldyBkaXNjdXNzaW9uLlxuICAgICRzY29wZS5hZGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSAkc2NvcGUubmV3ZGlzY3Vzc2lvbi5zdWJqZWN0LFxuICAgICAgICAgICAgbWVzc2FnZSA9ICRzY29wZS5uZXdkaXNjdXNzaW9uLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdWJzY3JpYmUgPSAkc2NvcGUubmV3ZGlzY3Vzc2lvbi5zdWJzY3JpYmUsXG4gICAgICAgICAgICBncm91cGlkID0gJHNjb3BlLm5ld2Rpc2N1c3Npb24uZ3JvdXBpZDtcblxuICAgICAgICBpZiAoIXN1YmplY3QpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfZm9ydW0uZXJyb3JlbXB0eXN1YmplY3QnLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfZm9ydW0uZXJyb3JlbXB0eW1lc3NhZ2UnLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlID0gJzxwPicgKyBtZXNzYWdlICsgJzxwPic7XG5cbiAgICAgICAgJG1tYU1vZEZvcnVtLmFkZE5ld0Rpc2N1c3Npb24oZm9ydW1pZCwgc3ViamVjdCwgbWVzc2FnZSwgc3Vic2NyaWJlLCBncm91cGlkKS50aGVuKGZ1bmN0aW9uKGRpc2N1c3Npb25pZCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZm9ydW1pZDogZm9ydW1pZCxcbiAgICAgICAgICAgICAgICBkaXNjdXNzaW9uaWQ6IGRpc2N1c3Npb25pZCxcbiAgICAgICAgICAgICAgICBjbWlkOiBjbWlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1hTW9kRm9ydW1OZXdEaXNjdXNzaW9uRXZlbnQsIGRhdGEpO1xuXG4gICAgICAgICAgICBpZiAoJGlvbmljUGxhdGZvcm0uaXNUYWJsZXQoKSkge1xuICAgICAgICAgICAgICAgIC8vIEVtcHR5IGZvcm0uXG4gICAgICAgICAgICAgICAgJHNjb3BlLm5ld2Rpc2N1c3Npb24uc3ViamVjdCA9ICcnO1xuICAgICAgICAgICAgICAgICRzY29wZS5uZXdkaXNjdXNzaW9uLm1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gR28gYmFjayB0byBkaXNjdXNzaW9ucyBsaXN0LlxuICAgICAgICAgICAgICAgICRpb25pY0hpc3RvcnkuZ29CYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9mb3J1bS5jYW5ub3RjcmVhdGVkaXNjdXNzaW9uJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9mb3J1bScpXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIHNob3cgYSBkaXNjdXNzaW9uIHBvc3QsIGl0cyBhdHRhY2htZW50cyBhbmQgdGhlIGFjdGlvbiBidXR0b25zIGFsbG93ZWQgKHJlcGx5LCBldGMuKS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1tYUZvcnVtRGlzY3Vzc2lvblBvc3RcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBkaXJlY3RpdmUgd2lsbCBzaG93IGEgZm9ydW0gcG9zdCBpZiB0aGUgcmlnaHQgZGF0YSBpcyBzdXBwbGllZC4gQXR0cmlidXRlczpcbiAqXG4gKiBAcGFyYW3CoHtPYmplY3R9IHBvc3QgICAgICAgICAgICAgUG9zdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCAgICAgICAgIFBvc3QncyBjb3Vyc2UgSUQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgICAgICAgICAgICBQb3N0J3MgdGl0bGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3ViamVjdCAgICAgICAgICBQb3N0J3Mgc3ViamVjdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgICAgICAgIENvbXBvbmVudCB0aGlzIHBvc3QgYmVsb25nIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IG5ld3Bvc3QgICAgICAgICAgT2JqZWN0IHdpdGggdGhlIG5ldyBwb3N0IGRhdGEuIFVzdWFsbHkgc2hhcmVkIGJldHdlZW4gcG9zdHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dkaXZpZGVyICAgICBUcnVlIGlmIGl0IHNob3VsZCBoYXZlIGEgbGlzdCBkaXZpZGVyIGJlZm9yZSB0aGUgcG9zdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdGl0bGVpbXBvcnRhbnQgIFRydWUgaWYgdGl0bGUgc2hvdWxkIGJlIFwiaW1wb3J0YW50XCIgKGJvbGQpLlxuICogQG9hcmFtIHtGdW5jdGlvbn0gW3Bvc3RhZGRlZF0gICAgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgbmV3IHBvc3QgaXMgYWRkZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRzdWJqZWN0XSBEZWZhdWx0IHN1YmplY3QgdG8gc2V0IHRvIG5ldyBwb3N0cy5cbiAqL1xuLmRpcmVjdGl2ZSgnbW1hTW9kRm9ydW1EaXNjdXNzaW9uUG9zdCcsIGZ1bmN0aW9uKCRtbWFNb2RGb3J1bSwgJG1tVXRpbCwgJHRyYW5zbGF0ZSwgJHEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgcG9zdDogJz0nLFxuICAgICAgICAgICAgY291cnNlaWQ6ICc9JyxcbiAgICAgICAgICAgIHRpdGxlOiAnPScsXG4gICAgICAgICAgICBzdWJqZWN0OiAnPScsXG4gICAgICAgICAgICBjb21wb25lbnQ6ICc9JyxcbiAgICAgICAgICAgIG5ld3Bvc3Q6ICc9JyxcbiAgICAgICAgICAgIHNob3dkaXZpZGVyOiAnPT8nLFxuICAgICAgICAgICAgdGl0bGVpbXBvcnRhbnQ6ICc9PycsXG4gICAgICAgICAgICBwb3N0YWRkZWQ6ICcmPycsXG4gICAgICAgICAgICBkZWZhdWx0c3ViamVjdDogJz0/J1xuICAgICAgICB9LFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FkZG9ucy9tb2RfZm9ydW0vdGVtcGxhdGVzL2Rpc2N1c3Npb25wb3N0Lmh0bWwnLFxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSkge1xuICAgICAgICAgICAgc2NvcGUuaXNSZXBseUVuYWJsZWQgPSAkbW1hTW9kRm9ydW0uaXNSZXBseVBvc3RFbmFibGVkKCk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGlzIHBvc3QgYXMgYmVpbmcgcmVwbGllZCB0by5cbiAgICAgICAgICAgIHNjb3BlLnNob3dSZXBseSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNjb3BlLm5ld3Bvc3QucmVwbHlpbmd0byA9IHNjb3BlLnBvc3QuaWQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBSZXBseSB0byB0aGlzIHBvc3QuXG4gICAgICAgICAgICBzY29wZS5yZXBseSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGUubmV3cG9zdC5zdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfZm9ydW0uZXJyb3JlbXB0eXN1YmplY3QnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLm5ld3Bvc3QubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2ZvcnVtLmVycm9yZW1wdHltZXNzYWdlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICc8cD4nICsgc2NvcGUubmV3cG9zdC5tZXNzYWdlLnJlcGxhY2UoL1xcbi9nLCAnPGJyPicpICsgJzwvcD4nLFxuICAgICAgICAgICAgICAgICAgICBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW0uY29yZS5zZW5kaW5nJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAkbW1hTW9kRm9ydW0ucmVwbHlQb3N0KHNjb3BlLm5ld3Bvc3QucmVwbHlpbmd0bywgc2NvcGUubmV3cG9zdC5zdWJqZWN0LCBtZXNzYWdlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUucG9zdGFkZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wb3N0YWRkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX2ZvcnVtLmNvdWxkbm90YWRkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDYW5jZWwgcmVwbHkuXG4gICAgICAgICAgICBzY29wZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLm5ld3Bvc3Quc3ViamVjdCAmJiAhc2NvcGUubmV3cG9zdC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKCk7IC8vIE5vdGhpbmcgd3JpdHRlbiwgY2FuY2VsIHJpZ2h0IGF3YXkuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRtbVV0aWwuc2hvd0NvbmZpcm0oJHRyYW5zbGF0ZSgnbW0uY29yZS5hcmV5b3VzdXJlJykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUubmV3cG9zdC5yZXBseWluZ3RvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5uZXdwb3N0LnN1YmplY3QgPSBzY29wZS5kZWZhdWx0c3ViamVjdMKgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm5ld3Bvc3QubWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9mb3J1bScpXG5cbi8qKlxuICogRm9ydW0gc2VydmljZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSAkbW1hTW9kRm9ydW1cbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RGb3J1bScsIGZ1bmN0aW9uKCRxLCAkbW1TaXRlLCAkbW1Vc2VyLCAkbW1Hcm91cHMsICR0cmFuc2xhdGUsICRtbVNpdGVzTWFuYWdlciwgbW1hTW9kRm9ydW1EaXNjUGVyUGFnZSkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBjYW4gYWRkIGRpc2N1c3Npb24gV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZvcnVtaWQgRm9ydW0gSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBncm91cGlkIEdyb3VwIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q2FuQWRkRGlzY3Vzc2lvbkNhY2hlS2V5KGZvcnVtaWQsIGdyb3VwaWQpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbW1vbkNhbkFkZERpc2N1c3Npb25DYWNoZUtleShmb3J1bWlkKSArICc6JyArIGdyb3VwaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbW1vbiBwYXJ0IG9mIGNhY2hlIGtleSBmb3IgY2FuIGFkZCBkaXNjdXNzaW9uIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmb3J1bWlkIEZvcnVtIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q29tbW9uQ2FuQWRkRGlzY3Vzc2lvbkNhY2hlS2V5KGZvcnVtaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RGb3J1bTpjYW5hZGRkaXNjdXNzaW9uOicgKyBmb3J1bWlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGZvcnVtIGRhdGEgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Rm9ydW1EYXRhQ2FjaGVLZXkoY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RGb3J1bTpmb3J1bTonICsgY291cnNlaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3IgZm9ydW0gZGlzY3Vzc2lvbiBwb3N0cyBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZGlzY3Vzc2lvbmlkIERpc2N1c3Npb24gSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldERpc2N1c3Npb25Qb3N0c0NhY2hlS2V5KGRpc2N1c3Npb25pZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZEZvcnVtOmRpc2N1c3Npb246JyArIGRpc2N1c3Npb25pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBmb3J1bSBkaXNjdXNzaW9ucyBsaXN0IFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmb3J1bWlkIEZvcnVtIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RGlzY3Vzc2lvbnNMaXN0Q2FjaGVLZXkoZm9ydW1pZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZEZvcnVtOmRpc2N1c3Npb25zOicgKyBmb3J1bWlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBkaXNjdXNzaW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNhZGROZXdEaXNjdXNzaW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvcnVtaWQgICBGb3J1bSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3ViamVjdCAgIE5ldyBkaXNjdXNzaW9uJ3Mgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAgIE5ldyBkaXNjdXNzaW9uJ3MgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3Vic2NyaWJlIFRydWUgaWYgc2hvdWxkIHN1YnNjcmliZSB0byB0aGUgZGlzY3Vzc2lvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZ3JvdXBpZF0gR3JvdXAgdGhpcyBkaXNjdXNzaW9uIGJlbG9uZ3MgdG8uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRpc2N1c3Npb24gaXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmFkZE5ld0Rpc2N1c3Npb24gPSBmdW5jdGlvbihmb3J1bWlkLCBzdWJqZWN0LCBtZXNzYWdlLCBzdWJzY3JpYmUsIGdyb3VwaWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGZvcnVtaWQ6IGZvcnVtaWQsXG4gICAgICAgICAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkaXNjdXNzaW9uc3Vic2NyaWJlJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEhc3Vic2NyaWJlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZ3JvdXBpZCkge1xuICAgICAgICAgICAgcGFyYW1zLmdyb3VwaWQgPSBncm91cGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9mb3J1bV9hZGRfZGlzY3Vzc2lvbicsIHBhcmFtcykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fMKgIXJlc3BvbnNlLmRpc2N1c3Npb25pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRpc2N1c3Npb25pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdXNlciBjYW4gcG9zdCB0byBhIGNlcnRhaW4gZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2NhbkFkZERpc2N1c3Npb25cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZvcnVtaWQgRm9ydW0gSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBncm91cGlkIEdyb3VwIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggYSBib29sZWFuOiB0cnVlIGlmIGNhbiBhZGQgZGlzY3Vzc2lvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuY2FuQWRkRGlzY3Vzc2lvbiA9IGZ1bmN0aW9uKGZvcnVtaWQsIGdyb3VwaWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBmb3J1bWlkOiBmb3J1bWlkLFxuICAgICAgICAgICAgICAgIGdyb3VwaWQ6IGdyb3VwaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRDYW5BZGREaXNjdXNzaW9uQ2FjaGVLZXkoZm9ydW1pZCwgZ3JvdXBpZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX2ZvcnVtX2Nhbl9hZGRfZGlzY3Vzc2lvbicsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFyZXN1bHQuc3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB1c2VyIGNhbiBwb3N0IHRvIGFsbCBncm91cHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2NhbkFkZERpc2N1c3Npb25Ub0FsbFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZm9ydW1pZCBGb3J1bSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgYm9vbGVhbjogdHJ1ZSBpZiBjYW4gYWRkIGRpc2N1c3Npb24gdG8gYWxsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5jYW5BZGREaXNjdXNzaW9uVG9BbGwgPSBmdW5jdGlvbihmb3J1bWlkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNhbkFkZERpc2N1c3Npb24oZm9ydW1pZCwgLTEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBzdGFydGluZyBwb3N0IG9mIGEgZGlzY3Vzc2lvbiBmcm9tIGEgbGlzdCBvZiBwb3N0cy4gVGhlIHBvc3QgaXMgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2dldFN0YXJ0aW5nUG9zdFxuICAgICAqIEBwYXJhbSAge09iamVjdFtdfSBwb3N0cyBQb3N0cyB0byBzZWFyY2guXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFN0YXJ0aW5nIHBvc3QuXG4gICAgICovXG4gICAgc2VsZi5leHRyYWN0U3RhcnRpbmdQb3N0ID0gZnVuY3Rpb24ocG9zdHMpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGxhc3QgcG9zdCBmaXJzdCwgc2luY2UgdGhleSdsbCB1c3VhbGx5IGJlIG9yZGVyZWQgYnkgY3JlYXRlIHRpbWUuXG4gICAgICAgIHZhciBsYXN0UG9zdCA9IHBvc3RzW3Bvc3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFBvc3QucGFyZW50ID09IDApIHtcbiAgICAgICAgICAgIHBvc3RzLnBvcCgpOyAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXkuXG4gICAgICAgICAgICByZXR1cm4gbGFzdFBvc3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMYXN0IHBvc3Qgd2Fzbid0IHRoZSBzdGFydGluZyBvbmUuIExldCdzIHNlYXJjaCBhbGwgdGhlIHBvc3RzIHVudGlsIHdlIGZpbmQgdGhlIGZpcnN0IG9uZS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBvc3RzW2ldLnBhcmVudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpOyAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc3RzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2FuQWRkRGlzY3Vzc2lvbiBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2lzQ2FuQWRkRGlzY3Vzc2lvbkF2YWlsYWJsZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgYXZhaWxhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc0NhbkFkZERpc2N1c3Npb25BdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3NBdmFpbGFibGUoJ21vZF9mb3J1bV9jYW5fYWRkX2Rpc2N1c3Npb24nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaXMgZW5hYmxlZCBpbiBhIGNlcnRhaW4gc2l0ZS4gUGx1Z2luIGlzIGVuYWJsZWQgaWYgdGhlIGZvcnVtIFdTIGFyZSBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIHBsdWdpbiBpcyBlbmFibGVkLCByZWplY3RlZCBvciByZXNvbHZlZCB3aXRoIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICBzaXRlLndzQXZhaWxhYmxlKCdtb2RfZm9ydW1fZ2V0X2ZvcnVtc19ieV9jb3Vyc2VzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2ZvcnVtX2dldF9mb3J1bV9kaXNjdXNzaW9uc19wYWdpbmF0ZWQnKSAmJlxuICAgICAgICAgICAgICAgICAgICBzaXRlLndzQXZhaWxhYmxlKCdtb2RfZm9ydW1fZ2V0X2ZvcnVtX2Rpc2N1c3Npb25fcG9zdHMnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBkaXNjdXNzaW9ucywgc2V0dGluZyBncm91cG5hbWUgaWYgdGhlIGRpc2N1c3Npb24gZ3JvdXAgaXMgdmFsaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNtaWQgICAgICAgICAgRm9ydW0gY21pZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gZGlzY3Vzc2lvbnMgTGlzdCBvZiBkaXNjdXNzaW9ucyB0byBmb3JtYXQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZm9ybWF0dGVkIGRpc2N1c3Npb25zLlxuICAgICAqL1xuICAgIHNlbGYuZm9ybWF0RGlzY3Vzc2lvbnNHcm91cHMgPSBmdW5jdGlvbihjbWlkLCBkaXNjdXNzaW9ucykge1xuICAgICAgICBkaXNjdXNzaW9ucyA9IGFuZ3VsYXIuY29weShkaXNjdXNzaW9ucyk7XG4gICAgICAgIHJldHVybiAkdHJhbnNsYXRlKCdtbS5jb3JlLmFsbHBhcnRpY2lwYW50cycpLnRoZW4oZnVuY3Rpb24oc3RyQWxsUGFydHMpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1Hcm91cHMuZ2V0QWN0aXZpdHlBbGxvd2VkR3JvdXBzKGNtaWQpLnRoZW4oZnVuY3Rpb24oZm9ydW1ncm91cHMpIHtcbiAgICAgICAgICAgICAgICAvLyBUdXJuIGdyb3VwcyBpbnRvIGFuIG9iamVjdCB3aGVyZSBlYWNoIGdyb3VwIGlzIGlkZW50aWZpZWQgYnkgaWQuXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9IHt9O1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChmb3J1bWdyb3VwcywgZnVuY3Rpb24oZmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2ZnLmlkXSA9IGZnO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9ybWF0IGRpc2N1c3Npb25zLlxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkaXNjdXNzaW9ucywgZnVuY3Rpb24oZGlzYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYy5ncm91cGlkID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYy5ncm91cG5hbWUgPSBzdHJBbGxQYXJ0cztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tkaXNjLmdyb3VwaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYy5ncm91cG5hbWUgPSBncm91cC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc2N1c3Npb25zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc2N1c3Npb25zO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgZm9ydW0uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2dldEZvcnVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY21pZCAgICAgQ291cnNlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBmb3J1bSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRGb3J1bSA9IGZ1bmN0aW9uKGNvdXJzZWlkLCBjbWlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY291cnNlaWRzOiBbY291cnNlaWRdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0Rm9ydW1EYXRhQ2FjaGVLZXkoY291cnNlaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9mb3J1bV9nZXRfZm9ydW1zX2J5X2NvdXJzZXMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24oZm9ydW1zKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEZvcnVtO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZvcnVtcywgZnVuY3Rpb24oZm9ydW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ydW0uY21pZCA9PSBjbWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGb3J1bSA9IGZvcnVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRGb3J1bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Rm9ydW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZm9ydW0gZGlzY3Vzc2lvbiBwb3N0cy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb3J1bVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9ydW0jZ2V0RGlzY3Vzc2lvblBvc3RzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc2N1c3Npb25pZCBEaXNjdXNzaW9uIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGZvcnVtIGRpc2N1c3Npb25zLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RGlzY3Vzc2lvblBvc3RzID0gZnVuY3Rpb24oZGlzY3Vzc2lvbmlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGlzY3Vzc2lvbmlkOiBkaXNjdXNzaW9uaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXREaXNjdXNzaW9uUG9zdHNDYWNoZUtleShkaXNjdXNzaW9uaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9mb3J1bV9nZXRfZm9ydW1fZGlzY3Vzc2lvbl9wb3N0cycsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgc3RvcmVVc2VyRGF0YShyZXNwb25zZS5wb3N0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnBvc3RzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZm9ydW0gZGlzY3Vzc2lvbnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2dldERpc2N1c3Npb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvcnVtaWQgRm9ydW0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2UgICAgUGFnZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggZm9ydW0gZGlzY3Vzc2lvbnMuXG4gICAgICovXG4gICAgc2VsZi5nZXREaXNjdXNzaW9ucyA9IGZ1bmN0aW9uKGZvcnVtaWQsIHBhZ2UpIHtcbiAgICAgICAgcGFnZSA9IHBhZ2UgfHwgMDtcblxuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGZvcnVtaWQ6IGZvcnVtaWQsXG4gICAgICAgICAgICAgICAgc29ydGJ5OiAgJ3RpbWVtb2RpZmllZCcsXG4gICAgICAgICAgICAgICAgc29ydGRpcmVjdGlvbjogICdERVNDJyxcbiAgICAgICAgICAgICAgICBwYWdlOiBwYWdlLFxuICAgICAgICAgICAgICAgIHBlcnBhZ2U6IG1tYU1vZEZvcnVtRGlzY1BlclBhZ2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXREaXNjdXNzaW9uc0xpc3RDYWNoZUtleShmb3J1bWlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2RfZm9ydW1fZ2V0X2ZvcnVtX2Rpc2N1c3Npb25zX3BhZ2luYXRlZCcsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbkxvYWRNb3JlID0gcmVzcG9uc2UuZGlzY3Vzc2lvbnMubGVuZ3RoID49IG1tYU1vZEZvcnVtRGlzY1BlclBhZ2U7XG4gICAgICAgICAgICAgICAgc3RvcmVVc2VyRGF0YShyZXNwb25zZS5kaXNjdXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtkaXNjdXNzaW9uczogcmVzcG9uc2UuZGlzY3Vzc2lvbnMsIGNhbkxvYWRNb3JlOiBjYW5Mb2FkTW9yZX07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIGNhbiBhZGQgZGlzY3Vzc2lvbiBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9mb3J1bVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kRm9ydW0jaW52YWxpZGF0ZUNhbkFkZERpc2N1c3Npb25cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZvcnVtaWQgRm9ydW0gSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDYW5BZGREaXNjdXNzaW9uID0gZnVuY3Rpb24oZm9ydW1pZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleVN0YXJ0aW5nV2l0aChnZXRDb21tb25DYW5BZGREaXNjdXNzaW9uQ2FjaGVLZXkoZm9ydW1pZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBmb3J1bSBkaXNjdXNzaW9uIHBvc3RzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNpbnZhbGlkYXRlRGlzY3Vzc2lvblBvc3RzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc2N1c3Npb25pZCBEaXNjdXNzaW9uIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZURpc2N1c3Npb25Qb3N0cyA9IGZ1bmN0aW9uKGRpc2N1c3Npb25pZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXREaXNjdXNzaW9uUG9zdHNDYWNoZUtleShkaXNjdXNzaW9uaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgZGlzY3Vzc2lvbiBsaXN0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNpbnZhbGlkYXRlRGlzY3Vzc2lvbnNMaXN0XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmb3J1bWlkIEZvcnVtIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlRGlzY3Vzc2lvbnNMaXN0ID0gZnVuY3Rpb24oZm9ydW1pZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXREaXNjdXNzaW9uc0xpc3RDYWNoZUtleShmb3J1bWlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIGZvcnVtIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2ludmFsaWRhdGVGb3J1bURhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlRm9ydW1EYXRhID0gZnVuY3Rpb24oY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0Rm9ydW1EYXRhQ2FjaGVLZXkoY291cnNlaWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgc2l0ZSBhbGxvd3MgY3JlYXRpbmcgbmV3IGRpc2N1c3Npb25zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bSNpc0NyZWF0ZURpc2N1c3Npb25FbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc0NyZWF0ZURpc2N1c3Npb25FbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX2dyb3VwX2dldF9hY3Rpdml0eV9ncm91cG1vZGUnKSAmJlxuICAgICAgICAgICAgICAgICRtbVNpdGUud3NBdmFpbGFibGUoJ2NvcmVfZ3JvdXBfZ2V0X2FjdGl2aXR5X2FsbG93ZWRfZ3JvdXBzJykgJiZcbiAgICAgICAgICAgICAgICAkbW1TaXRlLndzQXZhaWxhYmxlKCdtb2RfZm9ydW1fYWRkX2Rpc2N1c3Npb24nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgc2l0ZSBhbGxvd3MgcmVwbHlpbmcgdG8gcG9zdHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2lzUmVwbHlQb3N0RW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNSZXBseVBvc3RFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdtb2RfZm9ydW1fYWRkX2Rpc2N1c3Npb25fcG9zdCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgYSBmb3J1bSBhcyBiZWluZyB2aWV3ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI2xvZ1ZpZXdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgTW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ1ZpZXcgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZm9ydW1pZDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2ZvcnVtX3ZpZXdfZm9ydW0nLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwbHkgdG8gYSBjZXJ0YWluIHBvc3QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtI3JlcGx5UG9zdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3N0aWQgIElEIG9mIHRoZSBwb3N0IGJlaW5nIHJlcGxpZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN1YmplY3QgTmV3IHBvc3QncyBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIE5ldyBwb3N0J3MgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHBvc3QgaXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLnJlcGx5UG9zdCA9IGZ1bmN0aW9uKHBvc3RpZCwgc3ViamVjdCwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgcG9zdGlkOiBwb3N0aWQsXG4gICAgICAgICAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfZm9ydW1fYWRkX2Rpc2N1c3Npb25fcG9zdCcsIHBhcmFtcykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fMKgIXJlc3BvbnNlLnBvc3RpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnBvc3RpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIHRoZSB1c2VycyBkYXRhIGZyb20gYSBkaXNjdXNzaW9ucy9wb3N0cyBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gbGlzdCBBcnJheSBvZiBwb3N0cyBvciBkaXNjdXNzaW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yZVVzZXJEYXRhKGxpc3QpIHtcbiAgICAgICAgdmFyIGlkcyA9IFtdO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobGlzdCwgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHBhcnNlSW50KGVudHJ5LnVzZXJpZCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlkKSAmJiBpZHMuaW5kZXhPZihpZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICRtbVVzZXIuc3RvcmVVc2VyKGlkLCBlbnRyeS51c2VyZnVsbG5hbWUsIGVudHJ5LnVzZXJwaWN0dXJldXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkudXNlcm1vZGlmaWVkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludChlbnRyeS51c2VybW9kaWZpZWQpO1xuICAgICAgICAgICAgICAgIGlmKCFpc05hTihpZCkgJiYgaWRzLmluZGV4T2YoaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgICAgICRtbVVzZXIuc3RvcmVVc2VyKGlkLCBlbnRyeS51c2VybW9kaWZpZWRmdWxsbmFtZSwgZW50cnkudXNlcm1vZGlmaWVkcGljdHVyZXVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2ZvcnVtJylcblxuLyoqXG4gKiBNb2QgZm9ydW0gaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEZvcnVtSGFuZGxlcnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RGb3J1bUhhbmRsZXJzJywgZnVuY3Rpb24oJG1tQ291cnNlLCAkbW1hTW9kRm9ydW0sICRzdGF0ZSwgJG1tVXRpbCwgJG1tQ29udGVudExpbmtzSGVscGVyLCAkcSkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RGb3J1bUhhbmRsZXJzI2NvdXJzZUNvbnRlbnRcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ZvcnVtXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tYU1vZEZvcnVtQ291cnNlQ29udGVudEhhbmRsZXIjaXNFbmFibGVkXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RGb3J1bS5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1hTW9kRm9ydW1Db3Vyc2VDb250ZW50SGFuZGxlciNpc0VuYWJsZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKCdmb3J1bScpO1xuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2RfZm9ydW0nLCB7bW9kdWxlOiBtb2R1bGUsIGNvdXJzZWlkOiBjb3Vyc2VpZH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZm9ydW1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEZvcnVtSGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzSW5kZXhFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kRm9ydW0uaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCBTaXRlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNEaXNjRW5hYmxlZChzaXRlSWQpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNoZWNrIGNvdXJzZUlkIGJlY2F1c2UgaXQncyBvbmx5IG5lZWRlZCBmb3IgdXNlciBwcm9maWxlIGxpbmtzLCB3ZSBjYW4gYWZmb3JkIG5vdCBwYXNzaW5nIGl0LlxuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RGb3J1bS5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSBmb3J1bSBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy9tb2QvZm9ydW0vdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9ydW0gaW5kZXguXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNJbmRleEVuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXJsLmluZGV4T2YoJy9tb2QvZm9ydW0vZGlzY3Vzcy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9ydW0gZGlzY3Vzc2lvbi5cbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gJG1tVXRpbC5leHRyYWN0VXJsUGFyYW1zKHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5kICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgZmFsc2UgYmVjYXVzZSBhbGwgc2l0ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2l0ZXVybC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci5maWx0ZXJTdXBwb3J0ZWRTaXRlcyhzaXRlSWRzLCBpc0Rpc2NFbmFibGVkLCBmYWxzZSwgY291cnNlSWQpLnRoZW4oZnVuY3Rpb24oaWRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhY3Rpb25zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbW0uY29yZS52aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1leWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXRlczogaWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2N1c3Npb25pZDogcGFyc2VJbnQocGFyYW1zLmQsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaWQ6IGNvdXJzZUlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tQ29udGVudExpbmtzSGVscGVyLmdvSW5TaXRlKCdzaXRlLm1vZF9mb3J1bS1kaXNjdXNzaW9uJywgc3RhdGVQYXJhbXMsIHNpdGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2dsb3NzYXJ5JylcblxuLyoqXG4gKiBHbG9zc2FyeSBlbnRyeSBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZEdsb3NzYXJ5RW50cnlDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RHbG9zc2FyeUVudHJ5Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1hTW9kR2xvc3NhcnksICR0cmFuc2xhdGUsXG4gICAgICAgIG1tVXNlclByb2ZpbGVTdGF0ZSkge1xuICAgIHZhciBlbnRyeSA9ICRzdGF0ZVBhcmFtcy5lbnRyeSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY2lkIHx8IDAsXG4gICAgICAgIGdsb3NzYXJ5O1xuXG4gICAgLy8gVGhpcyBpcyBhIGNvZGluZyBlcnJvciwgZm9yIG5vdyB0aGUgY291cnNlIElEIGlzIHJlcXVpcmVkIGhlcmUgYXMgd2UgbmVlZCBpdCBmb3IgdGhlIGF1dGhvciBsaW5rLlxuICAgIGlmICghY291cnNlaWQpIHtcbiAgICAgICAgbm90aWZ5RXJyb3JPY2N1cmVkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAkc2NvcGUucmVmcmVzaEVudHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZnJlc2hFbnRyeSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gTG9hZCB0aGUgZ2xvc3NhcnkgZmlyc3QuXG4gICAgJG1tYU1vZEdsb3NzYXJ5LmdldEdsb3NzYXJ5QnlJZChjb3Vyc2VpZCwgZW50cnkuZ2xvc3NhcnlpZCkudGhlbihmdW5jdGlvbihnbG9zcykge1xuICAgICAgICBnbG9zc2FyeSA9IGdsb3NzO1xuICAgICAgICB2YXIgZGlzcGxheUZvcm1hdCA9IGdsb3NzYXJ5LmRpc3BsYXlmb3JtYXQ7XG5cbiAgICAgICAgJHNjb3BlLnRpdGxlID0gZW50cnkuY29uY2VwdDtcbiAgICAgICAgJHNjb3BlLmVudHJ5ID0gZW50cnk7XG4gICAgICAgICRzY29wZS5jb3Vyc2VpZCA9IGNvdXJzZWlkO1xuICAgICAgICAkc2NvcGUudXNlclN0YXRlTmFtZSA9IG1tVXNlclByb2ZpbGVTdGF0ZTtcblxuICAgICAgICBpZiAoZGlzcGxheUZvcm1hdCA9PSAnZnVsbHdpdGhhdXRob3InIHx8IGRpc3BsYXlGb3JtYXQgPT0gJ2VuY3ljbG9wZWRpYScpIHtcbiAgICAgICAgICAgICRzY29wZS5zaG93QXV0aG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICRzY29wZS5zaG93RGF0ZSA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIGlmIChkaXNwbGF5Rm9ybWF0ID09ICdmdWxsd2l0aG91dGF1dGhvcicpIHtcbiAgICAgICAgICAgICRzY29wZS5zaG93QXV0aG9yID0gZmFsc2U7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0RhdGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIERlZmF1bHQsIGFuZCBmYXEsIHNpbXBsZSwgZW50cnlsaXN0LCBjb250aW51b3VzLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnNob3dBdXRob3IgPSBmYWxzZTtcbiAgICAgICAgICAgICRzY29wZS5zaG93RGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gTG9nIHRoYXQgdGhlIGVudHJ5IHdhcyB2aWV3ZWQuXG4gICAgICAgICRtbWFNb2RHbG9zc2FyeS5sb2dFbnRyeVZpZXcoZW50cnkuaWQpO1xuXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgIG5vdGlmeUVycm9yT2NjdXJlZCgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZmV0Y2hFbnRyeSgpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RHbG9zc2FyeS5nZXRFbnRyeShlbnRyeS5pZCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICRzY29wZS5lbnRyeSA9IHJlc3VsdC5lbnRyeTtcbiAgICAgICAgICAgICRzY29wZS50aXRsZSA9IHJlc3VsdC5lbnRyeS5jb25jZXB0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoRW50cnkoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kR2xvc3NhcnkuaW52YWxpZGF0ZUVudHJ5KGVudHJ5LmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoRW50cnkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90aWZ5RXJyb3JPY2N1cmVkKCkge1xuICAgICAgICAkc2NvcGUudGl0bGUgPSAkdHJhbnNsYXRlLmluc3RhbnQoJ21tLmNvcmUuZXJyb3InKTtcbiAgICAgICAgJHNjb3BlLmVudHJ5ID0gZmFsc2U7XG4gICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgIH1cblxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZ2xvc3NhcnknKVxuXG4vKipcbiAqIEdsb3NzYXJ5IGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kR2xvc3NhcnlJbmRleEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZEdsb3NzYXJ5SW5kZXhDdHJsJywgZnVuY3Rpb24oJHEsICRzY29wZSwgJHN0YXRlUGFyYW1zLCAkaW9uaWNQb3BvdmVyLCAkbW1VdGlsLCAkbW1hTW9kR2xvc3NhcnksXG4gICAgICAgICRpb25pY1Njcm9sbERlbGVnYXRlKSB7XG5cbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlSWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIGdsb3NzYXJ5LFxuICAgICAgICBub29wID0gZnVuY3Rpb24oKXt9LFxuICAgICAgICBsaW1pdEZyb20gPSAwLFxuICAgICAgICBsaW1pdE51bSA9IDI1LFxuICAgICAgICBwb3BvdmVyLFxuICAgICAgICB2aWV3TW9kZSwgICAvLyBUaGUgYXJjaGV0eXBlIG9mIHZpZXcgKGxldHRlciwgZGF0ZSwgYXV0aG9yLCBjYXQpLlxuICAgICAgICBmZXRjaE1vZGUgPSAnbGV0dGVyX2FsbCcsICAgICAgIC8vIERlZmF1bHQuXG4gICAgICAgIGZldGNoRnVuY3Rpb24sXG4gICAgICAgIGZldGNoSW52YWxpZGF0ZSxcbiAgICAgICAgZmV0Y2hBcmd1bWVudHMsXG4gICAgICAgIHBvcG92ZXJTY29wZSA9ICRzY29wZS4kbmV3KHRydWUpLFxuICAgICAgICBicm93c2VNb2RlcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXk6ICdsZXR0ZXJfYWxsJyxcbiAgICAgICAgICAgICAgICBsYW5na2V5OiAnbW1hLm1vZF9nbG9zc2FyeS5ieWFscGhhYmV0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXk6ICdzZWFyY2gnLFxuICAgICAgICAgICAgICAgIGxhbmdrZXk6ICdtbWEubW9kX2dsb3NzYXJ5LmJ5c2VhcmNoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbW9kdWxlLmRlc2NyaXB0aW9uO1xuICAgICRzY29wZS5leHRlcm5hbFVybCA9IG1vZHVsZS51cmw7XG4gICAgJHNjb3BlLmNvdXJzZWlkID0gY291cnNlSWQ7XG4gICAgJHNjb3BlLmxvYWRlZCA9IGZhbHNlO1xuICAgICRzY29wZS5lbnRyaWVzID0gW107XG4gICAgJHNjb3BlLmdldERpdmlkZXIgPSBub29wO1xuICAgICRzY29wZS5zaG93RGl2aWRlciA9IG5vb3A7XG4gICAgJHNjb3BlLmNhbkxvYWRNb3JlID0gZmFsc2U7XG4gICAgJHNjb3BlLnNlYXJjaERhdGEgPSB7XG4gICAgICAgIHNlYXJjaFF1ZXJ5OiAnJ1xuICAgIH07XG5cbiAgICAkc2NvcGUubG9hZE1vcmVFbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRNb3JlRW50cmllcygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLmluZmluaXRlU2Nyb2xsQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAkc2NvcGUucmVmcmVzaEVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVmcmVzaEVudHJpZXMoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5waWNrTW9kZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcG9wb3ZlclNjb3BlLmRhdGEuc2VsZWN0ZWRNb2RlID0gZmV0Y2hNb2RlO1xuICAgICAgICBwb3BvdmVyLnNob3coZSk7XG4gICAgfTtcblxuICAgICRzY29wZS5zZWFyY2ggPSBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICBmZXRjaEFyZ3VtZW50cyA9IFtnbG9zc2FyeS5pZCwgcXVlcnksIDEsICdDT05DRVBUJywgJ0FTQyddO1xuICAgICAgICBmZXRjaEVudHJpZXMoKTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLnRyYWNrQnkgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICByZXR1cm4gZmV0Y2hNb2RlICsgJzonICsgZW50cnkuaWQ7XG4gICAgfTtcblxuICAgIC8vIENvbnRyb2xsZXIgcnVuLlxuICAgICRtbWFNb2RHbG9zc2FyeS5nZXRHbG9zc2FyeShjb3Vyc2VJZCwgbW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICBnbG9zc2FyeSA9IG1vZDtcblxuICAgICAgICAvLyBQcmVwYXJpbmcgYnJvd3NlIG1vZGVzLlxuICAgICAgICBpZiAoZ2xvc3NhcnkuYnJvd3NlbW9kZXMuaW5kZXhPZignZGF0ZScpID49IDApIHtcbiAgICAgICAgICAgIGJyb3dzZU1vZGVzLnB1c2goe2tleTogJ25ld2VzdF9maXJzdCcsIGxhbmdrZXk6ICdtbWEubW9kX2dsb3NzYXJ5LmJ5bmV3ZXN0Zmlyc3QnfSk7XG4gICAgICAgICAgICBicm93c2VNb2Rlcy5wdXNoKHtrZXk6ICdyZWNlbnRseV91cGRhdGVkJywgbGFuZ2tleTogJ21tYS5tb2RfZ2xvc3NhcnkuYnlyZWNlbnRseXVwZGF0ZWQnfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsb3NzYXJ5LmJyb3dzZW1vZGVzLmluZGV4T2YoJ2F1dGhvcicpID49IDApIHtcbiAgICAgICAgICAgIGJyb3dzZU1vZGVzLnB1c2goe2tleTogJ2F1dGhvcl9hbGwnLCBsYW5na2V5OiAnbW1hLm1vZF9nbG9zc2FyeS5ieWF1dGhvcid9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXBhcmluZyB0aGUgcG9wb3Zlci5cbiAgICAgICAgcG9wb3ZlclNjb3BlLm1vZGVzID0gYnJvd3NlTW9kZXM7XG4gICAgICAgIHBvcG92ZXJTY29wZS5tb2RlUGlja2VkID0gZnVuY3Rpb24obW9kZSkge1xuICAgICAgICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKCdtbWFNb2RHbG9zc2FyeUluZGV4Jykuc2Nyb2xsVG9wKGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChzd2l0Y2hNb2RlKG1vZGUpKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZldGNoRW50cmllcygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIG5vdCBhbiBpbnN0YW50IHNlYXJjaCwgdGhlbiB3ZSByZXNldCB0aGUgdmFsdWVzLlxuICAgICAgICAgICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICRzY29wZS5lbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNhbkxvYWRNb3JlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNob3dOb0VudHJpZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcG92ZXIuaGlkZSgpO1xuICAgICAgICB9O1xuICAgICAgICBwb3BvdmVyU2NvcGUuZGF0YSA9IHsgc2VsZWN0ZWRNb2RlOiAnJyB9O1xuICAgICAgICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgnYWRkb25zL21vZF9nbG9zc2FyeS90ZW1wbGF0ZXMvbW9kZV9waWNrZXIuaHRtbCcsIHtcbiAgICAgICAgICAgIHNjb3BlOiBwb3BvdmVyU2NvcGVcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihwbykge1xuICAgICAgICAgICAgcG9wb3ZlciA9IHBvO1xuICAgICAgICB9KTtcbiAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHBvcG92ZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICBwb3BvdmVyU2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJlcGFyaW5nIHRoZSBpbml0aWFsIG1vZGUuXG4gICAgICAgIHN3aXRjaE1vZGUoKTtcblxuICAgICAgICAvLyBEbyBub3QgcmV0dXJuIHRoZSBwcm9taXNlIGhlcmUsIHRoZSBlcnJvciBtb2RhbCBpcyBhbHJlYWR5IGhhbmRsZWQuXG4gICAgICAgIGZldGNoRW50cmllcygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBBZnRlciBhIHN1Y2Nlc3NmdWwgZmV0Y2gsIHRoZSBnbG9zc2FyeSBjYW4gYmUgY29uc2lkZXJlZCBhcyAndmlld2VkJy5cbiAgICAgICAgICAgICRtbWFNb2RHbG9zc2FyeS5sb2dWaWV3KGdsb3NzYXJ5LmlkLCB2aWV3TW9kZSk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfZ2xvc3NhcnkuZXJyb3Jsb2FkaW5nZ2xvc3NhcnknLCB0cnVlKTtcbiAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBDb250cm9sbGVyIGxpYnJhcnkuXG4gICAgZnVuY3Rpb24gZmV0Y2hFbnRyaWVzKGFwcGVuZCkge1xuICAgICAgICBpZiAoIWFwcGVuZCkge1xuICAgICAgICAgICAgbGltaXRGcm9tID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IGFuZ3VsYXIuZXh0ZW5kKFtdLCBmZXRjaEFyZ3VtZW50cyk7XG4gICAgICAgIGFyZ3MucHVzaChsaW1pdEZyb20pO1xuICAgICAgICBhcmdzLnB1c2gobGltaXROdW0pO1xuXG4gICAgICAgIHJldHVybiBmZXRjaEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmVudHJpZXMgPSAkc2NvcGUuZW50cmllcy5jb25jYXQocmVzdWx0LmVudHJpZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZW50cmllcyA9IHJlc3VsdC5lbnRyaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLmNhbkxvYWRNb3JlID0gKGxpbWl0RnJvbSArIGxpbWl0TnVtKSA8IHJlc3VsdC5jb3VudDtcbiAgICAgICAgICAgICRzY29wZS5zaG93Tm9FbnRyaWVzID0gcmVzdWx0LmNvdW50IDw9IDA7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9nbG9zc2FyeS5lcnJvcmxvYWRpbmdlbnRyaWVzJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hFbnRyaWVzKCkge1xuICAgICAgICBpZiAoZmV0Y2hNb2RlID09ICdzZWFyY2gnICYmICEkc2NvcGUuc2VhcmNoUXVlcnkpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBzZWFyY2ggbW9kZSB0aGF0IGlzIG5vdCBzZXQgeWV0LlxuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IGFuZ3VsYXIuZXh0ZW5kKFtdLCBmZXRjaEFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBmZXRjaEludmFsaWRhdGUuYXBwbHkodGhpcywgYXJncykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxpbWl0RnJvbSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hFbnRyaWVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRNb3JlRW50cmllcygpIHtcbiAgICAgICAgbGltaXRGcm9tICs9IGxpbWl0TnVtO1xuICAgICAgICByZXR1cm4gZmV0Y2hFbnRyaWVzKHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN3aXRjaE1vZGUobW9kZSkge1xuICAgICAgICBpZiAobW9kZSA9PSBmZXRjaE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnN0YW50RmV0Y2ggPSB0cnVlO1xuICAgICAgICBmZXRjaE1vZGUgPSBtb2RlO1xuICAgICAgICAkc2NvcGUuaXNTZWFyY2ggPSBmYWxzZTtcblxuICAgICAgICAvLyBCcm93c2UgYnkgYXV0aG9yLlxuICAgICAgICBpZiAobW9kZSA9PSAnYXV0aG9yX2FsbCcpIHtcbiAgICAgICAgICAgIHZpZXdNb2RlID0gJ2F1dGhvcic7XG4gICAgICAgICAgICBmZXRjaEZ1bmN0aW9uID0gJG1tYU1vZEdsb3NzYXJ5LmdldEVudHJpZXNCeUF1dGhvcjtcbiAgICAgICAgICAgIGZldGNoSW52YWxpZGF0ZSA9ICRtbWFNb2RHbG9zc2FyeS5pbnZhbGlkYXRlRW50cmllc0J5QXV0aG9yO1xuICAgICAgICAgICAgZmV0Y2hBcmd1bWVudHMgPSBbZ2xvc3NhcnkuaWQsICdBTEwnLCAnTEFTVE5BTUUnLCAnQVNDJ107XG4gICAgICAgICAgICAkc2NvcGUuZ2V0RGl2aWRlciA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnVzZXJmdWxsbmFtZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0RpdmlkZXIgPSBmdW5jdGlvbihlbnRyeSwgcHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByZXZpb3VzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnVzZXJpZCAhPSBwcmV2aW91cy51c2VyaWQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIE5ld2VzdCBmaXJzdC5cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09ICduZXdlc3RfZmlyc3QnKSB7XG4gICAgICAgICAgICB2aWV3TW9kZSA9ICdkYXRlJztcbiAgICAgICAgICAgIGZldGNoRnVuY3Rpb24gPSAkbW1hTW9kR2xvc3NhcnkuZ2V0RW50cmllc0J5RGF0ZTtcbiAgICAgICAgICAgIGZldGNoSW52YWxpZGF0ZSA9ICRtbWFNb2RHbG9zc2FyeS5pbnZhbGlkYXRlRW50cmllc0J5RGF0ZTtcbiAgICAgICAgICAgIGZldGNoQXJndW1lbnRzID0gW2dsb3NzYXJ5LmlkLCAnQ1JFQVRJT04nLCAnREVTQyddO1xuICAgICAgICAgICAgJHNjb3BlLmdldERpdmlkZXIgPSBub29wO1xuICAgICAgICAgICAgJHNjb3BlLnNob3dEaXZpZGVyID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcblxuICAgICAgICAvLyBSZWNlbnRseSB1cGRhdGVkLlxuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ3JlY2VudGx5X3VwZGF0ZWQnKSB7XG4gICAgICAgICAgICB2aWV3TW9kZSA9ICdkYXRlJztcbiAgICAgICAgICAgIGZldGNoRnVuY3Rpb24gPSAkbW1hTW9kR2xvc3NhcnkuZ2V0RW50cmllc0J5RGF0ZTtcbiAgICAgICAgICAgIGZldGNoSW52YWxpZGF0ZSA9ICRtbWFNb2RHbG9zc2FyeS5pbnZhbGlkYXRlRW50cmllc0J5RGF0ZTtcbiAgICAgICAgICAgIGZldGNoQXJndW1lbnRzID0gW2dsb3NzYXJ5LmlkLCAnVVBEQVRFJywgJ0RFU0MnXTtcbiAgICAgICAgICAgICRzY29wZS5nZXREaXZpZGVyID0gbm9vcDtcbiAgICAgICAgICAgICRzY29wZS5zaG93RGl2aWRlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbiAgICAgICAgLy8gU2VhcmNoIGZvciBlbnRyaWVzLlxuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ3NlYXJjaCcpIHtcbiAgICAgICAgICAgIHZpZXdNb2RlID0gJ3NlYXJjaCc7XG4gICAgICAgICAgICBmZXRjaEZ1bmN0aW9uID0gJG1tYU1vZEdsb3NzYXJ5LmdldEVudHJpZXNCeVNlYXJjaDtcbiAgICAgICAgICAgIGZldGNoSW52YWxpZGF0ZSA9ICRtbWFNb2RHbG9zc2FyeS5pbnZhbGlkYXRlRW50cmllc0J5U2VhcmNoO1xuICAgICAgICAgICAgZmV0Y2hBcmd1bWVudHMgPSBmYWxzZTsgLy8gRHluYW1pY2FsbHkgc2V0IGxhdGVyLlxuICAgICAgICAgICAgJHNjb3BlLmlzU2VhcmNoID0gdHJ1ZTtcbiAgICAgICAgICAgICRzY29wZS5nZXREaXZpZGVyID0gbm9vcDtcbiAgICAgICAgICAgICRzY29wZS5zaG93RGl2aWRlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICAgICAgICBpbnN0YW50RmV0Y2ggPSBmYWxzZTtcblxuICAgICAgICAvLyBDb25zaWRlciBpdCBpcyAnbGV0dGVyX2FsbCcuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWV3TW9kZSA9ICdsZXR0ZXInO1xuICAgICAgICAgICAgZmV0Y2hNb2RlID0gJ2xldHRlcl9hbGwnO1xuICAgICAgICAgICAgZmV0Y2hGdW5jdGlvbiA9ICRtbWFNb2RHbG9zc2FyeS5nZXRFbnRyaWVzQnlMZXR0ZXI7XG4gICAgICAgICAgICBmZXRjaEludmFsaWRhdGUgPSAkbW1hTW9kR2xvc3NhcnkuaW52YWxpZGF0ZUVudHJpZXNCeUxldHRlcjtcbiAgICAgICAgICAgIGZldGNoQXJndW1lbnRzID0gW2dsb3NzYXJ5LmlkLCAnQUxMJ107XG4gICAgICAgICAgICAkc2NvcGUuZ2V0RGl2aWRlciA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmNvbmNlcHQuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJHNjb3BlLnNob3dEaXZpZGVyID0gZnVuY3Rpb24oZW50cnksIHByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2aW91cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkc2NvcGUuZ2V0RGl2aWRlcihlbnRyeSkgIT0gJHNjb3BlLmdldERpdmlkZXIocHJldmlvdXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnN0YW50RmV0Y2g7XG4gICAgfVxufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfZ2xvc3NhcnknKVxuXG4vKipcbiAqIEdsb3NzYXJ5IHNlcnZpY2UuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEdsb3NzYXJ5XG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kR2xvc3NhcnknLCBmdW5jdGlvbigkbW1TaXRlLCAkcSwgJG1tU2l0ZXNNYW5hZ2VyKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY291cnNlIGdsb3NzYXJ5IGNhY2hlIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlSWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjX2dldENvdXJzZUdsb3NzYXJpZXNDYWNoZUtleVxuICAgICAqL1xuICAgIHNlbGYuX2dldENvdXJzZUdsb3NzYXJpZXNDYWNoZUtleSA9IGZ1bmN0aW9uKGNvdXJzZUlkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kR2xvc3Nhcnk6Y291cnNlR2xvc3NhcmllczonICsgY291cnNlSWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIGdsb3NzYXJpZXMgaW4gYSBjb3Vyc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZUlkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gcmVzb2x2ZWQgd2l0aCB0aGUgZ2xvc3Nhcmllc1xuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjZ2V0Q291cnNlR2xvc3Nhcmllc1xuICAgICAqL1xuICAgIHNlbGYuZ2V0Q291cnNlR2xvc3NhcmllcyA9IGZ1bmN0aW9uKGNvdXJzZUlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY291cnNlaWRzOiBbY291cnNlSWRdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogc2VsZi5fZ2V0Q291cnNlR2xvc3Nhcmllc0NhY2hlS2V5KGNvdXJzZUlkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX2dsb3NzYXJ5X2dldF9nbG9zc2FyaWVzX2J5X2NvdXJzZXMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmdsb3NzYXJpZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvdXJzZSBnbG9zc2FyeSBjYWNoZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZUlkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5nZG9jICBtZXRob2RcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmFtZSAgICRtbWFNb2RHbG9zc2FyeSNpbnZhbGlkYXRlQ291cnNlR2xvc3Nhcmllc1xuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUNvdXJzZUdsb3NzYXJpZXMgPSBmdW5jdGlvbihjb3Vyc2VJZCkge1xuICAgICAgICB2YXIga2V5ID0gc2VsZi5fZ2V0Q291cnNlR2xvc3Nhcmllc0NhY2hlS2V5KGNvdXJzZUlkKTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoa2V5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlbnRyaWVzIGJ5IGF1dGhvciBjYWNoZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdsb3NzYXJ5SWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGxldHRlclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmllbGRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNvcnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjX2dldEVudHJpZXNCeUF1dGhvckNhY2hlS2V5XG4gICAgICovXG4gICAgc2VsZi5fZ2V0RW50cmllc0J5QXV0aG9yQ2FjaGVLZXkgPSBmdW5jdGlvbihnbG9zc2FyeUlkLCBsZXR0ZXIsIGZpZWxkLCBzb3J0KSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kR2xvc3Nhcnk6ZW50cmllc0J5QXV0aG9yOicgKyBnbG9zc2FyeUlkICsgXCI6XCIgKyBsZXR0ZXIgKyBcIjpcIiArIGZpZWxkICsgXCI6XCIgKyBzb3J0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZW50cmllcyBieSBhdXRob3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdsb3NzYXJ5SWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGxldHRlclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmllbGRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNvcnRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZyb21cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbWl0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2dldEVudHJpZXNCeUF1dGhvclxuICAgICAqL1xuICAgIHNlbGYuZ2V0RW50cmllc0J5QXV0aG9yID0gZnVuY3Rpb24oZ2xvc3NhcnlJZCwgbGV0dGVyLCBmaWVsZCwgc29ydCwgZnJvbSwgbGltaXQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBpZDogZ2xvc3NhcnlJZCxcbiAgICAgICAgICAgICAgICBsZXR0ZXI6IGxldHRlcixcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgc29ydDogc29ydCxcbiAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgICAgIGxpbWl0OiBsaW1pdFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IHNlbGYuX2dldEVudHJpZXNCeUF1dGhvckNhY2hlS2V5KGdsb3NzYXJ5SWQsIGxldHRlciwgZmllbGQsIHNvcnQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9nbG9zc2FyeV9nZXRfZW50cmllc19ieV9hdXRob3InLCBwYXJhbXMsIHByZVNldHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGNhY2hlIG9mIGVudHJpZXMgYnkgYXV0aG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBnbG9zc2FyeUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBsZXR0ZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpZWxkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzb3J0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2ludmFsaWRhdGVFbnRyaWVzQnlBdXRob3JcbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVFbnRyaWVzQnlBdXRob3IgPSBmdW5jdGlvbihnbG9zc2FyeUlkLCBsZXR0ZXIsIGZpZWxkLCBzb3J0KSB7XG4gICAgICAgIHZhciBrZXkgPSBzZWxmLl9nZXRFbnRyaWVzQnlBdXRob3JDYWNoZUtleShnbG9zc2FyeUlkLCBsZXR0ZXIsIGZpZWxkLCBzb3J0KTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoa2V5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlbnRyaWVzIGJ5IGRhdGUgY2FjaGUga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBnbG9zc2FyeUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBvcmRlclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc29ydFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5nZG9jICBtZXRob2RcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmFtZSAgICRtbWFNb2RHbG9zc2FyeSNfZ2V0RW50cmllc0J5RGF0ZUNhY2hlS2V5XG4gICAgICovXG4gICAgc2VsZi5fZ2V0RW50cmllc0J5RGF0ZUNhY2hlS2V5ID0gZnVuY3Rpb24oZ2xvc3NhcnlJZCwgb3JkZXIsIHNvcnQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RHbG9zc2FyeTplbnRyaWVzQnlEYXRlOicgKyBnbG9zc2FyeUlkICsgXCI6XCIgKyBvcmRlciArIFwiOlwiICsgc29ydDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGVudHJpZXMgYnkgZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZ2xvc3NhcnlJZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gb3JkZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNvcnRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZyb21cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbWl0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2dldEVudHJpZXNCeURhdGVcbiAgICAgKi9cbiAgICBzZWxmLmdldEVudHJpZXNCeURhdGUgPSBmdW5jdGlvbihnbG9zc2FyeUlkLCBvcmRlciwgc29ydCwgZnJvbSwgbGltaXQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBpZDogZ2xvc3NhcnlJZCxcbiAgICAgICAgICAgICAgICBvcmRlcjogb3JkZXIsXG4gICAgICAgICAgICAgICAgc29ydDogc29ydCxcbiAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgICAgIGxpbWl0OiBsaW1pdFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IHNlbGYuX2dldEVudHJpZXNCeURhdGVDYWNoZUtleShnbG9zc2FyeUlkLCBvcmRlciwgc29ydClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX2dsb3NzYXJ5X2dldF9lbnRyaWVzX2J5X2RhdGUnLCBwYXJhbXMsIHByZVNldHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGNhY2hlIG9mIGVudHJpZXMgYnkgZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZ2xvc3NhcnlJZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbGV0dGVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBmaWVsZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQG5nZG9jICBtZXRob2RcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmFtZSAgICRtbWFNb2RHbG9zc2FyeSNpbnZhbGlkYXRlRW50cmllc0J5RGF0ZVxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUVudHJpZXNCeURhdGUgPSBmdW5jdGlvbihnbG9zc2FyeUlkLCBvcmRlciwgc29ydCkge1xuICAgICAgICB2YXIga2V5ID0gc2VsZi5fZ2V0RW50cmllc0J5RGF0ZUNhY2hlS2V5KGdsb3NzYXJ5SWQsIG9yZGVyLCBzb3J0KTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoa2V5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlbnRyaWVzIGJ5IGxldHRlciBjYWNoZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdsb3NzYXJ5SWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGxldHRlclxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5nZG9jICBtZXRob2RcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmFtZSAgICRtbWFNb2RHbG9zc2FyeSNfZ2V0RW50cmllc0J5TGV0dGVyQ2FjaGVLZXlcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRFbnRyaWVzQnlMZXR0ZXJDYWNoZUtleSA9IGZ1bmN0aW9uKGdsb3NzYXJ5SWQsIGxldHRlcikge1xuICAgICAgICByZXR1cm4gJ21tYU1vZEdsb3NzYXJ5OmVudHJpZXNCeUxldHRlcjonICsgZ2xvc3NhcnlJZCArIFwiOlwiICsgbGV0dGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZW50cmllcyBieSBsZXR0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdsb3NzYXJ5SWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGxldHRlclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZnJvbVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGltaXRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjZ2V0RW50cmllc0J5TGV0dGVyXG4gICAgICovXG4gICAgc2VsZi5nZXRFbnRyaWVzQnlMZXR0ZXIgPSBmdW5jdGlvbihnbG9zc2FyeUlkLCBsZXR0ZXIsIGZyb20sIGxpbWl0KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGdsb3NzYXJ5SWQsXG4gICAgICAgICAgICAgICAgbGV0dGVyOiBsZXR0ZXIsXG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICBsaW1pdDogbGltaXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBzZWxmLl9nZXRFbnRyaWVzQnlMZXR0ZXJDYWNoZUtleShnbG9zc2FyeUlkLCBsZXR0ZXIpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9nbG9zc2FyeV9nZXRfZW50cmllc19ieV9sZXR0ZXInLCBwYXJhbXMsIHByZVNldHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGNhY2hlIG9mIGVudHJpZXMgYnkgbGV0dGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBnbG9zc2FyeUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBsZXR0ZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjaW52YWxpZGF0ZUVudHJpZXNCeUxldHRlclxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUVudHJpZXNCeUxldHRlciA9IGZ1bmN0aW9uKGdsb3NzYXJ5SWQsIGxldHRlcikge1xuICAgICAgICB2YXIga2V5ID0gc2VsZi5fZ2V0RW50cmllc0J5TGV0dGVyQ2FjaGVLZXkoZ2xvc3NhcnlJZCwgbGV0dGVyKTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoa2V5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlbnRyaWVzIGJ5IHNlYXJjaCBjYWNoZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdsb3NzYXJ5SWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHF1ZXJ5XG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gZnVsbHNlYXJjaFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gb3JkZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNvcnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjX2dldEVudHJpZXNCeVNlYXJjaENhY2hlS2V5XG4gICAgICovXG4gICAgc2VsZi5fZ2V0RW50cmllc0J5U2VhcmNoQ2FjaGVLZXkgPSBmdW5jdGlvbihnbG9zc2FyeUlkLCBxdWVyeSwgZnVsbHNlYXJjaCwgb3JkZXIsIHNvcnQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RHbG9zc2FyeTplbnRyaWVzQnlTZWFyY2g6JyArIGdsb3NzYXJ5SWQgKyBcIjpcIiArIGZ1bGxzZWFyY2ggKyBcIjpcIiArIG9yZGVyICsgXCI6XCIgKyBzb3J0ICsgXCI6XCIgKyBxdWVyeTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGVudHJpZXMgYnkgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBnbG9zc2FyeUlkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBxdWVyeVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGZ1bGxzZWFyY2hcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG9yZGVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzb3J0XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcm9tXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsaW1pdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQG5nZG9jICBtZXRob2RcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmFtZSAgICRtbWFNb2RHbG9zc2FyeSNnZXRFbnRyaWVzQnlTZWFyY2hcbiAgICAgKi9cbiAgICBzZWxmLmdldEVudHJpZXNCeVNlYXJjaCA9IGZ1bmN0aW9uKGdsb3NzYXJ5SWQsIHF1ZXJ5LCBmdWxsc2VhcmNoLCBvcmRlciwgc29ydCwgZnJvbSwgbGltaXQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBpZDogZ2xvc3NhcnlJZCxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgZnVsbHNlYXJjaDogZnVsbHNlYXJjaCxcbiAgICAgICAgICAgICAgICBvcmRlcjogb3JkZXIsXG4gICAgICAgICAgICAgICAgc29ydDogc29ydCxcbiAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgICAgIGxpbWl0OiBsaW1pdFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IHNlbGYuX2dldEVudHJpZXNCeVNlYXJjaENhY2hlS2V5KGdsb3NzYXJ5SWQsIHF1ZXJ5LCBmdWxsc2VhcmNoLCBvcmRlciwgc29ydClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX2dsb3NzYXJ5X2dldF9lbnRyaWVzX2J5X3NlYXJjaCcsIHBhcmFtcywgcHJlU2V0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgY2FjaGUgb2YgZW50cmllcyBieSBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdsb3NzYXJ5SWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHF1ZXJ5XG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gZnVsbHNlYXJjaFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gb3JkZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNvcnRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjaW52YWxpZGF0ZUVudHJpZXNCeVNlYXJjaFxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUVudHJpZXNCeVNlYXJjaCA9IGZ1bmN0aW9uKGdsb3NzYXJ5SWQsIHF1ZXJ5LCBmdWxsc2VhcmNoLCBvcmRlciwgc29ydCkge1xuICAgICAgICB2YXIga2V5ID0gc2VsZi5fZ2V0RW50cmllc0J5U2VhcmNoQ2FjaGVLZXkoZ2xvc3NhcnlJZCwgcXVlcnksIGZ1bGxzZWFyY2gsIG9yZGVyLCBzb3J0KTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoa2V5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIGVudHJ5IGJ5IElEIGNhY2hlIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjX2dldEVudHJ5Q2FjaGVLZXlcbiAgICAgKi9cbiAgICBzZWxmLl9nZXRFbnRyeUNhY2hlS2V5ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RHbG9zc2FyeTpnZXRFbnRyeTonICsgaWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBvbmUgZW50cnkgYnkgSUQuXG4gICAgICpcbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2dldEVudHJ5XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAgICAgICBFbnRyeSBJRC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGVudHJ5LlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RW50cnkgPSBmdW5jdGlvbihpZCwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBzZWxmLl9nZXRFbnRyeUNhY2hlS2V5KGlkKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBzaXRlLnJlYWQoJ21vZF9nbG9zc2FyeV9nZXRfZW50cnlfYnlfaWQnLCBwYXJhbXMsIHByZVNldHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBjYWNoZSBvZiBlbnRyeSBieSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjaW52YWxpZGF0ZUVudHJ5XG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlRW50cnkgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIga2V5ID0gc2VsZi5fZ2V0RW50cnlDYWNoZUtleShpZCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBvbmUgZ2xvc3NhcnkgYnkgY21JRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlSWRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNtaWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBuZ2RvYyAgbWV0aG9kXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5hbWUgICAkbW1hTW9kR2xvc3NhcnkjZ2V0R2xvc3NhcnlcbiAgICAgKi9cbiAgICBzZWxmLmdldEdsb3NzYXJ5ID0gZnVuY3Rpb24oY291cnNlSWQsIGNtaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Q291cnNlR2xvc3Nhcmllcyhjb3Vyc2VJZCkudGhlbihmdW5jdGlvbihnbG9zc2FyaWVzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZ2xvc3NhcmllcywgZnVuY3Rpb24oZ2xvc3NhcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2xvc3NhcnkuY291cnNlbW9kdWxlID09IGNtaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2xvc3Nhcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IG9uZSBnbG9zc2FyeSBieSBnbG9zc2FyeSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlSWRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAbmdkb2MgIG1ldGhvZFxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuYW1lICAgJG1tYU1vZEdsb3NzYXJ5I2dldEdsb3NzYXJ5QnlJZFxuICAgICAqL1xuICAgIHNlbGYuZ2V0R2xvc3NhcnlCeUlkID0gZnVuY3Rpb24oY291cnNlSWQsIGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldENvdXJzZUdsb3NzYXJpZXMoY291cnNlSWQpLnRoZW4oZnVuY3Rpb24oZ2xvc3Nhcmllcykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGdsb3NzYXJpZXMsIGZ1bmN0aW9uKGdsb3NzYXJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGdsb3NzYXJ5LmlkID09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdsb3NzYXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGdsb3NzYXJ5IHBsdWdpbiBpcyBlbmFibGVkIGluIGEgY2VydGFpbiBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RHbG9zc2FyeSNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2FzIGludHJvZHVjZWQgYWxvbmcgd2l0aCBhbGwgdGhlIG90aGVyIHJlcXVpcmVkIG9uZXMuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS53c0F2YWlsYWJsZSgnbW9kX2dsb3NzYXJ5X2dldF9nbG9zc2FyaWVzX2J5X2NvdXJzZXMnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCBhIGdsb3NzYXJ5IGFzIGJlaW5nIHZpZXdlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kR2xvc3NhcnkjbG9nVmlld1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBHbG9zc2FyeSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSBUaGUgbW9kZSBpbiB3aGljaCB0aGUgZ2xvc3Nhcnkgd2FzIHZpZXdlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ1ZpZXcgPSBmdW5jdGlvbihpZCwgbW9kZSkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgbW9kZTogbW9kZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2dsb3NzYXJ5X3ZpZXdfZ2xvc3NhcnknLCBwYXJhbXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgYSBnbG9zc2FyeSBlbnRyeSBhcyBiZWluZyB2aWV3ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfZ2xvc3NhcnlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEdsb3NzYXJ5I2xvZ0VudHJ5Vmlld1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBFbnRyeSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ0VudHJ5VmlldyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBpZDogaWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9nbG9zc2FyeV92aWV3X2VudHJ5JywgcGFyYW1zKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9nbG9zc2FyeScpXG5cbi8qKlxuICogTW9kIGdsb3NzYXJ5IGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RHbG9zc2FyeUhhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kR2xvc3NhcnlIYW5kbGVycycsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tYU1vZEdsb3NzYXJ5LCAkc3RhdGUsICRxLCAkbW1Db250ZW50TGlua3NIZWxwZXIsICRtbVV0aWwsXG4gICAgICAgICAgICAkbW1Db3Vyc2VIZWxwZXIpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9nbG9zc2FyeVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kR2xvc3NhcnlIYW5kbGVycyNjb3Vyc2VDb250ZW50XG4gICAgICovXG4gICAgc2VsZi5jb3Vyc2VDb250ZW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEdsb3NzYXJ5LmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBpbmZvLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYygnZ2xvc3NhcnknKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW9kX2dsb3NzYXJ5Jywge21vZHVsZTogbW9kdWxlLCBjb3Vyc2VpZDogY291cnNlaWR9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2dsb3NzYXJ5XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RHbG9zc2FyeUhhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCB0byBzZWUgZ2xvc3NhcnkgaW5kZXggZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNJbmRleEVuYWJsZWQoc2l0ZUlkLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RHbG9zc2FyeS5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlSWQgfHwgJG1tQ291cnNlLmNhbkdldE1vZHVsZVdpdGhvdXRDb3Vyc2VJZChzaXRlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCB0byBzZWUgZ2xvc3NhcnkgZW50cnkgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbnRyeUVuYWJsZWQoc2l0ZUlkLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RHbG9zc2FyeS5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlSWQgfHwgJG1tQ291cnNlLmNhbkdldE1vZHVsZUJ5SW5zdGFuY2Uoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RW50cnkoZW50cnlJZCwgc2l0ZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEdsb3NzYXJ5LmdldEVudHJ5KGVudHJ5SWQsIHNpdGVJZCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmVudHJ5O1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9nbG9zc2FyeS5lcnJvcmxvYWRpbmdlbnRyeScsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmVhdCBhIGdsb3NzYXJ5IGVudHJ5IGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRyZWF0RW50cnlMaW5rKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSAkbW1VdGlsLmV4dHJhY3RVcmxQYXJhbXModXJsKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZWlkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBmYWxzZSBiZWNhdXNlIGFsbCBzaXRlcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaXRldXJsLlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIuZmlsdGVyU3VwcG9ydGVkU2l0ZXMoc2l0ZUlkcywgaXNFbnRyeUVuYWJsZWQsIGZhbHNlLCBjb3Vyc2VJZCkudGhlbihmdW5jdGlvbihpZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbW0uY29yZS52aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tZXllJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVzOiBpZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyeShwYXJzZUludChwYXJhbXMuZWlkLCAxMCksIHNpdGVJZCkudGhlbihmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihjb3Vyc2VJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gJG1tQ291cnNlSGVscGVyLmdldE1vZHVsZUNvdXJzZUlkQnlJbnN0YW5jZShlbnRyeS5nbG9zc2FyeWlkLCAnZ2xvc3NhcnknLCBzaXRlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oY291cnNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeTogZW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lkOiBjb3Vyc2VJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUNvbnRlbnRMaW5rc0hlbHBlci5nb0luU2l0ZSgnc2l0ZS5tb2RfZ2xvc3NhcnktZW50cnknLCBzdGF0ZVBhcmFtcywgc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSBnbG9zc2FyeSBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy9tb2QvZ2xvc3Nhcnkvdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gR2xvc3NhcnkgaW5kZXguXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNJbmRleEVuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXJsLmluZGV4T2YoJy9tb2QvZ2xvc3Nhcnkvc2hvd2VudHJ5LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBHbG9zc2FyeSBlbnRyeS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJlYXRFbnRyeUxpbmsoc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfaW1zY3AnKVxuXG4vKipcbiAqIElNU0NQIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kSW1zY3BJbmRleEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZEltc2NwSW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbVV0aWwsICRtbWFNb2RJbXNjcCwgJGxvZywgbW1hTW9kSW1zY3BDb21wb25lbnQsXG4gICAgICAgICAgICAkaW9uaWNQb3BvdmVyLCAkdGltZW91dCwgJHEsICRtbUNvdXJzZSwgJG1tQXBwKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tYU1vZEltc2NwSW5kZXhDdHJsJyk7XG5cbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIGN1cnJlbnRJdGVtO1xuXG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbW9kdWxlLmRlc2NyaXB0aW9uO1xuICAgICRzY29wZS5jb21wb25lbnQgPSBtbWFNb2RJbXNjcENvbXBvbmVudDtcbiAgICAkc2NvcGUuY29tcG9uZW50SWQgPSBtb2R1bGUuaWQ7XG4gICAgJHNjb3BlLmV4dGVybmFsVXJsID0gbW9kdWxlLnVybDtcbiAgICAkc2NvcGUubG9hZGVkID0gZmFsc2U7XG5cbiAgICAvLyBJbml0aWFsaXplIGVtcHR5IHByZXZpb3VzL25leHQgdG8gcHJldmVudCBzaG93aW5nIGFycm93cyBmb3IgYW4gaW5zdGFudCBiZWZvcmUgdGhleSdyZSBoaWRkZW4uXG4gICAgJHNjb3BlLnByZXZpb3VzSXRlbSA9ICcnO1xuICAgICRzY29wZS5uZXh0SXRlbSA9ICcnO1xuXG4gICAgJHNjb3BlLml0ZW1zID0gJG1tYU1vZEltc2NwLmNyZWF0ZUl0ZW1MaXN0KG1vZHVsZS5jb250ZW50cyk7XG4gICAgaWYgKCRzY29wZS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgY3VycmVudEl0ZW0gPSAkc2NvcGUuaXRlbXNbMF0uaHJlZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkSXRlbShpdGVtSWQpIHtcbiAgICAgICAgY3VycmVudEl0ZW0gPSBpdGVtSWQ7XG4gICAgICAgICRzY29wZS5wcmV2aW91c0l0ZW0gPSAkbW1hTW9kSW1zY3AuZ2V0UHJldmlvdXNJdGVtKCRzY29wZS5pdGVtcywgaXRlbUlkKTtcbiAgICAgICAgJHNjb3BlLm5leHRJdGVtID0gJG1tYU1vZEltc2NwLmdldE5leHRJdGVtKCRzY29wZS5pdGVtcywgaXRlbUlkKTtcbiAgICAgICAgdmFyIHNyYyA9ICRtbWFNb2RJbXNjcC5nZXRGaWxlU3JjKG1vZHVsZSwgaXRlbUlkKTtcbiAgICAgICAgaWYgKCRzY29wZS5zcmMgJiYgc3JjLnRvU3RyaW5nKCkgPT0gJHNjb3BlLnNyYy50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAvLyBSZS1sb2FkaW5nIHNhbWUgcGFnZS4gU2V0IGl0IHRvIGVtcHR5IGFuZCB0aGVuIHJlLXNldCB0aGUgc3JjIGluIHRoZSBuZXh0IGRpZ2VzdCBzbyBpdCBkZXRlY3RzIGl0IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgJHNjb3BlLnNyYyA9ICcnO1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNyYyA9IHNyYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnNyYyA9IHNyYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZldGNoQ29udGVudCgpIHtcbiAgICAgICAgaWYgKG1vZHVsZS5jb250ZW50cyAmJiBtb2R1bGUuY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZG93bmxvYWRGYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kSW1zY3AuZG93bmxvYWRBbGxDb250ZW50KG1vZHVsZSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFyayBkb3dubG9hZCBhcyBmYWlsZWQgYnV0IGdvIG9uIHNpbmNlIHRoZSBtYWluIGZpbGVzIGNvdWxkIGhhdmUgYmVlbiBkb3dubG9hZGVkLlxuICAgICAgICAgICAgICAgIGRvd25sb2FkRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RJbXNjcC5nZXRJZnJhbWVTcmMobW9kdWxlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkSXRlbShjdXJyZW50SXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkRmFpbGVkICYmICRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCBsb2FkIHRoZSBtYWluIGZpbGUgYnV0IHRoZSBkb3dubG9hZCBmYWlsZWQuIFNob3cgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZ3NvbWVmaWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfaW1zY3AuZGVwbG95bWVudGVycm9yJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9pbXNjcC5kZXBsb3ltZW50ZXJyb3InLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICRzY29wZS5kb1JlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYU1vZEltc2NwLmludmFsaWRhdGVDb250ZW50KG1vZHVsZS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaENvbnRlbnQoKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUubG9hZEl0ZW0gPSBmdW5jdGlvbihpdGVtSWQpIHtcbiAgICAgICAgJHNjb3BlLnBvcG92ZXIuaGlkZSgpO1xuICAgICAgICBsb2FkSXRlbShpdGVtSWQpO1xuICAgIH07XG5cbiAgICAkc2NvcGUuZ2V0TnVtYmVyRm9yUGFkZGluZyA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheShuKTtcbiAgICB9O1xuXG4gICAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ2FkZG9ucy9tb2RfaW1zY3AvdGVtcGxhdGVzL3RvYy5odG1sJywge1xuICAgICAgICBzY29wZTogJHNjb3BlLFxuICAgIH0pLnRoZW4oZnVuY3Rpb24ocG9wb3Zlcikge1xuICAgICAgICAkc2NvcGUucG9wb3ZlciA9IHBvcG92ZXI7XG4gICAgfSk7XG5cbiAgICBmZXRjaENvbnRlbnQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTW9kSW1zY3AubG9nVmlldyhtb2R1bGUuaW5zdGFuY2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfaW1zY3AnKVxuXG4vKipcbiAqIE1vZCBJTVNDUCBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kSW1zY3BIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZEltc2NwSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbWFNb2RJbXNjcCwgJG1tRXZlbnRzLCAkc3RhdGUsICRtbVNpdGUsICRtbVV0aWwsICRtbUZpbGVwb29sLFxuICAgICAgICAgICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSwgbW1Db3JlRG93bmxvYWRpbmcsIG1tQ29yZU5vdERvd25sb2FkZWQsIG1tQ29yZU91dGRhdGVkLCBtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLFxuICAgICAgICAgICAgbW1hTW9kSW1zY3BDb21wb25lbnQsICRtbUNvbnRlbnRMaW5rc0hlbHBlciwgJHEpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3BIYW5kbGVycyNjb3Vyc2VDb250ZW50XG4gICAgICovXG4gICAgc2VsZi5jb3Vyc2VDb250ZW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJG1tYU1vZEltc2NwQ291cnNlQ29udGVudEhhbmRsZXIjaXNFbmFibGVkXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RJbXNjcC5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3BDb3Vyc2VDb250ZW50SGFuZGxlciNnZXRDb250cm9sbGVyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgICBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyk7XG5cbiAgICAgICAgICAgICAgICBkb3dubG9hZEJ0biA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWlvcy1jbG91ZC1kb3dubG9hZC1vdXRsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLmRvd25sb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZEltc2NwLnByZWZldGNoQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tYW5kcm9pZC1yZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLnJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RJbXNjcC5pbnZhbGlkYXRlQ29udGVudChtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZEltc2NwLnByZWZldGNoQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJGRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW0uY29yZS5lcnJvcmRvd25sb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ2ltc2NwJyk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmJ1dHRvbnMgPSBbZG93bmxvYWRCdG4sIHJlZnJlc2hCdG5dO1xuICAgICAgICAgICAgICAgICRzY29wZS5zcGlubmVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW9kX2ltc2NwJywge21vZHVsZTogbW9kdWxlLCBjb3Vyc2VpZDogY291cnNlaWR9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gU2hvdyBidXR0b25zIGFjY29yZGluZyB0byBtb2R1bGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zcGlubmVyID0gc3RhdHVzID09PSBtbUNvcmVEb3dubG9hZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkQnRuLmhpZGRlbiA9IHN0YXR1cyAhPT0gbW1Db3JlTm90RG93bmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4uaGlkZGVuID0gc3RhdHVzICE9PSBtbUNvcmVPdXRkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgY2hhbmdlcyBvbiB0aGlzIG1vZHVsZSBzdGF0dXMuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c09ic2VydmVyID0gJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2l0ZWlkID09PSAkbW1TaXRlLmdldElkKCkgJiYgZGF0YS5jb21wb25lbnRJZCA9PT0gbW9kdWxlLmlkICYmIGRhdGEuY29tcG9uZW50ID09PSBtbWFNb2RJbXNjcENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1N0YXR1cyhkYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IHN0YXR1cyB0byBkZWNpZGUgd2hpY2ggaWNvbiBzaG91bGQgYmUgc2hvd24uXG4gICAgICAgICAgICAgICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5nZXRNb2R1bGVTdGF0dXMobW9kdWxlLCBjb3Vyc2VpZCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCkudGhlbihzaG93U3RhdHVzKTtcblxuICAgICAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c09ic2VydmVyICYmIHN0YXR1c09ic2VydmVyLm9mZiAmJiBzdGF0dXNPYnNlcnZlci5vZmYoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3BIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kSW1zY3AuaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhY3Rpb25zIHRvIHBlcmZvcm0gd2l0aCB0aGUgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhbiBJTVNDUCBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy9tb2QvaW1zY3Avdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfaW1zY3AnKVxuXG4vKipcbiAqIElNU0NQIGZhY3RvcnkuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEltc2NwXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kSW1zY3AnLCBmdW5jdGlvbigkbW1GaWxlcG9vbCwgJG1tU2l0ZSwgJG1tRlMsICRsb2csICRxLCAkc2NlLCAkbW1BcHAsICRtbVNpdGVzTWFuYWdlciwgbW1hTW9kSW1zY3BDb21wb25lbnQpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU1vZEltc2NwJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBjdXJyZW50RGlyUGF0aDsgLy8gRGlyZWN0b3J5IHBhdGggb2YgdGhlIGN1cnJlbnQgSU1TQ1AuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIElNU0NQIHRvYyBhcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3AjZ2V0VG9jXG4gICAgICogQHBhcmFtICB7YXJyYXl9IGNvbnRlbnRzIFRoZSBtb2R1bGUgY29udGVudHMuXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIFRoZSB0b2MuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuZ2V0VG9jID0gZnVuY3Rpb24oY29udGVudHMpIHtcbiAgICAgICAgaWYgKCFjb250ZW50cyB8fCAhY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudHNbMF0uY29udGVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW1zY3AgdG9jIGFzIGFuIGFycmF5IG9mIGl0ZW1zIChubyBuZXN0ZWQpIHRvIGJ1aWxkIHRoZSBuYXZpZ2F0aW9uIHRyZWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwI2NyZWF0ZUl0ZW1MaXN0XG4gICAgICogQHBhcmFtICB7YXJyYXl9IGNvbnRlbnRzIFRoZSBtb2R1bGUgY29udGVudHMuXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIFRoZSB0b2MgYXMgYSBsaXN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLmNyZWF0ZUl0ZW1MaXN0ID0gZnVuY3Rpb24oY29udGVudHMpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIHZhciB0b2MgPSBzZWxmLmdldFRvYyhjb250ZW50cyk7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh0b2MsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtocmVmOiBlbC5ocmVmLCB0aXRsZTogZWwudGl0bGUsIGxldmVsOiBlbC5sZXZlbH0pO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVsLnN1Yml0ZW1zLCBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtocmVmOiBzZWwuaHJlZiwgdGl0bGU6IHNlbC50aXRsZSwgbGV2ZWw6IHNlbC5sZXZlbH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJldmlvdXMgaXRlbSB0byB0aGUgZ2l2ZW4gb25lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNnZXRQcmV2aW91c0l0ZW1cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gaXRlbXMgICAgIFRoZSBpdGVtcyBsaXN0LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gaXRlbUlkICAgVGhlIGN1cnJlbnQgaXRlbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIFRoZSBwcmV2aW91cyBpdGVtIGlkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLmdldFByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uKGl0ZW1zLCBpdGVtSWQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXNbaV0uaHJlZiA9PSBpdGVtSWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzID0gaXRlbXNbaV0uaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IGl0ZW0gdG8gdGhlIGdpdmVuIG9uZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3AjZ2V0TmV4dEl0ZW1cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gaXRlbXMgICAgIFRoZSBpdGVtcyBsaXN0LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gaXRlbUlkICAgVGhlIGN1cnJlbnQgaXRlbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgbmV4dCBpdGVtIGlkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLmdldE5leHRJdGVtID0gZnVuY3Rpb24oaXRlbXMsIGl0ZW1JZCkge1xuICAgICAgICB2YXIgbmV4dCA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGl0ZW1zW2ldLmhyZWYgPT0gaXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtc1tpICsgMV0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGl0ZW1zW2kgKyAxXS5ocmVmO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2Ugc2hvdWxkIG9tbWl0IHRoZSBmaWxlIGRvd25sb2FkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNjaGVja1NwZWNpYWxGaWxlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlTmFtZSBUaGUgZmlsZSBuYW1lXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUgaWYgd2Ugc2hvdWxkIG9tbWl0IHRoZSBmaWxlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuY2hlY2tTcGVjaWFsRmlsZXMgPSBmdW5jdGlvbihmaWxlTmFtZSkge1xuICAgICAgICByZXR1cm4gZmlsZU5hbWUgPT0gJ2ltc21hbmlmZXN0LnhtbCc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGFsbCB0aGUgY29udGVudC4gQWxsIHRoZSBmaWxlcyBhcmUgZG93bmxvYWRlZCBpbnNpZGUgYSBmb2xkZXIgaW4gZmlsZXBvb2wsIGtlZXBpbmcgdGhlaXIgZm9sZGVyIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3AjZG93bmxvYWRBbGxDb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBjb250ZW50IGlzIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYuZG93bmxvYWRBbGxDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMobW9kdWxlKSxcbiAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgIHRpbWVtb2QgPSAkbW1GaWxlcG9vbC5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKTtcblxuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZ2V0RmlsZVBhdGhCeVVybCgkbW1TaXRlLmdldElkKCksIG1vZHVsZS51cmwpLnRoZW4oZnVuY3Rpb24oZGlyUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmRvd25sb2FkUGFja2FnZSgkbW1TaXRlLmdldElkKCksIGZpbGVzLCBtbWFNb2RJbXNjcENvbXBvbmVudCwgbW9kdWxlLmlkLCByZXZpc2lvbiwgdGltZW1vZCwgZGlyUGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlcyB0aGF0IGNhbiBiZSBkb3dubG9hZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNnZXREb3dubG9hZGFibGVGaWxlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7T2JqZWN0W119ICAgICBMaXN0IG9mIGZpbGVzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gW107XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZHVsZS5jb250ZW50cywgZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgZmlsZXMucHVzaChjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXZlbnQgbmFtZXMgb2YgZmlsZXMgYmVpbmcgZG93bmxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3AjZ2V0RG93bmxvYWRpbmdGaWxlc0V2ZW50TmFtZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZGluZ0ZpbGVzRXZlbnROYW1lcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgIGV2ZW50TmFtZXMgPSBbXSxcbiAgICAgICAgICAgIHNpdGVpZCA9ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gY29udGVudC5maWxldXJsO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzRmlsZURvd25sb2FkYWJsZShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tRmlsZXBvb2wuaXNGaWxlRG93bmxvYWRpbmdCeVVybChzaXRlaWQsIHVybCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZ2V0RmlsZUV2ZW50TmFtZUJ5VXJsKHNpdGVpZCwgdXJsKS50aGVuKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWVzLnB1c2goZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBmYWlscy5cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE5hbWVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZmlsZSBldmVudCBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3AjZ2V0RmlsZUV2ZW50TmFtZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhcnJheSBvZiAkbW1FdmVudCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVFdmVudE5hbWVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gY29udGVudC5maWxldXJsO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzRmlsZURvd25sb2FkYWJsZShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1GaWxlcG9vbC5nZXRGaWxlRXZlbnROYW1lQnlVcmwoJG1tU2l0ZS5nZXRJZCgpLCB1cmwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oZXZlbnROYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGZpbGVwYXRoLCBnZXQgYSBjZXJ0YWluIGZpbGV1cmwgZnJvbSBtb2R1bGUgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBjb250ZW50cyAgICAgTW9kdWxlIGNvbnRlbnRzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRGaWxlcGF0aCBGaWxlcGF0aCBvZiB0aGUgc2VhcmNoZWQgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgRmlsZXVybC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VsZi5fZ2V0RmlsZVVybEZyb21Db250ZW50cyA9IGZ1bmN0aW9uKGNvbnRlbnRzLCB0YXJnZXRGaWxlcGF0aCkge1xuICAgICAgICB2YXIgaW5kZXhVcmw7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250ZW50cywgZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PSAnZmlsZScgJiYgIWluZGV4VXJsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVwYXRoID0gJG1tRlMuY29uY2F0ZW5hdGVQYXRocyhjb250ZW50LmZpbGVwYXRoLCBjb250ZW50LmZpbGVuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGhhbHQgPSBmaWxlcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IGZpbGVwYXRoLnN1YnN0cigxKSA6ICcvJyArIGZpbGVwYXRoO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgbWFpbiBmaWxlLlxuICAgICAgICAgICAgICAgIGlmIChmaWxlcGF0aCA9PT0gdGFyZ2V0RmlsZXBhdGggfHwgZmlsZXBhdGhhbHQgPT09IHRhcmdldEZpbGVwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4VXJsID0gY29udGVudC5maWxldXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbmRleFVybDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgYWxsIHRoZSBmaWxlcyBuZWVkZWQgYW5kIHJldHVybnMgdGhlIHNyYyBvZiB0aGUgaWZyYW1lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNnZXRJZnJhbWVTcmNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBpZnJhbWUgc3JjLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0SWZyYW1lU3JjID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciB0b2MgPSBzZWxmLmdldFRvYyhtb2R1bGUuY29udGVudHMpLFxuICAgICAgICAgICAgbWFpbkZpbGVQYXRoO1xuICAgICAgICBpZiAoIXRvYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBtYWluRmlsZVBhdGggPSB0b2NbMF0uaHJlZjtcblxuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZ2V0RGlyZWN0b3J5VXJsQnlVcmwoJG1tU2l0ZS5nZXRJZCgpLCBtb2R1bGUudXJsKS50aGVuKGZ1bmN0aW9uKGRpclBhdGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnREaXJQYXRoID0gZGlyUGF0aDtcbiAgICAgICAgICAgIC8vIFRoaXMgVVJMIGlzIGdvaW5nIHRvIGJlIGluamVjdGVkIGluIGFuIGlmcmFtZSwgd2UgbmVlZCB0cnVzdEFzUmVzb3VyY2VVcmwgdG8gbWFrZSBpdCB3b3JrIGluIGEgYnJvd3Nlci5cbiAgICAgICAgICAgIHJldHVybiAkc2NlLnRydXN0QXNSZXNvdXJjZVVybCgkbW1GUy5jb25jYXRlbmF0ZVBhdGhzKGRpclBhdGgsIG1haW5GaWxlUGF0aCkpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEVycm9yIGdldHRpbmcgZGlyZWN0b3J5LCB0aGVyZSB3YXMgYW4gZXJyb3IgZG93bmxvYWRpbmcgb3Igd2UncmUgaW4gYnJvd3Nlci4gUmV0dXJuIG9ubGluZSBVUkwgaWYgY29ubmVjdGVkLlxuICAgICAgICAgICAgaWYgKCRtbUFwcC5pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4VXJsID0gc2VsZi5fZ2V0RmlsZVVybEZyb21Db250ZW50cyhtb2R1bGUuY29udGVudHMsIG1haW5GaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgVVJMIGlzIGdvaW5nIHRvIGJlIGluamVjdGVkIGluIGFuIGlmcmFtZSwgd2UgbmVlZCB0aGlzIHRvIG1ha2UgaXQgd29yay5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKCRtbVNpdGUuZml4UGx1Z2luZmlsZVVSTChpbmRleFVybCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBzcmMgb2YgYSBpbXNjcCBpdGVtLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNnZXRGaWxlU3JjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSAgICBUaGUgbW9kdWxlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbUlkICAgIEl0ZW0gdG8gZ2V0IHRoZSBzcmMuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICBJdGVtIHNyYy5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVTcmMgPSBmdW5jdGlvbihtb2R1bGUsIGl0ZW1JZCkge1xuICAgICAgICBpZiAoY3VycmVudERpclBhdGgpIHtcbiAgICAgICAgICAgIC8vIElNU0NQIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAgICAgICAgICAvLyBUaGlzIFVSTCBpcyBnb2luZyB0byBiZSBpbmplY3RlZCBpbiBhbiBpZnJhbWUsIHdlIG5lZWQgdHJ1c3RBc1Jlc291cmNlVXJsIHRvIG1ha2UgaXQgd29yayBpbiBhIGJyb3dzZXIuXG4gICAgICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzUmVzb3VyY2VVcmwoJG1tRlMuY29uY2F0ZW5hdGVQYXRocyhjdXJyZW50RGlyUGF0aCwgaXRlbUlkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFcnJvciBsb2FkaW5nIElNU0NQLiBMZXQncyBnZXQgb25saW5lIFVSTC5cbiAgICAgICAgICAgIGlmICgkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleFVybCA9IHNlbGYuX2dldEZpbGVVcmxGcm9tQ29udGVudHMobW9kdWxlLmNvbnRlbnRzLCBpdGVtSWQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleFVybCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIFVSTCBpcyBnb2luZyB0byBiZSBpbmplY3RlZCBpbiBhbiBpZnJhbWUsIHdlIG5lZWQgdGhpcyB0byBtYWtlIGl0IHdvcmsuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkc2NlLnRydXN0QXNSZXNvdXJjZVVybCgkbW1TaXRlLmZpeFBsdWdpbmZpbGVVUkwoaW5kZXhVcmwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSB0aGUgcHJlZmV0Y2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNpbnZhbGlkYXRlQ29udGVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb2R1bGVJZCBUaGUgbW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQ29udGVudCA9IGZ1bmN0aW9uKG1vZHVsZUlkKSB7XG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5pbnZhbGlkYXRlRmlsZXNCeUNvbXBvbmVudCgkbW1TaXRlLmdldElkKCksIG1tYU1vZEltc2NwQ29tcG9uZW50LCBtb2R1bGVJZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgZmlsZSBpcyBkb3dubG9hZGFibGUuIFRoZSBmaWxlIHBhcmFtIG11c3QgaGF2ZSAndHlwZScgYW5kICdmaWxlbmFtZScgYXR0cmlidXRlc1xuICAgICAqIGxpa2UgaW4gY29yZV9jb3Vyc2VfZ2V0X2NvbnRlbnRzIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcCNpc0ZpbGVEb3dubG9hZGFibGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZSBGaWxlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIFRydWUgaWYgZG93bmxvYWRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgIHJldHVybiBmaWxlLnR5cGUgPT09ICdmaWxlJyAmJiAhc2VsZi5jaGVja1NwZWNpYWxGaWxlcyhmaWxlLmZpbGVuYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaXMgZW5hYmxlZCBpbiBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3AjaXNQbHVnaW5FbmFibGVkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IHNpdGUuZ2V0SW5mbygpLnZlcnNpb247XG4gICAgICAgICAgICAvLyBSZXF1aXJlIE1vb2RsZSAyLjkuXG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbiAmJiAocGFyc2VJbnQodmVyc2lvbikgPj0gMjAxNTA1MTEwMCkgJiYgc2l0ZS5jYW5Eb3dubG9hZEZpbGVzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgYSBJTVNDUCBhcyBiZWluZyB2aWV3ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwI2xvZ1ZpZXdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgTW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ1ZpZXcgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaW1zY3BpZDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX2ltc2NwX3ZpZXdfaW1zY3AnLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlZmV0Y2ggdGhlIGNvbnRlbnQuIEFsbCB0aGUgZmlsZXMgYXJlIGRvd25sb2FkZWQgaW5zaWRlIGEgZm9sZGVyIGluIGZpbGVwb29sLCBrZWVwaW5nIHRoZWlyIGZvbGRlciBzdHJ1Y3R1cmUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfaW1zY3BcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEltc2NwI3ByZWZldGNoQ29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gY29udGVudCBpcyBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoQ29udGVudCA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBzZWxmLmdldERvd25sb2FkYWJsZUZpbGVzKG1vZHVsZSksXG4gICAgICAgICAgICByZXZpc2lvbiA9ICRtbUZpbGVwb29sLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyksXG4gICAgICAgICAgICB0aW1lbW9kID0gJG1tRmlsZXBvb2wuZ2V0VGltZW1vZGlmaWVkRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyk7XG5cbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmdldEZpbGVQYXRoQnlVcmwoJG1tU2l0ZS5nZXRJZCgpLCBtb2R1bGUudXJsKS50aGVuKGZ1bmN0aW9uKGRpclBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5wcmVmZXRjaFBhY2thZ2UoJG1tU2l0ZS5nZXRJZCgpLCBmaWxlcywgbW1hTW9kSW1zY3BDb21wb25lbnQsIG1vZHVsZS5pZCwgcmV2aXNpb24sIHRpbWVtb2QsIGRpclBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9pbXNjcCcpXG5cbi8qKlxuICogTW9kIGltc2NwIHByZWZldGNoIGhhbmRsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZEltc2NwUHJlZmV0Y2hIYW5kbGVyXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kSW1zY3BQcmVmZXRjaEhhbmRsZXInLCBmdW5jdGlvbigkbW1hTW9kSW1zY3AsIG1tYU1vZEltc2NwQ29tcG9uZW50KSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgc2VsZi5jb21wb25lbnQgPSBtbWFNb2RJbXNjcENvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG93bmxvYWQgc2l6ZSBvZiBhIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3BQcmVmZXRjaEhhbmRsZXIjZ2V0RG93bmxvYWRTaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBNb2R1bGUgdG8gZ2V0IHRoZSBzaXplLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgU2l6ZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkU2l6ZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2R1bGUuY29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICgkbW1hTW9kSW1zY3AuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpICYmIGNvbnRlbnQuZmlsZXNpemUpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gc2l6ZSArIGNvbnRlbnQuZmlsZXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9pbXNjcFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kSW1zY3BQcmVmZXRjaEhhbmRsZXIjaXNFbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZEltc2NwLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCB0aGUgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2ltc2NwXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RJbXNjcFByZWZldGNoSGFuZGxlciNwcmVmZXRjaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGZpbGVzIGhhdmUgYmVlbiBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kSW1zY3AucHJlZmV0Y2hDb250ZW50KG1vZHVsZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmNvcmUuY291cnNlJylcblxuLyoqXG4gKiBMYWJlbCBpbmRleCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sYWJlbFxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZExhYmVsSW5kZXhDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFNb2RMYWJlbEluZGV4Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbG9nKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tYU1vZExhYmVsSW5kZXhDdHJsJyk7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gJHN0YXRlUGFyYW1zLmRlc2NyaXB0aW9uO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfbGFiZWwnKVxuXG4vKipcbiAqIE1vZCBsYWJlbCBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbGFiZWxcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kTGFiZWxIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZExhYmVsSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1UZXh0LCAkdHJhbnNsYXRlLCAkc3RhdGUsICRtbUNvbnRlbnRMaW5rc0hlbHBlciwgJHEsICRtbUNvdXJzZSkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2xhYmVsXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RMYWJlbEhhbmRsZXJzI2NvdXJzZUNvbnRlbnRcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBpbmZvLlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9ICRtbVRleHQuc2hvcnRlblRleHQoJG1tVGV4dC5jbGVhblRhZ3MobW9kdWxlLmRlc2NyaXB0aW9uKS50cmltKCksIDEyOCk7XG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICR0cmFuc2xhdGUoJ21tYS5tb2RfbGFiZWwudGFwdG92aWV3JykudGhlbihmdW5jdGlvbih0YXB0b3ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICc8c3BhbiBjbGFzcz1cIm1tYS1tb2RfbGFiZWwtZW1wdHlcIj4nICsgdGFwdG92aWV3ICsgJzwvc3Bhbj4nO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2RfbGFiZWwnLCB7ZGVzY3JpcHRpb246IG1vZHVsZS5kZXNjcmlwdGlvbn0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbGFiZWxcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZExhYmVsSGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRW5hYmxlZChzaXRlSWQsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICBpZiAoY291cnNlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkbW1Db3Vyc2UuY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkKHNpdGVJZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgbGFiZWwgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL2xhYmVsL3ZpZXcucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIudHJlYXRNb2R1bGVJbmRleFVybChzaXRlSWRzLCB1cmwsIGlzRW5hYmxlZCwgY291cnNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX2x0aScpXG5cbi8qKlxuICogTFRJIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2x0aVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZEx0aUluZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kTHRpSW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbWFNb2RMdGksICRtbVV0aWwsICRxLCAkbW1Db3Vyc2UpIHtcbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIGx0aTtcblxuICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAkc2NvcGUuY291cnNlaWQgPSBjb3Vyc2VpZDtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBMVEkgZGF0YS5cbiAgICBmdW5jdGlvbiBmZXRjaExUSShyZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kTHRpLmdldEx0aShjb3Vyc2VpZCwgbW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKGx0aWRhdGEpIHtcbiAgICAgICAgICAgIGx0aSA9IGx0aWRhdGE7XG5cbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kTHRpLmdldEx0aUxhdW5jaERhdGEobHRpLmlkKS50aGVuKGZ1bmN0aW9uKGxhdW5jaGRhdGEpIHtcbiAgICAgICAgICAgICAgICBsdGkubGF1bmNoZGF0YSA9IGxhdW5jaGRhdGE7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gbHRpLm5hbWUgfHwgJHNjb3BlLnRpdGxlO1xuICAgICAgICAgICAgICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IGx0aS5pbnRybyB8fMKgJHNjb3BlLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICRzY29wZS5pc1ZhbGlkVXJsID0gJG1tVXRpbC5pc1ZhbGlkVVJMKGxhdW5jaGRhdGEuZW5kcG9pbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICghcmVmcmVzaCkge1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgY2FsbCBmYWlsZWQsIHJldHJ5IHdpdGhvdXQgdXNpbmcgY2FjaGUgc2luY2UgaXQgbWlnaHQgYmUgYSBuZXcgYWN0aXZpdHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZnJlc2hBbGxEYXRhKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9sdGkuZXJyb3JnZXRsdGknLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gcmVmcmVzaCBhbGwgdGhlIGRhdGEuXG4gICAgZnVuY3Rpb24gcmVmcmVzaEFsbERhdGEoKSB7XG4gICAgICAgIHZhciBwMSA9ICRtbWFNb2RMdGkuaW52YWxpZGF0ZUx0aShjb3Vyc2VpZCksXG4gICAgICAgICAgICBwMiA9IGx0aSA/ICRtbWFNb2RMdGkuaW52YWxpZGF0ZUx0aUxhdW5jaERhdGEobHRpLmlkKSA6ICRxLndoZW4oKTtcblxuICAgICAgICByZXR1cm4gJHEuYWxsKFtwMSwgcDJdKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoTFRJKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmZXRjaExUSSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5sdGlMb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gUHVsbCB0byByZWZyZXNoLlxuICAgICRzY29wZS5kb1JlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVmcmVzaEFsbERhdGEoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIExhdW5jaCB0aGUgTFRJLlxuICAgICRzY29wZS5sYXVuY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gXCJWaWV3XCIgTFRJLlxuICAgICAgICAkbW1hTW9kTHRpLmxvZ1ZpZXcobHRpLmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMYXVuY2ggTFRJLlxuICAgICAgICAkbW1hTW9kTHRpLmxhdW5jaChsdGkubGF1bmNoZGF0YS5lbmRwb2ludCwgbHRpLmxhdW5jaGRhdGEucGFyYW1ldGVycykuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfbHRpJylcblxuLyoqXG4gKiBNb2QgTFRJIGhhbmRsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2x0aVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RMdGlIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZEx0aUhhbmRsZXJzJywgZnVuY3Rpb24oJG1tQ291cnNlLCAkbW1hTW9kTHRpLCAkc3RhdGUsICRtbVNpdGUsICRtbUZpbGVwb29sLCAkbW1BcHAsICRtbVV0aWwsXG4gICAgICAgICAgICBtbWFNb2RMdGlDb21wb25lbnQsICRtbUNvbnRlbnRMaW5rc0hlbHBlciwgJHEpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEx0aUhhbmRsZXJzI2NvdXJzZUNvbnRlbnRcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZEx0aS5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgaW5mby5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIFRoZSBjb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ2x0aScpOyAvLyBHZXQgTFRJIGRlZmF1bHQgaWNvbiBmb3Igbm93LlxuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLm1vZF9sdGknLCB7bW9kdWxlOiBtb2R1bGUsIGNvdXJzZWlkOiBjb3Vyc2VpZH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgTFRJIGRhdGEuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSAkbW1hTW9kTHRpLmdldEx0aShjb3Vyc2VpZCwgbW9kdWxlLmlkKTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjdXN0b20gaWNvbnMuXG4gICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGx0aWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGljb24gPSBsdGlkYXRhLnNlY3VyZWljb24gfHwgbHRpZGF0YS5pY29uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tRmlsZXBvb2wuZG93bmxvYWRVcmwoJG1tU2l0ZS5nZXRJZCgpLCBpY29uLCBmYWxzZSwgbW1hTW9kTHRpQ29tcG9uZW50LCBtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciBkb3dubG9hZGluZy4gSWYgd2UncmUgb25saW5lIHdlJ2xsIHNldCB0aGUgb25saW5lIHVybC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSBpY29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBCdXR0b24gdG8gbGF1bmNoIHRoZSBMVEkuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmJ1dHRvbnMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWxpbmsnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ21tYS5tb2RfbHRpLmxhdW5jaGFjdGl2aXR5JyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW1VdGlsLnNob3dNb2RhbExvYWRpbmcoJ21tLmNvcmUubG9hZGluZycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IExUSSBhbmQgbGF1bmNoIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24obHRpZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kTHRpLmdldEx0aUxhdW5jaERhdGEobHRpZGF0YS5pZCkudGhlbihmdW5jdGlvbihsYXVuY2hkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiVmlld1wiIExUSS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZEx0aS5sb2dWaWV3KGx0aWRhdGEuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhdW5jaCBMVEkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kTHRpLmxhdW5jaChsYXVuY2hkYXRhLmVuZHBvaW50LCBsYXVuY2hkYXRhLnBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9sdGkuZXJyb3JnZXRsdGknLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbHRpXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RMdGlIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kTHRpLmlzUGx1Z2luRW5hYmxlZChzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb3Vyc2VJZCB8fCAkbW1Db3Vyc2UuY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkKHNpdGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSBMVEkgVVJMLlxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvbW9kL2x0aS92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9sdGknKVxuXG4vKipcbiAqIExUSSBzZXJ2aWNlLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kTHRpXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kTHRpJywgZnVuY3Rpb24oJHEsICRtbVNpdGUsICRtbUZTLCAkbW1UZXh0LCAkbW1VdGlsLCAkbW1MYW5nLCAkbW1TaXRlc01hbmFnZXIpIHtcbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBsYXVuY2hlckZpbGVOYW1lID0gJ2x0aV9sYXVuY2hlci5odG1sJztcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBsYXVuY2hlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEx0aSNkZWxldGVMYXVuY2hlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbGF1bmNoZXIgZmlsZSBpcyBkZWxldGVkLlxuICAgICAqL1xuICAgIHNlbGYuZGVsZXRlTGF1bmNoZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbUZTLnJlbW92ZUZpbGUobGF1bmNoZXJGaWxlTmFtZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGxhdW5jaGVyIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbHRpXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RMdGkjZ2VuZXJhdGVMYXVuY2hlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICBMYXVuY2ggVVJMLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHBhcmFtcyBMYXVuY2ggcGFyYW1zLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGZpbGUgVVJMLlxuICAgICAqL1xuICAgIHNlbGYuZ2VuZXJhdGVMYXVuY2hlciA9IGZ1bmN0aW9uKHVybCwgcGFyYW1zKSB7XG5cbiAgICAgICAgaWYgKCEkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbih1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgYSBmb3JtIHdpdGggdGhlIHBhcmFtcy5cbiAgICAgICAgdmFyIHRleHQgPSAnPGZvcm0gYWN0aW9uPVwiJyArIHVybCArICdcIiBuYW1lPVwibHRpTGF1bmNoRm9ybVwiICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWV0aG9kPVwicG9zdFwiIGVuY1R5cGU9XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIj5cXG4nO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBpZiAocC5uYW1lID09ICdleHRfc3VibWl0Jykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gJyAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSAnICAgIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cIicgKyAkbW1UZXh0LmVzY2FwZUhUTUwocC5uYW1lKSArICdcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ICs9ICcgdmFsdWU9XCInICsgJG1tVGV4dC5lc2NhcGVIVE1MKHAudmFsdWUpICsgJ1wiLz5cXG4nO1xuICAgICAgICB9KTtcbiAgICAgICAgdGV4dCArPSAnPC9mb3JtPlxcbic7XG5cbiAgICAgICAgLy8gQWRkIGFuIGluLWxpbmUgc2NyaXB0IHRvIGF1dG9tYXRpY2FsbHkgc3VibWl0IHRoZSBmb3JtLlxuICAgICAgICB0ZXh0ICs9ICc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj4gXFxuJyArXG4gICAgICAgICAgICAnICAgIGRvY3VtZW50Lmx0aUxhdW5jaEZvcm0uc3VibWl0KCk7IFxcbicgK1xuICAgICAgICAgICAgJzwvc2NyaXB0PiBcXG4nO1xuXG4gICAgICAgIHJldHVybiAkbW1GUy53cml0ZUZpbGUobGF1bmNoZXJGaWxlTmFtZSwgdGV4dCkudGhlbihmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnRvVVJMKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBMVEkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbHRpXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RMdGkjZ2V0THRpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY21pZCAgICAgQ291cnNlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBMVEkgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0THRpID0gZnVuY3Rpb24oY291cnNlaWQsIGNtaWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VpZHM6IFtjb3Vyc2VpZF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRMdGlDYWNoZUtleShjb3Vyc2VpZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX2x0aV9nZXRfbHRpc19ieV9jb3Vyc2VzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubHRpcykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50THRpO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNwb25zZS5sdGlzLCBmdW5jdGlvbihsdGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGx0aS5jb3Vyc2Vtb2R1bGUgPT0gY21pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEx0aSA9IGx0aTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50THRpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50THRpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIExUSSBkYXRhIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEx0aUNhY2hlS2V5KGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAnbW1hTW9kTHRpOmx0aTonICsgY291cnNlaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgTFRJIGxhdW5jaCBkYXRhLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX2x0aVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kTHRpI2dldEx0aUxhdW5jaERhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgTFRJIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGxhdW5jaCBkYXRhIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEx0aUxhdW5jaERhdGEgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRvb2xpZDogaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRMdGlMYXVuY2hEYXRhQ2FjaGVLZXkoaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ21vZF9sdGlfZ2V0X3Rvb2xfbGF1bmNoX2RhdGEnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIExUSSBsYXVuY2ggZGF0YSBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBMVEkgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRMdGlMYXVuY2hEYXRhQ2FjaGVLZXkoaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RMdGk6bGF1bmNoOicgKyBpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBMVEkgZGF0YS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEx0aSNpbnZhbGlkYXRlTHRpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZUx0aSA9IGZ1bmN0aW9uKGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldEx0aUNhY2hlS2V5KGNvdXJzZWlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbHRpXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RMdGkjaW52YWxpZGF0ZUx0aUxhdW5jaERhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgTFRJIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlTHRpTGF1bmNoRGF0YSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldEx0aUxhdW5jaERhdGFDYWNoZUtleShpZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBpcyBlbmFibGVkIGluIGEgY2VydGFpbiBzaXRlLiBQbHVnaW4gaXMgZW5hYmxlZCBpZiB0aGUgbHRpIFdTIGFyZSBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbHRpXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RMdGkjaXNQbHVnaW5FbmFibGVkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gIHNpdGUud3NBdmFpbGFibGUoJ21vZF9sdGlfZ2V0X2x0aXNfYnlfY291cnNlcycpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9sdGlfZ2V0X3Rvb2xfbGF1bmNoX2RhdGEnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExhdW5jaCBMVEkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfbHRpXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RMdGkjbGF1bmNoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgIExhdW5jaCBVUkwuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcGFyYW1zIExhdW5jaCBwYXJhbXMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgY2FsbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHNlbGYubGF1bmNoID0gZnVuY3Rpb24odXJsLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCEkbW1VdGlsLmlzVmFsaWRVUkwodXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KCdtbWEubW9kX2x0aS5lcnJvcmludmFsaWRsYXVuY2h1cmwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIGxhdW5jaGVyIGFuZCBvcGVuIGl0LlxuICAgICAgICByZXR1cm4gc2VsZi5nZW5lcmF0ZUxhdW5jaGVyKHVybCwgcGFyYW1zKS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgJG1tVXRpbC5vcGVuSW5BcHAodXJsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCB0aGUgTFRJIGFzIGJlaW5nIHZpZXdlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9sdGlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZEx0aSNsb2dWaWV3XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIExUSSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sb2dWaWV3ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGx0aWlkOiBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfbHRpX3ZpZXdfbHRpJywgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfcGFnZScpXG5cbi8qKlxuICogUGFnZSBpbmRleCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kUGFnZUluZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kUGFnZUluZGV4Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1VdGlsLCAkbW1hTW9kUGFnZSwgJG1tQ291cnNlLCAkcSwgJGxvZywgJG1tQXBwLFxuICAgICAgICAgICAgbW1hTW9kUGFnZUNvbXBvbmVudCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCdtbWFNb2RQYWdlSW5kZXhDdHJsJyk7XG5cbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQ7XG5cbiAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBtb2R1bGUuZGVzY3JpcHRpb247XG4gICAgJHNjb3BlLmNvbXBvbmVudCA9IG1tYU1vZFBhZ2VDb21wb25lbnQ7XG4gICAgJHNjb3BlLmNvbXBvbmVudElkID0gbW9kdWxlLmlkO1xuICAgICRzY29wZS5leHRlcm5hbFVybCA9IG1vZHVsZS51cmw7XG4gICAgJHNjb3BlLmxvYWRlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZmV0Y2hDb250ZW50KCkge1xuICAgICAgICB2YXIgZG93bmxvYWRGYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gUHJlZmV0Y2ggdGhlIGNvbnRlbnQgc28gQUxMIGZpbGVzIGFyZSBkb3dubG9hZGVkLCBub3QganVzdCB0aGUgb25lcyBzaG93biBpbiB0aGUgcGFnZS5cbiAgICAgICAgcmV0dXJuICRtbWFNb2RQYWdlLmRvd25sb2FkQWxsQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgLy8gTWFyayBkb3dubG9hZCBhcyBmYWlsZWQgYnV0IGdvIG9uIHNpbmNlIHRoZSBtYWluIGZpbGVzIGNvdWxkIGhhdmUgYmVlbiBkb3dubG9hZGVkLlxuICAgICAgICAgICAgZG93bmxvYWRGYWlsZWQgPSB0cnVlO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RQYWdlLmdldFBhZ2VIdG1sKG1vZHVsZS5jb250ZW50cywgbW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuY29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRGYWlsZWQgJiYgJG1tQXBwLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY291bGQgbG9hZCB0aGUgbWFpbiBmaWxlIGJ1dCB0aGUgZG93bmxvYWQgZmFpbGVkLiBTaG93IGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZ3NvbWVmaWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfcGFnZS5lcnJvcndoaWxlbG9hZGluZ3RoZXBhZ2UnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICRzY29wZS5kb1JlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJG1tYU1vZFBhZ2UuaW52YWxpZGF0ZUNvbnRlbnQobW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoQ29udGVudCgpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZldGNoQ29udGVudCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNb2RQYWdlLmxvZ1ZpZXcobW9kdWxlLmluc3RhbmNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3BhZ2UnKVxuXG4vKipcbiAqIE1vZCBwYWdlIGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZFBhZ2VIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZFBhZ2VIYW5kbGVycycsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tYU1vZFBhZ2UsICRtbUV2ZW50cywgJHN0YXRlLCAkbW1TaXRlLCAkbW1VdGlsLCAkbW1GaWxlcG9vbCxcbiAgICAgICAgICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUsIG1tQ29yZURvd25sb2FkaW5nLCBtbUNvcmVOb3REb3dubG9hZGVkLCBtbUNvcmVPdXRkYXRlZCwgbW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCxcbiAgICAgICAgICAgIG1tYU1vZFBhZ2VDb21wb25lbnQsICRtbUNvbnRlbnRMaW5rc0hlbHBlciwgJHEpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIGNvbnRlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlSGFuZGxlcnMjY291cnNlQ29udGVudFxuICAgICAqL1xuICAgIHNlbGYuY291cnNlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RQYWdlLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBpbmZvLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25sb2FkQnRuLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoQnRuLFxuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbiA9ICRtbUZpbGVwb29sLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuXG4gICAgICAgICAgICAgICAgZG93bmxvYWRCdG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1pb3MtY2xvdWQtZG93bmxvYWQtb3V0bGluZScsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnbW0uY29yZS5kb3dubG9hZCcsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RQYWdlLnByZWZldGNoQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tYW5kcm9pZC1yZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLnJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RQYWdlLmludmFsaWRhdGVDb250ZW50KG1vZHVsZS5pZCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kUGFnZS5wcmVmZXRjaENvbnRlbnQobW9kdWxlKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRkZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKCdwYWdlJyk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmJ1dHRvbnMgPSBbZG93bmxvYWRCdG4sIHJlZnJlc2hCdG5dO1xuICAgICAgICAgICAgICAgICRzY29wZS5zcGlubmVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW9kX3BhZ2UnLCB7bW9kdWxlOiBtb2R1bGUsIGNvdXJzZWlkOiBjb3Vyc2VpZH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBTaG93IGJ1dHRvbnMgYWNjb3JkaW5nIHRvIG1vZHVsZSBzdGF0dXMuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2hvd1N0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBzdGF0dXMgPT09IG1tQ29yZURvd25sb2FkaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRCdG4uaGlkZGVuID0gc3RhdHVzICE9PSBtbUNvcmVOb3REb3dubG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEJ0bi5oaWRkZW4gPSBzdGF0dXMgIT09IG1tQ29yZU91dGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoaXMgbW9kdWxlIHN0YXR1cy5cbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzT2JzZXJ2ZXIgPSAkbW1FdmVudHMub24obW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zaXRlaWQgPT09ICRtbVNpdGUuZ2V0SWQoKSAmJiBkYXRhLmNvbXBvbmVudElkID09PSBtb2R1bGUuaWQgJiYgZGF0YS5jb21wb25lbnQgPT09IG1tYU1vZFBhZ2VDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dTdGF0dXMoZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY3VycmVudCBzdGF0dXMgdG8gZGVjaWRlIHdoaWNoIGljb24gc2hvdWxkIGJlIHNob3duLlxuICAgICAgICAgICAgICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUuZ2V0TW9kdWxlU3RhdHVzKG1vZHVsZSwgY291cnNlaWQsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQpLnRoZW4oc2hvd1N0YXR1cyk7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNPYnNlcnZlciAmJiBzdGF0dXNPYnNlcnZlci5vZmYgJiYgc3RhdHVzT2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUGFnZUhhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgYSBjZXJ0YWluIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICBTaXRlIElELlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoc2l0ZUlkLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RQYWdlLmlzUGx1Z2luRW5hYmxlZChzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb3Vyc2VJZCB8fCAkbW1Db3Vyc2UuY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkKHNpdGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSBwYWdlIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignL21vZC9wYWdlL3ZpZXcucGhwJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1Db250ZW50TGlua3NIZWxwZXIudHJlYXRNb2R1bGVJbmRleFVybChzaXRlSWRzLCB1cmwsIGlzRW5hYmxlZCwgY291cnNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3BhZ2UnKVxuXG4vKipcbiAqIFBhZ2UgZmFjdG9yeS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcGFnZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RQYWdlXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kUGFnZScsIGZ1bmN0aW9uKCRtbUZpbGVwb29sLCAkbW1TaXRlLCAkbW1GUywgJGh0dHAsICRsb2csICRxLCAkbW1TaXRlc01hbmFnZXIsIG1tYU1vZFBhZ2VDb21wb25lbnQpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU1vZFBhZ2UnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbGwgdGhlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUGFnZSNkb3dubG9hZEFsbENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBjb250ZW50IGlzIGRvd25sb2FkZWQuIERhdGEgcmV0dXJuZWQgaXMgbm90IHJlbGlhYmxlLlxuICAgICAqL1xuICAgIHNlbGYuZG93bmxvYWRBbGxDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMobW9kdWxlKSxcbiAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgIHRpbWVtb2QgPSAkbW1GaWxlcG9vbC5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKTtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmRvd25sb2FkUGFja2FnZSgkbW1TaXRlLmdldElkKCksIGZpbGVzLCBtbWFNb2RQYWdlQ29tcG9uZW50LCBtb2R1bGUuaWQsIHJldmlzaW9uLCB0aW1lbW9kKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBjYW4gYmUgZG93bmxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlI2dldERvd25sb2FkYWJsZUZpbGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gICAgIExpc3Qgb2YgZmlsZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBbXTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBldmVudCBuYW1lcyBvZiBmaWxlcyBiZWluZyBkb3dubG9hZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2UjZ2V0RG93bmxvYWRpbmdGaWxlc0V2ZW50TmFtZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZGluZ0ZpbGVzRXZlbnROYW1lcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgIGV2ZW50TmFtZXMgPSBbXSxcbiAgICAgICAgICAgIHNpdGVpZCA9ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gY29udGVudC5maWxldXJsO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzRmlsZURvd25sb2FkYWJsZShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tRmlsZXBvb2wuaXNGaWxlRG93bmxvYWRpbmdCeVVybChzaXRlaWQsIHVybCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZ2V0RmlsZUV2ZW50TmFtZUJ5VXJsKHNpdGVpZCwgdXJsKS50aGVuKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWVzLnB1c2goZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBmYWlscy5cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE5hbWVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZmlsZSBldmVudCBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlI2dldEZpbGVFdmVudE5hbWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdpdGggYXJyYXkgb2YgJG1tRXZlbnQgbmFtZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXRGaWxlRXZlbnROYW1lcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZHVsZS5jb250ZW50cywgZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgdmFyIHVybCA9IGNvbnRlbnQuZmlsZXVybDtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc0ZpbGVEb3dubG9hZGFibGUoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbUZpbGVwb29sLmdldEZpbGVFdmVudE5hbWVCeVVybCgkbW1TaXRlLmdldElkKCksIHVybCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihldmVudE5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnROYW1lcztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhZ2UgSFRNTC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlI2dldFBhZ2VIdG1sXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRlbnRzIFRoZSBtb2R1bGUgY29udGVudHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZUlkIFRoZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmdldFBhZ2VIdG1sID0gZnVuY3Rpb24oY29udGVudHMsIG1vZHVsZUlkKSB7XG4gICAgICAgIHZhciBpbmRleFVybCxcbiAgICAgICAgICAgIHBhdGhzID0ge30sXG4gICAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIGluZm9ybWF0aW9uIGFib3V0IHBhdGhzIGZyb20gdGhlIG1vZHVsZSBjb250ZW50cy5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgICAgIHVybCA9IGNvbnRlbnQuZmlsZXVybDtcblxuICAgICAgICAgICAgaWYgKHNlbGYuX2lzTWFpblBhZ2UoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHdheSB0byBzcG90IHRoZSBpbmRleCBwYWdlLlxuICAgICAgICAgICAgICAgIGluZGV4VXJsID0gdXJsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBjb250ZW50LmZpbGVuYW1lO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50LmZpbGVwYXRoICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBmb2xkZXJzIHdpdGhvdXQgdGhlIGxlYWRpbmcgc2xhc2guXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGNvbnRlbnQuZmlsZXBhdGguc3Vic3RyKDEpICsga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoc1trZXldID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQcm9taXNlIGhhbmRsaW5nIHdoZW4gd2UgYXJlIGluIGEgYnJvd3Nlci5cbiAgICAgICAgcHJvbWlzZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZDtcbiAgICAgICAgICAgIGlmICghaW5kZXhVcmwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBldmVyIHRoYXQgaGFwcGVucy5cbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdDb3VsZCBub3QgbG9jYXRlIHRoZSBpbmRleCBwYWdlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpbGUgc3lzdGVtIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZG93bmxvYWRVcmwoJG1tU2l0ZS5nZXRJZCgpLCBpbmRleFVybCwgZmFsc2UsIG1tYU1vZFBhZ2VDb21wb25lbnQsIG1vZHVsZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgcmV0dXJuIHRoZSBsaXZlIFVSTC5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgkbW1TaXRlLmZpeFBsdWdpbmZpbGVVUkwoaW5kZXhVcmwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIFVSTCBjb250ZW50LlxuICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldCh1cmwpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBjb250ZW50LCB3ZSB1cGRhdGUgdGhlIFNSQyB0byBwb2ludCBiYWNrIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBleHRlcm5hbCByZXNvdXJjZS4gVGhhdCB3aWxsIGJlIGNhdWdodCBieSBtbS1mb3JtYXQtdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwuaHRtbChyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGh0bWwuZmluZCgnaW1nJyksIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyYyA9IHBhdGhzW2RlY29kZVVSSUNvbXBvbmVudChpbWcuZ2V0QXR0cmlidXRlKCdzcmMnKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnc3JjJywgc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoZSBzYW1lIGZvciBsaW5rcy5cbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGh0bWwuZmluZCgnYScpLCBmdW5jdGlvbihhbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBocmVmID0gcGF0aHNbZGVjb2RlVVJJQ29tcG9uZW50KGFuY2hvci5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBocmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBodG1sLmh0bWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgdGhlIHByZWZldGNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlI2ludmFsaWRhdGVDb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZUlkIFRoZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmludmFsaWRhdGVGaWxlc0J5Q29tcG9uZW50KCRtbVNpdGUuZ2V0SWQoKSwgbW1hTW9kUGFnZUNvbXBvbmVudCwgbW9kdWxlSWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGZpbGUgaXMgZG93bmxvYWRhYmxlLiBUaGUgZmlsZSBwYXJhbSBtdXN0IGhhdmUgYSAndHlwZScgYXR0cmlidXRlIGxpa2UgaW4gY29yZV9jb3Vyc2VfZ2V0X2NvbnRlbnRzIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2UjaXNGaWxlRG93bmxvYWRhYmxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGUgRmlsZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICBUcnVlIGlmIGRvd25sb2FkYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNGaWxlRG93bmxvYWRhYmxlID0gZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICByZXR1cm4gZmlsZS50eXBlID09PSAnZmlsZSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZmlsZSBpcyB0aGUgbWFpbiBwYWdlIG9mIHRoZSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUGFnZSNfaXNNYWluUGFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlIEFuIG9iamVjdCByZXR1cm5lZCBmcm9tIFdTIGNvbnRhaW5pbmcgZmlsZSBpbmZvLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2lzTWFpblBhZ2UgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGZpbGUuZmlsZW5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsZXVybCA9IGZpbGUuZmlsZXVybCB8fCAnJyxcbiAgICAgICAgICAgIHVybCA9ICcvbW9kX3BhZ2UvY29udGVudC9pbmRleC5odG1sJyxcbiAgICAgICAgICAgIGVuY29kZWRVcmwgPSBlbmNvZGVVUklDb21wb25lbnQodXJsKTtcblxuICAgICAgICByZXR1cm4gKGZpbGVuYW1lID09PSAnaW5kZXguaHRtbCcgJiYgKGZpbGV1cmwuaW5kZXhPZih1cmwpID4gMCB8fCBmaWxldXJsLmluZGV4T2YoZW5jb2RlZFVybCkgPiAwICkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBwYWdlIHBsdWdpbiBpcyBlbmFibGVkIGluIGEgY2VydGFpbiBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2UjaXNQbHVnaW5FbmFibGVkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5jYW5Eb3dubG9hZEZpbGVzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgYSBwYWdlIGFzIGJlaW5nIHZpZXdlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlI2xvZ1ZpZXdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgTW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ1ZpZXcgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcGFnZWlkOiBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAkbW1TaXRlLndyaXRlKCdtb2RfcGFnZV92aWV3X3BhZ2UnLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlZmV0Y2ggdGhlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcGFnZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUGFnZSNwcmVmZXRjaENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBmaWxlcyBoYXZlIGJlZW4gZG93bmxvYWRlZC4gRGF0YSByZXR1cm5lZCBpcyBub3QgcmVsaWFibGUuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaENvbnRlbnQgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyhtb2R1bGUpLFxuICAgICAgICAgICAgcmV2aXNpb24gPSAkbW1GaWxlcG9vbC5nZXRSZXZpc2lvbkZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpLFxuICAgICAgICAgICAgdGltZW1vZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wucHJlZmV0Y2hQYWNrYWdlKCRtbVNpdGUuZ2V0SWQoKSwgZmlsZXMsIG1tYU1vZFBhZ2VDb21wb25lbnQsIG1vZHVsZS5pZCwgcmV2aXNpb24sIHRpbWVtb2QpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3BhZ2UnKVxuXG4vKipcbiAqIE1vZCBwYWdlIHByZWZldGNoIGhhbmRsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kUGFnZVByZWZldGNoSGFuZGxlclxuICovXG4uZmFjdG9yeSgnJG1tYU1vZFBhZ2VQcmVmZXRjaEhhbmRsZXInLCBmdW5jdGlvbigkbW1hTW9kUGFnZSwgJG1tU2l0ZSwgbW1hTW9kUGFnZUNvbXBvbmVudCkge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIHNlbGYuY29tcG9uZW50ID0gbW1hTW9kUGFnZUNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG93bmxvYWQgc2l6ZSBvZiBhIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlUHJlZmV0Y2hIYW5kbGVyI2dldERvd25sb2FkU2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgTW9kdWxlIHRvIGdldCB0aGUgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIFNpemUuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZFNpemUgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoJG1tYU1vZFBhZ2UuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpICYmIGNvbnRlbnQuZmlsZXNpemUpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gc2l6ZSArIGNvbnRlbnQuZmlsZXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9wYWdlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RQYWdlUHJlZmV0Y2hIYW5kbGVyI2lzRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuY2FuRG93bmxvYWRGaWxlcygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCB0aGUgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3BhZ2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFBhZ2VQcmVmZXRjaEhhbmRsZXIjcHJlZmV0Y2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBmaWxlcyBoYXZlIGJlZW4gZG93bmxvYWRlZC4gRGF0YSByZXR1cm5lZCBpcyBub3QgcmVsaWFibGUuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaCA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZFBhZ2UucHJlZmV0Y2hDb250ZW50KG1vZHVsZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfcmVzb3VyY2UnKVxuXG4vKipcbiAqIFJlc291cmNlIGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTW9kUmVzb3VyY2VJbmRleEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZFJlc291cmNlSW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbVV0aWwsICRtbWFNb2RSZXNvdXJjZSwgJGxvZywgJG1tQXBwLCAkbW1Db3Vyc2UsICR0aW1lb3V0LFxuICAgICAgICAgICAgbW1hTW9kUmVzb3VyY2VDb21wb25lbnQpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnbW1hTW9kUmVzb3VyY2VJbmRleEN0cmwnKTtcblxuICAgIHZhciBtb2R1bGUgPSAkc3RhdGVQYXJhbXMubW9kdWxlIHx8IHt9LFxuICAgICAgICBjb3Vyc2VpZCA9ICRzdGF0ZVBhcmFtcy5jb3Vyc2VpZDtcblxuICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAkc2NvcGUuY29tcG9uZW50ID0gbW1hTW9kUmVzb3VyY2VDb21wb25lbnQ7XG4gICAgJHNjb3BlLmNvbXBvbmVudElkID0gbW9kdWxlLmlkO1xuICAgICRzY29wZS5leHRlcm5hbFVybCA9IG1vZHVsZS51cmw7XG4gICAgJHNjb3BlLm1vZGUgPSBmYWxzZTtcbiAgICAkc2NvcGUubG9hZGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBmZXRjaENvbnRlbnQoKSB7XG4gICAgICAgIGlmIChtb2R1bGUuY29udGVudHMgJiYgbW9kdWxlLmNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCRtbWFNb2RSZXNvdXJjZS5pc0Rpc3BsYXllZEluSWZyYW1lKG1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubW9kZSA9ICdpZnJhbWUnO1xuICAgICAgICAgICAgICAgIHZhciBkb3dubG9hZEZhaWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kUmVzb3VyY2UuZG93bmxvYWRBbGxDb250ZW50KG1vZHVsZSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgZG93bmxvYWQgYXMgZmFpbGVkIGJ1dCBnbyBvbiBzaW5jZSB0aGUgbWFpbiBmaWxlcyBjb3VsZCBoYXZlIGJlZW4gZG93bmxvYWRlZC5cbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbWFNb2RSZXNvdXJjZS5nZXRJZnJhbWVTcmMobW9kdWxlKS50aGVuKGZ1bmN0aW9uKHNyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5zcmMgJiYgc3JjLnRvU3RyaW5nKCkgPT0gJHNjb3BlLnNyYy50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtbG9hZGluZyBzYW1lIHBhZ2UuIFNldCBpdCB0byBlbXB0eSBhbmQgdGhlbiByZS1zZXQgdGhlIHNyY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBuZXh0IGRpZ2VzdCBzbyBpdCBkZXRlY3RzIGl0IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zcmMgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RSZXNvdXJjZS5sb2dWaWV3KG1vZHVsZS5pbnN0YW5jZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3dubG9hZEZhaWxlZCAmJiAkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIGxvYWQgdGhlIG1haW4gZmlsZSBidXQgdGhlIGRvd25sb2FkIGZhaWxlZC4gU2hvdyBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZ3NvbWVmaWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfcmVzb3VyY2UuZXJyb3J3aGlsZWxvYWRpbmd0aGVjb250ZW50JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRtbWFNb2RSZXNvdXJjZS5pc0Rpc3BsYXllZElubGluZShtb2R1bGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25sb2FkRmFpbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgJG1tYU1vZFJlc291cmNlLmRvd25sb2FkQWxsQ29udGVudChtb2R1bGUpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIGRvd25sb2FkIGFzIGZhaWxlZCBidXQgZ28gb24gc2luY2UgdGhlIG1haW4gZmlsZXMgY291bGQgaGF2ZSBiZWVuIGRvd25sb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkbW1hTW9kUmVzb3VyY2UuZ2V0UmVzb3VyY2VIdG1sKG1vZHVsZS5jb250ZW50cywgbW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5tb2RlID0gJ2lubGluZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kUmVzb3VyY2UubG9nVmlldyhtb2R1bGUuaW5zdGFuY2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3dubG9hZEZhaWxlZCAmJiAkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIGxvYWQgdGhlIG1haW4gZmlsZSBidXQgdGhlIGRvd25sb2FkIGZhaWxlZC4gU2hvdyBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZ3NvbWVmaWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2RfcmVzb3VyY2UuZXJyb3J3aGlsZWxvYWRpbmd0aGVjb250ZW50JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICRzY29wZS5tb2RlID0gJ2V4dGVybmFsJztcblxuICAgICAgICAgICAgICAgICRzY29wZS5vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW0uY29yZS5kb3dubG9hZGluZycsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICRtbWFNb2RSZXNvdXJjZS5vcGVuRmlsZShtb2R1bGUuY29udGVudHMsIG1vZHVsZS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RSZXNvdXJjZS5sb2dWaWV3KG1vZHVsZS5pbnN0YW5jZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX3Jlc291cmNlLmVycm9yd2hpbGVsb2FkaW5ndGhlY29udGVudCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWwuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9yZXNvdXJjZS5lcnJvcndoaWxlbG9hZGluZ3RoZWNvbnRlbnQnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIGRpcmVjdGl2ZSBtbWFNb2RSZXNvdXJjZUh0bWxMaW5rIHdoZW4gd2UgY2xpY2sgYW4gSFRNTCBsaW5rLlxuICAgICRzY29wZS4kb24oJ21tYU1vZFJlc291cmNlSHRtbExpbmtDbGlja2VkJywgZnVuY3Rpb24oZSwgdGFyZ2V0KSB7XG4gICAgICAgICRzY29wZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgJG1tYU1vZFJlc291cmNlLmdldFJlc291cmNlSHRtbChtb2R1bGUuY29udGVudHMsIG1vZHVsZS5pZCwgdGFyZ2V0KS50aGVuKGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICRzY29wZS5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbWEubW9kX3Jlc291cmNlLmVycm9yd2hpbGVsb2FkaW5ndGhlY29udGVudCcsIHRydWUpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLmRvUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTW9kUmVzb3VyY2UuaW52YWxpZGF0ZUNvbnRlbnQobW9kdWxlLmlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoQ29udGVudCgpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZldGNoQ29udGVudCgpO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfcmVzb3VyY2UnKVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0byBvcGVuIGEgbGluayBpbiBleHRlcm5hbCBicm93c2VyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbW1hTW9kUmVzb3VyY2VIdG1sTGlua1xuICovXG4uZGlyZWN0aXZlKCdtbWFNb2RSZXNvdXJjZUh0bWxMaW5rJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgcHJpb3JpdHk6IDk5LCAgIC8vIE11c3QgYmUgbG93ZXIgdGhhbiBtbS1icm93c2VyLCBvciBhbnl0aGluZyBsaXN0ZW5pbmcgZm9yIGEgY2xpY2sgZXZlbnQuXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgZWxlbWVudC5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBocmVmID0gZWxlbWVudFswXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaHJlZicpO1xuICAgICAgICAgICAgICAgIGlmICghaHJlZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBhbnkgb3RoZXIgZGlyZWN0aXZlIGZyb20gY2F0Y2hpbmcgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgdGhlIHNjb3BlIHdoaWNoIG11c3QgaGFuZGxlIHRoaXMgY2xpY2ssIHdlIGRvIG5vdCBzdXBwb3J0IGJ1YmJsaW5nLlxuICAgICAgICAgICAgICAgIHNjb3BlLiRlbWl0KCdtbWFNb2RSZXNvdXJjZUh0bWxMaW5rQ2xpY2tlZCcsIGhyZWYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfcmVzb3VyY2UnKVxuXG4vKipcbiAqIE1vZCByZXNvdXJjZSBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2VIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZFJlc291cmNlSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbWFNb2RSZXNvdXJjZSwgJG1tRXZlbnRzLCAkc3RhdGUsICRtbVNpdGUsICRtbVV0aWwsXG4gICAgICAgICAgICAkbW1Db3Vyc2VQcmVmZXRjaERlbGVnYXRlLCAkbW1GaWxlcG9vbCwgJG1tRlMsIG1tQ29yZURvd25sb2FkaW5nLCBtbUNvcmVOb3REb3dubG9hZGVkLCBtbUNvcmVPdXRkYXRlZCxcbiAgICAgICAgICAgIG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsIG1tYU1vZFJlc291cmNlQ29tcG9uZW50LCAkcSwgJG1tQ29udGVudExpbmtzSGVscGVyKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvdXJzZSBjb250ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlSGFuZGxlcnMjY291cnNlQ29udGVudFxuICAgICAqL1xuICAgIHNlbGYuY291cnNlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RSZXNvdXJjZS5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlICAgVGhlIG1vZHVsZSBpbmZvLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgVGhlIGNvdXJzZSBJRC5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25sb2FkQnRuLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoQnRuLFxuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbiA9ICRtbUZpbGVwb29sLmdldFJldmlzaW9uRnJvbUZpbGVMaXN0KG1vZHVsZS5jb250ZW50cyksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuXG4gICAgICAgICAgICAgICAgZG93bmxvYWRCdG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1pb3MtY2xvdWQtZG93bmxvYWQtb3V0bGluZScsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnbW0uY29yZS5kb3dubG9hZCcsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RSZXNvdXJjZS5wcmVmZXRjaENvbnRlbnQobW9kdWxlKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJGRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKCdtbS5jb3JlLmVycm9yZG93bmxvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZWZyZXNoQnRuID0ge1xuICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWFuZHJvaWQtcmVmcmVzaCcsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnbW0uY29yZS5yZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kUmVzb3VyY2UuaW52YWxpZGF0ZUNvbnRlbnQobW9kdWxlLmlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RSZXNvdXJjZS5wcmVmZXRjaENvbnRlbnQobW9kdWxlKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRkZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tLmNvcmUuZXJyb3Jkb3dubG9hZGluZycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IG1vZHVsZS5jb250ZW50c1swXS5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9ICRtbUZTLmdldEZpbGVFeHRlbnNpb24oZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlLmNvbnRlbnRzLmxlbmd0aCA9PSAxIHx8IChleHRlbnNpb24gIT0gXCJodG1sXCIgJiYgZXh0ZW5zaW9uICE9IFwiaHRtXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICRtbUZTLmdldEZpbGVJY29uKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ3Jlc291cmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKCdyZXNvdXJjZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkc2NvcGUuYnV0dG9ucyA9IFtkb3dubG9hZEJ0biwgcmVmcmVzaEJ0bl07XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2RfcmVzb3VyY2UnLCB7bW9kdWxlOiBtb2R1bGUsIGNvdXJzZWlkOiBjb3Vyc2VpZH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBTaG93IGJ1dHRvbnMgYWNjb3JkaW5nIHRvIG1vZHVsZSBzdGF0dXMuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2hvd1N0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBzdGF0dXMgPT09IG1tQ29yZURvd25sb2FkaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRCdG4uaGlkZGVuID0gc3RhdHVzICE9PSBtbUNvcmVOb3REb3dubG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEJ0bi5oaWRkZW4gPSBzdGF0dXMgIT09IG1tQ29yZU91dGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoaXMgbW9kdWxlIHN0YXR1cy5cbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzT2JzZXJ2ZXIgPSAkbW1FdmVudHMub24obW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zaXRlaWQgPT09ICRtbVNpdGUuZ2V0SWQoKSAmJiBkYXRhLmNvbXBvbmVudElkID09PSBtb2R1bGUuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbXBvbmVudCA9PT0gbW1hTW9kUmVzb3VyY2VDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dTdGF0dXMoZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY3VycmVudCBzdGF0dXMgdG8gZGVjaWRlIHdoaWNoIGljb24gc2hvdWxkIGJlIHNob3duLlxuICAgICAgICAgICAgICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUuZ2V0TW9kdWxlU3RhdHVzKG1vZHVsZSwgY291cnNlaWQsIHJldmlzaW9uLCB0aW1lbW9kaWZpZWQpLnRoZW4oc2hvd1N0YXR1cyk7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNPYnNlcnZlciAmJiBzdGF0dXNPYnNlcnZlci5vZmYgJiYgc3RhdHVzT2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlSGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRW5hYmxlZChzaXRlSWQsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFJlc291cmNlLmlzUGx1Z2luRW5hYmxlZChzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb3Vyc2VJZCB8fCAkbW1Db3Vyc2UuY2FuR2V0TW9kdWxlV2l0aG91dENvdXJzZUlkKHNpdGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSByZXNvdXJjZSBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJy9tb2QvcmVzb3VyY2Uvdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfcmVzb3VyY2UnKVxuXG4vKipcbiAqIE1vZCByZXNvdXJjZSBwcmVmZXRjaCBoYW5kbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZVByZWZldGNoSGFuZGxlclxuICovXG4uZmFjdG9yeSgnJG1tYU1vZFJlc291cmNlUHJlZmV0Y2hIYW5kbGVyJywgZnVuY3Rpb24oJG1tYU1vZFJlc291cmNlLCAkbW1TaXRlLCBtbWFNb2RSZXNvdXJjZUNvbXBvbmVudCkge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIHNlbGYuY29tcG9uZW50ID0gbW1hTW9kUmVzb3VyY2VDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRvd25sb2FkIHNpemUgb2YgYSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlUHJlZmV0Y2hIYW5kbGVyI2dldERvd25sb2FkU2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgTW9kdWxlIHRvIGdldCB0aGUgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIFNpemUuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZFNpemUgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoJG1tYU1vZFJlc291cmNlLmlzRmlsZURvd25sb2FkYWJsZShjb250ZW50KSAmJiBjb250ZW50LmZpbGVzaXplKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHNpemUgKyBjb250ZW50LmZpbGVzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlUHJlZmV0Y2hIYW5kbGVyI2lzRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuY2FuRG93bmxvYWRGaWxlcygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCB0aGUgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZVByZWZldGNoSGFuZGxlciNwcmVmZXRjaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWxsIGZpbGVzIGhhdmUgYmVlbiBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLnByZWZldGNoID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kUmVzb3VyY2UucHJlZmV0Y2hDb250ZW50KG1vZHVsZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfcmVzb3VyY2UnKVxuXG4vKipcbiAqIFJlc291cmNlIGZhY3RvcnkuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZFJlc291cmNlXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kUmVzb3VyY2UnLCBmdW5jdGlvbigkbW1GaWxlcG9vbCwgJG1tU2l0ZSwgJG1tVXRpbCwgJG1tRlMsICRodHRwLCAkbG9nLCAkcSwgJHNjZSwgJG1tQXBwLCAkbW1TaXRlc01hbmFnZXIsXG4gICAgICAgICAgICBtbWFNb2RSZXNvdXJjZUNvbXBvbmVudCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hTW9kUmVzb3VyY2UnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbGwgdGhlIGNvbnRlbnQuIEFsbCB0aGUgZmlsZXMgYXJlIGRvd25sb2FkZWQgaW5zaWRlIGEgZm9sZGVyIGluIGZpbGVwb29sLCBrZWVwaW5nIHRoZWlyIGZvbGRlciBzdHJ1Y3R1cmUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlI2Rvd25sb2FkQWxsQ29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gY29udGVudCBpcyBkb3dubG9hZGVkLiBEYXRhIHJldHVybmVkIGlzIG5vdCByZWxpYWJsZS5cbiAgICAgKi9cbiAgICBzZWxmLmRvd25sb2FkQWxsQ29udGVudCA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBzZWxmLmdldERvd25sb2FkYWJsZUZpbGVzKG1vZHVsZSksXG4gICAgICAgICAgICBzaXRlaWQgPSAkbW1TaXRlLmdldElkKCksXG4gICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgcmV2aXNpb24gPSAkbW1GaWxlcG9vbC5nZXRSZXZpc2lvbkZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpLFxuICAgICAgICAgICAgdGltZW1vZCA9ICRtbUZpbGVwb29sLmdldFRpbWVtb2RpZmllZEZyb21GaWxlTGlzdChtb2R1bGUuY29udGVudHMpO1xuXG4gICAgICAgIGlmIChzZWxmLmlzRGlzcGxheWVkSW5JZnJhbWUobW9kdWxlKSkge1xuICAgICAgICAgICAgLy8gR2V0IHBhdGggb2YgdGhlIG1vZHVsZSBmb2xkZXIgaW4gZmlsZXBvb2wuXG4gICAgICAgICAgICBwcm9taXNlID0gJG1tRmlsZXBvb2wuZ2V0RmlsZVBhdGhCeVVybChzaXRlaWQsIG1vZHVsZS51cmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGlyUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmRvd25sb2FkUGFja2FnZShzaXRlaWQsIGZpbGVzLCBtbWFNb2RSZXNvdXJjZUNvbXBvbmVudCwgbW9kdWxlLmlkLCByZXZpc2lvbiwgdGltZW1vZCwgZGlyUGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlcyB0aGF0IGNhbiBiZSBkb3dubG9hZGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RyZXNvdXJjZSNnZXREb3dubG9hZGFibGVGaWxlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgVGhlIG1vZHVsZSBvYmplY3QgcmV0dXJuZWQgYnkgV1MuXG4gICAgICogQHJldHVybiB7T2JqZWN0W119ICAgICBMaXN0IG9mIGZpbGVzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RG93bmxvYWRhYmxlRmlsZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gW107XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZHVsZS5jb250ZW50cywgZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNGaWxlRG93bmxvYWRhYmxlKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgZmlsZXMucHVzaChjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXZlbnQgbmFtZXMgb2YgZmlsZXMgYmVpbmcgZG93bmxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2UjZ2V0RG93bmxvYWRpbmdGaWxlc0V2ZW50TmFtZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXREb3dubG9hZGluZ0ZpbGVzRXZlbnROYW1lcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgIGV2ZW50TmFtZXMgPSBbXSxcbiAgICAgICAgICAgIHNpdGVpZCA9ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gY29udGVudC5maWxldXJsO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzRmlsZURvd25sb2FkYWJsZShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tRmlsZXBvb2wuaXNGaWxlRG93bmxvYWRpbmdCeVVybChzaXRlaWQsIHVybCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZ2V0RmlsZUV2ZW50TmFtZUJ5VXJsKHNpdGVpZCwgdXJsKS50aGVuKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWVzLnB1c2goZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBmYWlscy5cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE5hbWVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZmlsZSBldmVudCBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2UjZ2V0RmlsZUV2ZW50TmFtZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhcnJheSBvZiAkbW1FdmVudCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZWxmLmdldEZpbGVFdmVudE5hbWVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kdWxlLmNvbnRlbnRzLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gY29udGVudC5maWxldXJsO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzRmlsZURvd25sb2FkYWJsZShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tRmlsZXBvb2wuZ2V0RmlsZUV2ZW50TmFtZUJ5VXJsKCRtbVNpdGUuZ2V0SWQoKSwgdXJsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE5hbWVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgYWxsIHRoZSBmaWxlcyBuZWVkZWQgYW5kIHJldHVybnMgdGhlIHNyYyBvZiB0aGUgaWZyYW1lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZSNnZXRJZnJhbWVTcmNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBpZnJhbWUgc3JjLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0SWZyYW1lU3JjID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIGlmICghbW9kdWxlLmNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1haW5GaWxlID0gbW9kdWxlLmNvbnRlbnRzWzBdLFxuICAgICAgICAgICAgbWFpbkZpbGVQYXRoID0gbWFpbkZpbGUuZmlsZW5hbWU7XG5cbiAgICAgICAgaWYgKG1haW5GaWxlLmZpbGVwYXRoICE9PSAnLycpIHtcbiAgICAgICAgICAgIG1haW5GaWxlUGF0aCA9IG1haW5GaWxlLmZpbGVwYXRoLnN1YnN0cigxKSArIG1haW5GaWxlUGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXREaXJlY3RvcnlVcmxCeVVybCgkbW1TaXRlLmdldElkKCksIG1vZHVsZS51cmwpLnRoZW4oZnVuY3Rpb24oZGlyUGF0aCkge1xuICAgICAgICAgICAgLy8gVGhpcyBVUkwgaXMgZ29pbmcgdG8gYmUgaW5qZWN0ZWQgaW4gYW4gaWZyYW1lLCB3ZSBuZWVkIHRydXN0QXNSZXNvdXJjZVVybCB0byBtYWtlIGl0IHdvcmsgaW4gYSBicm93c2VyLlxuICAgICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKCRtbUZTLmNvbmNhdGVuYXRlUGF0aHMoZGlyUGF0aCwgbWFpbkZpbGVQYXRoKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gRXJyb3IgZ2V0dGluZyBkaXJlY3RvcnksIHRoZXJlIHdhcyBhbiBlcnJvciBkb3dubG9hZGluZyBvciB3ZSdyZSBpbiBicm93c2VyLiBSZXR1cm4gb25saW5lIFVSTC5cbiAgICAgICAgICAgIGlmICgkbW1BcHAuaXNPbmxpbmUoKSAmJiBtYWluRmlsZS5maWxldXJsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBVUkwgaXMgZ29pbmcgdG8gYmUgaW5qZWN0ZWQgaW4gYW4gaWZyYW1lLCB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBpdCB3b3JrLlxuICAgICAgICAgICAgICAgIHJldHVybiAkc2NlLnRydXN0QXNSZXNvdXJjZVVybCgkbW1TaXRlLmZpeFBsdWdpbmZpbGVVUkwobWFpbkZpbGUuZmlsZXVybCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmVzb3VyY2UgSFRNTC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2UjZ2V0UmVzb3VyY2VIdG1sXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gY29udGVudHMgQXJyYXkgb2YgY29udGVudCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb2R1bGVJZCBUaGUgbW9kdWxlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbdGFyZ2V0XSBUaGUgSFRNTCBmaWxlIHRoYXQgdGhlIHVzZXIgd2FudHMgdG8gb3BlbiwgaWYgbm90IGRlZmluZWQgdXNlcyB0aGUgbWFpbiBmaWxlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5nZXRSZXNvdXJjZUh0bWwgPSBmdW5jdGlvbihjb250ZW50cywgbW9kdWxlSWQsIHRhcmdldCkge1xuICAgICAgICB2YXIgaW5kZXhVcmwsXG4gICAgICAgICAgICBwYXRocyA9IHt9LFxuICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICAvLyBFeHRyYWN0IHRoZSBpbmZvcm1hdGlvbiBhYm91dCBwYXRocyBmcm9tIHRoZSBtb2R1bGUgY29udGVudHMuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250ZW50cywgZnVuY3Rpb24oY29udGVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBjb250ZW50LmZpbGV1cmwsXG4gICAgICAgICAgICAgICAgZnVsbHBhdGggPSBjb250ZW50LmZpbGVuYW1lO1xuXG4gICAgICAgICAgICBpZiAoY29udGVudC5maWxlcGF0aCAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgZnVsbHBhdGggPSBjb250ZW50LmZpbGVwYXRoLnN1YnN0cigxKSArIGZ1bGxwYXRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGFyZ2V0ID09IGZ1bGxwYXRoKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGFub3RoZXIgaW5kZXguXG4gICAgICAgICAgICAgICAgaW5kZXhVcmwgPSB1cmw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICd1bmRlZmluZWQnICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBtYWluIHBhZ2UsIGl0IHNob3VsZCBhbHdheXMgYmUgdGhlIGZpcnN0IG9uZS5cbiAgICAgICAgICAgICAgICBpbmRleFVybCA9IHVybDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQW55IG90aGVyIGZpbGUgaW4gdGhlIHJlc291cmNlLlxuICAgICAgICAgICAgICAgIHBhdGhzW2Z1bGxwYXRoXSA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvbWlzZSBoYW5kbGluZyB3aGVuIHdlIGFyZSBpbiBhIGJyb3dzZXIuXG4gICAgICAgIHByb21pc2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWluZGV4VXJsKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZXZlciB0aGF0IGhhcHBlbnMuXG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ291bGQgbm90IGxvY2F0ZSB0aGUgaW5kZXggcGFnZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpbGUgc3lzdGVtIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZG93bmxvYWRVcmwoJG1tU2l0ZS5nZXRJZCgpLCBpbmRleFVybCwgZmFsc2UsIG1tYU1vZFJlc291cmNlQ29tcG9uZW50LCBtb2R1bGVJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJldHVybiB0aGUgbGl2ZSBVUkwuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oJG1tU2l0ZS5maXhQbHVnaW5maWxlVVJMKGluZGV4VXJsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBVUkwgY29udGVudC5cbiAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQodXJsKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5kYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHRoYXQgd2UgaGF2ZSB0aGUgY29udGVudCwgd2UgdXBkYXRlIHRoZSBTUkMgdG8gcG9pbnQgYmFjayB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZXh0ZXJuYWwgcmVzb3VyY2UuIFRoYXQgd2lsbCBiZSBjYXVnaHQgYnkgbW0tZm9ybWF0LXRleHQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBodG1sID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2PicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbC5hcHBlbmQocmVzcG9uc2UuZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGh0bWwuZmluZCgnaW1nJyksIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyYyA9IHBhdGhzW2RlY29kZVVSSUNvbXBvbmVudChpbWcuZ2V0QXR0cmlidXRlKCdzcmMnKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnc3JjJywgc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoZSBzYW1lIGZvciBsaW5rcy5cbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGh0bWwuZmluZCgnYScpLCBmdW5jdGlvbihhbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBocmVmID0gZGVjb2RlVVJJQ29tcG9uZW50KGFuY2hvci5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gcGF0aHNbaHJlZl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ID0gJG1tRlMuZ2V0RmlsZUV4dGVuc2lvbihocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHQgPT0gJ2h0bWwnIHx8IGV4dCA9PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnbW1hLW1vZC1yZXNvdXJjZS1odG1sLWxpbmsnLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJywgaHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHRtbC5odG1sKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIHRoZSBwcmVmZXRjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlI2ludmFsaWRhdGVDb250ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vZHVsZUlkIFRoZSBtb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVDb250ZW50ID0gZnVuY3Rpb24obW9kdWxlSWQpIHtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmludmFsaWRhdGVGaWxlc0J5Q29tcG9uZW50KCRtbVNpdGUuZ2V0SWQoKSwgbW1hTW9kUmVzb3VyY2VDb21wb25lbnQsIG1vZHVsZUlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVzb3VyY2UgaGFzIHRvIGJlIGRpc3BsYXllZCBpbiBhbiBpZnJhbWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfcmVzb3VyY2VcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFJlc291cmNlI2lzRGlzcGxheWVkSW5JZnJhbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2VsZi5pc0Rpc3BsYXllZEluSWZyYW1lID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIHZhciBpbmxpbmUgPSBzZWxmLmlzRGlzcGxheWVkSW5saW5lKG1vZHVsZSk7XG5cbiAgICAgICAgaWYgKGlubGluZSAmJiAkbW1GUy5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZS5jb250ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBleHQgPSAkbW1GUy5nZXRGaWxlRXh0ZW5zaW9uKG1vZHVsZS5jb250ZW50c1tpXS5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4dCA9PSAnanMnIHx8IGV4dCA9PSAnc3dmJyB8fCBleHQgPT0gJ2NzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZXNvdXJjZSBpcyB0byBiZSBkaXNwbGF5ZWQgaW5saW5lIChIVE1MKS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2UjaXNEaXNwbGF5ZWRJbmxpbmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2VsZi5pc0Rpc3BsYXllZElubGluZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICBpZiAoIW1vZHVsZS5jb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0ID0gJG1tRlMuZ2V0RmlsZUV4dGVuc2lvbihtb2R1bGUuY29udGVudHNbMF0uZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gZXh0ID09PSAnaHRtJyB8fCBleHQgPT09ICdodG1sJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBmaWxlIGlzIGRvd25sb2FkYWJsZS4gVGhlIGZpbGUgcGFyYW0gbXVzdCBoYXZlIGEgJ3R5cGUnIGF0dHJpYnV0ZSBsaWtlIGluIGNvcmVfY291cnNlX2dldF9jb250ZW50cyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9yZXNvdXJjZVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kUmVzb3VyY2UjaXNGaWxlRG93bmxvYWRhYmxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGUgRmlsZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICBUcnVlIGlmIGRvd25sb2FkYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNGaWxlRG93bmxvYWRhYmxlID0gZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICByZXR1cm4gZmlsZS50eXBlID09PSAnZmlsZSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHJlc291cmNlIHBsdWdpbiBpcyBlbmFibGVkIGluIGEgY2VydGFpbiBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZSNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLmNhbkRvd25sb2FkRmlsZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCB0aGUgcmVzb3VyY2UgYXMgYmVpbmcgdmlld2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZSNsb2dWaWV3XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIE1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sb2dWaWV3ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHJlc291cmNlaWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9yZXNvdXJjZV92aWV3X3Jlc291cmNlJywgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGFuZCBvcGVuIHRoZSBmaWxlIGZyb20gdGhlIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZSNvcGVuRmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbnRlbnRzIEFycmF5IG9mIGNvbnRlbnQgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9kdWxlSWQgVGhlIG1vZHVsZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYub3BlbkZpbGUgPSBmdW5jdGlvbihjb250ZW50cywgbW9kdWxlSWQpIHtcbiAgICAgICAgaWYgKCFjb250ZW50cyB8fCAhY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXJsID0gY29udGVudHNbMF0uZmlsZXVybCxcbiAgICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgaWYgKCRtbUZTLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmaWxlIHN5c3RlbSBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICBwcm9taXNlID0gJG1tRmlsZXBvb2wuZG93bmxvYWRVcmwoJG1tU2l0ZS5nZXRJZCgpLCB1cmwsIGZhbHNlLCBtbWFNb2RSZXNvdXJjZUNvbXBvbmVudCwgbW9kdWxlSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBsaXZlIFVSTC5cbiAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKCRtbVNpdGUuZml4UGx1Z2luZmlsZVVSTCh1cmwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24obG9jYWxVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1VdGlsLm9wZW5GaWxlKGxvY2FsVXJsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIHRoZSBjb250ZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Jlc291cmNlXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RSZXNvdXJjZSNwcmVmZXRjaENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgb2JqZWN0IHJldHVybmVkIGJ5IFdTLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGNvbnRlbnQgaXMgZG93bmxvYWRlZC4gRGF0YSByZXR1cm5lZCBpcyBub3QgcmVsaWFibGUuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaENvbnRlbnQgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gc2VsZi5nZXREb3dubG9hZGFibGVGaWxlcyhtb2R1bGUpLFxuICAgICAgICAgICAgc2l0ZWlkID0gJG1tU2l0ZS5nZXRJZCgpLFxuICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgIHJldmlzaW9uID0gJG1tRmlsZXBvb2wuZ2V0UmV2aXNpb25Gcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKSxcbiAgICAgICAgICAgIHRpbWVtb2QgPSAkbW1GaWxlcG9vbC5nZXRUaW1lbW9kaWZpZWRGcm9tRmlsZUxpc3QobW9kdWxlLmNvbnRlbnRzKTtcblxuICAgICAgICBpZiAoc2VsZi5pc0Rpc3BsYXllZEluSWZyYW1lKG1vZHVsZSkpIHtcbiAgICAgICAgICAgIC8vIEdldCBwYXRoIG9mIHRoZSBtb2R1bGUgZm9sZGVyIGluIGZpbGVwb29sLlxuICAgICAgICAgICAgcHJvbWlzZSA9ICRtbUZpbGVwb29sLmdldEZpbGVQYXRoQnlVcmwoc2l0ZWlkLCBtb2R1bGUudXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGRpclBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5wcmVmZXRjaFBhY2thZ2Uoc2l0ZWlkLCBmaWxlcywgbW1hTW9kUmVzb3VyY2VDb21wb25lbnQsIG1vZHVsZS5pZCwgcmV2aXNpb24sIHRpbWVtb2QsIGRpclBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9zY29ybScpXG5cbi8qKlxuICogU0NPUk0gaW5kZXggY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RTY29ybUluZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kU2Nvcm1JbmRleEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tYU1vZFNjb3JtLCAkbW1VdGlsLCAkcSwgJG1tQ291cnNlLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSxcbiAgICAgICAgICAgICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUsICRtbWFNb2RTY29ybUhlbHBlciwgJG1tRXZlbnRzLCAkbW1TaXRlLCAkc3RhdGUsIG1tQ29yZU91dGRhdGVkLCBtbUNvcmVOb3REb3dubG9hZGVkLFxuICAgICAgICAgICAgbW1Db3JlRG93bmxvYWRpbmcsIG1tYU1vZFNjb3JtQ29tcG9uZW50LCBtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLCAkaW9uaWNIaXN0b3J5LCBtbWFNb2RTY29ybUV2ZW50QXV0b21TeW5jZWQsXG4gICAgICAgICAgICAkbW1hTW9kU2Nvcm1TeW5jLCAkdGltZW91dCkge1xuXG4gICAgdmFyIG1vZHVsZSA9ICRzdGF0ZVBhcmFtcy5tb2R1bGUgfHwge30sXG4gICAgICAgIGNvdXJzZWlkID0gJHN0YXRlUGFyYW1zLmNvdXJzZWlkLFxuICAgICAgICBzY29ybSxcbiAgICAgICAgc3RhdHVzT2JzZXJ2ZXIsXG4gICAgICAgIGN1cnJlbnRTdGF0dXMsXG4gICAgICAgIGxhc3RBdHRlbXB0LFxuICAgICAgICBsYXN0T2ZmbGluZSA9IGZhbHNlLFxuICAgICAgICBhdHRlbXB0cyxcbiAgICAgICAgc2Nyb2xsVmlldyA9ICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnbW1hTW9kU2Nvcm1JbmRleFNjcm9sbCcpO1xuXG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbW9kdWxlLmRlc2NyaXB0aW9uO1xuICAgICRzY29wZS5tb2R1bGVVcmwgPSBtb2R1bGUudXJsO1xuICAgICRzY29wZS5jdXJyZW50T3JnYW5pemF0aW9uID0ge307XG4gICAgJHNjb3BlLnNjb3JtT3B0aW9ucyA9IHtcbiAgICAgICAgbW9kZTogJG1tYU1vZFNjb3JtLk1PREVOT1JNQUxcbiAgICB9O1xuXG4gICAgJHNjb3BlLm1vZGVub3JtYWwgPSAkbW1hTW9kU2Nvcm0uTU9ERU5PUk1BTDtcbiAgICAkc2NvcGUubW9kZWJyb3dzZSA9ICRtbWFNb2RTY29ybS5NT0RFQlJPV1NFO1xuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IFNDT1JNIGRhdGEuXG4gICAgZnVuY3Rpb24gZmV0Y2hTY29ybURhdGEocmVmcmVzaCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldFNjb3JtKGNvdXJzZWlkLCBtb2R1bGUuaWQsIG1vZHVsZS51cmwpLnRoZW4oZnVuY3Rpb24oc2Nvcm1EYXRhKSB7XG4gICAgICAgICAgICBzY29ybSA9IHNjb3JtRGF0YTtcblxuICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gc2Nvcm0ubmFtZSB8fCAkc2NvcGUudGl0bGU7XG4gICAgICAgICAgICAkc2NvcGUuZGVzY3JpcHRpb24gPSBzY29ybS5pbnRybyB8fMKgJHNjb3BlLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgJHNjb3BlLnNjb3JtID0gc2Nvcm07XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAkbW1hTW9kU2Nvcm0uaXNTY29ybVN1cHBvcnRlZChzY29ybSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZXJyb3JNZXNzYWdlID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2Nvcm0ud2FybmluZ21lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFNDT1JNIGlzIGNsb3NlZCBvciBub3Qgb3BlbiB5ZXQsIHdlIGNhbid0IGdldCBtb3JlIGRhdGEuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzeW5jU2Nvcm0oIXJlZnJlc2gsIGZhbHNlKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzLCBrZWVwIGdldHRpbmcgZGF0YSBldmVuIGlmIHN5bmMgZmFpbHMuXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZXR1cm4gdGhpcyBwcm9taXNlLCBpdCBzaG91bGQgYmUgZmFzdGVyIHRoYW4gdGhlIHJlc3QuXG4gICAgICAgICAgICAgICAgJG1tYU1vZFNjb3JtSGVscGVyLmdldFNjb3JtUmVhZGFibGVTeW5jVGltZShzY29ybS5pZCkudGhlbihmdW5jdGlvbihzeW5jVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3luY1RpbWUgPSBzeW5jVGltZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzIGFuZCBjaGVjayBpZiBTQ09STSBpcyBpbmNvbXBsZXRlLlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0QXR0ZW1wdENvdW50KHNjb3JtLmlkKS50aGVuKGZ1bmN0aW9uKGF0dGVtcHRzRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0cyA9IGF0dGVtcHRzRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNob3dTeW5jQnV0dG9uID0gYXR0ZW1wdHMub2ZmbGluZS5sZW5ndGg7IC8vIFNob3cgc3luYyBidXR0b24gb25seSBpZiB0aGVyZSBhcmUgb2ZmbGluZSBhdHRlbXB0cy5cblxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGF0dGVtcHQgdGhhdCB3aWxsIGJlIGNvbnRpbnVlZCBvciByZXZpZXdlZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybUhlbHBlci5kZXRlcm1pbmVBdHRlbXB0VG9Db250aW51ZShzY29ybSwgYXR0ZW1wdHMpLnRoZW4oZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEF0dGVtcHQgPSBhdHRlbXB0Lm51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RPZmZsaW5lID0gYXR0ZW1wdC5vZmZsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RBdHRlbXB0ICE9IGF0dGVtcHRzLmxhc3RBdHRlbXB0Lm51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5hdHRlbXB0VG9Db250aW51ZSA9IGxhc3RBdHRlbXB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmF0dGVtcHRUb0NvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmlzQXR0ZW1wdEluY29tcGxldGUoc2Nvcm0uaWQsIGxhc3RBdHRlbXB0LCBsYXN0T2ZmbGluZSkudGhlbihmdW5jdGlvbihpbmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29ybS5pbmNvbXBsZXRlID0gaW5jb21wbGV0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29ybS5udW1BdHRlbXB0cyA9IGF0dGVtcHRzLnRvdGFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JtLmdyYWRlbWV0aG9kUmVhZGFibGUgPSAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm1HcmFkZU1ldGhvZChzY29ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nvcm0uYXR0ZW1wdHNMZWZ0ID0gJG1tYU1vZFNjb3JtLmNvdW50QXR0ZW1wdHNMZWZ0KHNjb3JtLCBhdHRlbXB0cy5sYXN0QXR0ZW1wdC5udW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29ybS5mb3JjZWF0dGVtcHQgJiYgc2Nvcm0uaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2Nvcm1PcHRpb25zLm5ld0F0dGVtcHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZ2V0UmVwb3J0ZWRHcmFkZXMoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGZldGNoU3RydWN0dXJlKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29ybS5wYWNrYWdlc2l6ZSAmJiAkc2NvcGUuZXJyb3JNZXNzYWdlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTQ09STSBpcyBzdXBwb3J0ZWQgYnV0IHdlIGRvbid0IGhhdmUgcGFja2FnZSBzaXplLiBUcnkgdG8gY2FsY3VsYXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RTY29ybS5jYWxjdWxhdGVTY29ybVNpemUoc2Nvcm0pLnRoZW4oZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nvcm0ucGFja2FnZXNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHN0YXR1cy4gV2UgZG9uJ3QgYWRkIGdldFN0YXR1cyB0byBwcm9taXNlcyBiZWNhdXNlIGl0IHNob3VsZCBiZSBmYXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0YXR1c0xpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhdHVzKCkudGhlbihzaG93U3RhdHVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3dFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKCFyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHNjb3JtIGZhaWxlZCwgcmV0cnkgd2l0aG91dCB1c2luZyBjYWNoZSBzaW5jZSBpdCBtaWdodCBiZSBhIG5ldyBhY3Rpdml0eS5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmcmVzaERhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaG93RXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNob3cgZXJyb3IgbWVzc2FnZSBhbmQgcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAgICBmdW5jdGlvbiBzaG93RXJyb3IobWVzc2FnZSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICAgICAgZGVmYXVsdE1lc3NhZ2UgPSBkZWZhdWx0TWVzc2FnZSB8fMKgJ21tYS5tb2Rfc2Nvcm0uZXJyb3JnZXRzY29ybSc7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChkZWZhdWx0TWVzc2FnZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgZ3JhZGVzIG9mIGVhY2ggYXR0ZW1wdCBhbmQgdGhlIGdyYWRlIG9mIHRoZSBTQ09STS5cbiAgICBmdW5jdGlvbiBnZXRSZXBvcnRlZEdyYWRlcygpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIHNjb3JtLm9ubGluZUF0dGVtcHRzID0ge307XG4gICAgICAgIHNjb3JtLm9mZmxpbmVBdHRlbXB0cyA9IHt9O1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGdyYWRlIGZvciBlYWNoIGF0dGVtcHQuXG4gICAgICAgIGF0dGVtcHRzLm9ubGluZS5mb3JFYWNoKGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgYXR0ZW1wdCBpc24ndCBpbiBvZmZsaW5lIHRvIHByZXZlbnQgc2hvd2luZyB0aGUgc2FtZSBhdHRlbXB0IHR3aWNlLiBPZmZsaW5lIHNob3VsZCBiZSBtb3JlIHJlY2VudC5cbiAgICAgICAgICAgIGlmIChhdHRlbXB0cy5vZmZsaW5lLmluZGV4T2YoYXR0ZW1wdCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGdldEF0dGVtcHRHcmFkZShzY29ybSwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXR0ZW1wdHMub2ZmbGluZS5mb3JFYWNoKGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goZ2V0QXR0ZW1wdEdyYWRlKHNjb3JtLCBhdHRlbXB0LCB0cnVlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZ3JhZGUgb2YgdGhlIHdob2xlIFNDT1JNLiBXZSBvbmx5IHVzZSBvbmxpbmUgYXR0ZW1wdHMgdG8gY2FsY3VsYXRlIHRoaXMgZGF0YS5cbiAgICAgICAgICAgIHNjb3JtLmdyYWRlID0gJG1tYU1vZFNjb3JtLmNhbGN1bGF0ZVNjb3JtR3JhZGUoc2Nvcm0sIHNjb3JtLm9ubGluZUF0dGVtcHRzKTtcblxuICAgICAgICAgICAgLy8gTm93IGZvcm1hdCB0aGUgZ3JhZGVzLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjb3JtLm9ubGluZUF0dGVtcHRzLCBmdW5jdGlvbihhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdC5ncmFkZSA9ICRtbWFNb2RTY29ybS5mb3JtYXRHcmFkZShzY29ybSwgYXR0ZW1wdC5ncmFkZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY29ybS5vZmZsaW5lQXR0ZW1wdHMsIGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0LmdyYWRlID0gJG1tYU1vZFNjb3JtLmZvcm1hdEdyYWRlKHNjb3JtLCBhdHRlbXB0LmdyYWRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Nvcm0uZ3JhZGUgPSAkbW1hTW9kU2Nvcm0uZm9ybWF0R3JhZGUoc2Nvcm0sIHNjb3JtLmdyYWRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IHRoZSBncmFkZSBvZiBhbiBhdHRlbXB0IGFuZCBhZGQgaXQgdG8gdGhlIHNjb3JtIGF0dGVtcHRzIGxpc3QuXG4gICAgZnVuY3Rpb24gZ2V0QXR0ZW1wdEdyYWRlKHNjb3JtLCBhdHRlbXB0LCBvZmZsaW5lKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0QXR0ZW1wdEdyYWRlKHNjb3JtLCBhdHRlbXB0LCBvZmZsaW5lKS50aGVuKGZ1bmN0aW9uKGdyYWRlKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiBhdHRlbXB0LFxuICAgICAgICAgICAgICAgIGdyYWRlOiBncmFkZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvZmZsaW5lKSB7XG4gICAgICAgICAgICAgICAgc2Nvcm0ub2ZmbGluZUF0dGVtcHRzW2F0dGVtcHRdID0gZW50cnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjb3JtLm9ubGluZUF0dGVtcHRzW2F0dGVtcHRdID0gZW50cnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZldGNoIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIFNDT1JNIChUT0MpLlxuICAgIGZ1bmN0aW9uIGZldGNoU3RydWN0dXJlKCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldE9yZ2FuaXphdGlvbnMoc2Nvcm0uaWQpLnRoZW4oZnVuY3Rpb24ob3JnYW5pemF0aW9ucykge1xuICAgICAgICAgICAgJHNjb3BlLm9yZ2FuaXphdGlvbnMgPSBvcmdhbml6YXRpb25zO1xuXG4gICAgICAgICAgICBpZiAoISRzY29wZS5jdXJyZW50T3JnYW5pemF0aW9uLmlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2FkIGZpcnN0IG9yZ2FuaXphdGlvbiAoaWYgYW55KS5cbiAgICAgICAgICAgICAgICBpZiAob3JnYW5pemF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmN1cnJlbnRPcmdhbml6YXRpb24uaWRlbnRpZmllciA9IG9yZ2FuaXphdGlvbnNbMF0uaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY3VycmVudE9yZ2FuaXphdGlvbi5pZGVudGlmaWVyID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbG9hZE9yZ2FuaXphdGlvblRvYygkc2NvcGUuY3VycmVudE9yZ2FuaXphdGlvbi5pZGVudGlmaWVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTG9hZCB0aGUgVE9DIG9mIGEgY2VydGFpbiBvcmdhbml6YXRpb24uXG4gICAgZnVuY3Rpb24gbG9hZE9yZ2FuaXphdGlvblRvYyhvcmdhbml6YXRpb25JZCkge1xuICAgICAgICBpZiAoIXNjb3JtLmRpc3BsYXljb3Vyc2VzdHJ1Y3R1cmUpIHtcbiAgICAgICAgICAgIC8vIFRPQyBpcyBub3QgZGlzcGxheWVkLCBubyBuZWVkIHRvIGxvYWQgaXQuXG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHNjb3BlLmxvYWRpbmdUb2MgPSB0cnVlO1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldE9yZ2FuaXphdGlvblRvYyhzY29ybS5pZCwgb3JnYW5pemF0aW9uSWQsIGxhc3RBdHRlbXB0LCBsYXN0T2ZmbGluZSkudGhlbihmdW5jdGlvbih0b2MpIHtcbiAgICAgICAgICAgICRzY29wZS50b2MgPSAkbW1hTW9kU2Nvcm0uZm9ybWF0VG9jVG9BcnJheSh0b2MpO1xuICAgICAgICAgICAgLy8gR2V0IGltYWdlcyBmb3IgZWFjaCBTQ08uXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLnRvYywgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICAgICAgc2NvLmltYWdlID0gJG1tYU1vZFNjb3JtLmdldFNjb1N0YXR1c0ljb24oc2NvLCBzY29ybS5pbmNvbXBsZXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gU2VhcmNoIG9yZ2FuaXphdGlvbiB0aXRsZS5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUub3JnYW5pemF0aW9ucywgZnVuY3Rpb24ob3JnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9yZy5pZGVudGlmaWVyID09IG9yZ2FuaXphdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jdXJyZW50T3JnYW5pemF0aW9uLnRpdGxlID0gb3JnLnRpdGxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUmVzaXplIHNjcm9sbCB0byBwcmV2ZW50IGVtcHR5IHNwYWNlcyBpZiBuZXcgVE9DIGlzIHNob3J0ZXIgdGhhbiBwcmV2aW91cyBUT0MuXG4gICAgICAgICAgICAkaW9uaWNTY3JvbGxEZWxlZ2F0ZS5yZXNpemUoKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS5sb2FkaW5nVG9jID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdldCBzdGF0dXMgb2YgdGhlIFNDT1JNLlxuICAgIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuICRtbUNvdXJzZVByZWZldGNoRGVsZWdhdGUuZ2V0TW9kdWxlU3RhdHVzKG1vZHVsZSwgY291cnNlaWQsIHNjb3JtLnNoYTFoYXNoLCAwKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYSBsaXN0ZW5lciB0byBtb25pdG9yIGNoYW5nZXMgb24gdGhpcyBTQ09STSBzdGF0dXMgdG8gc2hvdyBhIG1lc3NhZ2UgdG8gdGhlIHVzZXIuXG4gICAgZnVuY3Rpb24gc2V0U3RhdHVzTGlzdGVuZXIoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgc2V0LlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoaXMgbW9kdWxlIHN0YXR1cyB0byBzaG93IGEgbWVzc2FnZSB0byB0aGUgdXNlci5cbiAgICAgICAgc3RhdHVzT2JzZXJ2ZXIgPSAkbW1FdmVudHMub24obW1Db3JlRXZlbnRQYWNrYWdlU3RhdHVzQ2hhbmdlZCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuc2l0ZWlkID09PSAkbW1TaXRlLmdldElkKCkgJiYgZGF0YS5jb21wb25lbnRJZCA9PT0gc2Nvcm0uY291cnNlbW9kdWxlICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuY29tcG9uZW50ID09PSBtbWFNb2RTY29ybUNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHNob3dTdGF0dXMoZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTaG93aW5nIG9yIGhpZGUgYSBzdGF0dXMgbWVzc2FnZSBkZXBlbmRpbmcgb24gdGhlIFNDT1JNIHN0YXR1cy5cbiAgICBmdW5jdGlvbiBzaG93U3RhdHVzKHN0YXR1cykge1xuICAgICAgICBjdXJyZW50U3RhdHVzID0gc3RhdHVzO1xuXG4gICAgICAgIGlmIChzdGF0dXMgPT0gbW1Db3JlT3V0ZGF0ZWQpIHtcbiAgICAgICAgICAgICRzY29wZS5zdGF0dXNNZXNzYWdlID0gJ21tYS5tb2Rfc2Nvcm0uc2Nvcm1zdGF0dXNvdXRkYXRlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09IG1tQ29yZU5vdERvd25sb2FkZWQpIHtcbiAgICAgICAgICAgICRzY29wZS5zdGF0dXNNZXNzYWdlID0gJ21tYS5tb2Rfc2Nvcm0uc2Nvcm1zdGF0dXNub3Rkb3dubG9hZGVkJztcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gbW1Db3JlRG93bmxvYWRpbmcpIHtcbiAgICAgICAgICAgIGlmICghJHNjb3BlLmRvd25sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBiZWluZyBkb3dubG9hZGVkIHJpZ2h0IG5vdyBidXQgdGhlIHZpZXcgaXNuJ3QgdHJhY2tpbmcgaXQuIFwiUmVzdG9yZVwiIHRoZSBkb3dubG9hZC5cbiAgICAgICAgICAgICAgICBkb3dubG9hZFNjb3JtUGFja2FnZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5zdGF0dXNNZXNzYWdlID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWZyZXNoZXMgZGF0YS5cbiAgICBmdW5jdGlvbiByZWZyZXNoRGF0YShkb250Rm9yY2VTeW5jKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RTY29ybS5pbnZhbGlkYXRlU2Nvcm1EYXRhKGNvdXJzZWlkKSk7XG4gICAgICAgIGlmIChzY29ybSkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm0uaW52YWxpZGF0ZUFsbFNjb3JtRGF0YShzY29ybS5pZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNjb3JtRGF0YSghZG9udEZvcmNlU3luYyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERvd25sb2FkIGEgU0NPUk0gcGFja2FnZSBvciByZXN0b3JlcyBhbiBvbmdvaW5nIGRvd25sb2FkLlxuICAgIGZ1bmN0aW9uIGRvd25sb2FkU2Nvcm1QYWNrYWdlKCkge1xuICAgICAgICAkc2NvcGUuZG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmRvd25sb2FkKHNjb3JtKS50aGVuKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbihwcm9ncmVzcykge1xuXG4gICAgICAgICAgICBpZiAoIXByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MucGFja2FnZURvd25sb2FkKSB7IC8vIERvd25sb2FkaW5nIHBhY2thZ2UuXG4gICAgICAgICAgICAgICAgaWYgKHNjb3JtLnBhY2thZ2VzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5wZXJjZW50YWdlID0gKHBhcnNlRmxvYXQocHJvZ3Jlc3MubG9hZGVkIC8gc2Nvcm0ucGFja2FnZXNpemUpICogMTAwKS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvZ3Jlc3MubWVzc2FnZSkgeyAvLyBTaG93IGEgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAkc2NvcGUucHJvZ3Jlc3NNZXNzYWdlID0gcHJvZ3Jlc3MubWVzc2FnZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvZ3Jlc3MubG9hZGVkICYmIHByb2dyZXNzLnRvdGFsKSB7IC8vIFVuemlwcGluZyBwYWNrYWdlLlxuICAgICAgICAgICAgICAgICRzY29wZS5wZXJjZW50YWdlID0gKHBhcnNlRmxvYXQocHJvZ3Jlc3MubG9hZGVkIC8gcHJvZ3Jlc3MudG90YWwpICogMTAwKS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUucGVyY2VudGFnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLnByb2dyZXNzTWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICRzY29wZS5wZXJjZW50YWdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgJHNjb3BlLmRvd25sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE9wZW4gYSBTQ09STSBwYWNrYWdlLlxuICAgIGZ1bmN0aW9uIG9wZW5TY29ybShzY29JZCkge1xuICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW9kX3Njb3JtLXBsYXllcicsIHtcbiAgICAgICAgICAgIHNjb3JtOiBzY29ybSxcbiAgICAgICAgICAgIG1vZGU6ICRzY29wZS5zY29ybU9wdGlvbnMubW9kZSxcbiAgICAgICAgICAgIG5ld0F0dGVtcHQ6ICEhJHNjb3BlLnNjb3JtT3B0aW9ucy5uZXdBdHRlbXB0LFxuICAgICAgICAgICAgb3JnYW5pemF0aW9uSWQ6ICRzY29wZS5jdXJyZW50T3JnYW5pemF0aW9uLmlkZW50aWZpZXIsXG4gICAgICAgICAgICBzY29JZDogc2NvSWRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVHJpZXMgdG8gc3luY2hyb25pemUgdGhlIGN1cnJlbnQgU0NPUk0uXG4gICAgZnVuY3Rpb24gc3luY1Njb3JtKGNoZWNrVGltZSwgc2hvd0Vycm9ycykge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IGNoZWNrVGltZSA/ICRtbWFNb2RTY29ybVN5bmMuc3luY1Njb3JtSWZOZWVkZWQoc2Nvcm0pIDogJG1tYU1vZFNjb3JtU3luYy5zeW5jU2Nvcm0oc2Nvcm0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHdhcm5pbmdzKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICRtbWFNb2RTY29ybUhlbHBlci5idWlsZFdhcm5pbmdzTWVzc2FnZSh3YXJuaW5ncyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKHNob3dFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvd0Vycm9yKGVyciwgJ21tYS5tb2Rfc2Nvcm0uZXJyb3JzeW5jc2Nvcm0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggdGhlIFNDT1JNIGRhdGEuXG4gICAgZmV0Y2hTY29ybURhdGEoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTW9kU2Nvcm0ubG9nVmlldyhzY29ybS5pZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRtbUNvdXJzZS5jaGVja01vZHVsZUNvbXBsZXRpb24oY291cnNlaWQsIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLnNjb3JtTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIExvYWQgYSBvcmdhbml6YXRpb24ncyBUT0MuXG4gICAgJHNjb3BlLmxvYWRPcmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZE9yZ2FuaXphdGlvblRvYygkc2NvcGUuY3VycmVudE9yZ2FuaXphdGlvbi5pZGVudGlmaWVyKS5jYXRjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvd0Vycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLnJlZnJlc2hTY29ybSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWZyZXNoRGF0YSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gT3BlbiBhIFNDT1JNLiBJdCB3aWxsIGRvd25sb2FkIHRoZSBTQ09STSBwYWNrYWdlIGlmIGl0J3Mgbm90IGRvd25sb2FkZWQgb3IgaXQgaGFzIGNoYW5nZWQuXG4gICAgLy8gVGhlIHNjb0lkIHBhcmFtIGluZGljYXRlcyB0aGUgU0NPIHRoYXQgbmVlZHMgdG8gYmUgbG9hZGVkIHdoZW4gdGhlIFNDT1JNIGlzIG9wZW5lZC4gSWYgbm90IGRlZmluZWQsIGxvYWQgZmlyc3QgU0NPLlxuICAgICRzY29wZS5vcGVuID0gZnVuY3Rpb24oZSwgc2NvSWQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmICgkc2NvcGUuZG93bmxvYWRpbmcpIHtcbiAgICAgICAgICAgIC8vIFNjb3BlIGlzIGJlaW5nIGRvd25sb2FkZWQsIGFib3J0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0dXMgPT0gbW1Db3JlT3V0ZGF0ZWQgfHwgY3VycmVudFN0YXR1cyA9PSBtbUNvcmVOb3REb3dubG9hZGVkKSB7XG4gICAgICAgICAgICAvLyBTQ09STSBuZWVkcyB0byBiZSBkb3dubG9hZGVkLlxuICAgICAgICAgICAgJG1tYU1vZFNjb3JtSGVscGVyLmNvbmZpcm1Eb3dubG9hZChzY29ybSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGZpbGUgaWYgU0NPUk0gaXMgb3V0ZGF0ZWQuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBjdXJyZW50U3RhdHVzID09IG1tQ29yZU91dGRhdGVkID8gJG1tYU1vZFNjb3JtLmludmFsaWRhdGVDb250ZW50KHNjb3JtLmNvdXJzZW1vZHVsZSkgOiAkcS53aGVuKCk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZFNjb3JtUGFja2FnZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzIGRvd25sb2FkaW5nLCBvcGVuIHNjb3JtIGlmIHVzZXIgaGFzbid0IGxlZnQgdGhlIHZpZXcuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJGRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5TY29ybShzY29JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRkZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kU2Nvcm1IZWxwZXIuc2hvd0Rvd25sb2FkRXJyb3Ioc2Nvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3BlblNjb3JtKHNjb0lkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTeW5jaHJvbml6ZSB0aGUgU0NPUk0uXG4gICAgJHNjb3BlLnN5bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbS5zZXR0aW5ncy5zeW5jaHJvbml6aW5nJywgdHJ1ZSk7XG4gICAgICAgIHN5bmNTY29ybShmYWxzZSwgdHJ1ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlZnJlc2ggdGhlIGRhdGEuXG4gICAgICAgICAgICAkc2NvcGUuc2Nvcm1Mb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICByZWZyZXNoRGF0YSh0cnVlKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5zY29ybUxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZGFsLmRpc21pc3MoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBkYXRhIHdoZW4gd2UgY29tZSBiYWNrIGZyb20gdGhlIHBsYXllciBzaW5jZSBpdCdzIHByb2JhYmxlIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG4gICAgLy8gV2Ugd2FudCB0byBza2lwIHRoZSBmaXJzdCAkaW9uaWNWaWV3LmVudGVyIGV2ZW50IGJlY2F1c2UgaXQncyB3aGVuIHRoZSB2aWV3IGlzIGNyZWF0ZWQuXG4gICAgdmFyIHNraXAgPSB0cnVlO1xuICAgICRzY29wZS4kb24oJyRpb25pY1ZpZXcuZW50ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgICRzY29wZS5zY29ybU9wdGlvbnMubmV3QXR0ZW1wdCA9IGZhbHNlOyAvLyBVbmNoZWNrIG5ldyBhdHRlbXB0LlxuXG4gICAgICAgIHZhciBmb3J3YXJkVmlldyA9ICRpb25pY0hpc3RvcnkuZm9yd2FyZFZpZXcoKTtcbiAgICAgICAgaWYgKGZvcndhcmRWaWV3ICYmIGZvcndhcmRWaWV3LnN0YXRlTmFtZSA9PT0gJ3NpdGUubW9kX3Njb3JtLXBsYXllcicpIHtcbiAgICAgICAgICAgICRzY29wZS5zY29ybUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2Nyb2xsVmlldy5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIC8vIEFkZCBhIGRlbGF5IHRvIG1ha2Ugc3VyZSB0aGUgcGxheWVyIGhhcyBzdGFydGVkIHRoZSBsYXN0IHdyaXRpbmcgY2FsbHMgc28gd2UgY2FuIGRldGVjdCBjb25mbGljdHMuXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZWZyZXNoRGF0YSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zY29ybUxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWZyZXNoIGRhdGEgaWYgdGhpcyBTQ09STSBpcyBzeW5jaHJvbml6ZWQgYXV0b21hdGljYWxseS5cbiAgICB2YXIgc3luY09ic2VydmVyID0gJG1tRXZlbnRzLm9uKG1tYU1vZFNjb3JtRXZlbnRBdXRvbVN5bmNlZCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnNpdGVpZCA9PSAkbW1TaXRlLmdldElkKCkgJiYgZGF0YS5zY29ybWlkID09IHNjb3JtLmlkKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2Nvcm1Mb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICBmZXRjaFNjb3JtRGF0YSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNjb3JtTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGF0dXNPYnNlcnZlciAmJiBzdGF0dXNPYnNlcnZlci5vZmYgJiYgc3RhdHVzT2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgIHN5bmNPYnNlcnZlciAmJiBzeW5jT2JzZXJ2ZXIub2ZmICYmIHN5bmNPYnNlcnZlci5vZmYoKTtcbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3Njb3JtJylcblxuLyoqXG4gKiBTQ09STSBwbGF5ZXIgY29udHJvbGxlci5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RTY29ybVBsYXllckN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZFNjb3JtUGxheWVyQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1hTW9kU2Nvcm0sICRtbVV0aWwsICRpb25pY1BvcG92ZXIsICRtbWFNb2RTY29ybUhlbHBlcixcbiAgICAgICAgICAgICRtbUV2ZW50cywgJHRpbWVvdXQsICRxLCBtbWFNb2RTY29ybUV2ZW50VXBkYXRlVG9jLCBtbWFNb2RTY29ybUV2ZW50TGF1bmNoTmV4dFNjbywgbW1hTW9kU2Nvcm1FdmVudExhdW5jaFByZXZTY28sXG4gICAgICAgICAgICAkbW1hTW9kU2Nvcm1EYXRhTW9kZWwxMiwgbW1hTW9kU2Nvcm1FdmVudEdvT2ZmbGluZSwgJG1tYU1vZFNjb3JtU3luYykge1xuXG4gICAgdmFyIHNjb3JtID0gJHN0YXRlUGFyYW1zLnNjb3JtIHx8IHt9LFxuICAgICAgICBtb2RlID0gJHN0YXRlUGFyYW1zLm1vZGUgfHwgJG1tYU1vZFNjb3JtLk1PREVOT1JNQUwsXG4gICAgICAgIG5ld0F0dGVtcHQgPSAkc3RhdGVQYXJhbXMubmV3QXR0ZW1wdCxcbiAgICAgICAgb3JnYW5pemF0aW9uSWQgPSAkc3RhdGVQYXJhbXMub3JnYW5pemF0aW9uSWQsXG4gICAgICAgIGN1cnJlbnRTY28sXG4gICAgICAgIGF0dGVtcHQsXG4gICAgICAgIHVzZXJEYXRhLFxuICAgICAgICBhcGlJbml0aWFsaXplZCA9IGZhbHNlLFxuICAgICAgICBvZmZsaW5lID0gZmFsc2U7XG5cbiAgICAkc2NvcGUudGl0bGUgPSBzY29ybS5uYW1lOyAvLyBXZSB1c2UgU0NPUk0gbmFtZSBhdCBzdGFydCwgbGF0ZXIgd2UnbGwgdXNlIHRoZSBTQ08gdGl0bGUuXG4gICAgJHNjb3BlLnNjb3JtID0gc2Nvcm07XG4gICAgJHNjb3BlLmxvYWRpbmdUb2MgPSB0cnVlO1xuXG4gICAgaWYgKHNjb3JtLnBvcHVwKSB7XG4gICAgICAgIC8vIElmIHdlIHJlY2VpdmUgYSB2YWx1ZSA8PSAxMDAgd2UgbmVlZCB0byBhc3N1bWUgaXQncyBhIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzY29ybS53aWR0aCA8PSAxMDApIHtcbiAgICAgICAgICAgIHNjb3JtLndpZHRoID0gc2Nvcm0ud2lkdGggKyAnJSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3JtLmhlaWdodCA8PSAxMDApIHtcbiAgICAgICAgICAgIHNjb3JtLmhlaWdodCA9IHNjb3JtLmhlaWdodCArICclJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZldGNoIGRhdGEgbmVlZGVkIHRvIHBsYXkgdGhlIFNDT1JNLlxuICAgIGZ1bmN0aW9uIGZldGNoRGF0YSgpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgYW55IG9uZ29pbmcgc3luYyB0byBmaW5pc2guIFdlIHdvbid0IHN5bmMgYSBTQ09STSB3aGlsZSBpdCdzIGJlaW5nIHBsYXllZC5cbiAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybVN5bmMud2FpdEZvclN5bmMoc2Nvcm0uaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBHZXQgYXR0ZW1wdHMgZGF0YS5cbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0QXR0ZW1wdENvdW50KHNjb3JtLmlkKS50aGVuKGZ1bmN0aW9uKGF0dGVtcHRzRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXRlcm1pbmVBdHRlbXB0QW5kTW9kZShhdHRlbXB0c0RhdGEpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIFRPQyBhbmQgZ2V0IHVzZXIgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZmV0Y2hUb2MoKSk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtLmdldFNjb3JtVXNlckRhdGEoc2Nvcm0uaWQsIGF0dGVtcHQsIG9mZmxpbmUpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5jYXRjaChzaG93RXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGF0dGVtcHQgdG8gdXNlLCB0aGUgbW9kZSAobm9ybWFsL3ByZXZpZXcpIGFuZCBpZiBpdCdzIG9mZmxpbmUgb3Igb25saW5lLlxuICAgIGZ1bmN0aW9uIGRldGVybWluZUF0dGVtcHRBbmRNb2RlKGF0dGVtcHRzRGF0YSkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtSGVscGVyLmRldGVybWluZUF0dGVtcHRUb0NvbnRpbnVlKHNjb3JtLCBhdHRlbXB0c0RhdGEpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgYXR0ZW1wdCA9IGRhdGEubnVtYmVyO1xuICAgICAgICAgICAgb2ZmbGluZSA9IGRhdGEub2ZmbGluZTtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0ICE9IGF0dGVtcHRzRGF0YS5sYXN0QXR0ZW1wdC5udW1iZXIpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYXR0ZW1wdFRvQ29udGludWUgPSBhdHRlbXB0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGF0dGVtcHQgaXMgaW5jb21wbGV0ZS5cbiAgICAgICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRtbWFNb2RTY29ybS5pc0F0dGVtcHRJbmNvbXBsZXRlKHNjb3JtLmlkLCBhdHRlbXB0LCBvZmZsaW5lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlciBkb2Vzbid0IGhhdmUgYXR0ZW1wdHMuIExhc3QgYXR0ZW1wdCBpcyBub3QgaW5jb21wbGV0ZSAoc2luY2UgaGUgZG9lc24ndCBoYXZlIGFueSkuXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGluY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgbW9kZSBhbmQgYXR0ZW1wdCB0byB1c2UuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICRtbWFNb2RTY29ybS5kZXRlcm1pbmVBdHRlbXB0QW5kTW9kZShzY29ybSwgbW9kZSwgYXR0ZW1wdCwgbmV3QXR0ZW1wdCwgaW5jb21wbGV0ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmF0dGVtcHQgPiBhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGNyZWF0aW5nIGEgbmV3IGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXN0IGF0dGVtcHQgd2FzIG9mZmxpbmUsIHNvIHdlJ2xsIGNyZWF0ZSBhIG5ldyBvZmZsaW5lIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gJG1tYU1vZFNjb3JtSGVscGVyLmNyZWF0ZU9mZmxpbmVBdHRlbXB0KHNjb3JtLCByZXN1bHQuYXR0ZW1wdCwgYXR0ZW1wdHNEYXRhLm9ubGluZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCBhdHRlbXB0IHdhcyBvbmxpbmUsIHZlcmlmeSB0aGF0IHdlIGNhbiBjcmVhdGUgYSBuZXcgb25saW5lIGF0dGVtcHQuIFdlIGlnbm9yZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm1Vc2VyRGF0YShzY29ybS5pZCwgcmVzdWx0LmF0dGVtcHQsIGZhbHNlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW5ub3QgY29tbXVuaWNhdGUgd2l0aCB0aGUgc2VydmVyLCBjcmVhdGUgYW4gb2ZmbGluZSBhdHRlbXB0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1IZWxwZXIuY3JlYXRlT2ZmbGluZUF0dGVtcHQoc2Nvcm0sIHJlc3VsdC5hdHRlbXB0LCBhdHRlbXB0c0RhdGEub25saW5lLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IHJlc3VsdC5tb2RlO1xuICAgICAgICAgICAgICAgICAgICBuZXdBdHRlbXB0ID0gcmVzdWx0Lm5ld0F0dGVtcHQ7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQgPSByZXN1bHQuYXR0ZW1wdDtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmlzQnJvd3NlID0gbW9kZSA9PT0gJG1tYU1vZFNjb3JtLk1PREVCUk9XU0U7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5pc1JldmlldyA9IG1vZGUgPT09ICRtbWFNb2RTY29ybS5NT0RFUkVWSUVXO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNob3cgZXJyb3IgYW5kIHJlamVjdC5cbiAgICBmdW5jdGlvbiBzaG93RXJyb3IobWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoJ21tYS5tb2Rfc2Nvcm0uZXJyb3JnZXRzY29ybScsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9XG5cbiAgICAvLyBGZXRjaCBUT0MuXG4gICAgZnVuY3Rpb24gZmV0Y2hUb2MoKSB7XG4gICAgICAgICRzY29wZS5sb2FkaW5nVG9jID0gdHJ1ZTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpbmNvbXBsZXRlIGFnYWluOiBhdHRlbXB0IG51bWJlciBtaWdodCBoYXZlIGNoYW5nZWQgaW4gZGV0ZXJtaW5lQXR0ZW1wdEFuZE1vZGUsXG4gICAgICAgIC8vIG9yIGF0dGVtcHQgc3RhdHVzIG1pZ2h0IGhhdmUgY2hhbmdlZCBkdWUgdG8gYW4gYWN0aW9uIGluIHRoZSBjdXJyZW50IFNDTy5cbiAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5pc0F0dGVtcHRJbmNvbXBsZXRlKHNjb3JtLmlkLCBhdHRlbXB0LCBvZmZsaW5lKS50aGVuKGZ1bmN0aW9uKGluY29tcGxldGUpIHtcbiAgICAgICAgICAgIHNjb3JtLmluY29tcGxldGUgPSBpbmNvbXBsZXRlO1xuXG4gICAgICAgICAgICAvLyBHZXQgVE9DLlxuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRPcmdhbml6YXRpb25Ub2Moc2Nvcm0uaWQsIG9yZ2FuaXphdGlvbklkLCBhdHRlbXB0LCBvZmZsaW5lKS50aGVuKGZ1bmN0aW9uKHRvYykge1xuICAgICAgICAgICAgICAgICRzY29wZS50b2MgPSAkbW1hTW9kU2Nvcm0uZm9ybWF0VG9jVG9BcnJheSh0b2MpO1xuICAgICAgICAgICAgICAgIC8vIEdldCBpbWFnZXMgZm9yIGVhY2ggU0NPLlxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUudG9jLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmltYWdlID0gJG1tYU1vZFNjb3JtLmdldFNjb1N0YXR1c0ljb24oc2NvLCBzY29ybS5pbmNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgY3VycmVudCBTQ08gaWYgcGFyYW0gaXMgc2V0LlxuICAgICAgICAgICAgICAgIGlmICgkc3RhdGVQYXJhbXMuc2NvSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNDTyBzZXQgYnkgcGFyYW1ldGVyLCBnZXQgaXQgZnJvbSBUT0MuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY28gPSAkbW1hTW9kU2Nvcm1IZWxwZXIuZ2V0U2NvRnJvbVRvYygkc2NvcGUudG9jLCAkc3RhdGVQYXJhbXMuc2NvSWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFNjbykge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBTQ08gZGVmaW5lZC4gR2V0IHRoZSBmaXJzdCB2YWxpZCBvbmUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1IZWxwZXIuZ2V0Rmlyc3RTY28oc2Nvcm0uaWQsICRzY29wZS50b2MsIG9yZ2FuaXphdGlvbklkLCBhdHRlbXB0LCBvZmZsaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHNjbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY28gPSBzY287XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkbid0IGZpbmQgYSBTQ08gdG8gbG9hZDogdGhleSdyZSBhbGwgaW5hY3RpdmUgb3Igd2l0aG91dCBsYXVuY2ggVVJMLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lcnJvck1lc3NhZ2UgPSAnbW1hLm1vZF9zY29ybS5lcnJvcm5vdmFsaWRzY28nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS5sb2FkaW5nVG9jID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV4dCBhbmQgcHJldmlvdXMgU0NPLlxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU5leHRBbmRQcmV2aW91c1NjbyhzY29JZCkge1xuICAgICAgICAkc2NvcGUucHJldmlvdXNTY28gPSAkbW1hTW9kU2Nvcm1IZWxwZXIuZ2V0UHJldmlvdXNTY29Gcm9tVG9jKCRzY29wZS50b2MsIHNjb0lkKTtcbiAgICAgICAgJHNjb3BlLm5leHRTY28gPSAkbW1hTW9kU2Nvcm1IZWxwZXIuZ2V0TmV4dFNjb0Zyb21Ub2MoJHNjb3BlLnRvYywgc2NvSWQpO1xuICAgIH1cblxuICAgIC8vIExvYWQgYSBTQ08uXG4gICAgZnVuY3Rpb24gbG9hZFNjbyhzY28pIHtcbiAgICAgICAgLy8gU2V0dXAgQVBJLlxuICAgICAgICBpZiAoIWFwaUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAkbW1hTW9kU2Nvcm1EYXRhTW9kZWwxMi5pbml0QVBJKHNjb3JtLCBzY28uaWQsIGF0dGVtcHQsIHVzZXJEYXRhLCBtb2RlLCBvZmZsaW5lKTtcbiAgICAgICAgICAgIGFwaUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRtbWFNb2RTY29ybURhdGFNb2RlbDEyLmxvYWRTY28oc2NvLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRTY28gPSBzY287XG4gICAgICAgICRzY29wZS50aXRsZSA9IHNjby50aXRsZSB8fCBzY29ybS5uYW1lOyAvLyBUcnkgdG8gdXNlIFNDTyB0aXRsZS5cbiAgICAgICAgY2FsY3VsYXRlTmV4dEFuZFByZXZpb3VzU2NvKHNjby5pZCk7XG4gICAgICAgICRtbWFNb2RTY29ybS5nZXRTY29TcmMoc2Nvcm0sIHNjbykudGhlbihmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgICAgIGlmICgkc2NvcGUuc3JjICYmIHNyYy50b1N0cmluZygpID09ICRzY29wZS5zcmMudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlLWxvYWRpbmcgc2FtZSBwYWdlLiBTZXQgaXQgdG8gZW1wdHkgYW5kIHRoZW4gcmUtc2V0IHRoZSBzcmMgaW4gdGhlIG5leHQgZGlnZXN0IHNvIGl0IGRldGVjdHMgaXQgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgJHNjb3BlLnNyYyA9ICcnO1xuICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3JjID0gc3JjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2NvLnNjb3JtdHlwZSA9PSAnYXNzZXQnKSB7XG4gICAgICAgICAgICAvLyBNYXJrIHRoZSBhc3NldCBhcyBjb21wbGV0ZWQuXG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gW3tcbiAgICAgICAgICAgICAgICBlbGVtZW50OiAnY21pLmNvcmUubGVzc29uX3N0YXR1cycsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICdjb21wbGV0ZWQnXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICRtbWFNb2RTY29ybS5zYXZlVHJhY2tzKHNjby5pZCwgYXR0ZW1wdCwgdHJhY2tzLCBvZmZsaW5lLCBzY29ybSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gRXJyb3Igc2F2aW5nIGRhdGEuIFdlJ2xsIGdvIG9mZmxpbmUgaWYgd2UncmUgb25saW5lIGFuZCB0aGUgYXNzZXQgaXMgbm90IG1hcmtlZCBhcyBjb21wbGV0ZWQgYWxyZWFkeS5cbiAgICAgICAgICAgICAgICBpZiAoIW9mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRTY29ybVVzZXJEYXRhKHNjb3JtLmlkLCBhdHRlbXB0LCBvZmZsaW5lKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YVtzY28uaWRdIHx8wqBkYXRhW3Njby5pZF0udXNlcmRhdGFbJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnXSAhPSAnY29tcGxldGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvIG9mZmxpbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybUhlbHBlci5jb252ZXJ0QXR0ZW1wdFRvT2ZmbGluZShzY29ybSwgYXR0ZW1wdCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RTY29ybURhdGFNb2RlbDEyLnNldE9mZmxpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uc2F2ZVRyYWNrcyhzY28uaWQsIGF0dGVtcHQsIHRyYWNrcywgb2ZmbGluZSwgc2Nvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHNob3dFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVmcmVzaCBUT0MsIHNvbWUgcHJlcmVxdWlzaXRlcyBtaWdodCBoYXZlIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgcmVmcmVzaFRvYygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmlnZ2VyIFNDTyBsYXVuY2ggZXZlbnQuXG4gICAgICAgICRtbWFNb2RTY29ybS5sb2dMYXVuY2hTY28oc2Nvcm0uaWQsIHNjby5pZCk7XG4gICAgfVxuXG4gICAgLy8gUmVmcmVzaCB0aGUgVE9DLlxuICAgIGZ1bmN0aW9uIHJlZnJlc2hUb2MoKSB7XG4gICAgICAgICRtbWFNb2RTY29ybS5pbnZhbGlkYXRlQWxsU2Nvcm1EYXRhKHNjb3JtLmlkKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZmV0Y2hUb2MoKS5jYXRjaChzaG93RXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgU0NPUk0gc3RhcnQgdGltZS5cbiAgICBmdW5jdGlvbiBzZXRTdGFydFRpbWUoc2NvSWQpIHtcbiAgICAgICAgdmFyIHRyYWNrcyA9IFt7XG4gICAgICAgICAgICBlbGVtZW50OiAneC5zdGFydC50aW1lJyxcbiAgICAgICAgICAgIHZhbHVlOiAkbW1VdGlsLnRpbWVzdGFtcCgpXG4gICAgICAgIH1dO1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLnNhdmVUcmFja3Moc2NvSWQsIGF0dGVtcHQsIHRyYWNrcywgb2ZmbGluZSwgc2Nvcm0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIW9mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXcgb25saW5lIGF0dGVtcHQgY3JlYXRlZCwgdXBkYXRlIGNhY2hlZCBkYXRhIGFib3V0IG9ubGluZSBhdHRlbXB0cy5cbiAgICAgICAgICAgICAgICAkbW1hTW9kU2Nvcm0uZ2V0QXR0ZW1wdENvdW50KHNjb3JtLmlkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkc2NvcGUuc2hvd1RvYyA9ICRtbWFNb2RTY29ybS5kaXNwbGF5VG9jSW5QbGF5ZXIoc2Nvcm0pO1xuICAgIGlmICgkc2NvcGUuc2hvd1RvYykge1xuICAgICAgICAvLyBTZXR1cCBUT0MgcG9wb3Zlci5cbiAgICAgICAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ2FkZG9ucy9tb2Rfc2Nvcm0vdGVtcGxhdGVzL3RvYy5odG1sJywge1xuICAgICAgICAgICAgc2NvcGU6ICRzY29wZSxcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgICAgICAgICAkc2NvcGUucG9wb3ZlciA9IHBvcG92ZXI7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZldGNoIHRoZSBTQ09STSBkYXRhLlxuICAgIGZldGNoRGF0YSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjdXJyZW50U2NvKSB7XG4gICAgICAgICAgICAvLyBTZXQgc3RhcnQgdGltZSBpZiBpdCdzIGEgbmV3IGF0dGVtcHQuXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ld0F0dGVtcHQgPyBzZXRTdGFydFRpbWUoY3VycmVudFNjby5pZCkgOiAkcS53aGVuKCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5jYXRjaChzaG93RXJyb3IpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZCBTQ08uXG4gICAgICAgICAgICAgICAgbG9hZFNjbyhjdXJyZW50U2NvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmxvYWRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUubG9hZFNjbyA9IGZ1bmN0aW9uKHNjbykge1xuICAgICAgICBpZiAoIXNjby5wcmVyZXEgfHwgIXNjby5pc3Zpc2libGUgfHwgIXNjby5sYXVuY2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgICRzY29wZS5wb3BvdmVyLmhpZGUoKTtcbiAgICAgICAgbG9hZFNjbyhzY28pO1xuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGV2ZW50cyB0byB1cGRhdGUgdGhlIFRPQyBhbmQgbmF2aWdhdGUgdGhyb3VnaCBTQ09zLlxuICAgIHZhciB0b2NPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbWFNb2RTY29ybUV2ZW50VXBkYXRlVG9jLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnNjb3JtaWQgPT09IHNjb3JtLmlkKSB7XG4gICAgICAgICAgICBpZiAob2ZmbGluZSkge1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgdG8gbWFrZSBzdXJlIGRhdGEgaXMgc3RvcmVkLlxuICAgICAgICAgICAgICAgICR0aW1lb3V0KHJlZnJlc2hUb2MsIDEwMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZnJlc2hUb2MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGxhdW5jaE5leHRPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbWFNb2RTY29ybUV2ZW50TGF1bmNoTmV4dFNjbywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5zY29ybWlkID09PSBzY29ybS5pZCAmJiAkc2NvcGUubmV4dFNjbykge1xuICAgICAgICAgICAgbG9hZFNjbygkc2NvcGUubmV4dFNjbyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBsYXVuY2hQcmV2T2JzZXJ2ZXIgPSAkbW1FdmVudHMub24obW1hTW9kU2Nvcm1FdmVudExhdW5jaFByZXZTY28sIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuc2Nvcm1pZCA9PT0gc2Nvcm0uaWQgJiYgJHNjb3BlLnByZXZpb3VzU2NvKSB7XG4gICAgICAgICAgICBsb2FkU2NvKCRzY29wZS5wcmV2aW91c1Njbyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBnb09mZmxpbmVPYnNlcnZlciA9ICRtbUV2ZW50cy5vbihtbWFNb2RTY29ybUV2ZW50R29PZmZsaW5lLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnNjb3JtaWQgPT09IHNjb3JtLmlkICYmICFvZmZsaW5lKSB7XG4gICAgICAgICAgICBvZmZsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgdG8gcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gdGhpcyBzdG9yZSBhbmQgU0NPUk0gQVBJJ3Mgc3RvcmUuXG4gICAgICAgICAgICAgICAgJG1tYU1vZFNjb3JtSGVscGVyLmNvbnZlcnRBdHRlbXB0VG9PZmZsaW5lKHNjb3JtLCBhdHRlbXB0KS5jYXRjaChzaG93RXJyb3IpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hUb2MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEVtcHR5IHNyYyB3aGVuIGxlYXZpbmcgdGhlIHN0YXRlIHNvIHVubG9hZCBldmVudCBpcyB0cmlnZ2VyZWQgaW4gdGhlIGlmcmFtZS5cbiAgICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmJlZm9yZUxlYXZlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5zcmMgPSAnJztcbiAgICB9KTtcblxuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRvY09ic2VydmVyICYmIHRvY09ic2VydmVyLm9mZiAmJiB0b2NPYnNlcnZlci5vZmYoKTtcbiAgICAgICAgbGF1bmNoTmV4dE9ic2VydmVyICYmIGxhdW5jaE5leHRPYnNlcnZlci5vZmYgJiYgbGF1bmNoTmV4dE9ic2VydmVyLm9mZigpO1xuICAgICAgICBsYXVuY2hQcmV2T2JzZXJ2ZXIgJiYgbGF1bmNoUHJldk9ic2VydmVyLm9mZiAmJiBsYXVuY2hQcmV2T2JzZXJ2ZXIub2ZmKCk7XG4gICAgICAgIGdvT2ZmbGluZU9ic2VydmVyICYmIGdvT2ZmbGluZU9ic2VydmVyLm9mZiAmJiBnb09mZmxpbmVPYnNlcnZlci5vZmYoKTtcbiAgICB9KTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3Njb3JtJylcblxuLyoqXG4gKiBTQ09STSBkYXRhIG1vZGVsIGltcGxlbWVudGF0aW9uIGZvciB2ZXJzaW9uIDEuMi5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kU2Nvcm1EYXRhTW9kZWwxMlxuICovXG4uZmFjdG9yeSgnJG1tYU1vZFNjb3JtRGF0YU1vZGVsMTInLCBmdW5jdGlvbigkbW1hTW9kU2Nvcm0sICRtbUV2ZW50cywgJHdpbmRvdywgbW1hTW9kU2Nvcm1FdmVudExhdW5jaE5leHRTY28sXG4gICAgICAgICAgICBtbWFNb2RTY29ybUV2ZW50TGF1bmNoUHJldlNjbywgbW1hTW9kU2Nvcm1FdmVudFVwZGF0ZVRvYywgbW1hTW9kU2Nvcm1FdmVudEdvT2ZmbGluZSkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBnbG9iYWwgU0NPUk0gQVBJIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29ybSAgICBUaGUgU0NPUk0gb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgICAgVGhlIFNDTyBpZC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgIFRoZSBhdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHVzZXJEYXRhIFRoZSB1c2VyIGRlZmF1bHQgZGF0YS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1vZGUgICAgIE1vZGUuIE9uZSBvZiAkbW1hTW9kU2Nvcm0jTU9ERSBjb25zdGFudHMuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gb2ZmbGluZSBUcnVlIGlmIGF0dGVtcHQgaXMgb2ZmbGluZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNDT1JNQVBJKHNjb3JtLCBzY29JZCwgYXR0ZW1wdCwgdXNlckRhdGEsIG1vZGUsIG9mZmxpbmUpIHtcblxuICAgICAgICAvLyBDb250YWlucyBhbGwgdGhlIGN1cnJlbnQgdmFsdWVzIGZvciBhbGwgdGhlIGRhdGEgbW9kZWwgZWxlbWVudHMgZm9yIGVhY2ggU0NPLlxuICAgICAgICB2YXIgY3VycmVudFVzZXJEYXRhID0ge30sXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBDdXJyZW50IFNDTyBJZC5cbiAgICAgICAgc2VsZi5zY29JZCA9IHNjb0lkO1xuICAgICAgICBzZWxmLm9mZmxpbmUgPSBvZmZsaW5lO1xuXG4gICAgICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHRyaWdnZXIgZXZlbnRzLlxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQobmFtZSkge1xuICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobmFtZSwge1xuICAgICAgICAgICAgICAgIHNjb3JtaWQ6IHNjb3JtLmlkLFxuICAgICAgICAgICAgICAgIHNjb2lkOiBzZWxmLnNjb0lkLFxuICAgICAgICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhbmRhcmQgRGF0YSBUeXBlIERlZmluaXRpb24uXG4gICAgICAgIHZhciBDTUlTdHJpbmcyNTYgPSAnXltcXFxcdTAwMDAtXFxcXHVGRkZGXXswLDI1NX0kJztcbiAgICAgICAgdmFyIENNSVN0cmluZzQwOTYgPSAnXltcXFxcdTAwMDAtXFxcXHVGRkZGXXswLDQwOTZ9JCc7XG4gICAgICAgIHZhciBDTUlUaW1lID0gJ14oWzAtMl17MX1bMC05XXsxfSk6KFswLTVdezF9WzAtOV17MX0pOihbMC01XXsxfVswLTldezF9KShcXC5bMC05XXsxLDJ9KT8kJztcbiAgICAgICAgdmFyIENNSVRpbWVzcGFuID0gJ14oWzAtOV17Miw0fSk6KFswLTldezJ9KTooWzAtOV17Mn0pKFxcLlswLTldezEsMn0pPyQnO1xuICAgICAgICB2YXIgQ01JSW50ZWdlciA9ICdeXFxcXGQrJCc7XG4gICAgICAgIHZhciBDTUlTSW50ZWdlciA9ICdeLT8oWzAtOV0rKSQnO1xuICAgICAgICB2YXIgQ01JRGVjaW1hbCA9ICdeLT8oWzAtOV17MCwzfSkoXFwuWzAtOV0qKT8kJztcbiAgICAgICAgdmFyIENNSUlkZW50aWZpZXIgPSAnXltcXFxcdTAwMjEtXFxcXHUwMDdFXXswLDI1NX0kJztcbiAgICAgICAgdmFyIENNSUZlZWRiYWNrID0gQ01JU3RyaW5nMjU2OyAvLyBUaGlzIG11c3QgYmUgcmVkZWZpbmVkLlxuICAgICAgICB2YXIgQ01JSW5kZXggPSAnWy5fXShcXFxcZCspLic7XG5cbiAgICAgICAgLy8gVm9jYWJ1bGFyeSBEYXRhIFR5cGUgRGVmaW5pdGlvbi5cbiAgICAgICAgdmFyIENNSVN0YXR1cyA9ICdecGFzc2VkJHxeY29tcGxldGVkJHxeZmFpbGVkJHxeaW5jb21wbGV0ZSR8XmJyb3dzZWQkJztcbiAgICAgICAgdmFyIENNSVN0YXR1czIgPSAnXnBhc3NlZCR8XmNvbXBsZXRlZCR8XmZhaWxlZCR8XmluY29tcGxldGUkfF5icm93c2VkJHxebm90IGF0dGVtcHRlZCQnO1xuICAgICAgICB2YXIgQ01JRXhpdCA9ICdedGltZS1vdXQkfF5zdXNwZW5kJHxebG9nb3V0JHxeJCc7XG4gICAgICAgIHZhciBDTUlUeXBlID0gJ150cnVlLWZhbHNlJHxeY2hvaWNlJHxeZmlsbC1pbiR8Xm1hdGNoaW5nJHxecGVyZm9ybWFuY2UkfF5zZXF1ZW5jaW5nJHxebGlrZXJ0JHxebnVtZXJpYyQnO1xuICAgICAgICB2YXIgQ01JUmVzdWx0ID0gJ15jb3JyZWN0JHxed3JvbmckfF51bmFudGljaXBhdGVkJHxebmV1dHJhbCR8XihbMC05XXswLDN9KT8oXFwuWzAtOV0qKT8kJztcbiAgICAgICAgdmFyIE5BVkV2ZW50ID0gJ15wcmV2aW91cyR8XmNvbnRpbnVlJCc7XG5cbiAgICAgICAgLy8gQ2hpbGRyZW4gbGlzdHMuXG4gICAgICAgIHZhciBjbWlfY2hpbGRyZW4gPSAnY29yZSxzdXNwZW5kX2RhdGEsbGF1bmNoX2RhdGEsY29tbWVudHMsb2JqZWN0aXZlcyxzdHVkZW50X2RhdGEsc3R1ZGVudF9wcmVmZXJlbmNlLGludGVyYWN0aW9ucyc7XG4gICAgICAgIHZhciBjb3JlX2NoaWxkcmVuID0gJ3N0dWRlbnRfaWQsc3R1ZGVudF9uYW1lLGxlc3Nvbl9sb2NhdGlvbixjcmVkaXQsbGVzc29uX3N0YXR1cyxlbnRyeSxzY29yZSx0b3RhbF90aW1lLGxlc3Nvbl9tb2RlLGV4aXQsc2Vzc2lvbl90aW1lJztcbiAgICAgICAgdmFyIHNjb3JlX2NoaWxkcmVuID0gJ3JhdyxtaW4sbWF4JztcbiAgICAgICAgdmFyIGNvbW1lbnRzX2NoaWxkcmVuID0gJ2NvbnRlbnQsbG9jYXRpb24sdGltZSc7XG4gICAgICAgIHZhciBvYmplY3RpdmVzX2NoaWxkcmVuID0gJ2lkLHNjb3JlLHN0YXR1cyc7XG4gICAgICAgIHZhciBjb3JyZWN0X3Jlc3BvbnNlc19jaGlsZHJlbiA9ICdwYXR0ZXJuJztcbiAgICAgICAgdmFyIHN0dWRlbnRfZGF0YV9jaGlsZHJlbiA9ICdtYXN0ZXJ5X3Njb3JlLG1heF90aW1lX2FsbG93ZWQsdGltZV9saW1pdF9hY3Rpb24nO1xuICAgICAgICB2YXIgc3R1ZGVudF9wcmVmZXJlbmNlX2NoaWxkcmVuID0gJ2F1ZGlvLGxhbmd1YWdlLHNwZWVkLHRleHQnO1xuICAgICAgICB2YXIgaW50ZXJhY3Rpb25zX2NoaWxkcmVuID0gJ2lkLG9iamVjdGl2ZXMsdGltZSx0eXBlLGNvcnJlY3RfcmVzcG9uc2VzLHdlaWdodGluZyxzdHVkZW50X3Jlc3BvbnNlLHJlc3VsdCxsYXRlbmN5JztcblxuICAgICAgICAvLyBEYXRhIHJhbmdlcy5cbiAgICAgICAgdmFyIHNjb3JlX3JhbmdlID0gJzAjMTAwJztcbiAgICAgICAgdmFyIGF1ZGlvX3JhbmdlID0gJy0xIzEwMCc7XG4gICAgICAgIHZhciBzcGVlZF9yYW5nZSA9ICctMTAwIzEwMCc7XG4gICAgICAgIHZhciB3ZWlnaHRpbmdfcmFuZ2UgPSAnLTEwMCMxMDAnO1xuICAgICAgICB2YXIgdGV4dF9yYW5nZSA9ICctMSMxJztcblxuICAgICAgICAvLyBQcmVwYXJlIHRoZSBkZWZpbml0aW9uIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICB2YXIgZGVmID0ge307XG4gICAgICAgIC8vIFdlIG5lZWQgYW4gZXh0cmEgb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIHRoZSBvYmplY3RpdmVzIGFuZCBpbnRlcmFjdGlvbnMgZGF0YSAoYWxsIHRoZSAubi4gZWxlbWVudHMpLlxuICAgICAgICB2YXIgZGVmRXh0cmEgPSB7fTtcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2godXNlckRhdGEsIGZ1bmN0aW9uKHNjbykge1xuICAgICAgICAgICAgZGVmW3Njby5zY29pZF0gPSBzY28uZGVmYXVsdGRhdGE7XG4gICAgICAgICAgICBkZWZFeHRyYVtzY28uc2NvaWRdID0gc2NvLnVzZXJkYXRhO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGUgU0NPUk0gMS4yIGRhdGEgbW9kZWwuXG4gICAgICAgIC8vIFNldCB1cCBkYXRhIG1vZGVsIGZvciBlYWNoIHNjby5cbiAgICAgICAgdmFyIGRhdGFtb2RlbCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBzY29pZCBpbiBkZWYpIHtcbiAgICAgICAgICAgIGRhdGFtb2RlbFtzY29pZF0gPSB7XG4gICAgICAgICAgICAgICAgJ2NtaS5fY2hpbGRyZW4nOnsnZGVmYXVsdHZhbHVlJzpjbWlfY2hpbGRyZW4sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLl92ZXJzaW9uJzp7J2RlZmF1bHR2YWx1ZSc6JzMuNCcsICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUuX2NoaWxkcmVuJzp7J2RlZmF1bHR2YWx1ZSc6Y29yZV9jaGlsZHJlbiwgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMid9LFxuICAgICAgICAgICAgICAgICdjbWkuY29yZS5zdHVkZW50X2lkJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLmNvcmUuc3R1ZGVudF9pZCddLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAzJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLnN0dWRlbnRfbmFtZSc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb3JlLnN0dWRlbnRfbmFtZSddLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAzJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLmxlc3Nvbl9sb2NhdGlvbic6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb3JlLmxlc3Nvbl9sb2NhdGlvbiddLCAnZm9ybWF0JzpDTUlTdHJpbmcyNTYsICdtb2QnOidydycsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLmNyZWRpdCc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb3JlLmNyZWRpdCddLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAzJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuY29yZS5sZXNzb25fc3RhdHVzJ10sICdmb3JtYXQnOkNNSVN0YXR1cywgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUuZW50cnknOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuY29yZS5lbnRyeSddLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAzJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLnNjb3JlLl9jaGlsZHJlbic6eydkZWZhdWx0dmFsdWUnOnNjb3JlX2NoaWxkcmVuLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAyJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLnNjb3JlLnJhdyc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5jb3JlLnNjb3JlLnJhdyddLCAnZm9ybWF0JzpDTUlEZWNpbWFsLCAncmFuZ2UnOnNjb3JlX3JhbmdlLCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuY29yZS5zY29yZS5tYXgnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuY29yZS5zY29yZS5tYXgnXSwgJ2Zvcm1hdCc6Q01JRGVjaW1hbCwgJ3JhbmdlJzpzY29yZV9yYW5nZSwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUuc2NvcmUubWluJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLmNvcmUuc2NvcmUubWluJ10sICdmb3JtYXQnOkNNSURlY2ltYWwsICdyYW5nZSc6c2NvcmVfcmFuZ2UsICdtb2QnOidydycsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLnRvdGFsX3RpbWUnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuY29yZS50b3RhbF90aW1lJ10sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDMnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvcmUubGVzc29uX21vZGUnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuY29yZS5sZXNzb25fbW9kZSddLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAzJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLmV4aXQnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuY29yZS5leGl0J10sICdmb3JtYXQnOkNNSUV4aXQsICdtb2QnOid3JywgJ3JlYWRlcnJvcic6JzQwNCcsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5jb3JlLnNlc3Npb25fdGltZSc6eydmb3JtYXQnOkNNSVRpbWVzcGFuLCAnbW9kJzondycsICdkZWZhdWx0dmFsdWUnOicwMDowMDowMCcsICdyZWFkZXJyb3InOic0MDQnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuc3VzcGVuZF9kYXRhJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLnN1c3BlbmRfZGF0YSddLCAnZm9ybWF0JzpDTUlTdHJpbmc0MDk2LCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkubGF1bmNoX2RhdGEnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkubGF1bmNoX2RhdGEnXSwgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMyd9LFxuICAgICAgICAgICAgICAgICdjbWkuY29tbWVudHMnOnsnZGVmYXVsdHZhbHVlJzpkZWZbc2NvaWRdWydjbWkuY29tbWVudHMnXSwgJ2Zvcm1hdCc6Q01JU3RyaW5nNDA5NiwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAvLyBEZXByZWNhdGVkIGV2YWx1YXRpb24gYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAgICAnY21pLmV2YWx1YXRpb24uY29tbWVudHMuX2NvdW50Jzp7J2RlZmF1bHR2YWx1ZSc6JzAnLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAyJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5ldmFsdWF0aW9uLmNvbW1lbnRzLl9jaGlsZHJlbic6eydkZWZhdWx0dmFsdWUnOmNvbW1lbnRzX2NoaWxkcmVuLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAyJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5ldmFsdWF0aW9uLmNvbW1lbnRzLm4uY29udGVudCc6eydkZWZhdWx0dmFsdWUnOicnLCAncGF0dGVybic6Q01JSW5kZXgsICdmb3JtYXQnOkNNSVN0cmluZzI1NiwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmV2YWx1YXRpb24uY29tbWVudHMubi5sb2NhdGlvbic6eydkZWZhdWx0dmFsdWUnOicnLCAncGF0dGVybic6Q01JSW5kZXgsICdmb3JtYXQnOkNNSVN0cmluZzI1NiwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmV2YWx1YXRpb24uY29tbWVudHMubi50aW1lJzp7J2RlZmF1bHR2YWx1ZSc6JycsICdwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JVGltZSwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmNvbW1lbnRzX2Zyb21fbG1zJzp7J21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMyd9LFxuICAgICAgICAgICAgICAgICdjbWkub2JqZWN0aXZlcy5fY2hpbGRyZW4nOnsnZGVmYXVsdHZhbHVlJzpvYmplY3RpdmVzX2NoaWxkcmVuLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAyJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5vYmplY3RpdmVzLl9jb3VudCc6eydtb2QnOidyJywgJ2RlZmF1bHR2YWx1ZSc6JzAnLCAnd3JpdGVlcnJvcic6JzQwMid9LFxuICAgICAgICAgICAgICAgICdjbWkub2JqZWN0aXZlcy5uLmlkJzp7J3BhdHRlcm4nOkNNSUluZGV4LCAnZm9ybWF0JzpDTUlJZGVudGlmaWVyLCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkub2JqZWN0aXZlcy5uLnNjb3JlLl9jaGlsZHJlbic6eydwYXR0ZXJuJzpDTUlJbmRleCwgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMid9LFxuICAgICAgICAgICAgICAgICdjbWkub2JqZWN0aXZlcy5uLnNjb3JlLnJhdyc6eydkZWZhdWx0dmFsdWUnOicnLCAncGF0dGVybic6Q01JSW5kZXgsICdmb3JtYXQnOkNNSURlY2ltYWwsICdyYW5nZSc6c2NvcmVfcmFuZ2UsICdtb2QnOidydycsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5vYmplY3RpdmVzLm4uc2NvcmUubWluJzp7J2RlZmF1bHR2YWx1ZSc6JycsICdwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JRGVjaW1hbCwgJ3JhbmdlJzpzY29yZV9yYW5nZSwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLm9iamVjdGl2ZXMubi5zY29yZS5tYXgnOnsnZGVmYXVsdHZhbHVlJzonJywgJ3BhdHRlcm4nOkNNSUluZGV4LCAnZm9ybWF0JzpDTUlEZWNpbWFsLCAncmFuZ2UnOnNjb3JlX3JhbmdlLCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkub2JqZWN0aXZlcy5uLnN0YXR1cyc6eydwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JU3RhdHVzMiwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLnN0dWRlbnRfZGF0YS5fY2hpbGRyZW4nOnsnZGVmYXVsdHZhbHVlJzpzdHVkZW50X2RhdGFfY2hpbGRyZW4sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLnN0dWRlbnRfZGF0YS5tYXN0ZXJ5X3Njb3JlJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLnN0dWRlbnRfZGF0YS5tYXN0ZXJ5X3Njb3JlJ10sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDMnfSxcbiAgICAgICAgICAgICAgICAnY21pLnN0dWRlbnRfZGF0YS5tYXhfdGltZV9hbGxvd2VkJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLnN0dWRlbnRfZGF0YS5tYXhfdGltZV9hbGxvd2VkJ10sICdtb2QnOidyJywgJ3dyaXRlZXJyb3InOic0MDMnfSxcbiAgICAgICAgICAgICAgICAnY21pLnN0dWRlbnRfZGF0YS50aW1lX2xpbWl0X2FjdGlvbic6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5zdHVkZW50X2RhdGEudGltZV9saW1pdF9hY3Rpb24nXSwgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMyd9LFxuICAgICAgICAgICAgICAgICdjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLl9jaGlsZHJlbic6eydkZWZhdWx0dmFsdWUnOnN0dWRlbnRfcHJlZmVyZW5jZV9jaGlsZHJlbiwgJ21vZCc6J3InLCAnd3JpdGVlcnJvcic6JzQwMid9LFxuICAgICAgICAgICAgICAgICdjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLmF1ZGlvJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS5hdWRpbyddLCAnZm9ybWF0JzpDTUlTSW50ZWdlciwgJ3JhbmdlJzphdWRpb19yYW5nZSwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS5sYW5ndWFnZSc6eydkZWZhdWx0dmFsdWUnOmRlZltzY29pZF1bJ2NtaS5zdHVkZW50X3ByZWZlcmVuY2UubGFuZ3VhZ2UnXSwgJ2Zvcm1hdCc6Q01JU3RyaW5nMjU2LCAnbW9kJzoncncnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLnNwZWVkJzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS5zcGVlZCddLCAnZm9ybWF0JzpDTUlTSW50ZWdlciwgJ3JhbmdlJzpzcGVlZF9yYW5nZSwgJ21vZCc6J3J3JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS50ZXh0Jzp7J2RlZmF1bHR2YWx1ZSc6ZGVmW3Njb2lkXVsnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS50ZXh0J10sICdmb3JtYXQnOkNNSVNJbnRlZ2VyLCAncmFuZ2UnOnRleHRfcmFuZ2UsICdtb2QnOidydycsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5pbnRlcmFjdGlvbnMuX2NoaWxkcmVuJzp7J2RlZmF1bHR2YWx1ZSc6aW50ZXJhY3Rpb25zX2NoaWxkcmVuLCAnbW9kJzoncicsICd3cml0ZWVycm9yJzonNDAyJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5pbnRlcmFjdGlvbnMuX2NvdW50Jzp7J21vZCc6J3InLCAnZGVmYXVsdHZhbHVlJzonMCcsICd3cml0ZWVycm9yJzonNDAyJ30sXG4gICAgICAgICAgICAgICAgJ2NtaS5pbnRlcmFjdGlvbnMubi5pZCc6eydwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JSWRlbnRpZmllciwgJ21vZCc6J3cnLCAncmVhZGVycm9yJzonNDA0JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5uLm9iamVjdGl2ZXMuX2NvdW50Jzp7J3BhdHRlcm4nOkNNSUluZGV4LCAnbW9kJzoncicsICdkZWZhdWx0dmFsdWUnOicwJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5uLm9iamVjdGl2ZXMubi5pZCc6eydwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JSWRlbnRpZmllciwgJ21vZCc6J3cnLCAncmVhZGVycm9yJzonNDA0JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5uLnRpbWUnOnsncGF0dGVybic6Q01JSW5kZXgsICdmb3JtYXQnOkNNSVRpbWUsICdtb2QnOid3JywgJ3JlYWRlcnJvcic6JzQwNCcsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5pbnRlcmFjdGlvbnMubi50eXBlJzp7J3BhdHRlcm4nOkNNSUluZGV4LCAnZm9ybWF0JzpDTUlUeXBlLCAnbW9kJzondycsICdyZWFkZXJyb3InOic0MDQnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuaW50ZXJhY3Rpb25zLm4uY29ycmVjdF9yZXNwb25zZXMuX2NvdW50Jzp7J3BhdHRlcm4nOkNNSUluZGV4LCAnbW9kJzoncicsICdkZWZhdWx0dmFsdWUnOicwJywgJ3dyaXRlZXJyb3InOic0MDInfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5uLmNvcnJlY3RfcmVzcG9uc2VzLm4ucGF0dGVybic6eydwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JRmVlZGJhY2ssICdtb2QnOid3JywgJ3JlYWRlcnJvcic6JzQwNCcsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5pbnRlcmFjdGlvbnMubi53ZWlnaHRpbmcnOnsncGF0dGVybic6Q01JSW5kZXgsICdmb3JtYXQnOkNNSURlY2ltYWwsICdyYW5nZSc6d2VpZ2h0aW5nX3JhbmdlLCAnbW9kJzondycsICdyZWFkZXJyb3InOic0MDQnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICdjbWkuaW50ZXJhY3Rpb25zLm4uc3R1ZGVudF9yZXNwb25zZSc6eydwYXR0ZXJuJzpDTUlJbmRleCwgJ2Zvcm1hdCc6Q01JRmVlZGJhY2ssICdtb2QnOid3JywgJ3JlYWRlcnJvcic6JzQwNCcsICd3cml0ZWVycm9yJzonNDA1J30sXG4gICAgICAgICAgICAgICAgJ2NtaS5pbnRlcmFjdGlvbnMubi5yZXN1bHQnOnsncGF0dGVybic6Q01JSW5kZXgsICdmb3JtYXQnOkNNSVJlc3VsdCwgJ21vZCc6J3cnLCAncmVhZGVycm9yJzonNDA0JywgJ3dyaXRlZXJyb3InOic0MDUnfSxcbiAgICAgICAgICAgICAgICAnY21pLmludGVyYWN0aW9ucy5uLmxhdGVuY3knOnsncGF0dGVybic6Q01JSW5kZXgsICdmb3JtYXQnOkNNSVRpbWVzcGFuLCAnbW9kJzondycsICdyZWFkZXJyb3InOic0MDQnLCAnd3JpdGVlcnJvcic6JzQwNSd9LFxuICAgICAgICAgICAgICAgICduYXYuZXZlbnQnOnsnZGVmYXVsdHZhbHVlJzonJywgJ2Zvcm1hdCc6TkFWRXZlbnQsICdtb2QnOid3JywgJ3JlYWRlcnJvcic6JzQwNCcsICd3cml0ZWVycm9yJzonNDA1J31cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF0gPSB7fTtcblxuICAgICAgICAgICAgLy8gTG9hZCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgICAgIGZvciAodmFyIGVsZW1lbnQgaW4gZGF0YW1vZGVsW3Njb2lkXSkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm1hdGNoKC9cXC5uXFwuLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhbW9kZWxbc2NvaWRdW2VsZW1lbnRdLmRlZmF1bHR2YWx1ZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFVzZXJEYXRhW3Njb2lkXVtlbGVtZW50XSA9IGRhdGFtb2RlbFtzY29pZF1bZWxlbWVudF0uZGVmYXVsdHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb2FkIGluaXRpYWwgdXNlciBkYXRhIGZvciBjdXJyZW50IFNDTy5cbiAgICAgICAgICAgIGZvciAoZWxlbWVudCBpbiBkZWZbc2NvaWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQubWF0Y2goL1xcLm5cXC4vKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFtb2RlbFtzY29pZF1bZWxlbWVudF0uZGVmYXVsdHZhbHVlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlckRhdGFbc2NvaWRdW2VsZW1lbnRdID0gZGF0YW1vZGVsW3Njb2lkXVtlbGVtZW50XS5kZWZhdWx0dmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZkV4dHJhW3Njb2lkXVtlbGVtZW50XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaW4gdXNlciBkYXRhIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bZWxlbWVudF0gPSBkZWZFeHRyYVtzY29pZF1bZWxlbWVudF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlckRhdGFbc2NvaWRdW2VsZW1lbnRdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExvYWQgaW50ZXJhY3Rpb25zIGFuZCBvYmplY3RpdmVzLCBhbmQgaW5pdCB0aGUgY291bnRlcnMuXG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAoQ01JSW5kZXgsJ2cnKTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50RG90Rm9ybWF0LCBjb3VudGVyRWxlbWVudCwgY3VycmVudENvdW50ZXJJbmRleCwgY3VycmVudE47XG4gICAgICAgICAgICBmb3IgKGVsZW1lbnQgaW4gZGVmRXh0cmFbc2NvaWRdKSB7XG4gICAgICAgICAgICAgICAgY291bnRlckVsZW1lbnQgPSAnJztcbiAgICAgICAgICAgICAgICBjdXJyZW50Q291bnRlckluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoZWNrIGZvciBhbiBpbmRleGVkIGVsZW1lbnQuIGNtaS5vYmplY3RpdmVzLjEuaWQgb3IgY21pLm9iamVjdGl2ZXNfMS5pZC5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5tYXRjaChleHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gdGhlIGV4cGVjdGVkIHZhbHVlIGFjY29yZGluZyB0aGUgc3RhbmRhcmQuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vb2RsZSBzdG9yZXMgdGhpcyB2YWx1ZXMgdXNpbmcgX24uIGluc3RlYWQgLm4uXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnREb3RGb3JtYXQgPSBlbGVtZW50LnJlcGxhY2UoZXhwcmVzc2lvbiwgXCIuJDEuXCIpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlckRhdGFbc2NvaWRdW2VsZW1lbnREb3RGb3JtYXRdID0gZGVmRXh0cmFbc2NvaWRdW2VsZW1lbnRdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY29ycmVjdCBjb3VudGVyIGFuZCBjdXJyZW50IGluZGV4LlxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudERvdEZvcm1hdC5pbmRleE9mKFwiY21pLmV2YWx1YXRpb24uY29tbWVudHNcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJFbGVtZW50ID0gXCJjbWkuZXZhbHVhdGlvbi5jb21tZW50cy5fY291bnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb3VudGVySW5kZXggPSBlbGVtZW50RG90Rm9ybWF0Lm1hdGNoKC8uKFxcZCspLi8pWzFdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnREb3RGb3JtYXQuaW5kZXhPZihcImNtaS5vYmplY3RpdmVzXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyRWxlbWVudCA9IFwiY21pLm9iamVjdGl2ZXMuX2NvdW50XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q291bnRlckluZGV4ID0gZWxlbWVudERvdEZvcm1hdC5tYXRjaCgvLihcXGQrKS4vKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50RG90Rm9ybWF0LmluZGV4T2YoXCJjbWkuaW50ZXJhY3Rpb25zXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudERvdEZvcm1hdC5pbmRleE9mKFwiLm9iamVjdGl2ZXMuXCIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROID0gZWxlbWVudERvdEZvcm1hdC5tYXRjaCgvY21pLmludGVyYWN0aW9ucy4oXFxkKykuLylbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvdW50ZXJJbmRleCA9IGVsZW1lbnREb3RGb3JtYXQubWF0Y2goL29iamVjdGl2ZXMuKFxcZCspLi8pWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJFbGVtZW50ID0gXCJjbWkuaW50ZXJhY3Rpb25zLlwiICsgY3VycmVudE4gKyBcIi5vYmplY3RpdmVzLl9jb3VudFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50RG90Rm9ybWF0LmluZGV4T2YoXCIuY29ycmVjdF9yZXNwb25zZXMuXCIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROID0gZWxlbWVudERvdEZvcm1hdC5tYXRjaCgvY21pLmludGVyYWN0aW9ucy4oXFxkKykuLylbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvdW50ZXJJbmRleCA9IGVsZW1lbnREb3RGb3JtYXQubWF0Y2goL2NvcnJlY3RfcmVzcG9uc2VzLihcXGQrKS4vKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyRWxlbWVudCA9IFwiY21pLmludGVyYWN0aW9ucy5cIiArIGN1cnJlbnROICsgXCIuY29ycmVjdF9yZXNwb25zZXMuX2NvdW50XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJFbGVtZW50ID0gXCJjbWkuaW50ZXJhY3Rpb25zLl9jb3VudFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb3VudGVySW5kZXggPSBlbGVtZW50RG90Rm9ybWF0Lm1hdGNoKC8uKFxcZCspLi8pWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bY291bnRlckVsZW1lbnRdID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlckRhdGFbc2NvaWRdW2NvdW50ZXJFbGVtZW50XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHN1bS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChjdXJyZW50Q291bnRlckluZGV4KSA9PSBwYXJzZUludChjdXJyZW50VXNlckRhdGFbc2NvaWRdW2NvdW50ZXJFbGVtZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlckRhdGFbc2NvaWRdW2NvdW50ZXJFbGVtZW50XSA9IHBhcnNlSW50KGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bY291bnRlckVsZW1lbnRdKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoY3VycmVudENvdW50ZXJJbmRleCkgPiBwYXJzZUludChjdXJyZW50VXNlckRhdGFbc2NvaWRdW2NvdW50ZXJFbGVtZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlckRhdGFbc2NvaWRdW2NvdW50ZXJFbGVtZW50XSA9IHBhcnNlSW50KGN1cnJlbnRDb3VudGVySW5kZXgpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgZGVmYXVsdCBzdGF0dXMuXG4gICAgICAgICAgICBpZiAoY3VycmVudFVzZXJEYXRhW3Njb2lkXVsnY21pLmNvcmUubGVzc29uX3N0YXR1cyddID09PSAnJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnXSA9ICdub3QgYXR0ZW1wdGVkJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVmaW5lIG1vZGUgYW5kIGNyZWRpdC5cbiAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzY29pZF1bJ2NtaS5jb3JlLmNyZWRpdCddID0gbW9kZSA9PSAkbW1hTW9kU2Nvcm0uTU9ERU5PUk1BTCA/ICdjcmVkaXQnIDogJ25vLWNyZWRpdCc7XG4gICAgICAgICAgICBjdXJyZW50VXNlckRhdGFbc2NvaWRdWydjbWkuY29yZS5sZXNzb25fbW9kZSddID0gbW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFQSSBoZWxwZXIgbWV0aG9kcy5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBub24tcGVyc2lzdGVudCAoY3VycmVudCkgdXNlciBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVsIFRoZSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgVGhlIGVsZW1lbnQgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldEVsKGVsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY3VycmVudFVzZXJEYXRhW3NlbGYuc2NvSWRdW2VsXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF1bZWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIG5vbi1wZXJzaXN0ZW50IChjdXJyZW50KSB1c2VyIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gZWwgVGhlIGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNldEVsKGVsLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXVtlbF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBjbG9uaW5nIGFuIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gIGJlIGNsb25lZFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgY2xvbmVkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDbG9uZU9iaihvYmope1xuICAgICAgICAgICAgaWYob2JqID09IG51bGwgfHwgdHlwZW9mKG9iaikgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGVtcCA9IG5ldyBvYmouY29uc3RydWN0b3IoKTsgLy8gQ2hhbmdlZCAodHdpY2UpLlxuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgdGVtcFtrZXldID0gQ2xvbmVPYmoob2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBhZGRpbmcgdHdvIHRpbWVzIGluIGZvcm1hdCBoaDptbTpzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0ICBGaXJzdCB0aW1lLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2Vjb25kIFNlY29uZCB0aW1lLlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFRvdGFsIHRpbWUuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBZGRUaW1lIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgc0ZpcnN0ID0gZmlyc3Quc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgdmFyIHNTZWNvbmQgPSBzZWNvbmQuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgdmFyIGNGaXJzdCA9IHNGaXJzdFsyXS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICB2YXIgY1NlY29uZCA9IHNTZWNvbmRbMl0uc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IDA7XG5cbiAgICAgICAgICAgIEZpcnN0Q2VudHMgPSAwOyAgLy9DZW50c1xuICAgICAgICAgICAgaWYgKGNGaXJzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgRmlyc3RDZW50cyA9IHBhcnNlSW50KGNGaXJzdFsxXSwxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTZWNvbmRDZW50cyA9IDA7XG4gICAgICAgICAgICBpZiAoY1NlY29uZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgU2Vjb25kQ2VudHMgPSBwYXJzZUludChjU2Vjb25kWzFdLDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjZW50cyA9IEZpcnN0Q2VudHMgKyBTZWNvbmRDZW50cztcbiAgICAgICAgICAgIGNoYW5nZSA9IE1hdGguZmxvb3IoY2VudHMgLyAxMDApO1xuICAgICAgICAgICAgY2VudHMgPSBjZW50cyAtIChjaGFuZ2UgKiAxMDApO1xuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IoY2VudHMpIDwgMTApIHtcbiAgICAgICAgICAgICAgICBjZW50cyA9IFwiMFwiICsgY2VudHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlY3MgPSBwYXJzZUludChjRmlyc3RbMF0sMTApICsgcGFyc2VJbnQoY1NlY29uZFswXSwxMCkgKyBjaGFuZ2U7ICAvL1NlY29uZHNcbiAgICAgICAgICAgIGNoYW5nZSA9IE1hdGguZmxvb3Ioc2VjcyAvIDYwKTtcbiAgICAgICAgICAgIHNlY3MgPSBzZWNzIC0gKGNoYW5nZSAqIDYwKTtcbiAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKHNlY3MpIDwgMTApIHtcbiAgICAgICAgICAgICAgICBzZWNzID0gXCIwXCIgKyBzZWNzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbnMgPSBwYXJzZUludChzRmlyc3RbMV0sMTApICsgcGFyc2VJbnQoc1NlY29uZFsxXSwxMCkgKyBjaGFuZ2U7ICAgLy9NaW51dGVzXG4gICAgICAgICAgICBjaGFuZ2UgPSBNYXRoLmZsb29yKG1pbnMgLyA2MCk7XG4gICAgICAgICAgICBtaW5zID0gbWlucyAtIChjaGFuZ2UgKiA2MCk7XG4gICAgICAgICAgICBpZiAobWlucyA8IDEwKSB7XG4gICAgICAgICAgICAgICAgbWlucyA9IFwiMFwiICsgbWlucy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBob3VycyA9IHBhcnNlSW50KHNGaXJzdFswXSwxMCkgKyBwYXJzZUludChzU2Vjb25kWzBdLDEwKSArIGNoYW5nZTsgIC8vSG91cnNcbiAgICAgICAgICAgIGlmIChob3VycyA8IDEwKSB7XG4gICAgICAgICAgICAgICAgaG91cnMgPSBcIjBcIiArIGhvdXJzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjZW50cyAhPSAnMCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cnMgKyBcIjpcIiArIG1pbnMgKyBcIjpcIiArIHNlY3MgKyAnLicgKyBjZW50cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXJzICsgXCI6XCIgKyBtaW5zICsgXCI6XCIgKyBzZWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGNhbGN1bGF0aW5nIHRoZSB0b3RhbCB0aW1lIHNwZW50IGluIHRoZSBTQ08uXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBUb3RhbFRpbWUoKSB7XG4gICAgICAgICAgICB0b3RhbF90aW1lID0gQWRkVGltZShnZXRFbCgnY21pLmNvcmUudG90YWxfdGltZScpLCBnZXRFbCgnY21pLmNvcmUuc2Vzc2lvbl90aW1lJykpO1xuICAgICAgICAgICAgcmV0dXJuIHsnZWxlbWVudCc6ICdjbWkuY29yZS50b3RhbF90aW1lJywgdmFsdWU6IHRvdGFsX3RpbWV9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcnNpc3QgdGhlIGN1cnJlbnQgdXNlciBkYXRhICh0aGlzIGlzIHVzdWFsbHkgY2FsbGVkIGJ5IExNU0NvbW1pdClcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtCb29sfSBzdG9yZXRvdGFsdGltZSBJZiB0cnVlLCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgdG90YWwgdGltZSB0b29cbiAgICAgICAgICogQHJldHVybiB7Qm9vbH0gW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gU3RvcmVEYXRhKHN0b3JldG90YWx0aW1lKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmV0b3RhbHRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0RWwoJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnKSA9PSAnbm90IGF0dGVtcHRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWwoJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnLCAnY29tcGxldGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZXRFbCgnY21pLmNvcmUubGVzc29uX21vZGUnKSA9PSAkbW1hTW9kU2Nvcm0uTU9ERU5PUk1BTCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0RWwoJ2NtaS5jb3JlLmNyZWRpdCcpID09ICdjcmVkaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0RWwoJ2NtaS5zdHVkZW50X2RhdGEubWFzdGVyeV9zY29yZScpICE9PSAnJyAmJiBnZXRFbCgnY21pLmNvcmUuc2NvcmUucmF3JykgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQoZ2V0RWwoJ2NtaS5jb3JlLnNjb3JlLnJhdycpKSA+PSBwYXJzZUZsb2F0KGdldEVsKCdjbWkuc3R1ZGVudF9kYXRhLm1hc3Rlcnlfc2NvcmUnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWwoJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnLCAncGFzc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWwoJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZXRFbCgnY21pLmNvcmUubGVzc29uX21vZGUnKSA9PSAkbW1hTW9kU2Nvcm0uTU9ERUJST1dTRSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YW1vZGVsW3NlbGYuc2NvSWRdWydjbWkuY29yZS5sZXNzb25fc3RhdHVzJ10uZGVmYXVsdHZhbHVlID09ICcnICYmIGdldEVsKCdjbWkuY29yZS5sZXNzb25fc3RhdHVzJykgPT0gJ25vdCBhdHRlbXB0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFbCgnY21pLmNvcmUubGVzc29uX3N0YXR1cycsICdicm93c2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2tzID0gQ29sbGVjdERhdGEoKTtcbiAgICAgICAgICAgICAgICB0cmFja3MucHVzaChUb3RhbFRpbWUoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNrcyA9IENvbGxlY3REYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9ICRtbWFNb2RTY29ybS5zYXZlVHJhY2tzU3luYyhzZWxmLnNjb0lkLCBhdHRlbXB0LCB0cmFja3MsIHNlbGYub2ZmbGluZSwgc2Nvcm0sIGN1cnJlbnRVc2VyRGF0YSk7XG4gICAgICAgICAgICBpZiAoIXNlbGYub2ZmbGluZSAmJiAhc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIC8vIEZhaWx1cmUgc3RvcmluZyBkYXRhIGluIG9ubGluZS4gR28gb2ZmbGluZS5cbiAgICAgICAgICAgICAgICBzZWxmLm9mZmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChtbWFNb2RTY29ybUV2ZW50R29PZmZsaW5lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLnNhdmVUcmFja3NTeW5jKHNlbGYuc2NvSWQsIGF0dGVtcHQsIHRyYWNrcywgc2VsZi5vZmZsaW5lLCBzY29ybSwgY3VycmVudFVzZXJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3QgYWxsIHRoZSB1c2VyIHRyYWNraW5nIGRhdGEgdGhhdCBtdXN0IGJlIHBlcnNpc3RlZCBpbiB0aGUgc3lzdGVtLCB0aGlzIGlzIHVzdWFsbHkgY2FsbGVkIGJ5IExNU0NvbW1pdCgpLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29sbGVjdERhdGEoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgZWxlbWVudCBpbiBjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF0pIHtcbiAgICAgICAgICAgICAgICAvLyBPbW1pdCBmb3IgZXhhbXBsZSB0aGUgbmF2LiBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdWJzdHIoMCwgMykgPT0gJ2NtaScpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAoQ01JSW5kZXgsJ2cnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGdlbmVyaWMgbmFtZSBmb3IgdGhpcyBlbGVtZW50IChlLmcuIGNvbnZlcnQgJ2NtaS5pbnRlcmFjdGlvbnMuMS5pZCcgdG8gJ2NtaS5pbnRlcmFjdGlvbnMubi5pZCcpXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRtb2RlbCA9IFN0cmluZyhlbGVtZW50KS5yZXBsYWNlKGV4cHJlc3Npb24sJy5uLicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgc2Vzc2lvbiB0aW1lIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IFwiY21pLmNvcmUuc2Vzc2lvbl90aW1lXCIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBzcGVjaWZpYyBlbGVtZW50IGlzIG5vdCBkZWZpbmVkIGluIHRoZSBkYXRhbW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgdGhlIGdlbmVyaWMgZWxlbWVudCBuYW1lIGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudF0gPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRtb2RlbF0gIT0gXCJ1bmRlZmluZWRcIikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgc3BlY2lmaWMgZWxlbWVudCB0byB0aGUgZGF0YSBtb2RlbCAoYnkgY2xvbmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBnZW5lcmljIGVsZW1lbnQpIHNvIHdlIGNhbiB0cmFjayBjaGFuZ2VzIHRvIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50XSA9IENsb25lT2JqKGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50bW9kZWxdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZWxlbWVudCBleGlzdHMgaW4gdGhlIGRhdGFtb2RlbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRdICE9IFwidW5kZWZpbmVkXCIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGlzIG5vdCBhIHJlYWQgb25seSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudF0ubW9kICE9ICdyJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vb2RsZSBzdG9yZXMgdGhlIG9yZ2FuaXphdGlvbnMgYW5kIGludGVyYWN0aW9ucyB1c2luZyBfbi4gaW5zdGVhZCAubi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlbGVtZW50JzogZWxlbWVudC5yZXBsYWNlKGV4cHJlc3Npb24sIFwiXyQxLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IGdldEVsKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaGFzIGEgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudF0uZGVmYXVsdHZhbHVlICE9IFwidW5kZWZpbmVkXCIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRlZmF1bHQgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRdLmRlZmF1bHR2YWx1ZSAhPSBlbFsndmFsdWUnXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRdLmRlZmF1bHR2YWx1ZSAhPSB0eXBlb2YoZWxbJ3ZhbHVlJ10pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlbGVtZW50IGRlZmF1bHQgdG8gcmVmbGVjdCB0aGUgY3VycmVudCBjb21taXR0ZWQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRdLmRlZmF1bHR2YWx1ZSA9IGVsWyd2YWx1ZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBlbGVtZW50LCBzbyBzZXQgaXQgbm93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRdLmRlZmF1bHR2YWx1ZSA9IGVsWyd2YWx1ZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFQSSBtZXRob2RzIG5vdy5cbiAgICAgICAgdmFyIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvckNvZGU7XG4gICAgICAgIHZhciB0aW1lb3V0O1xuXG4gICAgICAgIHNlbGYuTE1TSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICBlcnJvckNvZGUgPSBcIjBcIjtcbiAgICAgICAgICAgIGlmIChwYXJhbSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cnVlXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIxMDFcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMjAxXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBcImZhbHNlXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5MTVNGaW5pc2ggPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIwXCI7XG4gICAgICAgICAgICBpZiAocGFyYW0gPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBTdG9yZURhdGEodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRFbCgnbmF2LmV2ZW50JykgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRFbCgnbmF2LmV2ZW50JykgPT0gJ2NvbnRpbnVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChtbWFNb2RTY29ybUV2ZW50TGF1bmNoTmV4dFNjbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChtbWFNb2RTY29ybUV2ZW50TGF1bmNoUHJldlNjbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nvcm0uYXV0byA9PSAnMScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQobW1hTW9kU2Nvcm1FdmVudExhdW5jaE5leHRTY28pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IChyZXN1bHQpID8gJzAnIDogJzEwMSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBUT0MgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQobW1hTW9kU2Nvcm1FdmVudFVwZGF0ZVRvYyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIzMDFcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMjAxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJmYWxzZVwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuTE1TR2V0VmFsdWUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBlcnJvckNvZGUgPSBcIjBcIjtcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAoQ01JSW5kZXgsJ2cnKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudG1vZGVsID0gU3RyaW5nKGVsZW1lbnQpLnJlcGxhY2UoZXhwcmVzc2lvbiwnLm4uJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRtb2RlbF0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50bW9kZWxdLm1vZCAhPSAndycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RWwoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50bW9kZWxdLnJlYWRlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuc3RyID0gJy5fY2hpbGRyZW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRzdHIgPSAnLl9jb3VudCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudG1vZGVsLnN1YnN0cihlbGVtZW50bW9kZWwubGVuZ3RoIC0gY2hpbGRyZW5zdHIubGVuZ3RoLGVsZW1lbnRtb2RlbC5sZW5ndGgpID09IGNoaWxkcmVuc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50bW9kZWwgPSBlbGVtZW50bW9kZWwuc3Vic3RyKDAsZWxlbWVudG1vZGVsLmxlbmd0aCAtIGNoaWxkcmVuc3RyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhbW9kZWxbc2VsZi5zY29JZF1bcGFyZW50bW9kZWxdICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIyMDJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjIwMVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudG1vZGVsLnN1YnN0cihlbGVtZW50bW9kZWwubGVuZ3RoIC0gY291bnRzdHIubGVuZ3RoLGVsZW1lbnRtb2RlbC5sZW5ndGgpID09IGNvdW50c3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50bW9kZWwgPSBlbGVtZW50bW9kZWwuc3Vic3RyKDAsZWxlbWVudG1vZGVsLmxlbmd0aCAtIGNvdW50c3RyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhbW9kZWxbc2VsZi5zY29JZF1bcGFyZW50bW9kZWxdICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIyMDNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjIwMVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIyMDFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMjAxXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjMwMVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5MTVNTZXRWYWx1ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgICAgICBlcnJvckNvZGUgPSBcIjBcIjtcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAoQ01JSW5kZXgsJ2cnKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudG1vZGVsID0gU3RyaW5nKGVsZW1lbnQpLnJlcGxhY2UoZXhwcmVzc2lvbiwnLm4uJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YW1vZGVsW3NlbGYuc2NvSWRdW2VsZW1lbnRtb2RlbF0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50bW9kZWxdLm1vZCAhPSAncicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gbmV3IFJlZ0V4cChkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudG1vZGVsXS5mb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gdmFsdWUubWF0Y2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZHluYW1pYyBkYXRhIG1vZGVsIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IGVsZW1lbnRtb2RlbCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbml0IGRlZmF1bHQgY291bnRlcnMgYW5kIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmluZGV4T2YoXCJjbWkub2JqZWN0aXZlc1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROID0gZWxlbWVudC5tYXRjaCgvY21pLm9iamVjdGl2ZXMuKFxcZCspLi8pWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJFbGVtZW50ID0gXCJjbWkub2JqZWN0aXZlcy5cIiArIGN1cnJlbnROICsgXCIuc2NvcmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXVtjb3VudGVyRWxlbWVudCArICcuX2NoaWxkcmVuJ10gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbChjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF1bY291bnRlckVsZW1lbnQgKyAnLl9jaGlsZHJlbiddLCBzY29yZV9jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsKGN1cnJlbnRVc2VyRGF0YVtzZWxmLnNjb0lkXVtjb3VudGVyRWxlbWVudCArICcucmF3J10sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWwoY3VycmVudFVzZXJEYXRhW3NlbGYuc2NvSWRdW2NvdW50ZXJFbGVtZW50ICsgJy5taW4nXSwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbChjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF1bY291bnRlckVsZW1lbnQgKyAnLm1heCddLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaW5kZXhPZihcImNtaS5pbnRlcmFjdGlvbnNcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TiA9IGVsZW1lbnQubWF0Y2goL2NtaS5pbnRlcmFjdGlvbnMuKFxcZCspLi8pWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlckVsZW1lbnQgPSBcImNtaS5pbnRlcmFjdGlvbnMuXCIgKyBjdXJyZW50TiArIFwiLm9iamVjdGl2ZXMuX2NvdW50XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF1bY291bnRlckVsZW1lbnRdID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWwoY291bnRlckVsZW1lbnQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyRWxlbWVudCA9IFwiY21pLmludGVyYWN0aW9ucy5cIiArIGN1cnJlbnROICsgXCIuY29ycmVjdF9yZXNwb25zZXMuX2NvdW50XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF1bY291bnRlckVsZW1lbnRdID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWwoY291bnRlckVsZW1lbnQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudEluZGV4ZXMgPSBlbGVtZW50LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJlbGVtZW50ID0gJ2NtaSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgZWxlbWVudEluZGV4ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudEluZGV4ID0gZWxlbWVudEluZGV4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRJbmRleGVzW2kgKyAxXS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VXNlckRhdGFbc2VsZi5zY29JZF1bc3ViZWxlbWVudCArICcuJyArIGVsZW1lbnRJbmRleCArICcuX2NvdW50J10gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWwoc3ViZWxlbWVudCArICcuJyArIGVsZW1lbnRJbmRleCArICcuX2NvdW50JywgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRJbmRleGVzW2kgKyAxXSA9PSBnZXRFbChzdWJlbGVtZW50ICsgJy4nICsgZWxlbWVudEluZGV4ICsgJy5fY291bnQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gZ2V0RWwoc3ViZWxlbWVudCArICcuJyArIGVsZW1lbnRJbmRleCArICcuX2NvdW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbChzdWJlbGVtZW50ICsgJy4nICsgZWxlbWVudEluZGV4ICsgJy5fY291bnQnLCBwYXJzZUludChjb3VudCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEluZGV4ZXNbaSArIDFdID4gZ2V0RWwoc3ViZWxlbWVudCArICcuJyArIGVsZW1lbnRJbmRleCArICcuX2NvdW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMjAxXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViZWxlbWVudCA9IHN1YmVsZW1lbnQuY29uY2F0KCcuJyArIGVsZW1lbnRJbmRleCArICcuJyArIGVsZW1lbnRJbmRleGVzW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJlbGVtZW50ID0gc3ViZWxlbWVudC5jb25jYXQoJy4nICsgZWxlbWVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gc3ViZWxlbWVudC5jb25jYXQoJy4nICsgZWxlbWVudEluZGV4ZXNbZWxlbWVudEluZGV4ZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU3RvcmUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09IFwiMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nvcm0uYXV0b2NvbW1pdCAmJiAhKHRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoc2VsZi5MTVNDb21taXQsIDYwMDAwLCBbXCJcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudG1vZGVsXS5yYW5nZSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudG1vZGVsXS5yYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMgPSByYW5nZS5zcGxpdCgnIycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA+PSByYW5nZXNbMF0pICYmICh2YWx1ZSA8PSByYW5nZXNbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsKGVsZW1lbnQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRydWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudG1vZGVsXS53cml0ZWVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT0gJ2NtaS5jb21tZW50cycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWwoJ2NtaS5jb21tZW50cycsIGdldEVsKCdjbWkuY29tbWVudHMnKSArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbChlbGVtZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRydWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IGRhdGFtb2RlbFtzZWxmLnNjb0lkXVtlbGVtZW50bW9kZWxdLndyaXRlZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBkYXRhbW9kZWxbc2VsZi5zY29JZF1bZWxlbWVudG1vZGVsXS53cml0ZWVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIyMDFcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMjAxXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvckNvZGUgPSBcIjMwMVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiZmFsc2VcIjtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLkxNU0NvbW1pdCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMFwiO1xuICAgICAgICAgICAgaWYgKHBhcmFtID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gU3RvcmVEYXRhKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBUT0MgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQobW1hTW9kU2Nvcm1FdmVudFVwZGF0ZVRvYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gcmVzdWx0ID8gJzAnIDogJzEwMSc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID0gXCIzMDFcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9IFwiMjAxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJmYWxzZVwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuTE1TR2V0TGFzdEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JDb2RlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBlcnJvclN0cmluZyA9IFtdO1xuICAgICAgICBlcnJvclN0cmluZ1tcIjBcIl0gPSBcIk5vIGVycm9yXCI7XG4gICAgICAgIGVycm9yU3RyaW5nW1wiMTAxXCJdID0gXCJHZW5lcmFsIGV4Y2VwdGlvblwiO1xuICAgICAgICBlcnJvclN0cmluZ1tcIjIwMVwiXSA9IFwiSW52YWxpZCBhcmd1bWVudCBlcnJvclwiO1xuICAgICAgICBlcnJvclN0cmluZ1tcIjIwMlwiXSA9IFwiRWxlbWVudCBjYW5ub3QgaGF2ZSBjaGlsZHJlblwiO1xuICAgICAgICBlcnJvclN0cmluZ1tcIjIwM1wiXSA9IFwiRWxlbWVudCBub3QgYW4gYXJyYXkgLSBjYW5ub3QgaGF2ZSBjb3VudFwiO1xuICAgICAgICBlcnJvclN0cmluZ1tcIjMwMVwiXSA9IFwiTm90IGluaXRpYWxpemVkXCI7XG4gICAgICAgIGVycm9yU3RyaW5nW1wiNDAxXCJdID0gXCJOb3QgaW1wbGVtZW50ZWQgZXJyb3JcIjtcbiAgICAgICAgZXJyb3JTdHJpbmdbXCI0MDJcIl0gPSBcIkludmFsaWQgc2V0IHZhbHVlLCBlbGVtZW50IGlzIGEga2V5d29yZFwiO1xuICAgICAgICBlcnJvclN0cmluZ1tcIjQwM1wiXSA9IFwiRWxlbWVudCBpcyByZWFkIG9ubHlcIjtcbiAgICAgICAgZXJyb3JTdHJpbmdbXCI0MDRcIl0gPSBcIkVsZW1lbnQgaXMgd3JpdGUgb25seVwiO1xuICAgICAgICBlcnJvclN0cmluZ1tcIjQwNVwiXSA9IFwiSW5jb3JyZWN0IGRhdGEgdHlwZVwiO1xuXG4gICAgICAgIHNlbGYuTE1TR2V0RXJyb3JTdHJpbmcgPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JTdHJpbmdbcGFyYW1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuTE1TR2V0RGlhZ25vc3RpYyA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICBpZiAocGFyYW0gPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHBhcmFtID0gZXJyb3JDb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgZGF0YW1vZGVsIGZvciBTQ09STSAxLjIgcG9wdWxhdGluZyBhbGwgdGhlIHJlcXVpcmVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtRGF0YU1vZGVsMTIjaW5pdEFQSVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2Nvcm0gICAgVGhlIFNDT1JNIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkICAgIFRoZSBTQ08gaWQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0ICBUaGUgYXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB1c2VyRGF0YSBUaGUgdXNlciBkZWZhdWx0IGRhdGEuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbbW9kZV0gICBNb2RlLiBPbmUgb2YgJG1tYU1vZFNjb3JtI01PREUgY29uc3RhbnRzLiBCeSBkZWZhdWx0LCBNT0RFTk9STUFMLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG9mZmxpbmUgVHJ1ZSBpZiBhdHRlbXB0IGlzIG9mZmxpbmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmluaXRBUEkgPSBmdW5jdGlvbihzY29ybSwgc2NvSWQsIGF0dGVtcHQsIHVzZXJEYXRhLCBtb2RlLCBvZmZsaW5lKSB7XG4gICAgICAgIG1vZGUgPSBtb2RlIHx8ICRtbWFNb2RTY29ybS5NT0RFTk9STUFMO1xuICAgICAgICAkd2luZG93LkFQSSA9IG5ldyBTQ09STUFQSShzY29ybSwgc2NvSWQsIGF0dGVtcHQsIHVzZXJEYXRhLCBtb2RlLCBvZmZsaW5lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgZGlmZmVyZW50IFNDTyBpZCBmb3IgdGhlIGN1cnJlbnQgQVBJIG9iamVjdC5cbiAgICAgKiBUaGUgc2NvSWQgaXMgbGlrZSBhIHBvaW50ZXIgdG8gYmUgYWJsZSB0byByZXRyaWV2ZSB0aGUgU0NPIGRlZmF1bHQgdmFsdWVzIGFuZCBzZXQgdGhlIG5ldyBvbmVzIGluIHRoZSBvdmVyYWxsIFNDT1JNIGRhdGEgc3RydWN0dXJlXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtRGF0YU1vZGVsMTIjbG9hZFNjb1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgVGhlIG5ldyBTQ08gaWQuXG4gICAgICovXG4gICAgc2VsZi5sb2FkU2NvID0gZnVuY3Rpb24oc2NvSWQpIHtcbiAgICAgICAgJHdpbmRvdy5BUEkuc2NvSWQgPSBzY29JZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mZmxpbmUgbW9kZSB0byB0cnVlIG9yIGZhbHNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybURhdGFNb2RlbDEyI3NldE9mZmxpbmVcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvZmZsaW5lIFRydWUgaWYgb2ZmbGluZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuc2V0T2ZmbGluZSA9IGZ1bmN0aW9uKG9mZmxpbmUpIHtcbiAgICAgICAgJHdpbmRvdy5BUEkub2ZmbGluZSA9IG9mZmxpbmU7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2Rfc2Nvcm0nKVxuXG4vKipcbiAqIE1vZCBzY29ybSBoYW5kbGVycy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kU2Nvcm1IYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZFNjb3JtSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1Db3Vyc2UsICRtbWFNb2RTY29ybSwgJG1tRXZlbnRzLCAkc3RhdGUsICRtbVNpdGUsICRtbWFNb2RTY29ybUhlbHBlcixcbiAgICAgICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZSwgbW1Db3JlRG93bmxvYWRpbmcsIG1tQ29yZU5vdERvd25sb2FkZWQsIG1tQ29yZU91dGRhdGVkLCBtbUNvcmVFdmVudFBhY2thZ2VTdGF0dXNDaGFuZ2VkLFxuICAgICAgICBtbWFNb2RTY29ybUNvbXBvbmVudCwgJHEsICRtbUNvbnRlbnRMaW5rc0hlbHBlcikge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybUhhbmRsZXJzI2NvdXJzZUNvbnRlbnRcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kdWxlIGlzIGVuYWJsZWQgZm9yIHRoZSBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRCdG4sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hCdG47XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGJ1dHRvbnMgd2l0aG91dCBhY3Rpb24geWV0LiBUaGlzIGlzIHRvIHByZXZlbnQgYSBnbGl0Y2ggaW4gdGhlIHZpZXcuXG4gICAgICAgICAgICAgICAgZG93bmxvYWRCdG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2lvbi1pb3MtY2xvdWQtZG93bmxvYWQnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ21tLmNvcmUuZG93bmxvYWQnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlZnJlc2hCdG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tYW5kcm9pZC1yZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdtbS5jb3JlLnJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAkbW1Db3Vyc2UuZ2V0TW9kdWxlSWNvblNyYygnc2Nvcm0nKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYnV0dG9ucyA9IFtkb3dubG9hZEJ0biwgcmVmcmVzaEJ0bl07XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNwaW5uZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2Rfc2Nvcm0nLCB7bW9kdWxlOiBtb2R1bGUsIGNvdXJzZWlkOiBjb3Vyc2VpZH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSBTQ09STSB0byBjYWxjdWxhdGUgdGhlIHJlc3Qgb2YgZGF0YS5cbiAgICAgICAgICAgICAgICAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm0oY291cnNlaWQsIG1vZHVsZS5pZCwgbW9kdWxlLnVybCkudGhlbihmdW5jdGlvbihzY29ybSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV2aXNpb24gPSBzY29ybS5zaGExaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG93bmxvYWQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kU2Nvcm1IZWxwZXIuY29uZmlybURvd25sb2FkKHNjb3JtKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RTY29ybS5wcmVmZXRjaChzY29ybSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kU2Nvcm1IZWxwZXIuc2hvd0Rvd25sb2FkRXJyb3Ioc2Nvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyBhZGQgdGhlIGFjdGlvbiB0byB0aGUgYnV0dG9ucy5cbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRCdG4uYWN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEJ0bi5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgJG1tYU1vZFNjb3JtLmludmFsaWRhdGVDb250ZW50KHNjb3JtLmNvdXJzZW1vZHVsZSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBidXR0b25zIGFjY29yZGluZyB0byBtb2R1bGUgc3RhdHVzLlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG93U3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zcGlubmVyID0gc3RhdHVzID09PSBtbUNvcmVEb3dubG9hZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEJ0bi5oaWRkZW4gPSBzdGF0dXMgIT09IG1tQ29yZU5vdERvd25sb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEJ0bi5oaWRkZW4gPSBzdGF0dXMgIT09IG1tQ29yZU91dGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoaXMgbW9kdWxlIHN0YXR1cy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1c09ic2VydmVyID0gJG1tRXZlbnRzLm9uKG1tQ29yZUV2ZW50UGFja2FnZVN0YXR1c0NoYW5nZWQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNpdGVpZCA9PT0gJG1tU2l0ZS5nZXRJZCgpICYmIGRhdGEuY29tcG9uZW50SWQgPT09IHNjb3JtLmNvdXJzZW1vZHVsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbXBvbmVudCA9PT0gbW1hTW9kU2Nvcm1Db21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93U3RhdHVzKGRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgc3RhdHVzIHRvIGRlY2lkZSB3aGljaCBpY29uIHNob3VsZCBiZSBzaG93bi5cbiAgICAgICAgICAgICAgICAgICAgJG1tQ291cnNlUHJlZmV0Y2hEZWxlZ2F0ZS5nZXRNb2R1bGVTdGF0dXMobW9kdWxlLCBjb3Vyc2VpZCwgcmV2aXNpb24sIHRpbWVtb2RpZmllZCkudGhlbihzaG93U3RhdHVzKTtcblxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzT2JzZXJ2ZXIgJiYgc3RhdHVzT2JzZXJ2ZXIub2ZmICYmIHN0YXR1c09ic2VydmVyLm9mZigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbGlua3MgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1IYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uaXNQbHVnaW5FbmFibGVkKHNpdGVJZCkudGhlbihmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdXJzZUlkIHx8ICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhY3Rpb25zIHRvIHBlcmZvcm0gd2l0aCB0aGUgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc2l0ZUlkcyAgU2l0ZSBJRHMgdGhlIFVSTCBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgbGlzdCBvZiBhY3Rpb25zLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsLCBjb3Vyc2VJZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaXQncyBhIFNDT1JNIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignL21vZC9zY29ybS92aWV3LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tQ29udGVudExpbmtzSGVscGVyLnRyZWF0TW9kdWxlSW5kZXhVcmwoc2l0ZUlkcywgdXJsLCBpc0VuYWJsZWQsIGNvdXJzZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9zY29ybScpXG5cbi8qKlxuICogSGVscGVyIHRvIGdhdGhlciBzb21lIGNvbW1vbiBTQ09STSBmdW5jdGlvbnMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tQ291cnNlSGVscGVyXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kU2Nvcm1IZWxwZXInLCBmdW5jdGlvbigkbW1hTW9kU2Nvcm0sICRtbVV0aWwsICR0cmFuc2xhdGUsICRxLCAkbW1hTW9kU2Nvcm1PZmZsaW5lLCAkbW1hTW9kU2Nvcm1TeW5jLCAkbW1TaXRlKSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBlbGVtZW50c1RvSWdub3JlID0gWydzdGF0dXMnLCAnc2NvcmVfcmF3JywgJ3RvdGFsX3RpbWUnLCAnc2Vzc2lvbl90aW1lJywgJ3N0dWRlbnRfaWQnLCAnc3R1ZGVudF9uYW1lJywgJ2NyZWRpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21vZGUnLCAnZW50cnknXTsgLy8gTGlzdCBvZiBlbGVtZW50cyB3ZSB3YW50IHRvIGlnbm9yZSB3aGVuIGNvcHlpbmcgYXR0ZW1wdHMgKHRoZXkncmUgY2FsY3VsYXRlZCkuXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCBtZXNzYWdlIHRvIHNob3cgd2FybmluZ3MuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtSGVscGVyI2J1aWxkV2FybmluZ3NNZXNzYWdlXG4gICAgICogQHBhcmFtICB7U3RyaW5nW119IHdhcm5pbmdzIFdhcm5pbmdzIHRvIHNob3cuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgIE1lc3NhZ2Ugd2l0aCBhbGwgdGhlIHdhcm5pbmdzLlxuICAgICAqL1xuICAgIHNlbGYuYnVpbGRXYXJuaW5nc01lc3NhZ2UgPSBmdW5jdGlvbih3YXJuaW5ncykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2god2FybmluZ3MsIGZ1bmN0aW9uKHdhcm5pbmcpIHtcbiAgICAgICAgICAgIGlmICh3YXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgKyAnPHA+JyArIHdhcm5pbmcgKyAnPC9wPic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvZmZsaW5lIGF0dGVtcHQgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb25saW5lIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtSGVscGVyI2NvbnZlcnRBdHRlbXB0VG9PZmZsaW5lXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29ybSAgIFNDT1JNLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCBOdW1iZXIgb2YgdGhlIG9ubGluZSBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGF0dGVtcHQgaXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmNvbnZlcnRBdHRlbXB0VG9PZmZsaW5lID0gZnVuY3Rpb24oc2Nvcm0sIGF0dGVtcHQsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIC8vIEdldCBkYXRhIGZyb20gdGhlIG9ubGluZSBhdHRlbXB0LlxuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldFNjb3JtVXNlckRhdGEoc2Nvcm0uaWQsIGF0dGVtcHQsIGZhbHNlLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24ob25saW5lRGF0YSkge1xuICAgICAgICAgICAgLy8gVGhlIFNDT1JNIEFQSSBtaWdodCBoYXZlIHdyaXR0ZW4gc29tZSBkYXRhIHRvIHRoZSBvZmZsaW5lIGF0dGVtcHQgYWxyZWFkeS5cbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgaXQgd2l0aCBjYWNoZWQgb25saW5lIGRhdGEuXG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5nZXRTY29ybVVzZXJEYXRhKHNpdGVJZCwgc2Nvcm0uaWQsIGF0dGVtcHQpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMuXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKG9mZmxpbmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUb1N0b3JlID0gYW5ndWxhci5jb3B5KG9ubGluZURhdGEpO1xuICAgICAgICAgICAgICAgIC8vIEZpbHRlciB0aGUgZGF0YSB0byBjb3B5LlxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhVG9TdG9yZSwgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBjYWxjdWxhdGVkIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9JZ25vcmUuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjby51c2VyZGF0YVtlbF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IG92ZXJyaWRlIG9mZmxpbmUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmxpbmVEYXRhICYmIG9mZmxpbmVEYXRhW3Njby5zY29pZF0gJiYgb2ZmbGluZURhdGFbc2NvLnNjb2lkXS51c2VyZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjb1VzZXJEYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NvLnVzZXJkYXRhLCBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2ZmbGluZURhdGFbc2NvLnNjb2lkXS51c2VyZGF0YVtlbGVtZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGVsZW1lbnQgaXMgbm90IHN0b3JlZCBpbiBvZmZsaW5lLCB3ZSBjYW4gc2F2ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvVXNlckRhdGFbZWxlbWVudF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjby51c2VyZGF0YSA9IHNjb1VzZXJEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5jcmVhdGVOZXdBdHRlbXB0KHNpdGVJZCwgc2Nvcm0sIHVuZGVmaW5lZCwgYXR0ZW1wdCwgZGF0YVRvU3RvcmUsIG9ubGluZURhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gU2hvdWxkbid0IGhhcHBlbi5cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLmVycm9yY3JlYXRlb2ZmbGluZWF0dGVtcHQnKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9mZmxpbmUgYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1IZWxwZXIjY3JlYXRlT2ZmbGluZUF0dGVtcHRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtICAgICAgU0NPUk0uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBuZXdBdHRlbXB0IE51bWJlciBvZiB0aGUgbmV3IGF0dGVtcHQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsYXN0T25saW5lIE51bWJlciBvZiB0aGUgbGFzdCBvbmxpbmUgYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBhdHRlbXB0IGlzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5jcmVhdGVPZmZsaW5lQXR0ZW1wdCA9IGZ1bmN0aW9uKHNjb3JtLCBuZXdBdHRlbXB0LCBsYXN0T25saW5lLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBkYXRhIGZyb20gb25saW5lIGF0dGVtcHRzLlxuICAgICAgICByZXR1cm4gc2VsZi5zZWFyY2hPbmxpbmVBdHRlbXB0VXNlckRhdGEoc2Nvcm0uaWQsIGxhc3RPbmxpbmUsIHNpdGVJZCkudGhlbihmdW5jdGlvbih1c2VyRGF0YSkge1xuICAgICAgICAgICAgLy8gV2UncmUgY3JlYXRpbmcgYSBuZXcgYXR0ZW1wdCwgcmVtb3ZlIGFsbCB0aGUgdXNlciBkYXRhIHRoYXQgaXMgbm90IG5lZWRlZCBmb3IgYSBuZXcgYXR0ZW1wdC5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IHRoZSBTQ08gZGF0YSBmcm9tIGhlcmUgYmVjYXVzZSBXUyBnZXRfc2NvZXMgZG9lc24ndCByZXR1cm4gc2NvX2RhdGEgaW4gTW9vZGxlIDMuMC5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1c2VyRGF0YSwgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0ge307XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjby51c2VyZGF0YSwgZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5kZXhPZignLicpID09IC0xICYmIGVsZW1lbnRzVG9JZ25vcmUuaW5kZXhPZihlbGVtZW50KSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgZG9lc24ndCB1c2UgYSBkb3Qgbm90YXRpb24sIHByb2JhYmx5IFNDTyBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRbZWxlbWVudF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNjby51c2VyZGF0YSA9IGZpbHRlcmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5jcmVhdGVOZXdBdHRlbXB0KHNpdGVJZCwgc2Nvcm0sIHVuZGVmaW5lZCwgbmV3QXR0ZW1wdCwgdXNlckRhdGEpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLmVycm9yY3JlYXRlb2ZmbGluZWF0dGVtcHQnKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93IGEgY29uZmlybSBkaWFsb2cgaWYgbmVlZGVkLiBJZiBTQ09STSBkb2Vzbid0IGhhdmUgc2l6ZSwgdHJ5IHRvIGNhbGN1bGF0ZSBpdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1IZWxwZXIjY29uZmlybURvd25sb2FkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtIFNDT1JNIHRvIGRvd25sb2FkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICBQcm9taXNlIHJlc29sdmVkIGlmIHRoZSB1c2VyIGNvbmZpcm1zIG9yIG5vIGNvbmZpcm1hdGlvbiBuZWVkZWQuXG4gICAgICovXG4gICAgc2VsZi5jb25maXJtRG93bmxvYWQgPSBmdW5jdGlvbihzY29ybSkge1xuICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgaWYgKCFzY29ybS5wYWNrYWdlc2l6ZSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBwYWNrYWdlIHNpemUsIHRyeSB0byBjYWxjdWxhdGUgaXQuXG4gICAgICAgICAgICBwcm9taXNlID0gJG1tYU1vZFNjb3JtLmNhbGN1bGF0ZVNjb3JtU2l6ZShzY29ybSkudGhlbihmdW5jdGlvbihzaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgaXQgc28gd2UgZG9uJ3QgaGF2ZSB0byBjYWxjdWxhdGUgaXQgYWdhaW4gd2hlbiB1c2luZyB0aGUgc2FtZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgc2Nvcm0ucGFja2FnZXNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihzY29ybS5wYWNrYWdlc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1VdGlsLmNvbmZpcm1Eb3dubG9hZFNpemUoc2l6ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBhdHRlbXB0IHRvIGNvbnRpbnVlL3Jldmlldy4gSXQgd2lsbCBiZTpcbiAgICAgKiAtIFRoZSBsYXN0IGluY29tcGxldGUgb25saW5lIGF0dGVtcHQgaWYgaXQgaGFzbid0IGJlZW4gY29udGludWVkIGluIG9mZmxpbmUgYW5kIGFsbCBvZmZsaW5lIGF0dGVtcHRzIGFyZSBjb21wbGV0ZS5cbiAgICAgKiAtIFRoZSBhdHRlbXB0IHdpdGggaGlnaGVzdCBudW1iZXIgd2l0aG91dCBzdXJwYXNzaW5nIG1heCBhdHRlbXB0cyBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtSGVscGVyI2RldGVybWluZUF0dGVtcHRUb0NvbnRpbnVlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29ybSAgICBTQ09STS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGF0dGVtcHRzIFJlc3VsdCBvZiAkbW1hTW9kU2Nvcm0jZ2V0QXR0ZW1wdENvdW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhbiBvYmplY3Qgd2l0aCAyIHByb3BlcnRpZXM6ICdudW1iZXInIGFuZCAnb2ZmbGluZScuXG4gICAgICovXG4gICAgc2VsZi5kZXRlcm1pbmVBdHRlbXB0VG9Db250aW51ZSA9IGZ1bmN0aW9uKHNjb3JtLCBhdHRlbXB0cywgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHZhciBsYXN0T25saW5lLFxuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMCxcbiAgICAgICAgICAgICAgICBvZmZsaW5lOiBmYWxzZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgdGhlIGxhc3QgYXR0ZW1wdC4gSXQnbGwgYmUgdGhlIGhpZ2hlc3QgbnVtYmVyIGFzIGxvbmcgYXMgaXQgZG9lc24ndCBzdXJwYXNzIHRoZSBtYXggbnVtYmVyIG9mIGF0dGVtcHRzLlxuICAgICAgICBmdW5jdGlvbiBnZXRMYXN0QmVmb3JlTWF4KCkge1xuICAgICAgICAgICAgaWYgKHNjb3JtLm1heGF0dGVtcHQgIT0gMCAmJiBhdHRlbXB0cy5sYXN0QXR0ZW1wdC5udW1iZXIgPiBzY29ybS5tYXhhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm51bWJlciA9IHNjb3JtLm1heGF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm9mZmxpbmUgPSBhdHRlbXB0cy5vZmZsaW5lLmluZGV4T2Yoc2Nvcm0ubWF4YXR0ZW1wdCkgPiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm51bWJlciA9IGF0dGVtcHRzLmxhc3RBdHRlbXB0Lm51bWJlcjtcbiAgICAgICAgICAgICAgICByZXN1bHQub2ZmbGluZSA9IGF0dGVtcHRzLmxhc3RBdHRlbXB0Lm9mZmxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgbGFzdCBvbmxpbmUgYXR0ZW1wdC5cbiAgICAgICAgaWYgKGF0dGVtcHRzLm9ubGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxhc3RPbmxpbmUgPSBNYXRoLm1heC5hcHBseShNYXRoLCBhdHRlbXB0cy5vbmxpbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RPbmxpbmUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGxhc3Qgb25saW5lIGluY29tcGxldGUuXG4gICAgICAgICAgICB2YXIgaGFzT2ZmbGluZSA9IGF0dGVtcHRzLm9mZmxpbmUuaW5kZXhPZihsYXN0T25saW5lKSA+IC0xO1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5pc0F0dGVtcHRJbmNvbXBsZXRlKHNjb3JtLmlkLCBsYXN0T25saW5lLCBoYXNPZmZsaW5lLCBmYWxzZSwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGluY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubnVtYmVyID0gbGFzdE9ubGluZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm9mZmxpbmUgPSBoYXNPZmZsaW5lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldExhc3RCZWZvcmVNYXgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0TGFzdEJlZm9yZU1heCgpO1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4ocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpcnN0IFNDTyB0byBsb2FkIGluIGEgU0NPUk0uIElmIGEgbm9uLWVtcHR5IFRPQyBpcyBwcm92aWRlZCwgaXQgd2lsbCBiZSB0aGUgZmlyc3QgdmFsaWQgU0NPIGluIHRoZSBUT0MuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIHRoZSBmaXJzdCB2YWxpZCBTQ08gcmV0dXJuZWQgYnkgJG1tYU1vZFNjb3JtI2dldFNjb3MuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtSGVscGVyI2dldEZpcnN0U2NvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNjb3JtSWQgICAgICAgIFNjb3JtIElELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IFt0b2NdICAgICAgICBTQ09STSdzIFRPQy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29yZ2FuaXphdGlvbl0gT3JnYW5pemF0aW9uIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCAgICAgICAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvZmZsaW5lICAgICAgIFRydWUgaWYgYXR0ZW1wdCBpcyBvZmZsaW5lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdICAgICAgIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgZmlyc3QgU0NPLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0Rmlyc3RTY28gPSBmdW5jdGlvbihzY29ybUlkLCB0b2MsIG9yZ2FuaXphdGlvbiwgYXR0ZW1wdCwgb2ZmbGluZSwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICBpZiAodG9jICYmIHRvYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKHRvYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTQ09STSBkb2Vzbid0IGhhdmUgYSBUT0MuIEdldCBhbGwgdGhlIHNjb3MuXG4gICAgICAgICAgICBwcm9taXNlID0gJG1tYU1vZFNjb3JtLmdldFNjb3NXaXRoRGF0YShzY29ybUlkLCBvcmdhbml6YXRpb24sIGF0dGVtcHQsIG9mZmxpbmUsIGZhbHNlLCBzaXRlSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihzY29zKSB7XG4gICAgICAgICAgICAvLyBTZWFyY2ggdGhlIGZpcnN0IHZhbGlkIFNDTy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Nvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzY28gPSBzY29zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzY28uaXN2aXNpYmxlICYmIHNjby5wcmVyZXEgJiYgc2NvLmxhdW5jaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgVE9DIGluIGFycmF5IGZvcm1hdCAoQHNlZSAkbW1hTW9kU2Nvcm0jZm9ybWF0VG9jVG9BcnJheSkgYW5kIGEgc2NvSWQsIHJldHVybiB0aGUgbmV4dCBhdmFpbGFibGUgU0NPLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybUhlbHBlciNnZXROZXh0U2NvRnJvbVRvY1xuICAgICAqIEBwYXJhbSAge09iamVjdFtdfSB0b2MgU0NPUk0ncyBUT0MuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29JZCBTQ08gSUQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBOZXh0IFNDTy5cbiAgICAgKi9cbiAgICBzZWxmLmdldE5leHRTY29Gcm9tVG9jID0gZnVuY3Rpb24odG9jLCBzY29JZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9jLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodG9jW2ldLmlkID09IHNjb0lkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgdGhlIGN1cnJlbnQgU0NPLiBOb3cgbGV0J3Mgc2VhcmNoIHRoZSBuZXh0IHZpc2libGUgU0NPIHdpdGggZnVsZmlsbGVkIHByZXJlcXVpc2l0ZXMuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvY1tqXS5pc3Zpc2libGUgJiYgdG9jW2pdLnByZXJlcSAmJiB0b2Nbal0ubGF1bmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9jW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgVE9DIGluIGFycmF5IGZvcm1hdCAoQHNlZSAkbW1hTW9kU2Nvcm0jZm9ybWF0VG9jVG9BcnJheSkgYW5kIGEgc2NvSWQsIHJldHVybiB0aGUgcHJldmlvdXMgYXZhaWxhYmxlIFNDTy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1IZWxwZXIjZ2V0UHJldmlvdXNTY29Gcm9tVG9jXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IHRvYyBTQ09STSdzIFRPQy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkIFNDTyBJRC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFByZXZpb3VzIFNDTy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFByZXZpb3VzU2NvRnJvbVRvYyA9IGZ1bmN0aW9uKHRvYywgc2NvSWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvYy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRvY1tpXS5pZCA9PSBzY29JZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHRoZSBjdXJyZW50IFNDTy4gTm93IGxldCdzIHNlYXJjaCB0aGUgcHJldmlvdXMgdmlzaWJsZSBTQ08gd2l0aCBmdWxmaWxsZWQgcHJlcmVxdWlzaXRlcy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2Nbal0uaXN2aXNpYmxlICYmIHRvY1tqXS5wcmVyZXEgJiYgdG9jW2pdLmxhdW5jaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvY1tqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIFRPQyBpbiBhcnJheSBmb3JtYXQgKEBzZWUgJG1tYU1vZFNjb3JtI2Zvcm1hdFRvY1RvQXJyYXkpIGFuZCBhIHNjb0lkLCByZXR1cm4gdGhlIFNDTy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1IZWxwZXIjZ2V0U2NvRnJvbVRvY1xuICAgICAqIEBwYXJhbSAge09iamVjdFtdfSB0b2MgU0NPUk0ncyBUT0MuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29JZCBTQ08gSUQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBTQ08uXG4gICAgICovXG4gICAgc2VsZi5nZXRTY29Gcm9tVG9jID0gZnVuY3Rpb24odG9jLCBzY29JZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9jLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodG9jW2ldLmlkID09IHNjb0lkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvY1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgU0NPUk0gc3luYyB0aW1lIGluIGEgaHVtYW4gcmVhZGFibGUgZm9ybWF0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybUhlbHBlciNnZXRTY29ybVJlYWRhYmxlU3luY1RpbWVcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgcmVhZGFibGUgdGltZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb3JtUmVhZGFibGVTeW5jVGltZSA9IGZ1bmN0aW9uKHNjb3JtSWQsIHNpdGVJZCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtU3luYy5nZXRTY29ybVN5bmNUaW1lKHNjb3JtSWQsIHNpdGVJZCkudGhlbihmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICBpZiAodGltZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUoJ21tLmNvcmUubm9uZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tZW50KHRpbWUpLmZvcm1hdCgnTExMJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB1c2VyIGRhdGEgZm9yIGFuIG9ubGluZSBhdHRlbXB0LiBJZiB0aGUgZGF0YSBjYW4ndCBiZSByZXRyaWV2ZWQsXG4gICAgICogcmUtdHJ5IHdpdGggdGhlIHByZXZpb3VzIG9ubGluZSBhdHRlbXB0IChpZiBleGlzdHMpLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybUhlbHBlciNzZWFyY2hPbmxpbmVBdHRlbXB0VXNlckRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgIE9ubGluZSBhdHRlbXB0IHRvIGdldCB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHVzZXIgZGF0YS5cbiAgICAgKi9cbiAgICBzZWxmLnNlYXJjaE9ubGluZUF0dGVtcHRVc2VyRGF0YSA9IGZ1bmN0aW9uKHNjb3JtSWQsIGF0dGVtcHQsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldFNjb3JtVXNlckRhdGEoc2Nvcm1JZCwgYXR0ZW1wdCwgZmFsc2UsIHNpdGVJZCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZG4ndCByZXRyaWV2ZSB0aGUgZGF0YS4gVHJ5IGFnYWluIHdpdGggdGhlIHByZXZpb3VzIG9ubGluZSBhdHRlbXB0LlxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNlYXJjaE9ubGluZUF0dGVtcHRVc2VyRGF0YShzY29ybUlkLCBhdHRlbXB0IC0gMSwgc2l0ZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbW9yZSBhdHRlbXB0cyB0byB0cnkuIFJlamVjdFxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3cgZXJyb3IgYmVjYXVzZSBhIFNDT1JNIGRvd25sb2FkIGZhaWxlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1IZWxwZXIjc2hvd0Rvd25sb2FkRXJyb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gU0NPUk0gZG93bmxvYWRlZC5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNlbGYuc2hvd0Rvd25sb2FkRXJyb3IgPSBmdW5jdGlvbihzY29ybSkge1xuICAgICAgICAkdHJhbnNsYXRlKCdtbWEubW9kX3Njb3JtLmVycm9yZG93bmxvYWRzY29ybScsIHtuYW1lOiBzY29ybS5uYW1lfSkudGhlbihmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9zY29ybScpXG5cbi8qKlxuICogTW9kIFNDT1JNIHByZWZldGNoIGhhbmRsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZFNjb3JtUHJlZmV0Y2hIYW5kbGVyXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kU2Nvcm1QcmVmZXRjaEhhbmRsZXInLCBmdW5jdGlvbigkbW1hTW9kU2Nvcm0sIG1tYU1vZFNjb3JtQ29tcG9uZW50KSB7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgc2VsZi5jb21wb25lbnQgPSBtbWFNb2RTY29ybUNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG93bmxvYWQgc2l6ZSBvZiBhIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1QcmVmZXRjaEhhbmRsZXIjZ2V0RG93bmxvYWRTaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSAgIE1vZHVsZSB0byBnZXQgdGhlIHNpemUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRCB0aGUgbW9kdWxlIGJlbG9uZ3MgdG8uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgc2l6ZS5cbiAgICAgKi9cbiAgICBzZWxmLmdldERvd25sb2FkU2l6ZSA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRTY29ybShjb3Vyc2VpZCwgbW9kdWxlLmlkLCBtb2R1bGUudXJsKS50aGVuKGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgICAgICBpZiAoJG1tYU1vZFNjb3JtLmlzU2Nvcm1TdXBwb3J0ZWQoc2Nvcm0pICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzY29ybS5wYWNrYWdlc2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgcGFja2FnZSBzaXplLCB0cnkgdG8gY2FsY3VsYXRlIGl0LlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uY2FsY3VsYXRlU2Nvcm1TaXplKHNjb3JtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3JtLnBhY2thZ2VzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGRvd25sb2FkYWJsZSBmaWxlcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1QcmVmZXRjaEhhbmRsZXIjZ2V0RmlsZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlICAgTW9kdWxlIHRvIGdldCB0aGUgZmlsZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRCB0aGUgbW9kdWxlIGJlbG9uZ3MgdG8uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBTaXplLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0RmlsZXMgPSBmdW5jdGlvbihtb2R1bGUsIGNvdXJzZWlkKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm0oY291cnNlaWQsIG1vZHVsZS5pZCwgbW9kdWxlLnVybCkudGhlbihmdW5jdGlvbihzY29ybSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRTY29ybUZpbGVMaXN0KHNjb3JtKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBTQ09STSBub3QgZm91bmQsIHJldHVybiBlbXB0eSBsaXN0LlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHJldmlzaW9uIG9mIGEgU0NPUk0gKHNoYTFoYXNoKS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1QcmVmZXRjaEhhbmRsZXIjZ2V0UmV2aXNpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlICAgTW9kdWxlIHRvIGdldCB0aGUgcmV2aXNpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRCB0aGUgbW9kdWxlIGJlbG9uZ3MgdG8uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgIFRpbWVtb2RpZmllZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFJldmlzaW9uID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmdldFNjb3JtKGNvdXJzZWlkLCBtb2R1bGUuaWQsIG1vZHVsZS51cmwpLnRoZW4oZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBzY29ybS5zaGExaGFzaDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aW1lbW9kaWZpZWQgb2YgYSBTQ09STS4gSXQgYWx3YXlzIHJldHVybiAwLCB3ZSBkb24ndCB1c2UgdGltZW1vZGlmaWVkIGZvciBTQ09STSBwYWNrYWdlcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1QcmVmZXRjaEhhbmRsZXIjZ2V0VGltZW1vZGlmaWVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSAgIE1vZHVsZSB0byBnZXQgdGhlIHRpbWVtb2RpZmllZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElEIHRoZSBtb2R1bGUgYmVsb25ncyB0by5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgVGltZW1vZGlmaWVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0VGltZW1vZGlmaWVkID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1QcmVmZXRjaEhhbmRsZXIjaXNFbmFibGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmlzUGx1Z2luRW5hYmxlZCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaCB0aGUgbW9kdWxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybVByZWZldGNoSGFuZGxlciNwcmVmZXRjaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgICBUaGUgbW9kdWxlIG9iamVjdCByZXR1cm5lZCBieSBXUy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElEIHRoZSBtb2R1bGUgYmVsb25ncyB0by5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCBmaWxlcyBoYXZlIGJlZW4gZG93bmxvYWRlZC4gRGF0YSByZXR1cm5lZCBpcyBub3QgcmVsaWFibGUuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaCA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRTY29ybShjb3Vyc2VpZCwgbW9kdWxlLmlkLCBtb2R1bGUudXJsKS50aGVuKGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLnByZWZldGNoKHNjb3JtKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2Rfc2Nvcm0nKVxuXG4vKipcbiAqIFNDT1JNIHNlcnZpY2UuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZFNjb3JtXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kU2Nvcm0nLCBmdW5jdGlvbigkbW1TaXRlLCAkcSwgJHRyYW5zbGF0ZSwgJG1tTGFuZywgJG1tRmlsZXBvb2wsICRtbUZTLCAkbW1XUywgJHNjZSwgJG1tYU1vZFNjb3JtT25saW5lLCAkc3RhdGUsXG4gICAgICAgICAgICAkbW1hTW9kU2Nvcm1PZmZsaW5lLCAkbW1VdGlsLCAkbG9nLCAkbW1TaXRlc01hbmFnZXIsIG1tYU1vZFNjb3JtQ29tcG9uZW50LCBtbUNvcmVOb3REb3dubG9hZGVkKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFNb2RTY29ybScpO1xuXG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgc3RhdHVzZXMgPSBbJ25vdGF0dGVtcHRlZCcsICdwYXNzZWQnLCAnY29tcGxldGVkJywgJ2ZhaWxlZCcsICdpbmNvbXBsZXRlJywgJ2Jyb3dzZWQnLCAnc3VzcGVuZCddLFxuICAgICAgICBkb3dubG9hZFByb21pc2VzID0ge307IC8vIFN0b3JlIGRvd25sb2FkIHByb21pc2VzIHRvIGJlIGFibGUgdG8gcmVzdG9yZSB0aGVtLlxuXG4gICAgLy8gQ29uc3RhbnRzLlxuICAgIHNlbGYuR1JBREVTQ09FUyAgICAgPSAwO1xuICAgIHNlbGYuR1JBREVISUdIRVNUICAgPSAxO1xuICAgIHNlbGYuR1JBREVBVkVSQUdFICAgPSAyO1xuICAgIHNlbGYuR1JBREVTVU0gICAgICAgPSAzO1xuXG4gICAgc2VsZi5ISUdIRVNUQVRURU1QVCA9IDA7XG4gICAgc2VsZi5BVkVSQUdFQVRURU1QVCA9IDE7XG4gICAgc2VsZi5GSVJTVEFUVEVNUFQgICA9IDI7XG4gICAgc2VsZi5MQVNUQVRURU1QVCAgICA9IDM7XG5cbiAgICBzZWxmLk1PREVCUk9XU0UgPSAnYnJvd3NlJztcbiAgICBzZWxmLk1PREVOT1JNQUwgPSAnbm9ybWFsJztcbiAgICBzZWxmLk1PREVSRVZJRVcgPSAncmV2aWV3JztcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIFNDT1JNIGdyYWRlIGJhc2VkIG9uIHRoZSBncmFkaW5nIG1ldGhvZCBhbmQgdGhlIGxpc3Qgb2YgYXR0ZW1wdHMgc2NvcmVzLlxuICAgICAqIFdlIG9ubHkgdHJlYXQgb25saW5lIGF0dGVtcHRzIHRvIGNhbGN1bGF0ZSBhIFNDT1JNIGdyYWRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNjYWxjdWxhdGVTY29ybUdyYWRlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29ybSAgICAgICAgICAgU0NPUk0uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvbmxpbmVBdHRlbXB0cyAgT25saW5lIGF0dGVtcHRzLiBFYWNoIGF0dGVtcHQgbXVzdCBoYXZlIGEgcHJvcGVydHkgY2FsbGVkIFwiZ3JhZGVcIi5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICBHcmFkZS4gLTEgaWYgbm8gZ3JhZGUuXG4gICAgICovXG4gICAgc2VsZi5jYWxjdWxhdGVTY29ybUdyYWRlID0gZnVuY3Rpb24oc2Nvcm0sIG9ubGluZUF0dGVtcHRzKSB7XG4gICAgICAgIGlmICghb25saW5lQXR0ZW1wdHMgfHzCoCFPYmplY3Qua2V5cyhvbmxpbmVBdHRlbXB0cykubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHNjb3JtLndoYXRncmFkZSkge1xuICAgICAgICAgICAgY2FzZSBzZWxmLkZJUlNUQVRURU1QVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gb25saW5lQXR0ZW1wdHNbMV0gPyBvbmxpbmVBdHRlbXB0c1sxXS5ncmFkZSA6IC0xO1xuICAgICAgICAgICAgY2FzZSBzZWxmLkxBU1RBVFRFTVBUOlxuICAgICAgICAgICAgICAgIHZhciBtYXggPSAwO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChPYmplY3Qua2V5cyhvbmxpbmVBdHRlbXB0cyksIGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChudW1iZXIsIG1heCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ubGluZUF0dGVtcHRzW21heF0uZ3JhZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5ISUdIRVNUQVRURU1QVDpcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGUgPSAwO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChvbmxpbmVBdHRlbXB0cywgZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgICAgICBncmFkZSA9IE1hdGgubWF4KGF0dGVtcHQuZ3JhZGUsIGdyYWRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JhZGU7XG4gICAgICAgICAgICBjYXNlIHNlbGYuQVZFUkFHRUFUVEVNUFQ6XG4gICAgICAgICAgICAgICAgdmFyIHN1bWdyYWRlcyA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsID0gMDtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gob25saW5lQXR0ZW1wdHMsIGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtZ3JhZGVzICs9IGF0dGVtcHQuZ3JhZGU7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoc3VtZ3JhZGVzIC8gdG90YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBzaXplIG9mIGEgU0NPUk0uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2NhbGN1bGF0ZVNjb3JtU2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSBTQ09STS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBTQ09STSBzaXplLlxuICAgICAqL1xuICAgIHNlbGYuY2FsY3VsYXRlU2Nvcm1TaXplID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgaWYgKHNjb3JtLnBhY2thZ2VzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihzY29ybS5wYWNrYWdlc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJG1tV1MuZ2V0UmVtb3RlRmlsZVNpemUoc2VsZi5nZXRQYWNrYWdlVXJsKHNjb3JtKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvdW50IHRoZSBhdHRlbXB0cyBsZWZ0IGZvciB0aGUgZ2l2ZW4gc2Nvcm0uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2NvdW50QXR0ZW1wdHNMZWZ0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtICAgICAgICAgU0NPUk0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHRzQ291bnQgTnVtYmVyIG9mIGF0dGVtcHRzIHBlcmZvcm1lZC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICBOdW1iZXIgb2YgYXR0ZW1wdHMgbGVmdC5cbiAgICAgKi9cbiAgICBzZWxmLmNvdW50QXR0ZW1wdHNMZWZ0ID0gZnVuY3Rpb24oc2Nvcm0sIGF0dGVtcHRzQ291bnQpIHtcbiAgICAgICAgaWYgKHNjb3JtLm1heGF0dGVtcHQgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7IC8vIFVubGltaXRlZCBhdHRlbXB0cy5cbiAgICAgICAgfVxuXG4gICAgICAgIGF0dGVtcHRzQ291bnQgPSBwYXJzZUludChhdHRlbXB0c0NvdW50LCAxMCk7XG4gICAgICAgIGlmIChpc05hTihhdHRlbXB0c0NvdW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29ybS5tYXhhdHRlbXB0IC0gYXR0ZW1wdHNDb3VudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kZSBhbmQgYXR0ZW1wdCBudW1iZXIgdG8gdXNlIGJhc2VkIG9uIG1vZGUgc2VsZWN0ZWQgYW5kIFNDT1JNIGRhdGEuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBNb29kbGUncyBzY29ybV9jaGVja19tb2RlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNkZXRlcm1pbmVBdHRlbXB0QW5kTW9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSAgICAgICBTQ09STS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSAgICAgICAgU2VsZWN0ZWQgbW9kZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCAgICAgQ3VycmVudCBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbmV3QXR0ZW1wdCBUcnVlIGlmIHNob3VsZCBzdGFydCBhIG5ldyBhdHRlbXB0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpbmNvbXBsZXRlIFRydWUgaWYgY3VycmVudCBhdHRlbXB0IGlzIGluY29tcGxldGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgT2JqZWN0IHdpdGggcHJvcGVydGllczogJ21vZGUnLCAnYXR0ZW1wdCcgYW5kICduZXdBdHRlbXB0Jy5cbiAgICAgKi9cbiAgICBzZWxmLmRldGVybWluZUF0dGVtcHRBbmRNb2RlID0gZnVuY3Rpb24oc2Nvcm0sIG1vZGUsIGF0dGVtcHQsIG5ld0F0dGVtcHQsIGluY29tcGxldGUpIHtcbiAgICAgICAgaWYgKG1vZGUgPT0gc2VsZi5NT0RFQlJPV1NFKSB7XG4gICAgICAgICAgICBpZiAoc2Nvcm0uaGlkZWJyb3dzZSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgQnJvd3NlIG1vZGUgaWYgaGlkZWJyb3dzZSBpcyBzZXQuXG4gICAgICAgICAgICAgICAgbW9kZSA9IHNlbGYuTU9ERU5PUk1BTDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBhdHRlbXB0cyBhcyBicm93c2UgbW9kZSBpcyBzZXQuXG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QXR0ZW1wdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdDogYXR0ZW1wdCxcbiAgICAgICAgICAgICAgICAgICAgbmV3QXR0ZW1wdDogbmV3QXR0ZW1wdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSB1c2VyIHJlcXVlc3QgdG8gc3RhcnQgYSBuZXcgYXR0ZW1wdC5cbiAgICAgICAgaWYgKGF0dGVtcHQgPT0gMCkge1xuICAgICAgICAgICAgbmV3QXR0ZW1wdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgLy8gVGhlIG9wdGlvbiB0byBzdGFydCBhIG5ldyBhdHRlbXB0IHNob3VsZCBuZXZlciBoYXZlIGJlZW4gcHJlc2VudGVkLiBGb3JjZSBmYWxzZS5cbiAgICAgICAgICAgIG5ld0F0dGVtcHQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzY29ybS5mb3JjZW5ld2F0dGVtcHQpIHtcbiAgICAgICAgICAgIC8vIEEgbmV3IGF0dGVtcHQgc2hvdWxkIGJlIGZvcmNlZCBmb3IgYWxyZWFkeSBjb21wbGV0ZWQgYXR0ZW1wdHMuXG4gICAgICAgICAgICBuZXdBdHRlbXB0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdBdHRlbXB0ICYmIChzY29ybS5tYXhhdHRlbXB0ID09IDAgfHwgYXR0ZW1wdCA8IHNjb3JtLm1heGF0dGVtcHQpKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgYXR0ZW1wdC4gRm9yY2UgbW9kZSBub3JtYWwuXG4gICAgICAgICAgICBhdHRlbXB0Kys7XG4gICAgICAgICAgICBtb2RlID0gc2VsZi5NT0RFTk9STUFMO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGluY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCByZXZpZXcgYW4gaW5jb21wbGV0ZSBhdHRlbXB0LlxuICAgICAgICAgICAgICAgIG1vZGUgPSBzZWxmLk1PREVOT1JNQUw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBzdGFydGluZyBhIG5ldyBhdHRlbXB0IGFuZCB0aGUgY3VycmVudCBvbmUgaXMgY29tcGxldGUsIGZvcmNlIHJldmlldyBtb2RlLlxuICAgICAgICAgICAgICAgIG1vZGUgPSBzZWxmLk1PREVSRVZJRVc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHQsXG4gICAgICAgICAgICBuZXdBdHRlbXB0OiBuZXdBdHRlbXB0XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIFRPQyBzaG91bGQgYmUgZGlzcGxheWVkIGluIHRoZSBwbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2Rpc3BsYXlUb2NJblBsYXllclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSBTQ09STS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSBpZiBzaG91bGQgZGlzcGxheSBUT0MsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmRpc3BsYXlUb2NJblBsYXllciA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgIHJldHVybiBzY29ybS5oaWRldG9jICE9PSAzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbmQgdW56aXBzIHRoZSBTQ09STSBwYWNrYWdlLlxuICAgICAqIEBzZWUgJG1tYU1vZFNjb3JtI19kb3dubG9hZE9yUHJlZmV0Y2hcbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZG93bmxvYWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gU0NPUk0gb2JqZWN0IHJldHVybmVkIGJ5ICRtbWFNb2RTY29ybSNnZXRTY29ybS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBwYWNrYWdlIGlzIGRvd25sb2FkZWQgYW5kIHVuemlwcGVkLlxuICAgICAqL1xuICAgIHNlbGYuZG93bmxvYWQgPSBmdW5jdGlvbihzY29ybSkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZG93bmxvYWRPclByZWZldGNoKHNjb3JtLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvd25sb2Fkcy9QcmVmZXRjaGVzIGFuZCB1bnppcHMgdGhlIFNDT1JNIHBhY2thZ2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI19kb3dubG9hZE9yUHJlZmV0Y2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gICAgIFNDT1JNIG9iamVjdCByZXR1cm5lZCBieSAkbW1hTW9kU2Nvcm0jZ2V0U2Nvcm0uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXRjaCBUcnVlIGlmIHByZWZldGNoLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHBhY2thZ2UgaXMgZG93bmxvYWRlZCBhbmQgdW56aXBwZWQuIEl0IHdpbGwgY2FsbCBub3RpZnkgaW4gdGhlc2UgY2FzZXM6XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1GaWxlIGRvd25sb2FkIGluIHByb2dyZXNzLiBOb3RpZnkgb2JqZWN0IHdpbGwgaGF2ZSB0aGVzZSBwcm9wZXJ0aWVzOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZURvd25sb2FkIHtCb29sZWFufSBBbHdheXMgdHJ1ZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZCB7TnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgb2YgdGhlIHBhY2thZ2UgbG9hZGVkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVByb2dyZXNzIHtPYmplY3R9IEZpbGVUcmFuc2ZlcidzIG5vdGlmeSBwYXJhbSBmb3IgdGhlIGN1cnJlbnQgZmlsZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLURvd25sb2FkIG9yIHVuemlwIHN0YXJ0aW5nLiBOb3RpZnkgb2JqZWN0IHdpbGwgaGF2ZSB0aGVzZSBwcm9wZXJ0aWVzOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSB7U3RyaW5nfSBNZXNzYWdlIGNvZGUgcmVsYXRlZCB0byB0aGUgc3RhcnRpbmcgb3BlcmF0aW9uLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtRmlsZSB1bnppcCBpbiBwcm9ncmVzcy4gTm90aWZ5IG9iamVjdCB3aWxsIGhhdmUgdGhlc2UgcHJvcGVydGllczpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZCB7TnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgdW56aXBwZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCB7TnVtYmVyfSBUb3RhbCBvZiBieXRlcyBvZiB0aGUgWklQIGZpbGUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX2Rvd25sb2FkT3JQcmVmZXRjaCA9IGZ1bmN0aW9uKHNjb3JtLCBwcmVmZXRjaCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2VsZi5pc1Njb3JtU3VwcG9ydGVkKHNjb3JtKSxcbiAgICAgICAgICAgIHNpdGVJZCA9ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbUxhbmcudHJhbnNsYXRlQW5kUmVqZWN0KHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG93bmxvYWRQcm9taXNlc1tzaXRlSWRdICYmIGRvd25sb2FkUHJvbWlzZXNbc2l0ZUlkXVtzY29ybS5pZF0pIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIGRvd25sb2FkIG9uZ29pbmcgZm9yIHRoaXMgcGFja2FnZSwgcmV0dXJuIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgcmV0dXJuIGRvd25sb2FkUHJvbWlzZXNbc2l0ZUlkXVtzY29ybS5pZF07XG4gICAgICAgIH0gZWxzZSBpZiAoIWRvd25sb2FkUHJvbWlzZXNbc2l0ZUlkXSkge1xuICAgICAgICAgICAgZG93bmxvYWRQcm9taXNlc1tzaXRlSWRdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsZXMgPSBzZWxmLmdldFNjb3JtRmlsZUxpc3Qoc2Nvcm0pLFxuICAgICAgICAgICAgcmV2aXNpb24gPSBzY29ybS5zaGExaGFzaCwgLy8gV2UgdXNlIHNoYTFoYXNoIGluc3RlYWQgb2YgcmV2aXNpb24gbnVtYmVyLlxuICAgICAgICAgICAgZGlyUGF0aCxcbiAgICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKSwgLy8gV2UgdXNlIGEgZGVmZXJyZWQgdG8gYmUgYWJsZSB0byBub3RpZnkuXG4gICAgICAgICAgICBmbiA9IHByZWZldGNoID8gJG1tRmlsZXBvb2wucHJlZmV0Y2hQYWNrYWdlIDogJG1tRmlsZXBvb2wuZG93bmxvYWRQYWNrYWdlO1xuXG4gICAgICAgIGRvd25sb2FkUHJvbWlzZXNbc2l0ZUlkXVtzY29ybS5pZF0gPSBkZWZlcnJlZC5wcm9taXNlOyAvLyBTdG9yZSBwcm9taXNlIHRvIGJlIGFibGUgdG8gcmVzdG9yZSBpdCBsYXRlci5cblxuICAgICAgICAvLyBHZXQgdGhlIGZvbGRlciB3aGVyZSB0aGUgdW56aXBwZWQgZmlsZXMgd2lsbCBiZS5cbiAgICAgICAgc2VsZi5nZXRTY29ybUZvbGRlcihzY29ybS5tb2R1bGV1cmwpLnRoZW4oZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgZGlyUGF0aCA9IHBhdGg7XG4gICAgICAgICAgICAvLyBEb3dubG9hZCB0aGUgWklQIGZpbGUgdG8gdGhlIGZpbGVwb29sLlxuICAgICAgICAgICAgLy8gVXNpbmcgdW5kZWZpbmVkIGZvciBzdWNjZXNzICYgZmFpbCB3aWxsIHBhc3MgdGhlIHN1Y2Nlc3MvZmFpbHVyZSB0byB0aGUgcGFyZW50IHByb21pc2UuXG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoe21lc3NhZ2U6ICdtbS5jb3JlLmRvd25sb2FkaW5nJ30pO1xuICAgICAgICAgICAgcmV0dXJuIGZuKHNpdGVJZCwgZmlsZXMsIG1tYU1vZFNjb3JtQ29tcG9uZW50LCBzY29ybS5jb3Vyc2Vtb2R1bGUsIHJldmlzaW9uLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbih1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZGVzdGluYXRpb24gZm9sZGVyIHRvIHByZXZlbnQgaGF2aW5nIG9sZCB1bnVzZWQgZmlsZXMuXG4gICAgICAgICAgICByZXR1cm4gJG1tRlMucmVtb3ZlRGlyKGRpclBhdGgpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMsIGl0IG1pZ2h0IGhhdmUgZmFpbGVkIGJlY2F1c2UgdGhlIGZvbGRlciBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIFpJUCBmaWxlIHBhdGguXG4gICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZ2V0RmlsZVBhdGhCeVVybChzaXRlSWQsIHNlbGYuZ2V0UGFja2FnZVVybChzY29ybSkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHppcHBhdGgpIHtcbiAgICAgICAgICAgIC8vIFVuemlwIGFuZCBkZWxldGUgdGhlIHppcCB3aGVuIGZpbmlzaGVkLlxuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHttZXNzYWdlOiAnbW0uY29yZS51bnppcHBpbmcnfSk7XG4gICAgICAgICAgICByZXR1cm4gJG1tRlMudW56aXBGaWxlKHppcHBhdGgsIGRpclBhdGgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLnJlbW92ZUZpbGVCeVVybChzaXRlSWQsIHNlbGYuZ2V0UGFja2FnZVVybChzY29ybSkpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzLlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciB1bnppcHBpbmcuIFNldCBzdGF0dXMgYXMgbm90IGRvd25sb2FkZWQgYW5kIHJlamVjdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuc3RvcmVQYWNrYWdlU3RhdHVzKHNpdGVJZCwgbW1hTW9kU2Nvcm1Db21wb25lbnQsIHNjb3JtLmNvdXJzZW1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW1Db3JlTm90RG93bmxvYWRlZCwgcmV2aXNpb24sIDApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICAgICAgfSkudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWxldGUgZG93bmxvYWRQcm9taXNlc1tzaXRlSWRdW3Njb3JtLmlkXTsgLy8gRGVsZXRlIHN0b3JlZCBwcm9taXNlLlxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGxpdHRsZSBsYW5ndWFnZSBwYXJzZXIgZm9yIEFJQ0NfU0NSSVBULlxuICAgICAqIEV2YWx1YXRlcyB0aGUgZXhwcmVzc2lvbiBhbmQgcmV0dXJucyBhIGJvb2xlYW4gYW5zd2VyLlxuICAgICAqIFNlZSAyLjMuMi41LjEuIFNlcXVlbmNpbmcvTmF2aWdhdGlvbiBUb2RheSAgLSBmcm9tIHRoZSBTQ09STSAxLjIgc3BlYyAoQ0FNKS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZXZhbFByZXJlcXVpc2l0ZXNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHByZXJlcXVpc2l0ZXMgVGhlIEFJQ0NfU0NSSVBUIHByZXJlcXVpc2l0ZXMgZXhwcmVzc2lvbi5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRyYWNrRGF0YSAgICAgVGhlIHRyYWNrZWQgdXNlciBkYXRhIG9mIGVhY2ggU0NPLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICBUcnVlIGlmIHByZXJlcXVpc2l0ZXMgYXJlIGZ1bGZpbGxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuZXZhbFByZXJlcXVpc2l0ZXMgPSBmdW5jdGlvbihwcmVyZXF1aXNpdGVzLCB0cmFja0RhdGEpIHtcblxuICAgICAgICB2YXIgc3RhY2sgPSBbXSxcbiAgICAgICAgICAgIHN0YXR1c2VzID0ge1xuICAgICAgICAgICAgICAgICdwYXNzZWQnOiAncGFzc2VkJyxcbiAgICAgICAgICAgICAgICAnY29tcGxldGVkJzogJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgJ2ZhaWxlZCc6ICdmYWlsZWQnLFxuICAgICAgICAgICAgICAgICdpbmNvbXBsZXRlJzogJ2luY29tcGxldGUnLFxuICAgICAgICAgICAgICAgICdicm93c2VkJzogJ2Jyb3dzZWQnLFxuICAgICAgICAgICAgICAgICdub3QgYXR0ZW1wdGVkJzogJ25vdGF0dGVtcHRlZCcsXG4gICAgICAgICAgICAgICAgJ3AnOiAncGFzc2VkJyxcbiAgICAgICAgICAgICAgICAnYyc6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgICAgICAgICdmJzogJ2ZhaWxlZCcsXG4gICAgICAgICAgICAgICAgJ2knOiAnaW5jb21wbGV0ZScsXG4gICAgICAgICAgICAgICAgJ2InOiAnYnJvd3NlZCcsXG4gICAgICAgICAgICAgICAgJ24nOiAnbm90YXR0ZW1wdGVkJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBFeHBhbmQgdGhlIGFtcCBlbnRpdGllcy5cbiAgICAgICAgcHJlcmVxdWlzaXRlcyA9IHByZXJlcXVpc2l0ZXMucmVwbGFjZSgvJmFtcDsvZ2ksICcmJyk7XG4gICAgICAgIC8vIEZpbmQgYWxsIG15IHBhcnNhYmxlIHRva2Vucy5cbiAgICAgICAgcHJlcmVxdWlzaXRlcyA9IHByZXJlcXVpc2l0ZXMucmVwbGFjZSgvKCZ8XFx8fFxcKHxcXCl8XFx+KS9naSwgJ1xcdCQxXFx0Jyk7XG4gICAgICAgIC8vIEV4cGFuZCBvcGVyYXRvcnMuXG4gICAgICAgIHByZXJlcXVpc2l0ZXMgPSBwcmVyZXF1aXNpdGVzLnJlcGxhY2UoLyYvZ2ksICcmJicpO1xuICAgICAgICBwcmVyZXF1aXNpdGVzID0gcHJlcmVxdWlzaXRlcy5yZXBsYWNlKC9cXHwvZ2ksICd8fCcpO1xuICAgICAgICAvLyBOb3cgLSBncmFiIGFsbCB0aGUgdG9rZW5zLlxuICAgICAgICB2YXIgZWxlbWVudHMgPSBwcmVyZXF1aXNpdGVzLnRyaW0oKS5zcGxpdCgnXFx0Jyk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHRva2VuIHRvIGJ1aWxkIGFuIGV4cHJlc3Npb24gdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICBhbmd1bGFyLmZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZWxlbWVudC5tYXRjaCgvXigmJnxcXHxcXHx8XFwofFxcKSkkL2dpKSkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBlYWNoIGluZGl2aWR1YWwgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIH4gPSA8PiBYKnt9IC5cblxuICAgICAgICAgICAgICAgIHZhciByZSA9IC9eKFxcZCspXFwqXFx7KC4rKVxcfSQvLCAvLyBTZXRzIGxpa2UgMyp7UzM0LCBTMzYsIFMzNywgUzM5fS5cbiAgICAgICAgICAgICAgICAgICAgcmVPdGhlciA9IC9eKC4rKShcXD18XFw8XFw+KSguKykkLywgLy8gT3RoZXIgc3ltYm9scy5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcztcblxuICAgICAgICAgICAgICAgIGlmIChyZS50ZXN0KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBlbGVtZW50Lm1hdGNoKHJlKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVwZWF0ID0gbWF0Y2hlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCA9IG1hdGNoZXNbMl0uc3BsaXQoJywnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNldCwgZnVuY3Rpb24oc2V0ZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0ZWxlbWVudCA9IHNldGVsZW1lbnQudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFja0RhdGFbc2V0ZWxlbWVudF0gIT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRyYWNrRGF0YVtzZXRlbGVtZW50XS5zdGF0dXMgPT0gJ2NvbXBsZXRlZCcgfHwgdHJhY2tEYXRhW3NldGVsZW1lbnRdLnN0YXR1cyA9PSAncGFzc2VkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID49IHJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9ICd0cnVlJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAnZmFsc2UnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09ICd+Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgbWFwcyB+LlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gJyEnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVPdGhlci50ZXN0KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIHN5bWJvbHMgPSB8IDw+IC5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IGVsZW1lbnQubWF0Y2gocmVPdGhlcik7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBtYXRjaGVzWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFja0RhdGFbZWxlbWVudF0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hlc1szXS50cmltKCkucmVwbGFjZSgvKFxcJ3xcXFwiKS9naSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1c2VzW3ZhbHVlXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhdHVzZXNbdmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbMl0gPT0gJzw+Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXIgPSAnIT0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyID0gJz09JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAnKFxcJycgKyB0cmFja0RhdGFbZWxlbWVudF0uc3RhdHVzICsgJ1xcJyAnICsgb3BlciArICcgXFwnJyArIHZhbHVlICsgJ1xcJyknO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgbXVzdCBiZSBhbiBlbGVtZW50IGRlZmluZWQgbGlrZSBTNDUgLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhY2tEYXRhW2VsZW1lbnRdICE9ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRyYWNrRGF0YVtlbGVtZW50XS5zdGF0dXMgPT0gJ2NvbXBsZXRlZCcgfHwgdHJhY2tEYXRhW2VsZW1lbnRdLnN0YXR1cyA9PSAncGFzc2VkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gJ2ZhbHNlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sucHVzaCgnICcgKyBlbGVtZW50ICsgJyAnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGV2YWwoc3RhY2suam9pbignJykgKyAnOycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgZ3JhZGUgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNmb3JtYXRHcmFkZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2Nvcm0gU0NPUk0uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBncmFkZSBHcmFkZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIEdyYWRlIHRvIGRpc3BsYXkuXG4gICAgICovXG4gICAgc2VsZi5mb3JtYXRHcmFkZSA9IGZ1bmN0aW9uKHNjb3JtLCBncmFkZSkge1xuICAgICAgICBpZiAodHlwZW9mIGdyYWRlID09ICd1bmRlZmluZWQnIHx8IGdyYWRlID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbS5jb3JlLm5vbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nvcm0uZ3JhZGVtZXRob2QgIT09IHNlbGYuR1JBREVTQ09FUyAmJiBzY29ybS5tYXhncmFkZSA+IDApIHtcbiAgICAgICAgICAgIGdyYWRlID0gKGdyYWRlIC8gc2Nvcm0ubWF4Z3JhZGUpICogMTAwO1xuICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUuaW5zdGFudCgnbW0uY29yZS5wZXJjZW50YWdlbnVtYmVyJywgeyRhOiAkbW1VdGlsLnJvdW5kVG9EZWNpbWFscyhncmFkZSwgMil9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JhZGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSB0cmVlLWxpa2UgVE9DIGludG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2Zvcm1hdFRvY1RvQXJyYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB0b2MgICAgIFNDT1JNJ3MgVE9DICh0cmVlIGZvcm1hdCkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsZXZlbD0wXSBUaGUgbGV2ZWwgb2YgdGhlIFRPQyB3ZSdyZSByaWdodCBub3cuIDAgYnkgZGVmYXVsdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gICAgICAgIFNDT1JNJ3MgVE9DIChhcnJheSBmb3JtYXQpLlxuICAgICAqL1xuICAgIHNlbGYuZm9ybWF0VG9jVG9BcnJheSA9IGZ1bmN0aW9uKHRvYywgbGV2ZWwpIHtcbiAgICAgICAgaWYgKCF0b2MgfHzCoCF0b2MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsZXZlbCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9ybWF0dGVkID0gW107XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh0b2MsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgIGZvcm1hdHRlZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLmNvbmNhdChzZWxmLmZvcm1hdFRvY1RvQXJyYXkobm9kZS5jaGlsZHJlbiwgbGV2ZWwgKyAxKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzIGRvbmUgYnkgYSB1c2VyIGluIHRoZSBnaXZlbiBTQ09STS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZ2V0QXR0ZW1wdENvdW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgICAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSAgICAgICBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSAgICAgICBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZU1pc3NpbmcgVHJ1ZSBpZiBpdCBzaG91bGQgaWdub3JlIGF0dGVtcHRzIHdpdGhvdXQgZ3JhZGUvY29tcGxldGlvbi4gT25seSBmb3Igb25saW5lIGF0dGVtcHRzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgICBUcnVlIGlmIGl0IHNob3VsZCBpZ25vcmUgY2FjaGVkIGRhdGEgZm9yIG9ubGluZSBhdHRlbXB0cy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBhdHRlbXB0IGNvdW50IGlzIHJldHJpZXZlZC4gSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmxpbmUgYXR0ZW1wdHMsIG9mZmxpbmUgYXR0ZW1wdHMsIHRvdGFsIG51bWJlciBvZiBhdHRlbXB0cyBhbmQgbGFzdCBhdHRlbXB0LlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QXR0ZW1wdENvdW50ID0gZnVuY3Rpb24oc2Nvcm1JZCwgc2l0ZUlkLCB1c2VySWQsIGlnbm9yZU1pc3NpbmcsIGlnbm9yZUNhY2hlKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgc2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEF0dGVtcHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZmxpbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtT25saW5lLmdldEF0dGVtcHRDb3VudChzaXRlSWQsIHNjb3JtSWQsIHVzZXJJZCwgaWdub3JlTWlzc2luZywgaWdub3JlQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihjb3VudCkge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXJzIG9mIG9ubGluZSBhdHRlbXB0cy5cbiAgICAgICAgICAgICAgICByZXN1bHQub25saW5lID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQub25saW5lLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBsYXN0IGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gcmVzdWx0Lmxhc3RBdHRlbXB0Lm51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubGFzdEF0dGVtcHQubnVtYmVyID0gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5sYXN0QXR0ZW1wdC5vZmZsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RTY29ybU9mZmxpbmUuZ2V0QXR0ZW1wdHMoc2l0ZUlkLCBzY29ybUlkLCB1c2VySWQpLnRoZW4oZnVuY3Rpb24oYXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgb25seSBhdHRlbXB0IG51bWJlcnMuXG4gICAgICAgICAgICAgICAgcmVzdWx0Lm9mZmxpbmUgPSBhdHRlbXB0cy5tYXAoZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGxhc3QgYXR0ZW1wdC4gV2UgdXNlID49IHRvIHByaW9yaXRpemUgb2ZmbGluZSBldmVudHMgaWYgYW4gYXR0ZW1wdCBpcyBib3RoIG9ubGluZSBhbmQgb2ZmbGluZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmF0dGVtcHQgPj0gcmVzdWx0Lmxhc3RBdHRlbXB0Lm51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmxhc3RBdHRlbXB0Lm51bWJlciA9IGVudHJ5LmF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGFzdEF0dGVtcHQub2ZmbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gcmVzdWx0Lm9ubGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm9mZmxpbmUuZm9yRWFjaChmdW5jdGlvbihhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgYXR0ZW1wdCBhbHNvIGV4aXN0cyBpbiBvbmxpbmUsIGl0IG1pZ2h0IGhhdmUgYmVlbiBjb3BpZWQgdG8gbG9jYWwuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQub25saW5lLmluZGV4T2YoYXR0ZW1wdCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQudG90YWwgPSB0b3RhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGdyYWRlIGZvciBhIGNlcnRhaW4gU0NPUk0gYW5kIGF0dGVtcHQuXG4gICAgICogQmFzZWQgb24gTW9vZGxlJ3Mgc2Nvcm1fZ3JhZGVfdXNlcl9hdHRlbXB0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNnZXRBdHRlbXB0R3JhZGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1pZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2ZmbGluZSBUcnVlIGlmIGF0dGVtcHQgaXMgb2ZmbGluZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGdyYWRlLiBJZiB0aGUgYXR0ZW1wdCBoYXNuJ3QgcmVwb3J0ZWQgZ3JhZGUvY29tcGxldGlvbiwgZ3JhZGUgd2lsbCBiZSAtMS5cbiAgICAgKi9cbiAgICBzZWxmLmdldEF0dGVtcHRHcmFkZSA9IGZ1bmN0aW9uKHNjb3JtLCBhdHRlbXB0LCBvZmZsaW5lLCBzaXRlSWQpIHtcbiAgICAgICAgdmFyIGF0dGVtcHRzY29yZSA9IHtcbiAgICAgICAgICAgIHNjb3M6IDAsXG4gICAgICAgICAgICB2YWx1ZXM6IDAsXG4gICAgICAgICAgICBtYXg6IDAsXG4gICAgICAgICAgICBzdW06IDBcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZi5nZXRTY29ybVVzZXJEYXRhKHNjb3JtLmlkLCBhdHRlbXB0LCBvZmZsaW5lLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRhdGEsIGZ1bmN0aW9uKHNjb2RhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXNlcmRhdGEgPSBzY29kYXRhLnVzZXJkYXRhO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyZGF0YS5zdGF0dXMgPT0gJ2NvbXBsZXRlZCcgfHwgdXNlcmRhdGEuc3RhdHVzID09ICdwYXNzZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzY29yZS5zY29zKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJkYXRhLnNjb3JlX3JhdyB8fCAodHlwZW9mIHNjb3JtLnNjb3JtdHlwZSAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JtLnNjb3JtdHlwZSA9PSAnc2NvJyAmJiB0eXBlb2YgdXNlcmRhdGEuc2NvcmVfcmF3ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcmVyYXcgPSBwYXJzZUZsb2F0KHVzZXJkYXRhLnNjb3JlX3Jhdyk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzY29yZS52YWx1ZXMrKztcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHNjb3JlLnN1bSArPSBzY29yZXJhdztcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHNjb3JlLm1heCA9IE1hdGgubWF4KHNjb3JlcmF3LCBhdHRlbXB0c2NvcmUubWF4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHNjb3JlID0gMDtcbiAgICAgICAgICAgIHN3aXRjaCAoc2Nvcm0uZ3JhZGVtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHNlbGYuR1JBREVISUdIRVNUOlxuICAgICAgICAgICAgICAgICAgICBzY29yZSA9IGF0dGVtcHRzY29yZS5tYXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZWxmLkdSQURFQVZFUkFHRTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHRzY29yZS52YWx1ZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29yZSA9IGF0dGVtcHRzY29yZS5zdW0gLyBhdHRlbXB0c2NvcmUudmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZWxmLkdSQURFU1VNOlxuICAgICAgICAgICAgICAgICAgICBzY29yZSA9IGF0dGVtcHRzY29yZS5zdW07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZWxmLkdSQURFU0NPRVM6XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlID0gYXR0ZW1wdHNjb3JlLnNjb3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgPSBhdHRlbXB0c2NvcmUubWF4OyAgIC8vIFJlbW90ZSBMZWFybmVyIEdSQURFSElHSEVTVCBpcyBkZWZhdWx0LlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2NvcmU7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgYSBvcmdhbml6YXRpb25zIGRlZmluZWQgaW4gYSBTQ09STSBwYWNrYWdlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNnZXRPcmdhbml6YXRpb25zXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29ybUlkIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2Ygb3JnYW5pemF0aW9ucy5cbiAgICAgKi9cbiAgICBzZWxmLmdldE9yZ2FuaXphdGlvbnMgPSBmdW5jdGlvbihzY29ybUlkLCBzaXRlSWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2NvcyhzY29ybUlkLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2Nvcykge1xuICAgICAgICAgICAgdmFyIG9yZ2FuaXphdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY29zLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICAvLyBJcyBhbiBvcmdhbml6YXRpb24gZW50cnk/XG4gICAgICAgICAgICAgICAgaWYgKHNjby5vcmdhbml6YXRpb24gPT0gJycgJiYgc2NvLnBhcmVudCA9PSAnLycgJiYgc2NvLnNjb3JtdHlwZSA9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBvcmdhbml6YXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogc2NvLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogc2NvLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydG9yZGVyOiBzY28uc29ydG9yZGVyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9yZ2FuaXphdGlvbnM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG9yZ2FuaXphdGlvbiBUb2Mgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldE9yZ2FuaXphdGlvblRvY1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gb3JnYW5pemF0aW9uIE9yZ2FuaXphdGlvbiBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCAgICAgIFRoZSBhdHRlbXB0IG51bWJlciAodG8gcG9wdWxhdGUgU0NPIHRyYWNrIGRhdGEpLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2ZmbGluZSAgICAgIFRydWUgaWYgYXR0ZW1wdCBpcyBvZmZsaW5lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdICAgICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHRvYyBvYmplY3QuXG4gICAgICovXG4gICAgc2VsZi5nZXRPcmdhbml6YXRpb25Ub2MgPSBmdW5jdGlvbihzY29ybUlkLCBvcmdhbml6YXRpb24sIGF0dGVtcHQsIG9mZmxpbmUsIHNpdGVJZCkge1xuXG4gICAgICAgIHJldHVybiBzZWxmLmdldFNjb3NXaXRoRGF0YShzY29ybUlkLCBvcmdhbml6YXRpb24sIGF0dGVtcHQsIG9mZmxpbmUsIGZhbHNlLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2Nvcykge1xuICAgICAgICAgICAgdmFyIG1hcCA9IHt9LFxuICAgICAgICAgICAgICAgIHJvb3RTY29zID0gW107XG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY29zLCBmdW5jdGlvbihzY28sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgc2NvLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgbWFwW3Njby5pZGVudGlmaWVyXSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChzY28ucGFyZW50ICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjby5wYXJlbnQgPT0gb3JnYW5pemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIGEgcm9vdCBTQ08sIGFkZCBpdCB0byB0aGUgcm9vdCBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RTY29zLnB1c2goc2NvKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIHNjbyB0byB0aGUgcGFyZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nvc1ttYXBbc2NvLnBhcmVudF1dLmNoaWxkcmVuLnB1c2goc2NvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcm9vdFNjb3M7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhY2thZ2UgVVJMIG9mIGEgZ2l2ZW4gU0NPUk0uXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldFBhY2thZ2VVcmxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtIFNDT1JNLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgUGFja2FnZSBVUkwuXG4gICAgICovXG4gICAgc2VsZi5nZXRQYWNrYWdlVXJsID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgaWYgKHNjb3JtLnBhY2thZ2V1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29ybS5wYWNrYWdldXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY29ybS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29ybS5yZWZlcmVuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVzZXIgZGF0YSBmb3IgYSBjZXJ0YWluIFNDT1JNIGFuZCBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNnZXRTY29ybVVzZXJEYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgICAgICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCAgICAgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2ZmbGluZSAgICAgVHJ1ZSBpZiBhdHRlbXB0IGlzIG9mZmxpbmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gICAgIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gW3Njb3NdICAgICBTQ09zIHJldHVybmVkIGJ5ICRtbWFNb2RTY29ybSNnZXRTY29zLiBSZWNvbW1lbmRlZCBpZiBvZmZsaW5lPXRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBUcnVlIGlmIGl0IHNob3VsZCBpZ25vcmUgY2FjaGVkIGRhdGEgZm9yIG9ubGluZSBhdHRlbXB0cy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgdXNlciBkYXRhIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb3JtVXNlckRhdGEgPSBmdW5jdGlvbihzY29ybUlkLCBhdHRlbXB0LCBvZmZsaW5lLCBzaXRlSWQsIHNjb3MsIGlnbm9yZUNhY2hlKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIGlmIChvZmZsaW5lKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHNjb3MgPyAkcS53aGVuKHNjb3MpIDogc2VsZi5nZXRTY29zKHNjb3JtSWQsIHNpdGVJZCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNjb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5nZXRTY29ybVVzZXJEYXRhKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdW5kZWZpbmVkLCBzY29zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9ubGluZS5nZXRTY29ybVVzZXJEYXRhKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgaWdub3JlQ2FjaGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIGdldCBTQ09STSBzY29zIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29ybUlkIFNDT1JNIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2Nvc0NhY2hlS2V5KHNjb3JtSWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RTY29ybTpzY29zOicgKyBzY29ybUlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBTQ08gb2JqZWN0cyBmb3IgYSBnaXZlbiBTQ09STSBhbmQgb3JnYW5pemF0aW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNnZXRTY29zXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29ybUlkICAgICAgICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdICAgICAgIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbb3JnYW5pemF0aW9uXSBPcmdhbml6YXRpb24gSUQuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgICBUcnVlIGlmIGl0IHNob3VsZCBpZ25vcmUgY2FjaGVkIGRhdGEgKGl0IHdpbGwgYWx3YXlzIGZhaWwgaWYgb2ZmbGluZSBvciBzZXJ2ZXIgZG93bikuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggYSBsaXN0IG9mIFNDTyBvYmplY3RzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2NvcyA9IGZ1bmN0aW9uKHNjb3JtSWQsIHNpdGVJZCwgb3JnYW5pemF0aW9uLCBpZ25vcmVDYWNoZSkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgb3JnYW5pemF0aW9uID0gb3JnYW5pemF0aW9uIHx8ICcnO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBzZW5kIHRoZSBvcmdhbml6YXRpb24gdG8gdGhlIFdTLCB3ZSdsbCBmaWx0ZXIgdGhlbSBsb2NhbGx5LlxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2Nvcm1pZDogc2Nvcm1JZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldFNjb3NDYWNoZUtleShzY29ybUlkKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChpZ25vcmVDYWNoZSkge1xuICAgICAgICAgICAgICAgIHByZVNldHMuZ2V0RnJvbUNhY2hlID0gMDtcbiAgICAgICAgICAgICAgICBwcmVTZXRzLmVtZXJnZW5jeUNhY2hlID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNpdGUucmVhZCgnbW9kX3Njb3JtX2dldF9zY29ybV9zY29lcycsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5zY29lcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JnYW5pemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgU0NPcyBieSBvcmdhbml6YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzcG9uc2Uuc2NvZXMsIGZ1bmN0aW9uKHNjbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY28ub3JnYW5pemF0aW9uID09IG9yZ2FuaXphdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29zLnB1c2goc2NvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3MgPSByZXNwb25zZS5zY29lcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgU0NPIG9iamVjdHMgZm9yIGEgZ2l2ZW4gU0NPUk0gYW5kIG9yZ2FuaXphdGlvbiwgaW5jbHVkaW5nIGRhdGEgYWJvdXRcbiAgICAgKiBhIGNlcnRhaW4gYXR0ZW1wdCAoc3RhdHVzLCBpc3Zpc2libGUsIC4uLikuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldFNjb3NXaXRoRGF0YVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2Nvcm1JZCAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gb3JnYW5pemF0aW9uIE9yZ2FuaXphdGlvbiBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgICAgICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvZmZsaW5lICAgICBUcnVlIGlmIGF0dGVtcHQgaXMgb2ZmbGluZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlnbm9yZUNhY2hlIFRydWUgaWYgaXQgc2hvdWxkIGlnbm9yZSBjYWNoZWQgZGF0YSBmb3Igb25saW5lIGF0dGVtcHRzLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gICAgIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgbGlzdCBvZiBTQ08gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb3NXaXRoRGF0YSA9IGZ1bmN0aW9uKHNjb3JtSWQsIG9yZ2FuaXphdGlvbiwgYXR0ZW1wdCwgb2ZmbGluZSwgaWdub3JlQ2FjaGUsIHNpdGVJZCkge1xuICAgICAgICAvLyBHZXQgb3JnYW5pemF0aW9uIFNDT3MuXG4gICAgICAgIHJldHVybiBzZWxmLmdldFNjb3Moc2Nvcm1JZCwgc2l0ZUlkLCBvcmdhbml6YXRpb24sIGlnbm9yZUNhY2hlKS50aGVuKGZ1bmN0aW9uKHNjb3MpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdHJhY2sgZGF0YSBmb3IgYWxsIHRoZSBTQ09zIGluIHRoZSBvcmdhbml6YXRpb24gZm9yIHRoZSBnaXZlbiBhdHRlbXB0LlxuICAgICAgICAgICAgLy8gV2UnbGwgdXNlIHRoaXMgZGF0YSB0byBzZXQgU0NPIGRhdGEgbGlrZSBpc3Zpc2libGUsIHN0YXR1cyBhbmQgc28uXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTY29ybVVzZXJEYXRhKHNjb3JtSWQsIGF0dGVtcHQsIG9mZmxpbmUsIHNpdGVJZCwgc2NvcywgaWdub3JlQ2FjaGUpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrRGF0YUJ5U0NPID0ge307XG5cbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBwb3B1bGF0ZSB0cmFja0RhdGFCeVNDTyB0byBpbmRleCBieSBTQ08gaWRlbnRpZmllci5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NvcywgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrRGF0YUJ5U0NPW3Njby5pZGVudGlmaWVyXSA9IGRhdGFbc2NvLmlkXS51c2VyZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY29zLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHNwZWNpZmljIFNDTyBpbmZvcm1hdGlvbiAocmVsYXRlZCB0byB0cmFja2VkIGRhdGEpLlxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NvZGF0YSA9IGRhdGFbc2NvLmlkXS51c2VyZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaXN2aXNpYmxlIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAgICAgICAgc2NvLmlzdmlzaWJsZSA9IHR5cGVvZiBzY29kYXRhLmlzdmlzaWJsZSAhPSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb2RhdGEuaXN2aXNpYmxlICYmIHNjb2RhdGEuaXN2aXNpYmxlICE9PSAnZmFsc2UnIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcHJlLXJlcXVpc2l0ZXMgc3RhdHVzLlxuICAgICAgICAgICAgICAgICAgICBzY28ucHJlcmVxID0gdHlwZW9mIHNjb2RhdGEucHJlcmVxdWlzaXRlcyA9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmV2YWxQcmVyZXF1aXNpdGVzKHNjb2RhdGEucHJlcmVxdWlzaXRlcywgdHJhY2tEYXRhQnlTQ08pO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgc3RhdHVzLlxuICAgICAgICAgICAgICAgICAgICBzY28uc3RhdHVzID0gKHR5cGVvZiBzY29kYXRhLnN0YXR1cyA9PSAndW5kZWZpbmVkJ8KgfHwgc2NvZGF0YS5zdGF0dXMgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdub3RhdHRlbXB0ZWQnIDogc2NvZGF0YS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4aXQgdmFyLlxuICAgICAgICAgICAgICAgICAgICBzY28uZXhpdHZhciA9IHR5cGVvZiBzY29kYXRhLmV4aXR2YXIgPT0gJ3VuZGVmaW5lZCcgPyAnY21pLmNvcmUuZXhpdCcgOiBzY29kYXRhLmV4aXR2YXI7XG4gICAgICAgICAgICAgICAgICAgIHNjby5leGl0dmFsdWUgPSBzY29kYXRhW3Njby5leGl0dmFyXTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzY29zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIFNDT1JNIGFuZCBhIFNDTywgcmV0dXJucyB0aGUgZnVsbCBsYXVuY2ggVVJMIGZvciB0aGUgU0NPLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNnZXRTY29TcmNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtICAgU0NPUk0uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY28gICAgIFNDTy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBVUkwuXG4gICAgICovXG4gICAgc2VsZi5nZXRTY29TcmMgPSBmdW5jdGlvbihzY29ybSwgc2NvLCBzaXRlSWQpIHtcbiAgICAgICAgaWYgKHNjby5sYXVuY2gubWF0Y2goL2h0dHAocyk/OlxcL1xcLy8pKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGFuIG9ubGluZSBVUkwuXG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbigkc2NlLnRydXN0QXNSZXNvdXJjZVVybChzY28ubGF1bmNoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuXG4gICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXREaXJlY3RvcnlVcmxCeVVybChzaXRlSWQsIHNjb3JtLm1vZHVsZXVybCkudGhlbihmdW5jdGlvbihkaXJQYXRoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIFVSTCBpcyBnb2luZyB0byBiZSBpbmplY3RlZCBpbiBhbiBpZnJhbWUsIHdlIG5lZWQgdHJ1c3RBc1Jlc291cmNlVXJsIHRvIG1ha2UgaXQgd29yayBpbiBhIGJyb3dzZXIuXG4gICAgICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzUmVzb3VyY2VVcmwoJG1tRlMuY29uY2F0ZW5hdGVQYXRocyhkaXJQYXRoLCBzY28ubGF1bmNoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBhIFNDT1JNIGlzIGRvd25sb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldFNjb3JtRm9sZGVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBtb2R1bGVVcmwgTW9kdWxlIFVSTCAocmV0dXJuZWQgYnkgZ2V0X2NvdXJzZV9jb250ZW50cykuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdICAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGZvbGRlciBwYXRoLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2Nvcm1Gb2xkZXIgPSBmdW5jdGlvbihtb2R1bGVVcmwsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICByZXR1cm4gJG1tRmlsZXBvb2wuZ2V0RmlsZVBhdGhCeVVybChzaXRlSWQsIG1vZHVsZVVybCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIGZpbGVzIHRvIGRvd25sYW9kIGZvciBhIFNDT1JNLCB1c2luZyBhIGZvcm1hdCBzaW1pbGFyIHRvIG1vZHVsZS5jb250ZW50cyBmcm9tIGdldF9jb3Vyc2VfY29udGVudHMuXG4gICAgICogSXQgd2lsbCBvbmx5IHJldHVybiBvbmUgZmlsZTogdGhlIFpJUCBwYWNrYWdlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNnZXRTY29ybUZpbGVMaXN0XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29ybSBTQ09STS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gICAgIEZpbGUgbGlzdC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb3JtRmlsZUxpc3QgPSBmdW5jdGlvbihzY29ybSkge1xuICAgICAgICB2YXIgZmlsZXMgPSBbXTtcbiAgICAgICAgaWYgKHNlbGYuaXNTY29ybVN1cHBvcnRlZChzY29ybSkgPT09IHRydWUgJiYgIXNjb3JtLndhcm5pbmdtZXNzYWdlKSB7XG4gICAgICAgICAgICBmaWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBmaWxldXJsOiBzZWxmLmdldFBhY2thZ2VVcmwoc2Nvcm0pLFxuICAgICAgICAgICAgICAgIGZpbGVwYXRoOiAnLycsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHNjb3JtLnJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICBmaWxlc2l6ZTogc2Nvcm0ucGFja2FnZXNpemUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2ZpbGUnLFxuICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZDogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFVSTCBhbmQgZGVzY3JpcHRpb24gb2YgdGhlIHN0YXR1cyBpY29uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNnZXRTY29TdGF0dXNJY29uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjbyAgICAgICAgIFNDTy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluY29tcGxldGUgVHJ1ZSBpZiBTQ09STSBpcyBpbmNvbXBsZXRlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgIEltYWdlIFVSTCBhbmQgZGVzY3JpcHRpb24uXG4gICAgICovXG4gICAgc2VsZi5nZXRTY29TdGF0dXNJY29uID0gZnVuY3Rpb24oc2NvLCBpbmNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBpbWFnZW5hbWUgPSAnJyxcbiAgICAgICAgICAgIGRlc2NuYW1lID0gJycsXG4gICAgICAgICAgICBzdGF0dXM7XG5cbiAgICAgICAgaWYgKHNjby5zY29ybXR5cGUgPT0gJ3NjbycpIHtcbiAgICAgICAgICAgIC8vIE5vdCBhbiBhc3NldCwgY2FsY3VsYXRlIGltYWdlIHVzaW5nIHN0YXR1cy5cbiAgICAgICAgICAgIHN0YXR1cyA9IHNjby5zdGF0dXM7XG4gICAgICAgICAgICBpZiAoc3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFN0YXR1cyBlbXB0eSBvciBub3QgdmFsaWQsIHVzZSAnbm90YXR0ZW1wdGVkJy5cbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAnbm90YXR0ZW1wdGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIFNDTyBpcyBjb21wbGV0ZWQgb3Igbm90LiBJZiBTQ09STSBpcyBpbmNvbXBsZXRlIHRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBTQ08uXG4gICAgICAgICAgICAgICAgaW5jb21wbGV0ZSA9IHNlbGYuaXNTdGF0dXNJbmNvbXBsZXRlKHN0YXR1cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmNvbXBsZXRlICYmIHNjby5leGl0dmFsdWUgPT0gJ3N1c3BlbmQnKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VuYW1lID0gJ3N1c3BlbmQnO1xuICAgICAgICAgICAgICAgIGRlc2NuYW1lID0gJ3N1c3BlbmRlZCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGltYWdlbmFtZSA9IHNjby5zdGF0dXM7XG4gICAgICAgICAgICAgICAgZGVzY25hbWUgPSBzY28uc3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1hZ2VuYW1lID0gJ2Fzc2V0JztcbiAgICAgICAgICAgIGRlc2NuYW1lID0gKCFzY28uc3RhdHVzIHx8IHNjby5zdGF0dXMgPT0gJ25vdGF0dGVtcHRlZCcpID8gJ2Fzc2V0JyA6ICdhc3NldGxhdW5jaGVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6ICdhZGRvbnMvbW9kX3Njb3JtL2ltZy8nICsgaW1hZ2VuYW1lICsgJy5naWYnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICR0cmFuc2xhdGUuaW5zdGFudCgnbW1hLm1vZF9zY29ybS4nICsgZGVzY25hbWUpXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIFNDT1JNIGRhdGEgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgQ291cnNlIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2Nvcm1EYXRhQ2FjaGVLZXkoY291cnNlSWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFNb2RTY29ybTpzY29ybTonICsgY291cnNlSWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgU0NPUk0gd2l0aCBrZXk9dmFsdWUuIElmIG1vcmUgdGhhbiBvbmUgaXMgZm91bmQsIG9ubHkgdGhlIGZpcnN0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY291cnNlSWQgIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGtleSAgICAgICBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gIHtNaXhlZH0gdmFsdWUgICAgICBWYWx1ZSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBtb2R1bGVVcmwgTW9kdWxlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFNDT1JNIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY29ybShzaXRlSWQsIGNvdXJzZUlkLCBrZXksIHZhbHVlLCBtb2R1bGVVcmwpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBjb3Vyc2VpZHM6IFtjb3Vyc2VJZF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRTY29ybURhdGFDYWNoZUtleShjb3Vyc2VJZClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5yZWFkKCdtb2Rfc2Nvcm1fZ2V0X3Njb3Jtc19ieV9jb3Vyc2VzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnNjb3Jtcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNjb3JtO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzcG9uc2Uuc2Nvcm1zLCBmdW5jdGlvbihzY29ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Nvcm0gJiYgc2Nvcm1ba2V5XSA9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29ybSA9IHNjb3JtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIFNDT1JNIGlzbid0IGF2YWlsYWJsZSB0aGUgV1MgcmV0dXJucyBhIHdhcm5pbmcgYW5kIGl0IGRvZXNuJ3QgcmV0dXJuIHRpbWVvcGVuIGFuZCB0aW1lY2xvc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50U2Nvcm0udGltZW9wZW4gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzcG9uc2Uud2FybmluZ3MsIGZ1bmN0aW9uKHdhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhcm5pbmcuaXRlbWlkID09PSBjdXJyZW50U2Nvcm0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29ybS53YXJuaW5nbWVzc2FnZSA9IHdhcm5pbmcubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3JtLm1vZHVsZXVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2Nvcm07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIFNDT1JNIGJ5IG1vZHVsZSBJRC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZ2V0U2Nvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgIENvdXJzZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY21pZCAgICAgIENvdXJzZSBtb2R1bGUgSUQuXG4gICAgICogQHBhcm1hIHtTdHJpbmd9IG1vZHVsZVVybCBNb2R1bGUgVVJMLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgU0NPUk0gaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2Nvcm0gPSBmdW5jdGlvbihjb3Vyc2VJZCwgY21pZCwgbW9kdWxlVXJsLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcmV0dXJuIGdldFNjb3JtKHNpdGVJZCwgY291cnNlSWQsICdjb3Vyc2Vtb2R1bGUnLCBjbWlkLCBtb2R1bGVVcmwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBTQ09STSBieSBTQ09STSBJRC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jZ2V0U2Nvcm1CeUlkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkICBDb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNtaWQgICAgICBDb3Vyc2UgbW9kdWxlIElELlxuICAgICAqIEBwYXJtYSB7U3RyaW5nfSBtb2R1bGVVcmwgTW9kdWxlIFVSTC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFNDT1JNIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb3JtQnlJZCA9IGZ1bmN0aW9uKGNvdXJzZUlkLCBpZCwgbW9kdWxlVXJsLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcmV0dXJuIGdldFNjb3JtKHNpdGVJZCwgY291cnNlSWQsICdpZCcsIGlkLCBtb2R1bGVVcmwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSByZWFkYWJsZSBTQ09STSBncmFkZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2dldFNjb3JtR3JhZGluZ01ldGhvZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSBTQ09STS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgR3JhZGluZyBtZXRob2QuXG4gICAgICovXG4gICAgc2VsZi5nZXRTY29ybUdyYWRlTWV0aG9kID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgaWYgKHNjb3JtLm1heGF0dGVtcHQgPT0gMSkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJzZUludChzY29ybS5ncmFkZW1ldGhvZCwgMTApKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBzZWxmLkdSQURFSElHSEVTVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUuaW5zdGFudCgnbW1hLm1vZF9zY29ybS5ncmFkZWhpZ2hlc3QnKTtcbiAgICAgICAgICAgICAgICBjYXNlIHNlbGYuR1JBREVBVkVSQUdFOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLmdyYWRlYXZlcmFnZScpO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5HUkFERVNVTTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUuaW5zdGFudCgnbW1hLm1vZF9zY29ybS5ncmFkZXN1bScpO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5HUkFERVNDT0VTOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLmdyYWRlc2NvZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFyc2VJbnQoc2Nvcm0ud2hhdGdyYWRlLCAxMCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHNlbGYuSElHSEVTVEFUVEVNUFQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tYS5tb2Rfc2Nvcm0uaGlnaGVzdGF0dGVtcHQnKTtcbiAgICAgICAgICAgICAgICBjYXNlIHNlbGYuQVZFUkFHRUFUVEVNUFQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdHJhbnNsYXRlLmluc3RhbnQoJ21tYS5tb2Rfc2Nvcm0uYXZlcmFnZWF0dGVtcHQnKTtcbiAgICAgICAgICAgICAgICBjYXNlIHNlbGYuRklSU1RBVFRFTVBUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLmZpcnN0YXR0ZW1wdCcpO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5MQVNUQVRURU1QVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUuaW5zdGFudCgnbW1hLm1vZF9zY29ybS5sYXN0YXR0ZW1wdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIGFsbCB0aGUgZGF0YSByZWxhdGVkIHRvIGEgY2VydGFpbiBTQ09STS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaW52YWxpZGF0ZUFsbFNjb3JtRGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJJZF0gVXNlciBJRC4gSWYgbm90IGRlZmluZWQgdXNlIHNpdGUncyBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVBbGxTY29ybURhdGEgPSBmdW5jdGlvbihzY29ybUlkLCBzaXRlSWQsIHVzZXJJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm1PbmxpbmUuaW52YWxpZGF0ZUF0dGVtcHRDb3VudChzaXRlSWQsIHNjb3JtSWQsIHVzZXJJZCkpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYuaW52YWxpZGF0ZVNjb3Moc2Nvcm1JZCwgc2l0ZUlkKSk7XG4gICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtT25saW5lLmludmFsaWRhdGVTY29ybVVzZXJEYXRhKHNpdGVJZCwgc2Nvcm1JZCkpO1xuICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSB0aGUgcHJlZmV0Y2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpbnZhbGlkYXRlQ29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGVJZCBUaGUgbW9kdWxlIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQ29udGVudCA9IGZ1bmN0aW9uKG1vZHVsZUlkLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmludmFsaWRhdGVGaWxlc0J5Q29tcG9uZW50KHNpdGVJZCwgbW1hTW9kU2Nvcm1Db21wb25lbnQsIG1vZHVsZUlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgU0NPUk0gc2NvcyBmb3IgYWxsIG9yZ2FuaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2ludmFsaWRhdGVTY29zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGlzIGludmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaW52YWxpZGF0ZVNjb3MgPSBmdW5jdGlvbihzY29ybUlkLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRTY29zQ2FjaGVLZXkoc2Nvcm1JZCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgU0NPUk0gZGF0YS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaW52YWxpZGF0ZVNjb3JtRGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVTY29ybURhdGEgPSBmdW5jdGlvbihjb3Vyc2VJZCwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0U2Nvcm1EYXRhQ2FjaGVLZXkoY291cnNlSWQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgU0NPUk0ncyBhdHRlbXB0IGlzIGluY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2lzQXR0ZW1wdEluY29tcGxldGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm1JZCAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICAgICAgQXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9mZmxpbmUgICAgIFRydWUgaWYgYXR0ZW1wdCBpcyBvZmZsaW5lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBUcnVlIGlmIGl0IHNob3VsZCBpZ25vcmUgY2FjaGVkIGRhdGEgZm9yIG9ubGluZSBhdHRlbXB0cy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gICAgIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggYSBib29sZWFuOiB0cnVlIGlmIGluY29tcGxldGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzQXR0ZW1wdEluY29tcGxldGUgPSBmdW5jdGlvbihzY29ybUlkLCBhdHRlbXB0LCBvZmZsaW5lLCBpZ25vcmVDYWNoZSwgc2l0ZUlkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldFNjb3NXaXRoRGF0YShzY29ybUlkLCB1bmRlZmluZWQsIGF0dGVtcHQsIG9mZmxpbmUsIGlnbm9yZUNhY2hlLCBzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2Nvcykge1xuICAgICAgICAgICAgdmFyIGluY29tcGxldGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjb3MsIGZ1bmN0aW9uKHNjbykge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBTQ09zIG5vdCB2aXNpYmxlIG9yIHdpdGhvdXQgbGF1bmNoIFVSTC5cbiAgICAgICAgICAgICAgICBpZiAoc2NvLmlzdmlzaWJsZSAmJiBzY28ubGF1bmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzU3RhdHVzSW5jb21wbGV0ZShzY28uc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGluY29tcGxldGU7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBpcyBlbmFibGVkIGluIGEgY2VydGFpbiBzaXRlLiBQbHVnaW4gaXMgZW5hYmxlZCBpZiB0aGUgc2Nvcm0gV1MgYXJlIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaXNQbHVnaW5FbmFibGVkXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gIHNpdGUud3NBdmFpbGFibGUoJ21vZF9zY29ybV9nZXRfc2Nvcm1fYXR0ZW1wdF9jb3VudCcpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9zY29ybV9nZXRfc2Nvcm1fc2NvX3RyYWNrcycpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9zY29ybV9nZXRfc2Nvcm1fc2NvZXMnKSAmJlxuICAgICAgICAgICAgICAgICAgICBzaXRlLndzQXZhaWxhYmxlKCdtb2Rfc2Nvcm1fZ2V0X3Njb3JtX3VzZXJfZGF0YScpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpdGUud3NBdmFpbGFibGUoJ21vZF9zY29ybV9nZXRfc2Nvcm1zX2J5X2NvdXJzZXMnKSAmJlxuICAgICAgICAgICAgICAgICAgICBzaXRlLndzQXZhaWxhYmxlKCdtb2Rfc2Nvcm1faW5zZXJ0X3Njb3JtX3RyYWNrcycpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBTQ09STSBpcyBiZWluZyBwbGF5ZWQgcmlnaHQgbm93LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpc1Njb3JtQmVpbmdQbGF5ZWRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBzY29ybUlkIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSAgU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgIFRydWUgaWYgaXQncyBiZWluZyBwbGF5ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzU2Nvcm1CZWluZ1BsYXllZCA9IGZ1bmN0aW9uKHNjb3JtSWQsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5nZXRJZCgpID09IHNpdGVJZCAmJiAkc3RhdGUuY3VycmVudC5uYW1lID09ICdzaXRlLm1vZF9zY29ybS1wbGF5ZXInICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUucGFyYW1zLnNjb3JtICYmICRzdGF0ZS5wYXJhbXMuc2Nvcm0uaWQgPT0gc2Nvcm1JZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIFNDT1JNIGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaXNTY29ybUNsb3NlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSBTQ09STSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSBpZiBTQ09STSBpcyBjbG9zZWQsIGZhbHNlIGlmIGl0IGhhc24ndCBjbG9zZWQgeWV0LlxuICAgICAqL1xuICAgIHNlbGYuaXNTY29ybUNsb3NlZCA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgIHZhciB0aW1lTm93ID0gJG1tVXRpbC50aW1lc3RhbXAoKTtcbiAgICAgICAgaWYgKHNjb3JtLnRpbWVjbG9zZSA+IDAgJiYgdGltZU5vdyA+IHNjb3JtLnRpbWVjbG9zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gU0NPUk0gaXMgZG93bmxvYWRhYmxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNpc1Njb3JtRG93bmxvYWRhYmxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtIFNDT1JNIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIFNDT1JNIGlzIGRvd25sb2FkYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNTY29ybURvd25sb2FkYWJsZSA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc2Nvcm0ucHJvdGVjdHBhY2thZ2Vkb3dubG9hZHMgIT0gJ3VuZGVmaW5lZCcgJiYgc2Nvcm0ucHJvdGVjdHBhY2thZ2Vkb3dubG9hZHMgPT09IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gU0NPUk0gaXMgb3Blbi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaXNTY29ybU9wZW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gU0NPUk0gdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUgaWYgU0NPUk0gaXMgb3BlbiwgZmFsc2UgaWYgaXQgaGFzbid0IG9wZW5lZCB5ZXQuXG4gICAgICovXG4gICAgc2VsZi5pc1Njb3JtT3BlbiA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgIHZhciB0aW1lTm93ID0gJG1tVXRpbC50aW1lc3RhbXAoKTtcbiAgICAgICAgaWYgKHNjb3JtLnRpbWVvcGVuID4gMCAmJiBzY29ybS50aW1lb3BlbiA+IHRpbWVOb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBTQ09STSBpcyBzdXBwb3J0ZWQgaW4gdGhlIGFwcC4gSWYgaXQncyBub3QsIHJldHVybnMgdGhlIGVycm9yIGNvZGUgdG8gc2hvdy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaXNTY29ybVN1cHBvcnRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSAgICBTQ09STSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufFN0cmluZ30gVHJ1ZSBpZiBTQ09STSBpcyBzdXBwb3J0ZWQsIHN0cmluZyB3aXRoIGVycm9yIGNvZGUgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNTY29ybVN1cHBvcnRlZCA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgIGlmICghc2VsZi5pc1Njb3JtVmFsaWRWZXJzaW9uKHNjb3JtKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtbWEubW9kX3Njb3JtLmVycm9yaW52YWxpZHZlcnNpb24nO1xuICAgICAgICB9IGVsc2UgaWYgKCFzZWxmLmlzU2Nvcm1Eb3dubG9hZGFibGUoc2Nvcm0pKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21tYS5tb2Rfc2Nvcm0uZXJyb3Jub3Rkb3dubG9hZGFibGUnO1xuICAgICAgICB9IGVsc2UgaWYgKCFzZWxmLmlzVmFsaWRQYWNrYWdlVXJsKHNlbGYuZ2V0UGFja2FnZVVybChzY29ybSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21tYS5tb2Rfc2Nvcm0uZXJyb3JwYWNrYWdlZmlsZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgaXQncyBhIHZhbGlkIFNDT1JNIDEuMi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaXNTY29ybVZhbGlkVmVyc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSBTQ09STSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSBpZiBTQ09STSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNTY29ybVZhbGlkVmVyc2lvbiA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgIHJldHVybiBzY29ybS52ZXJzaW9uID09ICdTQ09STV8xLjInO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIFNDTyBzdGF0dXMgaXMgaW5jb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jaXNTdGF0dXNJbmNvbXBsZXRlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgc3RhdHVzIFNDTyBzdGF0dXMuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUgaWYgaW5jb21wbGV0ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNTdGF0dXNJbmNvbXBsZXRlID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiAhc3RhdHVzIHx8IHN0YXR1cyA9PSAnbm90YXR0ZW1wdGVkJyB8fCBzdGF0dXMgPT0gJ2luY29tcGxldGUnIHx8IHN0YXR1cyA9PSAnYnJvd3NlZCc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgcGFja2FnZSBVUkwgaXMgdmFsaWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtI2lzVmFsaWRQYWNrYWdlVXJsXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgcGFja2FnZVVybCBQYWNrYWdlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIFRydWUgaWYgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzVmFsaWRQYWNrYWdlVXJsID0gZnVuY3Rpb24ocGFja2FnZVVybCkge1xuICAgICAgICBpZiAoIXBhY2thZ2VVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFja2FnZVVybC5pbmRleE9mKCdpbXNtYW5pZmVzdC54bWwnKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCBhIFNDT1JNIGFzIGJlaW5nIHZpZXdlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jbG9nVmlld1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAgICAgICBNb2R1bGUgSUQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgY2FsbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHNlbGYubG9nVmlldyA9IGZ1bmN0aW9uKGlkLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29ybWlkOiBpZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpdGUud3JpdGUoJ21vZF9zY29ybV92aWV3X3Njb3JtJywgcGFyYW1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IGEgU0NPIGFzIGJlaW5nIGxhdW5jaGVkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNsb2dMYXVuY2hTY29cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb0lkICAgIFNDTyBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBXUyBjYWxsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgc2VsZi5sb2dMYXVuY2hTY28gPSBmdW5jdGlvbihzY29ybUlkLCBzY29JZCwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBzY29ybWlkOiBzY29ybUlkLFxuICAgICAgICAgICAgc2NvaWQ6IHNjb0lkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpdGUud3JpdGUoJ21vZF9zY29ybV9sYXVuY2hfc2NvJywgcGFyYW1zKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZWZldGNoZXMgYW5kIHVuemlwcyB0aGUgU0NPUk0gcGFja2FnZSwgYW5kIGFsc28gcHJlZmV0Y2hlcyBzb21lIFdTIGNhbGxzLlxuICAgICAqIEBzZWUgJG1tYU1vZFNjb3JtI19kb3dubG9hZE9yUHJlZmV0Y2hcbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jcHJlZmV0Y2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gU0NPUk0gb2JqZWN0IHJldHVybmVkIGJ5ICRtbWFNb2RTY29ybSNnZXRTY29ybS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHByZWZldGNoIGlzIGRvbmUuIFJlc29sdmUgcGFyYW0gaXMgYSB3YXJuaW5nIG1lc3NhZ2UgKGlmIG5lZWRlZCkuXG4gICAgICovXG4gICAgc2VsZi5wcmVmZXRjaCA9IGZ1bmN0aW9uKHNjb3JtKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5wcmVmZXRjaFBhY2thZ2Uoc2Nvcm0pKTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYucHJlZmV0Y2hEYXRhKHNjb3JtKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIElmIHByZWZldGNoRGF0YSBmYWlscyB3ZSBkb24ndCB3YW50IHRvIGZhaWwgdGhlIHdob2xlIGRvd25sb2FkZWQsIHNvIHdlJ2xsIGlnbm9yZSB0aGUgZXJyb3IgZm9yIG5vdy5cbiAgICAgICAgICAgIC8vIEB0b2RvIEltcGxlbWVudCBhIHdhcm5pbmcgc3lzdGVtIHNvIHRoZSB1c2VyIGtub3dzIHdoaWNoIFNDT1JNcyBoYXZlIGZhaWxlZC5cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaGVzIHNvbWUgV1MgZGF0YSBmb3IgYSBTQ09STS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jcHJlZmV0Y2hEYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtICAgIFNDT1JNIG9iamVjdCByZXR1cm5lZCBieSAkbW1hTW9kU2Nvcm0jZ2V0U2Nvcm0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBwcmVmZXRjaGVkLlxuICAgICAqL1xuICAgIHNlbGYucHJlZmV0Y2hEYXRhID0gZnVuY3Rpb24oc2Nvcm0sIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAvLyBQcmVmZXRjaCBudW1iZXIgb2YgYXR0ZW1wdHMgKGluY2x1ZGluZyBub3QgY29tcGxldGVkKS5cbiAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm1PbmxpbmUuZ2V0QXR0ZW1wdENvdW50KHNpdGVJZCwgc2Nvcm0uaWQpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gSWYgaXQgZmFpbHMsIGFzc3VtZSB3ZSBoYXZlIG5vIGF0dGVtcHRzLlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24obnVtQXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIGlmIChudW1BdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdXNlciBkYXRhIGZvciBlYWNoIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gRmlsbCBhbiBhdHRlbXB0cyBhcnJheSB0byBiZSBhYmxlIHRvIHVzZSBmb3JFYWNoIGFuZCBwcmV2ZW50IHByb2JsZW1zIHdpdGggYXR0ZW1wdCB2YXJpYWJsZSBjaGFuZ2luZy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBudW1BdHRlbXB0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXR0ZW1wdHMuZm9yRWFjaChmdW5jdGlvbihhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFwcm9taXNlcy5wdXNoKCRtbWFNb2RTY29ybU9ubGluZS5nZXRTY29ybVVzZXJEYXRhKHNpdGVJZCwgc2Nvcm0uaWQsIGF0dGVtcHQpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGZhaWx1cmVzIG9mIGFsbCB0aGUgYXR0ZW1wdHMgdGhhdCBhcmVuJ3QgdGhlIGxhc3Qgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPT0gbnVtQXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwoZGF0YXByb21pc2VzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gYXR0ZW1wdHMuIFdlJ2xsIHN0aWxsIHRyeSB0byBnZXQgdXNlciBkYXRhIHRvIGJlIGFibGUgdG8gaWRlbnRpZnkgU0NPcyBub3QgdmlzaWJsZSBhbmQgc28uXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9ubGluZS5nZXRTY29ybVVzZXJEYXRhKHNpdGVJZCwgc2Nvcm0uaWQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gUHJlZmV0Y2ggU0NPcy5cbiAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLmdldFNjb3Moc2Nvcm0uaWQsIHNpdGVJZCkpO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVmZXRjaGVzIGFuZCB1bnppcHMgdGhlIFNDT1JNIHBhY2thZ2UuXG4gICAgICogQHNlZSAkbW1hTW9kU2Nvcm0jX2Rvd25sb2FkT3JQcmVmZXRjaFxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNwcmVmZXRjaFBhY2thZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Nvcm0gU0NPUk0gb2JqZWN0IHJldHVybmVkIGJ5ICRtbWFNb2RTY29ybSNnZXRTY29ybS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBwYWNrYWdlIGlzIHByZWZldGNoZWQgYW5kIHVuemlwcGVkLlxuICAgICAqL1xuICAgIHNlbGYucHJlZmV0Y2hQYWNrYWdlID0gZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2Rvd25sb2FkT3JQcmVmZXRjaChzY29ybSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgU0NPUk0gdHJhY2tpbmcgcmVjb3JkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybSNzYXZlVHJhY2tzXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29JZCAgICAgIFNjbyBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgICAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IHRyYWNrcyAgIFRyYWNraW5nIGRhdGEgdG8gc3RvcmUuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gb2ZmbGluZSAgIFRydWUgaWYgYXR0ZW1wdCBpcyBvZmZsaW5lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzY29ybSAgICAgIFNDT1JNLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW3VzZXJEYXRhXSBVc2VyIGRhdGEgZm9yIHRoaXMgYXR0ZW1wdCBhbmQgU0NPLiBJZiBub3QgZGVmaW5lZCwgaXQgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSBEQi4gUmVjb21tZW5kZWQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbc2l0ZUlkXSAgIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBkYXRhIGlzIHNhdmVkLlxuICAgICAqL1xuICAgIHNlbGYuc2F2ZVRyYWNrcyA9IGZ1bmN0aW9uKHNjb0lkLCBhdHRlbXB0LCB0cmFja3MsIG9mZmxpbmUsIHNjb3JtLCB1c2VyRGF0YSwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIGlmIChvZmZsaW5lKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHVzZXJEYXRhID8gJHEud2hlbih1c2VyRGF0YSkgOiBzZWxmLmdldFNjb3JtVXNlckRhdGEoc2Nvcm0uaWQsIGF0dGVtcHQsIG9mZmxpbmUsIHNpdGVJZCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVzZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9mZmxpbmUuc2F2ZVRyYWNrcyhzaXRlSWQsIHNjb3JtLCBzY29JZCwgYXR0ZW1wdCwgdHJhY2tzLCB1c2VyRGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PbmxpbmUuc2F2ZVRyYWNrcyhzaXRlSWQsIHNjb3JtLmlkLCBzY29JZCwgYXR0ZW1wdCwgdHJhY2tzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyBhIFNDT1JNIHRyYWNraW5nIHJlY29yZCB1c2luZyBhIHN5bmNocm9ub3VzIGNhbGwuXG4gICAgICogUGxlYXNlIHVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgaWYgc3luY2hyb25vdXMgaXMgYSBtdXN0LiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSAkbW1hTW9kU2Nvcm0jc2F2ZVRyYWNrcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm0jc2F2ZVRyYWNrc1N5bmNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkICAgICAgU2NvIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCAgICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gdHJhY2tzICAgVHJhY2tpbmcgZGF0YSB0byBzdG9yZS5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvZmZsaW5lICAgVHJ1ZSBpZiBhdHRlbXB0IGlzIG9mZmxpbmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtzY29ybV0gICAgU0NPUk0uIFJlcXVpcmVkIGlmIG9mZmxpbmU9dHJ1ZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFt1c2VyRGF0YV0gVXNlciBkYXRhIGZvciB0aGlzIGF0dGVtcHQgYW5kIFNDTy4gUmVxdWlyZWQgaWYgb2ZmbGluZT10cnVlLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICBJbiBvbmxpbmUgcmV0dXJucyB0cnVlIGlmIGRhdGEgaXMgaW5zZXJ0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gb2ZmbGluZSByZXR1cm5zIHRydWUgaWYgZGF0YSB0byBpbnNlcnQgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS4gVHJ1ZSBkb2Vzbid0IG1lYW4gdGhhdCB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSBoYXMgYmVlbiBzdG9yZWQsIHRoaXMgZnVuY3Rpb24gY2FuIHJldHVybiB0cnVlIGJ1dCB0aGUgaW5zZXJ0aW9uIGNhbiBzdGlsbCBmYWlsIHNvbWVob3cuXG4gICAgICovXG4gICAgc2VsZi5zYXZlVHJhY2tzU3luYyA9IGZ1bmN0aW9uKHNjb0lkLCBhdHRlbXB0LCB0cmFja3MsIG9mZmxpbmUsIHNjb3JtLCB1c2VyRGF0YSkge1xuICAgICAgICBpZiAob2ZmbGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9mZmxpbmUuc2F2ZVRyYWNrc1N5bmMoc2Nvcm0sIHNjb0lkLCBhdHRlbXB0LCB0cmFja3MsIHVzZXJEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PbmxpbmUuc2F2ZVRyYWNrc1N5bmMoc2NvSWQsIGF0dGVtcHQsIHRyYWNrcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF9zY29ybScpXG5cbi5jb25zdGFudCgnbW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZScsICdtb2Rfc2Nvcm1fb2ZmbGluZV9hdHRlbXB0cycpXG4uY29uc3RhbnQoJ21tYU1vZFNjb3JtT2ZmbGluZVRyYWNrc1N0b3JlJywgJ21vZF9zY29ybV9vZmZsaW5lX3Njb3NfdHJhY2tzJylcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1TaXRlc0ZhY3RvcnlQcm92aWRlciwgbW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZSwgbW1hTW9kU2Nvcm1PZmZsaW5lVHJhY2tzU3RvcmUpIHtcbiAgICB2YXIgc3RvcmVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBtbWFNb2RTY29ybU9mZmxpbmVBdHRlbXB0c1N0b3JlLFxuICAgICAgICAgICAga2V5UGF0aDogWydzY29ybWlkJywgJ3VzZXJpZCcsICdhdHRlbXB0J10sXG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYXR0ZW1wdCcgLy8gQXR0ZW1wdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyaWQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzY29ybWlkJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY291cnNlaWQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0aW1lbW9kaWZpZWQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCB1c2luZyBjb21wb3VuZCBpbmRleGVzIGJlY2F1c2UgdGhleSBzZWVtIHRvIGhhdmUgaXNzdWVzIHdpdGggd2hlcmUoKS5cbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Njb3JtQW5kVXNlcicsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW29iai5zY29ybWlkLCBvYmoudXNlcmlkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogbW1hTW9kU2Nvcm1PZmZsaW5lVHJhY2tzU3RvcmUsXG4gICAgICAgICAgICBrZXlQYXRoOiBbJ3VzZXJpZCcsICdzY29ybWlkJywgJ3Njb2lkJywgJ2F0dGVtcHQnLCAnZWxlbWVudCddLFxuICAgICAgICAgICAgaW5kZXhlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3VzZXJpZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Njb3JtaWQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzY29pZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2F0dGVtcHQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdlbGVtZW50J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc3luY2VkJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgdXNpbmcgY29tcG91bmQgaW5kZXhlcyBiZWNhdXNlIHRoZXkgc2VlbSB0byBoYXZlIGlzc3VlcyB3aXRoIHdoZXJlKCkuXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzY29ybVVzZXJBdHRlbXB0JyxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbb2JqLnNjb3JtaWQsIG9iai51c2VyaWQsIG9iai5hdHRlbXB0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgdXNpbmcgY29tcG91bmQgaW5kZXhlcyBiZWNhdXNlIHRoZXkgc2VlbSB0byBoYXZlIGlzc3VlcyB3aXRoIHdoZXJlKCkuXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzY29ybVVzZXJBdHRlbXB0U3luY2VkJyxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbb2JqLnNjb3JtaWQsIG9iai51c2VyaWQsIG9iai5hdHRlbXB0LCBvYmouc3luY2VkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIF07XG4gICAgJG1tU2l0ZXNGYWN0b3J5UHJvdmlkZXIucmVnaXN0ZXJTdG9yZXMoc3RvcmVzKTtcbn0pXG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgU0NPUk0gb2ZmbGluZSBmZWF0dXJlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kU2Nvcm1PZmZsaW5lXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kU2Nvcm1PZmZsaW5lJywgZnVuY3Rpb24oJG1tU2l0ZSwgJG1tVXRpbCwgJHEsICRsb2csICRtbVNpdGVzTWFuYWdlciwgbW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZSxcbiAgICAgICAgICAgIG1tYU1vZFNjb3JtT2ZmbGluZVRyYWNrc1N0b3JlKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFNb2RTY29ybU9mZmxpbmUnKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIGJsb2NrZWRTY29ybXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgYW4gYXR0ZW1wdCBudW1iZXIgaW4gdGhlIGRhdGEgc3RvcmVkIGluIG9mZmxpbmUuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnZlcnQgYXR0ZW1wdHMgaW50byBuZXcgYXR0ZW1wdHMsIHNvIHRoZSBzdG9yZWQgc25hcHNob3Qgd2lsbCBiZSByZW1vdmVkIGFuZFxuICAgICAqIGVudHJpZXMgd2lsbCBiZSBtYXJrZWQgYXMgbm90IHN5bmNlZC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PZmZsaW5lI2NoYW5nZUF0dGVtcHROdW1iZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybUlkICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICAgIE51bWJlciBvZiB0aGUgYXR0ZW1wdCB0byBjaGFuZ2UuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld0F0dGVtcHQgTmV3IGF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSAgIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkIHVzZSBzaXRlJ3MgY3VycmVudCB1c2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgYXR0ZW1wdCBudW1iZXIgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBzZWxmLmNoYW5nZUF0dGVtcHROdW1iZXIgPSBmdW5jdGlvbihzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIG5ld0F0dGVtcHQsIHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0NoYW5nZSBhdHRlbXB0IG51bWJlciBmcm9tICcgKyBhdHRlbXB0ICsgJyB0byAnICsgbmV3QXR0ZW1wdCArICcgaW4gU0NPUk0gJyArIHNjb3JtSWQpO1xuICAgICAgICAgICAgdXNlcklkID0gdXNlcklkIHx8IHNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAgICAgICAgIHZhciBkYiA9IHNpdGUuZ2V0RGIoKSxcbiAgICAgICAgICAgICAgICBuZXdFbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2Nvcm1pZDogc2Nvcm1JZCxcbiAgICAgICAgICAgICAgICAgICAgdXNlcmlkOiB1c2VySWQsXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQ6IG5ld0F0dGVtcHQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZDogJG1tVXRpbC50aW1lc3RhbXAoKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghYmxvY2tlZFNjb3Jtc1tzaXRlSWRdKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tlZFNjb3Jtc1tzaXRlSWRdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9ja2VkU2Nvcm1zW3NpdGVJZF1bc2Nvcm1JZF0gPSB0cnVlOyAvLyBCbG9jayB0aGUgU0NPUk0gc28gaXQgY2FuJ3QgYmUgc3luY2VkLlxuXG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBkYXRhLlxuICAgICAgICAgICAgcmV0dXJuIGRiLmdldChtbWFNb2RTY29ybU9mZmxpbmVBdHRlbXB0c1N0b3JlLCBbc2Nvcm1JZCwgdXNlcklkLCBhdHRlbXB0XSkudGhlbihmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgIG5ld0VudHJ5LnRpbWVjcmVhdGVkID0gZW50cnkudGltZWNyZWF0ZWQ7XG4gICAgICAgICAgICAgICAgbmV3RW50cnkuY291cnNlaWQgPSBlbnRyeS5jb3Vyc2VpZDtcblxuICAgICAgICAgICAgICAgIC8vIEluc2VydCBuZXcgYXR0ZW1wdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGIuaW5zZXJ0KG1tYU1vZFNjb3JtT2ZmbGluZUF0dGVtcHRzU3RvcmUsIG5ld0VudHJ5KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRyYWNraW5nIGRhdGEgdG8gdGhlIG5ldyBhdHRlbXB0LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTY29ybVN0b3JlZERhdGEoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1c2VySWQpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5hdHRlbXB0ID0gbmV3QXR0ZW1wdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zeW5jZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZGIuaW5zZXJ0KG1tYU1vZFNjb3JtT2ZmbGluZVRyYWNrc1N0b3JlLCBlbnRyeSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1VdGlsLmFsbFByb21pc2VzKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBlbnRyaWVzIGluc2VydGVkLiBEZWxldGUgdGhlIG9sZCBhdHRlbXB0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRlbGV0ZUF0dGVtcHQoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRlbGV0ZSBmYWlsZWQsIGl0IHNob3VsZG4ndCBoYXBwZW4uIExldCdzIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRlbGV0ZUF0dGVtcHQoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0KS5jYXRjaChmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhaWxlZCB0byBnZXQgdGhlIGRhdGEsIHJlbW92ZSB0aGUgbmV3IGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5kZWxldGVBdHRlbXB0KHNpdGVJZCwgc2Nvcm1JZCwgbmV3QXR0ZW1wdCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJsb2NrZWRTY29ybXNbc2l0ZUlkXVtzY29ybUlkXSA9IGZhbHNlOyAvLyBVbmJsb2NrIHRoZSBTQ09STS5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYmxvY2tlZCBTQ09STXMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT2ZmbGluZSNjbGVhckJsb2NrZWRTY29ybXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gSWYgc2V0LCBjbGVhciB0aGUgYmxvY2tlZCBTQ09STXMgb25seSBmb3IgdGhpcyBzaXRlLiBPdGhlcndpc2UgY2xlYXIgYWxsIFNDT1JNcy5cbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNlbGYuY2xlYXJCbG9ja2VkU2Nvcm1zID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIGlmIChzaXRlSWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBibG9ja2VkU2Nvcm1zW3NpdGVJZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBibG9ja2VkU2Nvcm1zID0ge307XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvZmZsaW5lIGF0dGVtcHQuIEl0IGNhbiBiZSBjcmVhdGVkIGZyb20gc2NyYXRjaCBvciBhcyBhIGNvcHkgb2YgYW5vdGhlciBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjY3JlYXRlTmV3QXR0ZW1wdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JtICAgICAgU0NPUk0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdICAgVXNlciBJRC4gSWYgbm90IGRlZmluZWQgdXNlIHNpdGUncyBjdXJyZW50IHVzZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgICAgTnVtYmVyIG9mIHRoZSBuZXcgYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlckRhdGEgICBVc2VyIGRhdGEgdG8gc3RvcmUgaW4gdGhlIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzbmFwc2hvdF0gT3B0aW9uYWwuIFNuYXBzaG90IHRvIHN0b3JlIGluIHRoZSBhdHRlbXB0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbmV3IGF0dGVtcHQgaXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmNyZWF0ZU5ld0F0dGVtcHQgPSBmdW5jdGlvbihzaXRlSWQsIHNjb3JtLCB1c2VySWQsIGF0dGVtcHQsIHVzZXJEYXRhLCBzbmFwc2hvdCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0NyZWF0aW5nIG5ldyBvZmZsaW5lIGF0dGVtcHQgJyArIGF0dGVtcHQgKyAnIGluIFNDT1JNICcgKyBzY29ybS5pZCk7XG4gICAgICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgc2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAgICAgaWYgKCFibG9ja2VkU2Nvcm1zW3NpdGVJZF0pIHtcbiAgICAgICAgICAgICAgICBibG9ja2VkU2Nvcm1zW3NpdGVJZF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrZWRTY29ybXNbc2l0ZUlkXVtzY29ybS5pZF0gPSB0cnVlOyAvLyBCbG9jayB0aGUgU0NPUk0gc28gaXQgY2FuJ3QgYmUgc3luY2VkLlxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYXR0ZW1wdCBpbiBEQi5cbiAgICAgICAgICAgIHZhciBkYiA9IHNpdGUuZ2V0RGIoKSxcbiAgICAgICAgICAgICAgICBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2Nvcm1pZDogc2Nvcm0uaWQsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJpZDogdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0LFxuICAgICAgICAgICAgICAgICAgICBjb3Vyc2VpZDogc2Nvcm0uY291cnNlLFxuICAgICAgICAgICAgICAgICAgICB0aW1lY3JlYXRlZDogJG1tVXRpbC50aW1lc3RhbXAoKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZW1vZGlmaWVkOiAkbW1VdGlsLnRpbWVzdGFtcCgpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBhIHNuYXBzaG90IG9mIHRoZSBkYXRhIHdlIGhhZCB3aGVuIHdlIGNyZWF0ZWQgdGhlIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBkZWZhdWx0IGRhdGEsIHdlIGRvbid0IHdhbnQgdG8gc3RvcmUgaXQuXG4gICAgICAgICAgICAgICAgZW50cnkuc25hcHNob3QgPSByZW1vdmVEZWZhdWx0RGF0YShzbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQobW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZSwgZW50cnkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgYWxsIHRoZSBkYXRhIGluIHVzZXJEYXRhLlxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1c2VyRGF0YSwgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjby51c2VyZGF0YSwgZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrcy5wdXNoKHtlbGVtZW50OiBlbGVtZW50LCB2YWx1ZTogdmFsdWV9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5zYXZlVHJhY2tzKHNpdGVJZCwgc2Nvcm0sIHNjby5zY29pZCwgYXR0ZW1wdCwgdHJhY2tzLCB1c2VyRGF0YSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBibG9ja2VkU2Nvcm1zW3NpdGVJZF1bc2Nvcm0uaWRdID0gZmFsc2U7IC8vIFVuYmxvY2sgdGhlIFNDT1JNLlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYWxsIHRoZSBzdG9yZWQgZGF0YSBmcm9tIGFuIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT2ZmbGluZSNkZWxldGVBdHRlbXB0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJJZF0gVXNlciBJRC4gSWYgbm90IGRlZmluZWQgdXNlIHNpdGUncyBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBhbGwgdGhlIGRhdGEgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmRlbGV0ZUF0dGVtcHQgPSBmdW5jdGlvbihzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0RlbGV0ZSBvZmZsaW5lIGF0dGVtcHQgJyArIGF0dGVtcHQgKyAnIGluIFNDT1JNICcgKyBzY29ybUlkKTtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fMKgc2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2Nvcm1TdG9yZWREYXRhKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdXNlcklkKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgZGIgPSBzaXRlLmdldERiKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWxldGUgYWxsIHRoZSB0cmFja3MuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeUlkID0gW2VudHJ5LnVzZXJpZCwgZW50cnkuc2Nvcm1pZCwgZW50cnkuc2NvaWQsIGVudHJ5LmF0dGVtcHQsIGVudHJ5LmVsZW1lbnRdO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRiLnJlbW92ZShtbWFNb2RTY29ybU9mZmxpbmVUcmFja3NTdG9yZSwgZW50cnlJZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBhdHRlbXB0LlxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZGIucmVtb3ZlKG1tYU1vZFNjb3JtT2ZmbGluZUF0dGVtcHRzU3RvcmUsIFtzY29ybUlkLCB1c2VySWQsIGF0dGVtcHRdKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHJldHVybiBhIGZvcm1hdHRlZCBsaXN0IG9mIGludGVyYWN0aW9ucyBmb3IgcmVwb3J0cy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIGluIE1vb2RsZSdzIHNjb3JtX2Zvcm1hdF9pbnRlcmFjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb1VzZXJEYXRhIFVzZXJkYXRhIGZyb20gYSBjZXJ0YWluIFNDTy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgIEZvcm1hdHRlZCB1c2VyZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXRJbnRlcmFjdGlvbnMoc2NvVXNlckRhdGEpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZCA9IHt9O1xuXG4gICAgICAgIC8vIERlZmluZWQgaW4gb3JkZXIgdG8gdW5pZnkgc2Nvcm0xLjIgYW5kIHNjb3JtMjAwNC5cbiAgICAgICAgZm9ybWF0dGVkLnNjb3JlX3JhdyA9ICcnO1xuICAgICAgICBmb3JtYXR0ZWQuc3RhdHVzID0gJyc7XG4gICAgICAgIGZvcm1hdHRlZC50b3RhbF90aW1lID0gJzAwOjAwOjAwJztcbiAgICAgICAgZm9ybWF0dGVkLnNlc3Npb25fdGltZSA9ICcwMDowMDowMCc7XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjb1VzZXJEYXRhLCBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGVsZW1lbnRzIHRoYXQgYXJlIGNhbGN1bGF0ZWQuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PSAnc2NvcmVfcmF3JyB8fCBlbGVtZW50ID09ICdzdGF0dXMnIHx8IGVsZW1lbnQgPT0gJ3RvdGFsX3RpbWUnIHx8IGVsZW1lbnQgPT0gJ3Nlc3Npb25fdGltZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdHRlZFtlbGVtZW50XSA9IHZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY21pLmNvcmUubGVzc29uX3N0YXR1cyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY21pLmNvbXBsZXRpb25fc3RhdHVzJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09ICdub3QgYXR0ZW1wdGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnbm90YXR0ZW1wdGVkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWQuc3RhdHVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NtaS5jb3JlLnNjb3JlLnJhdyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY21pLnNjb3JlLnJhdyc6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZC5zY29yZV9yYXcgPSAkbW1VdGlsLnJvdW5kVG9EZWNpbWFscyh2YWx1ZSwgMik7IC8vIFJvdW5kIHRvIDIgZGVjaW1hbHMgbWF4LlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbWkuY29yZS5zZXNzaW9uX3RpbWUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NtaS5zZXNzaW9uX3RpbWUnOlxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWQuc2Vzc2lvbl90aW1lID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NtaS5jb3JlLnRvdGFsX3RpbWUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NtaS50b3RhbF90aW1lJzpcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkLnRvdGFsX3RpbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGxhdW5jaCBVUkxzIGZyb20gYSBsaXN0IG9mIFNDT3MsIGluZGV4aW5nIHRoZW0gYnkgU0NPIElELlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IHNjb3MgTGlzdCBvZiBTQ09zLiBFYWNoIFNDTyBuZWVkcyB0byBoYXZlICdpZCcgYW5kICdsYXVuY2gnIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgTGF1bmNoIFVSTHMgaW5kZXhlZCBieSBTQ08gSUQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TGF1bmNoVXJsc0Zyb21TY29zKHNjb3MpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0ge307XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY29zLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgIHJlc3BvbnNlW3Njby5pZF0gPSBzY28ubGF1bmNoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIG9mZmxpbmUgYXR0ZW1wdHMgaW4gYSBjZXJ0YWluIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT2ZmbGluZSNnZXRBbGxBdHRlbXB0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3Qgc2V0LCB1c2UgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIG9mZmxpbmUgYXR0ZW1wdHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEFsbEF0dGVtcHRzID0gZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlRGIoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGRiKSB7XG4gICAgICAgICAgICBpZiAoIWRiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGIuZ2V0QWxsKG1tYU1vZFNjb3JtT2ZmbGluZUF0dGVtcHRzU3RvcmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvZmZsaW5lIGF0dGVtcHRzIGRvbmUgYnkgYSB1c2VyIGluIHRoZSBnaXZlbiBTQ09STS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PZmZsaW5lI2dldEF0dGVtcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBvZmZsaW5lIGF0dGVtcHRzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRBdHRlbXB0cyA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCwgdXNlcklkKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZShzaXRlSWQpLnRoZW4oZnVuY3Rpb24oc2l0ZSkge1xuICAgICAgICAgICAgdXNlcklkID0gdXNlcklkIHx8IHNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAgICAgICAgIHZhciBkYiA9IHNpdGUuZ2V0RGIoKTtcbiAgICAgICAgICAgIHJldHVybiBkYi53aGVyZUVxdWFsKG1tYU1vZFNjb3JtT2ZmbGluZUF0dGVtcHRzU3RvcmUsICdzY29ybUFuZFVzZXInLCBbc2Nvcm1JZCwgdXNlcklkXSkudGhlbihmdW5jdGlvbihhdHRlbXB0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRlbXB0cztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzbmFwc2hvdCBvZiBhbiBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjZ2V0QXR0ZW1wdFNuYXBzaG90XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJJZF0gVXNlciBJRC4gSWYgbm90IGRlZmluZWQgdXNlIHNpdGUncyBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgc25hcHNob3Qgb3IgdW5kZWZpbmVkIGlmIG5vIHNuYXBzaG90LlxuICAgICAqL1xuICAgIHNlbGYuZ2V0QXR0ZW1wdFNuYXBzaG90ID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgc2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNpdGUuZ2V0RGIoKS5nZXQobW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZSwgW3Njb3JtSWQsIHVzZXJJZCwgYXR0ZW1wdF0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTsgLy8gQXR0ZW1wdCBub3QgZm91bmQuXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnNuYXBzaG90O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNyZWF0aW9uIHRpbWUgb2YgYW4gYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PZmZsaW5lI2dldEF0dGVtcHRDcmVhdGlvblRpbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRpbWUgdGhlIGF0dGVtcHQgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRBdHRlbXB0Q3JlYXRpb25UaW1lID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgc2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNpdGUuZ2V0RGIoKS5nZXQobW1hTW9kU2Nvcm1PZmZsaW5lQXR0ZW1wdHNTdG9yZSwgW3Njb3JtSWQsIHVzZXJJZCwgYXR0ZW1wdF0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTsgLy8gQXR0ZW1wdCBub3QgZm91bmQuXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnRpbWVjcmVhdGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YSBzdG9yZWQgaW4gbG9jYWwgREIgZm9yIGEgY2VydGFpbiBzY29ybSBhbmQgYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PZmZsaW5lI2dldFNjb3JtU3RvcmVkRGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkICAgICAgICAgICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCAgICAgICAgICAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdICAgICAgICAgIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkIHVzZSBzaXRlJ3MgY3VycmVudCB1c2VyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhjbHVkZVN5bmNlZCAgICBUcnVlIGlmIGl0IHNob3VsZCBvbmx5IHJldHVybiBub3Qgc3luY2VkIGVudHJpZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBleGNsdWRlTm90U3luY2VkIFRydWUgaWYgaXQgc2hvdWxkIG9ubHkgcmV0dXJuIHN5bmNlZCBlbnRyaWVzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGVudHJpZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXRTY29ybVN0b3JlZERhdGEgPSBmdW5jdGlvbihzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIHVzZXJJZCwgZXhjbHVkZVN5bmNlZCwgZXhjbHVkZU5vdFN5bmNlZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fCBzaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICAgICB2YXIgd2hlcmU7XG5cbiAgICAgICAgICAgIGlmIChleGNsdWRlU3luY2VkICYmIGV4Y2x1ZGVOb3RTeW5jZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4Y2x1ZGVTeW5jZWQgfHwgZXhjbHVkZU5vdFN5bmNlZCkge1xuICAgICAgICAgICAgICAgIHdoZXJlID0gWydzY29ybVVzZXJBdHRlbXB0U3luY2VkJywgJz0nLCBbc2Nvcm1JZCwgdXNlcklkLCBhdHRlbXB0LCBleGNsdWRlTm90U3luY2VkID8gMSA6IDBdXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hlcmUgPSBbJ3Njb3JtVXNlckF0dGVtcHQnLCAnPScsIFtzY29ybUlkLCB1c2VySWQsIGF0dGVtcHRdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaXRlLmdldERiKCkucXVlcnkobW1hTW9kU2Nvcm1PZmZsaW5lVHJhY2tzU3RvcmUsIHdoZXJlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdXNlciBkYXRhIGZvciBhIGNlcnRhaW4gU0NPUk0gYW5kIG9mZmxpbmUgYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PZmZsaW5lI2dldFNjb3JtVXNlckRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBzY29zICAgU0NPcyByZXR1cm5lZCBieSAkbW1hTW9kU2Nvcm0jZ2V0U2Nvcy4gUmVxdWlyZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgdXNlciBkYXRhIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldFNjb3JtVXNlckRhdGEgPSBmdW5jdGlvbihzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIHVzZXJJZCwgc2Nvcykge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fCBzaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdXNlciBkYXRhLiBPcmRlcmluZyB3aGVuIHVzaW5nIGEgY29tcG91bmQgaW5kZXggaXMgY29tcGxleCwgc28gd2Ugd29uJ3Qgb3JkZXIgYnkgc2NvaWQuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTY29ybVN0b3JlZERhdGEoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1c2VySWQpLnRoZW4oZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBsYXVuY2hVcmxzID0gZ2V0TGF1bmNoVXJsc0Zyb21TY29zKHNjb3MpLFxuICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBzaXRlLmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgICAgICAgICB1c2VybmFtZSA9IHNpdGUuZ2V0SW5mbygpLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBmdWxsTmFtZSA9IHNpdGUuZ2V0SW5mbygpLmZ1bGxuYW1lO1xuXG4gICAgICAgICAgICAgICAgLy8gR2F0aGVyIHVzZXIgZGF0YSByZXRyaWV2ZWQgZnJvbSBEQiwgZ3JvdXBpbmcgaXQgYnkgc2NvaWQuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY29pZCA9IGVudHJ5LnNjb2lkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlW3Njb2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBTQ08uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtzY29pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvaWQ6IHNjb2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJpZDogdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29pZDogc2NvaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVtb2RpZmllZDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Vbc2NvaWRdLnVzZXJkYXRhW2VudHJ5LmVsZW1lbnRdID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS50aW1lbW9kaWZpZWQgPiByZXNwb25zZVtzY29pZF0udXNlcmRhdGEudGltZW1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtzY29pZF0udXNlcmRhdGEudGltZW1vZGlmaWVkID0gZW50cnkudGltZW1vZGlmaWVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgZWFjaCB1c2VyIGRhdGEgcmV0cmlldmVkLlxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNwb25zZSwgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjby51c2VyZGF0YSA9IGZvcm1hdEludGVyYWN0aW9ucyhzY28udXNlcmRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGVtcHR5IGVudHJpZXMgZm9yIHRoZSBTQ09zIHdpdGhvdXQgdXNlciBkYXRhIHN0b3JlZC5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NvcywgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Vbc2NvLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Vbc2NvLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29pZDogc2NvLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlX3JhdzogJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgZGVmYXVsdGRhdGEuXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc3BvbnNlLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUuc3R1ZGVudF9pZCddID0gdXNlcm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUuc3R1ZGVudF9uYW1lJ10gPSBmdWxsTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5sZXNzb25fbW9kZSddID0gJ25vcm1hbCc7IC8vIE92ZXJyaWRkZW4gaW4gcGxheWVyLlxuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5jb3JlLmNyZWRpdCddID0gJ2NyZWRpdCc7IC8vIE92ZXJyaWRkZW4gaW4gcGxheWVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvLnVzZXJkYXRhLnN0YXR1cyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUuZW50cnknXSA9ICdhYi1pbml0aW8nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjby51c2VyZGF0YVsnY21pLmNvcmUuZXhpdCddID09PSAnc3VzcGVuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUuZW50cnknXSA9ICdyZXN1bWUnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5lbnRyeSddID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuc3R1ZGVudF9kYXRhLm1hc3Rlcnlfc2NvcmUnXSA9IHNjb3JtSXNzZXQoc2NvLnVzZXJkYXRhLCAnbWFzdGVyeXNjb3JlJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLnN0dWRlbnRfZGF0YS5tYXhfdGltZV9hbGxvd2VkJ10gPSBzY29ybUlzc2V0KHNjby51c2VyZGF0YSwgJ21heF90aW1lX2FsbG93ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuc3R1ZGVudF9kYXRhLnRpbWVfbGltaXRfYWN0aW9uJ10gPSBzY29ybUlzc2V0KHNjby51c2VyZGF0YSwgJ3RpbWVfbGltaXRfYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUudG90YWxfdGltZSddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuY29yZS50b3RhbF90aW1lJywgJzAwOjAwOjAwJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmxhdW5jaF9kYXRhJ10gPSBsYXVuY2hVcmxzW3Njby5zY29pZF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IGhhbmRsZSBzdGFuZGFyZCB1c2VyZGF0YSBpdGVtcy5cbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5sZXNzb25fbG9jYXRpb24nXSA9IHNjb3JtSXNzZXQoc2NvLnVzZXJkYXRhLCAnY21pLmNvcmUubGVzc29uX2xvY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUubGVzc29uX3N0YXR1cyddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuY29yZS5sZXNzb25fc3RhdHVzJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUuc2NvcmUucmF3J10gPSBzY29ybUlzc2V0KHNjby51c2VyZGF0YSwgJ2NtaS5jb3JlLnNjb3JlLnJhdycpO1xuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5jb3JlLnNjb3JlLm1heCddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuY29yZS5zY29yZS5tYXgnKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuY29yZS5zY29yZS5taW4nXSA9IHNjb3JtSXNzZXQoc2NvLnVzZXJkYXRhLCAnY21pLmNvcmUuc2NvcmUubWluJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUuZXhpdCddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuY29yZS5leGl0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLnN1c3BlbmRfZGF0YSddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuc3VzcGVuZF9kYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvbW1lbnRzJ10gPSBzY29ybUlzc2V0KHNjby51c2VyZGF0YSwgJ2NtaS5jb21tZW50cycpO1xuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5zdHVkZW50X3ByZWZlcmVuY2UubGFuZ3VhZ2UnXSA9IHNjb3JtSXNzZXQoc2NvLnVzZXJkYXRhLCAnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS5sYW5ndWFnZScpO1xuICAgICAgICAgICAgICAgICAgICBzY28uZGVmYXVsdGRhdGFbJ2NtaS5zdHVkZW50X3ByZWZlcmVuY2UuYXVkaW8nXSA9IHNjb3JtSXNzZXQoc2NvLnVzZXJkYXRhLCAnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS5hdWRpbycsICcwJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YVsnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS5zcGVlZCddID0gc2Nvcm1Jc3NldChzY28udXNlcmRhdGEsICdjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLnNwZWVkJywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLmRlZmF1bHRkYXRhWydjbWkuc3R1ZGVudF9wcmVmZXJlbmNlLnRleHQnXSA9IHNjb3JtSXNzZXQoc2NvLnVzZXJkYXRhLCAnY21pLnN0dWRlbnRfcHJlZmVyZW5jZS50ZXh0JywgJzAnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTb21lIGRhdGEgbmVlZHMgdG8gYmUgYm90aCBpbiBkZWZhdWx0IGRhdGEgYW5kIHVzZXIgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgc2NvLnVzZXJkYXRhLnN0dWRlbnRfaWQgPSB1c2VybmFtZTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLnVzZXJkYXRhLnN0dWRlbnRfbmFtZSA9IGZ1bGxOYW1lO1xuICAgICAgICAgICAgICAgICAgICBzY28udXNlcmRhdGEubW9kZSA9IHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUubGVzc29uX21vZGUnXTtcbiAgICAgICAgICAgICAgICAgICAgc2NvLnVzZXJkYXRhLmNyZWRpdCA9IHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUuY3JlZGl0J107XG4gICAgICAgICAgICAgICAgICAgIHNjby51c2VyZGF0YS5lbnRyeSA9IHNjby5kZWZhdWx0ZGF0YVsnY21pLmNvcmUuZW50cnknXTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gaW5zZXJ0IGEgdHJhY2sgaW4gdGhlIERCLiBQbGVhc2UgZG8gbm90IHVzZSBpdCBkaXJlY3RseSwgdXNlIGluc2VydFRyYWNrIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRiICAgICAgICAgICBTaXRlJ3MgREIuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgICAgICAgVXNlciBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgICAgICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkICAgICAgICBTQ08gSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0ICAgICAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBlbGVtZW50ICAgICAgTmFtZSBvZiB0aGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtICB7TWl4ZWR9IHZhbHVlICAgICAgICAgVmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHN5bmNocm9ub3VzIFRydWUgaWYgaW5zZXJ0IHNob3VsZCBOT1QgcmV0dXJuIGEgcHJvbWlzZS4gUGxlYXNlIHVzZSBpdCBvbmx5IGlmIHN5bmNocm9ub3VzIGlzIGEgbXVzdC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufFByb21pc2V9ICAgICBSZXR1cm5zIGEgcHJvbWlzZSBpZiBzeW5jaHJvbm91cz1mYWxzZSwgb3RoZXJ3aXNlIHJldHVybnMgYSBib29sZWFuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFRyYWNrVG9EQihkYiwgdXNlcklkLCBzY29ybUlkLCBzY29JZCwgYXR0ZW1wdCwgZWxlbWVudCwgdmFsdWUsIHN5bmNocm9ub3VzKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgICAgIHVzZXJpZDogdXNlcklkLFxuICAgICAgICAgICAgc2Nvcm1pZDogc2Nvcm1JZCxcbiAgICAgICAgICAgIHNjb2lkOiBzY29JZCxcbiAgICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHQsXG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdGltZW1vZGlmaWVkOiAkbW1VdGlsLnRpbWVzdGFtcCgpLFxuICAgICAgICAgICAgc3luY2VkOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzeW5jaHJvbm91cykge1xuICAgICAgICAgICAgcmV0dXJuIGRiLmluc2VydFN5bmMobW1hTW9kU2Nvcm1PZmZsaW5lVHJhY2tzU3RvcmUsIGVudHJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYi5pbnNlcnQobW1hTW9kU2Nvcm1PZmZsaW5lVHJhY2tzU3RvcmUsIGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIHRyYWNrIGluIHRoZSBvZmZsaW5lIHRyYWNrcyBzdG9yZS5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIE1vb2RsZSdzIHNjb3JtX2luc2VydF90cmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbdXNlcklkXSAgICAgICAgVXNlciBJRC4gSWYgbm90IHNldCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgICAgICAgICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkICAgICAgICAgICBTQ08gSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0ICAgICAgICAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBlbGVtZW50ICAgICAgICAgTmFtZSBvZiB0aGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtICB7TWl4ZWR9IHZhbHVlICAgICAgICAgICAgVmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGZvcmNlQ29tcGxldGVkIFRydWUgaWYgU0NPUk0gZm9yY2VzIGNvbXBsZXRlZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtzY29EYXRhXSAgICAgICBVc2VyIGRhdGEgZm9yIHRoZSBnaXZlbiBTQ08uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBpbnNlcnQgaXMgZG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRUcmFjayhzaXRlSWQsIHVzZXJJZCwgc2Nvcm1JZCwgc2NvSWQsIGF0dGVtcHQsIGVsZW1lbnQsIHZhbHVlLCBmb3JjZUNvbXBsZXRlZCwgc2NvRGF0YSkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fMKgc2l0ZS5nZXRVc2VySWQoKTtcbiAgICAgICAgICAgIHNjb0RhdGEgPSBzY29EYXRhIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSwgLy8gTGlzdCBvZiBwcm9taXNlcyBmb3IgYWN0aW9ucyBwcmV2aW91cyB0byB0aGUgcmVhbCBpbnNlcnQuXG4gICAgICAgICAgICAgICAgbGVzc29uU3RhdHVzSW5zZXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBzY29Vc2VyRGF0YSA9IHNjb0RhdGEudXNlcmRhdGEgfHwge30sXG4gICAgICAgICAgICAgICAgZGIgPSBzaXRlLmdldERiKCk7XG5cbiAgICAgICAgICAgIGlmIChmb3JjZUNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09ICdjbWkuY29yZS5sZXNzb25fc3RhdHVzJyAmJiB2YWx1ZSA9PSAnaW5jb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb1VzZXJEYXRhWydjbWkuY29yZS5zY29yZS5yYXcnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnY29tcGxldGVkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PSAnY21pLmNvcmUuc2NvcmUucmF3Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvVXNlckRhdGFbJ2NtaS5jb3JlLmxlc3Nvbl9zdGF0dXMnXSA9PSAnaW5jb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlc3NvblN0YXR1c0luc2VydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goaW5zZXJ0VHJhY2tUb0RCKGRiLCB1c2VySWQsIHNjb3JtSWQsIHNjb0lkLCBhdHRlbXB0LCAnY21pLmNvcmUubGVzc29uX3N0YXR1cycsICdjb21wbGV0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIHguc3RhcnQudGltZSwga2VlcCB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKCFzY29Vc2VyRGF0YVtlbGVtZW50XSB8fCBlbGVtZW50ICE9ICd4LnN0YXJ0LnRpbWUnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydFRyYWNrVG9EQihkYiwgdXNlcklkLCBzY29ybUlkLCBzY29JZCwgYXR0ZW1wdCwgZWxlbWVudCwgdmFsdWUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlc3NvblN0YXR1c0luc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm9sbGJhY2sgcHJldmlvdXMgaW5zZXJ0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnNlcnRUcmFja1RvREIoZGIsIHVzZXJJZCwgc2Nvcm1JZCwgc2NvSWQsIGF0dGVtcHQsICdjbWkuY29yZS5sZXNzb25fc3RhdHVzJywgJ2luY29tcGxldGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIHRyYWNrIGluIHRoZSBvZmZsaW5lIHRyYWNrcyBzdG9yZSwgcmV0dXJuaW5nIGEgc3luY2hyb25vdXMgdmFsdWUuXG4gICAgICogUGxlYXNlIHVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgaWYgc3luY2hyb25vdXMgaXMgYSBtdXN0LiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSBpbnNlcnRUcmFjay5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIE1vb2RsZSdzIHNjb3JtX2luc2VydF90cmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW3VzZXJJZF0gICAgICAgIFVzZXIgSUQuIElmIG5vdCBzZXQgdXNlIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgICAgICAgICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkICAgICAgICAgICBTQ08gSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0ICAgICAgICAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBlbGVtZW50ICAgICAgICAgTmFtZSBvZiB0aGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtICB7TWl4ZWR9IHZhbHVlICAgICAgICAgICAgVmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGZvcmNlQ29tcGxldGVkIFRydWUgaWYgU0NPUk0gZm9yY2VzIGNvbXBsZXRlZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtzY29EYXRhXSAgICAgICBVc2VyIGRhdGEgZm9yIHRoZSBnaXZlbiBTQ08uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBpbnNlcnQgaXMgZG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRUcmFja1N5bmModXNlcklkLCBzY29ybUlkLCBzY29JZCwgYXR0ZW1wdCwgZWxlbWVudCwgdmFsdWUsIGZvcmNlQ29tcGxldGVkLCBzY29EYXRhKSB7XG4gICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fMKgJG1tU2l0ZS5nZXRVc2VySWQoKTtcbiAgICAgICAgc2NvRGF0YSA9IHNjb0RhdGEgfHwge307XG5cbiAgICAgICAgaWYgKCEkbW1TaXRlLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgICAgICAgLy8gTm90IGxvZ2dlZCBpbiwgd2UgY2FuJ3QgZ2V0IHRoZSBzaXRlIERCLiBVc2VyIGxvZ2dlZCBvdXQgb3Igc2Vzc2lvbiBleHBpcmVkIHdoaWxlIGFuIG9wZXJhdGlvbiB3YXMgb25nb2luZy5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZXNzb25TdGF0dXNJbnNlcnRlZCA9IGZhbHNlLFxuICAgICAgICAgICAgc2NvVXNlckRhdGEgPSBzY29EYXRhLnVzZXJkYXRhIHx8IHt9LFxuICAgICAgICAgICAgZGIgPSAkbW1TaXRlLmdldERiKCk7XG5cbiAgICAgICAgaWYgKGZvcmNlQ29tcGxldGVkKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PSAnY21pLmNvcmUubGVzc29uX3N0YXR1cycgJiYgdmFsdWUgPT0gJ2luY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjb1VzZXJEYXRhWydjbWkuY29yZS5zY29yZS5yYXcnXSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdjb21wbGV0ZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09ICdjbWkuY29yZS5zY29yZS5yYXcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjb1VzZXJEYXRhWydjbWkuY29yZS5sZXNzb25fc3RhdHVzJ10gPT0gJ2luY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlc3NvblN0YXR1c0luc2VydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnNlcnRUcmFja1RvREIoZGIsIHVzZXJJZCwgc2Nvcm1JZCwgc2NvSWQsIGF0dGVtcHQsICdjbWkuY29yZS5sZXNzb25fc3RhdHVzJywgJ2NvbXBsZXRlZCcsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCB1cGRhdGUgeC5zdGFydC50aW1lLCBrZWVwIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgICAgaWYgKCFzY29Vc2VyRGF0YVtlbGVtZW50XSB8fCBlbGVtZW50ICE9ICd4LnN0YXJ0LnRpbWUnKSB7XG4gICAgICAgICAgICBpZiAoIWluc2VydFRyYWNrVG9EQihkYiwgdXNlcklkLCBzY29ybUlkLCBzY29JZCwgYXR0ZW1wdCwgZWxlbWVudCwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGZhaWxlZC5cbiAgICAgICAgICAgICAgICBpZiAobGVzc29uU3RhdHVzSW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUm9sbGJhY2sgcHJldmlvdXMgaW5zZXJ0LlxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUcmFja1RvREIoZGIsIHVzZXJJZCwgc2Nvcm1JZCwgc2NvSWQsIGF0dGVtcHQsICdjbWkuY29yZS5sZXNzb25fc3RhdHVzJywgJ2luY29tcGxldGUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIFNDT1JNIGlzIGJsb2NrZWQgYnkgYSB3cml0aW5nIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjaXNTY29ybUJsb2NrZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgIFRydWUgaWYgYmxvY2tlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNTY29ybUJsb2NrZWQgPSBmdW5jdGlvbihzaXRlSWQsIHNjb3JtSWQpIHtcbiAgICAgICAgaWYgKCFibG9ja2VkU2Nvcm1zW3NpdGVJZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFibG9ja2VkU2Nvcm1zW3NpdGVJZF1bc2Nvcm1JZF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1hcmsgYWxsIHRoZSBlbnRyaWVzIGZyb20gYSBTQ08gYW5kIGF0dGVtcHQgYXMgc3luY2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjbWFya0FzU3luY2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3VzZXJJZF0gVXNlciBJRC4gSWYgbm90IGRlZmluZWQgdXNlIHNpdGUncyBjdXJyZW50IHVzZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb0lkICAgIFNDTyBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIG1hcmtlZC5cbiAgICAgKi9cbiAgICBzZWxmLm1hcmtBc1N5bmNlZCA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdXNlcklkLCBzY29JZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ01hcmsgU0NPICcgKyBzY29JZCArICcgYXMgc3luY2VkIGZvciBhdHRlbXB0ICcgKyBhdHRlbXB0ICsgJyBpbiBTQ09STSAnICsgc2Nvcm1JZCk7XG4gICAgICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgc2l0ZS5nZXRVc2VySWQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2Nvcm1TdG9yZWREYXRhKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdXNlcklkLCB0cnVlKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgZGIgPSBzaXRlLmdldERiKCk7XG5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnNjb2lkID09IHNjb0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zeW5jZWQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYi5pbnNlcnQobW1hTW9kU2Nvcm1PZmZsaW5lVHJhY2tzU3RvcmUsIGVudHJ5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBkZWZhdWx0IGRhdGEgZm9ybSB1c2VyIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHVzZXJEYXRhIFVzZXIgZGF0YSByZXR1cm5lZCBieSAkbW1hTW9kU2Nvcm0jZ2V0U2Nvcm1Vc2VyRGF0YS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIFVzZXIgZGF0YSB3aXRob3V0IGRlZmF1bHQgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVEZWZhdWx0RGF0YSh1c2VyRGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYW5ndWxhci5jb3B5KHVzZXJEYXRhKTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc3VsdCwgZnVuY3Rpb24oc2NvKSB7XG4gICAgICAgICAgICBkZWxldGUgc2NvLmRlZmF1bHRkYXRhO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyBhIFNDT1JNIHRyYWNraW5nIHJlY29yZCBpbiBvZmZsaW5lLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjc2F2ZVRyYWNrc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlSWQgICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2Nvcm0gICAgICBTQ09STS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkICAgICAgU2NvIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCAgICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gdHJhY2tzICAgVHJhY2tpbmcgZGF0YSB0byBzdG9yZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHVzZXJEYXRhICAgVXNlciBkYXRhIGZvciB0aGlzIGF0dGVtcHQgYW5kIFNDTy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGRhdGEgaXMgc2F2ZWQuXG4gICAgICovXG4gICAgc2VsZi5zYXZlVHJhY2tzID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybSwgc2NvSWQsIGF0dGVtcHQsIHRyYWNrcywgdXNlckRhdGEpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkID0gc2l0ZS5nZXRVc2VySWQoKSxcbiAgICAgICAgICAgICAgICBpbml0aWFsQmxvY2tlZDtcblxuICAgICAgICAgICAgaWYgKCFibG9ja2VkU2Nvcm1zW3NpdGVJZF0pIHtcbiAgICAgICAgICAgICAgICBibG9ja2VkU2Nvcm1zW3NpdGVJZF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaXRpYWxCbG9ja2VkID0gISFibG9ja2VkU2Nvcm1zW3NpdGVJZF1bc2Nvcm0uaWRdOyAvLyBTYXZlIGluaXRpYWwgYmxvY2tlZCBzdGF0ZS5cbiAgICAgICAgICAgIGJsb2NrZWRTY29ybXNbc2l0ZUlkXVtzY29ybS5pZF0gPSB0cnVlOyAvLyBCbG9jayB0aGUgU0NPUk0gc28gaXQgY2FuJ3QgYmUgc3luY2VkLlxuXG4gICAgICAgICAgICAvLyBJbnNlcnQgYWxsIHRoZSB0cmFja3MuXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh0cmFja3MsIGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChpbnNlcnRUcmFjayhzaXRlSWQsIHVzZXJJZCwgc2Nvcm0uaWQsIHNjb0lkLCBhdHRlbXB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5lbGVtZW50LCB0cmFjay52YWx1ZSwgc2Nvcm0uZm9yY2Vjb21wbGV0ZWQsIHVzZXJEYXRhW3Njb0lkXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghaW5pdGlhbEJsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tlZFNjb3Jtc1tzaXRlSWRdW3Njb3JtLmlkXSA9IGZhbHNlOyAvLyBVbmJsb2NrIHRoZSBTQ09STSBvbmx5IGlmIGl0IHdhc24ndCBibG9ja2VkIGJ5IGFub3RoZXIgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyBhIFNDT1JNIHRyYWNraW5nIHJlY29yZCBpbiBvZmZsaW5lIHJldHVybmluZyBhIHN5bmNocm9ub3VzIHZhbHVlLlxuICAgICAqIFBsZWFzZSB1c2UgdGhpcyBmdW5jdGlvbiBvbmx5IGlmIHN5bmNocm9ub3VzIGlzIGEgbXVzdC4gSXQncyByZWNvbW1lbmRlZCB0byB1c2UgJG1tYU1vZFNjb3JtT2ZmbGluZSNzYXZlVHJhY2tzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjc2F2ZVRyYWNrc1N5bmNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtICAgIFNDT1JNLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvSWQgICAgU2NvIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCAgQXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHBhcmFtICB7T2JqZWN0W119IHRyYWNrcyBUcmFja2luZyBkYXRhIHRvIHN0b3JlLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdXNlckRhdGEgVXNlciBkYXRhIGZvciB0aGlzIGF0dGVtcHQgYW5kIFNDTy5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgIFRydWUgaWYgZGF0YSB0byBpbnNlcnQgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS4gUmV0dXJuaW5nIHRydWUgZG9lc24ndCBtZWFuIHRoYXQgdGhlIGRhdGFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBiZWVuIHN0b3JlZCwgdGhpcyBmdW5jdGlvbiBjYW4gcmV0dXJuIHRydWUgYnV0IHRoZSBpbnNlcnRpb24gY2FuIHN0aWxsIGZhaWwgc29tZWhvdy5cbiAgICAgKi9cbiAgICBzZWxmLnNhdmVUcmFja3NTeW5jID0gZnVuY3Rpb24oc2Nvcm0sIHNjb0lkLCBhdHRlbXB0LCB0cmFja3MsIHVzZXJEYXRhKSB7XG4gICAgICAgIHZhciB1c2VySWQgPSAkbW1TaXRlLmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHRyYWNrcywgZnVuY3Rpb24odHJhY2spIHtcbiAgICAgICAgICAgIGlmICghaW5zZXJ0VHJhY2tTeW5jKHVzZXJJZCwgc2Nvcm0uaWQsIHNjb0lkLCBhdHRlbXB0LCB0cmFjay5lbGVtZW50LCB0cmFjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JtLmZvcmNlY29tcGxldGVkLCB1c2VyRGF0YVtzY29JZF0pKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBhIHBhcmFtZXRlciBpbiB1c2VyZGF0YSBhbmQgcmV0dXJuIGl0IGlmIGl0J3Mgc2V0IG9yIHJldHVybiAnaWZlbXB0eScgaWYgaXQncyBlbXB0eS5cbiAgICAgKiBCYXNlZCBvbiBNb29kbGUncyBzY29ybV9pc3NldCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdXNlcmRhdGEgIENvbnRhaW5zIHVzZXIncyBkYXRhLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGFyYW0gICAgIE5hbWUgb2YgcGFyYW1ldGVyIHRoYXQgc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgICogQHBhcmFtICB7TWl4ZWR9ICBbaWZlbXB0eV0gVmFsdWUgdG8gYmUgcmVwbGFjZWQgd2l0aCBpZiBwYXJhbSBpcyBub3Qgc2V0LlxuICAgICAqIEByZXR1cm4ge01peGVkfSAgICAgICAgICAgIFZhbHVlIGZyb20gdXNlcmRhdGFbcGFyYW1dIGlmIHNldCwgaWZlbXB0eSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2Nvcm1Jc3NldCh1c2VyZGF0YSwgcGFyYW0sIGlmZW1wdHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZmVtcHR5ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZmVtcHR5ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJkYXRhW3BhcmFtXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJkYXRhW3BhcmFtXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWZlbXB0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYW4gYXR0ZW1wdCdzIHNuYXBzaG90LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9mZmxpbmUjc2V0QXR0ZW1wdFNuYXBzaG90XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0ICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlckRhdGEgVXNlciBkYXRhIHRvIHN0b3JlIGFzIHNuYXBzaG90LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHNuYXBzaG90IGhhcyBiZWVuIHN0b3JlZC5cbiAgICAgKi9cbiAgICBzZWxmLnNldEF0dGVtcHRTbmFwc2hvdCA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdXNlckRhdGEsIHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ1NldCBzbmFwc2hvdCBmb3IgYXR0ZW1wdCAnICsgYXR0ZW1wdCArICcgaW4gU0NPUk0gJyArIHNjb3JtSWQpO1xuICAgICAgICAgICAgdXNlcklkID0gdXNlcklkIHx8IHNpdGUuZ2V0VXNlcklkKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzaXRlLmdldERiKCkuZ2V0KG1tYU1vZFNjb3JtT2ZmbGluZUF0dGVtcHRzU3RvcmUsIFtzY29ybUlkLCB1c2VySWQsIGF0dGVtcHRdKS50aGVuKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgZW50cnkuc25hcHNob3QgPSByZW1vdmVEZWZhdWx0RGF0YSh1c2VyRGF0YSk7XG4gICAgICAgICAgICAgICAgZW50cnkudGltZW1vZGlmaWVkID0gJG1tVXRpbC50aW1lc3RhbXAoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l0ZS5nZXREYigpLmluc2VydChtbWFNb2RTY29ybU9mZmxpbmVBdHRlbXB0c1N0b3JlLCBlbnRyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2Rfc2Nvcm0nKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gaGFuZGxlIFNDT1JNIG9ubGluZSBmZWF0dXJlcy5cbiAqIFRoaXMgc2VydmljZSBob2xkcyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgaGF2ZSBzb21lIGtpbmQgb2YgZXF1aXZhbGVudCBmZWF0dXJlIGluICRtbWFNb2RTY29ybU9mZmxpbmUuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZFNjb3JtT25saW5lXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kU2Nvcm1PbmxpbmUnLCBmdW5jdGlvbigkbW1TaXRlc01hbmFnZXIsICRtbVNpdGUsICRxLCAkbW1XUywgJGxvZywgbW1Db3JlV1NQcmVmaXgpIHtcbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU1vZFNjb3JtT25saW5lJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBibG9ja2VkU2Nvcm1zID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBibG9ja2VkIFNDT1JNcy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PbmxpbmUjY2xlYXJCbG9ja2VkU2Nvcm1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIElmIHNldCwgY2xlYXIgdGhlIGJsb2NrZWQgU0NPUk1zIG9ubHkgZm9yIHRoaXMgc2l0ZS4gT3RoZXJ3aXNlIGNsZWFyIGFsbCBTQ09STXMuXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBzZWxmLmNsZWFyQmxvY2tlZFNjb3JtcyA9IGZ1bmN0aW9uKHNpdGVJZCkge1xuICAgICAgICBpZiAoc2l0ZUlkKSB7XG4gICAgICAgICAgICBkZWxldGUgYmxvY2tlZFNjb3Jtc1tzaXRlSWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmxvY2tlZFNjb3JtcyA9IHt9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIFNDT1JNIGF0dGVtcHQgY291bnQgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHVzZXIuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBdHRlbXB0Q291bnRDYWNoZUtleShzY29ybUlkLCB1c2VySWQpIHtcbiAgICAgICAgdXNlcklkID0gdXNlcklkIHx8ICRtbVNpdGUuZ2V0VXNlcklkKCk7XG4gICAgICAgIHJldHVybiAnbW1hTW9kU2Nvcm06YXR0ZW1wdGNvdW50OicgKyBzY29ybUlkICsgJzonICsgdXNlcklkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzIGRvbmUgYnkgYSB1c2VyIGluIHRoZSBnaXZlbiBTQ09STS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zY29ybVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU2Nvcm1PbmxpbmUjZ2V0QXR0ZW1wdENvdW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgICAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdXNlcklkXSAgICAgICBVc2VyIElELiBJZiBub3QgZGVmaW5lZCB1c2Ugc2l0ZSdzIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZU1pc3NpbmcgVHJ1ZSBpZiBpdCBzaG91bGQgaWdub3JlIGF0dGVtcHRzIHRoYXQgaGF2ZW4ndCByZXBvcnRlZCBhIGdyYWRlL2NvbXBsZXRpb24uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSAgIFRydWUgaWYgaXQgc2hvdWxkIGlnbm9yZSBjYWNoZWQgZGF0YSAoaXQgd2lsbCBhbHdheXMgZmFpbCBpbiBvZmZsaW5lIG9yIHNlcnZlciBkb3duKS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBhdHRlbXB0IGNvdW50IGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBzZWxmLmdldEF0dGVtcHRDb3VudCA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCwgdXNlcklkLCBpZ25vcmVNaXNzaW5nLCBpZ25vcmVDYWNoZSkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHVzZXJJZCA9IHVzZXJJZCB8fCBzaXRlLmdldFVzZXJJZCgpO1xuXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29ybWlkOiBzY29ybUlkLFxuICAgICAgICAgICAgICAgICAgICB1c2VyaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlbWlzc2luZ2NvbXBsZXRpb246IGlnbm9yZU1pc3NpbmcgPyAxIDogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldEF0dGVtcHRDb3VudENhY2hlS2V5KHNjb3JtSWQsIHVzZXJJZClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaWdub3JlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBwcmVTZXRzLmdldEZyb21DYWNoZSA9IDA7XG4gICAgICAgICAgICAgICAgcHJlU2V0cy5lbWVyZ2VuY3lDYWNoZSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzaXRlLnJlYWQoJ21vZF9zY29ybV9nZXRfc2Nvcm1fYXR0ZW1wdF9jb3VudCcsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UuYXR0ZW1wdHNjb3VudCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXR0ZW1wdHNjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBTQ09STSB1c2VyIGRhdGEgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICBDYWNoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2Nvcm1Vc2VyRGF0YUNhY2hlS2V5KHNjb3JtSWQsIGF0dGVtcHQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNjb3JtVXNlckRhdGFDb21tb25DYWNoZUtleShzY29ybUlkKSArICc6JyArIGF0dGVtcHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbW1vbiBjYWNoZSBrZXkgZm9yIFNDT1JNIHVzZXIgZGF0YSBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkIFNDT1JNIElELlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY29ybVVzZXJEYXRhQ29tbW9uQ2FjaGVLZXkoc2Nvcm1JZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZFNjb3JtOnVzZXJkYXRhOicgKyBzY29ybUlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdXNlciBkYXRhIGZvciBhIGNlcnRhaW4gU0NPUk0gYW5kIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT25saW5lI2dldFNjb3JtVXNlckRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgICAgICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCAgICAgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgVHJ1ZSBpZiBpdCBzaG91bGQgaWdub3JlIGNhY2hlZCBkYXRhIChpdCB3aWxsIGFsd2F5cyBmYWlsIGluIG9mZmxpbmUgb3Igc2VydmVyIGRvd24pLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSB1c2VyIGRhdGEgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0U2Nvcm1Vc2VyRGF0YSA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgaWdub3JlQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29ybWlkOiBzY29ybUlkLFxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZ2V0U2Nvcm1Vc2VyRGF0YUNhY2hlS2V5KHNjb3JtSWQsIGF0dGVtcHQpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGlnbm9yZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgcHJlU2V0cy5nZXRGcm9tQ2FjaGUgPSAwO1xuICAgICAgICAgICAgICAgIHByZVNldHMuZW1lcmdlbmN5Q2FjaGUgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2l0ZS5yZWFkKCdtb2Rfc2Nvcm1fZ2V0X3Njb3JtX3VzZXJfZGF0YScsIHBhcmFtcywgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNwb25zZS5kYXRhLCBmdW5jdGlvbihzY28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWREZWZhdWx0RGF0YSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFVzZXJEYXRhID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY28uZGVmYXVsdGRhdGEsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkRGVmYXVsdERhdGFbZW50cnkuZWxlbWVudF0gPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjby51c2VyZGF0YSwgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRVc2VyRGF0YVtlbnRyeS5lbGVtZW50XSA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjby5kZWZhdWx0ZGF0YSA9IGZvcm1hdHRlZERlZmF1bHREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvLnVzZXJkYXRhID0gZm9ybWF0dGVkVXNlckRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbc2NvLnNjb2lkXSA9IHNjbztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIGF0dGVtcHQgY291bnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT25saW5lI2ludmFsaWRhdGVBdHRlbXB0Q291bnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nvcm1JZCAgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt1c2VySWRdIFVzZXIgSUQuIElmIG5vdCBkZWZpbmVkIHVzZSBzaXRlJ3MgY3VycmVudCB1c2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlQXR0ZW1wdENvdW50ID0gZnVuY3Rpb24oc2l0ZUlkLCBzY29ybUlkLCB1c2VySWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVJZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgc2l0ZS5nZXRVc2VySWQoKTtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5KGdldEF0dGVtcHRDb3VudENhY2hlS2V5KHNjb3JtSWQsIHVzZXJJZCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgU0NPUk0gdXNlciBkYXRhIGZvciBhbGwgYXR0ZW1wdHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT25saW5lI2ludmFsaWRhdGVTY29ybVVzZXJEYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpdGVJZCAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlU2Nvcm1Vc2VyRGF0YSA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXRlLmludmFsaWRhdGVXc0NhY2hlRm9yS2V5U3RhcnRpbmdXaXRoKGdldFNjb3JtVXNlckRhdGFDb21tb25DYWNoZUtleShzY29ybUlkKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIFNDT1JNIGlzIGJsb2NrZWQgYnkgYSB3cml0aW5nIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybU9ubGluZSNpc1Njb3JtQmxvY2tlZFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgU2l0ZSBJRC4gSWYgbm90IHNldCwgdXNlIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgVHJ1ZSBpZiBibG9ja2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1Njb3JtQmxvY2tlZCA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCkge1xuICAgICAgICBpZiAoIWJsb2NrZWRTY29ybXNbc2l0ZUlkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIWJsb2NrZWRTY29ybXNbc2l0ZUlkXVtzY29ybUlkXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgYSBTQ09STSB0cmFja2luZyByZWNvcmQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT25saW5lI3NhdmVUcmFja3NcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgIFNpdGUgSUQuIElmIG5vdCBzZXQsIHVzZSBjdXJyZW50IHNpdGUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb0lkICAgIFNjbyBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSAge09iamVjdFtdfSB0cmFja3MgVHJhY2tpbmcgZGF0YS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBkYXRhIGlzIHNhdmVkLlxuICAgICAqL1xuICAgIHNlbGYuc2F2ZVRyYWNrcyA9IGZ1bmN0aW9uKHNpdGVJZCwgc2Nvcm1JZCwgc2NvSWQsIGF0dGVtcHQsIHRyYWNrcykge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgc2NvaWQ6IHNjb0lkLFxuICAgICAgICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHQsXG4gICAgICAgICAgICAgICAgdHJhY2tzOiB0cmFja3NcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghdHJhY2tzIHx8ICF0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTsgLy8gTm90aGluZyB0byBzYXZlLlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWJsb2NrZWRTY29ybXNbc2l0ZUlkXSkge1xuICAgICAgICAgICAgICAgIGJsb2NrZWRTY29ybXNbc2l0ZUlkXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2tlZFNjb3Jtc1tzaXRlSWRdW3Njb3JtSWRdID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIHNpdGUud3JpdGUoJ21vZF9zY29ybV9pbnNlcnRfc2Nvcm1fdHJhY2tzJywgcGFyYW1zKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnRyYWNraWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50cmFja2lkcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBibG9ja2VkU2Nvcm1zW3NpdGVJZF1bc2Nvcm1JZF0gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgYSBTQ09STSB0cmFja2luZyByZWNvcmQgdXNpbmcgYSBzeW5jaHJvbm91cyBjYWxsLlxuICAgICAqIFBsZWFzZSB1c2UgdGhpcyBmdW5jdGlvbiBvbmx5IGlmIHN5bmNocm9ub3VzIGlzIGEgbXVzdC4gSXQncyByZWNvbW1lbmRlZCB0byB1c2UgJG1tYU1vZFNjb3JtI3NhdmVUcmFja3MuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtT25saW5lI3NhdmVUcmFja3NTeW5jXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29JZCAgICBTY28gSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0ICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gdHJhY2tzIFRyYWNraW5nIGRhdGEuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICBUcnVlIGlmIHN1Y2Nlc3MsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLnNhdmVUcmFja3NTeW5jID0gZnVuY3Rpb24oc2NvSWQsIGF0dGVtcHQsIHRyYWNrcykge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHNjb2lkOiBzY29JZCxcbiAgICAgICAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0LFxuICAgICAgICAgICAgICAgIHRyYWNrczogdHJhY2tzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU2V0cyA9IHtcbiAgICAgICAgICAgICAgICBzaXRldXJsOiAkbW1TaXRlLmdldFVSTCgpLFxuICAgICAgICAgICAgICAgIHdzdG9rZW46ICRtbVNpdGUuZ2V0VG9rZW4oKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdzRnVuY3Rpb24gPSAkbW1TaXRlLmdldENvbXBhdGlibGVGdW5jdGlvbignbW9kX3Njb3JtX2luc2VydF9zY29ybV90cmFja3MnKSxcbiAgICAgICAgICAgIHJlc3BvbnNlO1xuXG4gICAgICAgIGlmICghdHJhY2tzIHx8ICF0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm90aGluZyB0byBzYXZlLlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1ldGhvZCBpcyBhdmFpbGFibGUsIHVzZSBhIHByZWZpeGVkIHZlcnNpb24gaWYgcG9zc2libGUuXG4gICAgICAgIGlmICghJG1tU2l0ZS53c0F2YWlsYWJsZSh3c0Z1bmN0aW9uLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIGlmICgkbW1TaXRlLndzQXZhaWxhYmxlKG1tQ29yZVdTUHJlZml4ICsgd3NGdW5jdGlvbiwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgd3NGdW5jdGlvbiA9IG1tQ29yZVdTUHJlZml4ICsgd3NGdW5jdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJGxvZy5lcnJvcihcIldTIGZ1bmN0aW9uICdcIiArIHdzRnVuY3Rpb24gKyBcIicgaXMgbm90IGF2YWlsYWJsZSwgZXZlbiBpbiBjb21wYXRpYmlsaXR5IG1vZGUuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BvbnNlID0gJG1tV1Muc3luY0NhbGwod3NGdW5jdGlvbiwgcGFyYW1zLCBwcmVTZXRzKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmICFyZXNwb25zZS5lcnJvciAmJiByZXNwb25zZS50cmFja2lkcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3Njb3JtJylcblxuLmNvbnN0YW50KCdtbWFNb2RTY29ybVN5bmNocm9uaXphdGlvblN0b3JlJywgJ21vZF9zY29ybV9zeW5jJylcblxuLmNvbmZpZyhmdW5jdGlvbigkbW1TaXRlc0ZhY3RvcnlQcm92aWRlciwgbW1hTW9kU2Nvcm1TeW5jaHJvbml6YXRpb25TdG9yZSkge1xuICAgIHZhciBzdG9yZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1tYU1vZFNjb3JtU3luY2hyb25pemF0aW9uU3RvcmUsXG4gICAgICAgICAgICBrZXlQYXRoOiAnc2Nvcm1pZCcsXG4gICAgICAgICAgICBpbmRleGVzOiBbXVxuICAgICAgICB9XG4gICAgXTtcbiAgICAkbW1TaXRlc0ZhY3RvcnlQcm92aWRlci5yZWdpc3RlclN0b3JlcyhzdG9yZXMpO1xufSlcblxuLyoqXG4gKiBTQ09STSBzeW5jaHJvbml6YXRpb24gc2VydmljZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kU2Nvcm1TeW5jXG4gKi9cbi5mYWN0b3J5KCckbW1hTW9kU2Nvcm1TeW5jJywgZnVuY3Rpb24oJG1tYU1vZFNjb3JtLCAkbW1TaXRlLCAkcSwgJHRyYW5zbGF0ZSwgJG1tYU1vZFNjb3JtT25saW5lLCAkbW1hTW9kU2Nvcm1PZmZsaW5lLCAkbW1VdGlsLFxuICAgICAgICAgICAgJGxvZywgbW1hTW9kU2Nvcm1TeW5jaHJvbml6YXRpb25TdG9yZSwgbW1hTW9kU2Nvcm1TeW5jVGltZSwgJG1tQ29uZmlnLCBtbUNvcmVTZXR0aW5nc1N5bmNPbmx5T25XaWZpLCAkbW1BcHAsXG4gICAgICAgICAgICAkbW1FdmVudHMsIG1tYU1vZFNjb3JtRXZlbnRBdXRvbVN5bmNlZCwgJG1tU2l0ZXNNYW5hZ2VyKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFNb2RTY29ybVN5bmMnKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIHN5bmNQcm9taXNlcyA9IHt9OyAvLyBTdG9yZSBzeW5jIHByb21pc2VzLlxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzeW5jaHJvbml6YXRpb24gdGltZSBvZiBhIFNDT1JNLiBSZXR1cm5zIDAgaWYgbm8gdGltZSBzdG9yZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtU3luYyNnZXRTY29ybVN5bmNUaW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHRpbWUuXG4gICAgICovXG4gICAgc2VsZi5nZXRTY29ybVN5bmNUaW1lID0gZnVuY3Rpb24oc2Nvcm1JZCwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZURiKHNpdGVJZCkudGhlbihmdW5jdGlvbihkYikge1xuICAgICAgICAgICAgcmV0dXJuIGRiLmdldChtbWFNb2RTY29ybVN5bmNocm9uaXphdGlvblN0b3JlLCBzY29ybUlkKS50aGVuKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnRpbWU7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzeW5jaHJvbml6YXRpb24gdGltZSBvZiBhIFNDT1JNLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybVN5bmMjc2V0U2Nvcm1TeW5jVGltZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVdICAgVGltZSB0byBzZXQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHRpbWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgdGltZSBpcyBzZXQuXG4gICAgICovXG4gICAgc2VsZi5zZXRTY29ybVN5bmNUaW1lID0gZnVuY3Rpb24oc2Nvcm1JZCwgc2l0ZUlkLCB0aW1lKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHJldHVybiAkbW1TaXRlc01hbmFnZXIuZ2V0U2l0ZURiKHNpdGVJZCkudGhlbihmdW5jdGlvbihkYikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRiLmluc2VydChtbWFNb2RTY29ybVN5bmNocm9uaXphdGlvblN0b3JlLCB7c2Nvcm1pZDogc2Nvcm1JZCwgdGltZTogdGltZX0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJ5IHRvIHN5bmNocm9uaXplIGFsbCBTQ09STXMgZnJvbSBjdXJyZW50IHNpdGUgdGhhdCBuZWVkIGl0IGFuZCBoYXZlbid0IGJlZW4gc3luY2hyb25pemVkIGluIGEgd2hpbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtU3luYyNzeW5jQWxsU2Nvcm1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQgdG8gc3luYy4gSWYgbm90IGRlZmluZWQsIHN5bmMgYWxsIHNpdGVzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHN5bmMgaXMgZG9uZS5cbiAgICAgKi9cbiAgICBzZWxmLnN5bmNBbGxTY29ybXMgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgaWYgKCEkbW1BcHAuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQ2Fubm90IHN5bmMgYWxsIFNDT1JNcyBiZWNhdXNlIGRldmljZSBpcyBvZmZsaW5lLicpO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZmlyc3QgY2hlY2sgc3luYyBzZXR0aW5ncyBhbmQgY3VycmVudCBjb25uZWN0aW9uIHRvIHNlZSBpZiB3ZSBjYW4gc3luYy5cbiAgICAgICAgcmV0dXJuICRtbUNvbmZpZy5nZXQobW1Db3JlU2V0dGluZ3NTeW5jT25seU9uV2lmaSwgdHJ1ZSkudGhlbihmdW5jdGlvbihzeW5jT25seU9uV2lmaSkge1xuXG4gICAgICAgICAgICBpZiAoc3luY09ubHlPbldpZmkgJiYgJG1tQXBwLmlzTmV0d29ya0FjY2Vzc0xpbWl0ZWQoKSkge1xuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ0Nhbm5vdCBzeW5jIGFsbCBTQ09STXMgYmVjYXVzZSBkZXZpY2UgaXNuXFwndCB1c2luZyBhIFdpRmkgbmV0d29yay4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKCFzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzaXRlIElEIGRlZmluZWQsIHN5bmMgYWxsIHNpdGVzLlxuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1RyeSB0byBzeW5jIFNDT1JNcyBpbiBhbGwgc2l0ZXMuJyk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlc0lkcygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdUcnkgdG8gc3luYyBTQ09STXMgaW4gc2l0ZSAnICsgc2l0ZUlkKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihbc2l0ZUlkXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2l0ZUlkcykge1xuICAgICAgICAgICAgICAgIHZhciBzaXRlUHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzaXRlSWRzLCBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l0ZVByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtT2ZmbGluZS5nZXRBbGxBdHRlbXB0cyhzaXRlSWQpLnRoZW4oZnVuY3Rpb24oYXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY29ybXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHMgPSBbXSwgLy8gVG8gcHJldmVudCBkdXBsaWNhdGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgSURzIG9mIGFsbCB0aGUgU0NPUk1zIHRoYXQgaGF2ZSBzb21ldGhpbmcgdG8gYmUgc3luY2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGF0dGVtcHRzLCBmdW5jdGlvbihhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkcy5pbmRleE9mKGF0dGVtcHQuc2Nvcm1pZCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goYXR0ZW1wdC5zY29ybWlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nvcm1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGF0dGVtcHQuc2Nvcm1pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdXJzZWlkOiBhdHRlbXB0LmNvdXJzZWlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTeW5jIGFsbCBTQ09STXMgdGhhdCBoYXZlbid0IGJlZW4gc3luY2VkIGZvciBhIHdoaWxlIGFuZCB0aGF0IGFyZW4ndCBwbGF5ZWQgcmlnaHQgbm93LlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNjb3JtcywgZnVuY3Rpb24oc2Nvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISRtbWFNb2RTY29ybS5pc1Njb3JtQmVpbmdQbGF5ZWQoc2Nvcm0uaWQsIHNpdGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm1CeUlkKHNjb3JtLmNvdXJzZWlkLCBzY29ybS5pZCwgJycsIHNpdGVJZCkudGhlbihmdW5jdGlvbihzY29ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3luY1Njb3JtSWZOZWVkZWQoc2Nvcm0sIHNpdGVJZCkudGhlbihmdW5jdGlvbih3YXJuaW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2FybmluZ3MgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgdHJpZWQgdG8gc3luYy4gU2VuZCBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tRXZlbnRzLnRyaWdnZXIobW1hTW9kU2Nvcm1FdmVudEF1dG9tU3luY2VkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXRlaWQ6IHNpdGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JtaWQ6IHNjb3JtLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEuYWxsKHNpdGVQcm9taXNlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIGEgU0NPUk0gb2ZmbGluZSBhdHRlbXB0IHRvIHRoZSBzaXRlLlxuICAgICAqIFJlc2VydmVkIGZvciBjb3JlIHVzZSwgcGxlYXNlIHVzZSAkbW1hTW9kU2Nvcm1TeW5jI3N5bmNTY29ybSB0byBzeW5jaHJvbml6ZSBTQ09STSBkYXRhLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybVN5bmMjX3N5bmNBdHRlbXB0XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29ybUlkICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGF0dGVtcHQgIEF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgYXR0ZW1wdCBpcyBzdWNjZXNzZnVsbHkgc3luY2VkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9zeW5jQXR0ZW1wdCA9IGZ1bmN0aW9uKHNjb3JtSWQsIGF0dGVtcHQsIHNpdGVJZCkge1xuICAgICAgICBzaXRlSWQgPSBzaXRlSWQgfHwgJG1tU2l0ZS5nZXRJZCgpO1xuICAgICAgICAkbG9nLmRlYnVnKCdUcnkgdG8gc3luYyBhdHRlbXB0ICcgKyBhdHRlbXB0ICsgJyBpbiBTQ09STSAnICsgc2Nvcm1JZCArICcgYW5kIHNpdGUgJyArIHNpdGVJZCk7XG4gICAgICAgIC8vIEdldCBvbmx5IG5vdCBzeW5jZWQgZW50cmllcy5cbiAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9mZmxpbmUuZ2V0U2Nvcm1TdG9yZWREYXRhKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdW5kZWZpbmVkLCB0cnVlKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgIHZhciBzY29zID0ge30sXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBzb21ldGhpbmdTeW5jZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gR2V0IGRhdGEgdG8gc2VuZCAob25seSBlbGVtZW50cyB3aXRoIGRvdHMgbGlrZSBjbWkuY29yZS5leGl0LCBpbiBNb2JpbGUgd2Ugc3RvcmUgbW9yZSBkYXRhIHRvIG1ha2Ugb2ZmbGluZSB3b3JrKS5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5lbGVtZW50LmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2Nvc1tlbnRyeS5zY29pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3NbZW50cnkuc2NvaWRdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Nvc1tlbnRyeS5zY29pZF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbnRyeS5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NvcywgZnVuY3Rpb24odHJhY2tzLCBzY29JZCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtT25saW5lLnNhdmVUcmFja3Moc2l0ZUlkLCBzY29ybUlkLCBzY29JZCwgYXR0ZW1wdCwgdHJhY2tzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTY28gZGF0YSBzdWNjZXNzZnVsbHkgc2VudC4gTWFyayB0aGVtIGFzIHN5bmNlZC4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBzb21lIFNDT3Mgc3luYyBtaWdodCBmYWlsLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5tYXJrQXNTeW5jZWQoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCB1bmRlZmluZWQsIHNjb0lkKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb21ldGhpbmdTeW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICRtbVV0aWwuYWxsUHJvbWlzZXMocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCBoYXMgYmVlbiBzZW50LiBMZXQncyBkZWxldGUgaXQgZnJvbSBsb2NhbC5cbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5kZWxldGVBdHRlbXB0KHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhaWxlZCB0byBkZWxldGUgKHNob3VsZG4ndCBoYXBwZW4pLiBMZXQncyByZXRyeSBvbmNlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5kZWxldGVBdHRlbXB0KHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXliZSB0aGVyZSdzIHNvbWV0aGluZyB3cm9uZyB3aXRoIHRoZSBkYXRhIG9yIHRoZSBzdG9yYWdlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignQWZ0ZXIgc3luYzogZXJyb3IgZGVsZXRpbmcgYXR0ZW1wdCAnICsgYXR0ZW1wdCArICcgaW4gU0NPUk0gJyArIHNjb3JtSWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzb21ldGhpbmdTeW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU29tZSBTQ09zIGhhdmUgYmVlbiBzeW5jZWQgYW5kIHNvbWUgbm90LiBXZSdsbCB0cnkgdG8gc3RvcmUgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSBhYmxlIHRvIHJlLXRyeSB0aGUgc3luY2hyb25pemF0aW9uIGxhdGVyLlxuICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdFcnJvciBzeW5jaHJvbml6aW5nIHNvbWUgU0NPcyBmb3IgYXR0ZW1wdCAnICsgYXR0ZW1wdCArICcgaW4gU0NPUk0gJyArIHNjb3JtSWQgKyAnLiBTYXZpbmcgc25hcHNob3QuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzYXZlU3luY1NuYXBzaG90KHNjb3JtSWQsIGF0dGVtcHQsIHNpdGVJZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRXJyb3Igc3luY2hyb25pemluZyBhdHRlbXB0ICcgKyBhdHRlbXB0ICsgJyBpbiBTQ09STSAnICsgc2Nvcm1JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2F2ZSBhIHNuYXBzaG90IGZyb20gYSBzeW5jaHJvbml6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgU0NPUk0gSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhdHRlbXB0IEF0dGVtb3QgbnVtYmVyLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICBTaXRlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHNuYXBzaG90IGlzIHN0b3JlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYXZlU3luY1NuYXBzaG90KHNjb3JtSWQsIGF0dGVtcHQsIHNpdGVJZCkge1xuICAgICAgICAvLyBUcnkgdG8gZ2V0IGN1cnJlbnQgc3RhdGUgZnJvbSBNb29kbGUuXG4gICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm1Vc2VyRGF0YShzY29ybUlkLCBhdHRlbXB0LCBmYWxzZSwgc2l0ZUlkLCB1bmRlZmluZWQsIHRydWUpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybU9mZmxpbmUuc2V0QXR0ZW1wdFNuYXBzaG90KHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgZGF0YSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gRXJyb3IgZ2V0dGluZyB1c2VyIGRhdGEgZnJvbSBNb29kbGUuIFdlJ2xsIGhhdmUgdG8gYnVpbGQgaXQgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgLy8gTGV0J3MgdHJ5IHRvIGdldCBjYWNoZWQgZGF0YSBhYm91dCB0aGUgYXR0ZW1wdC5cbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm1Vc2VyRGF0YShzY29ybUlkLCBhdHRlbXB0LCBmYWxzZSwgc2l0ZUlkKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBjYWNoZWQgZGF0YSwgTW9vZGxlIGhhcyBubyBkYXRhIHN0b3JlZC5cbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGFkZCB0aGUgc3luY2VkIGRhdGEgdG8gdGhlIHNuYXBzaG90LlxuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmdldFNjb3JtU3RvcmVkRGF0YShzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIHVuZGVmaW5lZCwgZmFsc2UsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc3luY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzeW5jZWQsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGFbZW50cnkuc2NvaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtlbnRyeS5zY29pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb2lkOiBlbnRyeS5zY29pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmRhdGE6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZW50cnkuc2NvaWRdLnVzZXJkYXRhW2VudHJ5LmVsZW1lbnRdID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5zZXRBdHRlbXB0U25hcHNob3Qoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0LCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTeW5jIGEgU0NPUk0gb25seSBpZiBhIGNlcnRhaW4gdGltZSBoYXMgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtU3luYyNzeW5jU2Nvcm1JZk5lZWRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29ybSAgICBTQ09STSBkb3dubG9hZGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2l0ZUlkXSBTaXRlIElELiBJZiBub3QgZGVmaW5lZCwgY3VycmVudCBzaXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFNDT1JNIGlzIHN5bmNlZCBvciBpZiBpdCBkb2Vzbid0IG5lZWQgdG8gYmUgc3luY2VkLlxuICAgICAqL1xuICAgIHNlbGYuc3luY1Njb3JtSWZOZWVkZWQgPSBmdW5jdGlvbihzY29ybSwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIHJldHVybiBzZWxmLmdldFNjb3JtU3luY1RpbWUoc2Nvcm0uaWQsIHNpdGVJZCkudGhlbihmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBtbWFNb2RTY29ybVN5bmNUaW1lID49IHRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zeW5jU2Nvcm0oc2Nvcm0sIHNpdGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcnkgdG8gc3luY2hyb25pemUgYSBTQ09STSdzIGF0dGVtcHRzLlxuICAgICAqIFRoZSBwcm9taXNlIHJldHVybmVkIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCBhbiBhcnJheSB3aXRoIHdhcm5pbmdzIGlmIHRoZSBzeW5jaHJvbml6YXRpb24gaXMgc3VjY2Vzc2Z1bC4gQSBzdWNjZXNzZnVsXG4gICAgICogc3luY2hyb25pemF0aW9uIGRvZXNuJ3QgbWVhbiB0aGF0IGFsbCB0aGUgZGF0YSBoYXMgYmVlbiBzZW50IHRvIHRoZSBzaXRlLCBpdCdzIHBvc3NpYmxlIHRoYXQgc29tZSBhdHRlbXB0IGNhbid0IGJlIHNlbnQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc2Nvcm1cbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFNjb3JtU3luYyNzeW5jU2Nvcm1cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjb3JtICAgU0NPUk0gdG8gc3luYy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHdhcm5pbmdzIGluIHN1Y2Nlc3MsIHJlamVjdGVkIGlmIHN5bmNocm9uaXphdGlvbiBmYWlscy5cbiAgICAgKi9cbiAgICBzZWxmLnN5bmNTY29ybSA9IGZ1bmN0aW9uKHNjb3JtLCBzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcbiAgICAgICAgdmFyIHdhcm5pbmdzID0gW10sXG4gICAgICAgICAgICBzeW5jUHJvbWlzZSxcbiAgICAgICAgICAgIGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3luY1Byb21pc2VzW3NpdGVJZF0gJiYgc3luY1Byb21pc2VzW3NpdGVJZF1bc2Nvcm0uaWRdKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSBzeW5jIG9uZ29pbmcgZm9yIHRoaXMgU0NPUk0sIHJldHVybiB0aGUgcHJvbWlzZS5cbiAgICAgICAgICAgIHJldHVybiBzeW5jUHJvbWlzZXNbc2l0ZUlkXVtzY29ybS5pZF07XG4gICAgICAgIH0gZWxzZSBpZiAoIXN5bmNQcm9taXNlc1tzaXRlSWRdKSB7XG4gICAgICAgICAgICBzeW5jUHJvbWlzZXNbc2l0ZUlkXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRtbWFNb2RTY29ybU9ubGluZS5pc1Njb3JtQmxvY2tlZChzaXRlSWQsIHNjb3JtLmlkKSB8fCAkbW1hTW9kU2Nvcm1PZmZsaW5lLmlzU2Nvcm1CbG9ja2VkKHNpdGVJZCwgc2Nvcm0uaWQpKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdDYW5ub3Qgc3luYyBTQ09STSAnICsgc2Nvcm0uaWQgKyAnIGJlY2F1c2UgaXQgaXMgYmxvY2tlZC4nKTtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRsb2cuZGVidWcoJ1RyeSB0byBzeW5jIFNDT1JNICcgKyBzY29ybS5pZCArICcgaW4gc2l0ZSAnICsgc2l0ZUlkKTtcblxuICAgICAgICAvLyBQcmVmZXRjaGVzIGRhdGEgLCBzZXQgc3luYyB0aW1lIGFuZCByZXR1cm4gd2FybmluZ3MuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmlzaFN5bmMoKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLmludmFsaWRhdGVBbGxTY29ybURhdGEoc2Nvcm0uaWQsIHNpdGVJZCkuY2F0Y2goZnVuY3Rpb24oKSB7fSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtLnByZWZldGNoRGF0YShzY29ybSwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zZXRTY29ybVN5bmNUaW1lKHNjb3JtLmlkLCBzaXRlSWQpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YXJuaW5nczsgLy8gTm8gb2ZmbGluZSBhdHRlbXB0cywgbm90aGluZyB0byBzeW5jLlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGF0dGVtcHRzIGRhdGEuIFdlIGlnbm9yZSBjYWNoZSBmb3Igb25saW5lIGF0dGVtcHRzLCBzbyB0aGlzIGNhbGwgd2lsbCBmYWlsIGlmIG9mZmxpbmUgb3Igc2VydmVyIGRvd24uXG4gICAgICAgIHN5bmNQcm9taXNlID0gJG1tYU1vZFNjb3JtLmdldEF0dGVtcHRDb3VudChzY29ybS5pZCwgc2l0ZUlkLCB1bmRlZmluZWQsIGZhbHNlLCB0cnVlKS50aGVuKGZ1bmN0aW9uKGF0dGVtcHRzRGF0YSkge1xuICAgICAgICAgICAgaWYgKCFhdHRlbXB0c0RhdGEub2ZmbGluZSB8fCAhYXR0ZW1wdHNEYXRhLm9mZmxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFN5bmMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBbXSxcbiAgICAgICAgICAgICAgICBsYXN0T25saW5lID0gMCxcbiAgICAgICAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgY29sbGlzaW9ucyBiZXR3ZWVuIG9mZmxpbmUgYW5kIG9ubGluZSBhdHRlbXB0cyAoc2FtZSBudW1iZXIpLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGF0dGVtcHRzRGF0YS5vbmxpbmUsIGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICBsYXN0T25saW5lID0gTWF0aC5tYXgobGFzdE9ubGluZSwgYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHRzRGF0YS5vZmZsaW5lLmluZGV4T2YoYXR0ZW1wdCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25zLnB1c2goYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGxhc3Qgb25saW5lIGF0dGVtcHQgaXMgZmluaXNoZWQuIElnbm9yZSBjYWNoZS5cbiAgICAgICAgICAgIHByb21pc2UgPSBsYXN0T25saW5lID4gMCA/ICRtbWFNb2RTY29ybS5pc0F0dGVtcHRJbmNvbXBsZXRlKHNjb3JtLmlkLCBsYXN0T25saW5lLCBmYWxzZSwgdHJ1ZSwgc2l0ZUlkKSA6ICRxLndoZW4oZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGluY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbGxpc2lvbnMubGVuZ3RoICYmICFpbmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbGxpc2lvbnMgYW5kIGxhc3QgYXR0ZW1wdCBpcyBjb21wbGV0ZS4gU2VuZCBvZmZsaW5lIGF0dGVtcHRzIHRvIE1vb2RsZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChhdHRlbXB0c0RhdGEub2ZmbGluZSwgZnVuY3Rpb24oYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3JtLm1heGF0dGVtcHQgPT0gMCB8fCBhdHRlbXB0IDw9IHNjb3JtLm1heGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYuX3N5bmNBdHRlbXB0KHNjb3JtLmlkLCBhdHRlbXB0LCBzaXRlSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoU3luYygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sbGlzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBjb2xsaXNpb25zLCB0cmVhdCB0aGVtLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJlYXRDb2xsaXNpb25zKHNjb3JtLmlkLCBzaXRlSWQsIGNvbGxpc2lvbnMsIGxhc3RPbmxpbmUsIGF0dGVtcHRzRGF0YS5vZmZsaW5lKS50aGVuKGZ1bmN0aW9uKHdhcm5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncyA9IHdhcm5pbmdzLmNvbmNhdCh3YXJucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvZmZsaW5lIGF0dGVtcHRzIG1pZ2h0IGhhdmUgY2hhbmdlZCBzaW5jZSBzb21lIGNvbGxpc2lvbnMgY2FuIGJlIGNvbnZlcnRlZCB0byBuZXcgYXR0ZW1wdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5nZXRBdHRlbXB0cyhzaXRlSWQsIHNjb3JtLmlkKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fubm90U3luY1NvbWUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMgPSBlbnRyaWVzLm1hcChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuYXR0ZW1wdDsgLy8gR2V0IG9ubHkgdGhlIGF0dGVtcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNvbXBsZXRlICYmIGVudHJpZXMuaW5kZXhPZihsYXN0T25saW5lKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhc3Qgb25saW5lIHdhcyBpbmNvbXBsZXRlLCBidXQgaXQgd2FzIGNvbnRpbnVlZCBpbiBvZmZsaW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UnbGwgYWx3YXlzIHN5bmMgYXR0ZW1wdHMgcHJldmlvdXMgdG8gbGFzdE9ubGluZSAoZmFpbGVkIHN5bmMgb3IgY29udGludWVkIGluIG9mZmxpbmUpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdsbCBvbmx5IHN5bmMgbmV3IGF0dGVtcHMgaWYgbGFzdCBvbmxpbmUgYXR0ZW1wdCBpcyBjb21wbGV0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5jb21wbGV0ZSB8fCBhdHRlbXB0IDw9IGxhc3RPbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29ybS5tYXhhdHRlbXB0ID09IDAgfHwgYXR0ZW1wdCA8PSBzY29ybS5tYXhhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLl9zeW5jQXR0ZW1wdChzY29ybS5pZCwgYXR0ZW1wdCwgc2l0ZUlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ub3RTeW5jU29tZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2Fubm90U3luY1NvbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goJHRyYW5zbGF0ZS5pbnN0YW50KCdtbWEubW9kX3Njb3JtLndhcm5pbmdzeW5jb25saW5laW5jb21wbGV0ZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoU3luYygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbGxpc2lvbnMsIGJ1dCBsYXN0IG9ubGluZSBhdHRlbXB0IGlzIGluY29tcGxldGUgc28gd2UgY2FuJ3Qgc2VuZCBvZmZsaW5lIGF0dGVtcHRzLlxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKCR0cmFuc2xhdGUuaW5zdGFudCgnbW1hLm1vZF9zY29ybS53YXJuaW5nc3luY29ubGluZWluY29tcGxldGUnKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2hTeW5jKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBzeW5jUHJvbWlzZXNbc2l0ZUlkXVtzY29ybS5pZF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZGVsZXRlZCkge1xuICAgICAgICAgICAgc3luY1Byb21pc2VzW3NpdGVJZF1bc2Nvcm0uaWRdID0gc3luY1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN5bmNQcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmVhdCBjb2xsaXNpb25zIGZvdW5kIGluIGEgU0NPUk0gc3luY2hyb25pemF0aW9uIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgICAgICAgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICAgICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJbXX0gY29sbGlzaW9ucyAgICAgIE51bWJlcnMgb2YgYXR0ZW1wdHMgdGhhdCBleGlzdCBib3RoIGluIG9ubGluZSBhbmQgb2ZmbGluZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxhc3RPbmxpbmUgICAgICAgIExhc3Qgb25saW5lIGF0dGVtcHQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyW119IG9mZmxpbmVBdHRlbXB0cyBOdW1iZXJzIG9mIG9mZmxpbmUgYXR0ZW1wdHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGNvbGxpc2lvbnMgaGF2ZSBiZWVuIHRyZWF0ZWQuIEl0IHJldHVybnMgd2FybmluZ3MgYXJyYXkuXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBUcmVhdCBjb2xsaXNpb25zIGZvdW5kIGluIGEgU0NPUk0gc3luY2hyb25pemF0aW9uIHByb2Nlc3MuIEEgY29sbGlzaW9uIGlzIHdoZW4gYW4gYXR0ZW1wdCBleGlzdHMgYm90aCBpbiBvZmZsaW5lXG4gICAgICogYW5kIG9ubGluZS4gQSBjb2xsaXNpb24gY2FuIGJlOlxuICAgICAqXG4gICAgICogLSBUd28gZGlmZmVyZW50IGF0dGVtcHRzLlxuICAgICAqIC0gQW4gb25saW5lIGF0dGVtcHQgY29udGludWVkIGluIG9mZmxpbmUuXG4gICAgICogLSBBIGZhaWx1cmUgaW4gYSBwcmV2aW91cyBzeW5jLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIG1vdmUgaW50byBuZXcgYXR0ZW1wdHMgdGhlIGNvbGxpc2lvbnMgdGhhdCBjYW4ndCBiZSBtZXJnZWQuIEl0IHdpbGwgdXN1YWxseSBrZWVwIHRoZSBvcmRlciBvZiB0aGVcbiAgICAgKiBvZmZsaW5lIGF0dGVtcHRzIEVYQ0VQVCBpZiB0aGUgb2ZmbGluZSBhdHRlbXB0IHdhcyBjcmVhdGVkIGFmdGVyIHRoZSBsYXN0IG9mZmxpbmUgYXR0ZW1wdCAoZWRnZSBjYXNlKS5cbiAgICAgKlxuICAgICAqIEVkZ2UgY2FzZTogQSB1c2VyIGNyZWF0ZXMgb2ZmbGluZSBhdHRlbXB0cyBhbmQgd2hlbiBoZSBzeW5jcyB3ZSByZXRyaWV2ZSBhbiBpbmNvbXBsZXRlIG9ubGluZSBhdHRlbXB0LCBzbyB0aGUgb2ZmbGluZVxuICAgICAqIGF0dGVtcHRzIGNhbm5vdCBiZSBzeW5jZWQuIFRoZW4gdGhlIHVzZXIgY29udGludWVzIHRoYXQgb25saW5lIGF0dGVtcHQgYW5kIGdvZXMgb2ZmbGluZSwgc28gYSBjb2xsaXNpb24gaXMgY3JlYXRlZC5cbiAgICAgKiBXaGVuIHdlIHBlcmZvcm0gdGhlIG5leHQgc3luYyB3ZSBkZXRlY3QgdGhhdCB0aGlzIGNvbGxpc2lvbiBjYW5ub3QgYmUgbWVyZ2VkLCBzbyB0aGlzIG9mZmxpbmUgYXR0ZW1wdCBuZWVkcyB0byBiZVxuICAgICAqIGNyZWF0ZWQgYXMgYSBuZXcgYXR0ZW1wdC4gU2luY2UgdGhpcyBhdHRlbXB0IHdhcyBjcmVhdGVkIGFmdGVyIHRoZSBsYXN0IG9mZmxpbmUgYXR0ZW1wdCwgaXQgd2lsbCBiZSBhZGRlZCBvdCB0aGUgZW5kXG4gICAgICogb2YgdGhlIGxpc3QgaWYgdGhlIGxhc3QgYXR0ZW1wdCBpcyBjb21wbGV0ZWQuIElmIHRoZSBsYXN0IGF0dGVtcHQgaXMgbm90IGNvbXBsZXRlZCB0aGVuIHRoZSBvZmZsaW5lIGRhdGEgd2lsbCBkZSBkZWxldGVkXG4gICAgICogYmVjYXVzZSB3ZSBjYW4ndCBjcmVhdGUgYSBuZXcgYXR0ZW1wdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmVhdENvbGxpc2lvbnMoc2Nvcm1JZCwgc2l0ZUlkLCBjb2xsaXNpb25zLCBsYXN0T25saW5lLCBvZmZsaW5lQXR0ZW1wdHMpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdzID0gW10sXG4gICAgICAgICAgICBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgbmV3QXR0ZW1wdHNTYW1lT3JkZXIgPSBbXSwgLy8gQXR0ZW1wdHMgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgYXMgbmV3IGF0dGVtcHRzIGJ1dCBrZWVwaW5nIHRoZSBjdXJyZW50IG9yZGVyLlxuICAgICAgICAgICAgbmV3QXR0ZW1wdHNBdEVuZCA9IHt9LCAvLyBBdHRlbXB0cyB0aGF0IHdpbGwgYmUgY3JlYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IG9mIGF0dGVtcHRzIChzaG91bGQgYmUgbWF4IDEgYXR0ZW1wdCkuXG4gICAgICAgICAgICBsYXN0Q29sbGlzaW9uID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgY29sbGlzaW9ucyksXG4gICAgICAgICAgICBsYXN0T2ZmbGluZSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIG9mZmxpbmVBdHRlbXB0cyksXG4gICAgICAgICAgICBsYXN0T2ZmbGluZUluY29tcGxldGUsXG4gICAgICAgICAgICBsYXN0T2ZmbGluZUNyZWF0ZWQ7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBjcmVhdGlvbiB0aW1lIGFuZCB0aGUgc3RhdHVzIChjb21wbGV0ZS9pbmNvbXBsZXRlKSBvZiB0aGUgbGFzdCBvZmZsaW5lIGF0dGVtcHQuXG4gICAgICAgIGZ1bmN0aW9uIGdldExhc3RPZmZsaW5lQXR0ZW1wdERhdGEoKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBsYXN0IG9mZmxpbmUgYXR0ZW1wdCBpcyBpbmNvbXBsZXRlLlxuICAgICAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5pc0F0dGVtcHRJbmNvbXBsZXRlKHNjb3JtSWQsIGxhc3RPZmZsaW5lLCB0cnVlLCBmYWxzZSwgc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGluY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBsYXN0T2ZmbGluZUluY29tcGxldGUgPSBpbmNvbXBsZXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmdldEF0dGVtcHRDcmVhdGlvblRpbWUoc2l0ZUlkLCBzY29ybUlkLCBsYXN0T2ZmbGluZSkudGhlbihmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RPZmZsaW5lQ3JlYXRlZCA9IHRpbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBhbiBhdHRlbXB0IHRvIHRoZSByaWdodCBuZXcgYXR0ZW1wdHMgYXJyYXkgaWYgcG9zc2libGUuXG4gICAgICAgIC8vIElmIHRoZSBhdHRlbXB0IGNhbm5vdCBiZSBjcmVhdGVkIGFzIGEgbmV3IGF0dGVtcHQgdGhlbiBpdCB3aWxsIGJlIGRlbGV0ZWQuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFRvTmV3T3JEZWxldGUoYXR0ZW1wdCkge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPT0gbGFzdE9mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICBuZXdBdHRlbXB0c1NhbWVPcmRlci5wdXNoKGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmdldEF0dGVtcHRDcmVhdGlvblRpbWUoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0KS50aGVuKGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+IGxhc3RPZmZsaW5lQ3JlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGF0dGVtcHQgd2FzIGNyZWF0ZWQgYWZ0ZXIgdGhlIGxhc3Qgb2ZmbGluZSBhdHRlbXB0LCB3ZSdsbCBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RPZmZsaW5lSW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgY2FuJ3QgYmUgYWRkZWQgYmVjYXVzZSB0aGUgbGFzdCBvZmZsaW5lIGF0dGVtcHQgaXMgaW5jb21wbGV0ZSwgZGVsZXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVHJ5IHRvIGRlbGV0ZSBhdHRlbXB0ICcgKyBhdHRlbXB0ICsgJyBiZWNhdXNlIGl0IGNhbm5vdCBiZSBjcmVhdGVkIGFzIGEgbmV3IGF0dGVtcHQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5kZWxldGVBdHRlbXB0KHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKCR0cmFuc2xhdGUuaW5zdGFudCgnbW1hLm1vZF9zY29ybS53YXJuaW5nb2ZmbGluZWRhdGFkZWxldGVkJywge251bWJlcjogYXR0ZW1wdH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIHRoZXJlJ3Mgc29tZXRoaW5nIHdyb25nIHdpdGggdGhlIGRhdGEgb3IgdGhlIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0F0dGVtcHRzQXRFbmRbdGltZV0gPSBhdHRlbXB0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdBdHRlbXB0c1NhbWVPcmRlci5wdXNoKGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IG5lZWRlZCBkYXRhIGZyb20gdGhlIGxhc3Qgb2ZmbGluZSBhdHRlbXB0LlxuICAgICAgICByZXR1cm4gZ2V0TGFzdE9mZmxpbmVBdHRlbXB0RGF0YSgpLnRoZW4oZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGNvbGxpc2lvbnMuZm9yRWFjaChmdW5jdGlvbihhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgZ2V0IHN5bmNlZCBlbnRyaWVzIHRvIGRldGVjdCBpZiBpdCB3YXMgYSBmYWlsZWQgc3luY2hyb25pemF0aW9uLlxuICAgICAgICAgICAgICAgIHZhciBnZXREYXRhRm4gPSAkbW1hTW9kU2Nvcm1PZmZsaW5lLmdldFNjb3JtU3RvcmVkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IGdldERhdGFGbihzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIHVuZGVmaW5lZCwgZmFsc2UsIHRydWUpLnRoZW4oZnVuY3Rpb24oc3luY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW5jZWQgJiYgc3luY2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGF0dGVtcHQgaGFzIHN5bmNlZCBlbnRyaWVzLCBpdCBzZWVtcyB0byBiZSBhIGZhaWxlZCBzeW5jaHJvbml6YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBnZXQgdGhlIGVudHJpZXMgdGhhdCBoYXZlbid0IGJlZW4gc3luY2VkLCBtYXliZSBpdCBqdXN0IGZhaWxlZCB0byBkZWxldGUgdGhlIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RGF0YUZuKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgdW5kZWZpbmVkLCB0cnVlKS50aGVuKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzRGF0YVRvU2VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZWxlbWVudC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRGF0YVRvU2VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNEYXRhVG9TZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBlbGVtZW50cyB0byBzeW5jLiBXZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgcG9zc2libGUgdG8gc3luYyB0aGVtIG9yIG5vdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhblJldHJ5U3luYyhzY29ybUlkLCBzaXRlSWQsIGF0dGVtcHQsIGxhc3RPbmxpbmUpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJldHJ5IHN5bmMsIHdlJ2xsIGNyZWF0ZSBhIG5ldyBvZmZsaW5lIGF0dGVtcHQgaWYgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkVG9OZXdPckRlbGV0ZShhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBzeW5jLCBkZWxldGUgdGhlIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmRlbGV0ZUF0dGVtcHQoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIHRoZXJlJ3Mgc29tZXRoaW5nIHdyb25nIHdpdGggdGhlIGRhdGEgb3IgdGhlIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBub3QgYSBmYWlsZWQgc3luY2hyb25pemF0aW9uLiBDaGVjayBpZiBpdCdzIGFuIGF0dGVtcHQgY29udGludWVkIGluIG9mZmxpbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5nZXRBdHRlbXB0U25hcHNob3Qoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0KS50aGVuKGZ1bmN0aW9uKHNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ICYmIE9iamVjdC5rZXlzKHNuYXBzaG90KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgaGFzIGEgc25hcHNob3QsIGl0IG1lYW5zIGl0IGNvbnRpbnVlZCBhbiBvbmxpbmUgYXR0ZW1wdC4gV2UgbmVlZCB0byBjaGVjayBpZiB0aGV5J3ZlIGRpdmVyZ2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBsYXN0IGF0dGVtcHQgd2UgZG9uJ3QgbmVlZCB0byBpZ25vcmUgY2FjaGUgYmVjYXVzZSB3ZSBhbHJlYWR5IGRpZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZnJlc2ggPSBsYXN0T25saW5lICE9IGF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm0uZ2V0U2Nvcm1Vc2VyRGF0YShzY29ybUlkLCBhdHRlbXB0LCBmYWxzZSwgc2l0ZUlkLCB1bmRlZmluZWQsIHJlZnJlc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc25hcHNob3RFcXVhbHMoc25hcHNob3QsIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3QgaGFzIGRpdmVyZ2VkLCBpdCB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIGEgbmV3IGF0dGVtcHQgaWYgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZFRvTmV3T3JEZWxldGUoYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHNuYXBzaG90LCBpdCdzIGEgZGlmZmVyZW50IGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0F0dGVtcHRzU2FtZU9yZGVyLnB1c2goYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVOZXdBdHRlbXB0cyhzY29ybUlkLCBzaXRlSWQsIG5ld0F0dGVtcHRzU2FtZU9yZGVyLCBsYXN0T25saW5lLCBsYXN0Q29sbGlzaW9uLCBvZmZsaW5lQXR0ZW1wdHMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXcgYXR0ZW1wdHMgdGhhdCBuZWVkIHRvIGtlZXAgdGhlIG9yZGVyIGhhdmUgYmVlbiBjcmVhdGVkLiBOb3cgd2UnbGwgY3JlYXRlIHRoZSBuZXcgYXR0ZW1wdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBvZmZsaW5lIGF0dGVtcHRzLiBJdCBzaG91bGQgb25seSBiZSAxIGF0dGVtcHQgbWF4LlxuICAgICAgICAgICAgICAgICAgICBsYXN0T2ZmbGluZSA9IGxhc3RPZmZsaW5lICsgbmV3QXR0ZW1wdHNTYW1lT3JkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV3QXR0ZW1wdHNBdEVuZChzY29ybUlkLCBzaXRlSWQsIG5ld0F0dGVtcHRzQXRFbmQsIGxhc3RPZmZsaW5lKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhcm5pbmdzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIG51bWJlciBvZiBzb21lIG9mZmxpbmUgYXR0ZW1wdHMuIFdlIG5lZWQgdG8gbW92ZSBhbGwgb2ZmbGluZSBhdHRlbXB0cyBhZnRlciB0aGUgY29sbGlzaW9uc1xuICAgICAqIHRvbywgb3RoZXJ3aXNlIHdlIHdvdWxkIG92ZXJ3cml0ZSBkYXRhLlxuICAgICAqIEV4YW1wbGU6IFdlIGhhdmUgb2ZmbGluZSBhdHRlbXB0cyAxLCAyIGFuZCAzLiAjMSBhbmQgIzIgaGF2ZSBjb2xsaXNpb25zLiAjMSBjYW4gYmUgc3luY2VkLCBidXQgIzIgbmVlZHNcbiAgICAgKiB0byBiZSBhIG5ldyBhdHRlbXB0LiAjMyB3aWxsIG5vdyBiZSAjNCwgYW5kICMyIHdpbGwgbm93IGJlICMzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29ybUlkICAgICAgICAgICBTQ09STSBJRC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgICAgICAgIFNpdGUgSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyW119IG5ld0F0dGVtcHRzICAgICBBdHRlbXB0cyB0aGF0IG5lZWQgdG8gYmUgY29udmVydGVkIGludG8gbmV3IGF0dGVtcHRzLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGFzdE9ubGluZSAgICAgICAgTGFzdCBvbmxpbmUgYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxhc3RDb2xsaXNpb24gICAgIExhc3QgYXR0ZW1wdCB3aXRoIGNvbGxpc2lvbiAoZXhpc3RzIGluIG9ubGluZSBhbmQgb2ZmbGluZSkuXG4gICAgICogQHBhcmFtICB7TnVtYmVyW119IG9mZmxpbmVBdHRlbXB0cyBOdW1iZXJzIG9mIG9mZmxpbmUgYXR0ZW1wdHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gYXR0ZW1wdHMgaGF2ZSBiZWVuIG1vdmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vdmVOZXdBdHRlbXB0cyhzY29ybUlkLCBzaXRlSWQsIG5ld0F0dGVtcHRzLCBsYXN0T25saW5lLCBsYXN0Q29sbGlzaW9uLCBvZmZsaW5lQXR0ZW1wdHMpIHtcbiAgICAgICAgaWYgKCFuZXdBdHRlbXB0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS53aGVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvbWlzZSA9ICRxLndoZW4oKSxcbiAgICAgICAgICAgIGxhc3RTdWNjZXNzZnVsO1xuXG4gICAgICAgIC8vIFNvcnQgb2ZmbGluZSBhdHRlbXB0cyBpbiBERVNDIG9yZGVyLlxuICAgICAgICBvZmZsaW5lQXR0ZW1wdHMgPSBvZmZsaW5lQXR0ZW1wdHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoYSwgMTApIDwgcGFyc2VJbnQoYiwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaXJzdCBtb3ZlIHRoZSBvZmZsaW5lIGF0dGVtcHRzIGFmdGVyIHRoZSBjb2xsaXNpb25zO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gob2ZmbGluZUF0dGVtcHRzLCBmdW5jdGlvbihhdHRlbXB0KSB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IGxhc3RDb2xsaXNpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBjaGFpbiBvZiBwcm9taXNlcyBiZWNhdXNlIHdlIG5lZWQgdG8gbW92ZSB0aGVtIGluIG9yZGVyLlxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdOdW1iZXIgPSBhdHRlbXB0ICsgbmV3QXR0ZW1wdHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5jaGFuZ2VBdHRlbXB0TnVtYmVyKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgbmV3TnVtYmVyKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFN1Y2Nlc3NmdWwgPSBhdHRlbXB0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NmdWwgPSBbXTtcblxuICAgICAgICAgICAgLy8gU29ydCBuZXdBdHRlbXB0cyBpbiBBU0Mgb3JkZXIuXG4gICAgICAgICAgICBuZXdBdHRlbXB0cyA9IG5ld0F0dGVtcHRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChhLCAxMCkgPiBwYXJzZUludChiLCAxMCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTm93IG1vdmUgdGhlIGF0dGVtcHRzIGluIG5ld0F0dGVtcHRzLlxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG5ld0F0dGVtcHRzLCBmdW5jdGlvbihhdHRlbXB0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gdXNlIGNoYWluIG9mIHByb21pc2VzLlxuICAgICAgICAgICAgICAgIHZhciBuZXdOdW1iZXIgPSBsYXN0T25saW5lICsgaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goJG1tYU1vZFNjb3JtT2ZmbGluZS5jaGFuZ2VBdHRlbXB0TnVtYmVyKHNpdGVJZCwgc2Nvcm1JZCwgYXR0ZW1wdCwgbmV3TnVtYmVyKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzZnVsLnB1c2goYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE1vdmluZyB0aGUgbmV3IGF0dGVtcHRzIGZhaWxlZCAoaXQgc2hvdWxkbid0IGhhcHBlbikuIExldCdzIHVuZG8gdGhlIG5ldyBhdHRlbXB0cyBtb3ZlLlxuICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHN1Y2Nlc3NmdWwsIGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld051bWJlciA9IGxhc3RPbmxpbmUgKyBuZXdBdHRlbXB0cy5pbmRleE9mKGF0dGVtcHQpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkbW1hTW9kU2Nvcm1PZmZsaW5lLmNoYW5nZUF0dGVtcHROdW1iZXIoc2l0ZUlkLCBzY29ybUlkLCBuZXdOdW1iZXIsIGF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1tVXRpbC5hbGxQcm9taXNlcyhwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpOyAvLyBJdCB3aWxsIG5vdyBlbnRlciB0aGUgLmNhdGNoIHRoYXQgbW92ZXMgb2ZmbGluZSBhdHRlbXB0cyBhZnRlciBjb2xsaXNpb25zLlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBNb3Zpbmcgb2ZmbGluZSBhdHRlbXB0cyBhZnRlciBjb2xsaXNpb25zIGZhaWxlZCAoaXQgc2hvdWxkbid0IGhhcHBlbikuIExldCdzIHVuZG8gdGhlIGNoYW5nZXMuXG4gICAgICAgICAgICBpZiAoIWxhc3RTdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbigpO1xuXG4gICAgICAgICAgICB2YXIgYXR0ZW1wdHNUb1VuZG8gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsYXN0U3VjY2Vzc2Z1bDsgb2ZmbGluZUF0dGVtcHRzLmluZGV4T2YoaSkgIT0gLTE7IGkrKykge1xuICAgICAgICAgICAgICAgIGF0dGVtcHRzVG9VbmRvLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRlbXB0c1RvVW5kby5mb3JFYWNoKGZ1bmN0aW9uKGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIGl0IGJhY2suXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTW9kU2Nvcm1PZmZsaW5lLmNoYW5nZUF0dGVtcHROdW1iZXIoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0ICsgbmV3QXR0ZW1wdHMubGVuZ3RoLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG5ldyBhdHRlbXB0cyBhdCB0aGUgZW5kIG9mIHRoZSBvZmZsaW5lIGF0dGVtcHRzIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICAgU2l0ZSBJRC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG5ld0F0dGVtcHRzIEF0dGVtcHRzIHRvIGNyZWF0ZS4gVGhlIGtleXMgYXJlIHRoZSB0aW1lY3JlYXRlZCwgdGhlIHZhbHVlcyBhcmUgdGhlIGF0dGVtcHQgbnVtYmVyLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGFzdE9mZmxpbmUgTnVtYmVyIG9mIGxhc3Qgb2ZmbGluZSBhdHRlbXB0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjcmVhdGlvbiBpcyBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVOZXdBdHRlbXB0c0F0RW5kKHNjb3JtSWQsIHNpdGVJZCwgbmV3QXR0ZW1wdHMsIGxhc3RPZmZsaW5lKSB7XG4gICAgICAgIHZhciB0aW1lcyA9IE9iamVjdC5rZXlzKG5ld0F0dGVtcHRzKS5zb3J0KCksIC8vIFNvcnQgaW4gQVNDIG9yZGVyLlxuICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBpZiAoIXRpbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLndoZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh0aW1lcywgZnVuY3Rpb24odGltZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBhdHRlbXB0ID0gbmV3QXR0ZW1wdHNbdGltZV07XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRtbWFNb2RTY29ybU9mZmxpbmUuY2hhbmdlQXR0ZW1wdE51bWJlcihzaXRlSWQsIHNjb3JtSWQsIGF0dGVtcHQsIGxhc3RPZmZsaW5lICsgaW5kZXggKyAxKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJG1tVXRpbC5hbGxQcm9taXNlcyhwcm9taXNlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2FuIHJldHJ5IGFuIGF0dGVtcHQgc3luY2hyb25pemF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzY29ybUlkICAgIFNDT1JNIElELlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2l0ZUlkICAgICBTaXRlIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYXR0ZW1wdCAgICBBdHRlbXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxhc3RPbmxpbmUgTGFzdCBvbmxpbmUgYXR0ZW1wdCBudW1iZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgaWYgY2FuIHJldHJ5IHRoZSBzeW5jaHJvbml6YXRpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYW5SZXRyeVN5bmMoc2Nvcm1JZCwgc2l0ZUlkLCBhdHRlbXB0LCBsYXN0T25saW5lKSB7XG4gICAgICAgIC8vIElmIGl0J3MgdGhlIGxhc3QgYXR0ZW1wdCB3ZSBkb24ndCBuZWVkIHRvIGlnbm9yZSBjYWNoZSBiZWNhdXNlIHdlIGFscmVhZHkgZGlkIGl0LlxuICAgICAgICB2YXIgcmVmcmVzaCA9IGxhc3RPbmxpbmUgIT0gYXR0ZW1wdDtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RTY29ybS5nZXRTY29ybVVzZXJEYXRhKHNjb3JtSWQsIGF0dGVtcHQsIGZhbHNlLCBzaXRlSWQsIHVuZGVmaW5lZCwgcmVmcmVzaCkudGhlbihmdW5jdGlvbihzaXRlRGF0YSkge1xuICAgICAgICAgICAgLy8gR2V0IHN5bmNocm9uaXphdGlvbiBzbmFwc2hvdCAoaWYgc3luYyBmYWlscyBpdCBzaG91bGQgc3RvcmUgYSBzbmFwc2hvdCkuXG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFNjb3JtT2ZmbGluZS5nZXRBdHRlbXB0U25hcHNob3Qoc2l0ZUlkLCBzY29ybUlkLCBhdHRlbXB0KS50aGVuKGZ1bmN0aW9uKHNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzbmFwc2hvdCB8fCAhT2JqZWN0LmtleXMoc25hcHNob3QpLmxlbmd0aCB8fCAhc25hcHNob3RFcXVhbHMoc25hcHNob3QsIHNpdGVEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBzbmFwc2hvdCBvciBpdCBkb2Vzbid0IG1hdGNoLCB3ZSBjYW4ndCByZXRyeSB0aGUgc3luY2hyb25pemF0aW9uLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIGFuIGF0dGVtcHQncyBzbmFwc2hvdCB3aXRoIHRoZSBkYXRhIHJldHJpZXZlZCBmcm9tIHRoZSBzaXRlLlxuICAgICAqIEl0IG9ubHkgY29tcGFyZXMgZWxlbWVudHMgd2l0aCBkb3Qgbm90YXRpb24uIFRoaXMgbWVhbnMgdGhhdCwgaWYgc29tZSBTQ08gaGFzIGJlZW4gYWRkZWQgdG8gTW9vZGxlIHdlYlxuICAgICAqIGJ1dCB0aGUgdXNlciBoYXNuJ3QgZ2VuZXJhdGVkIGRhdGEgZm9yIGl0LCB0aGVuIHRoZSBzbmFwc2hvdCB3aWxsIGJlIGRldGVjdGVkIGFzIGVxdWFsLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzbmFwc2hvdCBBdHRlbXB0J3Mgc25hcHNob3QuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB1c2VyRGF0YSBEYXRhIHJldHJpZXZlZCBmcm9tIHRoZSBzaXRlLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgVHJ1ZSBpZiBzbmFwc2hvdCBpcyBlcXVhbCB0byB0aGUgdXNlciBkYXRhLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc25hcHNob3RFcXVhbHMoc25hcHNob3QsIHVzZXJEYXRhKSB7XG4gICAgICAgIHZhciBzY29JZCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBzaXRlU2NvLFxuICAgICAgICAgICAgc25hcHNob3RTY287XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzbmFwc2hvdCBjb250YWlucyB0aGUgZGF0YSBmcm9tIHRoZSBzaXRlLlxuICAgICAgICBmb3IgKHNjb0lkIGluIHVzZXJEYXRhKSB7XG4gICAgICAgICAgICBzaXRlU2NvID0gdXNlckRhdGFbc2NvSWRdO1xuICAgICAgICAgICAgc25hcHNob3RTY28gPSBzbmFwc2hvdFtzY29JZF07XG5cbiAgICAgICAgICAgIGZvciAoZWxlbWVudCBpbiBzaXRlU2NvLnVzZXJkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzbmFwc2hvdFNjbyB8fCBzaXRlU2NvLnVzZXJkYXRhW2VsZW1lbnRdICE9PSBzbmFwc2hvdFNjby51c2VyZGF0YVtlbGVtZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IGNoZWNrIHRoZSBvcHBvc2l0ZSB3YXk6IHNpdGUgdXNlckRhdGEgY29udGFpbnMgdGhlIGRhdGEgZnJvbSB0aGUgc25hcHNob3QuXG4gICAgICAgIGZvciAoc2NvSWQgaW4gc25hcHNob3QpIHtcbiAgICAgICAgICAgIHNpdGVTY28gPSB1c2VyRGF0YVtzY29JZF07XG4gICAgICAgICAgICBzbmFwc2hvdFNjbyA9IHNuYXBzaG90W3Njb0lkXTtcblxuICAgICAgICAgICAgZm9yIChlbGVtZW50IGluIHNuYXBzaG90U2NvLnVzZXJkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaXRlU2NvIHx8IHNpdGVTY28udXNlcmRhdGFbZWxlbWVudF0gIT09IHNuYXBzaG90U2NvLnVzZXJkYXRhW2VsZW1lbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSdzIGFuIG9uZ29pbmcgc3luYyBmb3IgYSBjZXJ0YWluIFNDT1JNLCB3YWl0IGZvciBpdCB0byBlbmQuXG4gICAgICogSWYgdGhlcmUncyBubyBzeW5jIG9uZ29pbmcgdGhlIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCByaWdodCBhd2F5LlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3Njb3JtXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTY29ybVN5bmMjd2FpdEZvclN5bmNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JtSWQgIFNDT1JNIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW3NpdGVJZF0gU2l0ZSBJRC4gSWYgbm90IGRlZmluZWQsIGN1cnJlbnQgc2l0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGVyZSdzIG5vIHN5bmMgZ29pbmcgb24gZm9yIHRoZSBTQ09STS5cbiAgICAgKi9cbiAgICBzZWxmLndhaXRGb3JTeW5jID0gZnVuY3Rpb24oc2Nvcm1JZCwgc2l0ZUlkKSB7XG4gICAgICAgIHNpdGVJZCA9IHNpdGVJZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIGlmIChzeW5jUHJvbWlzZXNbc2l0ZUlkXSAmJiBzeW5jUHJvbWlzZXNbc2l0ZUlkXVtzY29ybUlkXSkge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBhIHN5bmMgb25nb2luZyBmb3IgdGhpcyBTQ09STS5cbiAgICAgICAgICAgIHJldHVybiBzeW5jUHJvbWlzZXNbc2l0ZUlkXVtzY29ybUlkXS5jYXRjaChmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEud2hlbigpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubW9kX3N1cnZleScpXG5cbi8qKlxuICogU3VydmV5IGluZGV4IGNvbnRyb2xsZXIuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3N1cnZleVxuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU1vZFN1cnZleUluZGV4Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hTW9kU3VydmV5SW5kZXhDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRtbWFNb2RTdXJ2ZXksICRtbVV0aWwsICRxLCAkbW1Db3Vyc2UsICR0cmFuc2xhdGUsXG4gICAgICAgICAgICAkaW9uaWNQbGF0Zm9ybSwgJGlvbmljU2Nyb2xsRGVsZWdhdGUpIHtcbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIHN1cnZleSxcbiAgICAgICAgc2Nyb2xsVmlldztcblxuICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICRzY29wZS5kZXNjcmlwdGlvbiA9IG1vZHVsZS5kZXNjcmlwdGlvbjtcbiAgICAkc2NvcGUubW9kdWxldXJsID0gbW9kdWxlLnVybDtcbiAgICAkc2NvcGUuY291cnNlaWQgPSBjb3Vyc2VpZDtcbiAgICAkc2NvcGUuYW5zd2VycyA9IHt9O1xuICAgICRzY29wZS5pc1RhYmxldCA9ICRpb25pY1BsYXRmb3JtLmlzVGFibGV0KCk7XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgc3VydmV5IGRhdGEuXG4gICAgZnVuY3Rpb24gZmV0Y2hTdXJ2ZXlEYXRhKHJlZnJlc2gpIHtcbiAgICAgICAgcmV0dXJuICRtbWFNb2RTdXJ2ZXkuZ2V0U3VydmV5KGNvdXJzZWlkLCBtb2R1bGUuaWQpLnRoZW4oZnVuY3Rpb24oc3VydmV5ZGF0YSkge1xuICAgICAgICAgICAgc3VydmV5ID0gc3VydmV5ZGF0YTtcblxuICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gc3VydmV5Lm5hbWUgfHwgJHNjb3BlLnRpdGxlO1xuICAgICAgICAgICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gc3VydmV5LmludHJvIHx8wqAkc2NvcGUuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAkc2NvcGUuc3VydmV5ID0gc3VydmV5O1xuXG4gICAgICAgICAgICBpZiAoIXN1cnZleS5zdXJ2ZXlkb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoUXVlc3Rpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICghcmVmcmVzaCkge1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgY2FsbCBmYWlsZWQsIHJldHJ5IHdpdGhvdXQgdXNpbmcgY2FjaGUgc2luY2UgaXQgbWlnaHQgYmUgYSBuZXcgYWN0aXZpdHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZnJlc2hBbGxEYXRhKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9zdXJ2ZXkuZXJyb3JnZXRzdXJ2ZXknLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IHN1cnZleSBxdWVzdGlvbnMuXG4gICAgZnVuY3Rpb24gZmV0Y2hRdWVzdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiAkbW1hTW9kU3VydmV5LmdldFF1ZXN0aW9ucyhzdXJ2ZXkuaWQpLnRoZW4oZnVuY3Rpb24ocXVlc3Rpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFN1cnZleS5mb3JtYXRRdWVzdGlvbnMocXVlc3Rpb25zKS50aGVuKGZ1bmN0aW9uKGZvcm1hdHRlZCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5xdWVzdGlvbnMgPSBmb3JtYXR0ZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJbml0IGFuc3dlcnMgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChmb3JtYXR0ZWQsIGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzVGV4dEFyZWEgPSBxLm11bHRpICYmIHEubXVsdGkubGVuZ3RoID09PSAwICYmIHEudHlwZSA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5hbnN3ZXJzW3EubmFtZV0gPSBxLnJlcXVpcmVkID8gLTEgOiAoaXNUZXh0QXJlYSA/ICcnIDogJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHJlZnJlc2ggYWxsIHRoZSBkYXRhLlxuICAgIGZ1bmN0aW9uIHJlZnJlc2hBbGxEYXRhKCkge1xuICAgICAgICB2YXIgcDEgPSAkbW1hTW9kU3VydmV5LmludmFsaWRhdGVTdXJ2ZXlEYXRhKGNvdXJzZWlkKSxcbiAgICAgICAgICAgIHAyID0gc3VydmV5ID8gJG1tYU1vZFN1cnZleS5pbnZhbGlkYXRlUXVlc3Rpb25zKHN1cnZleS5pZCkgOiAkcS53aGVuKCk7XG5cbiAgICAgICAgcmV0dXJuICRxLmFsbChbcDEsIHAyXSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFN1cnZleURhdGEodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZldGNoU3VydmV5RGF0YSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFNb2RTdXJ2ZXkubG9nVmlldyhzdXJ2ZXkuaWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkbW1Db3Vyc2UuY2hlY2tNb2R1bGVDb21wbGV0aW9uKGNvdXJzZWlkLCBtb2R1bGUuY29tcGxldGlvbnN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5zdXJ2ZXlMb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gQ2hlY2sgaWYgYW5zd2VycyBhcmUgdmFsaWQgdG8gYmUgc3VibWl0dGVkLlxuICAgICRzY29wZS5pc1ZhbGlkUmVzcG9uc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5hbnN3ZXJzLCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH07XG5cbiAgICAvLyBTYXZlIG9wdGlvbnMgc2VsZWN0ZWQuXG4gICAgJHNjb3BlLnN1Ym1pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1VdGlsLnNob3dDb25maXJtKCR0cmFuc2xhdGUoJ21tLmNvcmUuYXJleW91c3VyZScpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFuc3dlcnMgPSBbXSxcbiAgICAgICAgICAgICAgICBtb2RhbCA9ICRtbVV0aWwuc2hvd01vZGFsTG9hZGluZygnbW0uY29yZS5zZW5kaW5nJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUuYW5zd2VycywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIGFuc3dlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkbW1hTW9kU3VydmV5LnN1Ym1pdEFuc3dlcnMoc3VydmV5LmlkLCBhbnN3ZXJzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghc2Nyb2xsVmlldykge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxWaWV3ID0gJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKCdtbWFNb2RTdXJ2ZXlTY3JvbGwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmlldyAmJiBzY3JvbGxWaWV3LnNjcm9sbFRvcCAmJiBzY3JvbGxWaWV3LnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWZyZXNoQWxsRGF0YSgpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm1vZF9zdXJ2ZXkuY2Fubm90c3VibWl0c3VydmV5JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFB1bGwgdG8gcmVmcmVzaC5cbiAgICAkc2NvcGUucmVmcmVzaFN1cnZleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWZyZXNoQWxsRGF0YSgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2Rfc3VydmV5JylcblxuLyoqXG4gKiBNb2Qgc3VydmV5IGhhbmRsZXJzLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zdXJ2ZXlcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTW9kU3VydmV5SGFuZGxlcnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFNb2RTdXJ2ZXlIYW5kbGVycycsIGZ1bmN0aW9uKCRtbUNvdXJzZSwgJG1tYU1vZFN1cnZleSwgJHN0YXRlLCAkcSwgJG1tQ29udGVudExpbmtzSGVscGVyKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENvdXJzZSBjb250ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc3VydmV5XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTdXJ2ZXlIYW5kbGVycyNjb3Vyc2VDb250ZW50XG4gICAgICovXG4gICAgc2VsZi5jb3Vyc2VDb250ZW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZHVsZSBpcyBlbmFibGVkIGZvciB0aGUgc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFN1cnZleS5pc1BsdWdpbkVuYWJsZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIFRoZSBtb2R1bGUgaW5mby5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIFRoZSBjb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24obW9kdWxlLCBjb3Vyc2VpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9IG1vZHVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJG1tQ291cnNlLmdldE1vZHVsZUljb25TcmMoJ3N1cnZleScpO1xuICAgICAgICAgICAgICAgICRzY29wZS5hY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5tb2Rfc3VydmV5Jywge21vZHVsZTogbW9kdWxlLCBjb3Vyc2VpZDogY291cnNlaWR9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBsaW5rcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3N1cnZleVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU3VydmV5SGFuZGxlcnMjbGlua3NIYW5kbGVyXG4gICAgICovXG4gICAgc2VsZi5saW5rc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzaXRlSWQgICAgIFNpdGUgSUQuXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGlzRW5hYmxlZChzaXRlSWQsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU1vZFN1cnZleS5pc1BsdWdpbkVuYWJsZWQoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291cnNlSWQgfHwgJG1tQ291cnNlLmNhbkdldE1vZHVsZVdpdGhvdXRDb3Vyc2VJZChzaXRlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzICBTaXRlIElEcyB0aGUgVVJMIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgIFVSTCB0byB0cmVhdC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb3Vyc2VJZF0gQ291cnNlIElEIHJlbGF0ZWQgdG8gdGhlIFVSTC5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBsaXN0IG9mIGFjdGlvbnMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgJG1tQ29udGVudExpbmtzRGVsZWdhdGUjcmVnaXN0ZXJMaW5rSGFuZGxlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmdldEFjdGlvbnMgPSBmdW5jdGlvbihzaXRlSWRzLCB1cmwsIGNvdXJzZUlkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgc3VydmV5IFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignL21vZC9zdXJ2ZXkvdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2Rfc3VydmV5JylcblxuLyoqXG4gKiBTdXJ2ZXkgc2VydmljZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc3VydmV5XG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZFN1cnZleVxuICovXG4uZmFjdG9yeSgnJG1tYU1vZFN1cnZleScsIGZ1bmN0aW9uKCRxLCAkbW1TaXRlLCAkdHJhbnNsYXRlLCAkbW1TaXRlc01hbmFnZXIpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVHVybnMgYSBzdHJpbmcgd2l0aCB2YWx1ZXMgc2VwYXJhdGVkIGJ5IGNvbW1hcyBpbnRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgIEFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbW1hU3RyaW5nVG9BcnJheSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBhIHF1ZXN0aW9ucyBsaXN0LCB0dXJuaW5nIFwibXVsdGlcIiBhbmQgXCJvcHRpb25zXCIgc3RyaW5ncyBpbnRvIGFycmF5cyBhbmQgYWRkaW5nIHRoZSBwcm9wZXJ0aWVzXG4gICAgICogJ251bScgYW5kICduYW1lJy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zdXJ2ZXlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFN1cnZleSNmb3JtYXRRdWVzdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBxdWVzdGlvbnMgUXVlc3Rpb25zLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGZvcm1hdHRlZCBxdWVzdGlvbnMuXG4gICAgICovXG4gICAgc2VsZi5mb3JtYXRRdWVzdGlvbnMgPSBmdW5jdGlvbihxdWVzdGlvbnMpIHtcbiAgICAgICAgdmFyIHN0cmluZ2tleXMgPSBbXG4gICAgICAgICAgICAnbW1hLm1vZF9zdXJ2ZXkuaXByZWZlcnRoYXQnLFxuICAgICAgICAgICAgJ21tYS5tb2Rfc3VydmV5Lmlmb3VuZHRoYXQnLFxuICAgICAgICAgICAgJ21tLmNvcmUuY2hvb3NlJ1xuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiAkdHJhbnNsYXRlKHN0cmluZ2tleXMpLnRoZW4oZnVuY3Rpb24odHJhbnNsYXRlcykge1xuICAgICAgICAgICAgdmFyIHN0cmlwcmVmZXJ0aGF0ID0gdHJhbnNsYXRlc1tzdHJpbmdrZXlzWzBdXSxcbiAgICAgICAgICAgICAgICBzdHJpZm91bmR0aGF0ID0gdHJhbnNsYXRlc1tzdHJpbmdrZXlzWzFdXSxcbiAgICAgICAgICAgICAgICBzdHJjaG9vc2UgPSB0cmFuc2xhdGVzW3N0cmluZ2tleXNbMl1dLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZCA9IFtdLFxuICAgICAgICAgICAgICAgIHBhcmVudHMgPSBzZWxmLmdldFBhcmVudFF1ZXN0aW9ucyhxdWVzdGlvbnMpLFxuICAgICAgICAgICAgICAgIG51bSA9IDE7XG5cbiAgICAgICAgICAgIHF1ZXN0aW9ucyA9IGFuZ3VsYXIuY29weShxdWVzdGlvbnMpOyAvLyBDb3B5IHRoZSBhcnJheSB0byBwcmV2ZW50IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChxdWVzdGlvbnMsIGZ1bmN0aW9uKHF1ZXN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbcXVlc3Rpb24ucGFyZW50XTtcblxuICAgICAgICAgICAgICAgIC8vIFR1cm4gbXVsdGkgYW5kIG9wdGlvbnMgaW50byBhcnJheXMuXG4gICAgICAgICAgICAgICAgcXVlc3Rpb24ubXVsdGkgPSBjb21tYVN0cmluZ1RvQXJyYXkocXVlc3Rpb24ubXVsdGkpO1xuICAgICAgICAgICAgICAgIHF1ZXN0aW9uLm9wdGlvbnMgPSBjb21tYVN0cmluZ1RvQXJyYXkocXVlc3Rpb24ub3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgYSBzdWItcXVlc3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIHF1ZXN0aW9uLnJlcXVpcmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IDEgfHzCoHBhcmVudC50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmUgYW5zd2VyIHF1ZXN0aW9uLiBTZXQgaXRzIG5hbWUgYW5kIGFkZCBpdCB0byB0aGUgcmV0dXJuZWQgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVzdGlvbi5uYW1lID0gJ3EnICsgKHBhcmVudC50eXBlID09IDIgPyAnUCcgOiAnJykgKyBxdWVzdGlvbi5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXN0aW9uLm51bSA9IG51bSsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHdvIGFuc3dlcnMgcGVyIHF1ZXN0aW9uIChDT0xMRVMgUCZBKS4gV2UnbGwgYWRkIHR3byBxdWVzdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcTIgPSBhbmd1bGFyLmNvcHkocXVlc3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVzdGlvbi50ZXh0ID0gc3RyaXByZWZlcnRoYXQgKyAnICcgKyBxdWVzdGlvbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlc3Rpb24ubmFtZSA9ICdxUCcgKyBxdWVzdGlvbi5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXN0aW9uLm51bSA9IG51bSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkLnB1c2gocXVlc3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBxMi50ZXh0ID0gc3RyaWZvdW5kdGhhdCArICcgJyArIHEyLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBxMi5uYW1lID0gJ3EnICsgcXVlc3Rpb24uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBxMi5udW0gPSBudW0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZC5wdXNoKHEyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxdWVzdGlvbi5tdWx0aSAmJiBxdWVzdGlvbi5tdWx0aS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBhIHNpbmdsZSBxdWVzdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgcXVlc3Rpb24ubmFtZSA9ICdxJyArIHF1ZXN0aW9uLmlkO1xuICAgICAgICAgICAgICAgICAgICBxdWVzdGlvbi5udW0gPSBudW0rKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXN0aW9uLnR5cGUgPiAwKSB7IC8vIEFkZCBcImNob29zZVwiIG9wdGlvbiBzaW5jZSB0aGlzIHF1ZXN0aW9uIGlzIG5vdCByZXF1aXJlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXN0aW9uLm9wdGlvbnMudW5zaGlmdChzdHJjaG9vc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkLnB1c2gocXVlc3Rpb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJlbnQgcXVlc3Rpb25zIGFuZCBwdXRzIHRoZW0gaW4gYW4gb2JqZWN0OiBJRCAtPiBxdWVzdGlvbi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zdXJ2ZXlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFN1cnZleSNnZXRQYXJlbnRRdWVzdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBxdWVzdGlvbnMgUXVlc3Rpb25zLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICBPYmplY3Qgd2l0aCBwYXJlbnQgcXVlc3Rpb25zLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UGFyZW50UXVlc3Rpb25zID0gZnVuY3Rpb24ocXVlc3Rpb25zKSB7XG4gICAgICAgIHZhciBwYXJlbnRzID0ge307XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHF1ZXN0aW9ucywgZnVuY3Rpb24ocXVlc3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChxdWVzdGlvbi5wYXJlbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRzW3F1ZXN0aW9uLmlkXSA9IHF1ZXN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3VydmV5J3MgcXVlc3Rpb25zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3N1cnZleVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU3VydmV5I2dldFF1ZXN0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBTdXJ2ZXkgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgcXVlc3Rpb25zIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRRdWVzdGlvbnMgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHN1cnZleWlkOiBpZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldFF1ZXN0aW9uc0NhY2hlS2V5KGlkKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdtb2Rfc3VydmV5X2dldF9xdWVzdGlvbnMnLCBwYXJhbXMsIHByZVNldHMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5xdWVzdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucXVlc3Rpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlIGtleSBmb3Igc3VydmV5IHF1ZXN0aW9ucyBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBTdXJ2ZXkgSUQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRRdWVzdGlvbnNDYWNoZUtleShpZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZFN1cnZleTpxdWVzdGlvbnM6JyArIGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHN1cnZleS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zdXJ2ZXlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFN1cnZleSNnZXRTdXJ2ZXlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlaWQgQ291cnNlIElELlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbWlkICAgICBDb3Vyc2UgbW9kdWxlIElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHN1cnZleSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRTdXJ2ZXkgPSBmdW5jdGlvbihjb3Vyc2VpZCwgY21pZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvdXJzZWlkczogW2NvdXJzZWlkXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZVNldHMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IGdldFN1cnZleURhdGFDYWNoZUtleShjb3Vyc2VpZClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGUucmVhZCgnbW9kX3N1cnZleV9nZXRfc3VydmV5c19ieV9jb3Vyc2VzJywgcGFyYW1zLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VydmV5cykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U3VydmV5O1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNwb25zZS5zdXJ2ZXlzLCBmdW5jdGlvbihzdXJ2ZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1cnZleS5jb3Vyc2Vtb2R1bGUgPT0gY21pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN1cnZleSA9IHN1cnZleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3VydmV5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U3VydmV5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIHN1cnZleSBkYXRhIFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN1cnZleURhdGFDYWNoZUtleShjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gJ21tYU1vZFN1cnZleTpzdXJ2ZXk6JyArIGNvdXJzZWlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHN1cnZleSBxdWVzdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc3VydmV5XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTdXJ2ZXkjaW52YWxpZGF0ZVF1ZXN0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBTdXJ2ZXkgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVRdWVzdGlvbnMgPSBmdW5jdGlvbihjb3Vyc2VpZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS5pbnZhbGlkYXRlV3NDYWNoZUZvcktleShnZXRRdWVzdGlvbnNDYWNoZUtleShjb3Vyc2VpZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBzdXJ2ZXkgZGF0YS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zdXJ2ZXlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFN1cnZleSNpbnZhbGlkYXRlU3VydmV5RGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBDb3Vyc2UgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVTdXJ2ZXlEYXRhID0gZnVuY3Rpb24oY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0U3VydmV5RGF0YUNhY2hlS2V5KGNvdXJzZWlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGlzIGVuYWJsZWQgaW4gYSBjZXJ0YWluIHNpdGUuIFBsdWdpbiBpcyBlbmFibGVkIGlmIHRoZSBzdXJ2ZXkgV1MgYXJlIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF9zdXJ2ZXlcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFN1cnZleSNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtzaXRlSWRdIFNpdGUgSUQuIElmIG5vdCBkZWZpbmVkLCBjdXJyZW50IHNpdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBwbHVnaW4gaXMgZW5hYmxlZCwgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQgd2l0aCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbihzaXRlSWQpIHtcbiAgICAgICAgc2l0ZUlkID0gc2l0ZUlkIHx8ICRtbVNpdGUuZ2V0SWQoKTtcblxuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZUlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX3N1cnZleV9nZXRfcXVlc3Rpb25zJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX3N1cnZleV9nZXRfc3VydmV5c19ieV9jb3Vyc2VzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS53c0F2YWlsYWJsZSgnbW9kX3N1cnZleV9zdWJtaXRfYW5zd2VycycpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IHRoZSBzdXJ2ZXkgYXMgYmVpbmcgdmlld2VkLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3N1cnZleVxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kU3VydmV5I2xvZ1ZpZXdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgU3VydmV5IElELlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIFdTIGNhbGwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBzZWxmLmxvZ1ZpZXcgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgc3VydmV5aWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9zdXJ2ZXlfdmlld19zdXJ2ZXknLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2VuZCBzdXJ2ZXkgYW5zd2VycyB0byBNb29kbGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2Rfc3VydmV5XG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RTdXJ2ZXkjc3VibWl0QW5zd2Vyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdXJ2ZXlpZCAgdXJ2ZXkgSUQuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gYW5zd2VycyBBbnN3ZXJzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFuc3dlcnMgYXJlIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQuXG4gICAgICovXG4gICAgc2VsZi5zdWJtaXRBbnN3ZXJzID0gZnVuY3Rpb24oc3VydmV5aWQsIGFuc3dlcnMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHN1cnZleWlkOiBzdXJ2ZXlpZCxcbiAgICAgICAgICAgIGFuc3dlcnM6IGFuc3dlcnNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ21vZF9zdXJ2ZXlfc3VibWl0X2Fuc3dlcnMnLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF91cmwnKVxuXG4vKipcbiAqIFVSTCBpbmRleCBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF91cmxcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFNb2RVcmxJbmRleEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU1vZFVybEluZGV4Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkbW1hTW9kVXJsLCAkbW1Db3Vyc2UpIHtcbiAgICB2YXIgbW9kdWxlID0gJHN0YXRlUGFyYW1zLm1vZHVsZSB8fCB7fSxcbiAgICAgICAgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQ7XG4gICAgJHNjb3BlLnRpdGxlID0gbW9kdWxlLm5hbWU7XG4gICAgJHNjb3BlLmRlc2NyaXB0aW9uID0gbW9kdWxlLmRlc2NyaXB0aW9uO1xuICAgICRzY29wZS51cmwgPSAobW9kdWxlLmNvbnRlbnRzICYmIG1vZHVsZS5jb250ZW50c1swXSAmJiBtb2R1bGUuY29udGVudHNbMF0uZmlsZXVybCkgPyBtb2R1bGUuY29udGVudHNbMF0uZmlsZXVybCA6IHVuZGVmaW5lZDtcblxuICAgICRzY29wZS5nbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkbW1hTW9kVXJsLmxvZ1ZpZXcobW9kdWxlLmluc3RhbmNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tQ291cnNlLmNoZWNrTW9kdWxlQ29tcGxldGlvbihjb3Vyc2VpZCwgbW9kdWxlLmNvbXBsZXRpb25zdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgJG1tYU1vZFVybC5vcGVuKCRzY29wZS51cmwpO1xuICAgIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm1vZF91cmwnKVxuXG4vKipcbiAqIE1vZCBVUkwgaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3VybFxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFNb2RVcmxIYW5kbGVyc1xuICovXG4uZmFjdG9yeSgnJG1tYU1vZFVybEhhbmRsZXJzJywgZnVuY3Rpb24oJG1tQ291cnNlLCAkbW1hTW9kVXJsLCAkc3RhdGUsICRtbVV0aWwsICRtbUNvbnRlbnRMaW5rc0hlbHBlciwgJHEpIHtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgY29udGVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubW9kX3VybFxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTW9kVXJsSGFuZGxlcnMjY291cnNlQ29udGVudEhhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmNvdXJzZUNvbnRlbnRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2R1bGUgaXMgZW5hYmxlZCBmb3IgdGhlIHNpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBUaGUgbW9kdWxlIGluZm8uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VpZCBUaGUgY291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgY291cnNlaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWNvbiA9ICRtbUNvdXJzZS5nZXRNb2R1bGVJY29uU3JjKCd1cmwnKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSBtb2R1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ3NpdGUubW9kX3VybCcsIHttb2R1bGU6IG1vZHVsZSwgY291cnNlaWQ6IGNvdXJzZWlkfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuY29udGVudHMgJiYgbW9kdWxlLmNvbnRlbnRzWzBdICYmIG1vZHVsZS5jb250ZW50c1swXS5maWxldXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5idXR0b25zID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246ICdpb24tbGluaycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ21tLmNvcmUub3BlbmluYnJvd3NlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbWFNb2RVcmwubG9nVmlldyhtb2R1bGUuaW5zdGFuY2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtbUNvdXJzZS5jaGVja01vZHVsZUNvbXBsZXRpb24oY291cnNlaWQsIG1vZHVsZS5jb21wbGV0aW9uc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1hTW9kVXJsLm9wZW4obW9kdWxlLmNvbnRlbnRzWzBdLmZpbGV1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfdXJsXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RVcmxIYW5kbGVycyNsaW5rc0hhbmRsZXJcbiAgICAgKi9cbiAgICBzZWxmLmxpbmtzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQgZm9yIGEgY2VydGFpbiBzaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpdGVJZCAgICAgU2l0ZSBJRC5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBbY291cnNlSWRdIENvdXJzZSBJRCByZWxhdGVkIHRvIHRoZSBVUkwuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKHNpdGVJZCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIGlmIChjb3Vyc2VJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS53aGVuKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRtbUNvdXJzZS5jYW5HZXRNb2R1bGVXaXRob3V0Q291cnNlSWQoc2l0ZUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWN0aW9ucyB0byBwZXJmb3JtIHdpdGggdGhlIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHNpdGVJZHMgIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICAgVVJMIHRvIHRyZWF0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdXJzZUlkXSBDb3Vyc2UgSUQgcmVsYXRlZCB0byB0aGUgVVJMLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGxpc3Qgb2YgYWN0aW9ucy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZSNyZWdpc3RlckxpbmtIYW5kbGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKHNpdGVJZHMsIHVybCwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGl0J3MgYSBtb2RfdXJsIFVSTC5cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignL21vZC91cmwvdmlldy5waHAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUNvbnRlbnRMaW5rc0hlbHBlci50cmVhdE1vZHVsZUluZGV4VXJsKHNpdGVJZHMsIHVybCwgaXNFbmFibGVkLCBjb3Vyc2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHEud2hlbihbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5tb2RfdXJsJylcblxuLyoqXG4gKiBVUkwgc2VydmljZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfdXJsXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYU1vZFVybFxuICovXG4uZmFjdG9yeSgnJG1tYU1vZFVybCcsIGZ1bmN0aW9uKCRtbVNpdGUsICRtbVV0aWwsICRxKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCBhIFVSTCBhcyBiZWluZyB2aWV3ZWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5tb2RfdXJsXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFNb2RVcmwjbG9nVmlld1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBNb2R1bGUgSUQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgV1MgY2FsbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHNlbGYubG9nVmlldyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1cmxpZDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnbW9kX3VybF92aWV3X3VybCcsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIFVSTC5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm1vZF91cmxcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU1vZFVybCNvcGVuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGdvIHRvLlxuICAgICAqL1xuICAgIHNlbGYub3BlbiA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAkbW1VdGlsLm9wZW5JbkJyb3dzZXIodXJsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm5vdGVzJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGhhbmRsZSBub3Rlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3Rlc1xuICogQG5nZG9jIGNvbnRyb2xsZXJcbiAqIEBuYW1lIG1tYU5vdGVzTGlzdEN0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU5vdGVzTGlzdEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJG1tVXRpbCwgJG1tYU5vdGVzLCAkbW1TaXRlLCAkdHJhbnNsYXRlKSB7XG5cbiAgICB2YXIgY291cnNlaWQgPSAkc3RhdGVQYXJhbXMuY291cnNlaWQsXG4gICAgICAgIHR5cGUgPSAkc3RhdGVQYXJhbXMudHlwZTtcblxuICAgICRzY29wZS5jb3Vyc2VpZCA9IGNvdXJzZWlkO1xuICAgICRzY29wZS50eXBlID0gdHlwZTtcblxuICAgICR0cmFuc2xhdGUoJ21tYS5ub3Rlcy4nICsgdHlwZSArICdub3RlcycpLnRoZW4oZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICRzY29wZS50aXRsZSA9IHN0cmluZztcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZldGNoTm90ZXMocmVmcmVzaCkge1xuICAgICAgICByZXR1cm4gJG1tYU5vdGVzLmdldE5vdGVzKGNvdXJzZWlkLCByZWZyZXNoKS50aGVuKGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgICAgICAgICBub3RlcyA9IG5vdGVzW3R5cGUgKyAnbm90ZXMnXTtcblxuICAgICAgICAgICAgcmV0dXJuICRtbWFOb3Rlcy5nZXROb3Rlc1VzZXJEYXRhKG5vdGVzLCBjb3Vyc2VpZCkudGhlbihmdW5jdGlvbihub3Rlcykge1xuICAgICAgICAgICAgICAgICRzY29wZS5ub3RlcyA9IG5vdGVzO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbChtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmV0Y2hOb3RlcygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEFkZCBsb2cgaW4gTW9vZGxlLlxuICAgICAgICAkbW1TaXRlLndyaXRlKCdjb3JlX25vdGVzX3ZpZXdfbm90ZXMnLCB7XG4gICAgICAgICAgICBjb3Vyc2VpZDogY291cnNlaWQsXG4gICAgICAgICAgICB1c2VyaWQ6IDBcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLm5vdGVzTG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgICRzY29wZS5yZWZyZXNoTm90ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmV0Y2hOb3Rlcyh0cnVlKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubm90ZXMnKVxuXG4vKipcbiAqIE5vdGUgdHlwZXMgdmlldyBjb250cm9sbGVyLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGVzXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTm90ZXNUeXBlc0N0cmxcbiAqL1xuLmNvbnRyb2xsZXIoJ21tYU5vdGVzVHlwZXNDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMpIHtcbiAgICB2YXIgY291cnNlID0gJHN0YXRlUGFyYW1zLmNvdXJzZSxcbiAgICAgICAgY291cnNlaWQgPSBjb3Vyc2UuaWQ7XG4gICAgJHNjb3BlLmNvdXJzZWlkID0gY291cnNlaWQ7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm5vdGVzJylcblxuLyoqXG4gKiBOb3RlcyBoYW5kbGVycyBmYWN0b3J5LlxuICpcbiAqIFRoaXMgZmFjdG9yeSBob2xkcyB0aGUgZGlmZmVyZW50IGhhbmRsZXJzIHVzZWQgZm9yIGRlbGVnYXRlcy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3Rlc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFOb3Rlc0hhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hTm90ZXNIYW5kbGVycycsIGZ1bmN0aW9uKCRtbWFOb3RlcywgJG1tU2l0ZSwgJG1tQXBwLCAkaW9uaWNNb2RhbCwgJG1tVXRpbCwgbW1Db3Vyc2VzQWNjZXNzTWV0aG9kcykge1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5vdGUgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3Rlc0hhbmRsZXJzI2FkZE5vdGVcbiAgICAgKi9cbiAgICBzZWxmLmFkZE5vdGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRtbWFOb3Rlcy5pc1BsdWdpbkFkZE5vdGVFbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgdGhpcyB1c2VyIGluIHRoaXMgY29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXIgICAgIFVzZXIgdG8gY2hlY2suXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWRGb3JVc2VyID0gZnVuY3Rpb24odXNlciwgY291cnNlSWQpIHtcbiAgICAgICAgICAgIC8vIEFjdGl2ZSBjb3Vyc2UgcmVxdWlyZWQuXG4gICAgICAgICAgICByZXR1cm4gY291cnNlSWQgJiYgdXNlci5pZCAhPSAkbW1TaXRlLmdldFVzZXJJZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyICAgICBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBDb250cm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24odXNlciwgY291cnNlaWQpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGQgbm90ZSBoYW5kbGVyIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMubm90ZXNcbiAgICAgICAgICAgICAqIEBuZ2RvYyBjb250cm9sbGVyXG4gICAgICAgICAgICAgKiBAbmFtZSAkbW1hTm90ZXNIYW5kbGVycyNhZGROb3RlOmNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQnV0dG9uIHRpdGxlLlxuICAgICAgICAgICAgICAgICRzY29wZS50aXRsZSA9ICdtbWEubm90ZXMuYWRkbmV3bm90ZSc7XG5cbiAgICAgICAgICAgICAgICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ2FkZG9ucy9ub3Rlcy90ZW1wbGF0ZXMvYWRkLmh0bWwnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlOiAkc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogJ3NsaWRlLWluLXVwJ1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUubW9kYWwgPSBtO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlTW9kYWwgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuYWRkTm90ZSA9IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAgICAgJG1tQXBwLmNsb3NlS2V5Ym9hcmQoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZGluZ01vZGFsID0gJG1tVXRpbC5zaG93TW9kYWxMb2FkaW5nKCdtbS5jb3JlLnNlbmRpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRnJlZXplIHRoZSBhZGQgbm90ZSBidXR0b24uXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5wcm9jZXNzaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAkbW1hTm90ZXMuYWRkTm90ZSh1c2VyLmlkLCBjb3Vyc2VpZCwgJHNjb3BlLm5vdGUucHVibGlzaHN0YXRlLCAkc2NvcGUubm90ZS50ZXh0KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93TW9kYWwoJ21tLmNvcmUuc3VjY2VzcycsICdtbWEubm90ZXMuZXZlbnRub3RlY3JlYXRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlTW9kYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtbVV0aWwuc2hvd0Vycm9yTW9kYWwoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmdNb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm5vdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoc3RhdGU6ICdwZXJzb25hbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUucHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5tb2RhbC5zaG93KCk7XG5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb3Vyc2UgbmF2IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3Rlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTm90ZXNIYW5kbGVycyNjb3Vyc2VzTmF2XG4gICAgICovXG4gICAgc2VsZi5jb3Vyc2VzTmF2ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgaGFuZGxlciBpcyBlbmFibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1hTm90ZXMuaXNQbHVnaW5WaWV3Tm90ZXNFbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgdGhpcyBjb3Vyc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCAgIENvdXJzZSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFjY2Vzc0RhdGEgVHlwZSBvZiBhY2Nlc3MgdG8gdGhlIGNvdXJzZTogZGVmYXVsdCwgZ3Vlc3QsIC4uLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWRGb3JDb3Vyc2UgPSBmdW5jdGlvbihjb3Vyc2VJZCwgYWNjZXNzRGF0YSkge1xuICAgICAgICAgICAgaWYgKGFjY2Vzc0RhdGEgJiYgYWNjZXNzRGF0YS50eXBlID09IG1tQ291cnNlc0FjY2Vzc01ldGhvZHMuZ3Vlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vdCBlbmFibGVkIGZvciBndWVzdHMuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgQ291cnNlIElELlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgQ29udHJvbGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKGNvdXJzZUlkKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ291cnNlcyBuYXYgaGFuZGxlciBjb250cm9sbGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGVzXG4gICAgICAgICAgICAgKiBAbmdkb2MgY29udHJvbGxlclxuICAgICAgICAgICAgICogQG5hbWUgJG1tYU5vdGVzSGFuZGxlcnMjY291cnNlc05hdjpjb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJ2lvbi1pb3MtbGlzdCc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5ub3Rlcy5ub3Rlcyc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjdGlvbiA9IGZ1bmN0aW9uKCRldmVudCwgY291cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc2l0ZS5ub3Rlcy10eXBlcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdXJzZTogY291cnNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubm90ZXMnKVxuXG4vKipcbiAqIE5vdGVzIGZhY3RvcnkuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubm90ZXNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTm90ZXNcbiAqL1xuLmZhY3RvcnkoJyRtbWFOb3RlcycsIGZ1bmN0aW9uKCRtbVNpdGUsICRsb2csICRxLCAkbW1Vc2VyLCAkdHJhbnNsYXRlKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbWFOb3RlcycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5vdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3Rlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTm90ZXMjYWRkTm90ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1c2VySWQgICAgICAgVXNlciBJRCBvZiB0aGUgcGVyc29uIHRvIGFkZCB0aGUgbm90ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291cnNlSWQgICAgIENvdXJzZSBJRCB3aGVyZSB0aGUgbm90ZSBiZWxvbmdzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwdWJsaXNoU3RhdGUgUGVyc29uYWwsIFNpdGUgb3IgQ291cnNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBub3RlVGV4dCAgICAgVGhlIG5vdGUgdGV4dC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNlbGYuYWRkTm90ZSA9IGZ1bmN0aW9uKHVzZXJJZCwgY291cnNlSWQsIHB1Ymxpc2hTdGF0ZSwgbm90ZVRleHQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBcIm5vdGVzWzBdW3VzZXJpZF1cIiA6IHVzZXJJZCxcbiAgICAgICAgICAgIFwibm90ZXNbMF1bcHVibGlzaHN0YXRlXVwiOiBwdWJsaXNoU3RhdGUsXG4gICAgICAgICAgICBcIm5vdGVzWzBdW2NvdXJzZWlkXVwiOiBjb3Vyc2VJZCxcbiAgICAgICAgICAgIFwibm90ZXNbMF1bdGV4dF1cIjogbm90ZVRleHQsXG4gICAgICAgICAgICBcIm5vdGVzWzBdW2Zvcm1hdF1cIjogMVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53cml0ZSgnY29yZV9ub3Rlc19jcmVhdGVfbm90ZXMnLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgYWRkIG5vdGUgcGx1Z2luIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IHNpdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgcXVpdGUgb2Z0ZW4gYW5kIHRodXMgc2hvdWxkIG9ubHkgcGVyZm9ybSBhIHF1aWNrXG4gICAgICogY2hlY2ssIHdlIHNob3VsZCBub3QgYmUgY2FsbGluZyBXUyBmcm9tIGhlcmUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3Rlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTm90ZXMjaXNQbHVnaW5BZGROb3RlRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpbkFkZE5vdGVFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbmZvcztcblxuICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoISRtbVNpdGUuY2FuVXNlQWR2YW5jZWRGZWF0dXJlKCdlbmFibGVub3RlcycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoISRtbVNpdGUud3NBdmFpbGFibGUoJ2NvcmVfbm90ZXNfY3JlYXRlX25vdGVzJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWFkIG5vdGVzIHBsdWdpbiBpcyBlbmFibGVkIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHF1aXRlIG9mdGVuIGFuZCB0aHVzIHNob3VsZCBvbmx5IHBlcmZvcm0gYSBxdWlja1xuICAgICAqIGNoZWNrLCB3ZSBzaG91bGQgbm90IGJlIGNhbGxpbmcgV1MgZnJvbSBoZXJlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubm90ZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU5vdGVzI2lzUGx1Z2luVmlld05vdGVzRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2VsZi5pc1BsdWdpblZpZXdOb3Rlc0VuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGluZm9zO1xuXG4gICAgICAgIGlmICghJG1tU2l0ZS5pc0xvZ2dlZEluKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghJG1tU2l0ZS5jYW5Vc2VBZHZhbmNlZEZlYXR1cmUoJ2VuYWJsZW5vdGVzJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghJG1tU2l0ZS53c0F2YWlsYWJsZSgnY29yZV9ub3Rlc19nZXRfY291cnNlX25vdGVzJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlcnMgbm90ZXMgZm9yIGEgY2VydGFpbiBzaXRlLCBjb3Vyc2UgYW5kIHBlcnNvbmFsIG5vdGVzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubm90ZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU5vdGVzI2dldE5vdGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZWlkIElEIG9mIHRoZSBjb3Vyc2UgdG8gZ2V0IHRoZSBub3RlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVmcmVzaCBUcnVlIHdoZW4gd2Ugc2hvdWxkIG5vdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIGNhY2hlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW4gdGhlIG5vdGVzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXROb3RlcyA9IGZ1bmN0aW9uKGNvdXJzZWlkLCByZWZyZXNoKSB7XG5cbiAgICAgICAgJGxvZy5kZWJ1ZygnR2V0IG5vdGVzIGZvciBjb3Vyc2UgJyArIGNvdXJzZWlkKTtcblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VpZCA6IGNvdXJzZWlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlc2V0cyA9IHt9O1xuICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgcHJlc2V0cy5nZXRGcm9tQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQoJ2NvcmVfbm90ZXNfZ2V0X2NvdXJzZV9ub3RlcycsIGRhdGEsIHByZXNldHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBkYXRhIGZvciBub3RlcyBzaW5jZSB0aGV5IG9ubHkgaGF2ZSB1c2VyaWQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3Rlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTm90ZXMjZ2V0Tm90ZXNVc2VyRGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG5vdGVzICAgICAgIE5vdGVzIHRvIGdldCB0aGUgZGF0YSBmb3IuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgY291cnNlaWQgICAgSUQgb2YgdGhlIGNvdXJzZSB0aGUgbm90ZXMgYmVsb25nIHRvLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgIFByb21pc2UgYWx3YXlzIHJlc29sdmVkLiBSZXNvbHZlIHBhcmFtIGlzIHRoZSBmb3JtYXR0ZWQgbm90ZXMuXG4gICAgICovXG4gICAgc2VsZi5nZXROb3Rlc1VzZXJEYXRhID0gZnVuY3Rpb24obm90ZXMsIGNvdXJzZWlkKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChub3RlcywgZnVuY3Rpb24obm90ZSkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSAkbW1Vc2VyLmdldFByb2ZpbGUobm90ZS51c2VyaWQsIGNvdXJzZWlkLCB0cnVlKS50aGVuKGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgICAgICAgICBub3RlLnVzZXJmdWxsbmFtZSA9IHVzZXIuZnVsbG5hbWU7XG4gICAgICAgICAgICAgICAgbm90ZS51c2VycHJvZmlsZWltYWdldXJsID0gdXNlci5wcm9maWxlaW1hZ2V1cmw7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBnZXR0aW5nIHByb2ZpbGUuIFNldCBkZWZhdWx0IGRhdGEuXG4gICAgICAgICAgICAgICAgcmV0dXJuICR0cmFuc2xhdGUoJ21tYS5ub3Rlcy51c2Vyd2l0aGlkJywge2lkOiBub3RlLnVzZXJpZH0pLnRoZW4oZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGUudXNlcmZ1bGxuYW1lID0gc3RyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBub3RlcztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5ub3RpZmljYXRpb25zJylcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGhhbmRsZSBub3RpZmljYXRpb24gbGlzdC5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3RpZmljYXRpb25zXG4gKiBAbmdkb2MgY29udHJvbGxlclxuICogQG5hbWUgbW1hTm90aWZpY2F0aW9uc0xpc3RDdHJsXG4gKi9cbi5jb250cm9sbGVyKCdtbWFOb3RpZmljYXRpb25zTGlzdEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRtbVV0aWwsICRtbWFOb3RpZmljYXRpb25zLCBtbWFOb3RpZmljYXRpb25zTGlzdExpbWl0KSB7XG5cbiAgICB2YXIgcmVhZENvdW50ID0gMCxcbiAgICAgICAgdW5yZWFkQ291bnQgPSAwO1xuXG4gICAgJHNjb3BlLm5vdGlmaWNhdGlvbnMgPSBbXTtcblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBub3RpZmljYXRpb25zLiBHZXQgdW5yZWFkIG5vdGlmaWNhdGlvbnMgZmlyc3QuXG4gICAgZnVuY3Rpb24gZmV0Y2hOb3RpZmljYXRpb25zKHJlZnJlc2gpIHtcblxuICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgcmVhZENvdW50ID0gMDtcbiAgICAgICAgICAgIHVucmVhZENvdW50ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1hTm90aWZpY2F0aW9ucy5nZXRVbnJlYWROb3RpZmljYXRpb25zKHVucmVhZENvdW50LMKgbW1hTm90aWZpY2F0aW9uc0xpc3RMaW1pdCkudGhlbihmdW5jdGlvbih1bnJlYWQpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGFkZCB0aGUgdW5yZWFkIG5vdGlmaWNhdGlvbnMgdG8gJHNjb3BlLm5vdGlmaWNhdGlvbnMgeWV0LiBJZiB0aGVyZSBhcmUgbm8gdW5yZWFkIG5vdGlmaWNhdGlvbnNcbiAgICAgICAgICAgIC8vIHRoYXQgY2F1c2VzIHRoYXQgdGhlIFwiVGhlcmUgYXJlIG5vIG5vdGlmaWNhdGlvbnNcIiBtZXNzYWdlIGlzIHNob3duIGluIHB1bGwgdG8gcmVmcmVzaC5cbiAgICAgICAgICAgIHVucmVhZENvdW50ICs9IHVucmVhZC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICh1bnJlYWQubGVuZ3RoIDwgbW1hTm90aWZpY2F0aW9uc0xpc3RMaW1pdCkge1xuICAgICAgICAgICAgICAgIC8vIExpbWl0IG5vdCByZWFjaGVkLiBHZXQgcmVhZCBub3RpZmljYXRpb25zIHVudGlsIHJlYWNoIHRoZSBsaW1pdC5cbiAgICAgICAgICAgICAgICB2YXIgcmVhZExpbWl0ID3CoG1tYU5vdGlmaWNhdGlvbnNMaXN0TGltaXQgLSB1bnJlYWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW1hTm90aWZpY2F0aW9ucy5nZXRSZWFkTm90aWZpY2F0aW9ucyhyZWFkQ291bnQsIHJlYWRMaW1pdCkudGhlbihmdW5jdGlvbihyZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRDb3VudCArPSByZWFkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5ub3RpZmljYXRpb25zID0gdW5yZWFkLmNvbmNhdChyZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5ub3RpZmljYXRpb25zID0gJHNjb3BlLm5vdGlmaWNhdGlvbnMuY29uY2F0KHVucmVhZCkuY29uY2F0KHJlYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IHJlYWQubGVuZ3RoID49IHJlYWRMaW1pdDtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5yZWFkLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm5vdGlmaWNhdGlvbnMuZXJyb3JnZXRub3RpZmljYXRpb25zJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2FuTG9hZE1vcmUgPSBmYWxzZTsgLy8gU2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgaW5maW5pdGUgY2FsbHMgd2l0aCBpbmZpbml0ZS1sb2FkaW5nLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5ub3RpZmljYXRpb25zID0gdW5yZWFkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5ub3RpZmljYXRpb25zID0gJHNjb3BlLm5vdGlmaWNhdGlvbnMuY29uY2F0KHVucmVhZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRzY29wZS5jYW5Mb2FkTW9yZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJG1tVXRpbC5zaG93RXJyb3JNb2RhbCgnbW1hLm5vdGlmaWNhdGlvbnMuZXJyb3JnZXRub3RpZmljYXRpb25zJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuY2FuTG9hZE1vcmUgPSBmYWxzZTsgLy8gU2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgaW5maW5pdGUgY2FsbHMgd2l0aCBpbmZpbml0ZS1sb2FkaW5nLlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmV0Y2hOb3RpZmljYXRpb25zKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLm5vdGlmaWNhdGlvbnNMb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLnJlZnJlc2hOb3RpZmljYXRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFOb3RpZmljYXRpb25zLmludmFsaWRhdGVOb3RpZmljYXRpb25zTGlzdCgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmZXRjaE5vdGlmaWNhdGlvbnModHJ1ZSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUubG9hZE1vcmVOb3RpZmljYXRpb25zID0gZnVuY3Rpb24oKXtcbiAgICAgICAgZmV0Y2hOb3RpZmljYXRpb25zKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwuaW5maW5pdGVTY3JvbGxDb21wbGV0ZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5ub3RpZmljYXRpb25zJylcblxuLyoqXG4gKiBOb3RpZmljYXRpb24gYWN0aW9uIGRpcmVjdGl2ZS5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3RpZmljYXRpb25zXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtbWFOb3RpZmljYXRpb25zQWN0aW9uc1xuICovXG4uZGlyZWN0aXZlKCdtbWFOb3RpZmljYXRpb25zQWN0aW9ucycsIGZ1bmN0aW9uKCRsb2csICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlKSB7XG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJ21tYU5vdGlmaWNhdGlvbnNBY3Rpb25zJyk7XG5cbiAgICAvLyBEaXJlY3RpdmUgbGluayBmdW5jdGlvbi5cbiAgICBmdW5jdGlvbiBsaW5rKHNjb3BlKSB7XG4gICAgICAgIGlmIChzY29wZS5jb250ZXh0dXJsKSB7XG4gICAgICAgICAgICAkbW1Db250ZW50TGlua3NEZWxlZ2F0ZS5nZXRBY3Rpb25zRm9yKHNjb3BlLmNvbnRleHR1cmwsIHNjb3BlLmNvdXJzZWlkKS50aGVuKGZ1bmN0aW9uKGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5hY3Rpb25zID0gYWN0aW9ucztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluazogbGluayxcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgIGNvbnRleHR1cmw6ICc9JyxcbiAgICAgICAgICAgIGNvdXJzZWlkOiAnPSdcbiAgICAgICAgfSxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdhZGRvbnMvbm90aWZpY2F0aW9ucy90ZW1wbGF0ZXMvYWN0aW9ucy5odG1sJyxcbiAgICB9O1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5ub3RpZmljYXRpb25zJylcblxuLyoqXG4gKiBGaWx0ZXIgdG8gZm9ybWF0IGEgbm90aWZpY2F0aW9uLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGlmaWNhdGlvbnNcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIG1tYU5vdGlmaWNhdGlvbnNGb3JtYXRcbiAqL1xuLmZpbHRlcignbW1hTm90aWZpY2F0aW9uc0Zvcm1hdCcsIGZ1bmN0aW9uKCRtbVRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8tezQsfS9pZywgJycpO1xuICAgIHRleHQgPSAkbW1UZXh0LnJlcGxhY2VOZXdMaW5lcyh0ZXh0LCAnPGJyIC8+Jyk7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLm5vdGlmaWNhdGlvbnMnKVxuXG4vKipcbiAqIE5vdGlmaWNhdGlvbnMgaGFuZGxlcnMgZmFjdG9yeS5cbiAqXG4gKiBUaGlzIGZhY3RvcnkgaG9sZHMgdGhlIGRpZmZlcmVudCBoYW5kbGVycyB1c2VkIGZvciBkZWxlZ2F0ZXMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMubm90aWZpY2F0aW9uc1xuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRtbWFOb3RpZmljYXRpb25zSGFuZGxlcnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFOb3RpZmljYXRpb25zSGFuZGxlcnMnLCBmdW5jdGlvbigkbG9nLCAkbW1hTm90aWZpY2F0aW9ucykge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hTm90aWZpY2F0aW9uc0hhbmRsZXJzJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogU2lkZSBtZW51IG5hdiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubm90aWZpY2F0aW9uc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTm90aWZpY2F0aW9uc0hhbmRsZXJzI3NpZGVNZW51TmF2XG4gICAgICovXG4gICAgc2VsZi5zaWRlTWVudU5hdiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBoYW5kbGVyIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJG1tYU5vdGlmaWNhdGlvbnMuaXNQbHVnaW5FbmFibGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBDb250cm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2lkZSBtZW51IG5hdiBoYW5kbGVyIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1vZHVsZSBtbS5hZGRvbnMubm90aWZpY2F0aW9uc1xuICAgICAgICAgICAgICogQG5nZG9jIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBuYW1lICRtbWFOb3RpZmljYXRpb25zSGFuZGxlcnMjc2lkZU1lbnVOYXY6Y29udHJvbGxlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmljb24gPSAnaW9uLWlvcy1iZWxsJztcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnbW1hLm5vdGlmaWNhdGlvbnMubm90aWZpY2F0aW9ucyc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnN0YXRlID0gJ3NpdGUubm90aWZpY2F0aW9ucyc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMubm90aWZpY2F0aW9ucycpXG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgbm90aWZpY2F0aW9ucyAobWVzc2FnZXMpLlxuICpcbiAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGlmaWNhdGlvbnNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hTm90aWZpY2F0aW9uc1xuICovXG4uZmFjdG9yeSgnJG1tYU5vdGlmaWNhdGlvbnMnLCBmdW5jdGlvbigkcSwgJGxvZywgJG1tU2l0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCBtbWFOb3RpZmljYXRpb25zTGlzdExpbWl0KSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYU5vdGlmaWNhdGlvbnMnKTtcblxuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvLyBGdW5jdGlvbiB0byBmb3JtYXQgbm90aWZpY2F0aW9uIGRhdGEuXG4gICAgZnVuY3Rpb24gZm9ybWF0Tm90aWZpY2F0aW9uc0RhdGEobm90aWZpY2F0aW9ucykge1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gobm90aWZpY2F0aW9ucywgZnVuY3Rpb24obm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAvLyBTZXQgbWVzc2FnZSB0byBzaG93LlxuICAgICAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi5jb250ZXh0dXJsICYmIG5vdGlmaWNhdGlvbi5jb250ZXh0dXJsLmluZGV4T2YoJy9tb2QvZm9ydW0vJykpIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb24ubW9iaWxldGV4dCA9IG5vdGlmaWNhdGlvbi5zbWFsbG1lc3NhZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5tb2JpbGV0ZXh0ID0gbm90aWZpY2F0aW9uLmZ1bGxtZXNzYWdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUcnkgdG8gc2V0IGNvdXJzZWlkIHRoZSBub3RpZmljYXRpb24gYmVsb25ncyB0by5cbiAgICAgICAgICAgIHZhciBjaWQgPSBub3RpZmljYXRpb24uZnVsbG1lc3NhZ2VodG1sLm1hdGNoKC9jb3Vyc2VcXC92aWV3XFwucGhwXFw/aWQ9KFteXCJdKikvKTtcbiAgICAgICAgICAgIGlmIChjaWQgJiYgY2lkWzFdKSB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uLmNvdXJzZWlkID0gY2lkWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUga2V5IGZvciBub3RpZmljYXRpb24gbGlzdCBXUyBjYWxscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ2FjaGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5vdGlmaWNhdGlvbnNDYWNoZUtleSgpIHtcbiAgICAgICAgcmV0dXJuICdtbWFOb3RpZmljYXRpb25zOmxpc3QnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbm90aWZpY2F0aW9ucyBmcm9tIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3RpZmljYXRpb25zI2dldE5vdGlmaWNhdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlYWQgICAgICAgVHJ1ZSBpZiBzaG91bGQgZ2V0IHJlYWQgbm90aWZpY2F0aW9ucywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdEZyb20gICBQb3NpdGlvbiBvZiB0aGUgZmlyc3Qgbm90aWZpY2F0aW9uIHRvIGdldC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXROdW1iZXIgTnVtYmVyIG9mIG5vdGlmaWNhdGlvbnMgdG8gZ2V0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICBQcm9taXNlIHJlc29sdmVkIHdpdGggbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBzZWxmLmdldE5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbihyZWFkLCBsaW1pdEZyb20sIGxpbWl0TnVtYmVyKSB7XG4gICAgICAgIGxpbWl0RnJvbSA9IGxpbWl0RnJvbSB8fCAwO1xuICAgICAgICBsaW1pdE51bWJlciA9IGxpbWl0TnVtYmVyIHx8wqBtbWFOb3RpZmljYXRpb25zTGlzdExpbWl0O1xuXG4gICAgICAgICRsb2cuZGVidWcoJ0dldCAnICsgKHJlYWQgPyAncmVhZCcgOiAndW5yZWFkJykgKyAnIG5vdGlmaWNhdGlvbnMgZnJvbSAnICsgbGltaXRGcm9tICsgJy4gTGltaXQ6ICcgKyBsaW1pdE51bWJlcik7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICB1c2VyaWR0bzogJG1tU2l0ZS5nZXRVc2VySWQoKSxcbiAgICAgICAgICAgIHVzZXJpZGZyb206IDAsXG4gICAgICAgICAgICB0eXBlOiAnbm90aWZpY2F0aW9ucycsXG4gICAgICAgICAgICByZWFkOiByZWFkID8gMSA6IDAsXG4gICAgICAgICAgICBuZXdlc3RmaXJzdDogMSxcbiAgICAgICAgICAgIGxpbWl0ZnJvbTogbGltaXRGcm9tLFxuICAgICAgICAgICAgbGltaXRudW06IGxpbWl0TnVtYmVyXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwcmVTZXRzID0ge1xuICAgICAgICAgICAgY2FjaGVLZXk6IGdldE5vdGlmaWNhdGlvbnNDYWNoZUtleSgpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2V0IHVucmVhZCBub3RpZmljYXRpb25zLlxuICAgICAgICByZXR1cm4gJG1tU2l0ZS5yZWFkKCdjb3JlX21lc3NhZ2VfZ2V0X21lc3NhZ2VzJywgZGF0YSwgcHJlU2V0cykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdGlmaWNhdGlvbnMgPSByZXNwb25zZS5tZXNzYWdlcztcbiAgICAgICAgICAgICAgICBmb3JtYXROb3RpZmljYXRpb25zRGF0YShub3RpZmljYXRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90aWZpY2F0aW9ucztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHJlYWQgbm90aWZpY2F0aW9ucyBmcm9tIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3RpZmljYXRpb25zI2dldFJlYWROb3RpZmljYXRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0RnJvbSAgIFBvc2l0aW9uIG9mIHRoZSBmaXJzdCBub3RpZmljYXRpb24gdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdE51bWJlciBOdW1iZXIgb2Ygbm90aWZpY2F0aW9ucyB0byBnZXQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0UmVhZE5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbihsaW1pdEZyb20sIGxpbWl0TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldE5vdGlmaWNhdGlvbnModHJ1ZSwgbGltaXRGcm9tLCBsaW1pdE51bWJlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB1bnJlYWQgbm90aWZpY2F0aW9ucyBmcm9tIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5ub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFOb3RpZmljYXRpb25zI2dldFVucmVhZE5vdGlmaWNhdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXRGcm9tICAgUG9zaXRpb24gb2YgdGhlIGZpcnN0IG5vdGlmaWNhdGlvbiB0byBnZXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0TnVtYmVyIE51bWJlciBvZiBub3RpZmljYXRpb25zIHRvIGdldC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIG5vdGlmaWNhdGlvbnMuXG4gICAgICovXG4gICAgc2VsZi5nZXRVbnJlYWROb3RpZmljYXRpb25zID0gZnVuY3Rpb24obGltaXRGcm9tLCBsaW1pdE51bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXROb3RpZmljYXRpb25zKGZhbHNlLCBsaW1pdEZyb20sIGxpbWl0TnVtYmVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgbm90aWZpY2F0aW9ucyBsaXN0IFdTIGNhbGxzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubm90aWZpY2F0aW9uc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTm90aWZpY2F0aW9ucyNpbnZhbGlkYXRlTm90aWZpY2F0aW9uc0xpc3RcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGxpc3QgaXMgaW52YWxpZGF0ZWQuXG4gICAgICovXG4gICAgc2VsZi5pbnZhbGlkYXRlTm90aWZpY2F0aW9uc0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0Tm90aWZpY2F0aW9uc0NhY2hlS2V5KCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBwbHVnaW4gaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMubm90aWZpY2F0aW9uc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hTm90aWZpY2F0aW9ucyNpc1BsdWdpbkVuYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBsdWdpbiBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWxmLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZS53c0F2YWlsYWJsZSgnY29yZV9tZXNzYWdlX2dldF9tZXNzYWdlcycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBwbHVnaW4gaXMgYXZhaWxhYmxlIGZvciBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLm5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYU5vdGlmaWNhdGlvbnMjaXNQbHVnaW5FbmFibGVkRm9yU2l0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlaWQgU2l0ZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFJlc29sdmVkIHdoZW4gZW5hYmxlZCwgb3RoZXJ3aXNlIHJlamVjdGVkLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkRm9yU2l0ZSA9IGZ1bmN0aW9uKHNpdGVpZCkge1xuICAgICAgICByZXR1cm4gJG1tU2l0ZXNNYW5hZ2VyLmdldFNpdGUoc2l0ZWlkKS50aGVuKGZ1bmN0aW9uKHNpdGUpIHtcbiAgICAgICAgICAgIGlmICghc2l0ZS53c0F2YWlsYWJsZSgnY29yZV9tZXNzYWdlX2dldF9tZXNzYWdlcycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLnBhcnRpY2lwYW50cycpXG5cbi8qKlxuICogQ29udHJvbGxlciB0byBoYW5kbGUgY291cnNlIHBhcnRpY2lwYW50cy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5wYXJ0aWNpcGFudHNcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBtbWFQYXJ0aWNpcGFudHNMaXN0Q3RybFxuICovXG4uY29udHJvbGxlcignbW1hUGFydGljaXBhbnRzTGlzdEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgJHN0YXRlUGFyYW1zLCAkbW1VdGlsLCAkbW1hUGFydGljaXBhbnRzLCAkaW9uaWNQbGF0Zm9ybSwgJG1tU2l0ZSxcbiAgICAgICAgICAgIG1tVXNlclByb2ZpbGVTdGF0ZSkge1xuICAgIHZhciBjb3Vyc2UgPSAkc3RhdGVQYXJhbXMuY291cnNlLFxuICAgICAgICBjb3Vyc2VpZCA9IGNvdXJzZS5pZDtcblxuICAgICRzY29wZS5wYXJ0aWNpcGFudHMgPSBbXTtcbiAgICAkc2NvcGUuY291cnNlaWQgPSBjb3Vyc2VpZDtcbiAgICAkc2NvcGUudXNlclN0YXRlTmFtZSA9IG1tVXNlclByb2ZpbGVTdGF0ZTtcblxuICAgIGZ1bmN0aW9uIGZldGNoUGFydGljaXBhbnRzKHJlZnJlc2gpIHtcbiAgICAgICAgdmFyIGZpcnN0VG9HZXQgPSByZWZyZXNoID8gMCA6ICRzY29wZS5wYXJ0aWNpcGFudHMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gJG1tYVBhcnRpY2lwYW50cy5nZXRQYXJ0aWNpcGFudHMoY291cnNlaWQsIGZpcnN0VG9HZXQpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUucGFydGljaXBhbnRzID0gZGF0YS5wYXJ0aWNpcGFudHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5wYXJ0aWNpcGFudHMgPSAkc2NvcGUucGFydGljaXBhbnRzLmNvbmNhdChkYXRhLnBhcnRpY2lwYW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuY2FuTG9hZE1vcmUgPSBkYXRhLmNhbkxvYWRNb3JlO1xuICAgICAgICB9LCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAkbW1VdGlsLnNob3dFcnJvck1vZGFsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgJHNjb3BlLmNhbkxvYWRNb3JlID0gZmFsc2U7IC8vIFNldCB0byBmYWxzZSB0byBwcmV2ZW50IGluZmluaXRlIGNhbGxzIHdpdGggaW5maW5pdGUtbG9hZGluZy5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGZpcnN0IHBhcnRpY2lwYW50cy5cbiAgICBmZXRjaFBhcnRpY2lwYW50cyh0cnVlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBBZGQgbG9nIGluIE1vb2RsZS5cbiAgICAgICAgJG1tU2l0ZS53cml0ZSgnY29yZV91c2VyX3ZpZXdfdXNlcl9saXN0Jywge1xuICAgICAgICAgICAgY291cnNlaWQ6IGNvdXJzZWlkXG4gICAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5wYXJ0aWNpcGFudHNMb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gTG9hZCBtb3JlIHBhcnRpY2lwYW50cy5cbiAgICAkc2NvcGUubG9hZE1vcmVQYXJ0aWNpcGFudHMgPSBmdW5jdGlvbigpe1xuICAgICAgICBmZXRjaFBhcnRpY2lwYW50cygpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLmluZmluaXRlU2Nyb2xsQ29tcGxldGUnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5yZWZyZXNoUGFydGljaXBhbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRtbWFQYXJ0aWNpcGFudHMuaW52YWxpZGF0ZVBhcnRpY2lwYW50c0xpc3QoY291cnNlaWQpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmZXRjaFBhcnRpY2lwYW50cyh0cnVlKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMucGFydGljaXBhbnRzJylcblxuLyoqXG4gKiBQYXJ0aWNpcGFudHMgaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMucGFydGljaXBhbnRzXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYVBhcnRpY2lwYW50c0hhbmRsZXJzXG4gKi9cbi5mYWN0b3J5KCckbW1hUGFydGljaXBhbnRzSGFuZGxlcnMnLCBmdW5jdGlvbigkbW1hUGFydGljaXBhbnRzLCBtbUNvdXJzZXNBY2Nlc3NNZXRob2RzLCAkbW1VdGlsLCAkbW1Db250ZW50TGlua3NIZWxwZXIpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ291cnNlIG5hdiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucGFydGljaXBhbnRzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFQYXJ0aWNpcGFudHNIYW5kbGVycyNjb3Vyc2VzTmF2SGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYuY291cnNlc05hdkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBoYW5kbGVyIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGhhbmRsZXIgaXMgZW5hYmxlZCBmb3IgdGhpcyBjb3Vyc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCAgIENvdXJzZSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFjY2Vzc0RhdGEgVHlwZSBvZiBhY2Nlc3MgdG8gdGhlIGNvdXJzZTogZGVmYXVsdCwgZ3Vlc3QsIC4uLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufFByb21pc2V9ICBQcm9taXNlIHJlc29sdmVkICB3aXRoIHRydWUgaWYgaGFuZGxlciBpcyBlbmFibGVkLFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBvciBwcm9taXNlIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0VuYWJsZWRGb3JDb3Vyc2UgPSBmdW5jdGlvbihjb3Vyc2VJZCwgYWNjZXNzRGF0YSkge1xuICAgICAgICAgICAgaWYgKGFjY2Vzc0RhdGEgJiYgYWNjZXNzRGF0YS50eXBlID09IG1tQ291cnNlc0FjY2Vzc01ldGhvZHMuZ3Vlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vdCBlbmFibGVkIGZvciBndWVzdHMuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJG1tYVBhcnRpY2lwYW50cy5pc1BsdWdpbkVuYWJsZWRGb3JDb3Vyc2UoY291cnNlSWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3Vyc2VJZCBDb3Vyc2UgSUQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBDb250cm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24oY291cnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pY29uID0gJ2lvbi1wZXJzb24tc3RhbGtlcic7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ21tYS5wYXJ0aWNpcGFudHMucGFydGljaXBhbnRzJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gZnVuY3Rpb24oJGV2ZW50LCBjb3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzaXRlLnBhcnRpY2lwYW50cycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdXJzZTogY291cnNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGxpbmtzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wYXJ0aWNpcGFudHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVBhcnRpY2lwYW50c0hhbmRsZXJzI2xpbmtzSGFuZGxlclxuICAgICAqL1xuICAgIHNlbGYubGlua3NIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFjdGlvbnMgdG8gcGVyZm9ybSB3aXRoIHRoZSBsaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzaXRlSWRzIFNpdGUgSURzIHRoZSBVUkwgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAgICAgICBVUkwgdG8gdHJlYXQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgTGlzdCBvZiBhY3Rpb25zLiBTZWUge0BsaW5rICRtbUNvbnRlbnRMaW5rc0RlbGVnYXRlI3JlZ2lzdGVyTGlua0hhbmRsZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRBY3Rpb25zID0gZnVuY3Rpb24oc2l0ZUlkcywgdXJsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpdCdzIGEgdXNlciBVUkwuXG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJ2dyYWRlL3JlcG9ydC91c2VyJykgPT0gLTEgJiYgdXJsLmluZGV4T2YoJy91c2VyL2luZGV4LnBocCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gJG1tVXRpbC5leHRyYWN0VXJsUGFyYW1zKHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuaWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ21tLmNvcmUudmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnaW9uLWV5ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXRlczogc2l0ZUlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oc2l0ZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3Vyc2U6IHtpZDogcGFyc2VJbnQocGFyYW1zLmlkLCAxMCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW1Db250ZW50TGlua3NIZWxwZXIuZ29JblNpdGUoJ3NpdGUucGFydGljaXBhbnRzJywgc3RhdGVQYXJhbXMsIHNpdGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcbiIsIi8vIChDKSBDb3B5cmlnaHQgMjAxNSBNYXJ0aW4gRG91Z2lhbWFzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5hbmd1bGFyLm1vZHVsZSgnbW0uYWRkb25zLnBhcnRpY2lwYW50cycpXG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgY291cnNlIHBhcnRpY2lwYW50cy5cbiAqXG4gKiBAbW9kdWxlIG1tLmFkZG9ucy5wYXJ0aWNpcGFudHNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hUGFydGljaXBhbnRzXG4gKi9cbi5mYWN0b3J5KCckbW1hUGFydGljaXBhbnRzJywgZnVuY3Rpb24oJGxvZywgJG1tU2l0ZSwgJG1tVXNlciwgbW1hUGFydGljaXBhbnRzTGlzdExpbWl0KSB7XG5cbiAgICAkbG9nID0gJGxvZy5nZXRJbnN0YW5jZSgnJG1tYVBhcnRpY2lwYW50cycpO1xuXG4gICAgdmFyIHNlbGYgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBrZXkgZm9yIHBhcnRpY2lwYW50IGxpc3QgV1MgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIENhY2hlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQYXJ0aWNpcGFudHNMaXN0Q2FjaGVLZXkoY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICdtbWFQYXJ0aWNpcGFudHM6bGlzdDonK2NvdXJzZWlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBwYXJ0aWNpcGFudHMgZm9yIGEgY2VydGFpbiBjb3Vyc2UuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wYXJ0aWNpcGFudHNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVBhcnRpY2lwYW50cyNnZXRQYXJ0aWNpcGFudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY291cnNlaWQgICAgSUQgb2YgdGhlIGNvdXJzZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXRGcm9tICAgUG9zaXRpb24gb2YgdGhlIGZpcnN0IHBhcnRpY2lwYW50IHRvIGdldC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXROdW1iZXIgTnVtYmVyIG9mIHBhcnRpY2lwYW50cyB0byBnZXQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgIFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbiB0aGUgcGFydGljaXBhbnRzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgc2VsZi5nZXRQYXJ0aWNpcGFudHMgPSBmdW5jdGlvbihjb3Vyc2VpZCwgbGltaXRGcm9tLCBsaW1pdE51bWJlcikge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGltaXRGcm9tID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsaW1pdEZyb20gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGltaXROdW1iZXIgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxpbWl0TnVtYmVyID0gbW1hUGFydGljaXBhbnRzTGlzdExpbWl0O1xuICAgICAgICB9XG5cbiAgICAgICAgJGxvZy5kZWJ1ZygnR2V0IHBhcnRpY2lwYW50cyBmb3IgY291cnNlICcgKyBjb3Vyc2VpZCArICcgc3RhcnRpbmcgYXQgJyArIGxpbWl0RnJvbSk7XG5cbiAgICAgICAgdmFyIHdzTmFtZSxcbiAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgY291cnNlaWQ6IGNvdXJzZWlkXG4gICAgICAgICAgICB9LCBwcmVTZXRzID0ge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBnZXRQYXJ0aWNpcGFudHNMaXN0Q2FjaGVLZXkoY291cnNlaWQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICgkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX2Vucm9sX2dldF9lbnJvbGxlZF91c2VycycpKSB7XG4gICAgICAgICAgICB3c05hbWUgPSAnY29yZV9lbnJvbF9nZXRfZW5yb2xsZWRfdXNlcnMnO1xuICAgICAgICAgICAgZGF0YS5vcHRpb25zID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0ZnJvbScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsaW1pdEZyb21cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0bnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpbWl0TnVtYmVyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzb3J0YnknLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ3NpdGVvcmRlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3NOYW1lID0gJ21vb2RsZV9lbnJvbF9nZXRfZW5yb2xsZWRfdXNlcnMnO1xuICAgICAgICAgICAgbGltaXROdW1iZXIgPSA5OTk5OTk5OTk5OyAvLyBTZXQgYSBiaWcgbGltaXROdW1iZXIgc28gY2FuTG9hZE1vcmUgaXMgYWx3YXlzIGZhbHNlIChXUyBub3QgcGFnaW5hdGVkKS5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbW1TaXRlLnJlYWQod3NOYW1lLCBkYXRhLCBwcmVTZXRzKS50aGVuKGZ1bmN0aW9uKHVzZXJzKSB7XG4gICAgICAgICAgICAvLyBGb3JtYXQgdXNlciBkYXRhLCBtb29kbGVfZW5yb2xfZ2V0X2Vucm9sbGVkX3VzZXJzIHJldHVybnMgc29tZSBhdHRyaWJ1dGVzIHdpdGggYSBkaWZmZXJlbnQgbmFtZS5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlci5pZCA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdXNlci51c2VyaWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5pZCA9IHVzZXIudXNlcmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVzZXIucHJvZmlsZWltYWdldXJsID09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB1c2VyLnByb2ZpbGVpbWd1cmwgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5wcm9maWxlaW1hZ2V1cmwgPSB1c2VyLnByb2ZpbGVpbWd1cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBjYW5Mb2FkTW9yZSA9IHVzZXJzLmxlbmd0aCA+PSBsaW1pdE51bWJlcjtcbiAgICAgICAgICAgICRtbVVzZXIuc3RvcmVVc2Vycyh1c2Vycyk7XG4gICAgICAgICAgICByZXR1cm4ge3BhcnRpY2lwYW50czogdXNlcnMsIGNhbkxvYWRNb3JlOiBjYW5Mb2FkTW9yZX07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyBwYXJ0aWNpcGFudCBsaXN0IGZvciBhIGNlcnRhaW4gY291cnNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucGFydGljaXBhbnRzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFQYXJ0aWNpcGFudHMjaW52YWxpZGF0ZVBhcnRpY2lwYW50c0xpc3RcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvdXJzZWlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgbGlzdCBpcyBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICBzZWxmLmludmFsaWRhdGVQYXJ0aWNpcGFudHNMaXN0ID0gZnVuY3Rpb24oY291cnNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUuaW52YWxpZGF0ZVdzQ2FjaGVGb3JLZXkoZ2V0UGFydGljaXBhbnRzTGlzdENhY2hlS2V5KGNvdXJzZWlkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBhcnRpY2lwYW50cyBhZGRvbiBpcyBlbmFibGVkIGZvciBhIGNlcnRhaW4gY291cnNlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucGFydGljaXBhbnRzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFQYXJ0aWNpcGFudHMjaXNQbHVnaW5FbmFibGVkRm9yQ291cnNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdXJzZUlkIENvdXJzZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgUHJvbWlzZSByZXNvbHZlZCB3aXRoIHRydWUgaWYgcGx1Z2luIGlzIGVuYWJsZWQsIHJlamVjdGVkIG9yIHJlc29sdmVkIHdpdGggZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkRm9yQ291cnNlID0gZnVuY3Rpb24oY291cnNlSWQpIHtcbiAgICAgICAgaWYgKCFjb3Vyc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0cmlldmluZyBvbmUgcGFydGljaXBhbnQgd2lsbCBmYWlsIGlmIGJyb3dzaW5nIHVzZXJzIGlzIGRpc2FibGVkIGJ5IGNhcGFiaWxpdGllcy5cbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0UGFydGljaXBhbnRzKGNvdXJzZUlkLCAwLCAxKS50aGVuKGZ1bmN0aW9uKHBhcmNpdGlwYW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIiwiLy8gKEMpIENvcHlyaWdodCAyMDE1IE1hcnRpbiBEb3VnaWFtYXNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmFuZ3VsYXIubW9kdWxlKCdtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnMnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gaGFuZGxlIHB1c2ggbm90aWZpY2F0aW9ucyBjbGlja3MuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlXG4gKi9cbi5mYWN0b3J5KCckbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlJywgZnVuY3Rpb24oJGxvZykge1xuXG4gICAgJGxvZyA9ICRsb2cuZ2V0SW5zdGFuY2UoJyRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUnKTtcblxuICAgIHZhciBoYW5kbGVycyA9IHt9LFxuICAgICAgICBzZWxmID0ge307XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjYWxsZWQgd2hlbiBhIHB1c2ggbm90aWZpY2F0aW9uIGlzIGNsaWNrZWQuIFNlbmRzIG5vdGlmaWNhdGlvbiB0byBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnB1c2hub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbVB1c2hOb3RpZmljYXRpb25zRGVsZWdhdGUjY2xpY2tlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZmljYXRpb24gTm90aWZpY2F0aW9uIGNsaWNrZWQuXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBzZWxmLmNsaWNrZWQgPSBmdW5jdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoYW5kbGVycykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJlYXRlZCA9IGNhbGxiYWNrKG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTdG9wIGV4ZWN1dGlvbiB3aGVuIG5vdGlmaWNhdGlvbiBpcyB0cmVhdGVkLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHB1c2ggbm90aWZpY2F0aW9ucyBoYW5kbGVyLiBUaGUgaGFuZGxlciB3aWxsIHJlY2VpdmUgYSBub3RpZmljYXRpb24gdG8gdHJlYXQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9uc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlI3JlZ2lzdGVySGFuZGxlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICAgIEhhbmRsZXIncyBuYW1lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbi4gV2lsbCBnZXQgYXMgcGFyYW1ldGVyIHRoZSBVUkwgdG8gaGFuZGxlLlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoZSBoYW5kbGVyIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiB0aGUgbm90aWZpY2F0aW9uIGlzIHRoZSBvbmUgZXhwZWN0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAc2VlIHtAbGluayAkbW1QdXNoTm90aWZpY2F0aW9uc0RlbGVnYXRlI2NsaWNrZWR9XG4gICAgICovXG4gICAgc2VsZi5yZWdpc3RlckhhbmRsZXIgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAkbG9nLmRlYnVnKFwiUmVnaXN0ZXJlZCBoYW5kbGVyICdcIiArIG5hbWUgKyBcIicgYXMgcHVzaCBub3RpZmljYXRpb24gaGFuZGxlci5cIik7XG4gICAgICAgIGhhbmRsZXJzW25hbWVdID0gY2FsbGJhY2s7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9ucycpXG5cbi8qKlxuICogUHVzaCBub3RpZmljYXRpb25zIGZhY3RvcnkuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnNcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkbW1hUHVzaE5vdGlmaWNhdGlvbnNcbiAqL1xuLmZhY3RvcnkoJyRtbWFQdXNoTm90aWZpY2F0aW9ucycsIGZ1bmN0aW9uKCRtbVNpdGUsICRsb2csICRjb3Jkb3ZhUHVzaCwgJG1tVGV4dCwgJHEsICRjb3Jkb3ZhRGV2aWNlLCAkbW1VdGlsLCBtbUNvcmVDb25maWdDb25zdGFudHMsXG4gICAgICAgICAgICAkbW1BcHAsICRtbUxvY2FsTm90aWZpY2F0aW9ucywgJG1tUHVzaE5vdGlmaWNhdGlvbnNEZWxlZ2F0ZSwgJG1tU2l0ZXNNYW5hZ2VyLCBtbWFQdXNoTm90aWZpY2F0aW9uc0NvbXBvbmVudCkge1xuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hUHVzaE5vdGlmaWNhdGlvbnMnKTtcblxuICAgIHZhciBzZWxmID0ge30sXG4gICAgICAgIHB1c2hJRDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBpcyBlbmFibGVkIGZvciB0aGUgY3VycmVudCBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVB1c2hOb3RpZmljYXRpb25zI2lzUGx1Z2luRW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNlbGYuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkbW1TaXRlLndzQXZhaWxhYmxlKCdjb3JlX3VzZXJfYWRkX3VzZXJfZGV2aWNlJylcbiAgICAgICAgICAgICAgICAmJiAkbW1TaXRlLndzQXZhaWxhYmxlKCdtZXNzYWdlX2Fpcm5vdGlmaWVyX2lzX3N5c3RlbV9jb25maWd1cmVkJylcbiAgICAgICAgICAgICAgICAmJiAkbW1TaXRlLndzQXZhaWxhYmxlKCdtZXNzYWdlX2Fpcm5vdGlmaWVyX2FyZV9ub3RpZmljYXRpb25fcHJlZmVyZW5jZXNfY29uZmlndXJlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjYWxsZWQgd2hlbiBhIHB1c2ggbm90aWZpY2F0aW9uIGlzIGNsaWNrZWQuIFJlZGlyZWN0IHRoZSB1c2VyIHRvIHRoZSByaWdodCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnB1c2hub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFQdXNoTm90aWZpY2F0aW9ucyNub3RpZmljYXRpb25DbGlja2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgTm90aWZpY2F0aW9uIGRhdGEuXG4gICAgICovXG4gICAgc2VsZi5ub3RpZmljYXRpb25DbGlja2VkID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAkbW1BcHAucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJG1tUHVzaE5vdGlmaWNhdGlvbnNEZWxlZ2F0ZS5jbGlja2VkKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZnJvbSB0aGUgUHVzaFBsdWdpbiB3aGVuIHdlIHJlY2VpdmUgYSBOb3RpZmljYXRpb24gZnJvbSBHQ00uXG4gICAgICogVGhlIGFwcCBjYW4gYmUgaW4gZm9yZWdyb3VuZCBvciBiYWNrZ3JvdW5kLFxuICAgICAqIGlmIHdlIGFyZSBpbiBiYWNrZ3JvdW5kIHRoaXMgY29kZSBpcyBleGVjdXRlZCB3aGVuIHdlIG9wZW4gdGhlIGFwcCBjbGlja2luZyBpbiB0aGUgbm90aWZpY2F0aW9uIGJhci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnB1c2hub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFQdXNoTm90aWZpY2F0aW9ucyNvbkdDTVJlY2VpdmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vdGlmaWNhdGlvbiBOb3RpZmljYXRpb24gZGF0YS5cbiAgICAgKi9cbiAgICBzZWxmLm9uR0NNUmVjZWl2ZWQgPSBmdW5jdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnR0NNIG5vdGlmaWNhdGlvbiByZWNlaXZlZC4gVHlwZTogJytub3RpZmljYXRpb24uZXZlbnQpO1xuXG4gICAgICAgIHN3aXRjaCAobm90aWZpY2F0aW9uLmV2ZW50KSB7XG4gICAgICAgICAgICBjYXNlICdyZWdpc3RlcmVkJzpcbiAgICAgICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uLnJlZ2lkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaElEID0gbm90aWZpY2F0aW9uLnJlZ2lkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yZWdpc3RlckRldmljZU9uTW9vZGxlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRGV2aWNlIE5PVCByZWdpc3RlcmVkIGluIEdDTSwgaW52YWxpZCByZWdpZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5wYXlsb2FkLmZvcmVncm91bmQgPSBub3RpZmljYXRpb24uZm9yZWdyb3VuZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5vbk1lc3NhZ2VSZWNlaXZlZChub3RpZmljYXRpb24ucGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdQdXNoIG1lc3NhZ2VzIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnUHVzaCB1bmtub3duIG1lc3NhZ2UnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHdlIHJlY2VpdmUgYSBOb3RpZmljYXRpb24gZnJvbSBBUE5TIG9yIGEgbWVzc2FnZSBub3RpZmljYXRpb24gZnJvbSBHQ00uXG4gICAgICogVGhlIGFwcCBjYW4gYmUgaW4gZm9yZWdyb3VuZCBvciBiYWNrZ3JvdW5kLFxuICAgICAqIGlmIHdlIGFyZSBpbiBiYWNrZ3JvdW5kIHRoaXMgY29kZSBpcyBleGVjdXRlZCB3aGVuIHdlIG9wZW4gdGhlIGFwcCBjbGlja2luZyBpbiB0aGUgbm90aWZpY2F0aW9uIGJhci5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnB1c2hub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFQdXNoTm90aWZpY2F0aW9ucyNvbk1lc3NhZ2VSZWNlaXZlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIE5vdGlmaWNhdGlvbiBkYXRhLlxuICAgICAqL1xuICAgIHNlbGYub25NZXNzYWdlUmVjZWl2ZWQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEuc2l0ZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9ICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKGRhdGEuc2l0ZSk7IC8vIENoZWNrIGlmIHNpdGUgZXhpc3RzLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oKTsgLy8gTm8gc2l0ZSBzcGVjaWZpZWQsIHJlc29sdmUuXG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJG1tVXRpbC5pc1RydWVPck9uZShkYXRhLmZvcmVncm91bmQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFwcCBpcyBpbiBmb3JlZ3JvdW5kIHdoZW4gdGhlIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZCwgaXQncyBub3Qgc2hvd24uIExldCdzIHNob3cgaXQgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIGlmICgkbW1Mb2NhbE5vdGlmaWNhdGlvbnMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBmb3JtYXRUZXh0IHRvIHRpdGxlIGFuZCBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAkbW1UZXh0LmZvcm1hdFRleHQoZGF0YS50aXRsZSwgdHJ1ZSwgdHJ1ZSkudGhlbihmdW5jdGlvbihmb3JtYXR0ZWRUaXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1tVGV4dC5mb3JtYXRUZXh0KGRhdGEubWVzc2FnZSwgdHJ1ZSwgdHJ1ZSkudGhlbihmdW5jdGlvbihmb3JtYXR0ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsTm90aWYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogZm9ybWF0dGVkVGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZvcm1hdHRlZE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWFsbEljb246ICdyZXM6Ly9pY29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWY6IGRhdGEubm90aWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXRlOiBkYXRhLnNpdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG1tTG9jYWxOb3RpZmljYXRpb25zLnNjaGVkdWxlKGxvY2FsTm90aWYsIG1tYVB1c2hOb3RpZmljYXRpb25zQ29tcG9uZW50LCBkYXRhLnNpdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ub3RpZmljYXRpb25DbGlja2VkKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBkZXZpY2UgaW4gQXBwbGUgQVBOUyBvciBHb29nbGUgR0NNLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVB1c2hOb3RpZmljYXRpb25zI3JlZ2lzdGVyRGV2aWNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBkZXZpY2UgaXMgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBzZWxmLnJlZ2lzdGVyRGV2aWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZWdpc3RlckRldmljZUFQTlMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcmVnaXN0ZXJEZXZpY2VHQ00oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChleCkge31cblxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgZGV2aWNlIGluIEFwcGxlIEFQTlMgKEFwcGxlIFB1c2ggTm90aWZpY2FpdG9uIFN5c3RlbSkgdXNpbmcgdGhlIFBob25lZ2FwIFB1c2hQbHVnaW4uXG4gICAgICogSXQgYWxzbyByZWdpc3RlcnMgdGhlIGRldmljZSBpbiB0aGUgTW9vZGxlIHNpdGUgdXNpbmcgdGhlIGNvcmVfdXNlcl9hZGRfdXNlcl9kZXZpY2UgV2ViU2VydmljZS5cbiAgICAgKiBXZSBuZWVkIHRoZSBkZXZpY2UgcmVnaXN0ZXJlZCBpbiBNb29kbGUgc28gd2UgY2FuIGNvbm5lY3QgdGhlIGRldmljZSB3aXRoIHRoZSBtZXNzYWdlIG91dHB1dCBNb29kZSBwbHVnaW4gYWlybm90aWZpZXIuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9uc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hUHVzaE5vdGlmaWNhdGlvbnMjX3JlZ2lzdGVyRGV2aWNlQVBOU1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZGV2aWNlIGlzIHJlZ2lzdGVyZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbGYuX3JlZ2lzdGVyRGV2aWNlQVBOUyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFsZXJ0OiAndHJ1ZScsXG4gICAgICAgICAgICBiYWRnZTogJ3RydWUnLFxuICAgICAgICAgICAgc291bmQ6ICd0cnVlJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJGNvcmRvdmFQdXNoLnJlZ2lzdGVyKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgIHB1c2hJRCA9IHRva2VuO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYucmVnaXN0ZXJEZXZpY2VPbk1vb2RsZSgpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBkZXZpY2UgaW4gR29vZ2xlIEdDTSB1c2luZyB0aGUgUGhvbmVnYXAgUHVzaFBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnB1c2hub3RpZmljYXRpb25zXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFQdXNoTm90aWZpY2F0aW9ucyNfcmVnaXN0ZXJEZXZpY2VHQ01cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRldmljZSBpcyByZWdpc3RlcmVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxmLl9yZWdpc3RlckRldmljZUdDTSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobW1Db3JlQ29uZmlnQ29uc3RhbnRzLmdjbXBuKSB7XG4gICAgICAgICAgICByZXR1cm4gJGNvcmRvdmFQdXNoLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICBzZW5kZXJJRDogbW1Db3JlQ29uZmlnQ29uc3RhbnRzLmdjbXBuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGRldmljZSBvbiBjdXJyZW50IE1vb2RsZSBzaXRlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucHVzaG5vdGlmaWNhdGlvbnNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVB1c2hOb3RpZmljYXRpb25zI3JlZ2lzdGVyRGV2aWNlT25Nb29kbGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2hlbiBkZXZpY2UgaXMgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBzZWxmLnJlZ2lzdGVyRGV2aWNlT25Nb29kbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJGxvZy5kZWJ1ZygnUmVnaXN0ZXIgZGV2aWNlIG9uIE1vb2RsZS4nKTtcblxuICAgICAgICBpZiAoISRtbVNpdGUuaXNMb2dnZWRJbigpIHx8ICFwdXNoSUQgfHwgISRtbUFwcC5pc0RldmljZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGFwcGlkOiAgICAgIG1tQ29yZUNvbmZpZ0NvbnN0YW50cy5hcHBfaWQsXG4gICAgICAgICAgICBuYW1lOiAgICAgICBpb25pYy5QbGF0Zm9ybS5kZXZpY2UoKS5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgbW9kZWw6ICAgICAgJGNvcmRvdmFEZXZpY2UuZ2V0TW9kZWwoKSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiAgICRjb3Jkb3ZhRGV2aWNlLmdldFBsYXRmb3JtKCksXG4gICAgICAgICAgICB2ZXJzaW9uOiAgICAkY29yZG92YURldmljZS5nZXRWZXJzaW9uKCksXG4gICAgICAgICAgICBwdXNoaWQ6ICAgICBwdXNoSUQsXG4gICAgICAgICAgICB1dWlkOiAgICAgICAkY29yZG92YURldmljZS5nZXRVVUlEKClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRtbVNpdGUud3JpdGUoJ2NvcmVfdXNlcl9hZGRfdXNlcl9kZXZpY2UnLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgYSBkZXZpY2UgZnJvbSBhIGNlcnRhaW4gTW9vZGxlIHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5wdXNobm90aWZpY2F0aW9uc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hUHVzaE5vdGlmaWNhdGlvbnMjdW5yZWdpc3RlckRldmljZU9uTW9vZGxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpdGUgU2l0ZSB0byB1bnJlZ2lzdGVyIGZyb20uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgUHJvbWlzZSByZXNvbHZlZCB3aGVuIGRldmljZSBpcyB1bnJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgc2VsZi51bnJlZ2lzdGVyRGV2aWNlT25Nb29kbGUgPSBmdW5jdGlvbihzaXRlKSB7XG5cbiAgICAgICAgaWYgKCFzaXRlIHx8ICEkbW1BcHAuaXNEZXZpY2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgJGxvZy5kZWJ1ZygnVW5yZWdpc3RlciBkZXZpY2Ugb24gTW9vZGxlOiAnICsgc2l0ZS5pZCk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBhcHBpZDogbW1Db3JlQ29uZmlnQ29uc3RhbnRzLmFwcF9pZCxcbiAgICAgICAgICAgIHV1aWQ6ICAkY29yZG92YURldmljZS5nZXRVVUlEKClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNpdGUud3JpdGUoJ2NvcmVfdXNlcl9yZW1vdmVfdXNlcl9kZXZpY2UnLCBkYXRhKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8wqAhcmVzcG9uc2UucmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xufSk7XG4iLCIvLyAoQykgQ29weXJpZ2h0IDIwMTUgTWFydGluIERvdWdpYW1hc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuYW5ndWxhci5tb2R1bGUoJ21tLmFkZG9ucy5yZW1vdGVzdHlsZXMnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gaGFuZGxlIHJlbW90ZSBzdHlsZXMuXG4gKlxuICogQG1vZHVsZSBtbS5hZGRvbnMucmVtb3Rlc3R5bGVzXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJG1tYVJlbW90ZVN0eWxlc1xuICovXG4uZmFjdG9yeSgnJG1tYVJlbW90ZVN0eWxlcycsIGZ1bmN0aW9uKCRsb2csICRxLCAkbW1TaXRlLCAkbW1TaXRlc01hbmFnZXIsICRtbUZpbGVwb29sLCAkaHR0cCwgJG1tRlMsIG1tYVJlbW90ZVN0eWxlc0NvbXBvbmVudCxcbiAgICAgICAgICAgIG1tQ29yZU5vdERvd25sb2FkZWQpIHtcblxuICAgICRsb2cgPSAkbG9nLmdldEluc3RhbmNlKCckbW1hUmVtb3RlU3R5bGVzJyk7XG5cbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICByZW1vdGVTdHlsZXNFbCA9IGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbW9iaWxlY3NzdXJsJykpO1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgcmVtb3RlIHN0eWxlcyBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBtbS5hZGRvbnMucmVtb3Rlc3R5bGVzXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lICRtbWFSZW1vdGVTdHlsZXMjY2xlYXJcbiAgICAgKi9cbiAgICBzZWxmLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbW90ZVN0eWxlc0VsLmh0bWwoJycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVtb3RlIHN0eWxlcyBvZiBhIGNlcnRhaW4gc2l0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgbW0uYWRkb25zLnJlbW90ZXN0eWxlc1xuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSAkbW1hUmVtb3RlU3R5bGVzI2dldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXRlaWQgU2l0ZSBJRC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgIFByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgc3R5bGVzLlxuICAgICAqL1xuICAgIHNlbGYuZ2V0ID0gZnVuY3Rpb24oc2l0ZWlkKSB7XG4gICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgIHNpdGVpZCA9IHNpdGVpZCB8fCAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIGlmICghc2l0ZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb3dubG9hZHMgYSBDU1MgZmlsZSBhbmQgcmVtb3ZlIG9sZCBmaWxlcyBpZiBuZWVkZWQuXG4gICAgICAgIGZ1bmN0aW9uIGRvd25sb2FkRmlsZUFuZFJlbW92ZU9sZCh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiAkbW1GaWxlcG9vbC5nZXRGaWxlU3RhdGVCeVVybChzaXRlaWQsIHVybCkudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSAhPT0gbW1Db3JlTm90RG93bmxvYWRlZDtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBnZXR0aW5nIHN0YXRlIChzaG91bGRuJ3QgaGFwcGVuKS4gRG9uJ3QgZGVsZXRlIGRvd25sb2FkZWQgZmlsZS5cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oaXNEb3dubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Rvd25sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsZSBub3QgZG93bmxvYWRlZCwgVVJMIGhhcyBjaGFuZ2VkIG9yIGZpcnN0IHRpbWUuIERlbGV0ZSBkb3dubG9hZGVkIENTUyBmaWxlcy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLnJlbW92ZUZpbGVzQnlDb21wb25lbnQoc2l0ZWlkLCBtbWFSZW1vdGVTdHlsZXNDb21wb25lbnQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtbUZpbGVwb29sLmRvd25sb2FkVXJsKHNpdGVpZCwgdXJsLCBmYWxzZSwgbW1hUmVtb3RlU3R5bGVzQ29tcG9uZW50LCAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRtbVNpdGVzTWFuYWdlci5nZXRTaXRlKHNpdGVpZCkudGhlbihmdW5jdGlvbihzaXRlKSB7XG4gICAgICAgICAgICB2YXIgaW5mb3MgPSBzaXRlLmdldEluZm8oKTtcbiAgICAgICAgICAgIGlmIChpbmZvcyAmJiBpbmZvcy5tb2JpbGVjc3N1cmwpIHtcbiAgICAgICAgICAgICAgICBpZiAoJG1tRlMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSBzeXN0ZW0gaXMgYXZhaWxhYmxlLiBEb3dubG9hZCB0aGUgZmlsZSBhbmQgcmVtb3ZlIG9sZCBDU1MgZmlsZXMgaWYgbmVlZGVkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93bmxvYWRGaWxlQW5kUmVtb3ZlT2xkKGluZm9zLm1vYmlsZWNzc3VybCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcmV0dXJuIHRoZSBvbmxpbmUgVVJMLiBXZSdyZSBwcm9iYWJseSBvbiBicm93c2VyLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5mb3MubW9iaWxlY3NzdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm9zLm1vYmlsZWNzc3VybCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NTIFVSTCBpcyBlbXB0eS4gRGVsZXRlIGRvd25sb2FkZWQgZmlsZXMgKGlmIGFueSkuXG4gICAgICAgICAgICAgICAgICAgICRtbUZpbGVwb29sLnJlbW92ZUZpbGVzQnlDb21wb25lbnQoc2l0ZWlkLCBtbWFSZW1vdGVTdHlsZXNDb21wb25lbnQsIDEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0xvYWRpbmcgc3R5bGVzIGZyb206ICcrdXJsKTtcbiAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQodXJsKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5kYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvYWQgc3R5bGVzIGZvciBjdXJyZW50IHNpdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIG1tLmFkZG9ucy5yZW1vdGVzdHlsZXNcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgJG1tYVJlbW90ZVN0eWxlcyNsb2FkXG4gICAgICovXG4gICAgc2VsZi5sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaXRlaWQgPSAkbW1TaXRlLmdldElkKCk7XG4gICAgICAgIGlmIChzaXRlaWQpIHtcbiAgICAgICAgICAgIHNlbGYuZ2V0KHNpdGVpZCkudGhlbihmdW5jdGlvbihzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2l0ZWlkID09PSAkbW1TaXRlLmdldElkKCkpIHsgLy8gTWFrZSBzdXJlIGl0IGhhc24ndCBsb2dvdXQgd2hpbGUgcmV0cmlldmluZyBzdHlsZXMuXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0eWxlc0VsLmh0bWwoc3R5bGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9

angular.module('mm.core')

.constant('mmCoreConfigConstants', {
    "app_id" : "uk.ac.bbk.moodle",
    "versioncode" : "2009",
    "versionname" : "0.0.18",
    "cache_expiration_time" : 300000,
    "default_lang" : "en",
    "languages": {"ar": "عربي", "bg": "Български", "ca": "Català", "cs": "Čeština", "de": "Deutsch","en": "English", "es": "Español", "es-mx": "Español - México", "eu": "Euskara", "fa": "فارسی", "fr" : "Français", "he" : "עברית", "hu": "magyar", "it": "Italiano", "ja": "日本語","nl": "Nederlands", "pl": "Polski", "pt-br": "Português - Brasil", "ru": "Русский", "sv": "Svenska", "tr" : "Türkçe", "zh-cn" : "简体中文", "zh-tw" : "正體中文"},
    "wsservice" : "moodle_mobile_app",
    "wsextservice" : "local_mobile",
    "gcmpn": "694767596569"
}
);